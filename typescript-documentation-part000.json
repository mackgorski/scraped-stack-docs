[
  {
    "url": "https://www.typescriptlang.org/docs/handbook/",
    "markdown": "# The starting point for learning TypeScript\n\n#### Get Started\n\nQuick introductions based on your background or preference.\n\n*   [TS for the New Programmer](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)\n*   [TypeScript for JS Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)\n*   [TS for Java/C# Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html)\n*   [TS for Functional Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)\n*   [TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)\n\n#### Handbook\n\nA great first read for your daily TS work.\n\n*   [The TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)\n*   [The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)\n*   [Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)\n*   [Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)\n*   [More on Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)\n*   [Object Types](https://www.typescriptlang.org/docs/handbook/2/objects.html)\n*   [Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)\n*   [Modules](https://www.typescriptlang.org/docs/handbook/2/modules.html)\n\n#### Reference\n\nDeep dive reference materials.\n\n*   [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)\n*   [Cheat Sheets](https://www.typescriptlang.org/cheatsheets/)\n*   [Decorators](https://www.typescriptlang.org/docs/handbook/decorators.html)\n*   [Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)\n*   [Enums](https://www.typescriptlang.org/docs/handbook/enums.html)\n*   [Iterators and Generators](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html)\n*   [JSX](https://www.typescriptlang.org/docs/handbook/jsx.html)\n*   [Mixins](https://www.typescriptlang.org/docs/handbook/mixins.html)\n*   [Namespaces](https://www.typescriptlang.org/docs/handbook/namespaces.html)\n*   [Namespaces and Modules](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html)\n*   [Symbols](https://www.typescriptlang.org/docs/handbook/symbols.html)\n*   [Triple-Slash Directives](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html)\n*   [Type Compatibility](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)\n*   [Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)\n*   [Variable Declaration](https://www.typescriptlang.org/docs/handbook/variable-declarations.html)\n\n#### Modules Reference\n\nHow TypeScript models JavaScript modules.\n\n*   [Introduction](https://www.typescriptlang.org/docs/handbook/modules/introduction.html)\n*   [Theory](https://www.typescriptlang.org/docs/handbook/modules/theory.html)\n*   [Reference](https://www.typescriptlang.org/docs/handbook/modules/reference.html)\n\n#### Tutorials\n\nUsing TypeScript in several environments.\n\n*   [ASP.NET Core](https://www.typescriptlang.org/docs/handbook/asp-net-core.html)\n*   [Gulp](https://www.typescriptlang.org/docs/handbook/gulp.html)\n*   [DOM Manipulation](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html)\n*   [Migrating from JavaScript](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html)\n*   [Using Babel with TypeScript](https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html)\n\n#### Declaration Files\n\nLearn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.\n\n*   [Introduction](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)\n*   [Declaration Reference](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)\n*   [Library Structures](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html)\n*   [Do's and Don'ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)\n*   [Deep Dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)\n*   [Publishing](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)\n*   [Consumption](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html)\n\n#### JavaScript\n\nHow to use TypeScript-powered JavaScript tooling.\n\n*   [JS Projects Utilizing TypeScript](https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html)\n*   [Type Checking JavaScript Files](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)\n*   [JSDoc Reference](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n*   [Creating .d.ts Files from .js files](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html)\n\n#### Project Configuration\n\nCompiler configuration reference.\n\n*   [What is a tsconfig.json](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n*   [Compiler Options in MSBuild](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html)\n*   [TSConfig Reference](https://www.typescriptlang.org/tsconfig/)\n*   [tsc CLI Options](https://www.typescriptlang.org/docs/handbook/compiler-options.html)\n*   [Project References](https://www.typescriptlang.org/docs/handbook/project-references.html)\n*   [Integrating with Build Tools](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html)\n*   [Configuring Watch](https://www.typescriptlang.org/docs/handbook/configuring-watch.html)\n*   [Nightly Builds](https://www.typescriptlang.org/docs/handbook/nightly-builds.html)",
    "title": "TypeScript: The starting point for learning TypeScript",
    "description": "Find TypeScript starter projects: from Angular to React or Node.js and CLIs.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/configuring-watch.html",
    "markdown": "# TypeScript: Documentation - Configuring Watch\n\nAs of TypeScript 3.8 and onward, the Typescript compiler exposes configuration which controls how it watches files and directories. Prior to this version, configuration required the use of environment variables which are still available.\n\n## [](#background)Background\n\nThe `--watch` implementation of the compiler relies on Node’s `fs.watch` and `fs.watchFile`. Each of these methods has pros and cons.\n\n`fs.watch` relies on file system events to broadcast changes in the watched files and directories. The implementation of this command is OS dependent and unreliable - on many operating systems, it does not work as expected. Additionally, some operating systems limit the number of watches which can exist simultaneously (e.g. some flavors of [Linux](https://man7.org/linux/man-pages/man7/inotify.7.html)). Heavy use of `fs.watch` in large codebases has the potential to exceed these limits and result in undesirable behavior. However, because this implementation relies on an events-based model, CPU use is comparatively light. The compiler typically uses `fs.watch` to watch directories (e.g. source directories included by compiler configuration files and directories in which module resolution failed, among others). TypeScript uses these to augment potential failures in individual file watchers. However, there is a key limitation of this strategy: recursive watching of directories is supported on Windows and macOS, but not on Linux. This suggested a need for additional strategies for file and directory watching.\n\n`fs.watchFile` uses polling and thus costs CPU cycles. However, `fs.watchFile` is by far the most reliable mechanism available to subscribe to the events from files and directories of interest. Under this strategy, the TypeScript compiler typically uses `fs.watchFile` to watch source files, config files, and files which appear missing based on reference statements. This means that the degree to which CPU usage will be higher when using `fs.watchFile` depends directly on number of files watched in the codebase.\n\n## [](#configuring-file-watching-using-a-tsconfigjson)Configuring file watching using a `tsconfig.json`\n\nThe suggested method of configuring watch behavior is through the new `watchOptions` section of `tsconfig.json`. We provide an example configuration below. See the following section for detailed descriptions of the settings available.\n\n`{`\n\n  `// Some typical compiler options`\n\n  `\"\": {`\n\n    `\"\": \"es2020\",`\n\n    `\"\": \"node\"`\n\n    `// ...`\n\n  `},`\n\n  `// NEW: Options for file/directory watching`\n\n  `\"watchOptions\": {`\n\n    `// Use native file system events for files and directories`\n\n    `\"\": \"useFsEvents\",`\n\n    `\"\": \"useFsEvents\",`\n\n    `// Poll files for updates more frequently`\n\n    `// when they're updated a lot.`\n\n    `\"\": \"dynamicPriority\",`\n\n    `// Don't coalesce watch notification`\n\n    `\"\": true,`\n\n    `// Finally, two additional settings for reducing the amount of possible`\n\n    `// files to track  work from these directories`\n\n    `\"\": [\"**/node_modules\", \"_build\"],`\n\n    `\"\": [\"build/fileWhichChangesOften.ts\"]`\n\n  `}`\n\n`}`\n\nFor further details, see [the release notes for Typescript 3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions).\n\n## [](#configuring-file-watching-using-environment-variable-tsc_watchfile)Configuring file watching using environment variable `TSC_WATCHFILE`\n\n| Option | Description |\n| --- | --- |\n| `PriorityPollingInterval` | Use `fs.watchFile`, but use different polling intervals for source files, config files and missing files |\n| `DynamicPriorityPolling` | Use a dynamic queue where frequently modified files are polled at shorter intervals, and unchanged files are polled less frequently |\n| `UseFsEvents` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to `fs.watchFile` when a watcher fails to be created. |\n| `UseFsEventsWithFallbackDynamicPolling` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to dynamic polling queues (as explained in `DynamicPriorityPolling`) |\n| `UseFsEventsOnParentDirectory` | Use `fs.watch` on the _parent_ directories of included files (yielding a compromise that results in lower CPU usage than pure `fs.watchFile` but potentially lower accuracy). |\n| default (no value specified) | If environment variable `TSC_NONPOLLING_WATCHER` is set to true, use `UseFsEventsOnParentDirectory`. Otherwise, watch files using `fs.watchFile` with `250ms` as the timeout for any file. |\n\n## [](#configuring-directory-watching-using-environment-variable-tsc_watchdirectory)Configuring directory watching using environment variable `TSC_WATCHDIRECTORY`\n\nFor directory watches on platforms which don’t natively allow recursive directory watching (i.e. non macOS and Windows operating systems) is supported through recursively creating directory watchers for each child directory using different options selected by `TSC_WATCHDIRECTORY`.\n\n**NOTE:** On platforms which support native recursive directory watching, the value of `TSC_WATCHDIRECTORY` is ignored.\n\n| Option | Description |\n| --- | --- |\n| `RecursiveDirectoryUsingFsWatchFile` | Use `fs.watchFile` to watch included directories and child directories. |\n| `RecursiveDirectoryUsingDynamicPriorityPolling` | Use a dynamic polling queue to poll changes to included directories and child directories. |\n| default (no value specified) | Use `fs.watch` to watch included directories and child directories. |",
    "title": "TypeScript: Documentation - Configuring Watch",
    "description": "How to configure the watch mode of TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/nightly-builds.html",
    "markdown": "# TypeScript: Documentation - Nightly Builds\n\nA nightly build from the [TypeScript’s `main`](https://github.com/Microsoft/TypeScript/tree/main) branch is published by midnight PST to npm. Here is how you can get it and use it with your tools.\n\n## [](#using-npm)Using npm\n\nshell\n\n`npm install -D typescript@next`\n\n## [](#updating-your-ide-to-use-the-nightly-builds)Updating your IDE to use the nightly builds\n\nYou can also update your editor/IDE to use the nightly drop. You will typically need to install the package through npm. The rest of this section mostly assumes `typescript@next` is already installed.\n\n### [](#visual-studio-code)Visual Studio Code\n\nThe VS Code website [has documentation on selecting a workspace version of TypeScript](https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions). After installing a nightly version of TypeScript in your workspace, you can follow directions there, or simply update your workspace settings in the JSON view. A direct way to do this is to open or create your workspace’s `.vscode/settings.json` and add the following property:\n\njson\n\n`\"typescript.tsdk\": \"<path to your folder>/node_modules/typescript/lib\"`\n\nAlternatively, if you simply want to run the nightly editing experience for JavaScript and TypeScript in Visual Studio Code without changing your workspace version, you can run the [JavaScript and TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName%253Dms-vscode.vscode-typescript-next)\n\n### [](#sublime-text)Sublime Text\n\nUpdate the `Settings - User` file with the following:\n\njson\n\n`\"typescript_tsdk\": \"<path to your folder>/node_modules/typescript/lib\"`\n\nMore information is available at the [TypeScript Plugin for Sublime Text installation documentation](https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation).\n\n### [](#visual-studio-2013-and-2015)Visual Studio 2013 and 2015\n\n> Note: Most changes do not require you to install a new version of the VS TypeScript plugin.\n\nThe nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.\n\n1.  Download the [VSDevMode.ps1](https://github.com/Microsoft/TypeScript/blob/main/scripts/VSDevMode.ps1) script.\n    \n    > Also see our wiki page on [using a custom language service file](https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file).\n    \n2.  From a PowerShell command window, run:\n    \n\nFor VS 2015:\n\n`VSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib`\n\nFor VS 2013:\n\n`VSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib`\n\n### [](#intellij-idea-mac)IntelliJ IDEA (Mac)\n\nGo to `Preferences` > `Languages & Frameworks` > `TypeScript`:\n\n> TypeScript Version: If you installed with npm: `/usr/local/lib/node_modules/typescript/lib`\n\n### [](#intellij-idea-windows)IntelliJ IDEA (Windows)\n\nGo to `File` > `Settings` > `Languages & Frameworks` > `TypeScript`:\n\n> TypeScript Version: If you installed with npm: `C:\\Users\\USERNAME\\AppData\\Roaming\\npm\\node_modules\\typescript\\lib`",
    "title": "TypeScript: Documentation - Nightly Builds",
    "description": "How to use a nightly build of TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html",
    "markdown": "# TypeScript: Documentation - Integrating with Build Tools\n\n## [](#babel)Babel\n\n### [](#install)Install\n\nsh\n\n`npm install @babel/cli @babel/core @babel/preset-typescript --save-dev`\n\n### [](#babelrc).babelrc\n\njs\n\n`{`\n\n  `\"presets\": [\"@babel/preset-typescript\"]`\n\n`}`\n\n### [](#using-command-line-interface)Using Command Line Interface\n\nsh\n\n`./node_modules/.bin/babel --out-file bundle.js src/index.ts`\n\n### [](#packagejson)package.json\n\njs\n\n`{`\n\n  `\"scripts\": {`\n\n    `\"build\": \"babel --out-file bundle.js main.ts\"`\n\n  `},`\n\n`}`\n\n### [](#execute-babel-from-the-command-line)Execute Babel from the command line\n\nsh\n\n`npm run build`\n\n## [](#browserify)Browserify\n\n### [](#install-1)Install\n\nsh\n\n`npm install tsify`\n\n### [](#using-command-line-interface-1)Using Command Line Interface\n\nsh\n\n`browserify main.ts -p [ tsify --noImplicitAny ] > bundle.js`\n\n### [](#using-api)Using API\n\njs\n\n`var browserify = require(\"browserify\");`\n\n`var tsify = require(\"tsify\");`\n\n`browserify()`\n\n  `.add(\"main.ts\")`\n\n  `.plugin(\"tsify\", { noImplicitAny: true })`\n\n  `.bundle()`\n\n  `.pipe(process.stdout);`\n\nMore details: [smrq/tsify](https://github.com/smrq/tsify)\n\n## [](#grunt)Grunt\n\n### [](#using-grunt-ts-no-longer-maintained)Using `grunt-ts` (no longer maintained)\n\n#### [](#install-2)Install\n\nsh\n\n`npm install grunt-ts --save-dev`\n\n#### [](#basic-gruntfilejs)Basic Gruntfile.js\n\njs\n\n`module.exports = function (grunt) {`\n\n  `grunt.initConfig({`\n\n    `ts: {`\n\n      `default: {`\n\n        `src: [\"**/*.ts\", \"!node_modules/**/*.ts\"],`\n\n      `},`\n\n    `},`\n\n  `});`\n\n  `grunt.loadNpmTasks(\"grunt-ts\");`\n\n  `grunt.registerTask(\"default\", [\"ts\"]);`\n\n`};`\n\nMore details: [TypeStrong/grunt-ts](https://github.com/TypeStrong/grunt-ts)\n\n### [](#using-grunt-browserify-combined-with-tsify)Using `grunt-browserify` combined with `tsify`\n\n#### [](#install-3)Install\n\nsh\n\n`npm install grunt-browserify tsify --save-dev`\n\n#### [](#basic-gruntfilejs-1)Basic Gruntfile.js\n\njs\n\n`module.exports = function (grunt) {`\n\n  `grunt.initConfig({`\n\n    `browserify: {`\n\n      `all: {`\n\n        `src: \"src/main.ts\",`\n\n        `dest: \"dist/main.js\",`\n\n        `options: {`\n\n          `plugin: [\"tsify\"],`\n\n        `},`\n\n      `},`\n\n    `},`\n\n  `});`\n\n  `grunt.loadNpmTasks(\"grunt-browserify\");`\n\n  `grunt.registerTask(\"default\", [\"browserify\"]);`\n\n`};`\n\nMore details: [jmreidy/grunt-browserify](https://github.com/jmreidy/grunt-browserify), [TypeStrong/tsify](https://github.com/TypeStrong/tsify)\n\n## [](#gulp)Gulp\n\n### [](#install-4)Install\n\nsh\n\n`npm install gulp-typescript`\n\n### [](#basic-gulpfilejs)Basic gulpfile.js\n\njs\n\n`var gulp = require(\"gulp\");`\n\n`var ts = require(\"gulp-typescript\");`\n\n`gulp.task(\"default\", function () {`\n\n  `var tsResult = gulp.src(\"src/*.ts\").pipe(`\n\n    `ts({`\n\n      `noImplicitAny: true,`\n\n      `out: \"output.js\",`\n\n    `})`\n\n  `);`\n\n  `return tsResult.js.pipe(gulp.dest(\"built/local\"));`\n\n`});`\n\nMore details: [ivogabe/gulp-typescript](https://github.com/ivogabe/gulp-typescript)\n\n## [](#jspm)Jspm\n\n### [](#install-5)Install\n\nsh\n\n`npm install -g jspm@beta`\n\n_Note: Currently TypeScript support in jspm is in 0.16beta_\n\nMore details: [TypeScriptSamples/jspm](https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm)\n\n## [](#msbuild)MSBuild\n\nUpdate project file to include locally installed `Microsoft.TypeScript.Default.props` (at the top) and `Microsoft.TypeScript.targets` (at the bottom) files:\n\nxml\n\n`<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n\n`<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">`\n\n  `<!-- Include default props at the top -->`\n\n  `<Import`\n\n      `Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\"`\n\n      `Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\" />`\n\n  `<!-- TypeScript configurations go here -->`\n\n  `<PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">`\n\n    `<TypeScriptRemoveComments>false</TypeScriptRemoveComments>`\n\n    `<TypeScriptSourceMap>true</TypeScriptSourceMap>`\n\n  `</PropertyGroup>`\n\n  `<PropertyGroup Condition=\"'$(Configuration)' == 'Release'\">`\n\n    `<TypeScriptRemoveComments>true</TypeScriptRemoveComments>`\n\n    `<TypeScriptSourceMap>false</TypeScriptSourceMap>`\n\n  `</PropertyGroup>`\n\n  `<!-- Include default targets at the bottom -->`\n\n  `<Import`\n\n      `Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"`\n\n      `Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />`\n\n`</Project>`\n\nMore details about defining MSBuild compiler options: [Setting Compiler Options in MSBuild projects](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html)\n\n## [](#nuget)NuGet\n\n*   Right-Click -> Manage NuGet Packages\n*   Search for `Microsoft.TypeScript.MSBuild`\n*   Hit `Install`\n*   When install is complete, rebuild!\n\nMore details can be found at [Package Manager Dialog](http://docs.nuget.org/Consume/Package-Manager-Dialog) and [using nightly builds with NuGet](https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild)\n\n## [](#rollup)Rollup\n\n### [](#install-6)Install\n\n`npm install @rollup/plugin-typescript --save-dev`\n\nNote that both `typescript` and `tslib` are peer dependencies of this plugin that need to be installed separately.\n\n### [](#usage)Usage\n\nCreate a `rollup.config.js` [configuration file](https://www.rollupjs.org/guide/en/#configuration-files) and import the plugin:\n\njs\n\n`// rollup.config.js`\n\n`import typescript from '@rollup/plugin-typescript';`\n\n`export default {`\n\n  `input: 'src/index.ts',`\n\n  `output: {`\n\n    `dir: 'output',`\n\n    `format: 'cjs'`\n\n  `},`\n\n  `plugins: [typescript()]`\n\n`};`\n\n## [](#svelte-compiler)Svelte Compiler\n\n### [](#install-7)Install\n\n`npm install --save-dev svelte-preprocess`\n\nNote that `typescript` is an optional peer dependencies of this plugin and needs to be installed separately. `tslib` is not provided either.\n\nYou may also consider [`svelte-check`](https://www.npmjs.com/package/svelte-check) for CLI type checking.\n\n### [](#usage-1)Usage\n\nCreate a `svelte.config.js` configuration file and import the plugin:\n\njs\n\n`// svelte.config.js`\n\n`import preprocess from 'svelte-preprocess';`\n\n`const config = {`\n\n  `// Consult https://github.com/sveltejs/svelte-preprocess`\n\n  `// for more information about preprocessors`\n\n  `preprocess: preprocess()`\n\n`};`\n\n`export default config;`\n\nYou can now specify that script blocks are written in TypeScript:\n\n`<script lang=\"ts\">`\n\n## [](#vite)Vite\n\nVite supports importing `.ts` files out-of-the-box. It only performs transpilation and not type checking. It also requires that some `compilerOptions` have certain values. See the [Vite docs](https://vitejs.dev/guide/features.html#typescript) for more details.\n\n## [](#webpack)Webpack\n\n### [](#install-8)Install\n\nsh\n\n`npm install ts-loader --save-dev`\n\n### [](#basic-webpackconfigjs-when-using-webpack-5-or-4)Basic webpack.config.js when using Webpack 5 or 4\n\njs\n\n`const path = require('path');`\n\n`module.exports = {`\n\n  `entry: './src/index.ts',`\n\n  `module: {`\n\n    `rules: [`\n\n      `{`\n\n        `test: /\\.tsx?$/,`\n\n        `use: 'ts-loader',`\n\n        `exclude: /node_modules/,`\n\n      `},`\n\n    `],`\n\n  `},`\n\n  `resolve: {`\n\n    `extensions: ['.tsx', '.ts', '.js'],`\n\n  `},`\n\n  `output: {`\n\n    `filename: 'bundle.js',`\n\n    `path: path.resolve(__dirname, 'dist'),`\n\n  `},`\n\n`};`\n\nSee [more details on ts-loader here](https://www.npmjs.com/package/ts-loader).\n\nAlternatives:\n\n*   [awesome-typescript-loader](https://www.npmjs.com/package/awesome-typescript-loader)",
    "title": "TypeScript: Documentation - Integrating with Build Tools",
    "description": "How to use TypeScript with other build tools",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/intro.html",
    "markdown": "# TypeScript: Handbook - The TypeScript Handbook\n\n## [](#about-this-handbook)About this Handbook\n\nOver 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript’s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.\n\nThe most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).\n\nIf you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation on either the [Microsoft Learn JavaScript tutorial](https://developer.microsoft.com/javascript/) or read [JavaScript at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide). If you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook.\n\n## [](#how-is-this-handbook-structured)How is this Handbook Structured\n\nThe handbook is split into two sections:\n\n*   **The Handbook**\n    \n    The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.\n    \n    You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language’s features and behaviors.\n    \n    A reader who completes the walkthrough should be able to:\n    \n    *   Read and understand commonly-used TypeScript syntax and patterns\n    *   Explain the effects of important compiler options\n    *   Correctly predict type system behavior in most cases\n    \n    In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.\n    \n*   **Reference Files**\n    \n    The reference section below the handbook in the navigation is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity.\n    \n\n### [](#non-goals)Non-Goals\n\nThe Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won’t be covered in order to keep things short.\n\nSpecifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we’ll include links to background reading that you can use to read up on those concepts.\n\nThe Handbook also isn’t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript’s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven’t read about yet.\n\nFinally, the Handbook won’t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web.\n\n## [](#get-started)Get Started\n\nBefore getting started with [The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html), we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages.\n\n*   [TypeScript for the New Programmer](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)\n*   [TypeScript for JavaScript Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)\n*   [TypeScript for Java/C# Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html)\n*   [TypeScript for Functional Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)\n\nOtherwise, jump to [The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html).",
    "title": "TypeScript: Handbook - The TypeScript Handbook",
    "description": "Your first step to learn TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/types-from-types.html",
    "markdown": "# TypeScript: Documentation - Creating Types from Types\n\nTypeScript’s type system is very powerful because it allows expressing types _in terms of other types_.\n\nThe simplest form of this idea is generics. Additionally, we have a wide variety of _type operators_ available to use. It’s also possible to express types in terms of _values_ that we already have.\n\nBy combining various type operators, we can express complex operations and values in a succinct, maintainable way. In this section we’ll cover ways to express a new type in terms of an existing type or value.\n\n*   [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html) - Types which take parameters\n*   [Keyof Type Operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html) - Using the `keyof` operator to create new types\n*   [Typeof Type Operator](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html) - Using the `typeof` operator to create new types\n*   [Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html) - Using `Type['a']` syntax to access a subset of a type\n*   [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) - Types which act like if statements in the type system\n*   [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html) - Creating types by mapping each property in an existing type\n*   [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html) - Mapped types which change properties via template literal strings\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/_Creating%20Types%20from%20Types.md) ❤\n\nContributors to this page:\n\nLast updated: Jul 11, 2024",
    "title": "TypeScript: Documentation - Creating Types from Types",
    "description": "An overview of the ways in which you can create more types from existing types.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html",
    "markdown": "# TypeScript: Documentation - TypeScript for the New Programmer\n\nCongratulations on choosing TypeScript as one of your first languages — you’re already making good decisions!\n\nYou’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.\n\n## [](#what-is-javascript-a-brief-history)What is JavaScript? A Brief History\n\nJavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.\n\nWeb browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is the long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for rich _applications_ of all kinds.\n\nMore than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The “run anywhere” nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use _only_ JavaScript to program their entire stack!\n\nTo summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own _quirks_ — oddities and surprises, and JavaScript’s humble beginning makes it have _many_ of these. Some examples:\n\n*   JavaScript’s equality operator (`==`) _coerces_ its operands, leading to unexpected behavior:\n    \n    js\n    \n    `if (\"\" == 0) {`\n    \n      `// It is! But why??`\n    \n    `}`\n    \n    `if (1 < x < 3) {`\n    \n      `// True for *any* value of x!`\n    \n    `}`\n    \n*   JavaScript also allows accessing properties which aren’t present:\n    \n    js\n    \n    `const obj = { width: 10, height: 15 };`\n    \n    `// Why is this NaN? Spelling is hard!`\n    \n    `const area = obj.width * obj.heigth;`\n    \n\nMost programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.\n\n## [](#typescript-a-static-type-checker)TypeScript: A Static Type Checker\n\nWe said earlier that some languages wouldn’t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as _static checking_. Determining what’s an error and what’s not based on the kinds of values being operated on is known as static _type_ checking.\n\nTypeScript checks a program for errors before execution, and does so based on the _kinds of values_, making it a _static type checker_. For example, the last example above has an error because of the _type_ of `obj`. Here’s the error TypeScript found:\n\nts\n\n`const obj = { width: 10, height: 15 };`\n\n`const area = obj.width * obj.heigth;`\n\n`Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?2551Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYBQBjOAO0QBdQ4AjAK1AF5QBvUAdwEsATUgC1WwAYANKG6Q2Ac26k+GUAF8A3AWJlQAQ2iQ19CjQB07Lt1AAqXdT2iJPBUA)\n\n### [](#a-typed-superset-of-javascript)A Typed Superset of JavaScript\n\nHow does TypeScript relate to JavaScript, though?\n\n#### [](#syntax)Syntax\n\nTypeScript is a language that is a _superset_ of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a _syntax_ error because it’s missing a `)`:\n\nts\n\n`let a = (4`\n\n`')' expected.1005')' expected.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYMFYBQAbSAF1AENQBeUACgBYg)\n\nTypeScript doesn’t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.\n\n#### [](#types)Types\n\nHowever, TypeScript is a _typed_ superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about `obj.heigth` was not a _syntax_ error: it is an error of using some kind of value (a _type_) in an incorrect way.\n\nAs another example, this is JavaScript code that you can run in your browser, and it _will_ log a value:\n\njs\n\n`console.log(4 / []);`\n\nThis syntactically-legal program logs `Infinity`. TypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:\n\nts\n\n`console.log(4 / []);`\n\n`The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.2363The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsGBQBjOAO0TgBtIA6MuAcwAoAWUMAbQF0BKAbiA)\n\nIt’s possible you really _did_ intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.)\n\nIf you move some code from a JavaScript file to a TypeScript file, you might see _type errors_ depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors.\n\n#### [](#runtime-behavior)Runtime Behavior\n\nTypeScript is also a programming language that preserves the _runtime behavior_ of JavaScript. For example, dividing by zero in JavaScript produces `Infinity` instead of throwing a runtime exception. As a principle, TypeScript **never** changes the runtime behavior of JavaScript code.\n\nThis means that if you move code from JavaScript to TypeScript, it is **guaranteed** to run the same way, even if TypeScript thinks that the code has type errors.\n\nKeeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.\n\n#### [](#erased-types)Erased Types\n\nRoughly speaking, once TypeScript’s compiler is done with checking your code, it _erases_ the types to produce the resulting “compiled” code. This means that once your code is compiled, the resulting plain JS code has no type information.\n\nThis also means that TypeScript never changes the _behavior_ of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.\n\nFinally, TypeScript doesn’t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn.\n\n## [](#learning-javascript-and-typescript)Learning JavaScript and TypeScript\n\nWe frequently see the question “Should I learn JavaScript or TypeScript?“.\n\nThe answer is that you can’t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.\n\nThere are many, many resources available for programmers to learn JavaScript; you should _not_ ignore these resources if you’re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged `javascript` than `typescript`, but _all_ of the `javascript` questions also apply to TypeScript.\n\nIf you find yourself searching for something like “how to sort a list in TypeScript”, remember: **TypeScript is JavaScript’s runtime with a compile-time type checker**. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.\n\n## [](#next-steps)Next Steps\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n*   Learn some of the JavaScript fundamentals, we recommend either:\n    \n    *   [Microsoft’s JavaScript Resources](https://developer.microsoft.com/javascript/) or\n    *   [JavaScript guide at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide)\n*   Continue to [TypeScript for JavaScript Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)\n    \n*   Read the full Handbook [from start to finish](https://www.typescriptlang.org/docs/handbook/intro.html)\n    \n*   Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)",
    "title": "TypeScript: Documentation - TypeScript for the New Programmer",
    "description": "Learn TypeScript from scratch",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html",
    "markdown": "# TypeScript: Documentation - TypeScript for JavaScript Programmers\n\nTypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system.\n\nFor example, JavaScript provides language primitives like `string` and `number`, but it doesn’t check that you’ve consistently assigned these. TypeScript does.\n\nThis means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.\n\nThis tutorial provides a brief overview of TypeScript, focusing on its type system.\n\n## [](#types-by-inference)Types by Inference\n\nTypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.\n\nts\n\n`let helloWorld = \"Hello World\";`\n\n        `let helloWorld: string`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAFizA9gdXgJ2AEwgXggIgBKwITJrq4DcAUAPQ0QQB6A-EA)\n\nBy understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that `helloWorld` is a `string` in the above example.\n\nYou may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.\n\n## [](#defining-types)Defining Types\n\nYou can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.\n\nFor example, to create an object with an inferred type which includes `name: string` and `id: number`, you can write:\n\nts\n\n`const user = {`\n\n  `name: \"Hayes\",`\n\n  `id: 0,`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwFAxmAQwFtEAuGAIgAkCBPRCCgGlxgEsATcgBhYF8A3EA)\n\nYou can explicitly describe this object’s shape using an `interface` declaration:\n\nts\n\n`interface User {`\n\n  `name: string;`\n\n  `id: number;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvkA)\n\nYou can then declare that a JavaScript object conforms to the shape of your new `interface` by using syntax like `: TypeName` after a variable declaration:\n\nts\n\n`const user: User = {`\n\n  `name: \"Hayes\",`\n\n  `id: 0,`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvrgD0Q5AFoJCDmAljcCAPYgqyDpigUMWALw4mRUhQBEACTgBPCOiMAaJqwoAGO-3pA)\n\nIf you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:\n\nts\n\n`interface User {`\n\n  `name: string;`\n\n  `id: number;`\n\n`}`\n\n`const user: User = {`\n\n  `username: \"Hayes\",`\n\n`Object literal may only specify known properties, and 'username' does not exist in type 'User'.2353Object literal may only specify known properties, and 'username' does not exist in type 'User'.    id: 0,  };  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAFVEZQBvHUUA8gW0lUSOkIBzANytQeACaoCAV04AjGKIC+OHJTgE+oGQ2ip6jALzMxumB26oARAAlyAT0iJrAGjGTUABnfLhQA)\n\nSince JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:\n\nts\n\n`interface User {`\n\n  `name: string;`\n\n  `id: number;`\n\n`}`\n\n`class UserAccount {`\n\n  `name: string;`\n\n  `id: number;`\n\n  `constructor(name: string, id: number) {`\n\n    `this.name = name;`\n\n    `this.id = id;`\n\n  `}`\n\n`}`\n\n`const user: User = new UserAccount(\"Murphy\", 1);`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvrlwIANnHTo0mKAEEECAPYdwOJkVIUqNEAyat2XXlEZNFILRwRgFUABTrylanQA0zNoUPQAlKoIEwAAtgdAA6B2QAXkISCEZ-ZCCQ0NYo93jkQUFhBXMwZA5pCgwsaJAIAHcpaDlFZTBbACIAWQ4oAAdAgE9GtwBGb3ogA)\n\nYou can use interfaces to annotate parameters and return values to functions:\n\nts\n\n`function deleteUser(user: User) {`\n\n  `// ...`\n\n`}`\n\n`function getAdminUser(): User {`\n\n  `//...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAEtIBcCm8AzAQwGNdQBVFfUAbzVFEiIFtcAuUFbeLAcwDcDUBgAmnSAFcWAI3xCAvmhCgAtOpKTs61WgKTIJbBmiRQo3ABtceKvgAUk6vE534ASjrCVAOj9olPQMjEzM+GwBBURYsN3t3V2cvRhA-HwCgA)\n\nThere is already a small set of primitive types available in JavaScript: `boolean`, `bigint`, `null`, `number`, `string`, `symbol`, and `undefined`, which you can use in an interface. TypeScript extends this list with a few more, such as `any` (allow anything), [`unknown`](https://www.typescriptlang.org/play#example/unknown-and-never) (ensure someone using this type declares what the type is), [`never`](https://www.typescriptlang.org/play#example/unknown-and-never) (it’s not possible that this type could happen), and `void` (a function which returns `undefined` or has no return value).\n\nYou’ll see that there are two syntaxes for building types: [Interfaces and Types](https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces). You should prefer `interface`. Use `type` when you need specific features.\n\n## [](#composing-types)Composing Types\n\nWith TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.\n\n### [](#unions)Unions\n\nWith a union, you can declare that a type could be one of many types. For example, you can describe a `boolean` type as being either `true` or `false`:\n\nts\n\n`type MyBool = true | false;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAsiBCB7RAbKBeKwBOBXaAPlAGYCGKAzhANxA)\n\n_Note:_ If you hover over `MyBool` above, you’ll see that it is classed as `boolean`. That’s a property of the Structural Type System. More on this below.\n\nA popular use-case for union types is to describe the set of `string` or `number` [literals](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types) that a value is allowed to be:\n\nts\n\n`type WindowStates = \"open\" | \"closed\" | \"minimized\";`\n\n`type LockStates = \"locked\" | \"unlocked\";`\n\n`type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6glgOwCYHsDuBlYBDYEDOUAvFAEQqQKlQA+ZAxgDYr4RLV2kC2icPAXm1IBuAFChIUADIp6Aayy4CxMs3lDaZAK4I1coWInQACizjA4ANwgB5JEgByWrgCMIAJ3wBVZB4AqEAgqAIyaAMyaAKyaAOyaAJzCQA)\n\nUnions provide a way to handle different types too. For example, you may have a function that takes an `array` or a `string`:\n\nts\n\n`function getLength(obj: string | string[]) {`\n\n  `return obj.length;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQDKrMqALACjgCMArALkQGcoAnGHRAH2roeQG0BdASkQG8AUIkS10IWkhKkAdABtsuPAG5BAXyA)\n\nTo learn the type of a variable, use `typeof`:\n\n| Type | Predicate |\n| --- | --- |\n| string | `typeof s === \"string\"` |\n| number | `typeof n === \"number\"` |\n| boolean | `typeof b === \"boolean\"` |\n| undefined | `typeof undefined === \"undefined\"` |\n| function | `typeof f === \"function\"` |\n| array | `Array.isArray(a)` |\n\nFor example, you can make a function return different values depending on whether it is passed a string or an array:\n\nts\n\n`function wrapInArray(obj: string | string[]) {`\n\n  `if (typeof obj === \"string\") {`\n\n    `return [obj];`\n\n            `(parameter) obj: string`\n\n  `}`\n\n  `return obj;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwE4EMAOBJMBBVDATwAo4AjAKwC5EBnKVGMAc0QB97HmWBtAXQCUiAN4AoRIhjBEJKEUwBTODIqVEAXi2IARAyasdw8ZMmpFUEKiS81-ANxiA9E9NvTAPQD8ExAF9fc0trRDVHPyA)\n\n### [](#generics)Generics\n\nGenerics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.\n\nts\n\n`type StringArray = Array<string>;`\n\n`type NumberArray = Array<number>;`\n\n`type ObjectWithNameArray = Array<{ name: string }>;`\n\nYou can declare your own types that use generics:\n\nts\n\n`interface Backpack<Type> {`\n\n  `add: (obj: Type) => void;`\n\n  `get: () => Type;`\n\n`}`\n\n`// This line is a shortcut to tell TypeScript there is a`\n\n``// constant called `backpack`, and to not worry about where it came from.``\n\n`declare const backpack: Backpack<string>;`\n\n`// object is a string, because we declared it above as the variable part of Backpack.`\n\n`const object = backpack.get();`\n\n`// Since the backpack variable is a string, you can't pass a number to the add function.`\n\n`backpack.add(23);`\n\n`Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAEI0DWADswDwAqAni5AHygA3nlChKAEwmoAFHABGAK1Q8+ASlABeQQDc4BCQG5RoAOaQSsjdtCrIxgL548IWwAsCiUABtidT+KgiG4IJNQAriSgJHDRkN7etryQAMrU0AQsUSRuMP5elC5g1HBEiCSUpKDUlAmQEqAABvLMbNRMjQA04kQNMaBEcFEA7gjQ3OLycJGgw7nQ-lE1ALZ05PDLAHR4EpDU3pQL1aXloC3tbUyojBcc5RlEpvzGRaAKintRAZRBJA+m3Xke0o4UQdGGdF2+0O9VABCilCmOjolC8OToOkOBER3jobGgUTg5AYrWY2xKZUJSk+WjOpPam3MJBkaherhSxFo0VydNu7VAmIyOPygXuxABoG402qlQA5FE2IgCgNwssgdBorF0eIpKByOEiNQSARSttzqwyZIJDJMKygA)\n\n## [](#structural-type-system)Structural Type System\n\nOne of TypeScript’s core principles is that type checking focuses on the _shape_ that values have. This is sometimes called “duck typing” or “structural typing”.\n\nIn a structural type system, if two objects have the same shape, they are considered to be of the same type.\n\nts\n\n`interface Point {`\n\n  `x: number;`\n\n  `y: number;`\n\n`}`\n\n`function logPoint(p: Point) {`\n\n  ``console.log(`${p.x}, ${p.y}`);``\n\n`}`\n\n`// logs \"12, 26\"`\n\n`const point = { x: 12, y: 26 };`\n\n`logPoint(point);`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwFDLIAeAXMiAK4C2ARtANwHICeZltDeAvnnjBSARhg6EMgA26AOYYsACgAOZWeACUuJglEBndOIgA6SVLkADACQ4FBolwA0yS9eZdTqxjzwB6LxOnbkACIARgAmB1CANkC8LRBtbAVMcGQAXlxiMjCHVmQo5C5GYxUwRWSwdyA)\n\nThe `point` variable is never declared to be a `Point` type. However, TypeScript compares the shape of `point` to the shape of `Point` in the type-check. They have the same shape, so the code passes.\n\nThe shape-matching only requires a subset of the object’s fields to match.\n\nts\n\n`const point3 = { x: 12, y: 26, z: 89 };`\n\n`logPoint(point3); // logs \"12, 26\"`\n\n`const rect = { x: 33, y: 3, width: 30, height: 80 };`\n\n`logPoint(rect); // logs \"33, 3\"`\n\n`const color = { hex: \"#187ABF\" };`\n\n`logPoint(color);`\n\n`Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.   Type '{ hex: string; }' is missing the following properties from type 'Point': x, y2345Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.   Type '{ hex: string; }' is missing the following properties from type 'Point': x, y`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAApzEmgDeeooAHqkQK4BbAEYwA3B1ABPXoJHRxAXzx5yfItRIE4RUABs4Ac0bMAFAAdUx0gEo2E6tsRxdkAHT6DJgAYASVmdcuBQAaUD8AyQUva0U8EFAAWiTqPhIkhLwHIkQWMyZSDFAAXjZuVABGNFDpdAA2UIAvVAAOAE5QBXEPKxJzfJIMGNB4j0RQACJK0LRa8eUsnNBoSA1i0p5QDAxq1G3QAHcCABMSAAtdgAZQ08gCA1OSFouOrsMek2WNIZHDMfGt0IYOaZRwsBz6aBrVigG4bcYAYnKzQA7ABBABCADFxi88N1+iZwQgYkA)\n\nThere is no difference between how classes and objects conform to shapes:\n\nts\n\n`class VirtualPoint {`\n\n  `x: number;`\n\n  `y: number;`\n\n  `constructor(x: number, y: number) {`\n\n    `this.x = x;`\n\n    `this.y = y;`\n\n  `}`\n\n`}`\n\n`const newVPoint = new VirtualPoint(13, 56);`\n\n`logPoint(newVPoint); // logs \"13, 56\"`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAApzEmgDeeooAHqkQK4BbAEYwA3B1ABPXoJHRxAXzx5yfItRIE4RUABs4Ac0bMAFAAdUx0gEo2E6tsRxdkAHT6DJgAYASVmdcuBQAaUD8AyQUva0U8EFAAWiTqPhIkhLxqXUpERFAANQJoEj5KXSsWdk4eUH5hMQlpWtkG+0cSaD4NBBMaurlQpv6YWyrOUBIACwJEQNAAXm5xcYnp2ckFqWXQJSVM9trIAHd8is2iY4KikrKKkwBGDFCcADYYvA87i5OKmNB4jx5ABEj2eLyBQA)\n\nIf the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.\n\n## [](#next-steps)Next Steps\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n*   Read the full Handbook [from start to finish](https://www.typescriptlang.org/docs/handbook/intro.html)\n*   Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)",
    "title": "TypeScript: Documentation - TypeScript for JavaScript Programmers",
    "description": "Learn how TypeScript extends JavaScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html",
    "markdown": "# TypeScript: Documentation - TypeScript for Functional Programmers\n\nTypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.\n\nThis introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell’s type system. It also describes unique features of TypeScript’s type system that arise from its modelling of JavaScript code.\n\nThis introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.\n\n## [](#prerequisites)Prerequisites\n\nIn this introduction, I assume you know the following:\n\n*   How to program in JavaScript, the good parts.\n*   Type syntax of a C-descended language.\n\nIf you need to learn the good parts of JavaScript, read [JavaScript: The Good Parts](https://shop.oreilly.com/product/9780596517748.do). You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. [R4RS Scheme](https://people.csail.mit.edu/jaffer/r4rs.pdf) is a good example.\n\n[The C++ Programming Language](http://www.stroustrup.com/4th.html) is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: `x: string` instead of `string x`.\n\n## [](#concepts-not-in-haskell)Concepts not in Haskell\n\n### [](#built-in-types)Built-in types\n\nJavaScript defines 8 built-in types:\n\n| Type | Explanation |\n| --- | --- |\n| `Number` | a double-precision IEEE 754 floating point. |\n| `String` | an immutable UTF-16 string. |\n| `BigInt` | integers in the arbitrary precision format. |\n| `Boolean` | `true` and `false`. |\n| `Symbol` | a unique value usually used as a key. |\n| `Null` | equivalent to the unit type. |\n| `Undefined` | also equivalent to the unit type. |\n| `Object` | similar to records. |\n\n[See the MDN page for more detail](https://developer.mozilla.org/docs/Web/JavaScript/Data_structures).\n\nTypeScript has corresponding primitive types for the built-in types:\n\n*   `number`\n*   `string`\n*   `bigint`\n*   `boolean`\n*   `symbol`\n*   `null`\n*   `undefined`\n*   `object`\n\n#### [](#other-important-typescript-types)Other important TypeScript types\n\n| Type | Explanation |\n| --- | --- |\n| `unknown` | the top type. |\n| `never` | the bottom type. |\n| object literal | e.g. `{ property: Type }` |\n| `void` | for functions with no documented return value |\n| `T[]` | mutable arrays, also written `Array<T>` |\n| `[T, T]` | tuples, which are fixed-length but mutable |\n| `(t: T) => U` | functions |\n\nNotes:\n\n1.  Function syntax includes parameter names. This is pretty hard to get used to!\n    \n    ts\n    \n    `let fst: (a: any, b: any) => any = (a, b) => a;`\n    \n    `// or more precisely:`\n    \n    `let fst: <T, U>(a: T, b: U) => T = (a, b) => a;`\n    \n2.  Object literal type syntax closely mirrors object literal value syntax:\n    \n    ts\n    \n    `let o: { n: number; xs: object[] } = { n: 1, xs: [] };`\n    \n3.  `[T, T]` is a subtype of `T[]`. This is different than Haskell, where tuples are not related to lists.\n    \n\n#### [](#boxed-types)Boxed types\n\nJavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type `number` and the boxed type `Number`. The boxed types are rarely needed, since their methods return primitives.\n\nts\n\n`(1).toExponential();`\n\n`// equivalent to`\n\n`Number.prototype.toExponential.call(1);`\n\nNote that calling a method on a numeric literal requires it to be in parentheses to aid the parser.\n\n### [](#gradual-typing)Gradual typing\n\nTypeScript uses the type `any` whenever it can’t tell what the type of an expression should be. Compared to `Dynamic`, calling `any` a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an `any[]` without marking the value in any way:\n\nts\n\n`// with \"noImplicitAny\": false in tsconfig.json, anys: any[]`\n\n`const anys = [];`\n\n`anys.push(1);`\n\n`anys.push(\"oh no\");`\n\n`anys.push({ anything: \"goes\" });`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEHcEsBcAtQEQDsD2BJAtgBwDaQMYwCCSAnggFygBmAhjgM4CmokSo0D+KS1kA5gDoAVgx4AaULTIMq00gG0AugChuSBtCkzQAXlDKA3CvkNBWAK4NYACgCMASmOnzV2whTxUCJyZmvrGwBvbVI4Nn4qBH4UJgYEUABfJyA)\n\nAnd you can use an expression of type `any` anywhere:\n\nts\n\n`anys.map(anys[1]); // oh no, \"oh no\" is not a function`\n\n`any` is contagious, too — if you initialize a variable with an expression of type `any`, the variable has type `any` too.\n\nts\n\n`let sepsis = anys[0] + anys[1]; // this could mean anything`\n\nTo get an error when TypeScript produces an `any`, use `\"noImplicitAny\": true`, or `\"strict\": true` in `tsconfig.json`.\n\n### [](#structural-typing)Structural typing\n\nStructural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:\n\nts\n\n`// @strict: false`\n\n`let o = { x: \"hi\", extra: 1 }; // ok`\n\n`let o2: { x: string } = o; // ok`\n\nHere, the object literal `{ x: \"hi\", extra: 1 }` has a matching literal type `{ x: string, extra: number }`. That type is assignable to `{ x: string }` since it has all the required properties and those properties have assignable types. The extra property doesn’t prevent assignment, it just makes it a subtype of `{ x: string }`.\n\nNamed types just give a name to a type; for assignability purposes there’s no difference between the type alias `One` and the interface type `Two` below. They both have a property `p: string`. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)\n\nts\n\n`type One = { p: string };`\n\n`interface Two {`\n\n  `p: string;`\n\n`}`\n\n`class Three {`\n\n  `p = \"Hello\";`\n\n`}`\n\n`let x: One = { p: \"hi\" };`\n\n`let two: Two = x;`\n\n`two = new Three();`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lAHkA7UgXlAG9QjVE9oBLCgc1AF8BuHBzwwAZgEMAxqQAqAdzj0coRs1YdOAnjgkAbMYkShpAC2iRSdJY1C0ARAAlIOnXFuacOHZDygAHqkoaehVQW2M2W14BLx88eVQ5BVpfATik0CpZI1NzAAoASj4gA)\n\n### [](#unions)Unions\n\nIn TypeScript, union types are untagged. In other words, they are not discriminated unions like `data` in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.\n\nts\n\n`function start(`\n\n  `arg: string | string[] | (() => string) | { s: string }`\n\n`): string {`\n\n  `// this is super common in JavaScript`\n\n  `if (typeof arg === \"string\") {`\n\n    `return commonCase(arg);`\n\n  `} else if (Array.isArray(arg)) {`\n\n    `return arg.map(commonCase).join(\",\");`\n\n  `} else if (typeof arg === \"function\") {`\n\n    `return commonCase(arg());`\n\n  `} else {`\n\n    `return commonCase(arg.s);`\n\n  `}`\n\n  `function commonCase(s: string): string {`\n\n    `// finally, just convert a string to another string`\n\n    `return s;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZygQwE5QBQChGKYDmAXClBjGEYgD7mXUDaAunYttgJSIC8AfAypEe9AN4oyqRjQC+uLlIrDEY-IgD0GxFAAWMZIgMoQABwCmGRBDgBbWwiNIAUmgBuaAMoRKpqOphgDigATws4IOI+Xl5EACJpYTieNQICDHMoEAwkG3sEAGE0ZHNsYi4AbnVZRHMAGxKjIOwAQQwMNBCAOgM2jpCyjBEU9XTM7KRiLts0U2w8hzAikq4ugCs4Kmw4gBpkqoIa+sbA4LDzCMIh6Ni40EhYBGTVUcQMrJzrO0Xl0uJuSrVWoNcwvNJvcafBaFYp-IZdZCAw64dT3aDwXLfGElbDIJQyRRCahgtJaRDAKhoOp1EI7RBrECoL5gNyWKCEIk0KBwQhgOB6Syc17vCYoA6IeSyIA)\n\n`string`, `Array` and `Function` have built-in type predicates, conveniently leaving the object type for the `else` branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it’s best to build only discriminated unions.\n\nThe following types have built-in predicates:\n\n| Type | Predicate |\n| --- | --- |\n| string | `typeof s === \"string\"` |\n| number | `typeof n === \"number\"` |\n| bigint | `typeof m === \"bigint\"` |\n| boolean | `typeof b === \"boolean\"` |\n| symbol | `typeof g === \"symbol\"` |\n| undefined | `typeof undefined === \"undefined\"` |\n| function | `typeof f === \"function\"` |\n| array | `Array.isArray(a)` |\n| object | `typeof o === \"object\"` |\n\nNote that functions and arrays are objects at runtime, but have their own predicates.\n\n#### [](#intersections)Intersections\n\nIn addition to unions, TypeScript also has intersections:\n\nts\n\n`type Combined = { a: number } & { b: string };`\n\n`type Conflicting = { a: number } & { a: string };`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gWwEYEsB2EAmUC8UDeUAhgFxRoCuyEATlAL5QBkBUSZAzsDegOYMBuAFChIsOGgBmAGxQBjYH1ytS5KkloNmKztyX0BQA)\n\n`Combined` has two properties, `a` and `b`, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so `Conflicting.a: number & string`.\n\n### [](#unit-types)Unit types\n\nUnit types are subtypes of primitive types that contain exactly one primitive value. For example, the string `\"foo\"` has the type `\"foo\"`. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:\n\nts\n\n`declare function pad(s: string, n: number, direction: \"left\" | \"right\"): string;`\n\n`pad(\"hi\", 10, \"left\");`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFBFS4lVnEsAjAAYWk6Rt1A)\n\nWhen needed, the compiler _widens_ — converts to a supertype — the unit type to the primitive type, such as `\"foo\"` to `string`. This happens when using mutability, which can hamper some uses of mutable variables:\n\nts\n\n`let s = \"right\";`\n\n`pad(\"hi\", 10, s); // error: 'string' is not assignable to '\"left\" | \"right\"'`\n\n`Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.2345Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUACaQDGANgIbSSgBmArgHbEAuAlnA6AA7kEAUKUImbRWDAOYAaUA1QM6AWwBGMaQVZUW7WaABEpSDWa7QAHz2jxAC2MBKVMNESA3HhCgAtF+J1mXj3gGzEKgALwWrNbGrjz8ulasutIAjAAM0oi2zqDuMPDQqADkjmLihaCsiDJwweSIiJEM5EoGoMxwoIX6hsZmEVG6hUA)\n\nHere’s how the error happens:\n\n*   `\"right\": \"right\"`\n*   `s: string` because `\"right\"` widens to `string` on assignment to a mutable variable.\n*   `string` is not assignable to `\"left\" | \"right\"`\n\nYou can work around this with a type annotation for `s`, but that in turn prevents assignments to `s` of variables that are not of type `\"left\" | \"right\"`.\n\nts\n\n`let s: \"left\" | \"right\" = \"right\";`\n\n`pad(\"hi\", 10, s);`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFAB6Q-AC05sMgznT+qRmpVJ02QqVZVrgLzvP4g0Sk4ipY4iwAjAAMLGTqukA)\n\n## [](#concepts-similar-to-haskell)Concepts similar to Haskell\n\n### [](#contextual-typing)Contextual typing\n\nTypeScript has some obvious places where it can infer types, like variable declarations:\n\nts\n\n`let s = \"I'm a string!\";`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzhC8ECICSByAthAhtMAnAlgHYDmAhAgNxA)\n\nBut it also infers types in a few other places that you may not expect if you’ve worked with other C-syntax languages:\n\nts\n\n`declare function map<T, U>(f: (t: T) => U, ts: T[]): U[];`\n\n`let sns = map((n) => n.toString(), [1, 2, 3]);`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKRALngY1fIEp4BeO2tQwBnTgG0Aul1Y1JAbgBQEEBnjDUwvoRIMGqHv3ioAdBhwBlDDCyoA5gy7UxARmoAmagGYpcoA)\n\nHere, `n: number` in this example also, despite the fact that `T` and `U` have not been inferred before the call. In fact, after `[1,2,3]` has been used to infer `T=number`, the return type of `n => n.toString()` is used to infer `U=string`, causing `sns` to have the type `string[]`.\n\nNote that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare `map` with the array first:\n\nts\n\n`declare function map<T, U>(ts: T[], f: (t: T) => U): U[];`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKDAZwC55yBtAXWsXabtyASngBeOrWHsaPANxA)\n\nContextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as `string` or `number`. And it can infer return types from context:\n\nts\n\n`declare function run<T>(thunk: (t: T) => void): T;`\n\n`let i: { inference: string } = run((o) => {`\n\n  `o.inference = \"INSERT STATE HERE\";`\n\n`});`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXxjQB4AVAPgAoMALNAawC54qmSBKeAXjPgDccswNqwDcAKAggM8LEwDeM1IhBx0IJgGcMMLKgDm8AL5cCaChRwdu8OWPjwcAOl3LVYBJ3gAiAJIA5AGUAUQAlEngAkgBBEiD4AAlQoK9xQzYRIA)\n\nThe type of `o` is determined to be `{ inference: string }` because\n\n1.  Declaration initializers are contextually typed by the declaration’s type: `{ inference: string }`.\n2.  The return type of a call uses the contextual type for inferences, so the compiler infers that `T={ inference: string }`.\n3.  Arrow functions use the contextual type to type their parameters, so the compiler gives `o: { inference: string }`.\n\nAnd it does so while you are typing, so that after typing `o.`, you get completions for the property `inference`, along with any other properties you’d have in a real program. Altogether, this feature can make TypeScript’s inference look a bit like a unifying type inference engine, but it is not.\n\n### [](#type-aliases)Type aliases\n\nType aliases are mere aliases, just like `type` in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.\n\nts\n\n`type Size = [number, number];`\n\n`let x: Size = [101.1, 999.9];`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyglgL2gXigbQHYFcC2AjCAJwBopt8iBdAbgCgAbCYKADwC5ZEV0BGABh4A6HqQCc4waJpA)\n\nThe closest equivalent to `newtype` is a _tagged intersection_:\n\nts\n\n`type FString = string & { __compileTimeOnly: any };`\n\nAn `FString` is just like a normal string, except that the compiler thinks it has a property named `__compileTimeOnly` that doesn’t actually exist. This means that `FString` can still be assigned to `string`, but not the other way round.\n\n### [](#discriminated-unions)Discriminated Unions\n\nThe closest equivalent to `data` is a union of types with discriminant properties, normally called discriminated unions in TypeScript:\n\nts\n\n`type Shape =`\n\n  `| { kind: \"circle\"; radius: number }`\n\n  `| { kind: \"square\"; x: number }`\n\n  `| { kind: \"triangle\"; x: number; y: number };`\n\nUnlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading `|` is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:\n\nts\n\n`type Shape =`\n\n  `| { kind: \"circle\"; radius: number }`\n\n  `| { kind: \"square\"; x: number }`\n\n  `| { kind: \"triangle\"; x: number; y: number };`\n\n`function area(s: Shape) {`\n\n  `if (s.kind === \"circle\") {`\n\n    `return Math.PI * s.radius * s.radius;`\n\n  `} else if (s.kind === \"square\") {`\n\n    `return s.x * s.x;`\n\n  `} else {`\n\n    `return (s.x * s.y) / 2;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoaABmfCS0wEQA9iRQWhAIABRCsIiQAJR48kRBUEkAdBZkqCgoNPRMzhm48pjawHwMMQCyCMBweQAKAJJQAFRQAnncvIJ9A0M8-AIBmDJQEMwC0Nm5g4XFpdTqmtrUVTVcEPWN47pjg7ozsvOL0NWYtUcNMfln-YMgGQD0UABMV3IZEA)\n\nNote that the return type of `area` is inferred to be `number` because TypeScript knows the function is total. If some variant is not covered, the return type of `area` will be `number | undefined` instead.\n\nAlso, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:\n\nts\n\n`function height(s: Shape) {`\n\n  `if (s.kind === \"circle\") {`\n\n    `return 2 * s.radius;`\n\n  `} else {`\n\n    `// s.kind: \"square\" | \"triangle\"`\n\n    `return s.x;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoAPSBUAC04bR8wOGhaABmfCS0wEQA9iRQcBBEDnDAABRCsIiQAJR48kRxUIUAdBZkqCgoNPRMzuW48pjawHwMGQBMUABUUAK13LyCAZgyUBDMAtBdmJjB4-XKVuqa2tQK1rb2TmzdXBB9A5u6s7JoMkA)\n\n### [](#type-parameters)Type Parameters\n\nLike most C-descended languages, TypeScript requires declaration of type parameters:\n\nts\n\n`function liftArray<T>(t: T): Array<T> {`\n\n  `return [t];`\n\n`}`\n\nThere is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:\n\nts\n\n`function firstish<T extends { length: number }>(t1: T, t2: T): T {`\n\n  `return t1.length > t2.length ? t1 : t2;`\n\n`}`\n\nTypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.\n\nBecause TypeScript is structural, it doesn’t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to _propagate_ type information, such as constraining parameters to be the same type:\n\nts\n\n`function length<T extends ArrayLike<unknown>>(t: T): number {}`\n\n`function length(t: ArrayLike<unknown>): number {}`\n\nIn the first `length`, T is not necessary; notice that it’s only referenced once, so it’s not being used to constrain the type of the return value or other parameters.\n\n#### [](#higher-kinded-types)Higher-kinded types\n\nTypeScript does not have higher kinded types, so the following is not legal:\n\nts\n\n`function length<T extends ArrayLike<unknown>, U>(m: T<U>) {}`\n\n#### [](#point-free-programming)Point-free programming\n\nPoint-free programming — heavy use of currying and function composition — is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you’ll end up specifying type parameters instead of value parameters. The result is so verbose that it’s usually better to avoid point-free programming.\n\n### [](#module-system)Module system\n\nJavaScript’s modern module syntax is a bit like Haskell’s, except that any file with `import` or `export` is implicitly a module:\n\nts\n\n`import { value, Type } from \"npm-package\";`\n\n`import { other, Types } from \"./local-package\";`\n\n`import * as prefix from \"../lib/third-package\";`\n\nYou can also import commonjs modules — modules written using node.js’ module system:\n\nts\n\n`import f = require(\"single-function-package\");`\n\nYou can export with an export list:\n\nts\n\n`export { f };`\n\n`function f() {`\n\n  `return g();`\n\n`}`\n\n`function g() {} // g is not exported`\n\nOr by marking each export individually:\n\nts\n\n`export function f() { return g() }`\n\n`function g() { }`\n\nThe latter style is more common but both are allowed, even in the same file.\n\n### [](#readonly-and-const)`readonly` and `const`\n\nIn JavaScript, mutability is the default, although it allows variable declarations with `const` to declare that the _reference_ is immutable. The referent is still mutable:\n\njs\n\n`const a = [1, 2, 3];`\n\n`a.push(102); // ):`\n\n`a[0] = 101; // D:`\n\nTypeScript additionally has a `readonly` modifier for properties.\n\nts\n\n`interface Rx {`\n\n  `readonly x: number;`\n\n`}`\n\n`let rx: Rx = { x: 1 };`\n\n`rx.x = 12; // error`\n\nIt also ships with a mapped type `Readonly<T>` that makes all properties `readonly`:\n\nts\n\n`interface X {`\n\n  `x: number;`\n\n`}`\n\n`let rx: Readonly<X> = { x: 1 };`\n\n`rx.x = 12; // error`\n\nAnd it has a specific `ReadonlyArray<T>` type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:\n\nts\n\n`let a: ReadonlyArray<number> = [1, 2, 3];`\n\n`let b: readonly number[] = [1, 2, 3];`\n\n`a.push(102); // error`\n\n`b[0] = 101; // error`\n\nYou can also use a const-assertion, which operates on arrays and object literals:\n\nts\n\n`let a = [1, 2, 3] as const;`\n\n`a.push(102); // error`\n\n`a[0] = 101; // error`\n\nHowever, none of these options are the default, so they are not consistently used in TypeScript code.\n\n### [](#next-steps)Next Steps\n\nThis doc is a high level overview of the syntax and types you would use in everyday code. From here you should:\n\n*   Read the full Handbook [from start to finish](https://www.typescriptlang.org/docs/handbook/intro.html)\n*   Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)",
    "title": "TypeScript: Documentation - TypeScript for Functional Programmers",
    "description": "Learn TypeScript if you have a background in functional programming",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html",
    "markdown": "# TypeScript: Documentation - TypeScript Tooling in 5 minutes\n\nLet’s get started by building a simple web application with TypeScript.\n\n## [](#installing-typescript)Installing TypeScript\n\nThere are two main ways to add TypeScript to your project:\n\n*   Via npm (the Node.js package manager)\n*   By installing TypeScript’s Visual Studio plugins\n\nVisual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language support by default but does not include the TypeScript compiler, `tsc`. If you didn’t install TypeScript with Visual Studio, you can still [download it](https://www.typescriptlang.org/download).\n\nFor npm users:\n\nshell\n\n`> npm install -g typescript`\n\n## [](#building-your-first-typescript-file)Building your first TypeScript file\n\nIn your editor, type the following JavaScript code in `greeter.ts`:\n\nts\n\n`function greeter(person) {`\n\n  `return \"Hello, \" + person;`\n\n`}`\n\n`let user = \"Jane User\";`\n\n`document.body.textContent = greeter(user);`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAkCuk6Wq0koA5gE7XVbVuACkSDK7AJSgA3rVCheWBtw4AiABLVkyaABpQq0AGpQo7uMgBuWgF9atZP1AMa3UAF4DAKTKRqoAFVXVWtaABNodAZ4akgsADoAI2gw-HiBAA8sAGF2ATiPLl5+QSEXQQlLIA)\n\n## [](#compiling-your-code)Compiling your code\n\nWe used a `.ts` extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.\n\nAt the command line, run the TypeScript compiler:\n\nshell\n\n`tsc greeter.ts`\n\nThe result will be a file `greeter.js` which contains the same JavaScript that you fed in. We’re up and running using TypeScript in our JavaScript app!\n\nNow we can start taking advantage of some of the new tools TypeScript offers. Add a `: string` type annotation to the ‘person’ function parameter as shown here:\n\nts\n\n`function greeter(person: string) {`\n\n  `return \"Hello, \" + person;`\n\n`}`\n\n`let user = \"Jane User\";`\n\n`document.body.textContent = greeter(user);`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFABxwGcEAuRIqVGMZASkQG8AoRRDKEVJAIgAl0AG0FwANIh6IA1IkKoSYANzMAvs2aCsiEERyIAvBIBSAQzDpEAVV2oey5gBM4EEAFt0YKADoARnAcAnl7YAB5QAMII2J4GKBhYOLg6OHSKQA)\n\n## [](#type-annotations)Type annotations\n\nType annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:\n\nts\n\n`function greeter(person: string) {`\n\n  `return \"Hello, \" + person;`\n\n`}`\n\n`let user = [0, 1, 2];`\n\n`document.body.textContent = greeter(user);`\n\n`Argument of type 'number[]' is not assignable to parameter of type 'string'.2345Argument of type 'number[]' is not assignable to parameter of type 'string'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUwAUADjIraohdCol6ASlABvPKFBMKRaHQBEACUgAbNXAA0oRaADUoLkloBuPAF88eNS1BFEMUAF5QAbQAMOgIw60AXXM8ABM4MiIAW0gSCgA6ACM4YIBPWNYADwoAYVpWGJcGJhZ2BxgRUyA)\n\nRe-compiling, you’ll now see an error:\n\nshell\n\n`error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.`\n\nSimilarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of arguments. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.\n\nNotice that although there were errors, the `greeter.js` file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.\n\n## [](#interfaces)Interfaces\n\nLet’s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit `implements` clause.\n\nts\n\n`interface Person {`\n\n  `firstName: string;`\n\n  `lastName: string;`\n\n`}`\n\n`function greeter(person: Person) {`\n\n  `return \"Hello, \" + person.firstName + \" \" + person.lastName;`\n\n`}`\n\n`let user = { firstName: \"Jane\", lastName: \"User\" };`\n\n`document.body.textContent = greeter(user);`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyMwUGYAcnALYQBcyFUoA5gNxHIA2cF1dRszacAvgQIwAriARhgOZKygQIkKAAoADphyN05HAEp8XFWClRcAIgASEbtywAaZNeQBqZDsMgAdKTkVLQoXu7uXj7Y-rz8IWIS3GrIUhjQyAC8+CRkcYJuAFJwIBDWrrHB+dYAqmlQ7qKcBAAmWAhSdOB+AEZYzQCefpAAHmAAwjiQ4JlKKmrQGqnQRuxAA)\n\n## [](#classes)Classes\n\nFinally, let’s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.\n\nHere we’re going to create a `Student` class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.\n\nAlso of note, the use of `public` on parameters to the constructor is a shorthand that allows us to automatically create properties with that name.\n\nts\n\n`class Student {`\n\n  `fullName: string;`\n\n  `constructor(`\n\n    `public firstName: string,`\n\n    `public middleInitial: string,`\n\n    `public lastName: string`\n\n  `) {`\n\n    `this.fullName = firstName + \" \" + middleInitial + \" \" + lastName;`\n\n  `}`\n\n`}`\n\n`interface Person {`\n\n  `firstName: string;`\n\n  `lastName: string;`\n\n`}`\n\n`function greeter(person: Person) {`\n\n  `return \"Hello, \" + person.firstName + \" \" + person.lastName;`\n\n`}`\n\n`let user = new Student(\"Jane\", \"M.\", \"User\");`\n\n`document.body.textContent = greeter(user);`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAuBXAJgUwHb2gbwFDWgDNEQQA5MAW1QC5oJ4AnAS3QHMBufaYAe3QaNEweL0YAKbgQAOiAEYhmwIs0YMK1OoNZsANFOiyFS6JWbJkIVAEl0zeMzAgtTHfoIz5i5eHVVa9K7s3ACUOAbwABbMEAB0xKQaqNAAvCpq8EnQANTQAET5OabmljZ2Dk5FBQW5vpn+XAQAvrgtuKzwqIyEYMDJAApdEPzhBISqfpqBLOyN0HVJLjOcrbi4xOgizCNsjKionRLSQ-x0g2r8YXgEe0iM6PkAEqikvLqFuccX6PET9dRVD6GE4-BYNVa4KxYRAQLqpaDoVAAdzgSDQmHEeQAUmBEXl3nkALKxfH5ACqsMYeRCXFwyF4wEQ1EwsTkvGQAE9Yp0AB7wADC-E6mHhu32h3EMK6NKAA)\n\nRe-run `tsc greeter.ts` and you’ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.\n\n## [](#running-your-typescript-web-app)Running your TypeScript web app\n\nNow type the following in `greeter.html`:\n\nhtml\n\n`<!DOCTYPE html>`\n\n`<html>`\n\n  `<head>`\n\n    `<title>TypeScript Greeter</title>`\n\n  `</head>`\n\n  `<body>`\n\n    `<script src=\"greeter.js\"></script>`\n\n  `</body>`\n\n`</html>`\n\nOpen `greeter.html` in the browser to run your first simple TypeScript web application!\n\nOptional: Open `greeter.ts` in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.\n\nThe type information provided works together with the tools to work with JavaScript at application scale. For more examples of what’s possible in TypeScript, see the Samples section of the website.\n\n![Visual Studio picture](https://www.typescriptlang.org/images/docs/greet_person.png)",
    "title": "TypeScript: Documentation - TypeScript Tooling in 5 minutes",
    "description": "A tutorial to understand how to create a small website with TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/basic-types.html",
    "markdown": "# TypeScript: Documentation - The Basics\n\nEach and every value in JavaScript has a set of behaviors you can observe from running different operations. That sounds abstract, but as a quick example, consider some operations we might run on a variable named `message`.\n\njs\n\n`// Accessing the property 'toLowerCase'`\n\n`// on 'message' and then calling it`\n\n`message.toLowerCase();`\n\n`// Calling 'message'`\n\n`message();`\n\nIf we break this down, the first runnable line of code accesses a property called `toLowerCase` and then calls it. The second one tries to call `message` directly.\n\nBut assuming we don’t know the value of `message` - and that’s pretty common - we can’t reliably say what results we’ll get from trying to run any of this code. The behavior of each operation depends entirely on what value we had in the first place.\n\n*   Is `message` callable?\n*   Does it have a property called `toLowerCase` on it?\n*   If it does, is `toLowerCase` even callable?\n*   If both of these values are callable, what do they return?\n\nThe answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right.\n\nLet’s say `message` was defined in the following way.\n\njs\n\n`const message = \"Hello World!\";`\n\nAs you can probably guess, if we try to run `message.toLowerCase()`, we’ll get the same string only in lower-case.\n\nWhat about that second line of code? If you’re familiar with JavaScript, you’ll know this fails with an exception:\n\ntxt\n\n`TypeError: message is not a function`\n\nIt’d be great if we could avoid mistakes like this.\n\nWhen we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the _type_ of the value - what sorts of behaviors and capabilities it has. That’s part of what that `TypeError` is alluding to - it’s saying that the string `\"Hello World!\"` cannot be called as a function.\n\nFor some values, such as the primitives `string` and `number`, we can identify their type at runtime using the `typeof` operator. But for other things like functions, there’s no corresponding runtime mechanism to identify their types. For example, consider this function:\n\njs\n\n`function fn(x) {`\n\n  `return x.flip();`\n\n`}`\n\nWe can _observe_ by reading the code that this function will only work if given an object with a callable `flip` property, but JavaScript doesn’t surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what `fn` does with a particular value is to call it and see what happens. This kind of behavior makes it hard to predict what the code will do before it runs, which means it’s harder to know what your code is going to do while you’re writing it.\n\nSeen in this way, a _type_ is the concept of describing which values can be passed to `fn` and which will crash. JavaScript only truly provides _dynamic_ typing - running the code to see what happens.\n\nThe alternative is to use a _static_ type system to make predictions about what the code is expected to do _before_ it runs.\n\n## [](#static-type-checking)Static type-checking\n\nThink back to that `TypeError` we got earlier from trying to call a `string` as a function. _Most people_ don’t like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.\n\nIf we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through.\n\nIdeally, we could have a tool that helps us find these bugs _before_ our code runs. That’s what a static type-checker like TypeScript does. _Static types systems_ describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.\n\nts\n\n`const message = \"hello!\";`\n\n`message();`\n\n`This expression is not callable.   Type 'String' has no call signatures.2349This expression is not callable.   Type 'String' has no call signatures.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBOAUAMZwB2iALqALaSKICGA5pKALygBEAFpADY9wBCdgG48earUaQAFAEphQA)\n\nRunning that last sample with TypeScript will give us an error message before we run the code in the first place.\n\n## [](#non-exception-failures)Non-exception Failures\n\nSo far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because [the ECMAScript specification](https://tc39.github.io/ecma262/) has explicit instructions on how the language should behave when it runs into something unexpected.\n\nFor example, the specification says that trying to call something that isn’t callable should throw an error. Maybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value `undefined`:\n\njs\n\n`const user = {`\n\n  `name: \"Daniel\",`\n\n  `age: 26,`\n\n`};`\n\n`user.location; // returns undefined`\n\nUltimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error. In TypeScript, the following code produces an error about `location` not being defined:\n\nts\n\n`const user = {`\n\n  `name: \"Daniel\",`\n\n  `age: 26,`\n\n`};`\n\n`user.location;`\n\n`Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBjOAO0QBdQBXRGUAXlAG9dRQiBDAW0lQCIARNkQCWkADY8ANM1BsA5t3QA2KQF8A3LlxUYAOlFx8bUkOJqgA)\n\nWhile sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches _a lot_ of legitimate bugs.\n\nFor example: typos,\n\nts\n\n`const announcement = \"Hello World!\";`\n\n`// How quickly can you spot the typos?`\n\n`announcement.toLocaleLowercase();`\n\n`announcement.toLocalLowerCase();`\n\n`// We probably meant to write this...`\n\n`announcement.toLocaleLowerCase();`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AIaQwCukGApgLYWT4C8oARABIUA270oA6suwBMAhEwDcaNCFAtoAd1ABHEgEsMAa3YBPUBiKhN0EqBQAHaPlwALCqFyazKAPxoipctVq4AdLmgAZaF12CgDZCnhdFAoACgBKcVdDdxo6H39AgnZQ8IBhAii48UkwHhsTJAAjAgqtUBoiC25ZeGVcGytlFC9ul2IkyhTvXwCgkLlc-Jj4oA)\n\nuncalled functions,\n\nts\n\n`function flipCoin() {`\n\n  `// Meant to be Math.random()`\n\n  `return Math.random < 0.5;`\n\n`Operator '<' cannot be applied to types '() => number' and 'number'.2365Operator '<' cannot be applied to types '() => number' and 'number'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBMAzAGwCsRAZgpNgC4BLaJFCd8AgA4BhaAMgAKAJSgA3kVChSAWRS5IfUH2igARilBbcfABYA6cnrTQAtkvWhyKPgnIjLN+0cXUAAeUAAGWzYAbiIAXyA)\n\nor basic logic errors.\n\nts\n\n`const value = Math.random() < 0.5 ? \"a\" : \"b\";`\n\n`if (value !== \"a\") {`\n\n  `// ...`\n\n`} else if (value === \"b\") {`\n\n`This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.2367This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.    // Oops, unreachable  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqAG4CGANgK6SgC8oAstWQBYB001xACZwAtgAoAlKAA8oAAw8ArKAD8oAETV1oVOoBG6gNx4AlgDNQYmgyYBCZq03qpAbzyhQIUDx94AvqCQtIhM5pbWjCwOGgau7p5gAPJwAA6IADSg9MTQkNQEXNR6tJD+QA)\n\nTypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can _also_ prevent us from making those mistakes in the first place.\n\nThe type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. Once it has that information, it can also start _suggesting_ which properties you might want to use.\n\nThat means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. That’s part of what people often refer to when they talk about tooling in TypeScript.\n\nts\n\n`import express from \"express\";`\n\n`const app = express();`\n\n`app.get(\"/\", function (req, res) {`\n\n  `res.sen`\n\n*   `send`\n*   `sendDate`\n*   `sendfile`\n*   `sendFile`\n*   `sendStatus`\n\n`});`\n\n`app.listen(3000);`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAggUxQWWgCYCuANlgJKQAuWSADmgJYC2dyVoWAHnfDiqABmSZqABE3XvzEBuNAGNokFBwCGdOqAC8nHnxQoAFAEo5adXQB0AcyxVDY4GIA0QopHlVGS0Ib4BHV31jUABvNFBQfUsULEgMMEik0AA9AB80AF9TNHMNSxJGFTjDAGYABkrTIA)\n\nTypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so it’s likely that [your favorite editor has TypeScript support available](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support).\n\n## [](#tsc-the-typescript-compiler)`tsc`, the TypeScript compiler\n\nWe’ve been talking about type-checking, but we haven’t yet used our type-_checker_. Let’s get acquainted with our new friend `tsc`, the TypeScript compiler. First we’ll need to grab it via npm.\n\nsh\n\n`npm install -g typescript`\n\n> This installs the TypeScript Compiler `tsc` globally. You can use `npx` or similar tools if you’d prefer to run `tsc` from a local `node_modules` package instead.\n\nNow let’s move to an empty folder and try writing our first TypeScript program: `hello.ts`:\n\nts\n\n`// Greets the world.`\n\n`console.log(\"Hello world!\");`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEHECcFNoFwM6jgC2qA7ge0gGwCYB0AUAMZYB2CWu0huWA5gBQBEAEtLg5jgQISsAlAG4gA)\n\nNotice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript. And now let’s type-check it by running the command `tsc` which was installed for us by the `typescript` package.\n\nsh\n\n`tsc hello.ts`\n\nTada!\n\nWait, “tada” _what_ exactly? We ran `tsc` and nothing happened! Well, there were no type errors, so we didn’t get any output in our console since there was nothing to report.\n\nBut check again - we got some _file_ output instead. If we look in our current directory, we’ll see a `hello.js` file next to `hello.ts`. That’s the output from our `hello.ts` file after `tsc` _compiles_ or _transforms_ it into a plain JavaScript file. And if we check the contents, we’ll see what TypeScript spits out after it processes a `.ts` file:\n\njs\n\n`// Greets the world.`\n\n`console.log(\"Hello world!\");`\n\nIn this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.\n\nWhat about if we _did_ introduce a type-checking error? Let’s rewrite `hello.ts`:\n\nts\n\n`// This is an industrial-grade general-purpose greeter function:`\n\n`function greet(person, date) {`\n\n  ``console.log(`Hello ${person}, today is ${date}!`);``\n\n`}`\n\n`greet(\"Brendan\");`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAlAFQBYEsVQDQBDSIyAEwFcUAXePEgGwFoBzeEygU1HZ6QeXNgAdq8UdBR9OPHnWGgAZtUgBjOnmiQAXGlUatO-vHl0AFKOEodAGlCUSigJSgA3mlCh1O28x4AOmZodgsAAwAJHmYQ0AASd2tUHQBfBzpoJwBPIkJEp0VUgEJwlwBuNFS0NDkFCwAiACEzKjIGiqA)\n\nIf we run `tsc hello.ts` again, notice that we get an error on the command line!\n\ntxt\n\n`Expected 2 arguments, but got 1.`\n\nTypeScript is telling us we forgot to pass an argument to the `greet` function, and rightfully so. So far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!\n\n## [](#emitting-with-errors)Emitting with Errors\n\nOne thing you might not have noticed from the last example was that our `hello.js` file changed again. If we open that file up then we’ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that `tsc` reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, _you_ will know better than TypeScript.\n\nTo reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time that’s okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it?\n\nSo TypeScript doesn’t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) compiler option. Try changing your `hello.ts` file and running `tsc` with that flag:\n\nsh\n\n`tsc --noEmitOnError hello.ts`\n\nYou’ll notice that `hello.js` never gets updated.\n\n## [](#explicit-types)Explicit Types\n\nUp until now, we haven’t told TypeScript what `person` or `date` are. Let’s edit the code to tell TypeScript that `person` is a `string`, and that `date` should be a `Date` object. We’ll also use the `toDateString()` method on `date`.\n\nts\n\n`function greet(person: string, date: Date) {`\n\n  ``console.log(`Hello ${person}, today is ${date.toDateString()}!`);``\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6gA)\n\nWhat we did was add _type annotations_ on `person` and `date` to describe what types of values `greet` can be called with. You can read that signature as ”`greet` takes a `person` of type `string`, and a `date` of type `Date`“.\n\nWith this, TypeScript can tell us about other cases where `greet` might have been called incorrectly. For example…\n\nts\n\n`function greet(person: string, date: Date) {`\n\n  ``console.log(`Hello ${person}, today is ${date.toDateString()}!`);``\n\n`}`\n\n`greet(\"Maddison\", Date());`\n\n`Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUAUADjIraohdFRL0ANKAAmAQwqRUAESmQAlKADeeUKDK1uAG0gA6HXHqsABgAlIOo6AAkKzkloBfURTiSAnqCqI7KyWl9d3lpAGV+QRNFZwBCU0UAbjxnPDxGZjYAIgBZCTExX1os0VDIVkUkoA)\n\nHuh? TypeScript reported an error on our second argument, but why?\n\nPerhaps surprisingly, calling `Date()` in JavaScript returns a `string`. On the other hand, constructing a `Date` with `new Date()` actually gives us what we were expecting.\n\nAnyway, we can quickly fix up the error:\n\nts\n\n`function greet(person: string, date: Date) {`\n\n  ``console.log(`Hello ${person}, today is ${date.toDateString()}!`);``\n\n`}`\n\n`greet(\"Maddison\", new Date());`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6BATRMHAAiAFkmBgYLBFD6MHQAd0QHdGxuXyA)\n\nKeep in mind, we don’t always have to write explicit type annotations. In many cases, TypeScript can even just _infer_ (or “figure out”) the types for us even if we omit them.\n\nts\n\n`let msg = \"hello there!\";`\n\n    `let msg: string`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgzg5hAvBARACxMYB7CYMBOIAhCgNwBQA9FRBAHoD8QA)\n\nEven though we didn’t tell TypeScript that `msg` had the type `string` it was able to figure that out. That’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.\n\n> Note: The message bubble inside the previous code sample is what your editor would show if you had hovered over the word.\n\n## [](#erased-types)Erased Types\n\nLet’s take a look at what happens when we compile the above function `greet` with `tsc` to output JavaScript:\n\nts\n\n`\"use strict\";`\n\n`function greet(person, date) {`\n\n    `console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));`\n\n`}`\n\n`greet(\"Maddison\", new Date());`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFygmQCsmAZgK4B2AxuqrM6EQSWQAoADiQKQulSOgKpmRADSgAJnnQlKAEVUkAlKADemUKFZdxAGxIA6c7CICABgAkS526AAk+kWK4BfRXRYFQBPUFRIT30VNSsgrTUAZWlZex0-AEIHHQBuTD9MTF5+dAEAIgBZPCUlCK4yxWYSeFAEkgEdXKA)\n\nNotice two things here:\n\n1.  Our `person` and `date` parameters no longer have type annotations.\n2.  Our “template string” - that string that used backticks (the `` ` `` character) - was converted to plain strings with concatenations.\n\nMore on that second point later, but let’s now focus on that first point. Type annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.\n\n> **Remember**: Type annotations never change the runtime behavior of your program.\n\n## [](#downleveling)Downleveling\n\nOne other difference from the above was that our template string was rewritten from\n\njs\n\n`` `Hello ${person}, today is ${date.toDateString()}!`; ``\n\nto\n\njs\n\n`\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\");`\n\nWhy did this happen?\n\nTemplate strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - _don’t ask_). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5). This process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called _downleveling_.\n\nBy default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the [`target`](https://www.typescriptlang.org/tsconfig#target) option. Running with `--target es2015` changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running `tsc --target es2015 hello.ts` gives us the following output:\n\njs\n\n`function greet(person, date) {`\n\n  ``console.log(`Hello ${person}, today is ${date.toDateString()}!`);``\n\n`}`\n\n`greet(\"Maddison\", new Date());`\n\n> While the default target is ES3, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.\n\n## [](#strictness)Strictness\n\nDifferent users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially `null`/`undefined` values. Much like how `tsc` emits in the face of errors, these defaults are put in place to stay out of your way. If you’re migrating existing JavaScript, that might be a desirable first step.\n\nIn contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on.\n\nTypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The [`strict`](https://www.typescriptlang.org/tsconfig#strict) flag in the CLI, or `\"strict\": true` in a [`tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) and [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks).\n\n## [](#noimplicitany)`noImplicitAny`\n\nRecall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type: `any`. This isn’t the worst thing that can happen - after all, falling back to `any` is just the plain JavaScript experience anyway.\n\nHowever, using `any` often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code. Turning on the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) flag will issue an error on any variables whose type is implicitly inferred as `any`.\n\n## [](#strictnullchecks)`strictNullChecks`\n\nBy default, values like `null` and `undefined` are assignable to any other type. This can make writing some code easier, but forgetting to handle `null` and `undefined` is the cause of countless bugs in the world - some consider it a [billion dollar mistake](https://www.youtube.com/watch?v=ybrQvs4x0Ps)! The [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) flag makes handling `null` and `undefined` more explicit, and _spares_ us from worrying about whether we _forgot_ to handle `null` and `undefined`.",
    "title": "TypeScript: Documentation - The Basics",
    "description": "Step one in learning TypeScript: The basic types.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html",
    "markdown": "# TypeScript: Documentation - Everyday Types\n\nIn this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript. This isn’t an exhaustive list, and future chapters will describe more ways to name and use other types.\n\nTypes can also appear in many more _places_ than just type annotations. As we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs.\n\nWe’ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code. These will later form the core building blocks of more complex types.\n\n## [](#the-primitives-string-number-and-boolean)The primitives: `string`, `number`, and `boolean`\n\nJavaScript has three very commonly used [primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive): `string`, `number`, and `boolean`. Each has a corresponding type in TypeScript. As you might expect, these are the same names you’d see if you used the JavaScript `typeof` operator on a value of those types:\n\n*   `string` represents string values like `\"Hello, world\"`\n*   `number` is for numbers like `42`. JavaScript does not have a special runtime value for integers, so there’s no equivalent to `int` or `float` - everything is simply `number`\n*   `boolean` is for the two values `true` and `false`\n\n> The type names `String`, `Number`, and `Boolean` (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. _Always_ use `string`, `number`, or `boolean` for types.\n\n## [](#arrays)Arrays\n\nTo specify the type of an array like `[1, 2, 3]`, you can use the syntax `number[]`; this syntax works for any type (e.g. `string[]` is an array of strings, and so on). You may also see this written as `Array<number>`, which means the same thing. We’ll learn more about the syntax `T<U>` when we cover _generics_.\n\n> Note that `[number]` is a different thing; refer to the section on [Tuples](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types).\n\n## [](#any)`any`\n\nTypeScript also has a special type, `any`, that you can use whenever you don’t want a particular value to cause typechecking errors.\n\nWhen a value is of type `any`, you can access any properties of it (which will in turn be of type `any`), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:\n\nts\n\n`let obj: any = { x: 0 };`\n\n`// None of the following lines of code will throw compiler errors.`\n\n``// Using `any` disables all further type checking, and it is assumed``\n\n`// you know the environment better than TypeScript.`\n\n`obj.foo();`\n\n`obj();`\n\n`obj.bar = 100;`\n\n`obj = \"hello\";`\n\n`const n: number = obj;`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBA9gRgVgLggQwHYE8IF4IG8IAeSADBAL4DcAsAFAD0dEAclKiNAGYRgAW7HUYMCgB3AJaoA5hGASQAZ04QAxlAAm7cUO48ATqJVQAtgAcxoXRBC79u+QDpaDCAFV5E6QAM06TxDVi8sgwoIrI2hwArrq81tzoJuzKfMoA1h4ANCioahBikIEo8vKRRiBqTozoUJEQqagGsVaoAG5i+qhlqJAw4GBxvGgQACoJIADKyrpiJmCONLBw9gJQABQAlNQL8Btbi-YwyJY4AIzExHvw2BAARHxCUDdbqqjykKhIqKW9x9DwFEA)\n\nThe `any` type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay.\n\n### [](#noimplicitany)`noImplicitAny`\n\nWhen you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to `any`.\n\nYou usually want to avoid this, though, because `any` isn’t type-checked. Use the compiler flag [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) to flag any implicit `any` as an error.\n\n## [](#type-annotations-on-variables)Type Annotations on Variables\n\nWhen you declare a variable using `const`, `var`, or `let`, you can optionally add a type annotation to explicitly specify the type of the variable:\n\nts\n\n`let myName: string = \"Alice\";`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgngcgQyiAXBAzmATgSwHYDmEAvBAEQCCwOAxiGQNwCwAUAPRsRfdcB6-A-hAAqMAA4gICPHgD2YBGByy8QA)\n\n> TypeScript doesn’t use “types on the left”-style declarations like `int x = 0;` Type annotations will always go _after_ the thing being typed.\n\nIn most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically _infer_ the types in your code. For example, the type of a variable is inferred based on the type of its initializer:\n\nts\n\n`// No type annotation needed -- 'myName' inferred as type 'string'`\n\n`let myName = \"Alice\";`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEDkHtQFwTwA4FNQEMB27I1TAlpOqOkkgCbmgC0VoA5ALZzioNJ2h7oBmSATn0qoAzrEQo6wmHy4BzOgFgAUABskMUExZtQAXlAAiAIIq8AYyQGA3EA)\n\nFor the most part you don’t need to explicitly learn the rules of inference. If you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on.\n\n## [](#functions)Functions\n\nFunctions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.\n\n### [](#parameter-type-annotations)Parameter Type Annotations\n\nWhen you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:\n\nts\n\n`// Parameter type annotation`\n\n`function greet(name: string) {`\n\n  `console.log(\"Hello, \" + name.toUpperCase() + \"!!\");`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAUEMCdIWwKYBcHVEgngBwaSA7fAeyUiQEsj8BYAKADMBXfAYwqtAHNoFkAKfPAQAuUAGck0cvk4BKUAG86oUCBXqNm9QD1de3ctAsqYogBsEAOjNFOfAEQAJBGZsAaUPdABqUIMSWSEQAqlg40ADCkGIIfPK+9gCEifayANx0AL5AA)\n\nWhen a parameter has a type annotation, arguments to that function will be checked:\n\nts\n\n`// Would be a runtime error if executed!`\n\n`greet(42);`\n\n`Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOgDmNkrABRNKAW0ipEraOyY8AlKgBucdkQDchEKAC0e0g1Z6dWsAHU4DckVAAjWpVDRmHcaBjxoodnXcAPMkNIIgBCQj5IAUEsNHl1IA)\n\n> Even if you don’t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments.\n\n### [](#return-type-annotations)Return Type Annotations\n\nYou can also add return type annotations. Return type annotations appear after the parameter list:\n\nts\n\n`function getFavoriteNumber(): number {`\n\n  `return 26;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQGIEMBucBOMUqAciALYBGq+AFAJQBciYF1+iA3gLABQiiAPSCBoseIliAejNky+A-OhD4kAJgBsAbj4BfIA)\n\nMuch like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its `return` statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.\n\n#### [](#functions-which-return-promises)Functions Which Return Promises\n\nIf you want to annotate the return type of a function which returns a promise, you should use the `Promise` type:\n\nts\n\n`async function getFavoriteNumber(): Promise<number> {`\n\n  `return 26;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/IYZwngdgxgBAZgV2gFwJYHsIwOYFNkBiwAbugE6rK4ByCAtgEa5kAUAlAFwwAKZ6dqELgA8EekzIA+GAG8AsACgYMMvgRksAJgBsAbkUBfIA)\n\n### [](#anonymous-functions)Anonymous Functions\n\nAnonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.\n\nHere’s an example:\n\nts\n\n`const names = [\"Alice\", \"Bob\", \"Eve\"];`\n\n`// Contextual typing for function - parameter s inferred to have type string`\n\n`names.forEach(function (s) {`\n\n  `console.log(s.toUpperCase());`\n\n`});`\n\n`// Contextual typing also applies to arrow functions`\n\n`names.forEach((s) => {`\n\n  `console.log(s.toUpperCase());`\n\n`});`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYCwAoAYzgDtEAXUEgQwFtJFQBeUAbQCIBBAGwEtDI7ADSh2AITgAjYaICiAN0EBdANwECIUAGFS5SAA9yAV2rdQ5AJ4AHXiQDmoAGYInRkoXK9SoALSgr1NB0kHrQoIy2jjDQkAAm5nCgABbUiubWkOHk0LZ2BDT0iAB0ztCy1IRJABSObh5eJKBViACUoADeBKCgxGRw3JBF3HB2zUXkcACqVlYwWtSIkFUtLWr4AL6r6viaOiR6hiZmljb2oKaIidQzfAwJ57BwAO6u7p6kiPnBxaXllVXNNpMAB8HS6PQ+-UGw1GxQm01m0Hmi2WWw2qyAA)\n\nEven though the parameter `s` didn’t have a type annotation, TypeScript used the types of the `forEach` function, along with the inferred type of the array, to determine the type `s` will have.\n\nThis process is called _contextual typing_ because the _context_ that the function occurred within informs what type it should have.\n\nSimilar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it _does_ happen can help you notice when type annotations aren’t needed. Later, we’ll see more examples of how the context that a value occurs in can affect its type.\n\n## [](#object-types)Object Types\n\nApart from primitives, the most common sort of type you’ll encounter is an _object type_. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.\n\nFor example, here’s a function that takes a point-like object:\n\nts\n\n`// The parameter's type annotation is an object type`\n\n`function printCoord(pt: { x: number; y: number }) {`\n\n  `console.log(\"The coordinate's x value is \" + pt.x);`\n\n  `console.log(\"The coordinate's y value is \" + pt.y);`\n\n`}`\n\n`printCoord({ x: 3, y: 7 });`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQBwIYCcEFtoBdpIOQGdQMBPOWBAO3IHsMEMBLK80egi0KgIwCtoBjDIRLQAsACgAZgFdyAxszhJ65DAGEqVJABMAFHAwAuUAG9QADyPkpqTtgDcoIpeu2koAL4BKE+NCgQfoFBwSF+AHoRkVHRMZG+oHxMeFQANtAAdClUAOY6AERQsImaWsp00PjmoABuCClSsKygeaAA1PAY6WaedvGJ5MlpmTn5hQka2mVYlUQ1dQ0sBC3t+ulEPeLu4orKahO6phagAMwANI5GAOwePUA)\n\nHere, we annotated the parameter with a type with two properties - `x` and `y` - which are both of type `number`. You can use `,` or `;` to separate the properties, and the last separator is optional either way.\n\nThe type part of each property is also optional. If you don’t specify a type, it will be assumed to be `any`.\n\n### [](#optional-properties)Optional Properties\n\nObject types can also specify that some or all of their properties are _optional_. To do this, add a `?` after the property name:\n\nts\n\n`function printName(obj: { first: string; last?: string }) {`\n\n  `// ...`\n\n`}`\n\n`// Both OK`\n\n`printName({ first: \"Bob\" });`\n\n`printName({ first: \"Alice\", last: \"Alisson\" });`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAcgQwLYCmAFHAEYBWAXIgN6LAyoDOU1L6YA5gNyIA2OFgH42UDp0QBfAJS0AsAChEiAPQrEAOi2LJitYgBCcKAAtEAeQDSitBmz5idBs1aIAREdJup07jY72hEROjCzUbgCCfDAQBG4ANPyCrpHRTEwI3jLcQA)\n\nIn JavaScript, if you access a property that doesn’t exist, you’ll get the value `undefined` rather than a runtime error. Because of this, when you _read_ from an optional property, you’ll have to check for `undefined` before using it.\n\nts\n\n`function printName(obj: { first: string; last?: string }) {`\n\n  `// Error - might crash if 'obj.last' wasn't provided!`\n\n  `console.log(obj.last.toUpperCase());`\n\n`'obj.last' is possibly 'undefined'.18048'obj.last' is possibly 'undefined'.    if (obj.last !== undefined) {      // OK      console.log(obj.last.toUpperCase());    }    // A safe alternative using modern JavaScript syntax:    console.log(obj.last?.toUpperCase());  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwA4AMAWDBYAKADMBXAOwGMAXASznNAAdpbzqA5AQwFtIAKOACMAVqgDeoYrSTVUiaq3IBzANygANlwUB+eYrbLQAXwCUocUVCgQoAKKwEoALSgetZQAtqoStG2eoLTEoADkwiIAdFoKoaAA7trkoT4scAButAAmkFkAhFa+DIhwGpDRcMqCotHa1JHUcACqTEwwAMLaAqamqoXBoNVRMT55ALxjoBQ50uS55paE1ta2APIA0oXWlMWl5RqVQ7UKDc2tHV38PX1LJkSFtgCCoIhcxJCgXBrUMORcdOkPqREIY3HActBGAApLjpLgAZT8tCYPkQAE92FwAB7IQo7cglMoVKoRY7UHSnFptaCdRDdXpEYxAA)\n\n## [](#union-types)Union Types\n\nTypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, it’s time to start _combining_ them in interesting ways.\n\n### [](#defining-a-union-type)Defining a Union Type\n\nThe first way to combine types you might see is a _union_ type. A union type is a type formed from two or more other types, representing values that may be _any one_ of those types. We refer to each of these types as the union’s _members_.\n\nLet’s write a function that can operate on strings or numbers:\n\nts\n\n`function printId(id: number | string) {`\n\n  `console.log(\"Your ID is: \" + id);`\n\n`}`\n\n`// OK`\n\n`printId(101);`\n\n`// OK`\n\n`printId(\"202\");`\n\n`// Error`\n\n`printId({ myID: 22342 });`\n\n`Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.2345Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFABmArgHYDGALgJZxmgAO0NZVAkgCYAUNnqZEgFsARjFAAfUIiosyAcwCUoAN6FQoCvURwANpAB0uuPO4AiAJpwS0UOwAioGilBnQAaiedFAbkIBfQhBQAHkAaUJmVg4eAEYABljfILBwyLkY8zR4tDNkgmCAUVgEdOiubhVQIQBPB1Q0TCw0UH9fIA)\n\n### [](#working-with-union-types)Working with Union Types\n\nIt’s easy to _provide_ a value matching a union type - simply provide a type matching any of the union’s members. If you _have_ a value of a union type, how do you work with it?\n\nTypeScript will only allow an operation if it is valid for _every_ member of the union. For example, if you have the union `string | number`, you can’t use methods that are only available on `string`:\n\nts\n\n`function printId(id: number | string) {`\n\n  `console.log(id.toUpperCase());`\n\n`Property 'toUpperCase' does not exist on type 'string | number'.   Property 'toUpperCase' does not exist on type 'number'.2339Property 'toUpperCase' does not exist on type 'string | number'.   Property 'toUpperCase' does not exist on type 'number'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoAMwFcA7AYwBcBLOU0AB2mtMoEkATACmo9VOIBbAEYxQAH1CJKzUgHMAlKADeBUKHJ1EcADaQAdDrhyeHfZTgBVBgxgBhAIaJIXBQoDcBAL5A)\n\nThe solution is to _narrow_ the union with code, the same as you would in JavaScript without type annotations. _Narrowing_ occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.\n\nFor example, TypeScript knows that only a `string` value will have a `typeof` value `\"string\"`:\n\nts\n\n`function printId(id: number | string) {`\n\n  `if (typeof id === \"string\") {`\n\n    `// In this branch, id is of type 'string'`\n\n    `console.log(id.toUpperCase());`\n\n  `} else {`\n\n    `// Here, id is of type 'number'`\n\n    `console.log(id);`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAkgEwBQw4BciYIAtgEYCmqiAPogM5TpgDmAlIgN4CwAKESIYwRHigBPZNThjCiALzLEAIhZt2q7vyHDEAegOIsSKAAsYTRJVQBDSOYA0InCOtzEUmYgDkGjHZfQX1ECAQmOAAbagA6KLh2AhxYqDgAVWQZVABhOyZqPE5OAG4QxABfRGoogt5y4SNEAAlaahcFK0RPb2o-MipaYL1hcLBImPjE5NLyisEKoA)\n\nAnother example is to use a function like `Array.isArray`:\n\nts\n\n`function welcomePeople(x: string[] | string) {`\n\n  `if (Array.isArray(x)) {`\n\n    `// Here: 'x' is 'string[]'`\n\n    `console.log(\"Hello, \" + x.join(\" and \"));`\n\n  `} else {`\n\n    `// Here: 'x' is 'string'`\n\n    `console.log(\"Welcome lone traveler \" + x);`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwKYBsJwLaoAqpwAO6qAFAB4BciAzlAE4xgDmA2gLqIA+djzLAJSIA3gFgAUIkQxgiMgEEGDAIYBPAHQxaS1WsqDh4qdMQB6M4gASqBqhoByCg5m1ED+k1acHk04iwwWjhSDXQ4FjIAIht0cIAaRCjEAGpECg0AKzhmaMQVMAATJMMAbj9EAF9EDFpUUQrpC2tbe3dnV3dPAV8TaUDg0PDIqIB1DCxcRHCwesYVADcMWyTU9MFyk0rJSqA)\n\nNotice that in the `else` branch, we don’t need to do anything special - if `x` wasn’t a `string[]`, then it must have been a `string`.\n\nSometimes you’ll have a union where all the members have something in common. For example, both arrays and strings have a `slice` method. If every member in a union has a property in common, you can use that property without narrowing:\n\nts\n\n`// Return type is inferred as number[] | string`\n\n`function getFirstThree(x: number[] | string) {`\n\n  `return x.slice(0, 3);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAECUFMBcFcCcB2poE8AOlQEsDOPEAzSeeSAE1AEN9FYBbAIxIG0BdUAH1F2nm0QBzALAAoQrEQBjaNgD2yQTABi2eLwAqACzKQAFAA8AXKDpNWHbr35CAlKADeY0KDJwkoAwDpcAG2xS+gAMADSgAMy2ANxiAL5AA)\n\n> It might be confusing that a _union_ of types appears to have the _intersection_ of those types’ properties. This is not an accident - the name _union_ comes from type theory. The _union_ `number | string` is composed by taking the union _of the values_ from each type. Notice that given two sets with corresponding facts about each set, only the _intersection_ of those facts applies to the _union_ of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about _every_ person is that they must be wearing a hat.\n\n## [](#type-aliases)Type Aliases\n\nWe’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.\n\nA _type alias_ is exactly that - a _name_ for any _type_. The syntax for a type alias is:\n\nts\n\n`type Point = {`\n\n  `x: number;`\n\n  `y: number;`\n\n`};`\n\n`// Exactly the same as the earlier example`\n\n`function printCoord(pt: Point) {`\n\n  `console.log(\"The coordinate's x value is \" + pt.x);`\n\n  `console.log(\"The coordinate's y value is \" + pt.y);`\n\n`}`\n\n`printCoord({ x: 100, y: 100 });`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbwLACgpQAeAXFEgK4C2ARhAE4DceBIpFN9TuAvl3gPT8oAUUIBDAMbAANiCjAAFtADOYytDHL5SqBDF1pCervGUw0iHgBm5JFIRwkUMHWTAAwnDh0AJgAowYFJ4NwBKLGYoCUdlOAsAOmk4AHM-ACIAFR1o7x9kMWAIAHItQigANzFpcmgELTSoAGpnYHjCUK4CaKRYhKTUzOyvX3zCkqg5Sura+qaW+JAOvG48PBc3T1y-TCJSAEYABgOAGgn9o6huDqA)\n\nYou can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:\n\nts\n\n`type ID = number | string;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAkgIlAvFAdgVwLYCMICcoA+UAzsLgJYoDmA3EA)\n\nNote that aliases are _only_ aliases - you cannot use type aliases to create different/distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might _look_ illegal, but is OK according to TypeScript because both types are aliases for the same type:\n\nts\n\n`type UserInputSanitizedString = string;`\n\n`function sanitizeInput(str: string): UserInputSanitizedString {`\n\n  `return sanitize(str);`\n\n`}`\n\n`// Create a sanitized input`\n\n`let userInput = sanitizeInput(getInput());`\n\n`// Can still be re-assigned with a string though`\n\n`userInput = \"new input\";`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBJVAB2QwAoBKALngGcMYtUCBuAWAChRIsBCnTY8zKKizYAXiGosYjRewINmrVT14B6HfAC0RsFSMG+GAJ7kEAVSYgYZShgDKk6VjnBXmjvABeDTYObT4RTFx8Jg9ZEGcqBVZlPzVGe0cEt1ivEB9U+ABvPnh4OAxkGGicuSSYWm0AXz4+PXgAYTgoDAQoCSk44Hh2Fz4IYnhkBycKKkD+zzks6iJSWZpaBpbdfXbJDSwICHgAIwQ4AygmJiwCVDz4AHdpAAt4PpV-DBecZAIXvhTTLreYAInuj2G61BnCAA)\n\n## [](#interfaces)Interfaces\n\nAn _interface declaration_ is another way to name an object type:\n\nts\n\n`interface Point {`\n\n  `x: number;`\n\n  `y: number;`\n\n`}`\n\n`function printCoord(pt: Point) {`\n\n  `console.log(\"The coordinate's x value is \" + pt.x);`\n\n  `console.log(\"The coordinate's y value is \" + pt.y);`\n\n`}`\n\n`printCoord({ x: 100, y: 100 });`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwLABQyyAHgFzIgCuAtgEbQDchxAnhdfU4QL6GEwqIBGGDoQyAA5QsAYXTooAEwAUksBQxYAlLhbIE4gM7oANhAB0p9AHMVAIgAqACxSHFS0HEgByI6WQANzhTKhRgf3tkAGopMAsSbWYiA2MzS2s7J1dUjy9ff1YgkLDkCOQo2PULViTefgJpOQVlFRxSCgBGAAZugBpkdmQe7uQeJKA)\n\nJust like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the _structure_ of the value we passed to `printCoord` - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a _structurally typed_ type system.\n\n### [](#differences-between-type-aliases-and-interfaces)Differences Between Type Aliases and Interfaces\n\nType aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an `interface` are available in `type`, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.\n\n| `Interface` | `Type` |\n| --- | --- |\n| Extending an interface<br><br>`interface Animal {   name: string; }   interface Bear extends Animal {   honey: boolean; }   const bear = getBear(); bear.name; bear.honey;` | Extending a type via intersections<br><br>`type Animal = {   name: string; }   type Bear = Animal & {    honey: boolean; }   const bear = getBear(); bear.name; bear.honey;` |\n| Adding new fields to an existing interface<br><br>`interface Window {   title: string; }   interface Window {   ts: TypeScriptAPI; }   const src = 'const a = \"Hello World\"'; window.ts.transpileModule(src, {});` | A type cannot be changed after being created<br><br>`type Window = {   title: string; }   type Window = {   ts: TypeScriptAPI; }    // Error: Duplicate identifier 'Window'.` |\n\nYou’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away.\n\n*   Prior to TypeScript version 4.2, type alias names [_may_ appear in error messages](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA), sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.\n*   Type aliases may not participate [in declaration merging, but interfaces can](https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA).\n*   Interfaces may only be used to [declare the shapes of objects, not rename primitives](https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA).\n*   Interface names will [_always_ appear in their original form](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA) in error messages, but _only_ when they are used by name.\n*   Using interfaces with `extends` [can often be more performant for the compiler](https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections) than type aliases with intersections\n\nFor the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use `interface` until you need to use features from `type`.\n\n## [](#type-assertions)Type Assertions\n\nSometimes you will have information about the type of a value that TypeScript can’t know about.\n\nFor example, if you’re using `document.getElementById`, TypeScript only knows that this will return _some_ kind of `HTMLElement`, but you might know that your page will always have an `HTMLCanvasElement` with a given ID.\n\nIn this situation, you can use a _type assertion_ to specify a more specific type:\n\nts\n\n`const myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtgTwMIEMwDcURgXhgExGAFc4BTMKAOgHMyoBRAGzPMoCEEBJfACgCI4KAJZgA+sDSYI-AJQwsMABIAVALIAZVBizNWFKAG4gA)\n\nLike a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code.\n\nYou can also use the angle-bracket syntax (except if the code is in a `.tsx` file), which is equivalent:\n\nts\n\n`const myCanvas = <HTMLCanvasElement>document.getElementById(\"main_canvas\");`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtgTwMIEMwDcURgXhgHgAkAVAWQBlUMsBRAGwFM4GwoA+AExGAFdnWAdAHMGUekxZQAQggCSHABQAiOCgCWYAPrA0mCEoCUAbiA)\n\n> Reminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion. There won’t be an exception or `null` generated if the type assertion is wrong.\n\nTypeScript only allows type assertions which convert to a _more specific_ or _less specific_ version of a type. This rule prevents “impossible” coercions like:\n\nts\n\n`const x = \"hello\" as number;`\n\n`Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.2352Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCsaCwAoAYzgDtEAXUAD1AF5QAiAC0gBtW4HQBDRUEgK4BbAEYwA3EA)\n\nSometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to `any` (or `unknown`, which we’ll introduce later), then to the desired type:\n\nts\n\n`const a = expr as any as T;`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3iAHgBxgC54oUBPAbgFgAoDMvBAFXgF54BvE4gRgvgBGxAEz8wxAMzwAvtRoB6efAC0qsAFcMq5bWTosUNtnwwSaEuTPwmFIA)\n\n## [](#literal-types)Literal Types\n\nIn addition to the general types `string` and `number`, we can refer to _specific_ strings and numbers in type positions.\n\nOne way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both `var` and `let` allow for changing what is held inside the variable, and `const` does not. This is reflected in how TypeScript creates types for literals.\n\nts\n\n`let changingString = \"Hello World\";`\n\n`changingString = \"Olá Mundo\";`\n\n``// Because `changingString` can represent any possible string, that``\n\n`// is how TypeScript describes it in the type system`\n\n`changingString;`\n\n      `let changingString: string`\n\n`const constantString = \"Hello World\";`\n\n``// Because `constantString` can only represent 1 possible string, it``\n\n`// has a literal type representation`\n\n`constantString;`\n\n      `const constantString: \"Hello World\"`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAxgFghgOwOYEtkGUwCc1IgXggCIAJEYYAewgHVKtgATIgbgFgAoWRVDbXAsQDywAIcQAsgFcEjSq04B6RRABCIKHCkBnEBAAG3ZLkw5k+6IghYQABxu6EkRAE8Itytu0oARqAja-MgANBBg8GBKKijaEDCUAO4QACoutiDoUDi2kIwg2lm++RAokGhhMHpgaXraLoEgALacRrxIprjsHMoQAHoA-JwtlAiB0COBiGAdyIKk5FS09EwK3Srqmjp6hhNgUzNIFpoIECPAbjb2+SBOEACM7p7efrVBSKGlUXFwsXAQwKUQFg4MAwjVrHYHDc9mAUCNhqM9k4Dl0egMgA)\n\nBy themselves, literal types aren’t very valuable:\n\nts\n\n`let x: \"hello\" = \"hello\";`\n\n`// OK`\n\n`x = \"hello\";`\n\n`// ...`\n\n`x = \"howdy\";`\n\n`Type '\"howdy\"' is not assignable to type '\"hello\"'.2322Type '\"howdy\"' is not assignable to type '\"hello\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UAiAC0gILktAF5Qa6HKBufEUAeQDS+Miza16jHnj4A6eSLE04AdwAmAT25A)\n\nIt’s not much use to have a variable that can only have one value!\n\nBut by _combining_ literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:\n\nts\n\n`function printText(s: string, alignment: \"left\" | \"right\" | \"center\") {`\n\n  `// ...`\n\n`}`\n\n`printText(\"Hello, world\", \"left\");`\n\n`printText(\"G'day, mate\", \"centre\");`\n\n`Argument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'.2345Argument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFABmArgHYDGALgJZxmgAO0NZVAKpAB5UAUKoRFRZkA5gBpQAQwA2NUWQC2kNqgBEMyESprQAH1BqWogBY79hiiqow1ASlABvQqFAhQAOi+EAvoWasHNx8agASkDIycJIA7ggyACZqkhpaOnYA3P4iQTy8agDiAOQJUgCekopSNsmW1tCQ9hlAA)\n\nNumeric literal types work the same way:\n\nts\n\n`function compare(a: string, b: string): -1 | 0 | 1 {`\n\n  `return a === b ? 0 : a > b ? 1 : -1;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbADgQwE4FMAUmAXIgM5TYxgDmANIgEYnmU0CUJAtAIyIA+iAAz9EvAN4BYAFCJEeKCGxJMiALzrGiAPxDEJFQD5NO3l24BuaQF8gA)\n\nOf course, you can combine these with non-literal types:\n\nts\n\n`interface Options {`\n\n  `width: number;`\n\n`}`\n\n`function configure(x: Options | \"auto\") {`\n\n  `// ...`\n\n`}`\n\n`configure({ width: 100 });`\n\n`configure(\"auto\");`\n\n`configure(\"automatic\");`\n\n`Argument of type '\"automatic\"' is not assignable to parameter of type 'Options | \"auto\"'.2345Argument of type '\"automatic\"' is not assignable to parameter of type 'Options | \"auto\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACWAdgC4wBmAhgMaSgDyADmUXCYqAN6GigB3IgBMyAC1QkArgFsARjADchAL6FKUkrTYdQtDpSIBzKdEgAKAB6oWOzqAA+oAETUpZOM4CUPPqBCgAHTBqoT6JIYmZubcgiLiqACMAAzJoCpeygThkaYWru6emWEGxnnmBR4y1Gy03opAA)\n\nThere’s one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types `true` and `false`. The type `boolean` itself is actually just an alias for the union `true | false`.\n\n### [](#literal-inference)Literal Inference\n\nWhen you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:\n\nts\n\n`const obj = { counter: 0 };`\n\n`if (someCondition) {`\n\n  `obj.counter = 1;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEAwqsAJYYmoBc8ARkkhCFCgNwCwAUAPRfwC0AsAFcMAvp2TosSGgCt4AXngBvREiEoMIGNQAM8AL7sOJAGbwAFDnxEUpcqgCUKzvHgzZAOmQatMRfAAjMYGQA)\n\nTypeScript doesn’t assume the assignment of `1` to a field which previously had `0` is an error. Another way of saying this is that `obj.counter` must have the type `number`, not `0`, because types are used to determine both _reading_ and _writing_ behavior.\n\nThe same applies to strings:\n\nts\n\n`declare function handleRequest(url: string, method: \"GET\" | \"POST\"): void;`\n\n`const req = { url: \"https://example.com\", method: \"GET\" };`\n\n`handleRequest(req.url, req.method);`\n\n`Argument of type 'string' is not assignable to parameter of type '\"GET\" | \"POST\"'.2345Argument of type 'string' is not assignable to parameter of type '\"GET\" | \"POST\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOgAWlTRcpABKkAI4NIiVgAoG0cqmnR2TAOYAaUAFtIrHnCKoARAHEAogBVjoAD6hjABQDyAZWsBKVADc47IgDchISkXNKgNGKgALygAN6g8ooOPKysAA4oIJAAHpTa6UIAdKHaxlq6+oYmFtagAL5BBHwCQqISUrKRRUla3ZUGRB4BQA)\n\nIn the above example `req.method` is inferred to be `string`, not `\"GET\"`. Because code can be evaluated between the creation of `req` and the call of `handleRequest` which could assign a new string like `\"GUESS\"` to `req.method`, TypeScript considers this code to have an error.\n\nThere are two ways to work around this.\n\n1.  You can change the inference by adding a type assertion in either location:\n    \n    ts\n    \n    `// Change 1:`\n    \n    `const req = { url: \"https://example.com\", method: \"GET\" as \"GET\" };`\n    \n    `// Change 2`\n    \n    `handleRequest(req.url, req.method as \"GET\");`\n    \n    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAspVgIQAlEAR2RAGcMAKZGCALngZi1QHMAaeAFsQGAjmAcARAHEAogBUp8AD7wpABQDyAZSUBKDgDccWYAG4AsACgA9LfgBaZ2GQZnjm-fgBhInwQARjYbMDwGeDgqeABeeABveBZ2dQIMDAAHOjZ7EAAPKCEMsgA6MKEpQRExCWl5JXgoOnV65QBfKzsHP2JeBAAmG39SCmpaBkYokuTBKerxYEbm2UUpfXMgA)\n    \n    Change 1 means “I intend for `req.method` to always have the _literal type_ `\"GET\"`”, preventing the possible assignment of `\"GUESS\"` to that field after. Change 2 means “I know for other reasons that `req.method` has the value `\"GET\"`“.\n    \n2.  You can use `as const` to convert the entire object to be type literals:\n    \n    ts\n    \n    `const req = { url: \"https://example.com\", method: \"GET\" } as const;`\n    \n    `handleRequest(req.url, req.method);`\n    \n    [Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAspVgIQAlEAR2RAGcMAKZGCALngZi1QHMAaeAFsQGAjmAcARAHEAogBUp8AD7wpABQDyAZSUBKDgDccWYAG4AsACgA9LfgBaZ2GQZnjm2DwN4cKvAAvPAA3vAs7OoEGBgADnRs9iAAHlBCsWQAdN5CUoIiYhLS8krwAL7wUHTw3qgMVtZEJGSUNPRM-pkRgp0F4sD65kA)\n    \n\nThe `as const` suffix acts like `const` but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like `string` or `number`.\n\n## [](#null-and-undefined)`null` and `undefined`\n\nJavaScript has two primitive values used to signal absent or uninitialized value: `null` and `undefined`.\n\nTypeScript has two corresponding _types_ by the same names. How these types behave depends on whether you have the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) option on.\n\n### [](#strictnullchecks-off)`strictNullChecks` off\n\nWith [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) _off_, values that might be `null` or `undefined` can still be accessed normally, and the values `null` and `undefined` can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; we always recommend people turn [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) on if it’s practical to do so in their codebase.\n\n### [](#strictnullchecks-on)`strictNullChecks` on\n\nWith [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) _on_, when a value is `null` or `undefined`, you will need to test for those values before using methods or properties on that value. Just like checking for `undefined` before using an optional property, we can use _narrowing_ to check for values that might be `null`:\n\nts\n\n`function doSomething(x: string | null) {`\n\n  `if (x === null) {`\n\n    `// do nothing`\n\n  `} else {`\n\n    `console.log(\"Hello, \" + x.toUpperCase());`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAB4BciAzlAE6FGIA+iYIANhwJSIDeAWABQiRDGCJyiALyy2nHv2GjRAelUo4bOPkbLEAX0TYO1bEpEqICanA7YAdBzikARAAkTzgDSJXiAGpEMgcoOABVAAdI7DoAYQBDMxJubgBufQNhAyA)\n\n### [](#non-null-assertion-operator-postfix-)Non-null Assertion Operator (Postfix `!`)\n\nTypeScript also has a special syntax for removing `null` and `undefined` from a type without doing any explicit checking. Writing `!` after any expression is effectively a type assertion that the value isn’t `null` or `undefined`:\n\nts\n\n`function liveDangerously(x?: number | null) {`\n\n  `// No error`\n\n  `console.log(x!.toFixed());`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGxgNwKYBECGYDmGATnCAM7ICeAFAB4D8AXImCALYBGxiAPiyMmQBKRAG8AsAChEiAPSzEAOTiJiJIlJkQEZOMgwA6ZHHx0AhAahwAYjFoYAJtSFCA3FIC+QA)\n\nJust like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use `!` when you know that the value _can’t_ be `null` or `undefined`.\n\n## [](#enums)Enums\n\nEnums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is _not_ a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the [Enum reference page](https://www.typescriptlang.org/docs/handbook/enums.html).\n\n## [](#less-common-primitives)Less Common Primitives\n\nIt’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system. Though we will not go into depth here.\n\n#### [](#bigint)`bigint`\n\nFrom ES2020 onwards, there is a primitive in JavaScript used for very large integers, `BigInt`:\n\nts\n\n`// Creating a bigint via the BigInt function`\n\n`const oneHundred: bigint = BigInt(100);`\n\n`// Creating a BigInt via the literal syntax`\n\n`const anotherHundred: bigint = 100n;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGXBYAKCJFAGFZFpIBLAO3lGlACMb57JQA3G5yABaJQAIXYBJOlwBmAVzoBjWgHs6RBaoxdViABLyAJpQNo2HKaAC8oiVIAUARhw4AlAG4iJMBSq0GTG3hJLl5+IVAAGxpIRFhoCNAMAE8paAAPdU0uaDplQVj9OiNEE1Z2TitQJxw6NyA)\n\nYou can learn more about BigInt in [the TypeScript 3.2 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint).\n\n#### [](#symbol)`symbol`\n\nThere is a primitive in JavaScript used to create a globally unique reference via the function `Symbol()`:\n\nts\n\n`const firstName = Symbol(\"name\");`\n\n`const secondName = Symbol(\"name\");`\n\n`if (firstName === secondName) {`\n\n`This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.2367This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.    // Can't ever happen  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AsAFADGcAdogC6gBmAlkhQHICGAtpKALygDKAnqwBGcADYAKAESk2kCQEoA3IRLkqiSCoAmLdl14Dh4qTPlKChWtVBi6DHR06PQ6rfbmgA3oVCgQoAMLMpADkVJAAbjCgABbMAA5xkKSEAL5AA)\n\nYou can learn more about them in [Symbols reference page](https://www.typescriptlang.org/docs/handbook/symbols.html).",
    "title": "TypeScript: Documentation - Everyday Types",
    "description": "The language primitives.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html",
    "markdown": "# TypeScript: Documentation - Narrowing\n\nImagine we have a function called `padLeft`.\n\nts\n\n`function padLeft(padding: number | string, input: string): string {`\n\n  `throw new Error(\"Not implemented yet!\");`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkRQAFkzgB3ath0BRJpqb4ARADk4UQbWQAbbLWxgo2dIgCe2KAEJTkgG5FAF8gA)\n\nIf `padding` is a `number`, it will treat that as the number of spaces we want to prepend to `input`. If `padding` is a `string`, it should just prepend `padding` to `input`. Let’s try to implement the logic for when `padLeft` is passed a `number` for `padding`.\n\nts\n\n`function padLeft(padding: number | string, input: string): string {`\n\n  `return \" \".repeat(padding) + input;`\n\n`Argument of type 'string | number' is not assignable to parameter of type 'number'.   Type 'string' is not assignable to type 'number'.2345Argument of type 'string | number' is not assignable to parameter of type 'number'.   Type 'string' is not assignable to type 'number'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAA4CGAJgDKQEUAUTzzVJAOaoSRALYAjGKAA+oRBWgDBAGlAD6RCqgVKhASh2LloAN55QoaJApFodAESgHAOmv1Ijbr34HQAanUSTQoAbjwAXyA)\n\nUh-oh, we’re getting an error on `padding`. TypeScript is warning us that we’re passing a value with type `number | string` to the `repeat` function, which only accepts a `number`, and it’s right. In other words, we haven’t explicitly checked if `padding` is a `number` first, nor are we handling the case where it’s a `string`, so let’s do exactly that.\n\nts\n\n`function padLeft(padding: number | string, input: string): string {`\n\n  `if (typeof padding === \"number\") {`\n\n    `return \" \".repeat(padding) + input;`\n\n  `}`\n\n  `return padding + input;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkHBE+KAE9k2OGqIlyiALynEAIhoNm5yQuUrETbFBBMk5iwDpnO1AQNeOwBqQTBhKABuBwBfB2dXdxQMQzJEUKERaJigA)\n\nIf this mostly looks like uninteresting JavaScript code, that’s sort of the point. Apart from the annotations we put in place, this TypeScript code looks like JavaScript. The idea is that TypeScript’s type system aims to make it as easy as possible to write typical JavaScript code without bending over backwards to get type safety.\n\nWhile it might not look like much, there’s actually a lot going on under the covers here. Much like how TypeScript analyzes runtime values using static types, it overlays type analysis on JavaScript’s runtime control flow constructs like `if/else`, conditional ternaries, loops, truthiness checks, etc., which can all affect those types.\n\nWithin our `if` check, TypeScript sees `typeof padding === \"number\"` and understands that as a special form of code called a _type guard_. TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called _type guards_) and assignments, and the process of refining types to more specific types than declared is called _narrowing_. In many editors we can observe these types as they change, and we’ll even do so in our examples.\n\nts\n\n`function padLeft(padding: number | string, input: string): string {`\n\n  `if (typeof padding === \"number\") {`\n\n    `return \" \".repeat(padding) + input;`\n\n                        `(parameter) padding: number`\n\n  `}`\n\n  `return padding + input;`\n\n           `(parameter) padding: string`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkHBE+KAE9k2OGqIlyiALynEAIhoNm5yQuUrETbFBBMk5iwDpnO1AQNeOwBqQTBhKABuBxUAeljHRKTEgD0AfgcAXwdnV3cUDEMyRFChEWi4hNSMzKA)\n\nThere are a couple of different constructs TypeScript understands for narrowing.\n\n## [](#typeof-type-guards)`typeof` type guards\n\nAs we’ve seen, JavaScript supports a `typeof` operator which can give very basic information about the type of values we have at runtime. TypeScript expects this to return a certain set of strings:\n\n*   `\"string\"`\n*   `\"number\"`\n*   `\"bigint\"`\n*   `\"boolean\"`\n*   `\"symbol\"`\n*   `\"undefined\"`\n*   `\"object\"`\n*   `\"function\"`\n\nLike we saw with `padLeft`, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.\n\nIn TypeScript, checking against the value returned by `typeof` is a type guard. Because TypeScript encodes how `typeof` operates on different values, it knows about some of its quirks in JavaScript. For example, notice that in the list above, `typeof` doesn’t return the string `null`. Check out the following example:\n\nts\n\n`function printAll(strs: string | string[] | null) {`\n\n  `if (typeof strs === \"object\") {`\n\n    `for (const s of strs) {`\n\n`'strs' is possibly 'null'.18047'strs' is possibly 'null'.        console.log(s);      }    } else if (typeof strs === \"string\") {      console.log(strs);    } else {      // do nothing    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMBGUOAOABgBYB2AKADMBXAOwGMAXASzjtAAdoW6mBBADaCAFIiZJU4nnQDmoAD6hpvWQG0AuotB0awgJSgA3hVCgWVUCKYBPTpDiXpiUAF53oAERwARgCtIZk9DEzMzKgQrBnZxZVBHZQlEENMws2i6RDhBSAA6QThZMX0AblSzAF9UitBIQURIc0trOwcnJLcPTxU5YONy0AysnPzCsSTS6tr6xtCwkFAAEzgdOCYAC1VqigqgA)\n\nIn the `printAll` function, we try to check if `strs` is an object to see if it’s an array type (now might be a good time to reinforce that arrays are object types in JavaScript). But it turns out that in JavaScript, `typeof null` is actually `\"object\"`! This is one of those unfortunate accidents of history.\n\nUsers with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that `strs` was only narrowed down to `string[] | null` instead of just `string[]`.\n\nThis might be a good segue into what we’ll call “truthiness” checking.\n\n## [](#truthiness-narrowing)Truthiness narrowing\n\nTruthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript.\n\nIn JavaScript, we can use any expression in conditionals, `&&`s, `||`s, `if` statements, Boolean negations (`!`), and more. As an example, `if` statements don’t expect their condition to always have the type `boolean`.\n\nts\n\n`function getUsersOnlineMessage(numUsersOnline: number) {`\n\n  `if (numUsersOnline) {`\n\n    ``return `There are ${numUsersOnline} online now!`;``\n\n  `}`\n\n  `return \"Nobody's here. :(\";`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQKoGdUCcsDyYANjGKgLKpZYCGaAFGCALbZ6ElmoBcizLAEZ4AlIgDeAKESIYwRE1bt8RUuTFSZM3OhC4kAAwAqACzypEtHYgAk4gcs5rUAX0QJn-OAHcAhAYBuaUQXYJ0oPSQAIgA5OEE4ABMATwByLEQzHQA6RB4GKKCXIA)\n\nIn JavaScript, constructs like `if` first “coerce” their conditions to `boolean`s to make sense of them, and then choose their branches depending on whether the result is `true` or `false`. Values like\n\n*   `0`\n*   `NaN`\n*   `\"\"` (the empty string)\n*   `0n` (the `bigint` version of zero)\n*   `null`\n*   `undefined`\n\nall coerce to `false`, and other values get coerced to `true`. You can always coerce values to `boolean`s by running them through the `Boolean` function, or by using the shorter double-Boolean negation. (The latter has the advantage that TypeScript infers a narrow literal boolean type `true`, while inferring the first as type `boolean`.)\n\nts\n\n`// both of these result in 'true'`\n\n`Boolean(\"hello\"); // type: boolean, value: true`\n\n`!!\"world\"; // type: true,    value: true`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAECMHsBcAtUgM1HApgZ1aAThgrgDbSgCWAdqAOTTZ6qUBQAQpJAagIZkAUARLKgIFIvAJQBuUCBQBPAA6oAXBFbsuAGlAA3DgTrKadBgEJjvAO6RsBACa9J06PKUpaqTaE869Lw6iA)\n\nIt’s fairly popular to leverage this behavior, especially for guarding against values like `null` or `undefined`. As an example, let’s try using it for our `printAll` function.\n\nts\n\n`function printAll(strs: string | string[] | null) {`\n\n  `if (strs && typeof strs === \"object\") {`\n\n    `for (const s of strs) {`\n\n      `console.log(s);`\n\n    `}`\n\n  `} else if (typeof strs === \"string\") {`\n\n    `console.log(strs);`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRDGCIiJQogBkcxFACeyAKZxJVWQF49iAERwARgCs10AwJFixwOKikQExSok1NS10bbHOwhHA4agB0OHA0RHwA3D5iAL4+8YhqOIRq4pL4Kuoe2oh6OoZULFZCcYj+gcFhEdJesQnC8UA)\n\nYou’ll notice that we’ve gotten rid of the error above by checking if `strs` is truthy. This at least prevents us from dreaded errors when we run our code like:\n\ntxt\n\n`TypeError: null is not iterable`\n\nKeep in mind though that truthiness checking on primitives can often be error prone. As an example, consider a different attempt at writing `printAll`\n\nts\n\n`function printAll(strs: string | string[] | null) {`\n\n  `// !!!!!!!!!!!!!!!!`\n\n  `//  DON'T DO THIS!`\n\n  `//   KEEP READING`\n\n  `// !!!!!!!!!!!!!!!!`\n\n  `if (strs) {`\n\n    `if (typeof strs === \"object\") {`\n\n      `for (const s of strs) {`\n\n        `console.log(s);`\n\n      `}`\n\n    `} else if (typeof strs === \"string\") {`\n\n      `console.log(strs);`\n\n    `}`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRAHpxiAISy58hdNESpiACIB5AHIByACrqNiPQAkAkgGUlYyWMQBpAKKOACogBKjrGrNaA4sq2isFyyjDAiEQkhAIidojhkVAAnsgApnARVISIALz5iABEcABGAFZp0IWxyvHAcKiREAjElIiZTKQ18fHNYIRwOGkAdDhwNER8ANy1dgC+s3OIaTiEaQkR+CnpHdl5BYVULNVCs2J9A0Oj41FdM-ELYgtzQA)\n\nWe wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly.\n\nTypeScript doesn’t hurt us here at all, but this behavior is worth noting if you’re less familiar with JavaScript. TypeScript can often help you catch bugs early on, but if you choose to do _nothing_ with a value, there’s only so much that it can do without being overly prescriptive. If you want, you can make sure you handle situations like these with a linter.\n\nOne last word on narrowing by truthiness is that Boolean negations with `!` filter out from negated branches.\n\nts\n\n`function multiplyAll(`\n\n  `values: number[] | undefined,`\n\n  `factor: number`\n\n`): number[] | undefined {`\n\n  `if (!values) {`\n\n    `return values;`\n\n  `} else {`\n\n    `return values.map((x) => x * factor);`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwIJpoAUAUIogG4CGaIApgM4BciYIyARnQE4DaAuogA+icABM6wGGDpiANGUTAq0ONxZtOPEgEoN7Ln0Ejxk6bMQBvRTGCIiAQmq1GOq4vLc6UENyTP6BgBuRQBfRDo0Bjp3ck9vX38aQIA6ZCpMIiIADzcAXgA+RGzEAColFSg1HRDyUJJQoA)\n\n## [](#equality-narrowing)Equality narrowing\n\nTypeScript also uses `switch` statements and equality checks like `===`, `!==`, `==`, and `!=` to narrow types. For example:\n\nts\n\n`function example(x: string | number, y: string | boolean) {`\n\n  `if (x === y) {`\n\n    `// We can now call any 'string' method on 'x' or 'y'.`\n\n    `x.toUpperCase();`\n\n          `(method) String.toUpperCase(): string`\n\n    `y.toLowerCase();`\n\n          `(method) String.toLowerCase(): string`\n\n  `} else {`\n\n    `console.log(x);`\n\n               `(parameter) x: string | number`\n\n    `console.log(y);`\n\n               `(parameter) y: string | boolean`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUwB4EMC2AHANsgClQC5EBnKAJxjAHNEAfRMETAI2UoBpEBPUitTqNEbOHHzowASkQBvAFCJEMYIiKIAvNr6zFy5QHpDiAOrJEEKczgB3S+ly5EU3ogDkgmrXeJMyKAALOAATRAQPVF84Sg9edwA6JQNUBKg4AFVsbE4AYXQyQmkAbmSjEwA9AH4yvjS4ABk7PIKi0oNEY0Rq5IBfFFxC+VqIBDIJZATcOFoiEtqujqWejtGwcfwpmYJeeY7FpYMVxF6FXqA)\n\nWhen we checked that `x` and `y` are both equal in the above example, TypeScript knew their types also had to be equal. Since `string` is the only common type that both `x` and `y` could take on, TypeScript knows that `x` and `y` must be `string`s in the first branch.\n\nChecking against specific literal values (as opposed to variables) works also. In our section about truthiness narrowing, we wrote a `printAll` function which was error-prone because it accidentally didn’t handle empty strings properly. Instead we could have done a specific check to block out `null`s, and TypeScript still correctly removes `null` from the type of `strs`.\n\nts\n\n`function printAll(strs: string | string[] | null) {`\n\n  `if (strs !== null) {`\n\n    `if (typeof strs === \"object\") {`\n\n      `for (const s of strs) {`\n\n                       `(parameter) strs: string[]`\n\n        `console.log(s);`\n\n      `}`\n\n    `} else if (typeof strs === \"string\") {`\n\n      `console.log(strs);`\n\n                   `(parameter) strs: string`\n\n    `}`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRDGCIiJQogCEAXgXdeOASLFiJUqAE9kAUziSqspcoBEcAEYArA9AvrRmscDiopEBMUqJjTKTOrq4A9KEhkYgAegD8LpHeYIRwOAYAdDhwNER8ANwJmgC+hUWIBjiEBuKS+HqGAaaI5ogWVCxOQoViSSlpmdnSQQWR4VGacaUuJUVAA)\n\nJavaScript’s looser equality checks with `==` and `!=` also get narrowed correctly. If you’re unfamiliar, checking whether something `== null` actually not only checks whether it is specifically the value `null` - it also checks whether it’s potentially `undefined`. The same applies to `== undefined`: it checks whether a value is either `null` or `undefined`.\n\nts\n\n`interface Container {`\n\n  `value: number | null | undefined;`\n\n`}`\n\n`function multiplyValue(container: Container, factor: number) {`\n\n  `// Remove both 'null' and 'undefined' from the type.`\n\n  `if (container.value != null) {`\n\n    `console.log(container.value);`\n\n                           `(property) Container.value: number`\n\n    `// Now we can safely multiply 'container.value'.`\n\n    `container.value *= factor;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHtx1NZBvAKGWQDc4AbAVwgC5kRKBbAI1wB97LzzkPKQAJhBg4BAbgIBfAgRj8EYYJmSMuigA7kAngDUK1ABQJMYbCGh0MWHFAA0yeAvRQ6DFtACU+IsgD0v5AAlCEZ0EhRmdDAAC2QAcgZuOOQ4QXj+IRFzAWSYKHRGZBiUMC11CAA6H2AYZCMTM2gKsioUAEIAXk5uL0JiYmMQAGd0ckrydABzeutzKGb9CA8Jfr8A1Y3N1YA9AH4ZVf9kADl0AHdkM5QEVOQhuBgIbRU1YE0teMHTGwXWuKrVl9GvMWtRkAAqLqOMDOFbIaSSIA)\n\n## [](#the-in-operator-narrowing)The `in` operator narrowing\n\nJavaScript has an operator for determining if an object or its prototype chain has a property with a name: the `in` operator. TypeScript takes this into account as a way to narrow down potential types.\n\nFor example, with the code: `\"value\" in x`. where `\"value\"` is a string literal and `x` is a union type. The “true” branch narrows `x`’s types which have either an optional or required property `value`, and the “false” branch narrows to types which have an optional or missing property `value`.\n\nts\n\n`type Fish = { swim: () => void };`\n\n`type Bird = { fly: () => void };`\n\n`function move(animal: Fish | Bird) {`\n\n  `if (\"swim\" in animal) {`\n\n    `return animal.swim();`\n\n  `}`\n\n  `return animal.fly();`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw4dRAVwB2AY2Bw6aqPjo0IJAIZqCJ8cXjIoAHz6DGFDByhQ4o0gCJcBbx56ZhbiLm7uUAIQwCoCQeb4lgB0fvjknO4sSu5RMXFQwYniSRIg6RwsQA)\n\nTo reiterate, optional properties will exist in both sides for narrowing. For example, a human could both swim and fly (with the right equipment) and thus should show up in both sides of the `in` check:\n\nts\n\n`type Fish = { swim: () => void };`\n\n`type Bird = { fly: () => void };`\n\n`type Human = { swim?: () => void; fly?: () => void };`\n\n`function move(animal: Fish | Bird | Human) {`\n\n  `if (\"swim\" in animal) {`\n\n    `animal;`\n\n      `(parameter) animal: Fish | Human`\n\n  `} else {`\n\n    `animal;`\n\n      `(parameter) animal: Bird | Human`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuy7hoACQCu+AIYA7NJmx58AfmkVU1ekzZQJIE6TMX5rTh1FrtAY2Bw6u-HQ0ECQ6BJrixPDIUAA+fILMcepa2hQYHFBQcKKkAES4BLlZuqFa4mkZmVCl4ZwA9HWZAHpGlSxQEOII0OlV1dph4vWNUC1tHCxAA)\n\n## [](#instanceof-narrowing)`instanceof` narrowing\n\nJavaScript has an operator for checking whether or not a value is an “instance” of another value. More specifically, in JavaScript `x instanceof Foo` checks whether the _prototype chain_ of `x` contains `Foo.prototype`. While we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed with `new`. As you might have guessed, `instanceof` is also a type guard, and TypeScript narrows in branches guarded by `instanceof`s.\n\nts\n\n`function logValue(x: Date | string) {`\n\n  `if (x instanceof Date) {`\n\n    `console.log(x.toUTCString());`\n\n               `(parameter) x: Date`\n\n  `} else {`\n\n    `console.log(x.toUpperCase());`\n\n               `(parameter) x: string`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgcwGoENkgKYAUAHgFyIAiWUeiAPogM5QBOMYaAlIgN4BQiiGMETFBYJlkh44wytS58BAiAgZxkeAHSo0xTVDgBVACoBhAMos2ujhwDc-JQHonSt0oB6AfkcBfRHjIDDSKSiri6lo6egaGAA5xeMymWMEEtg5uLu7u3n68vkA)\n\n## [](#assignments)Assignments\n\nAs we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.\n\nts\n\n`let x = Math.random() < 0.5 ? 10 : \"hello world!\";`\n\n   `let x: string | number`\n\n`x = 1;`\n\n`console.log(x);`\n\n           `let x: number`\n\n`x = \"goodbye!\";`\n\n`console.log(x);`\n\n           `let x: string`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EFkCGYAWA6ATkgdgEwHsBbACgEoIAeCABnQFYIB+CARhogC4IAiVEYMAIQA7gUzA8AQh4BuAFAB6RRAgA9JvJjxWC+QGMCOAM4FQ6IQHMSUMguWrHT9Zu29LBAngBGATxAyeoYmZiAWBNa29irOThpAA)\n\nNotice that each of these assignments is valid. Even though the observed type of `x` changed to `number` after our first assignment, we were still able to assign a `string` to `x`. This is because the _declared type_ of `x` - the type that `x` started with - is `string | number`, and assignability is always checked against the declared type.\n\nIf we’d assigned a `boolean` to `x`, we’d have seen an error since that wasn’t part of the declared type.\n\nts\n\n`let x = Math.random() < 0.5 ? 10 : \"hello world!\";`\n\n   `let x: string | number`\n\n`x = 1;`\n\n`console.log(x);`\n\n           `let x: number`\n\n`x = true;`\n\n`Type 'boolean' is not assignable to type 'string | number'.2322Type 'boolean' is not assignable to type 'string | number'.  console.log(x);             let x: string | number  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABtIAXUAD1AF5QBZAQ0IAsA6aGgOwBM4BbACgEpQAHlAAGRgFZQAflABGEaFQAiepDx44oAO4I87AIRKA3DhChQAPSk4ylWSZwBjOK0RwCjDQHMeJPibNzIOCrGwpQQmgAV0gHZ1d3SE84Hz8AsGDMqyA)\n\n## [](#control-flow-analysis)Control flow analysis\n\nUp until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches. But there’s a bit more going on than just walking up from every variable and looking for type guards in `if`s, `while`s, conditionals, etc. For example\n\nts\n\n`function padLeft(padding: number | string, input: string) {`\n\n  `if (typeof padding === \"number\") {`\n\n    `return \" \".repeat(padding) + input;`\n\n  `}`\n\n  `return padding + input;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJSIA3gChEg4InxQAnsmxxlREuUQBeI4gBENBsxPT5ixU2xQQTJCdMA6e5tQFdvaQGpBMGEoAG4FRABfCPtHZxQMPTJEQKERcMigA)\n\n`padLeft` returns from within its first `if` block. TypeScript was able to analyze this code and see that the rest of the body (`return padding + input;`) is _unreachable_ in the case where `padding` is a `number`. As a result, it was able to remove `number` from the type of `padding` (narrowing from `string | number` to `string`) for the rest of the function.\n\nThis analysis of code based on reachability is called _control flow analysis_, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments. When a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point.\n\nts\n\n`function example() {`\n\n  `let x: string | number | boolean;`\n\n  `x = Math.random() < 0.5;`\n\n  `console.log(x);`\n\n             `let x: boolean`\n\n  `if (Math.random() < 0.5) {`\n\n    `x = \"hello\";`\n\n    `console.log(x);`\n\n               `let x: string`\n\n  `} else {`\n\n    `x = 100;`\n\n    `console.log(x);`\n\n               `let x: number`\n\n  `}`\n\n  `return x;`\n\n        `let x: string | number`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUwB4EMC2AHANsgCgEpEBvAKEUXykVQC5EBnKAJxjAHNEAfRMEJgBGyVr0RC4cfOjABucpTqIAvIgCy6KAAsAdK1kATOJmKIAPIgAMugKwKlEBE2nJduOJwKoiCqgHp-KmCQxAA9AH5FKhhgRAJNHX0jEzNLG1sSChDUVUQAIm1kXA98v2CnMBd8d09vXyUAoNCQyKUAXxRcJmQyRuU1AEYrK3KqSuq3Dy8fMcRAltaoqnboxFZkKBBWJFRyhaXydqA)\n\n## [](#using-type-predicates)Using type predicates\n\nWe’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.\n\nTo define a user-defined type guard, we simply need to define a function whose return type is a _type predicate_:\n\nts\n\n`function isFish(pet: Fish | Bird): pet is Fish {`\n\n  `return (pet as Fish).swim !== undefined;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw6MIAY3EBDAdFEBXAHYrgcOnqgBzCMADK+dePEAFS+WLxkUAD59BjTgHo-KABaEJUdYBCgjl0DIxMoRDckEkhgV0QUL34hMmJUhIRYDMwOKCgtYB0BUxTLKHVCpLIAOlwCKABCVHR9ZVE4PQhfDhYgA)\n\n`pet is Fish` is our type predicate in this example. A predicate takes the form `parameterName is Type`, where `parameterName` must be the name of a parameter from the current function signature.\n\nAny time `isFish` is called with some variable, TypeScript will _narrow_ that variable to that specific type if the original type is compatible.\n\nts\n\n`// Both calls to 'swim' and 'fly' are now okay.`\n\n`let pet = getSmallPet();`\n\n`if (isFish(pet)) {`\n\n  `pet.swim();`\n\n`} else {`\n\n  `pet.fly();`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw6MIAY3EBDAdFEBXAHYrgcOnqgBzCMADK+dePEAFS+WLxkUAD59BjTroNGJlCIbkgkkMCuiChe-EJkxBHBCLDRmBxQUFrAOgKm4ZZQ6imhZAB0uARQAISo6PrKonB6EL4cLBwA9J1QALT9KjrA-b1dPbx0wCgqduIpwHRQAOSV+EtFesxLEiDrmtB6dDhQdADW6iBlHOKFSegW1rb2TsDknBxwoqQh0QXAZBQMBkoBEKnh8G92lAIHNoEDMqCdpCWEA)\n\nNotice that TypeScript not only knows that `pet` is a `Fish` in the `if` branch; it also knows that in the `else` branch, you _don’t_ have a `Fish`, so you must have a `Bird`.\n\nYou may use the type guard `isFish` to filter an array of `Fish | Bird` and obtain an array of `Fish`:\n\nts\n\n`const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];`\n\n`const underWater1: Fish[] = zoo.filter(isFish);`\n\n`// or, equivalently`\n\n`const underWater2: Fish[] = zoo.filter(isFish) as Fish[];`\n\n`// The predicate may need repeating for more complex examples`\n\n`const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {`\n\n  `if (pet.name === \"sharkey\") return false;`\n\n  `return isFish(pet);`\n\n`});`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMBuKAOwEN8JiFgAnOGwDmUAL7MAUKEhQAQnH6M0mKADMANiGLkqtBi3Zce2AUNETJjCAGMNHftDUBXNjeBw6bKMIjAAyvgcGhoACn7kxPDIUAA+8ooski5uHl5QiNFIJJDAUYgo8QpKZMS5GQiwBZiSUFCOwM783jl+UByVWWQAdLgEUACEqOiu1mpCEElikgD0M1AAtEs2zsBLC5I2XnxQAF50dDpZcQklANoAuipnvgFBIeHA5AA0Pn6BwWERZK+3Hw-fC5SLZsHajCD8ADqHGAEIAjPlkJcVPs6N1xhpYfwSJkCmQpHMoHR+K8IABHZxwGjBCBsYBaTbbYBQcFQmEQgBMiKQyPQqPRcExEJxCC67U6BUuUlm8wAKkhoGBHIw4DZ2VAgiB2BBJvUIJAYeZ1MSNcToFt8GANBAAB5QW1cK0QBCM0HM1nQrEAZm5vL2BwFQuxrWApSg5UQVRiqGoGFqGTUpFy3U43DQwygACJkA4ANYQECZigNJreNTBBAQKR1EvNCpZEP4yRifFAA)\n\nIn addition, classes can [use `this is Type`](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-based-type-guards) to narrow their type.\n\n## [](#assertion-functions)Assertion functions\n\nTypes can also be narrowed using [Assertion functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions).\n\n## [](#discriminated-unions)Discriminated unions\n\nMost of the examples we’ve looked at so far have focused around narrowing single variables with simple types like `string`, `boolean`, and `number`. While this is common, most of the time in JavaScript we’ll be dealing with slightly more complex structures.\n\nFor some motivation, let’s imagine we’re trying to encode shapes like circles and squares. Circles keep track of their radiuses and squares keep track of their side lengths. We’ll use a field called `kind` to tell which shape we’re dealing with. Here’s a first attempt at defining `Shape`.\n\nts\n\n`interface Shape {`\n\n  `kind: \"circle\" | \"square\";`\n\n  `radius?: number;`\n\n  `sideLength?: number;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyA1qACYBcyARAsFAgDYTXIA+NAzgI4CucUFgG5CyKHDLBenAPxUQvALYAjaCKKdgZCABkIIAOZh0c5ApVr8AXyA)\n\nNotice we’re using a union of string literal types: `\"circle\"` and `\"square\"` to tell us whether we should treat the shape as a circle or square respectively. By using `\"circle\" | \"square\"` instead of `string`, we can avoid misspelling issues.\n\nts\n\n`function handleShape(shape: Shape) {`\n\n  `// oops!`\n\n  `if (shape.kind === \"rect\") {`\n\n`This comparison appears to be unintentional because the types '\"circle\" | \"square\"' and '\"rect\"' have no overlap.2367This comparison appears to be unintentional because the types '\"circle\" | \"square\"' and '\"rect\"' have no overlap.      // ...    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAJYB2ALjAGYCGAxpKAMoAWlADnQN56igDWxAJqgBE1AtGoAbSENAAfUEMQBHAK6Vo0gNxdQ0SvwIrEAflREVAWwBGMbd0QF+kADKQiAcxKNToc9dt4AL54eCCgALSR1CokkeF45CpE1CQEcESgzET8UkyskAAUiMxsqHlsAJSgnNxhcHAsiACEOgTkoEUlkAB0fNmgALxDChopQlU13KBh3bM6wYFAA)\n\nWe can write a `getArea` function that applies the right logic based on if it’s dealing with a circle or square. We’ll first try dealing with circles.\n\nts\n\n`function getArea(shape: Shape) {`\n\n  `return Math.PI * shape.radius ** 2;`\n\n`'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoASwDsAXGAMwEMBjSUAZQAsmAHdgN7lQoANY0AJqgBELStBYAbSNNAAfUNMQBHAK5NoKgNzDQ0JhMq7EAflTVdAWwBGMEyMSUJkADKRqAOa0XHagDi5u5AC+5OQgoAC0SSy6tEkJ5Ay61Cy0lHDUoAGQtACChkwAFIg8-KjcfJAAlKBCIoa0utCFALJMwQB0AAoAkqAAVKA1jQPmltYTk2gmUUA)\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) that gives us an error - which is appropriate since `radius` might not be defined. But what if we perform the appropriate checks on the `kind` property?\n\nts\n\n`function getArea(shape: Shape) {`\n\n  `if (shape.kind === \"circle\") {`\n\n    `return Math.PI * shape.radius ** 2;`\n\n`'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoASwDsAXGAMwEMBjSUAZQAsmAHdgN7lQoANY0AJqgBELStBYAbSNNAAfUNMQBHAK5NoKgNzDQ0JhMq7EAflTVdAWwBGMEyMSUJkADKRqAOa0XHagDi5u5AC+5OQgoAC0SSy6tEkJ5Ay61Cy0lHDUoAGQtACChkwAFIg8-KjcfJAAlKBCIpQMoNW1kAB04tQSoAC8o5pyCsrSLW0iZiW60IUAskzBvQAKAJKgAFSgNY295pbWe-to7qAxUUA)\n\nHmm, TypeScript still doesn’t know what to do here. We’ve hit a point where we know more about our values than the type checker does. We could try to use a non-null assertion (a `!` after `shape.radius`) to say that `radius` is definitely present.\n\nts\n\n`function getArea(shape: Shape) {`\n\n  `if (shape.kind === \"circle\") {`\n\n    `return Math.PI * shape.radius! ** 2;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyA1qACYBcyARAsFAgDYTXIA+NAzgI4CucUFgG5CyKHDLBenAPxUQvALYAjaCKKdgZCABkIIAOZh0c5ApVr8AX3z4A9HeQBaFwl5gXT-DF4gEYYAB7EGQDCDAAQUE4AApOTBwqDGwIAEpkAiJgGGQ4hIgAOlIQMmQAXgqaOgZmanTMojFw3igQgFk4YwKABQBJZAAqZHiUgvFJaQBCQaGAJnVkGysgA)\n\nBut this doesn’t feel ideal. We had to shout a bit at the type-checker with those non-null assertions (`!`) to convince it that `shape.radius` was defined, but those assertions are error-prone if we start to move code around. Additionally, outside of [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) we’re able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them). We can definitely do better.\n\nThe problem with this encoding of `Shape` is that the type-checker doesn’t have any way to know whether or not `radius` or `sideLength` are present based on the `kind` property. We need to communicate what _we_ know to the type checker. With that in mind, let’s take another swing at defining `Shape`.\n\nts\n\n`interface Circle {`\n\n  `kind: \"circle\";`\n\n  `radius: number;`\n\n`}`\n\n`interface Square {`\n\n  `kind: \"square\";`\n\n  `sideLength: number;`\n\n`}`\n\n`type Shape = Circle | Square;`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1JiA)\n\nHere, we’ve properly separated `Shape` out into two types with different values for the `kind` property, but `radius` and `sideLength` are declared as required properties in their respective types.\n\nLet’s see what happens here when we try to access the `radius` of a `Shape`.\n\nts\n\n`function getArea(shape: Shape) {`\n\n  `return Math.PI * shape.radius ** 2;`\n\n`Property 'radius' does not exist on type 'Shape'.   Property 'radius' does not exist on type 'Square'.2339Property 'radius' does not exist on type 'Shape'.   Property 'radius' does not exist on type 'Square'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBLAOwBcYAzAQwGNJQBhfaKgG1oG9dRQBrIgE1QAiKoxaRBAbk6hoFPvgCuKUIQUBbAEYwpAX1wES5arQDKARwUVo7ab0IDQgxBavipXRPj6QAMpEIA5sQAFqiqmtq4erjEAJ4ADqbBFImgALz0oqygAD6g5pbWUrggoAC0FVQKxBVluGQKhFTE+HCEoAGQxACC1hQAFIjJiagmw5AAlKAcXNbECtDtALIUIQB0AAoAkqAAVKBDKZBrsvJKe-toukA)\n\nLike with our first definition of `Shape`, this is still an error. When `radius` was optional, we got an error (with [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) enabled) because TypeScript couldn’t tell whether the property was present. Now that `Shape` is a union, TypeScript is telling us that `shape` might be a `Square`, and `Square`s don’t have `radius` defined on them! Both interpretations are correct, but only the union encoding of `Shape` will cause an error regardless of how [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is configured.\n\nBut what if we tried checking the `kind` property again?\n\nts\n\n`function getArea(shape: Shape) {`\n\n  `if (shape.kind === \"circle\") {`\n\n    `return Math.PI * shape.radius ** 2;`\n\n                      `(parameter) shape: Circle`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1FnwAejjkAFoUhC4wFKT8GC4QBDBgAHsQZGsIMABBdTgACh5fbyoFBogASmQCImAYZDqWgDotMkCAoNoQxnbOojZyrigSgFk4e36ABQBJZAAqZHq-CH72Tl4d3YAmIxmEmdu7mYA9AH5WSXEgA)\n\nThat got rid of the error! When every type in a union contains a common property with literal types, TypeScript considers that to be a _discriminated union_, and can narrow out the members of the union.\n\nIn this case, `kind` was that common property (which is what’s considered a _discriminant_ property of `Shape`). Checking whether the `kind` property was `\"circle\"` got rid of every type in `Shape` that didn’t have a `kind` property with the type `\"circle\"`. That narrowed `shape` down to the type `Circle`.\n\nThe same checking works with `switch` statements as well. Now we can try to write our complete `getArea` without any pesky `!` non-null assertions.\n\nts\n\n`function getArea(shape: Shape) {`\n\n  `switch (shape.kind) {`\n\n    `case \"circle\":`\n\n      `return Math.PI * shape.radius ** 2;`\n\n                        `(parameter) shape: Circle`\n\n    `case \"square\":`\n\n      `return shape.sideLength ** 2;`\n\n              `(parameter) shape: Square`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1FnwAejjkAFoUhC4wFKT8GC4QBDBgAHsQZGsIMABBdTgACh5fbyoFBogASmQCYwB3YDAEO2Q6loA6LTJ2zqJkBDgeFFoQxgpWKbZyrigSgFk4e2GABQBJZAAqZHq-CGH2Tl5Ts4AmIymE1bf3ogA9AH4V6dn5npoks-kR1GANiULt5hiYzJYbPZ7sgnn9Xu8fqxJOIgA)\n\nThe important thing here was the encoding of `Shape`. Communicating the right information to TypeScript - that `Circle` and `Square` were really two separate types with specific `kind` fields - was crucial. Doing that lets us write type-safe TypeScript code that looks no different than the JavaScript we would’ve written otherwise. From there, the type system was able to do the “right” thing and figure out the types in each branch of our `switch` statement.\n\n> As an aside, try playing around with the above example and remove some of the return keywords. You’ll see that type-checking can help avoid bugs when accidentally falling through different clauses in a `switch` statement.\n\nDiscriminated unions are useful for more than just talking about circles and squares. They’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client/server communication), or encoding mutations in a state management framework.\n\n## [](#the-never-type)The `never` type\n\nWhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a `never` type to represent a state which shouldn’t exist.\n\n## [](#exhaustiveness-checking)Exhaustiveness checking\n\nThe `never` type is assignable to every type; however, no type is assignable to `never` (except `never` itself). This means you can use narrowing and rely on `never` turning up to do exhaustive checking in a `switch` statement.\n\nFor example, adding a `default` to our `getArea` function which tries to assign the shape to `never` will not raise an error when every possible case has been handled.\n\nts\n\n`type Shape = Circle | Square;`\n\n`function getArea(shape: Shape) {`\n\n  `switch (shape.kind) {`\n\n    `case \"circle\":`\n\n      `return Math.PI * shape.radius ** 2;`\n\n    `case \"square\":`\n\n      `return shape.sideLength ** 2;`\n\n    `default:`\n\n      `const _exhaustiveCheck: never = shape;`\n\n      `return _exhaustiveCheck;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJ+APRvkAWh8IuYHy98MABPAAdFOzgI5ABeNHocZAAfZGVVdRZ8GC4QBDBgAHsQZGsIMABBdTgACh4oiKoFBogASmQCYwB3YDAEO2Q6loA6LTJ2zqJkBDgeFFpExgpWKbZyrigSgFk4e2GABQBJZAAqZHroiGH2Tl5Ts4AmIymZud19dWpl1aJ1MA2ShcIsMTGZLDZ7PdkE8VsgzPAuFgwN8fghijwwMgAPoQAAeUV4BQAbhBUHYIAhiPwICSoHFzi1nqs-gDsXiCRjgCSyRTiM9JOIgA)\n\nAdding a new member to the `Shape` union, will cause a TypeScript error:\n\nts\n\n`interface Triangle {`\n\n  `kind: \"triangle\";`\n\n  `sideLength: number;`\n\n`}`\n\n`type Shape = Circle | Square | Triangle;`\n\n`function getArea(shape: Shape) {`\n\n  `switch (shape.kind) {`\n\n    `case \"circle\":`\n\n      `return Math.PI * shape.radius ** 2;`\n\n    `case \"square\":`\n\n      `return shape.sideLength ** 2;`\n\n    `default:`\n\n      `const _exhaustiveCheck: never = shape;`\n\n`Type 'Triangle' is not assignable to type 'never'.2322Type 'Triangle' is not assignable to type 'never'.        return _exhaustiveCheck;    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAGE9pKAbGgbx1FAGtCATVAESUGzSAIDcHUNHK88AVxSgC8gLYAjGJIC+OfMTJUaAZQCO88tDZSeBfqAGJzlsZM6I8vSABlIBAOZEABaoKhpaOLogoAC0cZTyRHEx+iTQFNSgACrQeOQBLKDsnLb2AkS5+f4sElIeXr4BwaFqmtA6ekQAngAOJkHkfaAAvHQihQA+oGYWVqBTOXkFkJI4pPIElER4cASg-pBEAIJW5AAUiAN9qMZXkACURXUA7nhElEGgF3cAdKWPxU4oEo5EQNCE4zEyCkQOkh3k0D2AFlyMEfgAFACSoAAVKBLoNID8ZHJFLi8Wg3ECQWCHE5ZlCYUCrEQEXsCX0fvUfH5Ap8cRSqZwvBR5EwiNDYZxKLtEERQAB9SAADwGim2ADdILQgpBKFxQpAtdARvi7kLmfDEYqVWq5XgtTq9VwqbptEA)",
    "title": "TypeScript: Documentation - Narrowing",
    "description": "Understand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html",
    "markdown": "# TypeScript: Documentation - More on Functions\n\nFunctions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class. They’re also values, and just like other values, TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions.\n\n## [](#function-type-expressions)Function Type Expressions\n\nThe simplest way to describe a function is with a _function type expression_. These types are syntactically similar to arrow functions:\n\nts\n\n`function greeter(fn: (a: string) => void) {`\n\n  `fn(\"Hello, World\");`\n\n`}`\n\n`function printToConsole(s: string) {`\n\n  `console.log(s);`\n\n`}`\n\n`greeter(printToConsole);`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFMMALkVwENiBnKVGMZASkQF4A+RANzhgBNGBvALAAoRIgK4ARAAl0AG1lwANIgDqcVLO4T6AbmEBfYcNCRYCRAAcaYKABU4AYQQU4s9LgqVqtBokEjECGdXdAA6BWQPXQMjITRMbDwrWjtHYLddIA)\n\nThe syntax `(a: string) => void` means “a function with one parameter, named `a`, of type `string`, that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly `any`.\n\n> Note that the parameter name is **required**. The function type `(string) => void` means “a function with a parameter named `string` of type `any`“!\n\nOf course, we can use a type alias to name a function type:\n\nts\n\n`type GreetFunction = (a: string) => void;`\n\n`function greeter(fn: GreetFunction) {`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwBiBXAdgY2ASwPbpQC8UAFAIYBcUAzsHDugOYCUxAfFAG544AmAbgCwAKABmGbPkJMESCHFJj01eIhSTcBNgG9RUKAHpDUAHTnRAXyA)\n\n## [](#call-signatures)Call Signatures\n\nIn JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a _call signature_ in an object type:\n\nts\n\n`type DescribableFunction = {`\n\n  `description: string;`\n\n  `(someArg: number): boolean;`\n\n`};`\n\n`function doSomething(fn: DescribableFunction) {`\n\n  `console.log(fn.description + \" returned \" + fn(6));`\n\n`}`\n\n`function myFunc(someArg: number) {`\n\n  `return someArg > 3;`\n\n`}`\n\n`myFunc.description = \"default description\";`\n\n`doSomething(myFunc);`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAIhDOBjATgSwEYEN0BsIDEBXAO0WFQHtioBeKAbwFgAoKKAEwRVTHKoC4o8YGmIBzANws2ACngUAthACCyMYOKEF6CMgCUg9BQp5MxKcwC+FgGYkylauwoBlRRGAALVOJk3ignBIaFi4BPZ8xHoM0lCIVPJ4AHQ4FGJ+xEmcwTyRUADUUABEUMgehMjEEOzFBVD+MgBsenoWliwsdqR5CiBEpHLuqupQmtq60UyspeWVQkNqUAB8UADMbSy9-YhZXGi8jrTFnDaYhDjAHHu5jkUWLM5uSl4+6Vv2rUA)\n\nNote that the syntax is slightly different compared to a function type expression - use `:` between the parameter list and the return type rather than `=>`.\n\n## [](#construct-signatures)Construct Signatures\n\nJavaScript functions can also be invoked with the `new` operator. TypeScript refers to these as _constructors_ because they usually create a new object. You can write a _construct signature_ by adding the `new` keyword in front of a call signature:\n\nts\n\n`type SomeConstructor = {`\n\n  `new (s: string): SomeObject;`\n\n`};`\n\n`function fn(ctor: SomeConstructor) {`\n\n  `return new ctor(\"hello\");`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgeQEYCsIGNhQLxQCGAdiANwCwAUAPQ1QC0TWArsEw9aJLIhAMJxiAZ2AAnFjjhj8UAN7UoUYhADuUABTCAXFFFiAlsQDmASl3wkaTDkpUAvnYBmLYjgNCoT4hqliLfIIi4pLA0qbyilBiEMAsYsTKalB+GgBEABYQADbZcGmmdvZAA)\n\nSome objects, like JavaScript’s `Date` object, can be called with or without `new`. You can combine call and construct signatures in the same type arbitrarily:\n\nts\n\n`interface CallOrConstruct {`\n\n  `(n?: number): string;`\n\n  `new (s: string): Date;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJwDYYPJVQexAGcwoBXBMZAbwFgAoZZAChAH4AuZEMgWwCNoASi4kooAOYBuBkxAQA7iyKjSkkcgAicSDPoBfIA)\n\n## [](#generic-functions)Generic Functions\n\nIt’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:\n\nts\n\n`function firstElement(arr: any[]) {`\n\n  `return arr[0];`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAFAIaqoBci5YAngNoC6AlIgN4CwAUIolR4oIVEkqomABhYBuPgF8gA)\n\nThis function does its job, but unfortunately has the return type `any`. It’d be better if the function returned the type of the array element.\n\nIn TypeScript, _generics_ are used when we want to describe a correspondence between two values. We do this by declaring a _type parameter_ in the function signature:\n\nts\n\n`function firstElement<Type>(arr: Type[]): Type | undefined {`\n\n  `return arr[0];`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAPACoCeADngHwAUAhqqgFyJW0DaAugJQcueRAB9E4ACZ4UYPJMQBvALAAoRIlR4oIVEhapuABl4BuNQF8gA)\n\nBy adding a type parameter `Type` to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:\n\nts\n\n`// s is of type 'string'`\n\n`const s = firstElement([\"a\", \"b\", \"c\"]);`\n\n`// n is of type 'number'`\n\n`const n = firstElement([1, 2, 3]);`\n\n`// u is of type undefined`\n\n`const u = firstElement([]);`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVKxgGcMBRCEAWxFQwB4AVATwAcQA+AClhgC55mbANoBdAJT9BCAD7w0oRFlQhgAbgCwAKAD02+AFpDYZBkP6tu+EXhZrORPAysEAchIwlAcxdaweElbwALwExGQU1LScQgBEUDEANPAxAEaJyWAx4ho6evi28PaOzvAuqMiUKSAwPpp+qAH4IYph5FQ0GNEAjEkATEkAzNkWesg2dg5ObHKoCkoqvv4YcsGhJG2RnaJiqkA)\n\n### [](#inference)Inference\n\nNote that we didn’t have to specify `Type` in this sample. The type was _inferred_ - chosen automatically - by TypeScript.\n\nWe can use multiple type parameters as well. For example, a standalone version of `map` would look like this:\n\nts\n\n`function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {`\n\n  `return arr.map(func);`\n\n`}`\n\n`// Parameter 'n' is of type 'string'`\n\n`// 'parsed' is of type 'number[]'`\n\n`const parsed = map([\"1\", \"2\", \"3\"], (n) => parseInt(n));`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYFgAoAMwFdMBjRbTUAWwENwAeASU3BNgBpQB5TjrAB8ACnqRIALlBtBAbQC6PUhWljI6abM4BKUAF4hfAbun9Y8haADehUKBiwSkGuMgA6BuBEryOgNyEAL6EhCCgAAri9LRwyKAA5JgJoAgAzqDYRKCwAJ7g0IlpsJAImOgJYWAJ4OJp0AAmKemZ2XkFiZgktABGyIqVBOTUxRB1jQZ0jCJyAEQAjLM8swBMS6CzAMyzSqAimHqGY5D1bLD7OgFAA)\n\nNote that in this example, TypeScript could infer both the type of the `Input` type parameter (from the given `string` array), as well as the `Output` type parameter based on the return value of the function expression (`number`).\n\n### [](#constraints)Constraints\n\nWe’ve written some generic functions that can work on _any_ kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a _constraint_ to limit the kinds of types that a type parameter can accept.\n\nLet’s write a function that returns the longer of two values. To do this, we need a `length` property that’s a number. We _constrain_ the type parameter to that type by writing an `extends` clause:\n\nts\n\n`function longest<Type extends { length: number }>(a: Type, b: Type) {`\n\n  `if (a.length >= b.length) {`\n\n    `return a;`\n\n  `} else {`\n\n    `return b;`\n\n  `}`\n\n`}`\n\n`// longerArray is of type 'number[]'`\n\n`const longerArray = longest([1, 2], [1, 2, 3]);`\n\n`// longerString is of type 'alice' | 'bob'`\n\n`const longerString = longest(\"alice\", \"bob\");`\n\n`// Error! Numbers don't have a 'length' property`\n\n`const notOK = longest(10, 100);`\n\n`Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdG00BYAKADMBXAOwGMAXASzitABtmBzSROgHgBUAngAdIoSAA86kKgBNEoAN5sZHOgAtUVCgFsARjFABfAHwAKAIaohogDSg91kZACUS0qFAMyoSwDpWVQ1QEwBeBwCg9TdFD09QaEg6CmgWCwBuOKNxVkQxWJJ4hKSUlj1MwuNSI1JSEDZOGABBWAtBLwU4HzpnUABybX0YAG0AXT7SGmYeBqouaBboNtBw9jnuOjNhgEZ7NFH7Hb37DFGXCvq1+YBlOmgGOY7QLtAe0X6LVgYaSD7QAB9+no4HoJiQplQZlcYLd7o9Vo0eGYAESfb6QZH2ZHAvTI851MAAUVgCAAhKAAHK6AxIUCyZh9OigdQWABuYgs-UCcw0f2E8FE0B6k2mTKocDoAHkANIrWZcJHbAAM9mVSvOQA)\n\nThere are a few interesting things to note in this example. We allowed TypeScript to _infer_ the return type of `longest`. Return type inference also works on generic functions.\n\nBecause we constrained `Type` to `{ length: number }`, we were allowed to access the `.length` property of the `a` and `b` parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.\n\nThe types of `longerArray` and `longerString` were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!\n\nFinally, just as we’d like, the call to `longest(10, 100)` is rejected because the `number` type doesn’t have a `.length` property.\n\n### [](#working-with-constrained-values)Working with Constrained Values\n\nHere’s a common error when working with generic constraints:\n\nts\n\n`function minimumLength<Type extends { length: number }>(`\n\n  `obj: Type,`\n\n  `minimum: number`\n\n`): Type {`\n\n  `if (obj.length >= minimum) {`\n\n    `return obj;`\n\n  `} else {`\n\n    `return { length: minimum };`\n\n`Type '{ length: number; }' is not assignable to type 'Type'.   '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.   '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAzAVwDsBjAFwEs4TQBbKkq+o+gGUhIHMKALADwAVAJ4AHSKEgAPClwAmiUAG9QAGy68+qEmwBGMUAF8AfAAp8oUHD0ArVKIkAaSwyYs2O-THwBKB+KSyq5UBKBmNrYAdBo8-KAmALxuzKz0viquVtCQFETQdJEA3K5GUmqIQVmgOXkFKuqa-KiMqWzGJXhWRvhGQA)\n\nIt might look like this function is OK - `Type` is constrained to `{ length: number }`, and the function either returns `Type` or a value matching that constraint. The problem is that the function promises to return the _same_ kind of object as was passed in, not just _some_ object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:\n\nts\n\n`// 'arr' gets value { length: 6 }`\n\n`const arr = minimumLength([1, 2, 3], 6);`\n\n`// and crashes here because arrays have`\n\n`// a 'slice' method, but not the returned object!`\n\n`console.log(arr.slice(0));`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFstUsDkCAZEVAcwwAsAeAFQE8AHBEADw2uADO8AN7wI1OvQBc8VOQBGIGPAC+APgAUAWABQ8eDnkArGW04AaXfqIkyBGXIKKYugJSmOIANy6A9L-gAWmCwZAxgwL8AgHJYGGj4GhAMIQA3KAhkBFFxWgYZADZVXTA8AQx4OPgAXkJiUnIqPPoNAG0ARnN4ACYugGYAXS6C1x8df0rUYHgwGCgBehAhRbh4RTAoZAEEOKhWZahUkCjK+GiBCCwwEASCZPocYC75MNkcCoYEOAxkGFQQaaGIzgDAAQhKZRw4gAdBAcDQNHFoRcriANAAGVyjIA)\n\n### [](#specifying-type-arguments)Specifying Type Arguments\n\nTypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:\n\nts\n\n`function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {`\n\n  `return arr1.concat(arr2);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbARjMBTAPAFQE8AHbAPgAoBDAJxoEYAuRI0gbQF0AaRWmgJmatsnAJRCSIjogDeAWABQiRDWxQQNJH3oA6FJCpRqdfqIDcigL5A)\n\nNormally it would be an error to call this function with mismatched arrays:\n\nts\n\n`const arr = combine([1, 2, 3], [\"hello\"]);`\n\n`Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgATSAYwBsBDaSUAMwFcA7YgFwEs4HRi4BbAI1YNIAHgAqATwAOkAHwAKStACMqCdIDaAXQA0oRWlVTIWgJSGNmgNz4QoALQPidZg7v5uDRMz2xQAXi5eASE5dSVdNF0MHVB1ACIAC0hSUjg4zRNLIA)\n\nIf you intended to do this, however, you could manually specify `Type`:\n\nts\n\n`const arr = combine<string | number>([1, 2, 3], [\"hello\"]);`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXzBwFsAjLVEAHgBUBPABxAD4AKWGARgC547GBtALoAaeOwBMPPiCEBKKQxmCA3AFgAUAHpN8ALT6wyDPt0bCqAM4YxMGPAC8BYmQqUrMcgHN4AH3ipkUhAYVn4OUXFRAGYReH4AIgALEAgIHHjBWWUgA)\n\n### [](#guidelines-for-writing-good-generic-functions)Guidelines for Writing Good Generic Functions\n\nWriting generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.\n\n#### [](#push-type-parameters-down)Push Type Parameters Down\n\nHere are two ways of writing a function that appear similar:\n\nts\n\n`function firstElement1<Type>(arr: Type[]) {`\n\n  `return arr[0];`\n\n`}`\n\n`function firstElement2<Type extends any[]>(arr: Type) {`\n\n  `return arr[0];`\n\n`}`\n\n`// a: number (good)`\n\n`const a = firstElement1([1, 2, 3]);`\n\n`// b: any (bad)`\n\n`const b = firstElement2([1, 2, 3]);`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAjADwAqAngA54B8AFAIaqoBciN9A2gLoBKRAG8AsAChEiVHighUSNql4AGfgG5JAX0mTQkWAmRpMuQsSgAmKnTyI8ADyjEAJukQsw1Ac2VcePGFxKRk5BSV2NU0dPQkAenjPLjAQAgAjPFREJgBzODhXQUkIBExPRABeEwxsfCISUiZeUgAaRCt2gGYhLQSk9K4vahz0liKSsqhEdKqas3rLK2a2ju7eoA)\n\nThese might seem identical at first glance, but `firstElement1` is a much better way to write this function. Its inferred return type is `Type`, but `firstElement2`’s inferred return type is `any` because TypeScript has to resolve the `arr[0]` expression using the constraint type, rather than “waiting” to resolve the element during a call.\n\n> **Rule**: When possible, use the type parameter itself rather than constraining it\n\n#### [](#use-fewer-type-parameters)Use Fewer Type Parameters\n\nHere’s another pair of similar functions:\n\nts\n\n`function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {`\n\n  `return arr.filter(func);`\n\n`}`\n\n`function filter2<Type, Func extends (arg: Type) => boolean>(`\n\n  `arr: Type[],`\n\n  `func: Func`\n\n`): Type[] {`\n\n  `return arr.filter(func);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAbKBTATgRgDwAqAngA4YB8AFAIZZYBcixZA2gLoA0y4EjNWAc0bMMASkQBecogBGcOKgzUwo4aQztEAbwCwAKESIsGKCCxJaWAHQp02SqEiiA3PoC++-Y+jwktzFgATITqXABiPIgYAB6YYAAmAM6I-EJM6uJSsvKKylT6hpZqrJwF3JCMEZD6qukl2mXGpuaIljZoAQ48Lu5AA)\n\nWe’ve created a type parameter `Func` that _doesn’t relate two values_. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. `Func` doesn’t do anything but make the function harder to read and reason about!\n\n> **Rule**: Always use as few type parameters as possible\n\n#### [](#type-parameters-should-appear-twice)Type Parameters Should Appear Twice\n\nSometimes we forget that a function might not need to be generic:\n\nts\n\n`function greet<Str extends string>(s: Str) {`\n\n  `console.log(\"Hello, \" + s);`\n\n`}`\n\n`greet(\"world\");`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QDwGUqqLoAeU6YAJgM6JUExjIB8AFFQFyL6oCUiA3gFgAUIkQQEVOABt0AOmlxkLAEQAJdNMUAaRCsQBqWjwDcIgL4iRaTFFUB3OKmkUVpoA)\n\nWe could just as easily have written a simpler version:\n\nts\n\n`function greet(s: string) {`\n\n  `console.log(\"Hello, \" + s);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQGcBciuUqMYyAlIgN4CwAUIohArnADboB07cy2AIgAS6drwA0iAYgDURCgG4GAXyA)\n\nRemember, type parameters are for _relating the types of multiple values_. If a type parameter is only used once in the function signature, it’s not relating anything. This includes the inferred return type; for example, if `Str` was part of the inferred return type of `greet`, it would be relating the argument and return types, so would be used _twice_ despite appearing only once in the written code.\n\n> **Rule**: If a type parameter only appears in one location, strongly reconsider if you actually need it\n\n## [](#optional-parameters)Optional Parameters\n\nFunctions in JavaScript often take a variable number of arguments. For example, the `toFixed` method of `number` takes an optional digit count:\n\nts\n\n`function f(n: number) {`\n\n  `console.log(n.toFixed()); // 0 arguments`\n\n  `console.log(n.toFixed(3)); // 1 argument`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFGAXIsIC2AjAUwCcBKRAbwFgAoRRCBAZzgBsCA6FuAczXajgAxGAA8CAExQkSAbkQB6eYgAMiAIZFuuAmCiMadBmGZtOPPgOFjJAZmlzFiAIzrN23TQC+QA)\n\nWe can model this in TypeScript by marking the parameter as _optional_ with `?`:\n\nts\n\n`function f(x?: number) {`\n\n  `// ...`\n\n`}`\n\n`f(); // OK`\n\n`f(10); // OK`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwPwC5FhAWwCMBTAJwEpEBvAWAChFEB6JxAOg-oF97VyBuZqwDyAaV4oAjAAYBQxGKA)\n\nAlthough the parameter is specified as type `number`, the `x` parameter will actually have the type `number | undefined` because unspecified parameters in JavaScript get the value `undefined`.\n\nYou can also provide a parameter _default_:\n\nts\n\n`function f(x = 10) {`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFAD0QXkQRgAwCUiA3gLABQiiA9NYgHSMUC+QA)\n\nNow in the body of `f`, `x` will have type `number` because any `undefined` argument will be replaced with `10`. Note that when a parameter is optional, callers can always pass `undefined`, as this simply simulates a “missing” argument:\n\nts\n\n`// All OK`\n\n`f();`\n\n`f(10);`\n\n`f(undefined);`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVIAoAPAfgC55VkBbAIxBgEoKA3HLYAbgFgAoAen7wAtKLDIMo4X0HwAghAjwA8gGk+iAox69NARgAM2jQTShEWVCGDagA)\n\n### [](#optional-parameters-in-callbacks)Optional Parameters in Callbacks\n\nOnce you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:\n\nts\n\n`function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {`\n\n  `for (let i = 0; i < arr.length; i++) {`\n\n    `callback(arr[i], i);`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWwJ4DE4CcCiBDCACwAo8ssAuRPMVAbQF0AaRCPAG3YCMCBrK0lgDmVGqhYwwAEwCmADwD8VMCGRcZWAJSIAvAD5EANzgwp2gN4BYAFCJEwbImLsZURDF2IADAG53iAB5qcgA6FzAhKEI-GABqWIsbOzs2Th4IXkEsOhhmd00fJMQAXxtioA)\n\nWhat people usually intend when writing `index?` as an optional parameter is that they want both of these calls to be legal:\n\nts\n\n`myForEach([1, 2, 3], (a) => console.log(a));`\n\n`myForEach([1, 2, 3], (a, i) => console.log(a, i));`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDmFRpsKIcAyQAHQMcI7NIRmUpbLyytW19Y0ObgIt0XTtnT19A0xzIUNAA)\n\nWhat this _actually_ means is that _`callback` might get invoked with one argument_. In other words, the function definition says that the implementation might look like this:\n\nts\n\n`function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {`\n\n  `for (let i = 0; i < arr.length; i++) {`\n\n    `// I don't feel like providing the index today`\n\n    `callback(arr[i]);`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKADMBXAOwGMAXASzntAFsBPAMQQBRAIaMAFgAphsVMPo8A2gF0ANKEbCANpoBGogNaop0AOaz5a1vQAmkAB4B+VPVpcdMAJSgAvAD5QAG5wrNZeAN5UoKDUCKASmpDMoKw+oEQA3MmgADyg0tAAdAn0JsximawA1JXhkVGgIKAAkqDWHADkSdSQkJqgmqz6kKAADvABIVYmoGXDVrZ2M3DWwjx1URraeoz6xtAKrEoe6XUAvlSnQA)\n\nIn turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:\n\nts\n\n`myForEach([1, 2, 3], (a, i) => {`\n\n  `console.log(i.toFixed());`\n\n`'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.  });  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDm4CYVGgAN4mdMKIcAyQAHQMcI5KAoN8cJICXpDUSiEhGZQAvstAA)\n\nIn JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.\n\n> **Rule**: When writing a function type for a callback, _never_ write an optional parameter unless you intend to _call_ the function without passing that argument\n\n## [](#function-overloads)Function Overloads\n\nSome JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a `Date` that takes either a timestamp (one argument) or a month/day/year specification (three arguments).\n\nIn TypeScript, we can specify a function that can be called in different ways by writing _overload signatures_. To do this, write some number of function signatures (usually two or more), followed by the body of the function:\n\nts\n\n`function makeDate(timestamp: number): Date;`\n\n`function makeDate(m: number, d: number, y: number): Date;`\n\n`function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {`\n\n  `if (d !== undefined && y !== undefined) {`\n\n    `return new Date(y, mOrTimestamp, d);`\n\n  `} else {`\n\n    `return new Date(mOrTimestamp);`\n\n  `}`\n\n`}`\n\n`const d1 = makeDate(12345678);`\n\n`const d2 = makeDate(5, 5, 5);`\n\n`const d3 = makeDate(1, 3);`\n\n`No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGCwAoAMwFcA7AYwBcBLOU0AWwEMBrSAEScsgAoaHIiSkwYAHVKWIMARjACUqTtwDcBEhRp1GrDl14MJU2dAA0oACaGZMMwE8rxhaCWRVRMlVr1mbFzwYA8tAAKtQCQiLioJLWphYA-A42oLaJ0UbyinqgAN4EoKDUhKA85qAAhAC8laBk5pCE1KSQZQBkrSkV1bWk9Y3N5nK5+QWg0JCUxND0zQDuzno8tmaBIWGCwmJmg24FAL6gkAA2iJDD+KNjE1MzkPN+q6Hhm6Jyu6B7BJ-45HRCFgBGUA1Hy6bg8AFoADMABYMAA2LAADjeBF+pH+5jQwO0vkWGDMBNAGFRPz+lAsUJxoL8ALMULeQA)\n\nIn this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the _overload signatures_.\n\nThen, we wrote a function implementation with a compatible signature. Functions have an _implementation_ signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!\n\n### [](#overload-signatures-and-the-implementation-signature)Overload Signatures and the Implementation Signature\n\nThis is a common source of confusion. Often people will write code like this and not understand why there is an error:\n\nts\n\n`function fn(x: string): void;`\n\n`function fn() {`\n\n  `// ...`\n\n`}`\n\n`// Expected to be able to call with zero arguments`\n\n`fn();`\n\n`Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYCwAoAMwFcA7AYwBcBLOU0Q0gCgA9VFLprSBzASlQA3ONQAmAbgIkKNOg2Z9QAbwKhQIUADptBAL4ENAURYAHSFUijQlOKABGkUAEM7AG0c3Q5J69egA7tSUABagAF4wtk7QPMQAtpCklIhSCuJAA)\n\nAgain, the signature used to write the function body can’t be “seen” from the outside.\n\n> The signature of the _implementation_ is not visible from the outside. When writing an overloaded function, you should always have _two_ or more signatures above the implementation of the function.\n\nThe implementation signature must also be _compatible_ with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:\n\nts\n\n`function fn(x: boolean): void;`\n\n`// Argument type isn't right`\n\n`function fn(x: string): void;`\n\n`This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.  function fn(x: boolean) {}  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqgEZxwA2kAhmQCUqAG5waAEwDchEKACC0AOYkAtpDJVQVAJ4AHSKBqIyAcm3QaygBZVCpSrXqMW7UIipWyykaHFSssTk1HQMTGyc3HyCQqAA3gC+QA)\n\nts\n\n`function fn(x: string): string;`\n\n`// Return type isn't right`\n\n`function fn(x: number): boolean;`\n\n`This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.  function fn(x: string | number) {    return \"oops\";  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqoldDWQOYCUHLj14BuQiFAAlSFRLQGVAJ4AHSKBqIyAciqhuvABZVCpSrXqMW7UGRIBbAEYxBoR3DgAbSAEMy44nJqOgYmNiFuPlAAH1sHZ2h+UABvQlB9WXkGACIPFURsgIBfIA)\n\n### [](#writing-good-overloads)Writing Good Overloads\n\nLike generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.\n\nLet’s consider a function that returns the length of a string or an array:\n\nts\n\n`function len(s: string): number;`\n\n`function len(arr: any[]): number;`\n\n`function len(x: any) {`\n\n  `return x.length;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQGcBcitQBOMYA5gJR5ggC2ARqoQNwCwAUKJLAiuhgIaFCefmACeAbQC6lRNXqNWHcNHhI0mAB4jx5RAG92iRIVRQQhJJoB0G0lAAWSgL5A)\n\nThis function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string _or_ an array, because TypeScript can only resolve a function call to a single overload:\n\nts\n\n`len(\"\"); // OK`\n\n`len([0]); // OK`\n\n`len(Math.random() > 0.5 ? \"hello\" : [0]);`\n\n`No overload matches this call.   Overload 1 of 2, '(s: string): number', gave the following error.     Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.       Type 'number[]' is not assignable to type 'string'.   Overload 2 of 2, '(arr: any[]): number', gave the following error.     Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.       Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.   Overload 1 of 2, '(s: string): number', gave the following error.     Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.       Type 'number[]' is not assignable to type 'string'.   Overload 2 of 2, '(arr: any[]): number', gave the following error.     Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.       Type 'string' is not assignable to type 'any[]'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYBsBOAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOjmRMAUKUIlbR2TAOYBKVEwYBbAEYwA3IRIVqtRiw5cefftWipKTAJ4BtALozQcpasIhQAWnekGrd68K8BAEQBUiqgLgDyANJ+hpYADLahEdEE-vwAspSsABYAdNBmRHDy-FKgAHygcbkArKAA-KAB2ZDk5HABoKjxiUA)\n\nBecause both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:\n\nts\n\n`function len(x: any[] | string) {`\n\n  `return x.length;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQA8BciCGYAngNoC6iAPogM5QBOMYA5gJSIDeAsAFCKL1UUEPSRYAdGhZQAFgG5eAXyA)\n\nThis is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.\n\n> Always prefer parameters with union types instead of overloads when possible\n\n### [](#declaring-this-in-a-function)Declaring `this` in a Function\n\nTypeScript will infer what the `this` should be in a function via code flow analysis, for example in the following:\n\nts\n\n`const user = {`\n\n  `id: 123,`\n\n  `admin: false,`\n\n  `becomeAdmin: function () {`\n\n    `this.admin = true;`\n\n  `},`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwLACgYwCWAJgFwwCMATAMwA0eeBAhsQLaFjkBmzANkgb4YAI0Sg2iAILtOPOGGBRC4GAAoAlFiYEYUABaEIAOlYcw6PcjiIA3DoC+Qh7aA)\n\nTypeScript understands that the function `user.becomeAdmin` has a corresponding `this` which is the outer object `user`. `this`, _heh_, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object `this` represents. The JavaScript specification states that you cannot have a parameter called `this`, and so TypeScript uses that syntax space to let you declare the type for `this` in the function body.\n\nts\n\n`interface DB {`\n\n  `filterUsers(filter: (this: User) => boolean): User[];`\n\n`}`\n\n`const db = getDB();`\n\n`const admins = db.filterUsers(function (this: User) {`\n\n  `return this.admin;`\n\n`});`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4FgBQyywAJgFzIgCuAtgEbQDcBRcJNoFdA9twDYQ4IZvgC+BEhAR84UFAm4h0YZAHMIYACIAhCgAoAlMgC8APmQ6RAeivIAtA4RUwDuwVCRYiFDpwtkMMB8nhjQ6HqBwdD6YAAWwOgUoVBGZsg8-IIgBkmYUADaALoi4vgECkoqJHQmaho6hiIVyshsHEq11QB0kSF54TBUIAhgwIrIenEJudBGeITIcmBUUCDIU+hdbaAlBoxAA)\n\nThis pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use `function` and not arrow functions to get this behavior:\n\nts\n\n`interface DB {`\n\n  `filterUsers(filter: (this: User) => boolean): User[];`\n\n`}`\n\n`const db = getDB();`\n\n`const admins = db.filterUsers(() => this.admin);`\n\n`The containing arrow function captures the global value of 'this'.   Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.7041   7017The containing arrow function captures the global value of 'this'.   Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYAsBGdGc0BYAKAEsA7AFxgDMBDAY0lAFVEZQBvU0UMgCaoKAVwC2AIxgBuXv0QBBAWMqoJcOABtI9CrJIBfUgMiNN9aC0ZwKiKqADmkKgBEAQqgAUASlABeAD5Qd30QUABaSMYRKkjw0koaaAZmYLduOVoyTST2GERPLJyYLyoACzIUNg5oX0DQdS0dCm9UPOgAbQBdfSMSUmtbewEJf0dndx99QbtQemVKRDGRgDoi3JqCn38g8sqV+ZUW6SA)\n\n## [](#other-types-to-know-about)Other Types to Know About\n\nThere are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.\n\n### [](#void)`void`\n\n`void` represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any `return` statements, or doesn’t return any explicit value from those return statements:\n\nts\n\n`// The inferred return type is void`\n\n`function noop() {`\n\n  `return;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQSwHYDNoCdXQCagwFwK6oKi4CeADrHAM6gBuA9nJgLABQS+CAxrnA8QQMG5ABQBKUAG92oHNAJEA3OwC+QA)\n\nIn JavaScript, a function that doesn’t return any value will implicitly return the value `undefined`. However, `void` and `undefined` are not the same thing in TypeScript. There are further details at the end of this chapter.\n\n> `void` is not the same as `undefined`.\n\n### [](#object)`object`\n\nThe special type `object` refers to any value that isn’t a primitive (`string`, `number`, `bigint`, `boolean`, `symbol`, `null`, or `undefined`). This is different from the _empty object type_ `{ }`, and also different from the global type `Object`. It’s very likely you will never use `Object`.\n\n> `object` is not `Object`. **Always** use `object`!\n\nNote that in JavaScript, function values are objects: They have properties, have `Object.prototype` in their prototype chain, are `instanceof Object`, you can call `Object.keys` on them, and so on. For this reason, function types are considered to be `object`s in TypeScript.\n\n### [](#unknown)`unknown`\n\nThe `unknown` type represents _any_ value. This is similar to the `any` type, but is safer because it’s not legal to do anything with an `unknown` value:\n\nts\n\n`function f1(a: any) {`\n\n  `a.b(); // OK`\n\n`}`\n\n`function f2(a: unknown) {`\n\n  `a.b();`\n\n`'a' is of type 'unknown'.18046'a' is of type 'unknown'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AWACgAzAVwDsBjAFwEs4HQacAKAQ1T8GATwCUoAN7VQofgDoARrzEBuUCFAB5ANLUAvtXrN2nbmgGpGAawZwA7gwnSqshcrUGgA)\n\nThis is useful when describing function types because you can describe functions that accept any value without having `any` values in your function body.\n\nConversely, you can describe a function that returns a value of unknown type:\n\nts\n\n`function safeParse(s: string): unknown {`\n\n  `return JSON.parse(s);`\n\n`}`\n\n`// Need to be careful with 'obj'!`\n\n`const obj = safeParse(someRandomString);`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEASlCsHgMoYwCWKA5gFzaU20DcAsAFAD038AtILABXDIP5cAZsJRgMVVNiiSQABVhoQACjSNM1OgEpGMgNYokAdxTwA3l3jw4GYTBsApMgHkAcgDoABw1tNEMOTgBfLi5eeB8QEGB4DCR4ACMEMFgQaQh4SyoMAAt4AHIkNIArUoBCLmR0LArK+ABeJRV1GE0dPEJiUlwKA1owoA)\n\n### [](#never)`never`\n\nSome functions _never_ return a value:\n\nts\n\n`function fail(msg: string): never {`\n\n  `throw new Error(msg);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAhjANgCgLYGcDmAXIrlAE4xj4CUxYApgG71mIDeAsAFCKJQAWZOAHdEDUQFEyQsjgLUA3NwC+QA)\n\nThe `never` type represents values which are _never_ observed. In a return type, this means that the function throws an exception or terminates execution of the program.\n\n`never` also appears when TypeScript determines there’s nothing left in a union.\n\nts\n\n`function fn(x: string | number) {`\n\n  `if (typeof x === \"string\") {`\n\n    `// do something`\n\n  `} else if (typeof x === \"number\") {`\n\n    `// do something else`\n\n  `} else {`\n\n    `x; // has type 'never'!`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMMAKAHgLkQZygJxjAHNEAfRMEAWwCMBTfASkQG8BYAKEURmEVRQAngAd6cfukQBeWYgBEeQiXksO3HogD0WxABM4uONXpQAFkWJceAX0T0ANjnq9+g0eMky58qnUaqbNaaOvqGOMamFiT2TvTBdo7OQRo86ADc2rpmAIY4iMJiiADkYPQAbozFAIQJXDZAA)\n\n### [](#function)`Function`\n\nThe global type `Function` describes properties like `bind`, `call`, `apply`, and others present on all function values in JavaScript. It also has the special property that values of type `Function` can always be called; these calls return `any`:\n\nts\n\n`function doSomething(f: Function) {`\n\n  `return f(1, 2, 3);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFMAFyIBi408YAlIgN4CwAUIogE64jdJgJAIwAaRACZxAZgYBuDgF8gA)\n\nThis is an _untyped function call_ and is generally best avoided because of the unsafe `any` return type.\n\nIf you need to accept an arbitrary function but don’t intend to call it, the type `() => void` is generally safer.\n\n## [](#rest-parameters-and-arguments)Rest Parameters and Arguments\n\n> Background Reading:  \n> [Rest Parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)  \n> [Spread Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)  \n\n### [](#rest-parameters)Rest Parameters\n\nIn addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an _unbounded_ number of arguments using _rest parameters_.\n\nA rest parameter appears after all other parameters, and uses the `...` syntax:\n\nts\n\n`function multiply(n: number, ...m: number[]) {`\n\n  `return m.map((x) => n * x);`\n\n`}`\n\n`// 'a' gets value [10, 20, 30, 40]`\n\n`const a = multiply(10, 1, 2, 3, 4);`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwBRgBciYIyARgKYBOANIgHRPLGkU0DaAugJSIDeAWABQiRNUpQQ1JMgbIAhpjx4AHnwC8APhKIAVInUBuEQF8RAeguIA5ApuIA5pIDOiAG4K0ISog4BGAAZ6ACZgxABmcIAWQK4RCAQXKEQFRA0UdCxcPCD6f1D6CPponiMgA)\n\nIn TypeScript, the type annotation on these parameters is implicitly `any[]` instead of `any`, and any type annotation given must be of the form `Array<T>` or `T[]`, or a tuple type (which we’ll learn about later).\n\n### [](#rest-arguments)Rest Arguments\n\nConversely, we can _provide_ a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the `push` method of arrays takes any number of arguments:\n\nts\n\n`const arr1 = [1, 2, 3];`\n\n`const arr2 = [4, 5, 6];`\n\n`arr1.push(...arr2);`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAhgJwQRhgXhgbWQGhgJjwGYBdAbgFgAoUSWRBfdLAFjwFY8A2c6h5AHQAHAK4QAFgAoBMhvgCUZIA)\n\nNote that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:\n\nts\n\n`// Inferred type is number[] -- \"an array with zero or more numbers\",`\n\n`// not specifically two numbers`\n\n`const args = [8, 5];`\n\n`const angle = Math.atan2(...args);`\n\n`A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMDYCwAoEUASQDsAzGaSAE1ABcBPAB0lAEtFRSBXAWwBGMANoBdUAFoJoAEQBDUqDmw5jUAHd29ABagAXjDigEoPgja9BMRDIA0BIqTj1QiVgGN25du7kAbPzV6dSNLISQCdzhSRBdlAHMuAF5QYQAOW1AMUQBuSOjYpVJ4vzYUgFk5HQA6KoU0AApq5oTEAEocoA)\n\nThe best fix for this situation depends a bit on your code, but in general a `const` context is the most straightforward solution:\n\nts\n\n`// Inferred as 2-length tuple`\n\n`const args = [8, 5] as const;`\n\n`// OK`\n\n`const angle = Math.atan2(...args);`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEEkDsDMFMCd6wCagIYGdQCYC0AbWSAcwBcALUUgVwAdCBYAKAGMB7SDU9eYrAXlABtABwAaUAFYAuuiztOpANzMQoAPIBpZgq7oShUIICyaCgDozaSNgAU5h2l4YAlEqA)\n\nUsing rest arguments may require turning on [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration) when targeting older runtimes.\n\n## [](#parameter-destructuring)Parameter Destructuring\n\n> Background Reading:  \n> [Destructuring Assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)  \n\nYou can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:\n\njs\n\n`function sum({ a, b, c }) {`\n\n  `console.log(a + b + c);`\n\n`}`\n\n`sum({ a: 10, b: 3, c: 9 });`\n\nThe type annotation for the object goes after the destructuring syntax:\n\nts\n\n`function sum({ a, b, c }: { a: number; b: number; c: number }) {`\n\n  `console.log(a + b + c);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZxAWwBQG9EEMA0iARoRIgL4BciOu1Y6RApgE4Dcx9jrHEXazFhQCUNALAAoRIggJkcADZMAdArgBzDLkQBqYrpnC2k8kA)\n\nThis can look a bit verbose, but you can use a named type here as well:\n\nts\n\n`// Same as prior example`\n\n`type ABC = { a: number; b: number; c: number };`\n\n`function sum({ a, b, c }: ABC) {`\n\n  `console.log(a + b + c);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEGUEMFsFNUgZ1ABwE4EsD2bSwB4woA2sAsAFAAuAnivAIIBCAwqALygDeCAXKADsArtABGsNAG5Qo-sLETpAYzkjxuAL6TKAMyEClVbANCIRACh6QANDNtLQG-sxYBKbpVCglWAYiykAHTEWADm5pCgANQy0d6u2hQaQA)\n\n## [](#assignability-of-functions)Assignability of Functions\n\n### [](#return-type-void)Return type `void`\n\nThe `void` return type for functions can produce some unusual, but expected behavior.\n\nContextual typing with a return type of `void` does **not** force functions to **not** return something. Another way to say this is a contextual function type with a `void` return type (`type voidFunc = () => void`), when implemented, can return _any_ other value, but it will be ignored.\n\nThus, the following implementations of the type `() => void` are valid:\n\nts\n\n`type voidFunc = () => void;`\n\n`const f1: voidFunc = () => {`\n\n  `return true;`\n\n`};`\n\n`const f2: voidFunc = () => true;`\n\n`const f3: voidFunc = function () {`\n\n  `return true;`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOkA)\n\nAnd when the return value of one of these functions is assigned to another variable, it will retain the type of `void`:\n\nts\n\n`const v1 = f1();`\n\n`const v2 = f2();`\n\n`const v3 = f3();`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOvQA9NFQALSJWGjAifEOBjBcwtzEunRMjrCGOYZ59gX67DDOOc55QA)\n\nThis behavior exists so that the following code is valid even though `Array.prototype.push` returns a number and the `Array.prototype.forEach` method expects a function with a return type of `void`.\n\nts\n\n`const src = [1, 2, 3];`\n\n`const dst = [0];`\n\n`src.forEach((el) => dst.push(el));`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBBBOwYF4YG0CMAaGAmHAzALoDcAsAFCiSwAm0K6ADKZZQsAHQBmI8AogENgACwAUYgKYAbAJQoAfDHpROABwCuEcTNmySQA)\n\nThere is one other special case to be aware of, when a literal function definition has a `void` return type, that function must **not** return anything.\n\nts\n\n`function f2(): void {`\n\n  `// @ts-expect-error`\n\n  `return true;`\n\n`}`\n\n`const f3 = function (): void {`\n\n  `// @ts-expect-error`\n\n  `return true;`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMATACgJQC5EDc4wAmiA3gLABQiiA9DYgAJQDOAtAKYAeADu9BwCcBcAZWoD2UEAKRQBIdgG5KAX0qUICZlGQBmRAF5k4aPCSYc+IqTG16TNl1792QkbYlSZiOQuUUVRSA)\n\nFor more on `void` please refer to these other documentation entries:\n\n*   [v2 handbook](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)\n*   [FAQ - “Why are functions returning non-void assignable to function returning void?”](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)",
    "title": "TypeScript: Documentation - More on Functions",
    "description": "Learn about how Functions work in TypeScript.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html",
    "markdown": "# TypeScript: Documentation - TypeScript for Java/C# Programmers\n\nTypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java.\n\nTypeScript’s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program. While TypeScript provides many familiar features for these developers, it’s worth stepping back to see how JavaScript (and therefore TypeScript) differ from traditional OOP languages. Understanding these differences will help you write better JavaScript code, and avoid common pitfalls that programmers who go straight from C#/Java to TypeScript may fall into.\n\n## [](#co-learning-javascript)Co-learning JavaScript\n\nIf you’re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to. Some of the ways that TypeScript models types are quite different from Java or C#, and it’s important to keep these in mind when learning TypeScript.\n\nIf you’re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScript _without_ types first to understand JavaScript’s runtime behaviors. Because TypeScript doesn’t change how your code _runs_, you’ll still have to learn how JavaScript works in order to write code that actually does something!\n\nIt’s important to remember that TypeScript uses the same _runtime_ as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs. Don’t limit yourself to TypeScript-specific resources!\n\n## [](#rethinking-the-class)Rethinking the Class\n\nC# and Java are what we might call _mandatory OOP_ languages. In these languages, the _class_ is the basic unit of code organization, and also the basic container of all data _and_ behavior at runtime. Forcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domain _needs_ to be represented this way.\n\n### [](#free-functions-and-data)Free Functions and Data\n\nIn JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-defined `class` or `struct`. This flexibility is extremely powerful. “Free” functions (those not associated with a class) working over data without an implied OOP hierarchy tend to be the preferred model for writing programs in JavaScript.\n\n### [](#static-classes)Static Classes\n\nAdditionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript.\n\n## [](#oop-in-typescript)OOP in TypeScript\n\nThat said, you can still use classes if you like! Some problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript’s support for JavaScript classes will make these models even more powerful. TypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods.\n\nWe’ll cover classes later in this guide.\n\n## [](#rethinking-types)Rethinking Types\n\nTypeScript’s understanding of a _type_ is actually quite different from C# or Java’s. Let’s explore some differences.\n\n### [](#nominal-reified-type-systems)Nominal Reified Type Systems\n\nIn C# or Java, any given value or object has one exact type - either `null`, a primitive, or a known class type. We can call methods like `value.GetType()` or `value.getClass()` to query the exact type at runtime. The definition of this type will reside in a class somewhere with some name, and we can’t use two classes with similar shapes in lieu of each other unless there’s an explicit inheritance relationship or commonly-implemented interface.\n\nThese aspects describe a _reified, nominal_ type system. The types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures.\n\n### [](#types-as-sets)Types as Sets\n\nIn C# or Java, it’s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations.\n\nIn TypeScript, it’s better to think of a type as a _set of values_ that share something in common. Because types are just sets, a particular value can belong to _many_ sets at the same time.\n\nOnce you start thinking of types as sets, certain operations become very natural. For example, in C#, it’s awkward to pass around a value that is _either_ a `string` or `int`, because there isn’t a single type that represents this sort of value.\n\nIn TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the `string` set or the `number` set? It simply belongs to the _union_ of those sets: `string | number`.\n\nTypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you’ll find them more intuitive if you think of types as sets.\n\n### [](#erased-structural-types)Erased Structural Types\n\nIn TypeScript, objects are _not_ of a single exact type. For example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two.\n\nts\n\n`interface Pointlike {`\n\n  `x: number;`\n\n  `y: number;`\n\n`}`\n\n`interface Named {`\n\n  `name: string;`\n\n`}`\n\n`function logPoint(point: Pointlike) {`\n\n  `console.log(\"x = \" + point.x + \", y = \" + point.y);`\n\n`}`\n\n`function logName(x: Named) {`\n\n  `console.log(\"Hello, \" + x.name);`\n\n`}`\n\n`const obj = {`\n\n  `x: 0,`\n\n  `y: 0,`\n\n  `name: \"Origin\",`\n\n`};`\n\n`logPoint(obj);`\n\n`logName(obj);`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRgDbANYoDeAUMsgB4BcyIArgLYBG0A3KcgJ7V1OvEC+xLNHhJkAOTj0IAE2QkyIKRGoBnMFFABzNoOIxaIBGGDoQybOi0YsACgAOmcNRvhcBAJTz2CM6vTYEAB0llq2AETkyAC8yOHIANTIjlhBUUnhADScMXGJyU5gQRweusT6hsam5qGS0rZUEsoyXgrIviD+gSFWEQASENiW2fFJ5EFK0qUC5R3qyOiMAFa5bY0ADJnsXMib7JMqcQDymlqgWQJsxKGuYLaLS9O1yvfLpUA)\n\nTypeScript’s type system is _structural_, not nominal: We can use `obj` as a `Pointlike` because it has `x` and `y` properties that are both numbers. The relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship.\n\nTypeScript’s type system is also _not reified_: There’s nothing at runtime that will tell us that `obj` is `Pointlike`. In fact, the `Pointlike` type is not present _in any form_ at runtime.\n\nGoing back to the idea of _types as sets_, we can think of `obj` as being a member of both the `Pointlike` set of values and the `Named` set of values.\n\n### [](#consequences-of-structural-typing)Consequences of Structural Typing\n\nOOP programmers are often surprised by two particular aspects of structural typing.\n\n#### [](#empty-types)Empty Types\n\nThe first is that the _empty type_ seems to defy expectation:\n\nts\n\n`class Empty {}`\n\n`function fn(arg: Empty) {`\n\n  `// do something?`\n\n`}`\n\n`// No error, but this isn't an 'Empty' ?`\n\n`fn({ k: 10 });`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4CgcDMBXAO2GQEsB7Y6fYgCjACcBzALjiTQEpMdpoAekHQAJpWgRK8AKbIAFuWIsA-Dlw5h0AHISZTJpSYAaaACNCyaAvIxbxAORWwNBwhSoH0NXXoZoANYcAIwADNBY3ADcQA)\n\nTypeScript determines if the call to `fn` here is valid by seeing if the provided argument is a valid `Empty`. It does so by examining the _structure_ of `{ k: 10 }` and `class Empty { }`. We can see that `{ k: 10 }` has _all_ of the properties that `Empty` does, because `Empty` has no properties. Therefore, this is a valid call!\n\nThis may seem surprising, but it’s ultimately a very similar relationship to one enforced in nominal OOP languages. A subclass cannot _remove_ a property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base. Structural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types.\n\n#### [](#identical-types)Identical Types\n\nAnother frequent source of surprise comes with identical types:\n\nts\n\n`class Car {`\n\n  `drive() {`\n\n    `// hit the gas`\n\n  `}`\n\n`}`\n\n`class Golfer {`\n\n  `drive() {`\n\n    `// hit the ball far`\n\n  `}`\n\n`}`\n\n`// No error?`\n\n`let w: Car = new Golfer();`\n\nAgain, this isn’t an error because the _structures_ of these classes are the same. While this may seem like a potential source of confusion, in practice, identical classes that shouldn’t be related are not common.\n\nWe’ll learn more about how classes relate to each other in the Classes chapter.\n\n### [](#reflection)Reflection\n\nOOP programmers are accustomed to being able to query the type of any value, even a generic one:\n\ncsharp\n\n`// C#`\n\n`static void LogType<T>() {`\n\n    `Console.WriteLine(typeof(T).Name);`\n\n`}`\n\nBecause TypeScript’s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime.\n\nJavaScript does have some limited primitives like `typeof` and `instanceof`, but remember that these operators are still working on the values as they exist in the type-erased output code. For example, `typeof (new Car())` will be `\"object\"`, not `Car` or `\"Car\"`.\n\n## [](#next-steps)Next Steps\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n*   Read the full Handbook [from start to finish](https://www.typescriptlang.org/docs/handbook/intro.html)\n*   Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)",
    "title": "TypeScript: Documentation - TypeScript for Java/C# Programmers",
    "description": "Learn TypeScript if you have a background in object-oriented languages",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html",
    "markdown": "# TypeScript: Documentation - Object Types\n\nIn JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through _object types_.\n\nAs we’ve seen, they can be anonymous:\n\nts\n\n`function greet(person: { name: string; age: number }) {`\n\n  `return \"Hello \" + person.name;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIgN6JgCGAtumYVKjGMgNyLXINUi0AjAogC+ASgoAoRIgD0smYqXLlAPXUbNW7TtXTEGKCFRIARAAl0AGytxEpxAGpE+IggB0Neu0kigA)\n\nor they can be named by using either an interface:\n\nts\n\n`interface Person {`\n\n  `name: string;`\n\n  `age: number;`\n\n`}`\n\n`function greet(person: Person) {`\n\n  `return \"Hello \" + person.name;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyA9CcRcgHo21HIhwC2EAXMhmFKAOYDc9ODzYMArkwBG0AQF8CBGKJAIwwHMh5QIEMAAoADphzt0UbCACU+elrCiouAEQAJCABs3WZI+QBqZIZmOAB0jCyyQA)\n\nor a type alias:\n\nts\n\n`type Person = {`\n\n  `name: string;`\n\n  `age: number;`\n\n`};`\n\n`function greet(person: Person) {`\n\n  `return \"Hello \" + person.name;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbwFBSgHpCoA9ci-KVAQwFsIAuKRYeAS1QHMBuKmrk2oBXOgCMEfAL59cAM2GoAxsHZooXeBAjAAFJCRpmcQ6gCUOKluDD46AEQAJCABsXyKPagBqKAZSoAHS0DNJAA)\n\nIn all three examples above, we’ve written functions that take objects that contain the property `name` (which must be a `string`) and `age` (which must be a `number`).\n\n## [](#quick-reference)Quick Reference\n\nWe have cheat-sheets available for both [`type` and `interface`](https://www.typescriptlang.org/cheatsheets), if you want a quick look at the important every-day syntax at a glance.\n\n## [](#property-modifiers)Property Modifiers\n\nEach property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.\n\n### [](#optional-properties)Optional Properties\n\nMuch of the time, we’ll find ourselves dealing with objects that _might_ have a property set. In those cases, we can mark those properties as _optional_ by adding a question mark (`?`) to the end of their names.\n\nts\n\n`interface PaintOptions {`\n\n  `shape: Shape;`\n\n  `xPos?: number;`\n\n  `yPos?: number;`\n\n`}`\n\n`function paintShape(opts: PaintOptions) {`\n\n  `// ...`\n\n`}`\n\n`const shape = getShape();`\n\n`paintShape({ shape });`\n\n`paintShape({ shape, xPos: 100 });`\n\n`paintShape({ shape, yPos: 100 });`\n\n`paintShape({ shape, xPos: 100, yPos: 100 });`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUIB6acgC0ihLTCL5hUJFiIUABTiaA8liasAzslyFkyM2IgieE68gAeu5mYD8IkLQC2AEbQkjayNgB6LgCeHt6+AcFQocjhyFFEhHQMpmxYBuBO-MwmZiL6RiYsIGYCli7hAHTNhJkI5mC29sgAvBxcRYKS+ZqDuF28yPgCwwXc9nzjdrwANG5xIgCMAAzbUzOEI4ULS-ZrsZ5bu-uzoycTOGvul8g72+cbr9fT4kA)\n\nIn this example, both `xPos` and `yPos` are considered optional. We can choose to provide either of them, so every call above to `paintShape` is valid. All optionality really says is that if the property _is_ set, it better have a specific type.\n\nWe can also read from those properties - but when we do under [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), TypeScript will tell us they’re potentially `undefined`.\n\nts\n\n`function paintShape(opts: PaintOptions) {`\n\n  `let xPos = opts.xPos;`\n\n                   `(property) PaintOptions.xPos?: number | undefined`\n\n  `let yPos = opts.yPos;`\n\n                   `(property) PaintOptions.yPos?: number | undefined`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6KxsPZDD9Lu6egD1bcsrvG1r6nKbhzXbOntn9fvNOpuXCfCA)\n\nIn JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value `undefined`. We can just handle `undefined` specially by checking for it.\n\nts\n\n`function paintShape(opts: PaintOptions) {`\n\n  `let xPos = opts.xPos === undefined ? 0 : opts.xPos;`\n\n       `let xPos: number`\n\n  `let yPos = opts.yPos === undefined ? 0 : opts.yPos;`\n\n       `let yPos: number`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6Kxtamrr6UhhQCGJkW2QABmQRBubWzQ9kMP0APVtyyu82uvGmle0OzpBu3v7BkbGcjZ9p2eQF81mm28J8IA)\n\nNote that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it.\n\nts\n\n`function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {`\n\n  `console.log(\"x coordinate at\", xPos);`\n\n                                  `(parameter) xPos: number`\n\n  `console.log(\"y coordinate at\", yPos);`\n\n                                  `(parameter) yPos: number`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTflwDIwAaSx9kAF5kAAZ87xtisuR8ESVVdRYQTQEdcwQtZnIIADpyZnY+ACILZE7mKGJQOEhkWeH8qxsBD2Qw-U2t7Z3d-QA9Ww6unv7Bkc9x5knpkFmUBYqfVfMNvfeP5EPX8N6-wnwQA)\n\nHere we used [a destructuring pattern](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) for `paintShape`’s parameter, and provided [default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values) for `xPos` and `yPos`. Now `xPos` and `yPos` are both definitely present within the body of `paintShape`, but optional for any callers to `paintShape`.\n\n> Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript.\n> \n> ts\n> \n> `function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {`\n> \n>   `render(shape);`\n> \n> `Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'?    render(xPos);  Cannot find name 'xPos'.2304Cannot find name 'xPos'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAgTUBOT0TlxATAKzeeicAzAAYALLVSQszcumqgAygAsyieQG8AvrQAm1dMjJN5JAK6R0WVNEihjkPUwAUAD2LmA1jADukAJQA3PRgALRh6KZYYSG0ZhZWNqA6TGTeTuqglCpqxMqq1AA0oC4ACtAcoJCm8ABGzKAAvKAAjMLCoMAAVAB0vZ1gmn6g6rSgdtQOzE5Z+YGj45POpeVzmkA)\n> \n> In an object destructuring pattern, `shape: Shape` means “grab the property `shape` and redefine it locally as a variable named `Shape`.” Likewise `xPos: number` creates a variable named `number` whose value is based on the parameter’s `xPos`.\n\n### [](#readonly-properties)`readonly` Properties\n\nProperties can also be marked as `readonly` for TypeScript. While it won’t change any behavior at runtime, a property marked as `readonly` can’t be written to during type-checking.\n\nts\n\n`interface SomeType {`\n\n  `readonly prop: string;`\n\n`}`\n\n`function doSomething(obj: SomeType) {`\n\n  `// We can read from 'obj.prop'.`\n\n  ``console.log(`prop has the value '${obj.prop}'.`);``\n\n  `// But we can't re-assign it.`\n\n  `obj.prop = \"hello\";`\n\n`Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKAMpwC2kAKgJ4AOdA3nqKGiRKAEzhEANu1Cd4nVIhLRiAcwDceAL5485AK5FqJAuNBjGLEgAtVACjgAjAFaoLbLpACUoPgJCgAdTpqSiJBYRFQcngmUAByRycAOlk4Tjik-lBqcUQ4CUgkiTgVWwADVM5QK0pEUGs6ADdKCT06OIASHkSUuU0Mss8NLP8AIT0SUAB3YNC4yaEAWlrEAhUwghJMgR7K0ABeUAAiK0gJYqONTSA)\n\nUsing the `readonly` modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to.\n\nts\n\n`interface Home {`\n\n  `readonly resident: { name: string; age: number };`\n\n`}`\n\n`function visitForBirthday(home: Home) {`\n\n  `// We can read and update properties from 'home.resident'.`\n\n  ``console.log(`Happy birthday ${home.resident.name}!`);``\n\n  `home.resident.age++;`\n\n`}`\n\n`function evict(home: Home) {`\n\n  `// But we can't write to the 'resident' property itself on a 'Home'.`\n\n  `home.resident = {`\n\n`Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property.      name: \"Victor the Evictor\",      age: 42,    };  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKABJwC2dA3nqKNJJQCZxEANgE8ukRAV6RSqVqCKUWqRCWjEA5gG5QldZFREArkwBGMUAF9NeC3jzlDRaiQIDQANwISSAMQQAhAmgSAAteSmEAChDmfQZYgEpQdk4QUAB1OmpKIjE+HSJeUEMAB3CyUBL4EpgXcVByeCZQAHIYlgA6bgkpUhaOjlBqAUQ4QUgOwTh1SIADekoSktETINDw0QASVnaJ7slpEg6FFgsAQlmE605drvED0g7dSABqF+tbe0dnV1zIT2c0ViqEYLCSKVAaX8hhIoAA7lkci1YXC1BUSHBQKE6C19r0SC1KtVaqICCREJBBORQG5KK1QZB+oNbnjDqAALzJQacE5xABEADUCM4EFiQnQAKIAjHQPkAGm5Oj0qCwaAVnCsNiAA)\n\nIt’s important to manage expectations of what `readonly` implies. It’s useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn’t factor in whether properties on two types are `readonly` when checking whether those types are compatible, so `readonly` properties can also change via aliasing.\n\nts\n\n`interface Person {`\n\n  `name: string;`\n\n  `age: number;`\n\n`}`\n\n`interface ReadonlyPerson {`\n\n  `readonly name: string;`\n\n  `readonly age: number;`\n\n`}`\n\n`let writablePerson: Person = {`\n\n  `name: \"Person McPersonface\",`\n\n  `age: 42,`\n\n`};`\n\n`// works`\n\n`let readonlyPerson: ReadonlyPerson = writablePerson;`\n\n`console.log(readonlyPerson.age); // prints '42'`\n\n`writablePerson.age++;`\n\n`console.log(readonlyPerson.age); // prints '43'`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LAL4ECoSLEQoAShDgATHABsAnuijZchYlFkKQKkuU616IZqx3ylyth2oge-KEJGKIYZAHd6YOLzdqGtSBOMgAvPispBTUAEQhuACyCAnwSLEANKzsnAAsAExZgiwEAPSlXlhQANYYBG4elnoqCdQyVvqqmKER3sC+-hAJJQg42G4AdIpYDAAUTdYJEzkAlEzI5cgADqZgGMgA5AUHBH0DAd0gyxwA1DcsoyDjEFMz87qLl9cQaxsVO2J9kcAMwHIA)\n\nUsing [mapping modifiers](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers), you can remove `readonly` attributes.\n\n### [](#index-signatures)Index Signatures\n\nSometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values.\n\nIn those cases you can use an index signature to describe the types of possible values, for example:\n\nts\n\n`interface StringArray {`\n\n  `[index: number]: string;`\n\n`}`\n\n`const myArray: StringArray = getStringArray();`\n\n`const secondItem = myArray[1];`\n\n          `const secondItem: string`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBlDGLVAgQRhigE8AKASgC54yKrb6GBuAFAB6YfAC0ksMgyTxgyhhAxEUMAi6UadRvADeg+PADalUAA8OqZAFsARsoC6HAM7ktQgL6DBYPG-gbBl5GDk0eHQZ4AF5CYnDtPlYhP1QAl3A8YABJJRsYwODI4wBGRyFRIyqAPQB+IA)\n\nAbove, we have a `StringArray` interface which has an index signature. This index signature states that when a `StringArray` is indexed with a `number`, it will return a `string`.\n\nOnly some types are allowed for index signature properties: `string`, `number`, `symbol`, template string patterns, and union types consisting only of these.\n\nIt is possible to support multiple types of indexers...\n\nIt is possible to support multiple types of indexers. Note that when using both \\`number\\` and \\`string\\` indexers, the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a `number`, JavaScript will actually convert that to a `string` before indexing into an object. That means that indexing with `100` (a `number`) is the same thing as indexing with `\"100\"` (a `string`), so the two need to be consistent.\n\nts\n\n`interface Animal {`\n\n  `name: string;`\n\n`}`\n\n`interface Dog extends Animal {`\n\n  `breed: string;`\n\n`}`\n\n`// Error: indexing with a numeric string might get you a completely separate type of Animal!`\n\n`interface NotOkay {`\n\n  `[x: number]: Animal;`\n\n`'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.    [x: string]: Dog;  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBmAUCBIgC7QCWAxsQArwAOMxAngJIB2ZxZAhgDZkAvblzhtUAMz6JIeMm2IxJFSKACCHALZ9QAbzyhQbbhsioS5NgHMA3HgC+eWfMXdloACJxLoSAA8FbAAmiGqa2noGAEbQkJCBZqRyNvaOhACisAiocoF+SaAA7pwAFqDchgCuJuQUoOb5GmSWxcSglpCtTHAVZaAUcBp0vB2QvEx1kHTc0MIqzAygcOKhZFq8AIROCtBKKgBycMQA8gDW3OMRoADavqhsVZEwALqo6qt8tgY3CRaWLx5eWx2IA)\n\nWhile string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that `obj.property` is also available as `obj[\"property\"]`. In the following example, `name`’s type does not match the string index’s type, and the type checker gives an error:\n\nts\n\n`interface NumberDictionary {`\n\n  `[index: string]: number;`\n\n  `length: number; // ok`\n\n  `name: string;`\n\n`Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMWBQIIZ4lVMdcBLAOwBcYAzAQwGNJQA5AVwFsAjGACIVmNCnCqNoAT1ABvXKFABtagBNIAD1SIa0agHMAuqio9+0ANy4FoADaQq+mgAsTZmBdAE4AaxsTuSG1dAysAXyA)\n\nHowever, properties of different types are acceptable if the index signature is a union of the property types:\n\nts\n\n`interface NumberOrStringDictionary {`\n\n  `[index: string]: number | string;`\n\n  `length: number; // ok, length is a number`\n\n  `name: string; // ok, name is a string`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaB5KAZTClAHMARYBMYAexDigE9kBvAKGWQG1QATCAA8AXMgDOJcgF0xILLijIAPhKkgyAbi7IANhA1gAFnIXRNyAPSXkdANYAaPQbLHkwccjjJ5OaDsZMCDFJUg0La1tHHzgg909vUPIOAF8gA)\n\nFinally, you can make index signatures `readonly` in order to prevent assignment to their indices:\n\nts\n\n`interface ReadonlyStringArray {`\n\n  `readonly [index: number]: string;`\n\n`}`\n\n`let myArray: ReadonlyStringArray = getReadOnlyStringArray();`\n\n`myArray[2] = \"Mallory\";`\n\n`Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.`[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMAlEKYAeVQgE8BlDGLVAgQRhiloAoBKAFzwyFPHUbNWHLrQDcAKAD0i+AFp1YZBnWqlKgAIhOOGAGchAJgCsAFgvyWGI4ihgEI4GIZMW7Tt3gAb3l4eDhRGlp4AG0WUAAPIVRkAFsAIyMAXSFTH1YFAF95eQhieBTaaW4hDy8JXyqogF5CYg9qcTy-GX4FCsboi0z4FoAiAFkoCAgTWlHZIA)\n\nYou can’t set `myArray[2]` because the index signature is `readonly`.\n\n## [](#excess-property-checks)Excess Property Checks\n\nWhere and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation.\n\nts\n\n`interface SquareConfig {`\n\n  `color?: string;`\n\n  `width?: number;`\n\n`}`\n\n`function createSquare(config: SquareConfig): { color: string; area: number } {`\n\n  `return {`\n\n    `color: config.color || \"red\",`\n\n    `area: config.width ? config.width * config.width : 20,`\n\n  `};`\n\n`}`\n\n`let mySquare = createSquare({ colour: \"red\", width: 100 });`\n\n`Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2Dk5ykFSglgCeEbygALzekL6Q15CBiS1lqD2Qff16S8ZUABGHY7AqxTRAA)\n\nNotice the given argument to `createSquare` is spelled _`colour`_ instead of `color`. In plain JavaScript, this sort of thing fails silently.\n\nYou could argue that this program is correctly typed, since the `width` properties are compatible, there’s no `color` property present, and the extra `colour` property is insignificant.\n\nHowever, TypeScript takes the stance that there’s probably a bug in this code. Object literals get special treatment and undergo _excess property checking_ when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error:\n\nts\n\n`let mySquare = createSquare({ colour: \"red\", width: 100 });`\n\n`Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEi0yqgepA+v09EtjKgAIw7HYFWKaIA)\n\nGetting around these checks is actually really simple. The easiest method is to just use a type assertion:\n\nts\n\n`let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEptjKgAIw7PagOAAByYZCoz1QO0aeEK9EQbC4kQE81imiAA)\n\nHowever, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way. If `SquareConfig` can have `color` and `width` properties with the above types, but could _also_ have any number of other properties, then we could define it like so:\n\nts\n\n`interface SquareConfig {`\n\n  `color?: string;`\n\n  `width?: number;`\n\n  `[propName: string]: any;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXyA)\n\nHere we’re saying that `SquareConfig` can have any number of properties, and as long as they aren’t `color` or `width`, their types don’t matter.\n\nOne final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since assigning `squareOptions` won’t undergo excess property checks, the compiler won’t give you an error:\n\nts\n\n`let squareOptions = { colour: \"red\", width: 100 };`\n\n`let mySquare = createSquare(squareOptions);`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OcEAE9BAXypUYmEAjDAidXHEgZsuAAU9MRkHP44+EQkpACUHBR0jMzGPHz8yJFwHHJK0Mj2lEK4YJhQIEW0tPRMUBwhMQB0NczIAD5tyABEuGJdADRCtFn10WSNohKSyCxJoaQT4lLIAFRzTZPLHABMAAyDtPYOVAD0J8gAtFcImGBXF1QMEGBcWJEA8hoeRJzIALyUJJMMocHoQPr9ERLSQcACMu12BUETxe8hsEVw-28EF8EAxEECnDeuE+3xAnFi-CAA)\n\nThe above workaround will work as long as you have a common property between `squareOptions` and `SquareConfig`. In this example, it was the property `width`. It will however, fail if the variable does not have any common object property. For example:\n\nts\n\n`let squareOptions = { colour: \"red\" };`\n\n`let mySquare = createSquare(squareOptions);`\n\n`Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYME4BQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCqmzETNCE2SIiYpLQqL6hAHSlCKAAPvWgAERsms0ANKoiyRUhfFUa2jqgUtF+vINauqAAVOPVQzOoaAAMXSIWlrggoAC0B1RMxAd7uOKQxKCIzEEA8gAOjlyIoAC8gtGS+aitkO2ZFQXK5GACegTY7xckDckAhkC8N08kEez0IiDCSiAA)\n\nKeep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs.\n\nThat means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a `color` or `colour` property to `createSquare`, you should fix up the definition of `SquareConfig` to reflect that.\n\n## [](#extending-types)Extending Types\n\nIt’s pretty common to have types that might be more specific versions of other types. For example, we might have a `BasicAddress` type that describes the fields necessary for sending letters and packages in the U.S.\n\nts\n\n`interface BasicAddress {`\n\n  `name?: string;`\n\n  `street: string;`\n\n  `city: string;`\n\n  `country: string;`\n\n  `postalCode: string;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvkA)\n\nIn some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an `AddressWithUnit`.\n\nts\n\n`interface AddressWithUnit {`\n\n  `name?: string;`\n\n  `unit: string;`\n\n  `street: string;`\n\n  `city: string;`\n\n  `country: string;`\n\n  `postalCode: string;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIIBN1QgZxwdWDAAsBVEI5AbwChlkQ4BbCAfgC5kcwpQBzANx1kAVwphO3XiEE0A9HIB6ylapXCpECBK49+Q+giIBPSXpkHkCAPZiep3dNn0ADte5wANgGFr6CGZOQgC+QA)\n\nThis does the job, but the downside here is that we had to repeat all the other fields from `BasicAddress` when our changes were purely additive. Instead, we can extend the original `BasicAddress` type and just add the new fields that are unique to `AddressWithUnit`.\n\nts\n\n`interface BasicAddress {`\n\n  `name?: string;`\n\n  `street: string;`\n\n  `city: string;`\n\n  `country: string;`\n\n  `postalCode: string;`\n\n`}`\n\n`interface AddressWithUnit extends BasicAddress {`\n\n  `unit: string;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvhQqhIsRCnyFiGAOoyAFgCqIDLIEAAekCB4pOhYuAREJOT8mjK2ShT2QA)\n\nThe `extends` keyword on an `interface` allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, `AddressWithUnit` didn’t need to repeat the `street` property, and because `street` originates from `BasicAddress`, a reader will know that those two types are related in some way.\n\n`interface`s can also extend from multiple types.\n\nts\n\n`interface Colorful {`\n\n  `color: string;`\n\n`}`\n\n`interface Circle {`\n\n  `radius: number;`\n\n`}`\n\n`interface ColorfulCircle extends Colorful, Circle {}`\n\n`const cc: ColorfulCircle = {`\n\n  `color: \"red\",`\n\n  `radius: 42,`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xxoksiKqYFASYUJMlDgATYLlo0QuALYAjaG07dw0eEjSU8mQcNHIIAD0ggptfdkMAaNEJFjNFEPXIIaGezHxjV2QAXiJScgMaACIoCClohwjJGTkaABYAJiT2FiA)\n\n## [](#intersection-types)Intersection Types\n\n`interface`s allowed us to build up new types from other types by extending them. TypeScript provides another construct called _intersection types_ that is mainly used to combine existing object types.\n\nAn intersection type is defined using the `&` operator.\n\nts\n\n`interface Colorful {`\n\n  `color: string;`\n\n`}`\n\n`interface Circle {`\n\n  `radius: number;`\n\n`}`\n\n`type ColorfulCircle = Colorful & Circle;`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xoksiKqwKAkwoSZKHAAmwXLRohcAWwBG0Np2JgAngAd+lPJgFCRyALxoDMfMgBkaQcIgsgA)\n\nHere, we’ve intersected `Colorful` and `Circle` to produce a new type that has all the members of `Colorful` _and_ `Circle`.\n\nts\n\n`function draw(circle: Colorful & Circle) {`\n\n  ``console.log(`Color was ${circle.color}`);``\n\n  ``console.log(`Radius was ${circle.radius}`);``\n\n`}`\n\n`// okay`\n\n`draw({ color: \"blue\", radius: 42 });`\n\n`// oops`\n\n`draw({ color: \"red\", raidus: 42 });`\n\n`Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAMJwA2C5Ark6AN56ijXMEqRCWjEA5gG48AX0KkKNOvQLRqTOjz7RKAEwJsUoImwC2AIxjS5IUAFoH1NiQd287ItRIE4RULp0AdwAKalV1SFRGFmh2TgAyBnCNAEpuXn5fRGZIADoWcWCAA2iEUEDKRFAAEi4wtQ1cgRiZIpTpPgEibMaC4oAlPQMqiqra+ojcnX1DVvbZPDxbOABrSgBPPADKEK5MmNQAInMmNkhDgBpQaeHULDRQGXmlsDg4AAdELaDgveahUCHaCQXSXa6UAi6Qx3B5PSRAA)\n\n## [](#interfaces-vs-intersections)Interfaces vs. Intersections\n\nWe just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an `extends` clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.\n\n## [](#generic-object-types)Generic Object Types\n\nLet’s imagine a `Box` type that can contain any value - `string`s, `number`s, `Giraffe`s, whatever.\n\nts\n\n`interface Box {`\n\n  `contents: any;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5k4QBPAbjwF8g)\n\nRight now, the `contents` property is typed as `any`, which works, but can lead to accidents down the line.\n\nWe could instead use `unknown`, but that would mean that in cases where we already know the type of `contents`, we’d need to do precautionary checks, or use error-prone type assertions.\n\nts\n\n`interface Box {`\n\n  `contents: unknown;`\n\n`}`\n\n`let x: Box = {`\n\n  `contents: \"hello world\",`\n\n`};`\n\n`// we could check 'x.contents'`\n\n`if (typeof x.contents === \"string\") {`\n\n  `console.log(x.contents.toLowerCase());`\n\n`}`\n\n`// or we could use a type assertion`\n\n`console.log((x.contents as string).toLowerCase());`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5kBXEAaxHQHcQBuPAXzzwBsIwyTNQzYAvLgJESkCtQBEACwi9e6ZM3RReAE3kAaLhzwB6ExpTEauosoT1kAckwA6YqQqO8wGMgAUYACeAA4Q6L6u7rJg5Mhi8cjy5GBQoADm8gCUkoTu5Oj8LmppfpEyZDEuYOgAMizQAMJw5BB+mZkc3KbmWhbS1jq0LchwyEGhI+QtUGDAJHh5BRBF6CWlbuUUk8jJqSBpmVW19VBNLW0dQA)\n\nOne type safe approach would be to instead scaffold out different `Box` types for every type of `contents`.\n\nts\n\n`interface NumberBox {`\n\n  `contents: number;`\n\n`}`\n\n`interface StringBox {`\n\n  `contents: string;`\n\n`}`\n\n`interface BooleanBox {`\n\n  `contents: boolean;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lADkBXAWwCMYAhOAD1AG8dRQlOMUjEUoAk1bQA3DgC+OfCOgVqoAMpFohAOYdufAUJFjUibXrmLlJVVRoc4AG0jkCB3v0HCSZ0MxwLm4E1kA)\n\nBut that means we’ll have to create different functions, or overloads of functions, to operate on these types.\n\nts\n\n`function setContents(box: StringBox, newContents: string): void;`\n\n`function setContents(box: NumberBox, newContents: number): void;`\n\n`function setContents(box: BooleanBox, newContents: boolean): void;`\n\n`function setContents(box: { contents: any }, newContents: any) {`\n\n  `box.contents = newContents;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaAhAewA9kBvAKGWQQPAnAGcAuZELXKAbnIF9zzQkWIhQBlMFFABzQiQpUadRiwYTp3PgLrCkyQgQA2EOCFllK1WpGXJsBQ8ZAbyAehfIAtF4TowXj+Qw6CAIYMC0yAwQYADCVvRgDAAUdkQs4pIgMsQANKwQAO5xSokqalkAlCwAbgTAACbcQSFhEVGx8YwpxCwYOPi5+UWdpazs0FXItQ1NwaHhIJHRxdaJ3Wl69kYmsnkghSsJzLZbjpPTjYFzrYvth12pLKSWJccmAJ7IPHsHI28g7wq5ioqQAdIpVgxkABeIb3RIaIA)\n\nThat’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.\n\nInstead, we can make a _generic_ `Box` type which declares a _type parameter_.\n\nts\n\n`interface Box<Type> {`\n\n  `contents: Type;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA)\n\nYou might read this as “A `Box` of `Type` is something whose `contents` have type `Type`”. Later on, when we refer to `Box`, we have to give a _type argument_ in place of `Type`.\n\nts\n\n`let box: Box<string>;`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSgen7IAtKIQBXMKOGUANhDDIARljYYcTMFFABzEpyA)\n\nThink of `Box` as a template for a real type, where `Type` is a placeholder that will get replaced with some other type. When TypeScript sees `Box<string>`, it will replace every instance of `Type` in `Box<Type>` with `string`, and end up working with something like `{ contents: string }`. In other words, `Box<string>` and our earlier `StringBox` work identically.\n\nts\n\n`interface Box<Type> {`\n\n  `contents: Type;`\n\n`}`\n\n`interface StringBox {`\n\n  `contents: string;`\n\n`}`\n\n`let boxA: Box<string> = { contents: \"hello\" };`\n\n`boxA.contents;`\n\n        `(property) Box<string>.contents: string`\n\n`let boxB: StringBox = { contents: \"world\" };`\n\n`boxB.contents;`\n\n        `(property) StringBox.contents: string`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfS0SLEQoAymCigA5hkwVqtepGZsm4qdz6UANhDDIARlgCCbGdlUSQksgF4KChsuQAiABYQtW9M+Q9uhzCMAOjpHMCZuAHpImmQAPQB+Sm1dAyxUNjFLaSxkO3IHJXC2ZwB3dCgtABMfP0oA1BDFRnComJpEoA)\n\n`Box` is reusable in that `Type` can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new `Box` type at all (though we certainly could if we wanted to).\n\nts\n\n`interface Box<Type> {`\n\n  `contents: Type;`\n\n`}`\n\n`interface Apple {`\n\n  `// ....`\n\n`}`\n\n`// Same as '{ contents: Apple }'.`\n\n`type AppleBox = Box<Apple>;`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSy0JFiIUAQUKEANiio0A9HOQA6FUt78FyAMpwAtijhNkAcnK16kZm3FSUPY2rBExE6RkzIAvGizYb0kk4gA)\n\nThis also means that we can avoid overloads entirely by instead using [generic functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#generic-functions).\n\nts\n\n`function setContents<Type>(box: Box<Type>, newContents: Type) {`\n\n  `box.contents = newContents;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSygPQDkAWjEIArmDEjKMCSARhg9ZEwhgAwvUjM8RUgAoARljYYcHUgBpkICAHdtDZmysBKCtWSnMAOjoXMCZkAF47R2ddYO4eIA)\n\nIt is worth noting that type aliases can also be generic. We could have defined our new `Box<Type>` interface, which was:\n\nts\n\n`interface Box<Type> {`\n\n  `contents: Type;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA)\n\nby using a type alias instead:\n\nts\n\n`type Box<Type> = {`\n\n  `contents: Type;`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBVwQHxQLxQN4BQUUAxnAHbASUDOAXFGpANwEC+zQA)\n\nSince type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.\n\nts\n\n`type OrNull<Type> = Type | null;`\n\n`type OneOrMany<Type> = Type | Type[];`\n\n`type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;`\n\n           `type OneOrManyOrNull<Type> = OneOrMany<Type> | null`\n\n`type OneOrManyOrNullStrings = OneOrManyOrNull<string>;`\n\n               `type OneOrManyOrNullStrings = OneOrMany<string> | null`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGBQAXATwAdJQB5aAOQFcAbOgHgBUTIA+UAXlFdNAA+oAHb06AblwE2FYZEoBZAIbDCLNpx58yQ7QG0AupOn9ycxSsKVaDdaU0VqYxmfnRlqux3aSQofwB6APxSRKbm7pbWYgDK+NAAlsIA5ojcsm4eVk62iPFJyT64foFBQA)\n\nWe’ll circle back to type aliases in just a little bit.\n\n### [](#the-array-type)The `Array` Type\n\nGeneric object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.\n\nIt turns out we’ve been working with a type just like that throughout this handbook: the `Array` type. Whenever we write out types like `number[]` or `string[]`, that’s really just a shorthand for `Array<number>` and `Array<string>`.\n\nts\n\n`function doSomething(value: Array<string>) {`\n\n  `// ...`\n\n`}`\n\n`let myArray: string[] = [\"hello\", \"world\"];`\n\n`// either of these work!`\n\n`doSomething(myArray);`\n\n`doSomething(new Array(\"hello\", \"world\"));`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAG4CGANiNgFyICCATsxQJ4A8AzlM4UQB8ASkQBvAFCJEAehmIAdEokBfCRKq5EmdizbsGvfsQDaAXUQBeRCYBEebFSpxbAGkS2A7nGZVktswBudTlEbBh8bGZEOGBESO5sRG9mAGsAQglUDBx8ARIdPQ5hYOysXAJiEjBsTyZWDhJ7R2c3DxS-W2ESoA)\n\nMuch like the `Box` type above, `Array` itself is a generic type.\n\nts\n\n`interface Array<Type> {`\n\n`Global type 'Array' must have 1 type parameter(s).   All declarations of 'Array' must have identical type parameters.2317   2428Global type 'Array' must have 1 type parameter(s).   All declarations of 'Array' must have identical type parameters.    /**     * Gets or sets the length of the array.     */    length: number;    /**     * Removes the last element from an array and returns it.     */    pop(): Type | undefined;    /**     * Appends new elements to an array, and returns the new length of the array.     */    push(...items: Type[]): number;  A rest parameter must be of an array type.2370A rest parameter must be of an array type.    // ...  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsBkEsBGAuUAXATgVwKYCh5I0cMAzAQwGMdQA5LAW0RNAG8BfAoki60AZUyEA5m06FiZKjQBC0aABsc5SGK6TeNfgE8mitSFABaE5SxoTR9T2mgAghgzltAHgAq2gA44AfGzygoMAAVMEBgcGgAOI4aADOoNAYoHGxCWgAFjRKkMKZiaToWaDkjs4AdOGgwcDhOXkZqJCMzBgA3HjhIWGB1aAASjgM0ABuOOnFCuRxaKA4Sgw4RKCkGNAMJaqlTtqbACagGLFYGJAJ8GiVvTXhntCeABQAlKge3qAAPqBYkHs4pIQcHsOl1QlVInZPN5fglIDgAO5zBZLeLoaCbEplbQAGn2h2OpwmNDhiPq+WghUyNG2FXBtUCniwcQyD3KbIuQziry8OAA2gBdF6gZpMEggwKGNmVdhAA)\n\nModern JavaScript also provides other data structures which are generic, like `Map<K, V>`, `Set<T>`, and `Promise<T>`. All this really means is that because of how `Map`, `Set`, and `Promise` behave, they can work with any sets of types.\n\n### [](#the-readonlyarray-type)The `ReadonlyArray` Type\n\nThe `ReadonlyArray` is a special type that describes arrays that shouldn’t be changed.\n\nts\n\n`function doStuff(values: ReadonlyArray<string>) {`\n\n  `// We can read from 'values'...`\n\n  `const copy = values.slice();`\n\n  ``console.log(`The first value is ${values[0]}`);``\n\n  `// ...but we can't mutate 'values'.`\n\n  `values.push(\"hello!\");`\n\n`Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUACVI3BsV4BPAIKxuUgDyJy0SsQDmAPgCUoAN65QoEKADqkUKW61oYuqHzwAtqADkPfoLcA6P0asaFUCABylQAF5QTwFEH0ReSlJIdh0AbgDSILheSB9eOA12AAMAFQALS3xKJHJovgFQSkRQABJ9GMEAbQAGAF0AX2L03ADTPx8AI0I6gHdLa2I3OucZ7nJLDwbvHwDOuJDCRHL2ACJK3gKAQlORgaA)\n\nMuch like the `readonly` modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns `ReadonlyArray`s, it tells us we’re not meant to change the contents at all, and when we see a function that consumes `ReadonlyArray`s, it tells us that we can pass any array into that function without worrying that it will change its contents.\n\nUnlike `Array`, there isn’t a `ReadonlyArray` constructor that we can use.\n\nts\n\n`new ReadonlyArray(\"red\", \"green\", \"blue\");`\n\n`'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcBmAUAHaQDuoASpAIYAmcBANgJ4CCsljAFAETSTVcAaUFwDmvSAUHCARvQCukLgEoA3EA)\n\nInstead, we can assign regular `Array`s to `ReadonlyArray`s.\n\nts\n\n`const roArray: ReadonlyArray<string> = [\"red\", \"green\", \"blue\"];`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBATiAgnOBDAngLhgJQKaoAm4ANusmugDzRwCWYA5gHwwC8MA2gERx6HcANDG6M+eMEJEAjEgFc83ALoBuIA)\n\nJust as TypeScript provides a shorthand syntax for `Array<Type>` with `Type[]`, it also provides a shorthand syntax for `ReadonlyArray<Type>` with `readonly Type[]`.\n\nts\n\n`function doStuff(values: readonly string[]) {`\n\n  `// We can read from 'values'...`\n\n  `const copy = values.slice();`\n\n  ``console.log(`The first value is ${values[0]}`);``\n\n  `// ...but we can't mutate 'values'.`\n\n  `values.push(\"hello!\");`\n\n`Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUNEjcGxXgE9QictErEA5gG0AugEpQAb1yhQIPYaPGToAHoXLV6xd36wAdUihS3WiLGh88ALagA5Dz8gv4AdOF2pDSyLnAADtIAvKBBAoihiLyUpJDs6gDckdFwvJChvHCK7AAGACoAFs74lEjkKXwCoJSIoAAkWqmCygAMqgC+1QW4dgbhoQBGhG0A7s6uxP5tPkvc5M6BHSGhdoPpcYSI9ewARI28FQCE11NjQA)\n\nOne last thing to note is that unlike the `readonly` property modifier, assignability isn’t bidirectional between regular `Array`s and `ReadonlyArray`s.\n\nts\n\n`let x: readonly string[] = [];`\n\n`let y: string[] = [];`\n\n`x = y;`\n\n`y = x;`\n\n`The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYAMaBQAbSAF1AA9VpIBDAEzgDt8BPURI6AS3oHMBtAXVABeUAIDcBYqCao2nHgOGj+E3KSVMJLEaTFA)\n\n### [](#tuple-types)Tuple Types\n\nA _tuple type_ is another sort of `Array` type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.\n\nts\n\n`type StringNumberPair = [string, number];`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8ACgIaLxQC8UA2gM4IqoA0UyO+8AugNwBQA9PyjCRoseKgA9aTNlzJQA)\n\nHere, `StringNumberPair` is a tuple type of `string` and `number`. Like `ReadonlyArray`, it has no representation at runtime, but is significant to TypeScript. To the type system, `StringNumberPair` describes arrays whose `0` index contains a `string` and whose `1` index contains a `number`.\n\nts\n\n`function doSomething(pair: [string, number]) {`\n\n  `const a = pair[0];`\n\n       `const a: string`\n\n  `const b = pair[1];`\n\n       `const b: number`\n\n  `// ...`\n\n`}`\n\n`doSomething([\"hello\", 42]);`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyIDaAzlNYUQDSJgiYBG2agF0AlIgDeAKESIICFogqIAvIko0GABiEBuaYgD0BmTIB6Afn1ywCvirVVqDAIy79Rk4gvvjAOn+SAL6SkqgYOPjsJAwARHjYADYJcDFcACwATKI6QA)\n\nIf we try to index past the number of elements, we’ll get an error.\n\nts\n\n`function doSomething(pair: [string, number]) {`\n\n  `// ...`\n\n  `const c = pair[2];`\n\n`Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCcBmAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWioA2ogrQevADSgSRVgCMYAXQCUoAN55QoEKAB0ZvAdBla0q6AC8oEWIloNAbjwBfIA)\n\nWe can also [destructure tuples](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring) using JavaScript’s array destructuring.\n\nts\n\n`function doSomething(stringHash: [string, number]) {`\n\n  `const [inputString, hash] = stringHash;`\n\n  `console.log(inputString);`\n\n                  `const inputString: string`\n\n  `console.log(hash);`\n\n               `const hash: number`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAM5QBOhRAEgIZl4BciA2hdcQDSJgiYARtkoBdAJSIA3gChEiCAgrtCABxBQ0VGrzyM8oxAF5EnGgyYBuGXIVK4AG2wA6B3FJqNWrkXHX5APQB8iGhiAB6APw28opgZI4ubqR6TH62QWFhUTIAvkA)\n\n> Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements `0` and `1` to whatever we wanted.\n> \n> However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.\n\nOther than those length checks, simple tuple types like these are equivalent to types which are versions of `Array`s that declare properties for specific indexes, and that declare `length` with a numeric literal type.\n\nts\n\n`interface StringNumberPair {`\n\n  `// specialized properties`\n\n  `length: 2;`\n\n  `0: string;`\n\n  `1: number;`\n\n  `// Other 'Array<string | number>' members...`\n\n  `slice(start?: number, end?: number): Array<string | number>;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMpiqA5gOQK4C2ARtAApzBTIDeAUMsgPSPIDOADhAsHADbAAvCABNk7KAHtOUMMAit6yXhBBYwACwBcyAEwBuRQAZtrDNgMMAjNpCESUA4ubIA8hujIA5AEEoUOACeADymmKrIAD7ItsTQAHyeyAQQsVCsAHSZiqz8SAAUpnAyAPw2dtAANMgqwqXR5VAAlNq+-sGh2JH1qXEGAL5AA)\n\nAnother thing you may be interested in is that tuples can have optional properties by writing out a question mark (`?` after an element’s type). Optional tuple elements can only come at the end, and also affect the type of `length`.\n\nts\n\n`type Either2dOr3d = [number, number, number?];`\n\n`function setCoordinate(coord: Either2dOr3d) {`\n\n  `const [x, y, z] = coord;`\n\n              `const z: number | undefined`\n\n  ``console.log(`Provided coordinates had ${coord.length} dimensions`);``\n\n                                                  `(property) length: 2 | 3`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAoglsAFhATgJgCYHkUGYNQC8UA2gHYCuAtgEaoA0UltDT1dKA-ALoDcAUPwBmFMgGNgcAPZkoAZwjAAwlKkoMcMgENgEABRjV6gFywEydNjwYAlFADe-KFENk5wUgA9GIRgC9uIhcjDAFnAHpw52iY5wA9TkFnVzkpABsIADo0qQBzPQADAAUUKQA3OAwIAkM1DW1dOShELQIAEnta9WyIMlykAF8oDSpeuWk3ApswqEjY+YXFpaWE-gGgA)\n\nTuples can also have rest elements, which have to be an array/tuple type.\n\nts\n\n`type StringNumberBooleans = [string, number, ...boolean[]];`\n\n`type StringBooleansNumber = [string, ...boolean[], number];`\n\n`type BooleansStringNumber = [...boolean[], string, number];`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3AChQkWGzQlyVWljwEGzVkjSDho9ZK48t8GfPDRVY2nH0Ze2xkyECRa8RK572Zi6W0kA)\n\n*   `StringNumberBooleans` describes a tuple whose first two elements are `string` and `number` respectively, but which may have any number of `boolean`s following.\n*   `StringBooleansNumber` describes a tuple whose first element is `string` and then any number of `boolean`s and ending with a `number`.\n*   `BooleansStringNumber` describes a tuple whose starting elements are any number of `boolean`s and ending with a `string` then a `number`.\n\nA tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.\n\nts\n\n`const a: StringNumberBooleans = [\"hello\", 1];`\n\n`const b: StringNumberBooleans = [\"beautiful\", 2, true];`\n\n`const c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3ACgA9PKgBaVQGNMwVctlritYFEoAuWGzRY8BEuSq0GzAEQALCGTLFHXAIwzd+1ihcUzgkC15rUTs6RiZHfEpNRAAzTDIvKAAmLgRMCD89Ayg1EPMMCKIo6hinAHdieDIAEwyAZhz4PK5kyjIaCA6uqB6+gahc-OkgA)\n\nWhy might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in [rest parameters and arguments](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters-and-arguments), so that the following:\n\nts\n\n`function readButtonInput(...args: [string, number, ...boolean[]]) {`\n\n  `const [name, version, ...input] = args;`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBQB016yA5gM4BciA2g1MjGHQDSJgQAWwBGqZP2qURcOABsMYVgF1lASkQBvAFCJEEBBzZh0Q1PwBu4hvDCTq3MlGWIAvIlqMA3LsQB6P0QpbQBfIA)\n\nis basically equivalent to:\n\nts\n\n`function readButtonInput(name: string, version: number, ...input: boolean[]) {`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBRjoC2qAXIgM5TIxgDmANIgG6rKN4YBmBDUARv24A6WWzJQG4uHAA2GMAG0AugEpEAbwBQiRAHoziWdKMBfIA)\n\nThis is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.\n\n### [](#readonly-tuple-types)`readonly` Tuple Types\n\nOne final note about tuple types - tuple types have `readonly` variants, and can be specified by sticking a `readonly` modifier in front of them - just like with array shorthand syntax.\n\nts\n\n`function doSomething(pair: readonly [string, number]) {`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyLXYWpgA2AnogNoDOU1hIgBpEYEJgBG2agF0AlIgDeAKESIA9OrXaduvdoB6R4ydNmTqjVoB0t5QF8gA)\n\nAs you might expect, writing to any property of a `readonly` tuple isn’t allowed in TypeScript.\n\nts\n\n`function doSomething(pair: readonly [string, number]) {`\n\n  `pair[0] = \"hello!\";`\n\n`Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWipokYYxIAbAJ6gA2ogrQevADSgSRVgCMYAXQCUoAN55QoEWKU4joALygARJ0izZcAISuA3HgAvkA)\n\nTuples tend to be created and left un-modified in most code, so annotating types as `readonly` tuples when possible is a good default. This is also important given that array literals with `const` assertions will be inferred with `readonly` tuple types.\n\nts\n\n`let point = [3, 4] as const;`\n\n`function distanceFromOrigin([x, y]: [number, number]) {`\n\n  `return Math.sqrt(x ** 2 + y ** 2);`\n\n`}`\n\n`distanceFromOrigin(point);`\n\n`Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.   The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.   The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUADaQAuoADnAJYB2pAvKANoYA0oWAuqAIaKgDGcaomIBuPHgBmAV2r9ilIaAAmlEdzmQAYvAC2AeWiUA5jQAUjAB5sAnh1SNq03QCMYbJ65gcAlKADeeKCg0CTS0NSgALLcxAAWAHSIAI7QxGaWoABUWeigANSgNtm5aD7iAL4SquqaOnAGRqbUZhQ0xOVAA)\n\nHere, `distanceFromOrigin` never modifies its elements, but expects a mutable tuple. Since `point`’s type was inferred as `readonly [3, 4]`, it won’t be compatible with `[number, number]` since that type can’t guarantee `point`’s elements won’t be mutated.",
    "title": "TypeScript: Documentation - Object Types",
    "description": "How TypeScript describes the shapes of JavaScript objects.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html",
    "markdown": "# TypeScript: Documentation - Utility Types\n\nTypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.\n\n## [](#awaitedtype)`Awaited<Type>`\n\n> Released: [4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#the-awaited-type-and-promise-improvements)\n\nThis type is meant to model operations like `await` in `async` functions, or the `.then()` method on `Promise`s - specifically, the way that they recursively unwrap `Promise`s.\n\n##### [](#example)Example\n\nts\n\n`type A = Awaited<Promise<string>>;`\n\n    `type A = string`\n\n`type B = Awaited<Promise<Promise<number>>>;`\n\n    `type B = number`\n\n`type C = Awaited<boolean | Promise<number>>;`\n\n    `type C = number | boolean`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAglC8sDuBDAlsCATAPABQCcB7AWzQGcIdzgC0A7AcwD5mBuAKAHouo+A9APwcOoSFABCCZOky5CpClQVlKOegFcSAIwgFW7brwHDR4aAGFpMVBmw5tRIgBsIKelAA+UFUvVbdfUMePighIA)\n\n## [](#partialtype)`Partial<Type>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type with all properties of `Type` set to optional. This utility will return a type that represents all subsets of a given type.\n\n##### [](#example-1)Example\n\nts\n\n`interface Todo {`\n\n  `title: string;`\n\n  `description: string;`\n\n`}`\n\n`function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {`\n\n  `return { ...todo, ...fieldsToUpdate };`\n\n`}`\n\n`const todo1 = {`\n\n  `title: \"organize desk\",`\n\n  `description: \"clear clutter\",`\n\n`};`\n\n`const todo2 = updateTodo(todo1, {`\n\n  `description: \"throw out trash\",`\n\n`});`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgW+AL758MAK4gE-EMhk9McSBmwAKMFnTVN6ADTIYwCGUw0MAVVXqqyAApwoJOGQA8hgHwBKPDYoCDAZKCVcZAA6GN1sExioswsrW3tIZHFWSXwEATpiPQBGZABeQKISckcAInQoRjgQYAAvFA4aAGsaozYO7mA+YAFqGoQKV2RxmTBIKB6JVlz8sELsACYy5XSIQx1ikwIift5FUbAACyh0AHdkdBniKDgaC4XxP2YgA)\n\n## [](#requiredtype)`Required<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#improved-control-over-mapped-type-modifiers)\n\nConstructs a type consisting of all properties of `Type` set to required. The opposite of [`Partial`](#partialtype).\n\n##### [](#example-2)Example\n\nts\n\n`interface Props {`\n\n  `a?: number;`\n\n  `b?: string;`\n\n`}`\n\n`const obj: Props = { a: 5 };`\n\n`const obj2: Required<Props> = { a: 5 };`\n\n`Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.2741Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYAsBGAUAJYB2ALjAGYCGAxpKAArwAOioA3nqKJQPypEBXALYAjGAG5OoEX1CIS0YgHNJAXzx5qcIvNBwRAK1SM4LUAF523VAFZQqyZu279BtKgBKkAI4CC0SAATAB4TFgA+CytKW3txIA)\n\n## [](#readonlytype)`Readonly<Type>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type with all properties of `Type` set to `readonly`, meaning the properties of the constructed type cannot be reassigned.\n\n##### [](#example-3)Example\n\nts\n\n`interface Todo {`\n\n  `title: string;`\n\n`}`\n\n`const todo: Readonly<Todo> = {`\n\n  `title: \"Delete inactive users\",`\n\n`};`\n\n`todo.title = \"Hello\";`\n\n`Cannot assign to 'title' because it is a read-only property.2540Cannot assign to 'title' because it is a read-only property.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKACpwAmcoA3nqKCQSQDaRUiEtGIBzANx4AvnjzU4RYd2ZxUAJUiUWRPgE8APIxYA+UAF52nbrwGoARABFIAsqGI0eANzoBXRDCI9gA0MlJ4JKoAdDz8dJb2ABIufHD2EkA)\n\nThis utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a [frozen object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)).\n\n##### [](#objectfreeze)`Object.freeze`\n\nts\n\n`function freeze<Type>(obj: Type): Readonly<Type>;`\n\n## [](#recordkeys-type)`Record<Keys, Type>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs an object type whose property keys are `Keys` and whose property values are `Type`. This utility can be used to map the properties of a type to another type.\n\n##### [](#example-4)Example\n\nts\n\n`type CatName = \"miffy\" | \"boris\" | \"mordred\";`\n\n`interface CatInfo {`\n\n  `age: number;`\n\n  `breed: string;`\n\n`}`\n\n`const cats: Record<CatName, CatInfo> = {`\n\n  `miffy: { age: 10, breed: \"Persian\" },`\n\n  `boris: { age: 5, breed: \"Maine Coon\" },`\n\n  `mordred: { age: 16, breed: \"British Shorthair\" },`\n\n`};`\n\n`cats.boris;`\n\n `const cats: Record<CatName, CatInfo>`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwghsAcnAttAvFARCglgM3xCygB9sAjAewCdcBnE8nWgExolawG4AoX3ADtgEGvjgBjaPGABJQfipQA3ryhQ4AcwgAuKIICuKCqL7qKHTnvrA6gzXwC+-CVUE2oEhPT0AlCK40rAA8MshoADSwCPKKAHxQmKrqeIQgesoa2noAjAAMURYQVtgACqL0uHCCJI4RalDUdD4qWbpQAKyFlqx6WACycELSVG619SlsHL2tWu05AGzdxTNYAEJ0wAwAFlAAytu0wNtDNOO8jny8XsD0AHRNDHwA9M9QAHoA-EA)\n\n## [](#picktype-keys)`Pick<Type, Keys>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type by picking the set of properties `Keys` (string literal or union of string literals) from `Type`.\n\n##### [](#example-5)Example\n\nts\n\n`interface Todo {`\n\n  `title: string;`\n\n  `description: string;`\n\n  `completed: boolean;`\n\n`}`\n\n`type TodoPreview = Pick<Todo, \"title\" | \"completed\">;`\n\n`const todo: TodoPreview = {`\n\n  `title: \"Clean room\",`\n\n  `completed: false,`\n\n`};`\n\n`todo;`\n\n `const todo: TodoPreview`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVgF98+MAE8eKDNgAKUCADdgEAO7IAvMmPAEAawA8R9ABpkAIhLkEL7IAD5+EtKyEJi+AHys+BIgdMRY6NSephZWtg4ERAEU1L4AwqogyFDKkr5e4lIyEHLU8GQ0EHUaCWBprAD0fcgAegD8QA)\n\n## [](#omittype-keys)`Omit<Type, Keys>`\n\n> Released:  \n> [3.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type)\n\nConstructs a type by picking all properties from `Type` and then removing `Keys` (string literal or union of string literals). The opposite of [`Pick`](#picktype-keys).\n\n##### [](#example-6)Example\n\nts\n\n`interface Todo {`\n\n  `title: string;`\n\n  `description: string;`\n\n  `completed: boolean;`\n\n  `createdAt: number;`\n\n`}`\n\n`type TodoPreview = Omit<Todo, \"description\">;`\n\n`const todo: TodoPreview = {`\n\n  `title: \"Clean room\",`\n\n  `completed: false,`\n\n  `createdAt: 1615544252770,`\n\n`};`\n\n`todo;`\n\n `const todo: TodoPreview`\n\n`type TodoInfo = Omit<Todo, \"completed\" | \"createdAt\">;`\n\n`const todoInfo: TodoInfo = {`\n\n  `title: \"Pick up kids\",`\n\n  `description: \"Kindergarten closes at 5pm\",`\n\n`};`\n\n`todoInfo;`\n\n   `const todoInfo: TodoInfo`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVkW4Q4cgIJhqIAK6SF0VgF98+MAE8eKDNgAKUCADdgEAO7IAvMgA8pKkADxO6AA0yABEHFy8-CAxAHys+BIgdMRY6NQRrh5evgEERCTkVLEAwqogyFDKkjGR4lIyEHLU8GQ0EK2abjoQmPrUAIwAbOMArDMALPMATDNLAOxrAAytFulguawA9IfIAHoA-NZ2Dmi5AJIgMDgBwWER0TES0rIjMcgAPrEtMNRmBUulMtl9tgHk98vdHs88GwKhRqDFnMAEABrZBGHjIbHATA0FpseLcYB8YACdEAaVAHCgjDgUEg9QQZHQfRoyB0yBmPGaOz2CKeRxOFyAA)\n\n## [](#excludeuniontype-excludedmembers)`Exclude<UnionType, ExcludedMembers>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by excluding from `UnionType` all union members that are assignable to `ExcludedMembers`.\n\n##### [](#example-7)Example\n\nts\n\n`type T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;`\n\n     `type T0 = \"b\" | \"c\"`\n\n`type T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">;`\n\n     `type T1 = \"c\"`\n\n`type T2 = Exclude<string | number | (() => void), Function>;`\n\n     `type T2 = string | number`\n\n`type Shape =`\n\n  `| { kind: \"circle\"; radius: number }`\n\n  `| { kind: \"square\"; x: number }`\n\n  `| { kind: \"triangle\"; x: number; y: number };`\n\n`type T3 = Exclude<Shape, { kind: \"circle\" }>`\n\n     `type T3 = {     kind: \"square\";     x: number; } | {     kind: \"triangle\";     x: number;     y: number; }`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAogDwMYBsCuATCAHgCIBDYqAHymICMLriNiAaG8gPgG4AoAej5QhUAHoB+HqEiwAjElSZcBEuSo16apq3YN1xbv0HDxk8NBgAmeemz4iAZ2AAnAJYA7AOZq3OALa0IJzUACmCASiQOKAA3AHsXPDC2ADEcNwxgF1i3AwFhUQlTaQBlAAtSaUQeIWoAbygAa3c8AC4aDBcnbAhiLignUjwXHHs2n39AqABfarV6prdWmnsARxxSJx6+tDG-AKCZmqh55rbiZxdSTywtqB2ocf2+kF2Jg94i8wBma0U7QjKFQgbBOizOHS6NwoUw4hny4iAA)\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by extracting from `Type` all union members that are assignable to `Union`.\n\n##### [](#example-8)Example\n\nts\n\n`type T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">;`\n\n     `type T0 = \"a\"`\n\n`type T1 = Extract<string | number | (() => void), Function>;`\n\n     `type T1 = () => void`\n\n`type Shape =`\n\n  `| { kind: \"circle\"; radius: number }`\n\n  `| { kind: \"square\"; x: number }`\n\n  `| { kind: \"triangle\"; x: number; y: number };`\n\n`type T2 = Extract<Shape, { kind: \"circle\" }>`\n\n     `type T2 = {     kind: \"circle\";     radius: number; }`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAogD2AJwIYGNgA8ARNkVAD5REBGZlRuRANFaRVQGZEB8A3AFAB6QVFFQAegH5+oSLACMSVBhz4CAZywBLAHYBzdjoCuAW2oRM7ABRWAlEm5QAbgHstAE1ssAYkZ34tFx0+IRExKX4ZcGgAZQALbDlEflFKAG8oAGtddwAuKlwtTFwAGwgiXigcdy0jdXzjMwsoAF8U9gzsnTyqdQBHI2xMcsq0BtNzSzbUqE6c-KJtbH0yiqgxqEbJypBxpqmBKLkYACYldCw8QnjEiBY57oXC4tXW7lCxCUkgA)\n\n## [](#nonnullabletype)`NonNullable<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by excluding `null` and `undefined` from `Type`.\n\n##### [](#example-9)Example\n\nts\n\n`type T0 = NonNullable<string | number | undefined>;`\n\n     `type T0 = string | number`\n\n`type T1 = NonNullable<string[] | null | undefined>;`\n\n     `type T1 = string[]`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAcgewHYoK4BtcCGARrhADwDOwATgJYYDmUAPlBtgLZETUtTYYAJhABm9CIIB8AbgBQAenlRlUAHoB+WaEiwAjElSYc+YqUo16DANoBdPu3x8BwsRgkyFSlRqA)\n\n## [](#parameterstype)`Parameters<Type>`\n\n> Released:  \n> [3.1](https://github.com/microsoft/TypeScript/pull/26243)\n\nConstructs a tuple type from the types used in the parameters of a function type `Type`.\n\nFor overloaded functions, this will be the parameters of the _last_ signature; see [Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types).\n\n##### [](#example-10)Example\n\nts\n\n`declare function f1(arg: { a: number; b: string }): void;`\n\n`type T0 = Parameters<() => string>;`\n\n     `type T0 = []`\n\n`type T1 = Parameters<(s: string) => void>;`\n\n     `type T1 = [s: string]`\n\n`type T2 = Parameters<<T>(arg: T) => T>;`\n\n     `type T2 = [arg: unknown]`\n\n`type T3 = Parameters<typeof f1>;`\n\n     `type T3 = [arg: {     a: number;     b: string; }]`\n\n`type T4 = Parameters<any>;`\n\n     `type T4 = unknown[]`\n\n`type T5 = Parameters<never>;`\n\n     `type T5 = never`\n\n`type T6 = Parameters<string>;`\n\n`Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.       type T6 = never  type T7 = Parameters<Function>;  Type 'Function' does not satisfy the constraint '(...args: any) => any'.   Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.   Type 'Function' provides no match for the signature '(...args: any): any'.       type T7 = never  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQATSAYwBsBDaSUAMwFcA7IgFwEs56aBGACgoHNUAb1BlU9WgFsARjADcoKakRNoLen1ABfAJSoAbnBb5ZuXEwCeAByoAVAAygAvKAAKFMhMhMYiADzdtJwA+UGVVdSCTEFAY0AA9AH4zK1tOJ1d3T28kfxRQlTU+QMcQgyNI3GjYxOTrUBs0dLdoDy8fX18bIN5oAXrikK6osGqkizqbDCbMtpzxyDhqLgqqmJr5+qxplqz2snpzFZG1sZT6gFZt1uy-ekg9GCPY+NOJgDYr3ZywwqfR2tsAHZPrM-AAxBjMNj0P4nIA)\n\n## [](#constructorparameterstype)`ConstructorParameters<Type>`\n\n> Released:  \n> [3.1](https://github.com/microsoft/TypeScript/pull/26243)\n\nConstructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type `never` if `Type` is not a function).\n\n##### [](#example-11)Example\n\nts\n\n`type T0 = ConstructorParameters<ErrorConstructor>;`\n\n     `type T0 = [message?: string]`\n\n`type T1 = ConstructorParameters<FunctionConstructor>;`\n\n     `type T1 = string[]`\n\n`type T2 = ConstructorParameters<RegExpConstructor>;`\n\n     `type T2 = [pattern: string | RegExp, flags?: string]`\n\n`class C {`\n\n  `constructor(a: number, b: string) {}`\n\n`}`\n\n`type T3 = ConstructorParameters<typeof C>;`\n\n     `type T3 = [a: number, b: string]`\n\n`type T4 = ConstructorParameters<any>;`\n\n     `type T4 = unknown[]`\n\n`type T5 = ConstructorParameters<Function>;`\n\n`Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.   Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.   Type 'Function' provides no match for the signature 'new (...args: any): any'.       type T5 = never  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQIJEAXaASwGMjUAzAQwBtFJciBPAB0lABUAGUALygAwnAB2xaAFdKCAAq1otALaQiMRAB4AorASiJJGUQQA+ANz4woGwD0A-Cw5duARkEjxk4-MUq1GpoAYlJilKTiBt6y0BZWNnaObJw8aB5RRjEKSqrqSJoASpAA5toAHuwZ0jFxBAkOuOT0tIiIIqAA3rg25F6ZJtAAFLSoYlLKAEYwADSgE6iSpGLFAJSdAL64m8kuGOl91QPZ-nlaO3DUIrXWiU4p3Fj7hoe+OQH5tGKs1wmgDXcuACsT2iRz8uUCITCRAiYh+9XsQA)\n\n## [](#returntypetype)`ReturnType<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type consisting of the return type of function `Type`.\n\nFor overloaded functions, this will be the return type of the _last_ signature; see [Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types).\n\n##### [](#example-12)Example\n\nts\n\n`declare function f1(): { a: number; b: string };`\n\n`type T0 = ReturnType<() => string>;`\n\n     `type T0 = string`\n\n`type T1 = ReturnType<(s: string) => void>;`\n\n     `type T1 = void`\n\n`type T2 = ReturnType<<T>() => T>;`\n\n     `type T2 = unknown`\n\n`type T3 = ReturnType<<T extends U, U extends number[]>() => T>;`\n\n     `type T3 = number[]`\n\n`type T4 = ReturnType<typeof f1>;`\n\n     `type T4 = {     a: number;     b: string; }`\n\n`type T5 = ReturnType<any>;`\n\n     `type T5 = any`\n\n`type T6 = ReturnType<never>;`\n\n     `type T6 = never`\n\n`type T7 = ReturnType<string>;`\n\n`Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.       type T7 = any  type T8 = ReturnType<Function>;  Type 'Function' does not satisfy the constraint '(...args: any) => any'.   Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.   Type 'Function' provides no match for the signature '(...args: any): any'.       type T8 = any  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsX3awFAAmkAxgDYCG0koAZgK4B2pALgJZxP0CMAFAEpUAb1CVUTBgFsARjADcoGakSto7JgHNQAX3kECrAJ4AHWgBUADKAC8oAEqRWDaE3OnIAHkG2AfKFV1LV99EFBw0AA9AH5DD1BzHlsHJxc3D28UALUNTQE-UAA3OHYiEIIwiJi4swS0ZMdnV3czT09zXx8bfw7QsCrY41rzDAbU5oz20EgAD1ZIJiJEUABVABpV6bmFpdBJWRgAbQBdTvzuhPLK8Oqhi1w7RrSWrzu4Ol4r-pvB+PMAVjGTXSrUoTCMXwiUV+wwAbEDnhkmJBCjBIQMahYAOwIiatQK5dE-TEJAAcuJBXgAYsw2JwmEToUA)\n\n## [](#instancetypetype)`InstanceType<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type consisting of the instance type of a constructor function in `Type`.\n\n##### [](#example-13)Example\n\nts\n\n`class C {`\n\n  `x = 0;`\n\n  `y = 0;`\n\n`}`\n\n`type T0 = InstanceType<typeof C>;`\n\n     `type T0 = C`\n\n`type T1 = InstanceType<any>;`\n\n     `type T1 = any`\n\n`type T2 = InstanceType<never>;`\n\n     `type T2 = never`\n\n`type T3 = InstanceType<string>;`\n\n`Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.2344Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.       type T3 = any  type T4 = InstanceType<Function>;  Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.   Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.   Type 'Function' provides no match for the signature 'new (...args: any): any'.       type T4 = any  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsX3awFAgSIAu0AlgMamoBmAhgDaKQFVMOKKgDCoAbwKhQAD1ABeUAAYA3MNABPSTPkBfAgVKKADpFAAVaSoCSAOzIMzVSAd2QAPNr1w6fAHzziI0AD0A-Fr2hgCMphakVjZ2eg5Wip5EYD4BQXqGaOGW1rb2DmaQAG4wid4iqc76BhhZkTkxjmSUZgDmpcnlgZWGuFLm2dF5AGIArtakFHBm7T5+-kA)\n\n## [](#noinfertype)`NoInfer<Type>`\n\n> Released:  \n> [5.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#the-noinfer-utility-type)\n\nBlocks inferences to the contained type. Other than blocking inferences, `NoInfer<Type>` is identical to `Type`.\n\n##### [](#example-14)Example\n\nts\n\n`function createStreetLight<C extends string>(`\n\n  `colors: C[],`\n\n  `defaultColor?: NoInfer<C>,`\n\n`) {`\n\n  `// ...`\n\n`}`\n\n`createStreetLight([\"red\", \"yellow\", \"green\"], \"red\");  // OK`\n\n`createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");  // Error`\n\n## [](#thisparametertypetype)`ThisParameterType<Type>`\n\n> Released:  \n> [3.3](https://github.com/microsoft/TypeScript/pull/28920)\n\nExtracts the type of the [this](https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters) parameter for a function type, or [unknown](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type) if the function type has no `this` parameter.\n\n##### [](#example-15)Example\n\nts\n\n`function toHex(this: Number) {`\n\n  `return this.toString(16);`\n\n`}`\n\n`function numberToString(n: ThisParameterType<typeof toHex>) {`\n\n  `return toHex.apply(n);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFOAJApgDwBRQBYwDOAXIgHIgC2ARugE4CUiA3gFCKJ3pQh1L5EAdCgDKUOjDABzbAEYAbAwDcrAL6tWoSLASIwVWnQAqcMROnYwpIwUIAFAIZ0HlbvSMBPAA7oAPFG90OGBkNCwAPiY2Di4ePlCMTEEHLy8AGw9LZTUgA)\n\n## [](#omitthisparametertype)`OmitThisParameter<Type>`\n\n> Released:  \n> [3.3](https://github.com/microsoft/TypeScript/pull/28920)\n\nRemoves the [`this`](https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters) parameter from `Type`. If `Type` has no explicitly declared `this` parameter, the result is simply `Type`. Otherwise, a new function type with no `this` parameter is created from `Type`. Generics are erased and only the last overload signature is propagated into the new function type.\n\n##### [](#example-16)Example\n\nts\n\n`function toHex(this: Number) {`\n\n  `return this.toString(16);`\n\n`}`\n\n`const fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);`\n\n`console.log(fiveToHex());`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFOAJApgDwBRQBYwDOAXIgHIgC2ARugE4CUiA3gFCKJ3pQh1L5EAdCgDKUOjDABzbAEYAbAwDcrAL6tWEBISiJgMAG7oAKmiykA8pRhRjBQgAUAhnSeVu9ADxQAngAd0OGBkM0wAPkQAXhCMTEFqSQATbABWZQ0tMEI4ABt0QRy4GX0jU1jsBmUgA)\n\n## [](#thistypetype)`ThisType<Type>`\n\n> Released:  \n> [2.3](https://github.com/microsoft/TypeScript/pull/14141)\n\nThis utility does not return a transformed type. Instead, it serves as a marker for a contextual [`this`](https://www.typescriptlang.org/docs/handbook/functions.html#this) type. Note that the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis) flag must be enabled to use this utility.\n\n##### [](#example-17)Example\n\nts\n\n`type ObjectDescriptor<D, M> = {`\n\n  `data?: D;`\n\n  `methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M`\n\n`};`\n\n`function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {`\n\n  `let data: object = desc.data || {};`\n\n  `let methods: object = desc.methods || {};`\n\n  `return { ...data, ...methods } as D & M;`\n\n`}`\n\n`let obj = makeObject({`\n\n  `data: { x: 0, y: 0 },`\n\n  `methods: {`\n\n    `moveBy(dx: number, dy: number) {`\n\n      `this.x += dx; // Strongly typed this`\n\n      `this.y += dy; // Strongly typed this`\n\n    `},`\n\n  `},`\n\n`});`\n\n`obj.x = 10;`\n\n`obj.y = 20;`\n\n`obj.moveBy(5, 5);`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwCoAtUBnALlCwCcBXAUwCgsBPRa0AeQCMAra9LAEWqF05VIizRyAHj4AaUAFkAfKAC8oAN61QoACYBDLHoD8pPgG4toeNSx5oOwiYWgAZKHxEcTatNcLFZqAg7t6g0ABmoADktkRRoKiQVjZ2DgmEoHx+8rQAvha04ZSQvKjQSfB6ANbUHNy80nJKABQ6guikdTz87SJiEo3+AJSm2RqWyDa6Bnqk0FzdqrrtAHT6hqAAPpsa+RNT1rb2JGELvEttQiuHqRnbuxba5DaU5EnqoCtf63pyX9cpY6gXKgPQZLJueQWXK0WiTLCnThLSo1Lq8ZqabQ-UgfAAepAADHIGITgTJLDdjjjLNp4NAAG7UABCDFa+NAkEo8HY1HIch0JI5XJ55CG420ErIBEIK1xoAA1GodLjAsEAMoUcoAc2QDDI3h0UqINIlsRlesVugYqrAGvI2t1+uYhrNJty5O07ryQwK804sqWAEYCRY-Ss9WoAEwh2hhumMlnNACsciTPqAA)\n\nIn the example above, the `methods` object in the argument to `makeObject` has a contextual type that includes `ThisType<D & M>` and therefore the type of [this](https://www.typescriptlang.org/docs/handbook/functions.html#this) in methods within the `methods` object is `{ x: number, y: number } & { moveBy(dx: number, dy: number): void }`. Notice how the type of the `methods` property simultaneously is an inference target and a source for the `this` type in methods.\n\nThe `ThisType<T>` marker interface is simply an empty interface declared in `lib.d.ts`. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.\n\n## [](#intrinsic-string-manipulation-types)Intrinsic String Manipulation Types\n\n### [](#uppercasestringtype)`Uppercase<StringType>`\n\n### [](#lowercasestringtype)`Lowercase<StringType>`\n\n### [](#capitalizestringtype)`Capitalize<StringType>`\n\n### [](#uncapitalizestringtype)`Uncapitalize<StringType>`\n\nTo help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uppercasestringtype) documentation.",
    "title": "TypeScript: Documentation - Utility Types",
    "description": "Types which are globally included in TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/modules.html",
    "markdown": "# TypeScript: Documentation - Modules\n\nJavaScript has a long history of different ways to handle modularizing code. Having been around since 2012, TypeScript has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as the `import`/`export` syntax.\n\nES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes.\n\nFor focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJS `module.exports =` syntax, and you can find information about the other module patterns in the reference section under [Modules](https://www.typescriptlang.org/docs/handbook/modules.html).\n\n## [](#how-javascript-modules-are-defined)How JavaScript Modules are Defined\n\nIn TypeScript, just as in ECMAScript 2015, any file containing a top-level `import` or `export` is considered a module.\n\nConversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).\n\nModules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms.\n\n## [](#non-modules)Non-modules\n\nBefore we start, it’s important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an `import` declaration, `export`, or top-level `await` should be considered a script and not a module.\n\nInside a script file variables and types are declared to be in the shared global scope, and it’s assumed that you’ll either use the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) compiler option to join multiple input files into one output file, or use multiple `<script>` tags in your HTML to load these files (in the correct order!).\n\nIf you have a file that doesn’t currently have any `import`s or `export`s, but you want to be treated as a module, add the line:\n\nts\n\n`export {};`\n\n[Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAbwL4G4g)\n\nwhich will change the file to be a module exporting nothing. This syntax works regardless of your module target.\n\n## [](#modules-in-typescript)Modules in TypeScript\n\n> Additional Reading:  \n> [Impatient JS (Modules)](https://exploringjs.com/impatient-js/ch_modules.html#overview-syntax-of-ecmascript-modules)  \n> [MDN: JavaScript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)  \n\nThere are three main things to consider when writing module-based code in TypeScript:\n\n*   **Syntax**: What syntax do I want to use to import and export things?\n*   **Module Resolution**: What is the relationship between module names (or paths) and files on disk?\n*   **Module Output Target**: What should my emitted JavaScript module look like?\n\n### [](#es-module-syntax)ES Module Syntax\n\nA file can declare a main export via `export default`:\n\nts\n\n`// @filename: hello.ts`\n\n`export default function helloWorld() {`\n\n  `console.log(\"Hello, world!\");`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvkA)\n\nThis is then imported via:\n\nts\n\n`import helloWorld from \"./hello.js\";`\n\n`helloWorld();`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvtRAQYCFOhY0IgctKSUVD4AtDFC3CQxUdTQqIwskvgEskzyoJBMBKigJkTAuJlEAFZkJu5U5TIOyq5AA)\n\nIn addition to the default export, you can have more than one export of variables and functions via the `export` by omitting `default`:\n\nts\n\n`// @filename: maths.ts`\n\n`export var pi = 3.14;`\n\n`export let squareTwo = 1.41;`\n\n`export const phi = 1.61;`\n\n`export class RandomNumberGenerator {}`\n\n`export function absolute(num: number) {`\n\n  `if (num < 0) return num * -1;`\n\n  `return num;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNyLsZIUKgAJWREABMGVAA5FVQAI3gmAHEkeLxmUABvAF93U1lWSBVEC1xoa1BkGMIGWBVceAAKRGisJtj4gEoMqlBQaEhQRujQAB5QAAZOpnhcFSZEUFbQACpQAFo3Sh6pmbmF6JNMoA)\n\nThese can be used in another file via the `import` syntax:\n\nts\n\n`import { pi, phi, absolute } from \"./maths.js\";`\n\n`console.log(pi);`\n\n`const absPhi = absolute(phi);`\n\n        `const absPhi: number`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsx6WbkXYyQoVAAlZEQAEwZUADkVVAAjeCYAcSQ4vGZQAG8AX3dZVkgVRAtcaGtQZGjCBlgVXHgACkQorAaYuIBKdKpQUGhIUHqo0AAeUAAGdqZ4XBUmRFBm0AAqUABaN0ouiamZuaiTLMoQCBgEFHQsZDo6UgoDsGX7i2r75apoVBz07mgAGm4HX7KFSqNVAGVAkCYYVAACJiMAcAQSAArQjQkxUKw2SrwYiwBgAc1qPFaJkxtlK5QACg49IDKtU6vZoCSqIcuqAAHoAfiAA)\n\n### [](#additional-import-syntax)Additional Import Syntax\n\nAn import can be renamed using a format like `import {old as new}`:\n\nts\n\n`import { pi as π } from \"./maths.js\";`\n\n`console.log(π);`\n\n           `(alias) var π: number import π`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qICDAQp0WZHTqkKlGQFptAYwCuubZqrRUjFqADe3XskKhAA8CgAvqEhMGqUACJiwHAQkAFaE3lKUVDoMiIQMCMSwDADmABQOAJThMqA5ubkAegD8QA)\n\nYou can mix and match the above syntax into a single `import`:\n\nts\n\n`// @filename: maths.ts`\n\n`export const pi = 3.14;`\n\n`export default class RandomNumberGenerator {}`\n\n`// @filename: app.ts`\n\n`import RandomNumberGenerator, { pi as π } from \"./maths.js\";`\n\n`RandomNumberGenerator;`\n\n         `(alias) class RandomNumberGenerator import RandomNumberGenerator`\n\n`console.log(π);`\n\n           `(alias) const π: 3.14 import π`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQBjBxQ1u6UAXlABmYgEYALAG4qtRi1AATeJGQBXWKzaxkhQqABKyRAoaoAcqtQAjeEwDiSW3magA3gF8qVEBBgIU6FjIdHSkFJTQqHKshsamFta2DohOuMwANG6gvKA6oIADwKDuoJBMpqAARMTAOAQkAFaEFdKUVLEm5pY29o5MzkwtPgB6APxelBxcDAjEsAwA5gAU+QCUg2Cgm1tbo0A)\n\nYou can take all of the exported objects and put them into a single namespace using `* as name`:\n\nts\n\n`// @filename: app.ts`\n\n`import * as math from \"./maths.js\";`\n\n`console.log(math.pi);`\n\n`const positivePhi = math.absolute(math.phi);`\n\n          `const positivePhi: number`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNzIKxBdzRrUGQAI0IGWBVceAAKRBVULDjUYPgmAEpQAG8qUFBoSFBY+NAAHlAABgymeFwVJkRQJNAAKlAAWjdKXOra+sb4kwBfKhB2traLSPG2kbAoOCQ0TCC6OlIKSmhUWVZW5EJsPHxQSCYGVFAAImJgHAISACtCS5MqKxtw+GJYBgBzaLu+GIPDSJnetm4DEI0H8bHgAAUHHpAcQQmEIlEAUdgQ5QbNcrkAHoAfiAA)\n\nYou can import a file and _not_ include any variables into your current module via `import \"./file\"`:\n\nts\n\n`// @filename: app.ts`\n\n`import \"./maths.js\";`\n\n`console.log(\"3.14\");`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qIUAFp5AYwCuuebOlgocJGkyhkdOqQqVoqRi1AAiYsBwESAK0JWplKgoaJCDBMVgMAOYAFFbC4lYAlBJAA)\n\nIn this case, the `import` does nothing. However, all of the code in `maths.ts` was evaluated, which could trigger side-effects which affect other objects.\n\n#### [](#typescript-specific-es-module-syntax)TypeScript Specific ES Module Syntax\n\nTypes can be exported and imported using the same syntax as JavaScript values:\n\nts\n\n`// @filename: animal.ts`\n\n`export type Cat = { breed: string; yearOfBirth: number };`\n\n`export interface Dog {`\n\n  `breeds: string[];`\n\n  `yearOfBirth: number;`\n\n`}`\n\n`// @filename: app.ts`\n\n`import { Cat, Dog } from \"./animal.js\";`\n\n`type Animals = Cat | Dog;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVKrUYtQS4jcjIAxtwAiDMoiVKDikjKkcgpKygDaALqOlGGa2nqGJmaW1kzJdk6UIBAwCCjoWMh0dCQUlHiurKJ8xAA0oIHBdqCQTAyooABEhMA4eASEAFakg8kcXKAAgrj4sKSgQi2gAD4dQapAA)\n\nTypeScript has extended the `import` syntax with two concepts for declaring an import of a type:\n\n###### [](#import-type)`import type`\n\nWhich is an import statement which can _only_ import types:\n\nts\n\n`// @filename: animal.ts`\n\n`export type Cat = { breed: string; yearOfBirth: number };`\n\n`export type Dog = { breeds: string[]; yearOfBirth: number };`\n\n`export const createCatName = () => \"fluffy\";`\n\n`// @filename: valid.ts`\n\n`import type { Cat, Dog } from \"./animal.js\";`\n\n`export type Animals = Cat | Dog;`\n\n`// @filename: app.ts`\n\n`import type { createCatName } from \"./animal.js\";`\n\n`const name = createCatName();`\n\n`'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlFQgEDAIKOhYAG4E0NIkFJR4LqwcXCK8-AA0oF4+dqCQTAyoLYTAOHgEhABWpD3pC27LAIK4+LCkvqusAD6b3r39YFA4EhKlhkHQ6DN-hAbPsmMFQABGADMADYEVR5pl7txRIUtMQSvwKuh7Lt9odmsdTi9Ltdejk8qwRlUCkUCaVifA6qogA)\n\n###### [](#inline-type-imports)Inline `type` imports\n\nTypeScript 4.5 also allows for individual imports to be prefixed with `type` to indicate that the imported reference is a type:\n\nts\n\n`// @filename: app.ts`\n\n`import { createCatName, type Cat, type Dog } from \"./animal.js\";`\n\n`export type Animals = Cat | Dog;`\n\n`const name = createCatName();`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlCCgALRDWebEQwNU-VBwSJVYyHR0JBSUeC6sooVaxCX8FegANG5cvPxHHCdePnagkEwMqC2EwDh4BIQAVqQ9VOnrx9wAIK4fCwUi+U6sAA+oCuvRyeVYKHQEK2xVK+3gdVUQA)\n\nTogether these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed.\n\n#### [](#es-module-syntax-with-commonjs-behavior)ES Module Syntax with CommonJS Behavior\n\nTypeScript has ES Module syntax which _directly_ correlates to a CommonJS and AMD `require`. Imports using ES Module are _for most cases_ the same as the `require` from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:\n\nts\n\n`import fs = require(\"fs\");`\n\n`const code = fs.readFileSync(\"hello.ts\", \"utf8\");`\n\n[Try](https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAAQFsKBXAG2gC5QyUmw6IAVniZgAtLOSd0s6UwCWbbKUjpQsPKAKgYAR04qYACiK6iASgDcTIYjzahlfTrwA6GAENyAGIqvADKmCiWABbQ3NykXuh4RAA0oEQKsAActnZAA)\n\nYou can learn more about this syntax in the [modules reference page](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require).\n\n## [](#commonjs-syntax)CommonJS Syntax\n\nCommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier.\n\n#### [](#exporting)Exporting\n\nIdentifiers are exported via setting the `exports` property on a global called `module`.\n\nts\n\n`function absolute(num: number) {`\n\n  `if (num < 0) return num * -1;`\n\n  `return num;`\n\n`}`\n\n`module.exports = {`\n\n  `pi: 3.14,`\n\n  `squareTwo: 1.41,`\n\n  `phi: 1.61,`\n\n  `absolute,`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAWjeQFd02WnYOU6AJalEoAIYAjPKQA2XaAApEHALYAuUCtWSEASlABvJqFBDYoZWoigADAZjoOkMdtAAqUCwCMAbhOgjs6uav6MAL5MTKoUHLLQAHTQAB7YpJDoeKAERgHYQpoAzAneACwANAF4AI4c4jAAKgDupJreCaXelYym2AAWBaDtAGxdAVIy8ujQ3eG+QA)\n\nThen these files can be imported via a `require` statement:\n\nts\n\n`const maths = require(\"./maths\");`\n\n`maths.pi;`\n\n      `any`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgsdhcdqFZCTaiiJxqbjAVicQhqHxleFcbjdS5gYKgAB6AH4gA)\n\nOr you can simplify a bit using the destructuring feature in JavaScript:\n\nts\n\n`const { squareTwo } = require(\"./maths\");`\n\n`squareTwo;`\n\n   `const squareTwo: any`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgBUATKazBagcrtQrISbUURONTcYCsTiENQ+Mog6bIebQS5gAB6AH4gA)\n\n### [](#commonjs-and-es-modules-interop)CommonJS and ES Modules interop\n\nThere is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop).\n\n## [](#typescripts-module-resolution-options)TypeScript’s Module Resolution Options\n\nModule resolution is the process of taking a string from the `import` or `require` statement, and determining what file that string refers to.\n\nTypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option [`module`](https://www.typescriptlang.org/tsconfig#module) is not `commonjs`, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for `.ts` and `.d.ts`.\n\nThere are many TSConfig flags which influence the module strategy within TypeScript: [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution), [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl), [`paths`](https://www.typescriptlang.org/tsconfig#paths), [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs).\n\nFor the full details on how these strategies work, you can consult the [Module Resolution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#the-moduleresolution-compiler-option) reference page.\n\n## [](#typescripts-module-output-options)TypeScript’s Module Output Options\n\nThere are two options which affect the emitted JavaScript output:\n\n*   [`target`](https://www.typescriptlang.org/tsconfig#target) which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact\n*   [`module`](https://www.typescriptlang.org/tsconfig#module) which determines what code is used for modules to interact with each other\n\nWhich [`target`](https://www.typescriptlang.org/tsconfig#target) you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.\n\nAll communication between modules happens via a module loader, the compiler option [`module`](https://www.typescriptlang.org/tsconfig#module) determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.\n\nFor example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for [`module`](https://www.typescriptlang.org/tsconfig#module):\n\nts\n\n`import { valueOfPi } from \"./constants.js\";`\n\n`export const twoPi = valueOfPi * 2;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxge0QM4AuyiRBAdOQLABQ8AHgA64BORO+xoAbsrAFd4AeUgAFaKAC8oAMwUAjABYATAG46ICDAQp0WaIgAmjKgU1gAtNewCi1y3WioW7UAG9e-IaImgAvqCQrLiooABEFMB4hCRklABWBOEatHSMrhwx3EQA7rh+MnyCIuKSAFSg6kA)\n\n#### [](#es2020)`ES2020`\n\nts\n\n`import { valueOfPi } from \"./constants.js\";`\n\n`export const twoPi = valueOfPi * 2;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBco5kATAAyM57gB2siATl7F5DlTIADn3SgA3qABuAQ1LFyAeQBmABVSgAvqBW9koAEQA6YAGNYbSOllt0kYwCtIhgNw4c5AB6iu4i1bi6PCwGqAAvDLyiqphAFSgdK5AA)\n\n#### [](#commonjs)`CommonJS`\n\nts\n\n`\"use strict\";`\n\n`Object.defineProperty(exports, \"__esModule\", { value: true });`\n\n`exports.twoPi = void 0;`\n\n`const constants_js_1 = require(\"./constants.js\");`\n\n`exports.twoPi = constants_js_1.valueOfPi * 2;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoAxrMgQHYBWkOe4jsiATj7DzbZUyAA4D0oAN6gAbgENSxcgHkAZgAVUoAL6g1-ZKABEAOmB1GkdPMbpIp1sYDcOHOQAe4npMvXQ6PCwWqAAvHKKyuohAFSgAEzOQA)\n\n#### [](#umd)`UMD`\n\nts\n\n`(function (factory) {`\n\n    `if (typeof module === \"object\" && typeof module.exports === \"object\") {`\n\n        `var v = factory(require, exports);`\n\n        `if (v !== undefined) module.exports = v;`\n\n    `}`\n\n    `else if (typeof define === \"function\" && define.amd) {`\n\n        `define([\"require\", \"exports\", \"./constants.js\"], factory);`\n\n    `}`\n\n`})(function (require, exports) {`\n\n    `\"use strict\";`\n\n    `Object.defineProperty(exports, \"__esModule\", { value: true });`\n\n    `exports.twoPi = void 0;`\n\n    `const constants_js_1 = require(\"./constants.js\");`\n\n    `exports.twoPi = constants_js_1.valueOfPi * 2;`\n\n`});`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoxyhOe4AdrIgE5uxuQ6rIAOXdKADeoAG4BDUsXIB5AGYAFVKAC+oBZ2SgARADpgAY1hNI6SU3SR9AK0i6A3DhzkAHoLbCTZ4eniwKqAAvBLSsopBAFSgAEyOQA)\n\n> Note that ES2020 is effectively the same as the original `index.ts`.\n\nYou can see all of the available options and what their emitted JavaScript code looks like in the [TSConfig Reference for `module`](https://www.typescriptlang.org/tsconfig#module).\n\n## [](#typescript-namespaces)TypeScript namespaces\n\nTypeScript has its own module format called `namespaces` which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use [in DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces in [the namespaces reference page](https://www.typescriptlang.org/docs/handbook/namespaces.html).",
    "title": "TypeScript: Documentation - Modules",
    "description": "How JavaScript handles communicating across file boundaries.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html",
    "markdown": "# TypeScript: Documentation - Classes\n\n> Background Reading:  \n> [Classes (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)\n\nTypeScript offers full support for the `class` keyword introduced in ES2015.\n\nAs with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types.\n\n## [](#class-members)Class Members\n\nHere’s the most basic class - an empty one:\n\nts\n\n`class Point {}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwL5A)\n\nThis class isn’t very useful yet, so let’s start adding some members.\n\n### [](#fields)Fields\n\nA field declaration creates a public writeable property on a class:\n\nts\n\n`class Point {`\n\n  `x: number;`\n\n  `y: number;`\n\n`}`\n\n`const pt = new Point();`\n\n`pt.x = 0;`\n\n`pt.y = 0;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQKdPGLRQAbz6hQAD1bEArgFsARrgDcc0PmXqtsXbwC+fPoiYxQmKQF5QxbAHdR4yQAoAlKfsAdAqgTgAM-tAB+CGg4UA)\n\nAs with other locations, the type annotation is optional, but will be an implicit `any` if not specified.\n\nFields can also have _initializers_; these will run automatically when the class is instantiated:\n\nts\n\n`class Point {`\n\n  `x = 0;`\n\n  `y = 0;`\n\n`}`\n\n`const pt = new Point();`\n\n`// Prints 0, 0`\n\n``console.log(`${pt.x}, ${pt.y}`);``\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaABgG5d8BPE8qnAX112HmQnQAd1TkApgHc4SNAAoAlIwD0MuACcUqGGQA05NhwjwQAgHQh4Ac3EADACQZe+gkw1WbNJmelA)\n\nJust like with `const`, `let`, and `var`, the initializer of a class property will be used to infer its type:\n\nts\n\n`const pt = new Point();`\n\n`pt.x = \"0\";`\n\n`Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgBjAGwENFFQAFOASwDsAXUAb31FAA9QBeUABgDcbUAE8e-IXgC++EKAC0iggFcGi+fgJw6iJgAcmvOpADuVWowAUASkkGAdF14AiPs4FA)\n\n#### [](#--strictpropertyinitialization)`--strictPropertyInitialization`\n\nThe [`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization) setting controls whether class fields need to be initialized in the constructor.\n\nts\n\n`class BadGreeter {`\n\n  `name: string;`\n\n`Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYBsAWAsAFADGANgIaKKgBCZAJgOLSSQAuMoA3oaKAHZkAtpFSJW0AJZ8A5gG5CAXyA)\n\nts\n\n`class GoodGreeter {`\n\n  `name: string;`\n\n  `constructor() {`\n\n    `this.name = \"hello\";`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiD28AmsBOBTdAXdroG8BYAKGmgDswBbdALmgi1QEtyBzAbhJLOHnMaoArsCzxUACgCUBHmWhYAFswgA6SjWgBeaACJF6ECHi6upaAF8SFoA)\n\nNote that the field needs to be initialized _in the constructor itself_. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members.\n\nIf you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the _definite assignment assertion operator_, `!`:\n\nts\n\n`class OKGreeter {`\n\n  `// Not initialized, but no error`\n\n  `name!: string;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDyDSBxATgU1QF1c6BvAsAFDTQD0p0AcgPYbQCWAdvRvWCPQF6oAmANNABGAVzqNq0bMmrIiJRmAC2qAIQAuaBAzImAcwDcRAL5A)\n\n### [](#readonly)`readonly`\n\nFields may be prefixed with the `readonly` modifier. This prevents assignments to the field outside of the constructor.\n\nts\n\n`class Greeter {`\n\n  `readonly name: string = \"world\";`\n\n  `constructor(otherName?: string) {`\n\n    `if (otherName !== undefined) {`\n\n      `this.name = otherName;`\n\n    `}`\n\n  `}`\n\n  `err() {`\n\n    `this.name = \"not ok\";`\n\n`Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.    }  }  const g = new Greeter();  g.name = \"also not ok\";  Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGd2cBYAKAGMAbAQ0UVAHFpJIAXGUAbxNFEcoBM4AO3IBPUIMoBbSKkTNoAS0EBzUAF5QAIgDuCcn00BuEl1Ckhc6AFdSzBAAo4zABYwAclMgB+WfKXKASg5TbgUAM1BHF3dPUABCNQ0rQT5IMKVIPiDOYm480BcFRAA6CWl1UCdXaA9pY1y8gF9TZuJTGGh7bJCC5yLS2I1NQSdKgGsjFpJW80E5UFUNQUhtekYWGC765QHyocpyRDhxUbgJwyA)\n\n### [](#constructors)Constructors\n\n> Background Reading:  \n> [Constructor (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor)  \n\nClass constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads:\n\nts\n\n`class Point {`\n\n  `x: number;`\n\n  `y: number;`\n\n  `// Normal signature with defaults`\n\n  `constructor(x = 0, y = 0) {`\n\n    `this.x = x;`\n\n    `this.y = y;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCcBuXfATxPOvqZ2egHo+0AHLw6FMCGgREAc2RhUZOjWgB3RKgAW0ACY0AZmDIhUEXsHjIIqOmWCpRACgLQAvNAAMAGmgs3ngEpMXnwtRAgAOhd3Am58UM1wiL93FjjoAF9cDKA)\n\nts\n\n`class Point {`\n\n  `x: number = 0;`\n\n  `y: number = 0;`\n\n  `// Constructor overloads`\n\n  `constructor(x: number, y: number);`\n\n  `constructor(xy: string);`\n\n  `constructor(x: string | number, y: number = 0) {`\n\n    `// Code logic here`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCdoBeaABgG5d8BPE86+pqw45O0APRjoAYXjIIqOmWCp4DeADd6IeGAAmEUcFnzFy1QApipSrToAaaD2v86ASmH4jchUpV1LTiYoAObuhsY+Zv5WQcjB0AA+zrYOTny2giyumKL4EtLwujTQ2sGIwNAAFvQ0ogC+uHVAA)\n\nThere are just a few differences between class constructor signatures and function signatures:\n\n*   Constructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later\n*   Constructors can’t have return type annotations - the class instance type is always what’s returned\n\n#### [](#super-calls)Super Calls\n\nJust as in JavaScript, if you have a base class, you’ll need to call `super();` in your constructor body before using any `this.` members:\n\nts\n\n`class Base {`\n\n  `k = 4;`\n\n`}`\n\n`class Derived extends Base {`\n\n  `constructor() {`\n\n    `// Prints a wrong value in ES5; throws exception in ES6`\n\n    `console.log(this.k);`\n\n`'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class.      super();    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwHYAMWCcBYAKAGMAbAQ0UVACFLJQBvI0UAa1AF5QAWAbiIBfIkTKVqAERgBLAG6QAJqEgAPAC6QAdgup1EDZoVbE4mxGugBXYmoQAKAJRMWrUCFAAFaNM1rq5UAB3eE0Ac1BZclJLBh9QAFEAZQBWPlA1AAt4QOpVYkgABzVpU1A4pIA2F2NTRDhSSAA6UjhQu0zpREa2BwEjV0RLAphHPtZhQkEgA)\n\nForgetting to call `super` is an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary.\n\n### [](#methods)Methods\n\n> Background Reading:  \n> [Method definitions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions)  \n\nA function property on a class is called a _method_. Methods can use all the same type annotations as functions and constructors:\n\nts\n\n`class Point {`\n\n  `x = 10;`\n\n  `y = 10;`\n\n  `scale(n: number): void {`\n\n    `this.x *= n;`\n\n    `this.y *= n;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaARgAYBuXfATxPOt1ugmDBAFMAKZALmjIArgFsARlwBOASkEA3JABNMrfKgAWiCADoiAKlLIaefNE3adDQ0JP4AvrntA)\n\nOther than the standard type annotations, TypeScript doesn’t add anything else new to methods.\n\nNote that inside a method body, it is still mandatory to access fields and other methods via `this.`. An unqualified name in a method body will always refer to something in the enclosing scope:\n\nts\n\n`let x: number = 0;`\n\n`class C {`\n\n  `x: string = \"hello\";`\n\n  `m() {`\n\n    `// This is trying to modify 'x' from line 1, not the class property`\n\n    `x = \"world\";`\n\n`Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UA7AVwFsAjGUAXlAAYBuffAYwIENEiUAGFQAb3yhyqRMWgBLSgHMWoAEQALSAQJx1XPFNC0AFAEoJx6SFAAVTQuFPQ8gJ5LVxOCbgATBQAzN1AAcjJQ0ED4WlACJUhQAEYAGlBKOFJibVA+QWEAB3gCmGI3a3I1dQB3BAI-A2MAX3wmoA)\n\n### [](#getters--setters)Getters / Setters\n\nClasses can also have _accessors_:\n\nts\n\n`class C {`\n\n  `_length = 0;`\n\n  `get length() {`\n\n    `return this._length;`\n\n  `}`\n\n  `set length(value) {`\n\n    `this._length = value;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8CwAoa0D6ICmA7A5gC4AW0AvNAAwDcq6+2h0OBJAFAJSJ3rQBOjAK59c0EgEsIAOix4ixWmmgBfHhEbM57AG5gQg7F2RL0E6bNakKu-dkXpVKZUA)\n\n> Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript. It’s fine to expose public fields if you don’t need to add additional logic during the get/set operations.\n\nTypeScript has some special inference rules for accessors:\n\n*   If `get` exists but no `set`, the property is automatically `readonly`\n*   If the type of the setter parameter is not specified, it is inferred from the return type of the getter\n\nSince [TypeScript 4.3](https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/), it is possible to have accessors with different types for getting and setting.\n\nts\n\n`class Thing {`\n\n  `_size = 0;`\n\n  `get size(): number {`\n\n    `return this._size;`\n\n  `}`\n\n  `set size(value: string | number | boolean) {`\n\n    `let num = Number(value);`\n\n    `// Don't allow NaN, Infinity, etc`\n\n    `if (!Number.isFinite(num)) {`\n\n      `this._size = 0;`\n\n      `return;`\n\n    `}`\n\n    `this._size = num;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwLAChrQH0JEAvAU2gF5oAGAbl131TIBdpjyAKASgC5oyAK4BbAEZkATpib5oktkMnJorJBAB0RUmQZ5oAX0b6IbDjq4A3MCCFkBEVpJToAPoNETp7sQHtfIGRgyDwy+viB7MIiVNAAcp5SVjZ2PHqy+AD0mdAAIr7IAOTsNiC+AO7xYHEANNAAksgAZiiIrACedWzAxnLQiE3QXACECeJSGogQAGKtrGRc0Tyh2OFyalNanBTU9BlyCqxKyHp9Rjj7G5ra5LHRp4a4BkA)\n\n### [](#index-signatures)Index Signatures\n\nClasses can declare index signatures; these work the same as [Index Signatures for other object types](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures):\n\nts\n\n`class MyClass {`\n\n  `[s: string]: boolean | ((s: string) => boolean);`\n\n  `check(s: string) {`\n\n    `return this[s] as boolean;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0DaEAXNBAC4BOAlgHYDmAusQEYD2LIApmNdAD7QAKAURIUatAJTQAvAD5ordl2oSA3Nmy5gACw7AA1sOJkqdKZhy5o5DqQCu5HqW2UIBetEgK2nbussAvtgBQA)\n\nBecause the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types. Generally it’s better to store indexed data in another place instead of on the class instance itself.\n\n## [](#class-heritage)Class Heritage\n\nLike other languages with object-oriented features, classes in JavaScript can inherit from base classes.\n\n### [](#implements-clauses)`implements` Clauses\n\nYou can use an `implements` clause to check that a class satisfies a particular `interface`. An error will be issued if a class fails to correctly implement it:\n\nts\n\n`interface Pingable {`\n\n  `ping(): void;`\n\n`}`\n\n`class Sonar implements Pingable {`\n\n  `ping() {`\n\n    `console.log(\"ping!\");`\n\n  `}`\n\n`}`\n\n`class Ball implements Pingable {`\n\n`Class 'Ball' incorrectly implements interface 'Pingable'.   Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'.   Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.    pong() {      console.log(\"pong!\");    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBY0AYCwAoASwDsAXGAMwEMBjSUABRIHMqAjAG3oG8DRQADiwAUASlQA3OIQAmAbgIBfAgRocqiRKADKcYlWihCAWwFdjkMlqbFWnHn0EjRoXvn78aexHC4A6DjhmYQAiIVsAQhDRBXdQZXwE1XVNUAAhKg4OI1NzS1JrFnYuV0cBPWCXNw9QL2Iff0DgsIqomMcExSA)\n\nClasses may also implement multiple interfaces, e.g. `class C implements A, B {`.\n\n#### [](#cautions)Cautions\n\nIt’s important to understand that an `implements` clause is only a check that the class can be treated as the interface type. It doesn’t change the type of the class or its methods _at all_. A common source of error is to assume that an `implements` clause will change the class type - it doesn’t!\n\nts\n\n`interface Checkable {`\n\n  `check(name: string): boolean;`\n\n`}`\n\n`class NameChecker implements Checkable {`\n\n  `check(s) {`\n\n`Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.      // Notice no error here      return s.toLowerCase() === \"ok\";                   any    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYMDYCwAoASwDsAXGAMwEMBjSUAYQAtIaBrKgIwBt6BvAqFA0W7ABTEqAW0ipEpaCQDmASlSc4cXlWIBuAgF8CBGtyqJEoAHLTIzVmxihCUgA68ZZS-fZdeoAXwhEQcxRBUAwSFQEGs4UkI6UGI4UBh4aFAWaEgooRzSAFdoYlBEADpSOAAZOAB3GAZzSDEIgF4O0AAiODYu-SDo2OiR0AA9AH4oo3wDIA)\n\nIn this example, we perhaps expected that `s`’s type would be influenced by the `name: string` parameter of `check`. It is not - `implements` clauses don’t change how the class body is checked or its type inferred.\n\nSimilarly, implementing an interface with an optional property doesn’t create that property:\n\nts\n\n`interface A {`\n\n  `x: number;`\n\n  `y?: number;`\n\n`}`\n\n`class C implements A {`\n\n  `x = 0;`\n\n`}`\n\n`const c = new C();`\n\n`c.y = 10;`\n\n`Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoASwDsAXGAMwEMBjSUAQVAG8DRQAPVYgVwFsARjADcbUAE8A-N35Doo-AF8CNADZVEiUAGFQhPgAdVkPpDJamrfOw6gAvKAAMC5fhpxiiUqBr3QxSAB3HQAKAEoFGgA6cT8ARmcgA)\n\n### [](#extends-clauses)`extends` Clauses\n\n> Background Reading:  \n> [extends keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends)  \n\nClasses may `extend` from a base class. A derived class has all the properties and methods of its base class, and can also define additional members.\n\nts\n\n`class Animal {`\n\n  `move() {`\n\n    `console.log(\"Moving along!\");`\n\n  `}`\n\n`}`\n\n`class Dog extends Animal {`\n\n  `woof(times: number) {`\n\n    `for (let i = 0; i < times; i++) {`\n\n      `console.log(\"woof!\");`\n\n    `}`\n\n  `}`\n\n`}`\n\n`const d = new Dog();`\n\n`// Base class method`\n\n`d.move();`\n\n`// Derived class method`\n\n`d.woof(3);`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeBYAUNayA9gG4CmAFAJSa777CHwSEikB0IhA5uQEQCyJRPC7Q0jLgEJelANy1oAX1zKcuUJBgARbtFIAPAC6l4AExgIUaGnmgB3QoQBm5QylIQAXNHgBXZABGpABO1Ni2+E6EwdDkrIbQiNAAvNAADLKJ0AA80G7IHpmIANTFYQp00AxMLOycPLwOztJyFUoKqqrqjBAJpik+pHbQOjytOAD0E9AAQpCkVeBQBKSGABaEprimbERkVPKT01ohiGT9GssF65vbbE0uAMxyQA)\n\n#### [](#overriding-methods)Overriding Methods\n\n> Background Reading:  \n> [super keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super)  \n\nA derived class can also override a base class field or property. You can use the `super.` syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a “super field”.\n\nTypeScript enforces that a derived class is always a subtype of its base class.\n\nFor example, here’s a legal way to override a method:\n\nts\n\n`class Base {`\n\n  `greet() {`\n\n    `console.log(\"Hello, world!\");`\n\n  `}`\n\n`}`\n\n`class Derived extends Base {`\n\n  `greet(name?: string) {`\n\n    `if (name === undefined) {`\n\n      `super.greet();`\n\n    `} else {`\n\n      ``console.log(`Hello, ${name.toUpperCase()}`);``\n\n    `}`\n\n  `}`\n\n`}`\n\n`const d = new Derived();`\n\n`d.greet();`\n\n`d.greet(\"reader\");`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvQZQkGABEEuAJYA3BJOgIAHoQR1JMeBCRpMOfEWJ0wAWwQB+AFzQEISGdNjkzlTQBgBm0B7eSAC8KdAArrYIMQZ0phFKURBpAA76LHgEJAoFKuYgjhQuUbQMTKzsnAAGfAI0wgAkyJ4+LIQ0AKrFpbgAwohkyp3VTSpK6uqa9MHQZknQuSLQeoYmkmSK6JLlblUXVxXuXPhgkvpy8kA)\n\nIt’s important that a derived class follow its base class contract. Remember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:\n\nts\n\n`// Alias the derived instance through a base class reference`\n\n`const b: Base = d;`\n\n`// No problem`\n\n`b.greet();`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvShIMACIJcASwBuCSdAQAPQgjqSY8CEmTraDQtFMBeaHQQjoug2NJMkV0AHow6ABaGOAAV0IYqIwI6ABBEH1IaEIACyRJPSMTaH1XMDpgJDzcGjjsXOgwaAAjRGhNKGh8ADM9ayqMFwg3FoAuOHavSVDUgDkaaAAHWpbmAFsMFpY8AhIFIA)\n\nWhat if `Derived` didn’t follow `Base`’s contract?\n\nts\n\n`class Base {`\n\n  `greet() {`\n\n    `console.log(\"Hello, world!\");`\n\n  `}`\n\n`}`\n\n`class Derived extends Base {`\n\n  `// Make this parameter required`\n\n  `greet(name: string) {`\n\n``Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.   Type '(name: string) => void' is not assignable to type '() => void'.     Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.   Type '(name: string) => void' is not assignable to type '() => void'.     Target signature provides too few arguments. Expected 1 or more, but got 0.      console.log(`Hello, ${name.toUpperCase()}`);    }  }  ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMA2AsAFADGANgIaKKgBCFkoA3oaKAObSSQAuAFAJSNmLUETgA7RHBKQAdCTiseAIgASkEvIA0oAO4ISAEwCESvgG4hAX0LWChUhSoARGAEsAbpAOhIADy6QYgZUtIj0TAQsIKAAsmQA1vRcABauVAAOZNBkALbcMKAcAI4Arq4cBkLsnLxiuZCoiFzQrmKsAhHCIuKS0nIKPAAGahpw2gAkDHV5MlxwAKrp6TAAwnT8loPmVjZAA)\n\nIf we compiled this code despite the error, this sample would then crash:\n\nts\n\n`const b: Base = new Derived();`\n\n`// Crashes because \"name\" will be undefined`\n\n`b.greet();`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEkoGdnwEIoQbwLACh54BzOEAFwAoBKALngDcB7AS2AG4CBfA0JORNFTwAIiBgsGIYPBAAPciAB2wNJmQ4e+APTb4AWkNgAruUP6CYJkuTl4AI3rqEAXnhKQAd1HjJ0mpw6egDCMCgAFiBo9uBQxhrwAERKUAC2IInwniwQEA4IxiogAGYsHsAE9gB0pCAUAUA)\n\n#### [](#type-only-field-declarations)Type-only Field Declarations\n\nWhen `target >= ES2022` or [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) is `true`, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write `declare` to indicate to TypeScript that there should be no runtime effect for this field declaration.\n\nts\n\n`interface Animal {`\n\n  `dateOfBirth: any;`\n\n`}`\n\n`interface Dog extends Animal {`\n\n  `breed: any;`\n\n`}`\n\n`class AnimalHouse {`\n\n  `resident: Animal;`\n\n  `constructor(animal: Animal) {`\n\n    `this.resident = animal;`\n\n  `}`\n\n`}`\n\n`class DogHouse extends AnimalHouse {`\n\n  `// Does not emit JavaScript code,`\n\n  `// only ensures the types are correct`\n\n  `declare resident: Dog;`\n\n  `constructor(dog: Dog) {`\n\n    `super(dog);`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwFgAoZZAEzkgHkYAhYKMACwC5k4QBPAbhIF8SJUJFiIUAEQD2Ac2QQAHpBDkAzmgzY8RUsgBGUCBHLtOvAUOIIccVevRZcACSkBXVSh1lDq4OQjg7A5afLoIUiCqYFCuCGBSUAAUnI44QZq4AJQEJGRkLMCqAHQ+fgFgyAC8HBk4oWSCxI0k1rbq0jIu7iiKymoaqV0eOboA9KPI0hDqIFIVEJjAFQBScABucADKCFDAAA4V4f4ANLnI48gROFzyka4+yCwoYFx70xyGyOFQhnFn-q1PqV-IFJrJ6l8IlEYnEEolyLJ2B1sl48qpXG8kgiZJkIY1+EA)\n\n#### [](#initialization-order)Initialization Order\n\nThe order that JavaScript classes initialize can be surprising in some cases. Let’s consider this code:\n\nts\n\n`class Base {`\n\n  `name = \"base\";`\n\n  `constructor() {`\n\n    `console.log(\"My name is \" + this.name);`\n\n  `}`\n\n`}`\n\n`class Derived extends Base {`\n\n  `name = \"derived\";`\n\n`}`\n\n`// Prints \"base\", not \"derived\"`\n\n`const d = new Derived();`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0B2YC2SAvNAEQBGiJA3BlsAPbYQAuATgK7DP2sAUAlClpZoDJvRAIAdCHoBzXiQCyATxz4kASxgloAamjMAFtqm4C-GpmgBfDHfQZQkGABEErTQDcEAE2gIAB7MCNi+MPAQSGjW5kSkvh7eftT2GBgA9BnQAAqe2Mw6FFEkADQ49MwJST6+JE6MLND+xNgIAO7Q7p61AlRAA)\n\nWhat happened here?\n\nThe order of class initialization, as defined by JavaScript, is:\n\n*   The base class fields are initialized\n*   The base class constructor runs\n*   The derived class fields are initialized\n*   The derived class constructor runs\n\nThis means that the base class constructor saw its own value for `name` during its own constructor, because the derived class field initializations hadn’t run yet.\n\n#### [](#inheriting-built-in-types)Inheriting Built-in Types\n\n> Note: If you don’t plan to inherit from built-in types like `Array`, `Error`, `Map`, etc. or your compilation target is explicitly set to `ES6`/`ES2015` or above, you may skip this section\n\nIn ES2015, constructors which return an object implicitly substitute the value of `this` for any callers of `super(...)`. It is necessary for generated constructor code to capture any potential return value of `super(...)` and replace it with `this`.\n\nAs a result, subclassing `Error`, `Array`, and others may no longer work as expected. This is due to the fact that constructor functions for `Error`, `Array`, and the like use ECMAScript 6’s `new.target` to adjust the prototype chain; however, there is no way to ensure a value for `new.target` when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default.\n\nFor a subclass like the following:\n\nts\n\n`class MsgError extends Error {`\n\n  `constructor(m: string) {`\n\n    `super(m);`\n\n  `}`\n\n  `sayHello() {`\n\n    `return \"hello \" + this.message;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9RgF9tIsAE8AEthAh0vGXIXQU2fBxRFoAIgAWZi2+gBqaPjuYhAAdPzYUGAI2FryenQ6QA)\n\nyou may find that:\n\n*   methods may be `undefined` on objects returned by constructing these subclasses, so calling `sayHello` will result in an error.\n*   `instanceof` will be broken between instances of the subclass and their instances, so `(new MsgError()) instanceof MsgError` will return `false`.\n\nAs a recommendation, you can manually adjust the prototype immediately after any `super(...)` calls.\n\nts\n\n`class MsgError extends Error {`\n\n  `constructor(m: string) {`\n\n    `super(m);`\n\n    `// Set the prototype explicitly.`\n\n    `Object.setPrototypeOf(this, MsgError.prototype);`\n\n  `}`\n\n  `sayHello() {`\n\n    `return \"hello \" + this.message;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9egugB6PdADK2fNHwALbNCUYe+AJ4qcuJSDHAx+EA4B0OhQB5ACMAK2xuXwhTAAU7dEcVQIAzXksxCAAaOEQKTF9bBISnbE0AgF9teQgwBwAJbBAQdF4ZOV0UUw4UImgAIism9H7oAGpzCwzffmwoMARsLXlKunKgA)\n\nHowever, any subclass of `MsgError` will have to manually set the prototype as well. For runtimes that don’t support [`Object.setPrototypeOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf), you may instead be able to use [`__proto__`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto).\n\nUnfortunately, [these workarounds will not work on Internet Explorer 10 and prior](https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx). One can manually copy methods from the prototype onto the instance itself (i.e. `MsgError.prototype` onto `this`), but the prototype chain itself cannot be fixed.\n\n## [](#member-visibility)Member Visibility\n\nYou can use TypeScript to control whether certain methods or properties are visible to code outside the class.\n\n### [](#public)`public`\n\nThe default visibility of class members is `public`. A `public` member can be accessed anywhere:\n\nts\n\n`class Greeter {`\n\n  `public greet() {`\n\n    `console.log(\"hi!\");`\n\n  `}`\n\n`}`\n\n`const g = new Greeter();`\n\n`g.greet();`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8CwAoa0ADgK4BGIAlsNAOZKoAUAlFngQcAPYB2EnIiAHQhONBgCIAFhQCE4pgG420AL541uLrxS1oAXmjdEAdzj008Zktw1BdZCitA)\n\nBecause `public` is already the default visibility modifier, you don’t ever _need_ to write it on a class member, but might choose to do so for style/readability reasons.\n\n### [](#protected)`protected`\n\n`protected` members are only visible to subclasses of the class they’re declared in.\n\nts\n\n`class Greeter {`\n\n  `public greet() {`\n\n    `console.log(\"Hello, \" + this.getName());`\n\n  `}`\n\n  `protected getName() {`\n\n    `return \"hi\";`\n\n  `}`\n\n`}`\n\n`class SpecialGreeter extends Greeter {`\n\n  `public howdy() {`\n\n    `// OK to access protected member here`\n\n    `console.log(\"Howdy, \" + this.getName());`\n\n  `}`\n\n`}`\n\n`const g = new SpecialGreeter();`\n\n`g.greet(); // OK`\n\n`g.getName();`\n\n`Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMFYCwAoAYwBsBDRRUAcWkkgBcZQBvA0UABwFcAjYgS0KgA5rQYAKAJQs27UITgA7RHGKQAdMTjDxAIgASkYloA0oXaADUoegAt+idcIYA5UgFtIUyQG5ZAX1kOeEZCRgATEVcPL2lWfDlQWnouaEVze10-BNBA-DyCEnJKAGUOSEJ+UmIaOkZoUEgAD0ZFcMpahiZ49m4+QVBbOAB3cIBPKRkc9hBQAHkAaRs4UFJCQkgKThCKiNBPdx4mWxhIWXYFZVUNLR0DEfGzC2s7Bydoz29sxNnEv-+AXIAHog0FgsEBAh5S6IegiUAAXlAikgw1AZQqVRqYnqUmywicOLxoFmiwIBOc9Dcn18QA)\n\n#### [](#exposure-of-protected-members)Exposure of `protected` members\n\nDerived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making `protected` members `public`:\n\nts\n\n`class Base {`\n\n  `protected m = 10;`\n\n`}`\n\n`class Derived extends Base {`\n\n  `// No modifier, so default is 'public'`\n\n  `m = 15;`\n\n`}`\n\n`const d = new Derived();`\n\n`console.log(d.m); // OK`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0AOAnA9gC4LDEAm0AttALzQCMADANwYC+GokMAIgrgEsAbggoIAHsQB2ZGPAhI0maAHoV0AHL4q+MgIBmA-gBpoEbWQT6wAVxCFoAmAHJsNgEYgBwZxizU6egBWVnQOdGB8KQgHCjopBAB3aD5BETIACgBKUMjo-BAEADoQfABzDLIiyhzVdQB5AGkgA)\n\nNote that `Derived` was already able to freely read and write `m`, so this doesn’t meaningfully alter the “security” of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the `protected` modifier if this exposure isn’t intentional.\n\n#### [](#cross-hierarchy-protected-access)Cross-hierarchy `protected` access\n\nDifferent OOP languages disagree about whether it’s legal to access a `protected` member through a base class reference:\n\nts\n\n`class Base {`\n\n  `protected x: number = 1;`\n\n`}`\n\n`class Derived1 extends Base {`\n\n  `protected x: number = 5;`\n\n`}`\n\n`class Derived2 extends Base {`\n\n  `f1(other: Derived2) {`\n\n    `other.x = 10;`\n\n  `}`\n\n  `f2(other: Derived1) {`\n\n    `other.x = 10;`\n\n`Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMDYCwAoAYwBsBDRRUAIXMlAG8DRQAHeAF0kM4BNQAPVADsArgFsARjFABeUAEYA3AQC+BEuUoARGAEsAbpB7zQkfpyE9KNRHUb5mbOJ25GBw8VOizQAVmX4akRkFKA60AZGaKbmkJbWtAxMoABm8gAUzgAWMKjhkTxoAJRJDsyg2TAAdPw+8gAMAcxBzClomew50Hl6hsYl9uUVndW1cg1NoEEqQA)\n\nJava, for example, considers this to be legal. On the other hand, C# and C++ chose that this code should be illegal.\n\nTypeScript sides with C# and C++ here, because accessing `x` in `Derived2` should only be legal from `Derived2`’s subclasses, and `Derived1` isn’t one of them. Moreover, if accessing `x` through a `Derived1` reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.\n\nSee also [Why Can’t I Access A Protected Member From A Derived Class?](https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/) which explains more of C#‘s reasoning.\n\n### [](#private)`private`\n\n`private` is like `protected`, but doesn’t allow access to the member even from subclasses:\n\nts\n\n`class Base {`\n\n  `private x = 0;`\n\n`}`\n\n`const b = new Base();`\n\n`// Can't access from outside the class`\n\n`console.log(b.x);`\n\n`Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EicAHaJeoAEYjQCyAHcadABQBKKQRCgAwmQUByFWSJFIlUADN4AW1BwArr0QcAE3peAAt6UgpEOUVEOBJIADoSOABzfVUEgWMgA)\n\nts\n\n`class Derived extends Base {`\n\n  `showX() {`\n\n    `// Can't access in subclasses`\n\n    `console.log(this.x);`\n\n`Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EQoALRKiAV15KFhUhSoARGN0gATUJAH8Adkaq1E9JgRaIAFnADuADQAUASkbMWUHkAYTILAHJeUDIiIkhKUA4LUEQVACNtSniAliI4C0Q4EkgAOhI4AHMvXmcORBKBHylHUFkCaSA)\n\nBecause `private` members aren’t visible to derived classes, a derived class can’t increase their visibility:\n\nts\n\n`class Base {`\n\n  `private x = 0;`\n\n`}`\n\n`class Derived extends Base {`\n\n`Class 'Derived' incorrectly extends base class 'Base'.   Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'.   Property 'x' is private in type 'Base' but not in type 'Derived'.    x = 1;  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBWAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6FSFKgBEY3SABNQkAfwB2aqrUT0mBFkNFYpBaUA)\n\n#### [](#cross-instance-private-access)Cross-instance `private` access\n\nDifferent OOP languages disagree about whether different instances of the same class may access each others’ `private` members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.\n\nTypeScript does allow cross-instance `private` access:\n\nts\n\n`class A {`\n\n  `private x = 10;`\n\n  `public sameAs(other: A) {`\n\n    `// No error`\n\n    `return other.x === this.x;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECC0G8CwAoa0AOAnAlgNzABcBTaAD2gF5oBGABgG5VV0MBXAIxB2GgjAC2xWBAAUAe0IALYlgBccAJSIW6aAHp10AHLjosrOKyr0WYoTZYAdtEkysAOgqUX0aTghOmaaAF9UvkA)\n\n#### [](#caveats)Caveats\n\nLike other aspects of TypeScript’s type system, `private` and `protected` [are only enforced during type checking](https://www.typescriptlang.org/play?removeComments=true&target=99&ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA).\n\nThis means that JavaScript runtime constructs like `in` or simple property lookup can still access a `private` or `protected` member:\n\nts\n\n`class MySafe {`\n\n  `private secretKey = 12345;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBlMAzAptA3gWAFDWgAcAnASwDcwAXDCNYYtKgaTXmgF5oBGAJgGYALAFYA3HgC+QA)\n\njs\n\n`// In a JavaScript file...`\n\n`const s = new MySafe();`\n\n`// Will print 12345`\n\n`console.log(s.secretKey);`\n\n`private` also allows access using bracket notation during type checking. This makes `private`\\-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are _soft private_ and don’t strictly enforce privacy.\n\nts\n\n`class MySafe {`\n\n  `private secretKey = 12345;`\n\n`}`\n\n`const s = new MySafe();`\n\n`// Not allowed during type checking`\n\n`console.log(s.secretKey);`\n\n`Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'.  // OK  console.log(s[\"secretKey\"]);  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMpkBmkoA3oaKAA7QCWANzIAXVokhFokYQGlItUAF5QOTFgCsAbkIBfQoSJwAdomGgqyo5ADuNBs0gAKAJTaChEKABycM2RIkcNaQACagIQCu-EYA5qDCtNysRAAWEgDWfLEGxohwJJAAdIExjoiF4pLScrSu+gSeAPIyOSb5RSVlANoARJVSsvI9ALquQA)\n\nUnlike TypeScripts’s `private`, JavaScript’s [private fields](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) (`#`) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them _hard private_.\n\nts\n\n`class Dog {`\n\n  `#barkAmount = 0;`\n\n  `personality = \"happy\";`\n\n  `constructor() {}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAiD2BzaBvAsAKGtAxAIzACcBrAQQFt4BXAOwBdoBeaABgG5NsAHAU0Ing0wIAJZ0Ank2gAiABZguXcdI4ZO0YIIh1CVYHXiEAFAEpUAX0zmgA)\n\nts\n\n`\"use strict\";`\n\n`class Dog {`\n\n    `#barkAmount = 0;`\n\n    `personality = \"happy\";`\n\n    `constructor() { }`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcB2iAekBYAKBAgwAsB7AdwFEBbAS0KIGMAbaDDUAEUvigA3sVCgAxACM4AawCC9SgFcskUAF5QABgDco0AAdEsDJSzR2zAJ4bQAInLQDBq3b1F9rMxkiwlrSEpYAAoASmEAX2IIoA)\n\nWhen compiling to ES2021 or less, TypeScript will use WeakMaps in place of `#`.\n\nts\n\n`\"use strict\";`\n\n`var _Dog_barkAmount;`\n\n`class Dog {`\n\n    `constructor() {`\n\n        `_Dog_barkAmount.set(this, 0);`\n\n        `this.personality = \"happy\";`\n\n    `}`\n\n`}`\n\n`_Dog_barkAmount = new WeakMap();`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGAjAKwCwAUCBBgBYD2A7gKIC2AlpKQMYA20GGoAItXigA3qVCgAxACM4AawCCjagFcAdpFABeUDgDc40AAdEsDNTXROrAJ7bQAIkrQjRmw4MlD7CxkiwVdkhqWAAKAEpRAF9SKKA)\n\nIf you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.\n\n## [](#static-members)Static Members\n\n> Background Reading:  \n> [Static Members (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static)  \n\nClasses may have `static` members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself:\n\nts\n\n`class MyClass {`\n\n  `static x = 0;`\n\n  `static printX() {`\n\n    `console.log(MyClass.x);`\n\n  `}`\n\n`}`\n\n`console.log(MyClass.x);`\n\n`MyClass.printX();`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0IBcx8BLYaAD2gF5oAGAbm1wKNOgAcAnYgO3wA0AFAEp0TXNGAB7HhCkgApgDoQUgOaCEySBCXlhjHNAC+2U1mmz5y1Rq0pd+w-Z1KuvASPpA)\n\nStatic members can also use the same `public`, `protected`, and `private` visibility modifiers:\n\nts\n\n`class MyClass {`\n\n  `private static x = 0;`\n\n`}`\n\n`console.log(MyClass.x);`\n\n`Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMLmWgDehooADtAJYBuZAC6RQiQUJ5FQAD1ABeUAAYA3IQC+hInAB2iOCUgA6EnADmACjqMKiQ9ICUyoA)\n\nStatic members are also inherited:\n\nts\n\n`class Base {`\n\n  `static getGreeting() {`\n\n    `return \"Hello world\";`\n\n  `}`\n\n`}`\n\n`class Derived extends Base {`\n\n  `myGreeting = Derived.getGreeting();`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0IBcw4EthoBzBHAcQCcFyCA7EgCgEoUMssacBXK+6ACIAEghAgA9tADuEqiAAmggNwdoAXwyb0oSDAAiCKgQBuCBdAQAPHAnoKY8CEjSZoAWwCe1WoUbQAXmhDYzMFADoySho6RlZVdHUgA)\n\n### [](#special-static-names)Special Static Names\n\nIt’s generally not safe/possible to overwrite properties from the `Function` prototype. Because classes are themselves functions that can be invoked with `new`, certain `static` names can’t be used. Function properties like `name`, `length`, and `call` aren’t valid to define as `static` members:\n\nts\n\n`class S {`\n\n  `static name = \"S!\";`\n\n`Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcWCwAoAYwBsBDRRUAZVAG8DRREAXU5gS0NADtSBbSKAC8oAERUAhKIDcBAL5A)\n\n### [](#why-no-static-classes)Why No Static Classes?\n\nTypeScript (and JavaScript) don’t have a construct called `static class` the same way as, for example, C# does.\n\nThose constructs _only_ exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. A class with only a single instance is typically just represented as a normal _object_ in JavaScript/TypeScript.\n\nFor example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:\n\nts\n\n`// Unnecessary \"static\" class`\n\n`class MyStaticClass {`\n\n  `static doSomething() {}`\n\n`}`\n\n`// Preferred (alternative 1)`\n\n`function doSomething() {}`\n\n`// Preferred (alternative 2)`\n\n`const MyHelperObject = {`\n\n  `dosomething() {},`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEFUDtIUwYxgZ0QQwE4E9QCJEBcU8BLObUOAGxWQFgAoS6xUAWQwGUDi4BhK5UAG96oUPkIlQAEwD27GQFsYeABZFIAcwAUASiEBfeobr0QoAApoYAMxhorU0FpQU8dyBIBuMUAEYd9NYArpBwxDKQ0nKKymqaugb0pmCWNnYOTi5uaB7E3qAATAEMEfisGAASMBQADnYA8gBGAFbweKAAvEIiUYgxquraeoL6ADRGANxAA)\n\n## [](#static-blocks-in-classes)`static` Blocks in Classes\n\nStatic blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.\n\nts\n\n`class Foo {`\n\n    `static #count = 0;`\n\n    `get count() {`\n\n        `return Foo.#count;`\n\n    `}`\n\n    `static {`\n\n        `try {`\n\n            `const lastInstances = loadLastInstances();`\n\n            `Foo.#count += lastInstances.length;`\n\n        `}`\n\n        `catch {}`\n\n    `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwhymABkoBnDASVUqnRHIAoBKALnnoE8BtAXQCwAKAD0I+AFopYZBikThkCuXgAxHDngBvYfD3w62MPADEYHGgzwAvPAAMAbmG79AcxBXzl1tpf79cBjIMPjqOAB0ZhaoGE5C-gC+zvH6hljGOin+ehgwXL5Z2f7mtFbQlDR0DCq2hMRkFaX0YIyscUVFYZFeMfAA1LUU1E3V4RAgqK4YABbtHUmFxVAYYNPaC4nCCUA)\n\n## [](#generic-classes)Generic Classes\n\nClasses, much like interfaces, can be generic. When a generic class is instantiated with `new`, its type parameters are inferred the same way as in a function call:\n\nts\n\n`class Box<Type> {`\n\n  `contents: Type;`\n\n  `constructor(value: Type) {`\n\n    `this.contents = value;`\n\n  `}`\n\n`}`\n\n`const b = new Box(\"hello!\");`\n\n     `const b: Box<string>`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQJ4AcCmA+aA3gLABQ00w8AdgC7a0QBc0GOA3KeZVRDQE4BXYDXh8AFADcwIAdmatsASkKdy0GgAsAlhAB03Og2gBeaFJnYOZaAF9SdkqW69oAIxPQq2AO5wkYgCINbBAQeABCAMUrAHoYtWgAPQB+IA)\n\nClasses can use generic constraints and defaults the same way as interfaces.\n\n### [](#type-parameters-in-static-members)Type Parameters in Static Members\n\nThis code isn’t legal, and it may not be obvious why:\n\nts\n\n`class Box<Type> {`\n\n  `static defaultValue: Type;`\n\n`Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMaCwAoAYwBsBDRRUAITgA8AeAFQE8AHSAPlAG8DRREAF1KCAloVAATSADNSAV2KCAaqWLzIqFuwDcBAL5A)\n\nRemember that types are always fully erased! At runtime, there’s only _one_ `Box.defaultValue` property slot. This means that setting `Box<string>.defaultValue` (if that were possible) would _also_ change `Box<number>.defaultValue` - not good. The `static` members of a generic class can never refer to the class’s type parameters.\n\n## [](#this-at-runtime-in-classes)`this` at Runtime in Classes\n\n> Background Reading:  \n> [this keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)  \n\nIt’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.\n\nJavaScript’s handling of `this` is indeed unusual:\n\nts\n\n`class MyClass {`\n\n  `name = \"MyClass\";`\n\n  `getName() {`\n\n    `return this.name;`\n\n  `}`\n\n`}`\n\n`const c = new MyClass();`\n\n`const obj = {`\n\n  `name: \"obj\",`\n\n  `getName: c.getName,`\n\n`};`\n\n`// Prints \"obj\", not \"MyClass\"`\n\n`console.log(obj.getName());`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJHEAUAlOma5oAJw4BXUXmjsAFgEsIAOgIkmOaAF9sOrMAD2eCO2jBy+YgHc4SFBAEbDx0wYBGAKwuZNa4gC4qdw9KABphNi4eQOBlSO4ScKwtDWwAejToAAVRBTx2GEpgsPwDU2o7OkpsZwgDEGJlEAMWXmC4jgS+fn4GIA)\n\nLong story short, by default, the value of `this` inside a function depends on _how the function was called_. In this example, because the function was called through the `obj` reference, its value of `this` was `obj` rather than the class instance.\n\nThis is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.\n\n### [](#arrow-functions)Arrow Functions\n\n> Background Reading:  \n> [Arrow functions (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)  \n\nIf you have a function that will often be called in a way that loses its `this` context, it can make sense to use an arrow function property instead of a method definition:\n\nts\n\n`class MyClass {`\n\n  `name = \"MyClass\";`\n\n  `getName = () => {`\n\n    `return this.name;`\n\n  `};`\n\n`}`\n\n`const c = new MyClass();`\n\n`const g = c.getName;`\n\n`// Prints \"MyClass\" instead of crashing`\n\n`console.log(g());`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJGkUAUASnIA+dM1zQAThwCukvNHYALAJYQAdARJMc0AL4692YAHs8EdtGDl8xAO5wkKCIJ2nzlljeDq2XHjoA9IHQAAqSKnjsMNROdJTQkRbEYAAm0CYAZlaSkKp4LMZmECYgxOogJix81QICDEA)\n\nThis has some trade-offs:\n\n*   The `this` value is guaranteed to be correct at runtime, even for code not checked with TypeScript\n*   This will use more memory, because each class instance will have its own copy of each function defined this way\n*   You can’t use `super.getName` in a derived class, because there’s no entry in the prototype chain to fetch the base class method from\n\n### [](#this-parameters)`this` parameters\n\nIn a method or function definition, an initial parameter named `this` has special meaning in TypeScript. These parameters are erased during compilation:\n\nts\n\n`// TypeScript input with 'this' parameter`\n\n`function fn(this: SomeType, x: number) {`\n\n  `/* ... */`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgFgAoAelKgFpqBjAV2GspPKlUhhoCcBLMYKDxxgGUAO49gACygByaTwDOsqGCxcsSYBC4kAZnRw1gPODih6cACgWKAXLEQo0AGigAPBzjoIARjoBKKABvEigoUgAqKAA6OKhI0hIAXyA)\n\njs\n\n`// JavaScript output`\n\n`function fn(x) {`\n\n  `/* ... */`\n\n`}`\n\nTypeScript checks that calling a function with a `this` parameter is done so with a correct context. Instead of using an arrow function, we can add a `this` parameter to method definitions to statically enforce that the method is called correctly:\n\nts\n\n`class MyClass {`\n\n  `name = \"MyClass\";`\n\n  `getName(this: MyClass) {`\n\n    `return this.name;`\n\n  `}`\n\n`}`\n\n`const c = new MyClass();`\n\n`// OK`\n\n`c.getName();`\n\n`// Error, would crash`\n\n`const g = c.getName;`\n\n`console.log(g());`\n\n`The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYAcAWAsAFADGANgIaKKgCyAngMLmWgDehooAdmQLaSgBeUACI6jComEBudqADmkAC4A5XpAAUigBYBLFDQZNEASlayO0JQFdonUNr0A6bnxkEOAX0JficTokVQIkEuSAB3A3FKdWM3EFAAeQBpQiJHBRU1GLdCeIBRWAQAGlAwuCsSABMg6AotVL8A+RC0jNVXBv84EkhHEjg5dUHjWKA)\n\nThis method makes the opposite trade-offs of the arrow function approach:\n\n*   JavaScript callers might still use the class method incorrectly without realizing it\n*   Only one function per class definition gets allocated, rather than one per class instance\n*   Base method definitions can still be called via `super`.\n\n## [](#this-types)`this` Types\n\nIn classes, a special type called `this` refers _dynamically_ to the type of the current class. Let’s see how this is useful:\n\nts\n\n`class Box {`\n\n  `contents: string = \"\";`\n\n  `set(value: string) {`\n\n  `(method) Box.set(value: string): this`\n\n    `this.contents = value;`\n\n    `return this;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVJgD0i7AD0A-D2zQCAC1oQAdLkIkCMViPFFuWbdX5jqeHfoi3sAX0yegA)\n\nHere, TypeScript inferred the return type of `set` to be `this`, rather than `Box`. Now let’s make a subclass of `Box`:\n\nts\n\n`class ClearableBox extends Box {`\n\n  `clear() {`\n\n    `this.contents = \"\";`\n\n  `}`\n\n`}`\n\n`const a = new ClearableBox();`\n\n`const b = a.set(\"hello\");`\n\n     `const b: ClearableBox`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVD2zQCAC1oQAdLkIkCMViPFFuWJdX5jqeZWognsAX0xOMAelfQAtN+BiC3z0xQSBgAYRAiMGowACMIhGQiRGI8ABMYBIVTUEjqAXl0U2xVdS18FL0Wdi5FFxcg-CpoMCq8IgB3aHDc2PikfJNtJpiqsA0+QTYVIhAQeDZZE3claAA9AH4gA)\n\nYou can also use `this` in a parameter type annotation:\n\nts\n\n`class Box {`\n\n  `content: string = \"\";`\n\n  `sameAs(other: this) {`\n\n    `return other.content === this.content;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEBc0EBATgJZ4Dm0AvNAESsDcm2EYAtkQCCEABTwCACyJVykmhACUqbtmhUiBAK5U80cVKoA6XIRIFmTFnIjH8xQlyzQAvpmdA)\n\nThis is different from writing `other: Box` — if you have a derived class, its `sameAs` method will now only accept other instances of that same derived class:\n\nts\n\n`class Box {`\n\n  `content: string = \"\";`\n\n  `sameAs(other: this) {`\n\n    `return other.content === this.content;`\n\n  `}`\n\n`}`\n\n`class DerivedBox extends Box {`\n\n  `otherContent: string = \"?\";`\n\n`}`\n\n`const base = new Box();`\n\n`const derived = new DerivedBox();`\n\n`derived.sameAs(base);`\n\n`Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.   Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.   Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFADGANgIaKKgBCcAHqAN6GihFwB2ALpN6ol2gBLDgHNQAXlAAiaQG4WoRGQC2kAIKIAFHC4ALGKn1DEASiaLW0SFwCu0DqF0HoAOnbdeXSRKnHE7pw83AoErAC+hJEEhKQUVAAiMEIAbpAAJrQMkHTB6VRZFmFO+jAAwkFe-IIi4lLSAPzyUYSxnAKgAEYUkJKgHJAA7jT0WqahHh3pyWnpfQPDScKzWWOh08sZrspqmlrdiJDjQA)\n\n### [](#this-based-type-guards)`this`\\-based type guards\n\nYou can use `this is Type` in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. `if` statements) the type of the target object would be narrowed to the specified `Type`.\n\nts\n\n`class FileSystemObject {`\n\n  `isFile(): this is FileRep {`\n\n    `return this instanceof FileRep;`\n\n  `}`\n\n  `isDirectory(): this is Directory {`\n\n    `return this instanceof Directory;`\n\n  `}`\n\n  `isNetworked(): this is Networked & this {`\n\n    `return this.networked;`\n\n  `}`\n\n  `constructor(public path: string, private networked: boolean) {}`\n\n`}`\n\n`class FileRep extends FileSystemObject {`\n\n  `constructor(path: string, public content: string) {`\n\n    `super(path, false);`\n\n  `}`\n\n`}`\n\n`class Directory extends FileSystemObject {`\n\n  `children: FileSystemObject[];`\n\n`}`\n\n`interface Networked {`\n\n  `host: string;`\n\n`}`\n\n`const fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\");`\n\n`if (fso.isFile()) {`\n\n  `fso.content;`\n\n  `const fso: FileRep`\n\n`} else if (fso.isDirectory()) {`\n\n  `fso.children;`\n\n  `const fso: Directory`\n\n`} else if (fso.isNetworked()) {`\n\n  `fso.host;`\n\n  `const fso: Networked & FileSystemObject`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQAMXhVsAZXwxsAWwDyAIwBW2ZKADefUKHiRxkgBQBKVtAAWB-SKPYAStkzbde0LGzQArrGKgrG3hiGApiRGx0NjEJR2cAbjcAXzcDABF4T2R0WHwzC2sRGwys6Bz8V153Dy9ff0CikOgwiKjQEo0y3MSq0BTegwA5LwB3HIBrbAATfIDC21Bh6DHYSanQADI5mx1evU8fP23IADpiUYnpnr1+vUQmGFhvbNhjTG9lGkRQTAZLVkewQA5gAaH4IABuDGwoHOy0uU1YynQ6EkYVM2n6-T4AiEdliThc2AAHtBsMQpvjJDI5Eo1J1KncHnBnl03n8AXBgWD3p8kKB7sQyULOQhiECMbtqpBvDhXr8rGCOFQuKZrn0+Nj+IJhO1Mp1yqAScLKTFqbIyXT1JopQLrFQpp4WGbpBaFCprdAANoAXR6WuCZNgHAiiwuq2mjNAlnQMFFwP9fBxzPYkHQrHsNMtHoZAF5YdgRi7CcYAERsFHAZQUWAnaCk0tg8so0tqpO8eDRYxsNMnAz2MyStw99AnQXC6A9ECgAB6AH5NUaVTDO6Bu730vqXnlTEPeiOx-bHeSp2B54vsMv9F2D0Nw2tB1GDzGYKfZwveEkgA)\n\nA common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an `undefined` from the value held inside box when `hasValue` has been verified to be true:\n\nts\n\n`class Box<T> {`\n\n  `value?: T;`\n\n  `hasValue(): this is { value: T } {`\n\n    `return this.value !== undefined;`\n\n  `}`\n\n`}`\n\n`const box = new Box<string>();`\n\n`box.value = \"Gameboy\";`\n\n`box.value;`\n\n     `(property) Box<string>.value?: string`\n\n`if (box.hasValue()) {`\n\n  `box.value;`\n\n       `(property) value: string`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQHzQN4FgBQ00AbmCAK4CmA-AFzSoDc++hAFpAGqmUAUAlHQAurAJYwx2Ytwp1U0AL7YWhaACcKgsqoB20YWIB0JchWgBCALwXoZbQBMKAMxHaKdpgQX55zPMHjaEILQAEZI0NauAO5wSMhBqi4A5uj8HmGIRtIR0ABEAOJgALYUYQCeuR74GVkmHgD09YQAelS+Io7QPDXsEFwm-HxKnjXGlB6EjS1tePJAA)\n\n## [](#parameter-properties)Parameter Properties\n\nTypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called _parameter properties_ and are created by prefixing a constructor argument with one of the visibility modifiers `public`, `private`, `protected`, or `readonly`. The resulting field gets those modifier(s):\n\nts\n\n`class Params {`\n\n  `constructor(`\n\n    `public readonly x: number,`\n\n    `protected y: number,`\n\n    `private z: number`\n\n  `) {`\n\n    `// No body necessary`\n\n  `}`\n\n`}`\n\n`const a = new Params(1, 2, 3);`\n\n`console.log(a.x);`\n\n             `(property) Params.x: number`\n\n`console.log(a.z);`\n\n`Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgAKZ0ZAtlQN6GihFwB2iALtAFcivBAAo27UAAcBAIxIBLIqGiQyAE24kAnqAAeqLgIayYAGgnsp8XpGGR1obYeOnoFgpOnQFANzK2oABeLiYwEgCUoKyekiCgAHJwoLJw6rpcdpCUdNoSAL6EhcTcfKBkoAC8oJkA7jR0jIiiOGbobRgRANyEnDxwJJAAdCRwAOaiZEN63YTxXgvsAHoA-L2lA8OjE1NB3UA)\n\n## [](#class-expressions)Class Expressions\n\n> Background Reading:  \n> [Class expressions (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class)  \n\nClass expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:\n\nts\n\n`const someClass = class<Type> {`\n\n  `content: Type;`\n\n  `constructor(value: Type) {`\n\n    `this.content = value;`\n\n  `}`\n\n`};`\n\n`const m = new someClass(\"Hello, world\");`\n\n     `const m: someClass<string>`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBBIFsCmBhANgQwhGBeGwm2APACoCeADkgHwwDeAsAFAwHhRJhQBcMF1ANws2oSFABOAV2BQQEgBQA3DGilI+ApAEoGItjCgALAJYQAdGM7c8MFWqTDWMAL4sXTlmOgwEtsEgA7nCIqEQQCgBEABJIaGggADQwgfJoACaR2k4A9DkGMAB6APxAA)\n\n## [](#constructor-signatures)Constructor Signatures\n\nJavaScript classes are instantiated with the `new` operator. Given the type of a class itself, the [InstanceType](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype) utility type models this operation.\n\nts\n\n`class Point {`\n\n  `createdAt: number;`\n\n  `x: number;`\n\n  `y: number`\n\n  `constructor(x: number, y: number) {`\n\n    `this.createdAt = Date.now()`\n\n    `this.x = x;`\n\n    `this.y = y;`\n\n  `}`\n\n`}`\n\n`type PointInstance = InstanceType<typeof Point>`\n\n`function moveRight(point: PointInstance) {`\n\n  `point.x += 5;`\n\n`}`\n\n`const point = new Point(3, 4);`\n\n`moveRight(point);`\n\n`point.x; // => 8`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrWACcBTMVYgEwEFUAuaZAVwFsAjYwgbl3wA96mbDtzzQAngJbtCPAvGQRUhRsFTxCACn4MpHADTjJQwgEpMs-KgAWiCADoipctXQBeaABEyxO8ngB3DRMLaGtbO15od14RfEsbezEo8VjoAF9cDJxUMQAHYjgkNABJBVQwZGAC91LFCqqAFTziAB4c-PgAM0KUVAA+XFxOxkrURHloZngAN2IAJUQAcytUDVyiuh6SsvriM2xRdd6I6ABqdwBWESzcYHlFaCO0ZORify3VgGYDABYTESmswWy1WT1Q-1wYIinGgAHpYVE+tAABxAA)\n\n## [](#abstract-classes-and-members)`abstract` Classes and Members\n\nClasses, methods, and fields in TypeScript may be _abstract_.\n\nAn _abstract method_ or _abstract field_ is one that hasn’t had an implementation provided. These members must exist inside an _abstract class_, which cannot be directly instantiated.\n\nThe role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be _concrete_.\n\nLet’s look at an example:\n\nts\n\n`abstract class Base {`\n\n  `abstract getName(): string;`\n\n  `printName() {`\n\n    `console.log(\"Hello, \" + this.getName());`\n\n  `}`\n\n`}`\n\n`const b = new Base();`\n\n`Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3AV6gADtHWSZ8hd118qcNYjj1IAOnpwRcgEQAJSPWcAaUG6gANSgZAAWKogOYsayigra+HwAvgSp+ARWNrTEoAC8oGqQAO5sHIqaQA)\n\nWe can’t instantiate `Base` with `new` because it’s abstract. Instead, we need to make a derived class and implement the abstract members:\n\nts\n\n`class Derived extends Base {`\n\n  `getName() {`\n\n    `return \"world\";`\n\n  `}`\n\n`}`\n\n`const d = new Derived();`\n\n`d.printName();`\n\n[Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgQmgpgg3gLABQCCokM8CA5jhAHLAC2OAFAJQBcClAlgDsaAbhJkADlEGMW7DgQC+JJcQD0qhAFptsAK4RtmkijQYAIjikA3HABMEOAB4QcA2xmxg8RUrXpNWTgIxMgQoel0oAQQAIgB3AHsoZFsY0V8VFWMEgUgEewBeBAEcOIQLaztOdNsAOklpALlhIA)\n\nNotice that if we forget to implement the base class’s abstract members, we’ll get an error:\n\nts\n\n`class Derived extends Base {`\n\n`Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.    // forgot to do anything  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMGCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-CFABae1QCuZe7YIMmLACIwVAN0gAE1BIAA8ySDVAlnZETh58PhsAMwQROFoyOFBA7MI1AE8yAAt1EUsgA)\n\n### [](#abstract-construct-signatures)Abstract Construct Signatures\n\nSometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.\n\nFor example, you might want to write this code:\n\nts\n\n`function greet(ctor: typeof Base) {`\n\n  `const instance = new ctor();`\n\n`Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.    instance.printName();  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-AyYsAIjBUA3SABNQkAB5lIa1y3ZETh58PjEjWUVuHT5ocQBXaDVQACIU7VDQKysQUABaAqp4sgK8ggAzeLUaFThkkTjxORoEVDIAT11IOHK2DlMQvio68lB1ckJqzgBeUDVIAHc6MgRFDL5xskmqSAA6fUMpSIUMsyA)\n\nTypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of `greet`, it’s perfectly legal to write this code, which would end up constructing an abstract class:\n\nts\n\n`// Bad!`\n\n`greet(Base);`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3gcziDAXPFCgJ4A08AQlGiESaQNwCwAUAPQfwC0fYAVwx8e7LtSjAAhO1wh8AChp0AlEyA)\n\nInstead, you want to write a function that accepts something with a construct signature:\n\nts\n\n`function greet(ctor: new () => Base) {`\n\n  `const instance = new ctor();`\n\n  `instance.printName();`\n\n`}`\n\n`greet(Derived);`\n\n`greet(Base);`\n\n`Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.   Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.   Cannot assign an abstract constructor type to a non-abstract constructor type.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACGARogC7REDG5o1ANkYoqAELOSgDehoopClVqgA5pHIA5IgFtIACgCUqIQEsAdqIDcfUAAdoGqbIWKeAX0KWCjZqwAiMVQDdIAE1CQAHuUjq3rByIXLwE-OLGcko8uvzQEgCu0OqgAESpOmGg1tYgoAC0hdQJ5IX5hABmCeq0qnApovES8rQIqOqQAO6g0QC8AHzsnGah-NT1FKAaFEQ1XL2gHd2t0EqZ-NPks9SQAHQGRtJRipnWjZDNjoaubieE581BkCdAA)\n\nNow TypeScript correctly tells you about which class constructor functions can be invoked - `Derived` can because it’s concrete, but `Base` cannot.\n\n## [](#relationships-between-classes)Relationships Between Classes\n\nIn most cases, classes in TypeScript are compared structurally, the same as other types.\n\nFor example, these two classes can be used in place of each other because they’re identical:\n\nts\n\n`class Point1 {`\n\n  `x = 0;`\n\n  `y = 0;`\n\n`}`\n\n`class Point2 {`\n\n  `x = 0;`\n\n  `y = 0;`\n\n`}`\n\n`// OK`\n\n`const p: Point1 = new Point2();`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgFwIzQN4FgBQ00AHtALzQAMA3PoQJ5mU14C+++okMCKqATNlrFG1IQ3KjW7PAHoZ0APIBpDvGQRU0AA4AuOEjSZyyAKYB3fbz4AKAJRUgA)\n\nSimilarly, subtype relationships between classes exist even if there’s no explicit inheritance:\n\nts\n\n`class Person {`\n\n  `name: string;`\n\n  `age: number;`\n\n`}`\n\n`class Employee {`\n\n  `name: string;`\n\n  `age: number;`\n\n  `salary: number;`\n\n`}`\n\n`// OK`\n\n`const p: Person = new Employee();`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgLABQi2mkkoACnrJAPYB2oA3saKI5gLZ5owJGAcwDc7UJiF9OAV24AjWmKIBfYsVLlKAUW4AHbPQCeePK3Fde-OPGHKOk6YzmLY90JByZYRtM4VKxGpExCCgAPIA0hpMMKB6aDR0TKAAvJx4AO6gugbGpgAUAJQiQA)\n\nThis sounds straightforward, but there are a few cases that seem stranger than others.\n\nEmpty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:\n\nts\n\n`class Empty {}`\n\n`function fn(x: Empty) {`\n\n  `// can't do anything with 'x', so I won't`\n\n`}`\n\n`// All OK!`\n\n`fn(window);`\n\n`fn({});`\n\n`fn(fn);`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4FgBQ+AZgK4B2wyAlgPanSGkAUAHgFxxJoCUm+00AegHRgYUgHJk0ACbVoY1MgAWlUgHNoAd0rLo45uIA00CHICSW2pPy4CeIdACCIENADyAaQCERJttKymlwA3L6M2CFhDCFAA)",
    "title": "TypeScript: Documentation - Classes",
    "description": "How classes work in TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-merging.html",
    "markdown": "# TypeScript: Documentation - Declaration Merging\n\n## [](#introduction)Introduction\n\nSome of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of ‘declaration merging’. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.\n\nFor the purposes of this article, “declaration merging” means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it’s not limited to just two declarations.\n\n## [](#basic-concepts)Basic Concepts\n\nIn TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.\n\n| Declaration Type | Namespace | Type | Value |\n| --- | --- | --- | --- |\n| Namespace | X   |     | X   |\n| Class |     | X   | X   |\n| Enum |     | X   | X   |\n| Interface |     | X   |     |\n| Type Alias |     | X   |     |\n| Function |     |     | X   |\n| Variable |     |     | X   |\n\nUnderstanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.\n\n## [](#merging-interfaces)Merging Interfaces\n\nThe simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.\n\nts\n\n`interface Box {`\n\n  `height: number;`\n\n  `width: number;`\n\n`}`\n\n`interface Box {`\n\n  `scale: number;`\n\n`}`\n\n`let box: Box = { height: 5, width: 6, scale: 10 };`\n\nNon-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.\n\nFor function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface `A` merging with later interface `A`, the second interface will have a higher precedence than the first.\n\nThat is, in the example:\n\nts\n\n`interface Cloner {`\n\n  `clone(animal: Animal): Animal;`\n\n`}`\n\n`interface Cloner {`\n\n  `clone(animal: Sheep): Sheep;`\n\n`}`\n\n`interface Cloner {`\n\n  `clone(animal: Dog): Dog;`\n\n  `clone(animal: Cat): Cat;`\n\n`}`\n\nThe three interfaces will merge to create a single declaration as so:\n\nts\n\n`interface Cloner {`\n\n  `clone(animal: Dog): Dog;`\n\n  `clone(animal: Cat): Cat;`\n\n  `clone(animal: Sheep): Sheep;`\n\n  `clone(animal: Animal): Animal;`\n\n`}`\n\nNotice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.\n\nOne exception to this rule is specialized signatures. If a signature has a parameter whose type is a _single_ string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.\n\nFor instance, the following interfaces will merge together:\n\nts\n\n`interface Document {`\n\n  `createElement(tagName: any): Element;`\n\n`}`\n\n`interface Document {`\n\n  `createElement(tagName: \"div\"): HTMLDivElement;`\n\n  `createElement(tagName: \"span\"): HTMLSpanElement;`\n\n`}`\n\n`interface Document {`\n\n  `createElement(tagName: string): HTMLElement;`\n\n  `createElement(tagName: \"canvas\"): HTMLCanvasElement;`\n\n`}`\n\nThe resulting merged declaration of `Document` will be the following:\n\nts\n\n`interface Document {`\n\n  `createElement(tagName: \"canvas\"): HTMLCanvasElement;`\n\n  `createElement(tagName: \"div\"): HTMLDivElement;`\n\n  `createElement(tagName: \"span\"): HTMLSpanElement;`\n\n  `createElement(tagName: string): HTMLElement;`\n\n  `createElement(tagName: any): Element;`\n\n`}`\n\n## [](#merging-namespaces)Merging Namespaces\n\nSimilarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.\n\nTo merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.\n\nTo merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.\n\nThe declaration merge of `Animals` in this example:\n\nts\n\n`namespace Animals {`\n\n  `export class Zebra {}`\n\n`}`\n\n`namespace Animals {`\n\n  `export interface Legged {`\n\n    `numberOfLegs: number;`\n\n  `}`\n\n  `export class Dog {}`\n\n`}`\n\nis equivalent to:\n\nts\n\n`namespace Animals {`\n\n  `export interface Legged {`\n\n    `numberOfLegs: number;`\n\n  `}`\n\n  `export class Zebra {}`\n\n  `export class Dog {}`\n\n`}`\n\nThis model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.\n\nWe can see this more clearly in this example:\n\nts\n\n`namespace Animal {`\n\n  `let haveMuscles = true;`\n\n  `export function animalsHaveMuscles() {`\n\n    `return haveMuscles;`\n\n  `}`\n\n`}`\n\n`namespace Animal {`\n\n  `export function doAnimalsHaveMuscles() {`\n\n    `return haveMuscles; // Error, because haveMuscles is not accessible here`\n\n  `}`\n\n`}`\n\nBecause `haveMuscles` is not exported, only the `animalsHaveMuscles` function that shares the same un-merged namespace can see the symbol. The `doAnimalsHaveMuscles` function, even though it’s part of the merged `Animal` namespace can not see this un-exported member.\n\n## [](#merging-namespaces-with-classes-functions-and-enums)Merging Namespaces with Classes, Functions, and Enums\n\nNamespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.\n\n### [](#merging-namespaces-with-classes)Merging Namespaces with Classes\n\nThis gives the user a way of describing inner classes.\n\nts\n\n`class Album {`\n\n  `label: Album.AlbumLabel;`\n\n`}`\n\n`namespace Album {`\n\n  `export class AlbumLabel {}`\n\n`}`\n\nThe visibility rules for merged members is the same as described in the [Merging Namespaces](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces) section, so we must export the `AlbumLabel` class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.\n\nIn addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.\n\nts\n\n`function buildLabel(name: string): string {`\n\n  `return buildLabel.prefix + name + buildLabel.suffix;`\n\n`}`\n\n`namespace buildLabel {`\n\n  `export let suffix = \"\";`\n\n  `export let prefix = \"Hello, \";`\n\n`}`\n\n`console.log(buildLabel(\"Sam Smith\"));`\n\nSimilarly, namespaces can be used to extend enums with static members:\n\nts\n\n`enum Color {`\n\n  `red = 1,`\n\n  `green = 2,`\n\n  `blue = 4,`\n\n`}`\n\n`namespace Color {`\n\n  `export function mixColor(colorName: string) {`\n\n    `if (colorName == \"yellow\") {`\n\n      `return Color.red + Color.green;`\n\n    `} else if (colorName == \"white\") {`\n\n      `return Color.red + Color.green + Color.blue;`\n\n    `} else if (colorName == \"magenta\") {`\n\n      `return Color.red + Color.blue;`\n\n    `} else if (colorName == \"cyan\") {`\n\n      `return Color.green + Color.blue;`\n\n    `}`\n\n  `}`\n\n`}`\n\n## [](#disallowed-merges)Disallowed Merges\n\nNot all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the [Mixins in TypeScript](https://www.typescriptlang.org/docs/handbook/mixins.html) section.\n\n## [](#module-augmentation)Module Augmentation\n\nAlthough JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let’s look at a toy Observable example:\n\nts\n\n`// observable.ts`\n\n`export class Observable<T> {`\n\n  `// ... implementation left as an exercise for the reader ...`\n\n`}`\n\n`// map.ts`\n\n`import { Observable } from \"./observable\";`\n\n`Observable.prototype.map = function (f) {`\n\n  `// ... another exercise for the reader`\n\n`};`\n\nThis works fine in TypeScript too, but the compiler doesn’t know about `Observable.prototype.map`. You can use module augmentation to tell the compiler about it:\n\nts\n\n`// observable.ts`\n\n`export class Observable<T> {`\n\n  `// ... implementation left as an exercise for the reader ...`\n\n`}`\n\n`// map.ts`\n\n`import { Observable } from \"./observable\";`\n\n`declare module \"./observable\" {`\n\n  `interface Observable<T> {`\n\n    `map<U>(f: (x: T) => U): Observable<U>;`\n\n  `}`\n\n`}`\n\n`Observable.prototype.map = function (f) {`\n\n  `// ... another exercise for the reader`\n\n`};`\n\n`// consumer.ts`\n\n`import { Observable } from \"./observable\";`\n\n`import \"./map\";`\n\n`let o: Observable<number>;`\n\n`o.map((x) => x.toFixed());`\n\nThe module name is resolved the same way as module specifiers in `import`/`export`. See [Modules](https://www.typescriptlang.org/docs/handbook/modules.html) for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.\n\nHowever, there are two limitations to keep in mind:\n\n1.  You can’t declare new top-level declarations in the augmentation — just patches to existing declarations.\n2.  Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and `default` is a reserved word - see [#14080](https://github.com/Microsoft/TypeScript/issues/14080) for details)\n\n### [](#global-augmentation)Global augmentation\n\nYou can also add declarations to the global scope from inside a module:\n\nts\n\n`// observable.ts`\n\n`export class Observable<T> {`\n\n  `// ... still no implementation ...`\n\n`}`\n\n`declare global {`\n\n  `interface Array<T> {`\n\n    `toObservable(): Observable<T>;`\n\n  `}`\n\n`}`\n\n`Array.prototype.toObservable = function () {`\n\n  `// ...`\n\n`};`\n\nGlobal augmentations have the same behavior and limits as module augmentations.",
    "title": "TypeScript: Documentation - Declaration Merging",
    "description": "How merging namespaces and interfaces works",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/decorators.html",
    "markdown": "# TypeScript: Documentation - Decorators\n\n> NOTE  This document refers to an experimental stage 2 decorators implementation. Stage 3 decorator support is available since Typescript 5.0. See: [Decorators in Typescript 5.0](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators)\n\n## [](#introduction)Introduction\n\nWith the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members.\n\n> Further Reading (stage 2): [A Complete Guide to TypeScript Decorators](https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/)\n\nTo enable experimental support for decorators, you must enable the [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators) compiler option either on the command line or in your `tsconfig.json`:\n\n**Command Line**:\n\nshell\n\n`tsc --target ES5 --experimentalDecorators`\n\n**tsconfig.json**:\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"ES5\",`\n\n    `\"\": true`\n\n  `}`\n\n`}`\n\n## [](#decorators)Decorators\n\nA _Decorator_ is a special kind of declaration that can be attached to a [class declaration](#class-decorators), [method](#method-decorators), [accessor](#accessor-decorators), [property](#property-decorators), or [parameter](#parameter-decorators). Decorators use the form `@expression`, where `expression` must evaluate to a function that will be called at runtime with information about the decorated declaration.\n\nFor example, given the decorator `@sealed` we might write the `sealed` function as follows:\n\nts\n\n`function sealed(target) {`\n\n  `// do something with 'target' ...`\n\n`}`\n\n## [](#decorator-factories)Decorator Factories\n\nIf we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A _Decorator Factory_ is simply a function that returns the expression that will be called by the decorator at runtime.\n\nWe can write a decorator factory in the following fashion:\n\nts\n\n`function color(value: string) {`\n\n  `// this is the decorator factory, it sets up`\n\n  `// the returned decorator function`\n\n  `return function (target) {`\n\n    `// this is the decorator`\n\n    `// do something with 'target' and 'value'...`\n\n  `};`\n\n`}`\n\n## [](#decorator-composition)Decorator Composition\n\nMultiple decorators can be applied to a declaration, for example on a single line:\n\nts\n\nOn multiple lines:\n\nts\n\nWhen multiple decorators apply to a single declaration, their evaluation is similar to [function composition in mathematics](https://wikipedia.org/wiki/Function_composition). In this model, when composing functions _f_ and _g_, the resulting composite (_f_ ∘ _g_)(_x_) is equivalent to _f_(_g_(_x_)).\n\nAs such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:\n\n1.  The expressions for each decorator are evaluated top-to-bottom.\n2.  The results are then called as functions from bottom-to-top.\n\nIf we were to use [decorator factories](#decorator-factories), we can observe this evaluation order with the following example:\n\nts\n\n`function first() {`\n\n  `console.log(\"first(): factory evaluated\");`\n\n  `return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {`\n\n    `console.log(\"first(): called\");`\n\n  `};`\n\n`}`\n\n`function second() {`\n\n  `console.log(\"second(): factory evaluated\");`\n\n  `return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {`\n\n    `console.log(\"second(): called\");`\n\n  `};`\n\n`}`\n\n`class ExampleClass {`\n\n  `@first()`\n\n  `@second()`\n\n  `method() {}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqh1IJWYAUASlABvGqFCl0VErkgA6XCQDmfAERce-AQC5O2FmQCeoSADc8DCpAAmqgQG4xoBJEwMEHRs1btQfHAhKrrrY6IYANKCwCCTwCJiGANKQhrq8yOhKkdaQVETIsJQIugAKMXEJhHkFRUKi4uKS0rIKymoavIK6RHiytg5OAL6OgzT0TCxsHFTE7NaCIk5NMvKKKqozkvM6egYIxmYWVv2O4i5uHpwTPhz+2IHBoKERUeWICcmpoOlImdm5+SQhTIpTe8UMVUBwIQdScjXYzVWbQ2s3Q226vRsdlOoGGNFGNCIuGwVCooAAotBsChYLIAMLE0mLcTgDpaJzgTZzQRONCYAAWJG2IlGgyAA)\n\nWhich would print this output to the console:\n\nshell\n\n`first(): factory evaluated`\n\n`second(): factory evaluated`\n\n`second(): called`\n\n`first(): called`\n\n## [](#decorator-evaluation)Decorator Evaluation\n\nThere is a well defined order to how decorators applied to various declarations inside of a class are applied:\n\n1.  _Parameter Decorators_, followed by _Method_, _Accessor_, or _Property Decorators_ are applied for each instance member.\n2.  _Parameter Decorators_, followed by _Method_, _Accessor_, or _Property Decorators_ are applied for each static member.\n3.  _Parameter Decorators_ are applied for the constructor.\n4.  _Class Decorators_ are applied for the class.\n\n## [](#class-decorators)Class Decorators\n\nA _Class Decorator_ is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a `declare` class).\n\nThe expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.\n\nIf the class decorator returns a value, it will replace the class declaration with the provided constructor function.\n\n> NOTE  Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will **not** do this for you.\n\nThe following is an example of a class decorator (`@sealed`) applied to a `BugReport` class:\n\nts\n\n`@sealed`\n\n`class BugReport {`\n\n  `type = \"report\";`\n\n  `title: string;`\n\n  `constructor(t: string) {`\n\n    `this.title = t;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqhWR6QAmAFKXRVMCBizIAuUADEmLNugCUoAN41QoAPIAjAFbFMAOi55B7EWIkIlAbg3b9hk91znho8ZQRHYCEpSYAJ7wdjQAvjQgoAC0cUQMmHExNOCmuHw0RLjYVFSgAEIMAOYASpCwZJhqDsHwoAC8oABECBVVzfaarJgZ0pZI6MX2DkKWXmT8mP2ig8Uq6prdABZIVEY9GY2gmF2gkeFAA)\n\nWe can define the `@sealed` decorator using the following function declaration:\n\nts\n\n`function sealed(constructor: Function) {`\n\n  `Object.seal(constructor);`\n\n  `Object.seal(constructor.prototype);`\n\n`}`\n\nWhen `@sealed` is executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessing `BugReport.prototype` or by defining properties on `BugReport` itself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator does **not** prevent classes from sub-classing `BugReport`.\n\nNext we have an example of how to override the constructor to set new defaults.\n\nts\n\n`function reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {`\n\n  `return class extends constructor {`\n\n    `reportingURL = \"http://www...\";`\n\n  `};`\n\n`}`\n\n`@reportableClassDecorator`\n\n`class BugReport {`\n\n  `type = \"report\";`\n\n  `title: string;`\n\n  `constructor(t: string) {`\n\n    `this.title = t;`\n\n  `}`\n\n`}`\n\n`const bug = new BugReport(\"Needs dark mode\");`\n\n`console.log(bug.title); // Prints \"Needs dark mode\"`\n\n`console.log(bug.type); // Prints \"report\"`\n\n`// Note that the decorator _does not_ change the TypeScript type`\n\n``// and so the new property `reportingURL` is not known``\n\n`// to the type system:`\n\n`bug.reportingURL;`\n\n`Property 'reportingURL' does not exist on type 'BugReport'.2339Property 'reportingURL' does not exist on type 'BugReport'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQIJIAPABxgEsBbSAOwBcBDAGwBFIBjBBuhRXAMwCuNdnXJwaoaJBIJGAIyaQAwkwaJEbTtG4IAPABVQxOrQAmiUAG9QNSAHdQACgB0bhtADmKUAxoBPAG0AXQBKVCsAX1BIgD4nThpEOmhBUQRUA1DrXFApSDpBaEl2NQ1jIlMaC1BE5NT06By8vOlZaDEaTwBVACUAGVAAXlAAIgALOjoSZBB7ebcXUYBuXJjVyNxccDa5BkUVMs0OLh5oXFL1SwAhQU9emTlm0Dp-MmGx3Y6VtbE6JVQ9XIXVWazqKTSZycdEBKWBnmyVjWeTo43IiBcfyUHzoqzym02FwkyVA8juHzsjlu90eHScowAcpBIDUzB4ANagShwMyQUahVZ1OBKFxMOCeJxkzyY8j-SAC0AEAAK0GBdEsjOZrI5XJ5fKJSWFkFF4sld0xb3ly0VYBVao1Xzooy2BAZcFML3G3E9kFAvO0uiaAH0zHBIJYaO6g7UvV1fajfQZLQBldiqkh0F6W-BgPxmUCIOA+2wOUAkeBkDr+UAAA0d8L6-RroHRtndoHZkfsNBzLyLCaz70Q-mSkEoyFwUpc9a6jeWQA)\n\n## [](#method-decorators)Method Decorators\n\nA _Method Decorator_ is declared just before a method declaration. The decorator is applied to the _Property Descriptor_ for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the method decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The _Property Descriptor_ for the member.\n\n> NOTE  The _Property Descriptor_ will be `undefined` if your script target is less than `ES5`.\n\nIf the method decorator returns a value, it will be used as the _Property Descriptor_ for the method.\n\n> NOTE  The return value is ignored if your script target is less than `ES5`.\n\nThe following is an example of a method decorator (`@enumerable`) applied to a method on the `Greeter` class:\n\nts\n\n`class Greeter {`\n\n  `greeting: string;`\n\n  `constructor(message: string) {`\n\n    `this.greeting = message;`\n\n  `}`\n\n  `@enumerable(false)`\n\n  `greet() {`\n\n    `return \"Hello, \" + this.greeting;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgYNrkBGukABQA3PA0gAuULxIkB2dAEpQAbxqhQCSJgYIOjZq3ahBOBAHNtUhQE8ANLAQl4CTDYDSkG1KqZk6czsAE0gqImRYSgQpAAUnFzdCMIio5TUNDRDkpEiyADouHmx+SFAAXlBRXHEAbnVQAF86hpoQUABaTqIGTE72miJcbCoqUABxLW1EVXrzSdYAnz8kALqNUnRfBAYWMkE0EexLJf9zNPqNTAALJCo8uchtFfNy0AOqI8g1xpp6qHRuIhigJBHQ8FRIIpZvNBOcMpptLoOAAiAASkFwuBIdlAyNAAGpQNdbvd5s9vi0GkA)\n\nWe can define the `@enumerable` decorator using the following function declaration:\n\nts\n\n`function enumerable(value: boolean) {`\n\n  `return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {`\n\n    `descriptor.enumerable = value;`\n\n  `};`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUzCAtsgTgQwEYA2yAFAG44EjIBcieccROYAlIgN4BQiiWyUILElCRYCRMSg4sAc361mATwA0iAA5Y4a7FEUBpZItoBnKFhhgZqgCbJjEc2qhwstAAqbtWXQBE7DmCcXNi4eHlt7R2csADpUDGx8IkQAXkRySmQAbm5EAF8cvKA)\n\nThe `@enumerable(false)` decorator here is a [decorator factory](#decorator-factories). When the `@enumerable(false)` decorator is called, it modifies the `enumerable` property of the property descriptor.\n\n## [](#accessor-decorators)Accessor Decorators\n\nAn _Accessor Decorator_ is declared just before an accessor declaration. The accessor decorator is applied to the _Property Descriptor_ for the accessor and can be used to observe, modify, or replace an accessor’s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a `declare` class).\n\n> NOTE  TypeScript disallows decorating both the `get` and `set` accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a _Property Descriptor_, which combines both the `get` and `set` accessor, not each declaration separately.\n\nThe expression for the accessor decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The _Property Descriptor_ for the member.\n\n> NOTE  The _Property Descriptor_ will be `undefined` if your script target is less than `ES5`.\n\nIf the accessor decorator returns a value, it will be used as the _Property Descriptor_ for the member.\n\n> NOTE  The return value is ignored if your script target is less than `ES5`.\n\nThe following is an example of an accessor decorator (`@configurable`) applied to a member of the `Point` class:\n\nts\n\n`class Point {`\n\n  `private _x: number;`\n\n  `private _y: number;`\n\n  `constructor(x: number, y: number) {`\n\n    `this._x = x;`\n\n    `this._y = y;`\n\n  `}`\n\n  `@configurable(false)`\n\n  `get x() {`\n\n    `return this._x;`\n\n  `}`\n\n  `@configurable(false)`\n\n  `get y() {`\n\n    `return this._y;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqinp1IDmD5AEa5IACgBueBpABcoQSRIjs6AJSgA3jVCgEkTAI6NmrdqFHadoHAl765KgJ4AaSztgIS8BJkcBpSEc5KkxkdF5XK1AAE0gqImRYSgQ5AAVPb19CeMTky3UtKNicpCSyADouHn4hEVAAXlBJXGkAbksAX3aOmhBQAFpBogZMQf6aIlxsKipQVJIkLE1LDyRJTEhQAH1oOXQGFEFEdvdkdc2toNB9w+PLLhCEBhYyUV3rg6OEZ1Arm6+Cm5rAALJBUco7BqgaAnKyYUHgy5QxywnqWcBVPgCbDCMR0PBUSCqSx2TDQ0SAqJ6AwIDjwsEQmGdGjozE1HEiUT43CE4k6Um-CnLKn6QwghmXVE0DpAA)\n\nWe can define the `@configurable` decorator using the following function declaration:\n\nts\n\n`function configurable(value: boolean) {`\n\n  `return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {`\n\n    `descriptor.configurable = value;`\n\n  `};`\n\n`}`\n\n## [](#property-decorators)Property Decorators\n\nA _Property Decorator_ is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the property decorator will be called as a function at runtime, with the following two arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n\n> NOTE  A _Property Descriptor_ is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.\n\nWe can use this information to record metadata about the property, as in the following example:\n\nts\n\n`class Greeter {`\n\n  `@format(\"Hello, %s\")`\n\n  `greeting: string;`\n\n  `constructor(message: string) {`\n\n    `this.greeting = message;`\n\n  `}`\n\n  `greet() {`\n\n    `let formatString = getFormat(this, \"greeting\");`\n\n    `return formatString.replace(\"%s\", this.greeting);`\n\n  `}`\n\n`}`\n\nWe can then define the `@format` decorator and `getFormat` functions using the following function declarations:\n\nts\n\n`import \"reflect-metadata\";`\n\n`const formatMetadataKey = Symbol(\"format\");`\n\n`function format(formatString: string) {`\n\n  `return Reflect.metadata(formatMetadataKey, formatString);`\n\n`}`\n\n`function getFormat(target: any, propertyKey: string) {`\n\n  `return Reflect.getMetadata(formatMetadataKey, target, propertyKey);`\n\n`}`\n\nThe `@format(\"Hello, %s\")` decorator here is a [decorator factory](#decorator-factories). When `@format(\"Hello, %s\")` is called, it adds a metadata entry for the property using the `Reflect.metadata` function from the `reflect-metadata` library. When `getFormat` is called, it reads the metadata value for the format.\n\n> NOTE  This example requires the `reflect-metadata` library. See [Metadata](#metadata) for more information about the `reflect-metadata` library.\n\n## [](#parameter-decorators)Parameter Decorators\n\nA _Parameter Decorator_ is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the parameter decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The ordinal index of the parameter in the function’s parameter list.\n\n> NOTE  A parameter decorator can only be used to observe that a parameter has been declared on a method.\n\nThe return value of the parameter decorator is ignored.\n\nThe following is an example of a parameter decorator (`@required`) applied to parameter of a member of the `BugReport` class:\n\nts\n\n`class BugReport {`\n\n  `type = \"report\";`\n\n  `title: string;`\n\n  `constructor(t: string) {`\n\n    `this.title = t;`\n\n  `}`\n\n  `@validate`\n\n  `print(@required verbose: boolean) {`\n\n    `if (verbose) {`\n\n      ``return `type: ${this.type}\\ntitle: ${this.title}`;``\n\n    `} else {`\n\n     `return this.title;` \n\n    `}`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgBueSAJhZAAUOBAHNImAFyhs6AJ4AaULAQl4CTHIBy2NNKqZk6UUt6QqRZLEoJpAFTnxeABVXrNhC1ZsAeWXIA+AEpQAG8AX3omFjYOBEgARwYkeN5hbDEJaQB5ACMAK2JMJRU1RE0AaUg5fUMkY1AAH1AqORRcklwSjN0JRABJdDNoaXQGdsQQiJoQUABaBaIGTAW5miJcbCoqUAAhBlEAJUhYMkwwmlBQTXhQAF5QACJ4041HgG5L66RMXEhaoyiT5fUjoAwIBgsMjCAH1URTL5XTAACyQVAAdKxfpB7tdPldIl9wNxcHwBF8VPVMIJwPEkilILwuIgOlR-qAOp1ILIEVcrkg6KBBJwWSQ2by+Vd4pgGAgOAADG7sgAkoRRaMxjkg4QAOlgfn9pKr1RisX9wvL8XzwqBILg2RdJaBpbKOCbMQbIO9QIjQJECTRwkA)\n\nWe can then define the `@required` and `@validate` decorators using the following function declarations:\n\nts\n\n`import \"reflect-metadata\";`\n\n`const requiredMetadataKey = Symbol(\"required\");`\n\n`function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {`\n\n  `let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];`\n\n  `existingRequiredParameters.push(parameterIndex);`\n\n  `Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);`\n\n`}`\n\n`function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {`\n\n  `let method = descriptor.value!;`\n\n  `descriptor.value = function () {`\n\n    `let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);`\n\n    `if (requiredParameters) {`\n\n      `for (let parameterIndex of requiredParameters) {`\n\n        `if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {`\n\n          `throw new Error(\"Missing required argument.\");`\n\n        `}`\n\n      `}`\n\n    `}`\n\n    `return method.apply(this, arguments);`\n\n  `};`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEkKSmhp5lCAspDgCYXYaqWGUygARAkgAzXMUwBaNHwHiA3DVLoqYqQEcArkim9uKnAGlIAT1ABeUAGVrKAEYlcACkmRDxyLziAJQaNNIG6ESYSCTooPpGJp44CADmPABcoADyrgBW8gA0oLAIJPAImNZW1lk6yOipoAA+oFQu7rjFsNjkyogAkui8MFnoBm6IQaAA3jSgoHJiMEg6SI0ASr6JAQAKvdj9CFRjE66IANoAuvagW7LyAHTpmNkA7uhm2Pw4ngn+ph43wENWKKRe3TKFSqNWmzVa1w0CxWa022wB+z6PEQVEesAMVAAFp4eljMINhjAQvM7jI5FFHiNpOtIF8fthPPF0SY2SCbMUUdE0X4TJjDtjjmDehCSlDEDCbNSAL40MIRKIxOIANzwSB+kGS0syoGw6GskPK8usADlxXVMA1UsURlQiMhYBwsgAVazwXi7OWVayEV3ujgAHgAYurorEAHzTOYLJagZSEki8W4ut1ID1kR463AGSAAQlCC2zYfzheLt3CkVjcU8iZpyZ4XJFewORxOoHGkwQ11u93pmGePHenyB7L+3ICvMs-NA4J4FuhNvF1IWCyQ0lAs87-u7EqoLe32+kZH3KdJ4vJCCGI2goBIe-+ouP99Ps1b59Au-3W8jkfGBQDjBxpQmDBMFxORGkwQkWlaSC0CwKgLiAiUQOgG47Dw0AIiZFleDPP9zwQso3j7SAqIAUQQMoEG8ThViodYmnfAITTSKCsEeYIkTI0AVTIkTtzEhYpEwAwEDiNMM0ebBYFgXBrGSQlVmKFDoNPQSlQ0JUgA)\n\nThe `@required` decorator adds a metadata entry that marks the parameter as required. The `@validate` decorator then wraps the existing `print` method in a function that validates the arguments before invoking the original method.\n\n> NOTE  This example requires the `reflect-metadata` library. See [Metadata](#metadata) for more information about the `reflect-metadata` library.\n\nSome examples use the `reflect-metadata` library which adds a polyfill for an [experimental metadata API](https://github.com/rbuckton/ReflectDecorators). This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.\n\nYou can install this library via npm:\n\nshell\n\n`npm i reflect-metadata --save`\n\nTypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the [`emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata) compiler option either on the command line or in your `tsconfig.json`:\n\n**Command Line**:\n\nshell\n\n`tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata`\n\n**tsconfig.json**:\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"ES5\",`\n\n    `\"\": true,`\n\n    `\"\": true`\n\n  `}`\n\n`}`\n\nWhen enabled, as long as the `reflect-metadata` library has been imported, additional design-time type information will be exposed at runtime.\n\nWe can see this in action in the following example:\n\nts\n\n`import \"reflect-metadata\";`\n\n`class Point {`\n\n  `constructor(public x: number, public y: number) {}`\n\n`}`\n\n`class Line {`\n\n  `private _start: Point;`\n\n  `private _end: Point;`\n\n  `@validate`\n\n  `set start(value: Point) {`\n\n    `this._start = value;`\n\n  `}`\n\n  `get start() {`\n\n    `return this._start;`\n\n  `}`\n\n  `@validate`\n\n  `set end(value: Point) {`\n\n    `this._end = value;`\n\n  `}`\n\n  `get end() {`\n\n    `return this._end;`\n\n  `}`\n\n`}`\n\n`function validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {`\n\n  `let set = descriptor.set!;`\n\n  `descriptor.set = function (value: T) {`\n\n    `let type = Reflect.getMetadata(\"design:type\", target, propertyKey);`\n\n    `if (!(value instanceof type)) {`\n\n      ``throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);``\n\n    `}`\n\n    `set.call(this, value);`\n\n  `};`\n\n`}`\n\n`const line = new Line()`\n\n`line.start = new Point(0, 0)`\n\n`// @ts-ignore`\n\n`// line.end = {}`\n\n`// Fails at runtime with:`\n\n`// > Invalid type, got object not Point`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMFsEsBcAikDGB7ATgQ3pgspPFgCY5YBQIEkAHgA6QazSQB2RANsutrhgM6Uw4fvCYp4ABQxoGGeAE8AkqwSwsHWAC8csNKwBcoAGYb+kcszqZ4oAEQZIxjqngBaFkVJE7AbnLkKBxY-Pygkmiw7KAA3uSgoOisohgArhKYABR0qQBGmiigNEasqdC5jAA0oDn5sIUKJWUVGACUsQC+5F2BwaGgADJRkLHxNUwAbjgjAPqiWPJGEVHw-gl0k9OgM2zES5Hs-mPgU5reFgnmtvPymaepkPsr7XEJCfAAFrD8AHRzRPJQABeUD3SBrUA9BIAc0IoBu8EyLzGCUc8FSGFYoE+3z+CIhUIgp1g5zGV1AuzuGgeT3YyLe2K+vx2rGIwNB1PBY0JsNslPpbzRGKxOOZuwJ3QCxlSrAkeixxPOAB4ACoAPkyAN5RiwrAU1Q2skYigA0pBGvCxFFodViJB+CgmHQ+EYVQoGMRpEb5ApkA6nXxVWqBS5rnCQXb-bBnZgflcAIQQsaRx3Rvhx8MmGVy-SgKkcGmgFUChKh7HukYggBKThcEh+vIIXjImTskdg0MMigYdmqWsIBpkclN5taRwZsGMefj+YeoCi81lkDQU+7kFaJbenxkAHdQKxIHu3QwAKIYGQYTIAAxUivLDGq0LQtgAJDE1yuOQXIB198-QG+a4-KwWAsB0PxXmOKKQgEDJXD8KAaBwmpMtUYJQQkHT+D0SSiKAmgHuyB57kMB5IuQBGQHGAK2CCxHhAciIAAzVExrQBFQ4DwPwbgdqwmAWFQlE-Ls7IxD0VAAGJYLAHBhDgoBpOwzAjDuCAfAYQigGqoC3hoJL3pAj7-mguQAFauH+tjLOw5BAA)\n\nThe TypeScript compiler will inject design-time type information using the `@Reflect.metadata` decorator. You could consider it the equivalent of the following TypeScript:\n\nts\n\n`class Line {`\n\n  `private _start: Point;`\n\n  `private _end: Point;`\n\n  `@validate`\n\n  `@Reflect.metadata(\"design:type\", Point)`\n\n  `set start(value: Point) {`\n\n    `this._start = value;`\n\n  `}`\n\n  `get start() {`\n\n    `return this._start;`\n\n  `}`\n\n  `@validate`\n\n  `@Reflect.metadata(\"design:type\", Point)`\n\n  `set end(value: Point) {`\n\n    `this._end = value;`\n\n  `}`\n\n  `get end() {`\n\n    `return this._end;`\n\n  `}`\n\n`}`\n\n> NOTE  Decorator metadata is an experimental feature and may introduce breaking changes in future releases.",
    "title": "TypeScript: Documentation - Decorators",
    "description": "TypeScript Decorators overview",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/enums.html",
    "markdown": "# TypeScript: Handbook - Enums\n\nEnums are one of the few features TypeScript has which is not a type-level extension of JavaScript.\n\nEnums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.\n\n## [](#numeric-enums)Numeric enums\n\nWe’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages. An enum can be defined using the `enum` keyword.\n\nts\n\n`enum Direction {`\n\n  `Up = 1,`\n\n  `Down,`\n\n  `Left,`\n\n  `Right,`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQCMANAbBgO4h2EAywAZqq1AEpwA5gAseeAL5A)\n\nAbove, we have a numeric enum where `Up` is initialized with `1`. All of the following members are auto-incremented from that point on. In other words, `Direction.Up` has the value `1`, `Down` has `2`, `Left` has `3`, and `Right` has `4`.\n\nIf we wanted, we could leave off the initializers entirely:\n\nts\n\n`enum Direction {`\n\n  `Up,`\n\n  `Down,`\n\n  `Left,`\n\n  `Right,`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADgDQGwYDuIFhAMsAGar1QBKcA5gBZt4AvkA)\n\nHere, `Up` would have the value `0`, `Down` would have `1`, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.\n\nUsing an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:\n\nts\n\n`enum UserResponse {`\n\n  `No = 0,`\n\n  `Yes = 1,`\n\n`}`\n\n`function respond(recipient: string, message: UserResponse): void {`\n\n  `// ...`\n\n`}`\n\n`respond(\"Princess Caroline\", UserResponse.Yes);`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAqgzsATgJWHADgexAqBvAKCigDlMoBeKABgBoioBNNSqARnoF8CCAzMEAGMALgEtsURGiwgAJgAopg0elGhhALihxhiUSADmtKBDRwAhgeBb4SVBmwIAlFoBumUbPwMA9D6gAdEEE3ARSDnLyAEQACnpCZlAAwuaImAA2+sBRxrYo0o7AAcxwTgDcQA)\n\nNumeric enums can be mixed in [computed and constant members (see below)](#computed-and-constant-members). The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn’t allowed:\n\nts\n\n`enum E {`\n\n  `A = getSomeValue(),`\n\n  `B,`\n\n`Enum member must have initializer.1061Enum member must have initializer.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYBsaBQBjOAO0QBdQBzSUgZTgFtIA1AQwBsBXSUAXlAAoAlLwB8oAEwBmANy4QoALRL8HUkoW5IRDvVABRUAG9coUAEFelanUatOkIQBoToAELOAvkA)\n\n## [](#string-enums)String enums\n\nString enums are a similar concept, but have some subtle [runtime differences](#enums-at-runtime) as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.\n\nts\n\n`enum Direction {`\n\n  `Up = \"UP\",`\n\n  `Down = \"DOWN\",`\n\n  `Left = \"LEFT\",`\n\n  `Right = \"RIGHT\",`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQBERAClQDQGwYDu2lVMA8gOoByjZgBlgAM1QVqwgKIAxACpDCAJTgBzABaTOKgJIBxABJKmAXyA)\n\nWhile string enums don’t have auto-incrementing behavior, string enums have the benefit that they “serialize” well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn’t convey any useful meaning on its own (though [reverse mapping](#reverse-mappings) can often help). String enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.\n\n## [](#heterogeneous-enums)Heterogeneous enums\n\nTechnically enums can be mixed with string and numeric members, but it’s not clear why you would ever want to do so:\n\nts\n\n`enum BooleanLikeHeterogeneousEnum {`\n\n  `No = 0,`\n\n  `Yes = \"YES\",`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAQg9nANsAhiAMgSwNbABLAAuwATnAOajBxgDOAouNAN4BQUUAcnFALxQAGADTsoATWC0+UAERj6AZRkiAvkA)\n\nUnless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this.\n\n## [](#computed-and-constant-members)Computed and constant members\n\nEach enum member has a value associated with it which can be either _constant_ or _computed_. An enum member is considered constant if:\n\n*   It is the first member in the enum and it has no initializer, in which case it’s assigned the value `0`:\n    \n    ts\n    \n    `// E.X is constant:`\n    \n    `enum E {`\n    \n      `X,`\n    \n    `}`\n    \n    [Try](https://www.typescriptlang.org/play/#code/PTAEFEDoA1QSwM6gMYHsB2CAuBDdWAuAKAFN0BXAWwlAG8jRRoAaIgXyA)\n    \n*   It does not have an initializer and the preceding enum member was a _numeric_ constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.\n    \n    ts\n    \n    `// All enum members in 'E1' and 'E2' are constant.`\n    \n    `enum E1 {`\n    \n      `X,`\n    \n      `Y,`\n    \n      `Z,`\n    \n    `}`\n    \n    `enum E2 {`\n    \n      `A = 1,`\n    \n      `B,`\n    \n      `C,`\n    \n    `}`\n    \n    [Try](https://www.typescriptlang.org/play/#code/PTAEEEBtNBTA7ArgW1M2yBGsBOBnUAS3lAHIBRARlNAEN4ATM8gJhtp1lAGMB7ePABd6ggHQAocQhSgqoAN7jQoABoAaJaACaG5QC0NAX0nTUrBZvCgAvKEq7QAIQcBhI0A)\n    \n*   The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:\n    \n    1.  a literal enum expression (basically a string literal or a numeric literal)\n    2.  a reference to previously defined constant enum member (which can originate from a different enum)\n    3.  a parenthesized constant enum expression\n    4.  one of the `+`, `-`, `~` unary operators applied to constant enum expression\n    5.  `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` binary operators with constant enum expressions as operands\n    \n    It is a compile time error for constant enum expressions to be evaluated to `NaN` or `Infinity`.\n    \n\nIn all other cases enum member is considered computed.\n\nts\n\n`enum FileAccess {`\n\n  `// constant members`\n\n  `None,`\n\n  `Read = 1 << 1,`\n\n  `Write = 1 << 2,`\n\n  `ReadWrite = Read | Write,`\n\n  `// computed member`\n\n  `G = \"123\".length,`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAYglgG2AQQMauAZ01A3gKCigHpipUB7ETAFwEMQaoJgIAjYAJ00KgDkqwADS8ASsDoATKAF4oARigAeJQpFEA6pzg1gshctUAmdVHFStOvXPPSAPlEu7TpchQgAHMLukt2XXgBxfQAieSMAZhCAOiQQAHMaAAsRAF8gA)\n\n## [](#union-enums-and-enum-member-types)Union enums and enum member types\n\nThere is a special subset of constant enum members that aren’t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to\n\n*   any string literal (e.g. `\"foo\"`, `\"bar\"`, `\"baz\"`)\n*   any numeric literal (e.g. `1`, `100`)\n*   a unary minus applied to any numeric literal (e.g. `-1`, `-100`)\n\nWhen all members in an enum have literal enum values, some special semantics come into play.\n\nThe first is that enum members also become types as well! For example, we can say that certain members can _only_ have the value of an enum member:\n\nts\n\n`enum ShapeKind {`\n\n  `Circle,`\n\n  `Square,`\n\n`}`\n\n`interface Circle {`\n\n  `kind: ShapeKind.Circle;`\n\n  `radius: number;`\n\n`}`\n\n`interface Square {`\n\n  `kind: ShapeKind.Square;`\n\n  `sideLength: number;`\n\n`}`\n\n`let c: Circle = {`\n\n  `kind: ShapeKind.Square,`\n\n`Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.2322Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.    radius: 100,  };  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFCQHYCuAtqAMoAWAhgA6QDSAlvgCagDeOooAwo9AGMANpAA0XcgEdCVaGJwBfHDmYAXGADMqAyL37DdnbgGtmLVJVoMzAOj6CRAbgnQqLRoRSgixAEYxnJRV8dWgtHSkZOQ4JU1YLajomVhsyaVlIZ25ERhZIABkCAHNVClQff2hA5RFVUAFUewNQAF4YkzMEq2SWVPS5cW5Xd09UAEYABgnxBUcgA)\n\nThe other change is that enum types themselves effectively become a _union_ of each enum member. With union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch bugs where we might be comparing values incorrectly. For example:\n\nts\n\n`enum E {`\n\n  `Foo,`\n\n  `Bar,`\n\n`}`\n\n`function f(x: E) {`\n\n  `if (x !== E.Foo || x !== E.Bar) {`\n\n`This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.2367This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.      //    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUJAHYCuAtqAKKgDeeooAYnHADR2gBCAhtGwL548AM2KEAxgBcAlnEKghACgAeqCgEoa7KUNDLQAQgC8hygDomcUAB8roJQeNnu0DbXr0Q7AXyA)\n\nIn that example, we first checked whether `x` was _not_ `E.Foo`. If that check succeeds, then our `||` will short-circuit, and the body of the ‘if’ will run. However, if the check didn’t succeed, then `x` can _only_ be `E.Foo`, so it doesn’t make sense to see whether it’s _not_ equal to `E.Bar`.\n\n## [](#enums-at-runtime)Enums at runtime\n\nEnums are real objects that exist at runtime. For example, the following enum\n\nts\n\n`enum E {`\n\n  `X,`\n\n  `Y,`\n\n  `Z,`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfIA)\n\ncan actually be passed around to functions\n\nts\n\n`enum E {`\n\n  `X,`\n\n  `Y,`\n\n  `Z,`\n\n`}`\n\n`function f(obj: { X: number }) {`\n\n  `return obj.X;`\n\n`}`\n\n`// Works, since 'E' has a property named 'X' which is a number.`\n\n`f(E);`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfRRAMzBAGMAXASwHsQoyAKBgIwCsAuBNPuAgdgAJyhEAlAiyjgNMKOacuAOlQBuRCUQB6XVADqDUQGsAzuijm61YFADkMB1AAWAQ3NR3UAA6iGXzEaAE8oEHcIYAATR1QXAHdXOipXKDovHyERUVVyVhhJDSA)\n\n## [](#enums-at-compile-time)Enums at compile time\n\nEven though Enums are real objects that exist at runtime, the `keyof` keyword works differently than you might expect for typical objects. Instead, use `keyof typeof` to get a Type that represents all Enum keys as strings.\n\nts\n\n`enum LogLevel {`\n\n  `ERROR,`\n\n  `WARN,`\n\n  `INFO,`\n\n  `DEBUG,`\n\n`}`\n\n`/**`\n\n `* This is equivalent to:`\n\n `* type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';`\n\n `*/`\n\n`type LogLevelStrings = keyof typeof LogLevel;`\n\n`function printImportant(key: LogLevelStrings, message: string) {`\n\n  `const num = LogLevel[key];`\n\n  `if (num <= LogLevel.WARN) {`\n\n    `console.log(\"Log level key is:\", key);`\n\n    `console.log(\"Log level value is:\", num);`\n\n    `console.log(\"Log level message is:\", message);`\n\n  `}`\n\n`}`\n\n`printImportant(\"ERROR\", \"This is a message\");`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAMg9gcxsAbsANlA3gKClAUQCUiB5IgGjygHUBBIgOSvwElGAxUlqAEQIBCAVQDiVAL44cAegBUsvLKgAVABYBLAM5QtUYAEcw6lAEN0oAC5QLcAFyLrATwAOwWImRp0AZQsAndRAEbQBeKAByYjIicKgAHwj6JliE8PYuFIj+YRFwgG5FaRwLFzd4JFQMXwCg0KgAa2BHOAAzJ1dW9wqvApwWsBAAYwt1OBAoZxqLVghnOD8LExALAApGx1suzyr-QOCKKAhgTU0TBGBNzV2ggEpsakGxq6hwaDDy7fQAbXWAXQL8Oo2itXlAADzvDyVdAAOiSjDuuHw+EeIE0cHMMPQiBWACJylBzF4Gk0dJpbLiDusbgDkaj0ZjsQg8QSiRgoKZ0GA3FoKQdXjTqCinhjgFicfjEIToYdjqdzmS+bKTmdgIL8JJJJNAtNZvNFss8VFyJSoLi1LpdCZlfLgLiaUA)\n\n### [](#reverse-mappings)Reverse mappings\n\nIn addition to creating an object with property names for members, numeric enums members also get a _reverse mapping_ from enum values to enum names. For example, in this example:\n\nts\n\n`enum Enum {`\n\n  `A,`\n\n`}`\n\n`let a = Enum.A;`\n\n`let nameOfA = Enum[a]; // \"A\"`\n\n[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAou0G8BQUoEEA0SC+SkBtgAXKAQygF5Z4A6NAbgOKhFImAHkAzNS6yANqkAuvSgB6cVABEaaUA)\n\nTypeScript compiles this down to the following JavaScript:\n\nts\n\n`\"use strict\";`\n\n`var Enum;`\n\n`(function (Enum) {`\n\n    `Enum[Enum[\"A\"] = 0] = \"A\";`\n\n`})(Enum || (Enum = {}));`\n\n`let a = Enum.A;`\n\n`let nameOfA = Enum[a]; // \"A\"`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAFMB2BXZURAogb01FAEEAaTAX00wBtt1QBDUAXmNIB01ANyt2oXJ2TYA8gDNqvfoQDanALrDQIUACJquoA)\n\nIn this generated code, an enum is compiled into an object that stores both forward (`name` -> `value`) and reverse (`value` -> `name`) mappings. References to other enum members are always emitted as property accesses and never inlined.\n\nKeep in mind that string enum members _do not_ get a reverse mapping generated at all.\n\n### [](#const-enums)`const` enums\n\nIn most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use `const` enums. Const enums are defined using the `const` modifier on our enums:\n\nts\n\n`const enum Enum {`\n\n  `A = 1,`\n\n  `B = A * 2,`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUSag3gKBjAQRgF4YBGAGjxgCETCYAqGAJioF8g)\n\nConst enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.\n\nts\n\n`const enum Direction {`\n\n  `Up,`\n\n  `Down,`\n\n  `Left,`\n\n  `Right,`\n\n`}`\n\n`let directions = [`\n\n  `Direction.Up,`\n\n  `Direction.Down,`\n\n  `Direction.Left,`\n\n  `Direction.Right,`\n\n`];`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgEQJYCc7Ch8GAbwCgYYBVABwBoz0QB3MO8gGTgDMpWYAlDAHMAFjxIBfEiQA2cWABNsufOAgwAvDADa9TDjwEwAOmq89yw0bRMWupQfBGO3M-ZXGBIsQF0A3EA)\n\nin generated code will become\n\nts\n\n`\"use strict\";`\n\n`let directions = [`\n\n    `0 /* Direction.Up */,`\n\n    `1 /* Direction.Down */,`\n\n    `2 /* Direction.Left */,`\n\n    `3 /* Direction.Right */,`\n\n`];`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1QBTPAV2VABFUAnY7dVfUAb01FAFUAHAGg7UEeAZwAyxAGbpRoAEqoA5tBmYAvpkwAbYkQAmdBk3yRQAXlABtQTXqNmeAHS9Ztow8dVhrw-fyOJaR87YycFZVUAXQBuIA)\n\n#### [](#const-enum-pitfalls)Const enum pitfalls\n\nInlining enum values is straightforward at first, but comes with subtle implications. These pitfalls pertain to _ambient_ const enums only (basically const enums in `.d.ts` files) and sharing them between projects, but if you are publishing or consuming `.d.ts` files, these pitfalls likely apply to you, because `tsc --declaration` transforms `.ts` files into `.d.ts` files.\n\n1.  For the reasons laid out in the [`isolatedModules` documentation](https://www.typescriptlang.org/tsconfig#references-to-const-enum-members), that mode is fundamentally incompatible with ambient const enums. This means if you publish ambient const enums, downstream consumers will not be able to use [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules) and those enum values at the same time.\n2.  You can easily inline values from version A of a dependency at compile time, and import version B at runtime. Version A and B’s enums can have different values, if you are not very careful, resulting in [surprising bugs](https://github.com/microsoft/TypeScript/issues/5219#issue-110947903), like taking the wrong branches of `if` statements. These bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.\n3.  [`importsNotUsedAsValues: \"preserve\"`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues) will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime `.js` files exist. The unresolvable imports cause errors at runtime. The usual way to unambiguously elide imports, [type-only imports](https://www.typescriptlang.org/docs/handbook/modules/reference.html#type-only-imports-and-exports), [does not allow const enum values](https://github.com/microsoft/TypeScript/issues/40344), currently.\n\nHere are two approaches to avoiding these pitfalls:\n\n1.  Do not use const enums at all. You can easily [ban const enums](https://typescript-eslint.io/linting/troubleshooting#how-can-i-ban-specific-language-feature) with the help of a linter. Obviously this avoids any issues with const enums, but prevents your project from inlining its own enums. Unlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications.\n    \n2.  Do not publish ambient const enums, by deconstifying them with the help of [`preserveConstEnums`](https://www.typescriptlang.org/tsconfig#preserveConstEnums). This is the approach taken internally by the [TypeScript project itself](https://github.com/microsoft/TypeScript/pull/5422). [`preserveConstEnums`](https://www.typescriptlang.org/tsconfig#preserveConstEnums) emits the same JavaScript for const enums as plain enums. You can then safely strip the `const` modifier from `.d.ts` files [in a build step](https://github.com/microsoft/TypeScript/blob/1a981d1df1810c868a66b3828497f049a944951c/Gulpfile.js#L144).\n    \n    This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely.\n    \n\n## [](#ambient-enums)Ambient enums\n\nAmbient enums are used to describe the shape of already existing enum types.\n\nts\n\n`declare enum Enum {`\n\n  `A = 1,`\n\n  `B,`\n\n  `C = 2,`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEIB2BXAtvAoqjBvAUPPAILwC88AjADSHwBCtRAwufAEy0C+QA)\n\nOne important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer will be considered constant if its preceding enum member is considered constant. By contrast, an ambient (and non-const) enum member that does not have an initializer is _always_ considered computed.\n\n## [](#objects-vs-enums)Objects vs Enums\n\nIn modern TypeScript, you may not need an enum when an object with `as const` could suffice:\n\nts\n\n`const enum EDirection {`\n\n  `Up,`\n\n  `Down,`\n\n  `Left,`\n\n  `Right,`\n\n`}`\n\n`const ODirection = {`\n\n  `Up: 0,`\n\n  `Down: 1,`\n\n  `Left: 2,`\n\n  `Right: 3,`\n\n`} as const;`\n\n`EDirection.Up;`\n\n           `(enum member) EDirection.Up = 0`\n\n`ODirection.Up;`\n\n           `(property) Up: 0`\n\n`// Using the enum as a parameter`\n\n`function walk(dir: EDirection) {}`\n\n`// It requires an extra line to pull out the values`\n\n`type Direction = typeof ODirection[keyof typeof ODirection];`\n\n`function run(dir: Direction) {}`\n\n`walk(EDirection.Left);`\n\n`run(ODirection.Right);`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUQCIEsBOdhRbgwDeAUDDAKoAOANBTBiAO5gOUAycAZlBzABKWAOYALfmQC+ZMqEiwA8tjwEiYGAF5SjWgC4YABgHM2BgIwDufAwCYBw8VAMBmBlJgBDCDHnQA3LKYuPiE4AB0tIEA9NGU8QkAegD8ssohahFRZLEJeSmyuVQQWGAiMFBicPBIqN5eMDSeOJ7IcFBwOGQ8iGCZGiyeADYA1gAUACa4BsGqYWAAlKQyOXEAkrB4AI6IIT6eGnAAHlAtMEOl1VAgjYhDQzAgiLCV1QBuw4hwEGRQAJ40aoqULqLQVAFwEA8GDpObqADaIzgfyh4MBqNhIPAAF1Aj0+vMYDhepNpkwMvMliQVoNRmNZliwOFrFAFoFiWAxpj+uFHBI2UA)\n\nThe biggest argument in favour of this format over TypeScript’s `enum` is that it keeps your codebase aligned with the state of JavaScript, and [when/if](https://github.com/rbuckton/proposal-enum) enums are added to JavaScript then you can move to the additional syntax.",
    "title": "TypeScript: Handbook - Enums",
    "description": "How TypeScript enums work",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html",
    "markdown": "# TypeScript: Documentation - Iterators and Generators\n\n## [](#iterables)Iterables\n\nAn object is deemed iterable if it has an implementation for the [`Symbol.iterator`](https://www.typescriptlang.org/docs/handbook/symbols.html#symboliterator) property. Some built-in types like `Array`, `Map`, `Set`, `String`, `Int32Array`, `Uint32Array`, etc. have their `Symbol.iterator` property already implemented. `Symbol.iterator` function on an object is responsible for returning the list of values to iterate on.\n\n### [](#iterable-interface)`Iterable` interface\n\n`Iterable` is a type we can use if we want to take in types listed above which are iterable. Here is an example:\n\nts\n\n`function toArray<X>(xs: Iterable<X>): X[] {`\n\n  `return [...xs]`\n\n`}`\n\n### [](#forof-statements)`for..of` statements\n\n`for..of` loops over an iterable object, invoking the `Symbol.iterator` property on the object. Here is a simple `for..of` loop on an array:\n\nts\n\n`let someArray = [1, \"string\", false];`\n\n`for (let entry of someArray) {`\n\n  `console.log(entry); // 1, \"string\", false`\n\n`}`\n\n### [](#forof-vs-forin-statements)`for..of` vs. `for..in` statements\n\nBoth `for..of` and `for..in` statements iterate over lists; the values iterated on are different though, `for..in` returns a list of _keys_ on the object being iterated, whereas `for..of` returns a list of _values_ of the numeric properties of the object being iterated.\n\nHere is an example that demonstrates this distinction:\n\nts\n\n`let list = [4, 5, 6];`\n\n`for (let i in list) {`\n\n  `console.log(i); // \"0\", \"1\", \"2\",`\n\n`}`\n\n`for (let i of list) {`\n\n  `console.log(i); // 4, 5, 6`\n\n`}`\n\nAnother distinction is that `for..in` operates on any object; it serves as a way to inspect properties on this object. `for..of` on the other hand, is mainly interested in values of iterable objects. Built-in objects like `Map` and `Set` implement `Symbol.iterator` property allowing access to stored values.\n\nts\n\n`let pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);`\n\n`pets[\"species\"] = \"mammals\";`\n\n`for (let pet in pets) {`\n\n  `console.log(pet); // \"species\"`\n\n`}`\n\n`for (let pet of pets) {`\n\n  `console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"`\n\n`}`\n\n### [](#code-generation)Code generation\n\n#### [](#targeting-es5-and-es3)Targeting ES5 and ES3\n\nWhen targeting an ES5 or ES3-compliant engine, iterators are only allowed on values of `Array` type. It is an error to use `for..of` loops on non-Array values, even if these non-Array values implement the `Symbol.iterator` property.\n\nThe compiler will generate a simple `for` loop for a `for..of` loop, for instance:\n\nts\n\n`let numbers = [1, 2, 3];`\n\n`for (let num of numbers) {`\n\n  `console.log(num);`\n\n`}`\n\nwill be generated as:\n\njs\n\n`var numbers = [1, 2, 3];`\n\n`for (var _i = 0; _i < numbers.length; _i++) {`\n\n  `var num = numbers[_i];`\n\n  `console.log(num);`\n\n`}`\n\n#### [](#targeting-ecmascript-2015-and-higher)Targeting ECMAScript 2015 and higher\n\nWhen targeting an ECMAScript 2015-compliant engine, the compiler will generate `for..of` loops to target the built-in iterator implementation in the engine.",
    "title": "TypeScript: Documentation - Iterators and Generators",
    "description": "How Iterators and Generators work in TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/mixins.html",
    "markdown": "# TypeScript: Documentation - Mixins\n\nAlong with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.\n\n## [](#how-does-a-mixin-work)How Does A Mixin Work?\n\nThe pattern relies on using generics with class inheritance to extend a base class. TypeScript’s best mixin support is done via the class expression pattern. You can read more about how this pattern works in JavaScript [here](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/).\n\nTo get started, we’ll need a class which will have the mixins applied on top of:\n\nts\n\n`class Sprite {`\n\n  `name = \"\";`\n\n  `x = 0;`\n\n  `y = 0;`\n\n  `constructor(name: string) {`\n\n    `this.name = name;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAOAnAlgFwKbQN4ChrQDswBbTAXmgCJKBuPaAD2goAY78BPZ6Nne4APYEIqRAFdgqAYgAURUgC5oIlAQDmASmz18qABbIIAOnnlCJdO2gBfHNaA)\n\nThen you need a type and a factory function which returns a class expression extending the base class.\n\nts\n\n`// To get started, we need a type which we'll use to extend`\n\n`// other classes from. The main responsibility is to declare`\n\n`// that the type being passed in is a class.`\n\n`type Constructor = new (...args: any[]) => {};`\n\n`// This mixin adds a scale property, with getters and setters`\n\n`// for changing it with an encapsulated private property:`\n\n`function Scale<TBase extends Constructor>(Base: TBase) {`\n\n  `return class Scaling extends Base {`\n\n    `// Mixins may not declare private/protected properties`\n\n    `// however, you can use ES2020 private fields`\n\n    `_scale = 1;`\n\n    `setScale(scale: number) {`\n\n      `this._scale = scale;`\n\n    `}`\n\n    `get scale(): number {`\n\n      `return this._scale;`\n\n    `}`\n\n  `};`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEBUHtQcwUwC6gM4IIYCcFwCYBpQB3OUAOzl1DVAQE8AHEwgCwEsBjZouAcgBs+oAK7ISCaHAAe2UjgBQIUJATM4GUOz5pko5KABmGSAFsAdBFWhjaVqVAY4yepFLJWAI1Z9WdUKz3ioDhwmphwCmAqaEgqYgwk7nC2MKD02qI4fnb+VBpaOqZycnSMoADCLqgYQuzi6gC8ZHCEoAAUph2YMMgAXFSktADaALoAlKD1AHygAN4AvgDcRYrgbHrGrJK2VDg4etTI7Gh8JPRGjFi0BIQ+XPAI2Bj7siiIj8gRBpDqnGikMMk-Egbip+qA4KQjvRkEItNhMmdWAA3aKnc5qOg9Ir6ISQhCsFygADKRxOAB5wAAhbQkKQyPblSoIaq1b6TVrU0R9Kk08YzOSgeyIIQYOyhHTE0mAukQhmckj8wWCxQAWU2tnWaFoZGUQRCWgcqQwyNRwDOyhC8KNkAu+McAqVimYkGISLUBFokCEGj+wlEoAAokSAEwABjDRpN2AMrDgfD2DsFAH1DscSI0AIxLROvBAktOtVMnPqkITGRIYPk5wUqfymFOk9MoRtLJWgOZFNv3ZsF0YlssV2bVoUIEV2WvIetFuCtpUdwWLORzIA)\n\nWith these all set up, then you can create a class which represents the base class with mixins applied:\n\nts\n\n`// Compose a new class from the Sprite class,`\n\n`// with the Mixin Scale applier:`\n\n`const EightBitSprite = Scale(Sprite);`\n\n`const flappySprite = new EightBitSprite(\"Bird\");`\n\n`flappySprite.setScale(0.8);`\n\n`console.log(flappySprite.scale);`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAOAnAlgFwKbQN4ChrQDswBbTAXmgCJKBuPaAD2goAY78BPZ6Nne4APYEIqRAFdgqAYgAURUgC5oIlAQDmASmz18qABbIIAOnnlCJdO2gBfHLdQd4mAMJCVEqYm4F0Ad2gyRkFgiGoQSmAEHADaALpaZAB82NZ0AGZiBJLIQnDAYCDoADwAKgBCkJjoDBgEACYwrsKiHtKJMhUQ6ErllVq4+IjoqGKIBNCgkDCw+SDI6tDVtQ3QnZgD+NAA9FvQALLIDPMwxGBcBAKo0HXok0PQSMgAbmAYW0iXtxh1D4gCTohUMh0BAdNtdnoBL50E90IgADTQDgCMQTSLQMRdaAAUVgACYWATfs9Xpg0sCQA0wQB9CCzMwARjoYK6qBmBXQMjpHKUBDExAARnD+mDdAZjLT6dxuYUrPhbGC1MNlPSZBpefyhV4NptoEMRmNoPpDEZJRy5TZ6Kk7DgdtAALSO4BiVCO+223auYjwARYsCEPwTcBQaBpP7EI16TAIFAYINTeEe6C+NB6SOYA5HcbswrQMDweBzOEKHCCZo45BqPSoMpoGNoMw5zn1jAaZllkSh8AFjgtsw+fzYyvV2tsx4YGSUWuIOqUNs4NLd+C98foIyspsyFhGAAc847AkKRhAAjUMkX+eXffX9LbQA)\n\n## [](#constrained-mixins)Constrained Mixins\n\nIn the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want.\n\nTo model this, we modify the original constructor type to accept a generic argument.\n\nts\n\n`// This was our previous constructor:`\n\n`type Constructor = new (...args: any[]) => {};`\n\n`// Now we use a generic version which can apply a constraint on`\n\n`// the class which this mixin is applied to`\n\n`type GConstructor<T = {}> = new (...args: any[]) => T;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEBUAsEsGdQO4EN4HsCuAnUAHTBTAN2g3gGNUA7WAF03TJtUwC4AoGgTx31AGEqteo2agAvKEr4EoABQA6RUkwBzWC1BJKnANoBdAJTiAfKADeAXwDcbEKAByqGQl7pYvJKBX4pmaGVBCfExYEkpEGDJIUDItTRwcABtOTRjBOiRoShpQKlswGkheMkSUeARI6MK4UABbaAAPLNAapATE6HwAE1AmDm5eAHEBajoGJkwAHnBxcwtTCSkZBSVVdU1tfSMxU3ArIA)\n\nThis allows for creating classes which only work with constrained base classes:\n\nts\n\n`type Positionable = GConstructor<{ setPos: (x: number, y: number) => void }>;`\n\n`type Spritable = GConstructor<Sprite>;`\n\n`type Loggable = GConstructor<{ print: () => void }>;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gwgewHYGdgCcCuBjYD0A8AKlALxQDeAvgHxlRIQDuUAFAHScCG6A5igC4oXJCADaAXQCUZOkQDcAKGwAbLihRQAymHQBLYNAqKoDLgFto5AETWlpgB70ADPaggXSk1GzI0WXHxWJAsIIX89JF4ZY1NTYAALPRR2EMt6NIg3KkUcgHo8qABaEuxMYBKixVBIKAAFBBQDPWQuACMVK1hEVAwcPEIKKBQIYAbBNgchJExzNoh0ABp3adn59BlSOgA3BD0AEyhaJRroHX1gds76eD8+wMJzgwgaE-BoABkEXl4rrtvegEBgQhrpIsAhKxNjs9odjkA)\n\nThen you can create mixins which only work when you have a particular base to build on:\n\nts\n\n`function Jumpable<TBase extends Positionable>(Base: TBase) {`\n\n  `return class Jumpable extends Base {`\n\n    `jump() {`\n\n      `// This mixin will only work if it is passed a base`\n\n      `// class which has setPos defined because of the`\n\n      `// Positionable constraint.`\n\n      `this.setPos(0, 20);`\n\n    `}`\n\n  `};`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gwgewHYGdgCcCuBjYD0A8AKlALxQDeAvgHxlRIQDuUAFAHScCG6A5igC4oXJCADaAXQCUZOkQDcAKGwAbLihRQAymHQBLYNAqKoDLgFto5AETWlpgB70ADPaggXSk1GzI0WXHxWJAsIIX89JF4ZY1NTYAALPRR2EMt6NIg3KkUc0EgoAAUEFAM9ZC4AIxUrWERUDBw8QgooFAhgYsE2ByEkTHNKiHQAGnc+gaH0GVI6ADcEPQATKFolfOgdfWAqmvp4P0bAwi2DCBp18GgAGQReXl3ag4aA5oJW3UjgIVYZ+cWVmtFAB6YFQAC0kOwmGAkPBikUADNMEhcOUkFAAFIDMCPYgAIXU0AgDkMSCWmi6ZQq1XOrEJ7SERAZEBi3nQHUw6AxqnUmmx5lxtKgJLJFKgLMo3lMACscb8pXE4qCoEQkppzHoHJEoEw9CoVFBkCoPEx8ABrKB6RFW4BWzS4jQQFZcKCVInS5Vg3kaXVJbAJKAJdRtDpdKBLCCIyLOt0QbBcTDtI02xIQT2mFVU4Dox4+Q7oLhfdgZqCJZLsdqdEqsZxjABMzikblMOVbSioQA)\n\n## [](#alternative-pattern)Alternative Pattern\n\nPrevious versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:\n\nts\n\n`// Each mixin is a traditional ES class`\n\n`class Jumpable {`\n\n  `jump() {}`\n\n`}`\n\n`class Duckable {`\n\n  `duck() {}`\n\n`}`\n\n`// Including the base`\n\n`class Sprite {`\n\n  `x = 0;`\n\n  `y = 0;`\n\n`}`\n\n`// Then you create an interface which merges`\n\n`// the expected mixins with the same name as your base`\n\n`interface Sprite extends Jumpable, Duckable {}`\n\n`// Apply the mixins into the base class via`\n\n`// the JS at runtime`\n\n`applyMixins(Sprite, [Jumpable, Duckable]);`\n\n`let player = new Sprite();`\n\n`player.jump();`\n\n`console.log(player.x, player.y);`\n\n`// This can live anywhere in your codebase:`\n\n`function applyMixins(derivedCtor: any, constructors: any[]) {`\n\n  `constructors.forEach((baseCtor) => {`\n\n    `Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {`\n\n      `Object.defineProperty(`\n\n        `derivedCtor.prototype,`\n\n        `name,`\n\n        `Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||`\n\n          `Object.create(null)`\n\n      `);`\n\n    `});`\n\n  `});`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFAigCimiAFqALbwAe8AdqPJKJqHJgCbzTwB7RjlIBlUImyZIkApOlsAUgFdqAB0wAjbHlABvAqFAArVWoAUASn0BfAnblSZoACLLEAay079h0N3cPK1t7AiIwAElGSWVeRgBzTgpdTWlCeWdRNQRoXQMjOlAAXlAABgBuPwBPYrLKh2IAFWTmKoFlCVg8TFz2ZiZc2CxEXQB3CiQqajxYeLxZYmhk0Dw6NTxkPG4aeiY2Ub4qJd1ITGnQYXPpUDblWFBU-AIBmeHdLJzdVdzGbiUzbx4AA0rkCgJCxAAgmo1NgascdgxGGwBgIkik0hInGwAG7wTDhdGgRTiHqgWDKRj8aYETAwuEAWV2yPMHz4wNAAG0VOpASC3J5AQBdSyVAg6aCgWGYKozWqMPCjUBs3JWSrS2WwAB0pnUarkQkgAh0WuwAni5g1My1dBBVu1VVFYSaEzYiEwzGw8Bxug9VXGM10TBu7XuiAE3DwjzwKAI6EpyEEzDpsKqTKRkHMkYQPu4AGFoAJYGg-SDw8i4O5C7BICXGFVOSLfEZyzAKcgi5Ategi2RKOZzNGC0XrEUAHzNoygADymmMG2gWrm0Gno0YAAVYAJ1rBoFUAHJneaDtLD7XZASFvfrSzd3vkCgDy54UcT-JToyz+fILWR9BMPBN23GY93MPwPyMbNvS2M8tQvK8qnWIFwIg59kIgqcvwXJc8BXNcgJ3PcXHmRAEDUasT3wWD4MvRCOWfawAB9GJQjCsJ-UjulVRhlGwbBLFY0AnQ-GxhNAUT6iAA)\n\nThis pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync.\n\n## [](#constraints)Constraints\n\nThe mixin pattern is supported natively inside the TypeScript compiler by code flow analysis. There are a few cases where you can hit the edges of the native support.\n\n#### [](#decorators-and-mixins-4881)Decorators and Mixins [`#4881`](https://github.com/microsoft/TypeScript/issues/4881)\n\nYou cannot use decorators to provide mixins via code flow analysis:\n\nts\n\n`// A decorator function which replicates the mixin pattern:`\n\n`const Pausable = (target: typeof Player) => {`\n\n  `return class Pausable extends target {`\n\n    `shouldFreeze = false;`\n\n  `};`\n\n`};`\n\n`@Pausable`\n\n`class Player {`\n\n  `x = 0;`\n\n  `y = 0;`\n\n`}`\n\n`// The Player class does not have the decorator's type merged:`\n\n`const player = new Player();`\n\n`player.shouldFreeze;`\n\n`Property 'shouldFreeze' does not exist on type 'Player'.2339Property 'shouldFreeze' does not exist on type 'Player'.  // The runtime aspect could be manually replicated via  // type composition or interface merging.  type FreezablePlayer = Player & { shouldFreeze: boolean };  const playerTwo = (new Player() as unknown) as FreezablePlayer;  playerTwo.shouldFreeze;  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEiC1AXKAEwDMHAnHWAIKgAJsTIUyoAGYBXdEUxIS6UAHcAFkiJrQCSLFyaKkKqExrIoFEmhJlsCpkTpmNUuiqZQABWzSq2ACNcCwBeUAAKHAQAc0hMVkwAT3gSSW9cbETEAEpQEIA+UABvGlAdOOkEZSIMqhMfP0Dg0BhHdCETKNjPErKyqjUSaVwhADFdSAAvUKk8KkgAblLQAF8ltZoacAb-IMhXWvqMrIRi5eg80AAGJbLEy5uaFc36ABVzdMzEUBrsOuESMZQOgSJ41NgAG4WMwWESkciUBAAck6yQsaBikCELjcHlA+i+pzC6EgKk+J3C2SWBJOADoBkMRuNIFNFi8wO8LAhZAo0KA-vB5D9GUJQAF0dh0NI8Lh7rp9IZHKKIUhsHxTGjhShYCQqEgFEpQBJbI4EJJsER0YhorZorSaEl4KBmVMmpAvMdvmEPYTQAAyYqgBnDMYTaasAIkEjBSWrJauJR4mmIV4qEiXcIksk+im5P6gWQAaxBKnQeZMLsmbpziGpnoQqZI9MGIcriyAA)\n\n#### [](#static-property-mixins-17829)Static Property Mixins [`#17829`](https://github.com/microsoft/TypeScript/issues/17829)\n\nMore of a gotcha than a constraint. The class expression pattern creates singletons, so they can’t be mapped at the type system to support different variable types.\n\nYou can work around this by using functions to return your classes which differ based on a generic:\n\nts\n\n`function base<T>() {`\n\n  `class Base {`\n\n    `static prop: T;`\n\n  `}`\n\n  `return Base;`\n\n`}`\n\n`function derived<T>() {`\n\n  `class Derived extends base<T>() {`\n\n    `static anotherProp: T;`\n\n  `}`\n\n  `return Derived;`\n\n`}`\n\n`class Spec extends derived<string>() {}`\n\n`Spec.prop; // string`\n\n`Spec.anotherProp; // string`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAIwIYGcCmAeAKgPgAoBKRAbwChFEIAbDdRAIQ03KusXSlVgkQAOAJzgCAXIlwBuDgF8OQzFBBCkLLDPkVQkWAkQATTEJgA3TAbxFSlanQaIAIsbMXEmAB5RMYA4zRYViTsnFw8fIioYHBQABbGAAoi4pIy1PLUisqqTi7mBpoUFPbojADKApj8nt6+jEYm+djcJmAA5tbkWhVVAHTColKIAPTDYa1tFD0QvVEx8UJJgyNjLTDtQA)",
    "title": "TypeScript: Documentation - Mixins",
    "description": "Using the mixin pattern with TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/jsx.html",
    "markdown": "# TypeScript: Documentation - JSX\n\n[JSX](https://facebook.github.io/jsx/) is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the [React](https://reactjs.org/) framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.\n\n## [](#basic-usage)Basic usage\n\nIn order to use JSX you must do two things.\n\n1.  Name your files with a `.tsx` extension\n2.  Enable the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) option\n\nTypeScript ships with several JSX modes: `preserve`, `react` (classic runtime), `react-jsx` (automatic runtime), `react-jsxdev` (automatic development runtime), and `react-native`. The `preserve` mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. [Babel](https://babeljs.io/)). Additionally the output will have a `.jsx` file extension. The `react` mode will emit `React.createElement`, does not need to go through a JSX transformation before use, and the output will have a `.js` file extension. The `react-native` mode is the equivalent of `preserve` in that it keeps all JSX, but the output will instead have a `.js` file extension.\n\n| Mode | Input | Output | Output File Extension |\n| --- | --- | --- | --- |\n| `preserve` | `<div />` | `<div />` | `.jsx` |\n| `react` | `<div />` | `React.createElement(\"div\")` | `.js` |\n| `react-native` | `<div />` | `<div />` | `.js` |\n| `react-jsx` | `<div />` | `_jsx(\"div\", {}, void 0);` | `.js` |\n| `react-jsxdev` | `<div />` | `_jsxDEV(\"div\", {}, void 0, false, {...}, this);` | `.js` |\n\nYou can specify this mode using either the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) command line flag or the corresponding option [`jsx` in your tsconfig.json](https://www.typescriptlang.org/tsconfig#jsx) file.\n\n> \\*Note: You can specify the JSX factory function to use when targeting react JSX emit with [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory) option (defaults to `React.createElement`)\n\n## [](#the-as-operator)The `as` operator\n\nRecall how to write a type assertion:\n\nts\n\n`const foo = <foo>bar;`\n\nThis asserts the variable `bar` to have the type `foo`. Since TypeScript also uses angle brackets for type assertions, combining it with JSX’s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in `.tsx` files.\n\nSince the above syntax cannot be used in `.tsx` files, an alternate type assertion operator should be used: `as`. The example can easily be rewritten with the `as` operator.\n\nts\n\n`const foo = bar as foo;`\n\nThe `as` operator is available in both `.ts` and `.tsx` files, and is identical in behavior to the angle-bracket type assertion style.\n\n## [](#type-checking)Type Checking\n\nIn order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression `<expr />`, `expr` may either refer to something intrinsic to the environment (e.g. a `div` or `span` in a DOM environment) or to a custom component that you’ve created. This is important for two reasons:\n\n1.  For React, intrinsic elements are emitted as strings (`React.createElement(\"div\")`), whereas a component you’ve created is not (`React.createElement(MyComponent)`).\n2.  The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known _intrinsically_ whereas components will likely want to specify their own set of attributes.\n\nTypeScript uses the [same convention that React does](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components) for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.\n\n### [](#the-jsx-namespace)The `JSX` namespace\n\nJSX in TypeScript is typed by the `JSX` namespace. The `JSX` namespace may be defined in various places, depending on the `jsx` compiler option.\n\nThe `jsx` options `preserve`, `react`, and `react-native` use the type definitions for classic runtime. This means a variable needs to be in scope that’s determined by the `jsxFactory` compiler option. The `JSX` namespace should be specified on the top-most identifier of the JSX factory. For example, React uses the default factory `React.createElement`. This means its `JSX` namespace should be defined as `React.JSX`.\n\nts\n\n`export function createElement(): any;`\n\n`export namespace JSX {`\n\n  `// …`\n\n`}`\n\nAnd the user should always import React as `React`.\n\nts\n\n`import * as React from 'react';`\n\nPreact uses the JSX factory `h`. That means its types should be defined as the `h.JSX`.\n\nts\n\n`export function h(props: any): any;`\n\n`export namespace h.JSX {`\n\n  `// …`\n\n`}`\n\nThe user should use a named import to import `h`.\n\nts\n\n`import { h } from 'preact';`\n\nFor the `jsx` options `react-jsx` and `react-jsxdev`, the `JSX` namespace should be exported from the matching entry points. For `react-jsx` this is `${jsxImportSource}/jsx-runtime`. For `react-jsxdev`, this is `${jsxImportSource}/jsx-dev-runtime`. Since these don’t use a file extension, you must use the [`exports`](https://nodejs.org/api/packages.html#exports) field in `package.json` map in order to support ESM users.\n\njson\n\n`{`\n\n  `\"exports\": {`\n\n    `\"./jsx-runtime\": \"./jsx-runtime.js\",`\n\n    `\"./jsx-dev-runtime\": \"./jsx-dev-runtime.js\",`\n\n  `}`\n\n`}`\n\nThen in `jsx-runtime.d.ts` and `jsx-dev-runtime.d.ts`:\n\nts\n\n`export namespace JSX {`\n\n  `// …`\n\n`}`\n\nNote that while exporting the `JSX` namespace is sufficient for type checking, the production runtime needs the `jsx`, `jsxs`, and `Fragment` exports at runtime, and the development runtime needs `jsxDEV` and `Fragment`. Ideally you add types for those too.\n\nIf the `JSX` namespace isn’t available in the appropriate location, both the classic and the automatic runtime fall back to the global `JSX` namespace.\n\n### [](#intrinsic-elements)Intrinsic elements\n\nIntrinsic elements are looked up on the special interface `JSX.IntrinsicElements`. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface _is_ present, then the name of the intrinsic element is looked up as a property on the `JSX.IntrinsicElements` interface. For example:\n\ntsx\n\n`declare namespace JSX {`\n\n  `interface IntrinsicElements {`\n\n    `foo: any;`\n\n  `}`\n\n`}`\n\n`<foo />; // ok`\n\n`<bar />; // error`\n\nIn the above example, `<foo />` will work fine but `<bar />` will result in an error since it has not been specified on `JSX.IntrinsicElements`.\n\n> Note: You can also specify a catch-all string indexer on `JSX.IntrinsicElements` as follows:\n\nts\n\n`declare namespace JSX {`\n\n  `interface IntrinsicElements {`\n\n    `[elemName: string]: any;`\n\n  `}`\n\n`}`\n\n### [](#value-based-elements)Value-based elements\n\nValue-based elements are simply looked up by identifiers that are in scope.\n\ntsx\n\n`import MyComponent from \"./myComponent\";`\n\n`<MyComponent />; // ok`\n\n`<SomeOtherComponent />; // error`\n\nThere are two ways to define a value-based element:\n\n1.  Function Component (FC)\n2.  Class Component\n\nBecause these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.\n\n#### [](#function-component)Function Component\n\nAs the name suggests, the component is defined as a JavaScript function where its first argument is a `props` object. TS enforces that its return type must be assignable to `JSX.Element`.\n\ntsx\n\n`interface FooProp {`\n\n  `name: string;`\n\n  `X: number;`\n\n  `Y: number;`\n\n`}`\n\n`declare function AnotherComponent(prop: { name: string });`\n\n`function ComponentFoo(prop: FooProp) {`\n\n  `return <AnotherComponent name={prop.name} />;`\n\n`}`\n\n`const Button = (prop: { value: string }, context: { color: string }) => (`\n\n  `<button />`\n\n`);`\n\nBecause a Function Component is simply a JavaScript function, function overloads may be used here as well:\n\nts\n\n`interface ClickableProps {`\n\n  `children: JSX.Element[] | JSX.Element;`\n\n`}`\n\n`interface HomeProps extends ClickableProps {`\n\n  `home: JSX.Element;`\n\n`}`\n\n`interface SideProps extends ClickableProps {`\n\n  `side: JSX.Element | string;`\n\n`}`\n\n`function MainButton(prop: HomeProps): JSX.Element;`\n\n`function MainButton(prop: SideProps): JSX.Element;`\n\n`function MainButton(prop: ClickableProps): JSX.Element {`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABMCmBjANgIbxagC20GArniQFIDKAGqAN5qigCWkALlvADMCOErBqksvVgF92XXvyEjQASV7xuKTjjFYJvFKzkcA2igBcoFDw2QA5gF1LBSAE8A3HNmyQoALQBOJQ8AX5o3HyCwiQAwnjaANYEAEY0AApIAA6GbBw4ABaceBjEkJYMjAB0uvo8Jg6gAD6gFdXikjyesuEKUcoAEtASGdDZoFgAHnyQGIZxiSnpWTly+UNY5Uxteh1daD2RSiT0nNgjY5PTs6DzOEmpWOcrHFrYm1U1HU1WNtx2e2gBJRIDgeJxoJBQABZAjcABCwR4EIAFJkspZBsNlgBKd7bWqeIEgsEQ6GwyAInhIyCo9GgE5nHF4z68QnA0HgyEw+GIlFo0aWW73JajFC4lpbFk8IwcXyVeVoaRAA)\n\n> Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type `SFC` and its alias `StatelessComponent` were deprecated.\n\n#### [](#class-component)Class Component\n\nIt is possible to define the type of a class component. However, to do so it is best to understand two new terms: the _element class type_ and the _element instance type_.\n\nGiven `<Expr />`, the _element class type_ is the type of `Expr`. So in the example above, if `MyComponent` was an ES6 class the class type would be that class’s constructor and statics. If `MyComponent` was a factory function, the class type would be that function.\n\nOnce the class type is established, the instance type is determined by the union of the return types of the class type’s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.\n\nts\n\n`class MyComponent {`\n\n  `render() {}`\n\n`}`\n\n`// use a construct signature`\n\n`const myComponent = new MyComponent();`\n\n`// element class type => MyComponent`\n\n`// element instance type => { render: () => void }`\n\n`function MyFactoryFunction() {`\n\n  `return {`\n\n    `render: () => {},`\n\n  `};`\n\n`}`\n\n`// use a call signature`\n\n`const myComponent = MyFactoryFunction();`\n\n`// element class type => MyFactoryFunction`\n\n`// element instance type => { render: () => void }`\n\nThe element instance type is interesting because it must be assignable to `JSX.ElementClass` or it will result in an error. By default `JSX.ElementClass` is `{}`, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.\n\ntsx\n\n`declare namespace JSX {`\n\n  `interface ElementClass {`\n\n    `render: any;`\n\n  `}`\n\n`}`\n\n`class MyComponent {`\n\n  `render() {}`\n\n`}`\n\n`function MyFactoryFunction() {`\n\n  `return { render: () => {} };`\n\n`}`\n\n`<MyComponent />; // ok`\n\n`<MyFactoryFunction />; // ok`\n\n`class NotAValidComponent {}`\n\n`function NotAValidFactoryFunction() {`\n\n  `return {};`\n\n`}`\n\n`<NotAValidComponent />; // error`\n\n`<NotAValidFactoryFunction />; // error`\n\n### [](#attribute-type-checking)Attribute type checking\n\nThe first step to type checking attributes is to determine the _element attributes type_. This is slightly different between intrinsic and value-based elements.\n\nFor intrinsic elements, it is the type of the property on `JSX.IntrinsicElements`\n\ntsx\n\n`declare namespace JSX {`\n\n  `interface IntrinsicElements {`\n\n    `foo: { bar?: boolean };`\n\n  `}`\n\n`}`\n\n`// element attributes type for 'foo' is '{bar?: boolean}'`\n\n`<foo bar />;`\n\nFor value-based elements, it is a bit more complex. It is determined by the type of a property on the _element instance type_ that was previously determined. Which property to use is determined by `JSX.ElementAttributesProperty`. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if `JSX.ElementAttributesProperty` is not provided, the type of first parameter of the class element’s constructor or Function Component’s call will be used instead.\n\ntsx\n\n`declare namespace JSX {`\n\n  `interface ElementAttributesProperty {`\n\n    `props; // specify the property name to use`\n\n  `}`\n\n`}`\n\n`class MyComponent {`\n\n  `// specify the property on the element instance type`\n\n  `props: {`\n\n    `foo?: string;`\n\n  `};`\n\n`}`\n\n`// element attributes type for 'MyComponent' is '{foo?: string}'`\n\n`<MyComponent foo=\"bar\" />;`\n\nThe element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.\n\ntsx\n\n`declare namespace JSX {`\n\n  `interface IntrinsicElements {`\n\n    `foo: { requiredProp: string; optionalProp?: number };`\n\n  `}`\n\n`}`\n\n`<foo requiredProp=\"bar\" />; // ok`\n\n`<foo requiredProp=\"bar\" optionalProp={0} />; // ok`\n\n`<foo />; // error, requiredProp is missing`\n\n`<foo requiredProp={0} />; // error, requiredProp should be a string`\n\n`<foo requiredProp=\"bar\" unknownProp />; // error, unknownProp does not exist`\n\n`<foo requiredProp=\"bar\" some-unknown-prop />; // ok, because 'some-unknown-prop' is not a valid identifier`\n\n> Note: If an attribute name is not a valid JS identifier (like a `data-*` attribute), it is not considered to be an error if it is not found in the element attributes type.\n\nAdditionally, the `JSX.IntrinsicAttributes` interface can be used to specify extra properties used by the JSX framework which are not generally used by the components’ props or arguments - for instance `key` in React. Specializing further, the generic `JSX.IntrinsicClassAttributes<T>` type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the `ref` attribute of type `Ref<T>`. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.\n\nThe spread operator also works:\n\ntsx\n\n`const props = { requiredProp: \"bar\" };`\n\n`<foo {...props} />; // ok`\n\n`const badProps = {};`\n\n`<foo {...badProps} />; // error`\n\n### [](#children-type-checking)Children Type Checking\n\nIn TypeScript 2.3, TS introduced type checking of _children_. _children_ is a special property in an _element attributes type_ where child _JSXExpression_s are taken to be inserted into the attributes. Similar to how TS uses `JSX.ElementAttributesProperty` to determine the name of _props_, TS uses `JSX.ElementChildrenAttribute` to determine the name of _children_ within those props. `JSX.ElementChildrenAttribute` should be declared with a single property.\n\nts\n\n`declare namespace JSX {`\n\n  `interface ElementChildrenAttribute {`\n\n    `children: {}; // specify children name to use`\n\n  `}`\n\n`}`\n\ntsx\n\n`<div>`\n\n  `<h1>Hello</h1>`\n\n`</div>;`\n\n`<div>`\n\n  `<h1>Hello</h1>`\n\n  `World`\n\n`</div>;`\n\n`const CustomComp = (props) => <div>{props.children}</div>`\n\n`<CustomComp>`\n\n  `<div>Hello World</div>`\n\n  `{\"This is just a JS expression...\" + 1000}`\n\n`</CustomComp>`\n\nYou can specify the type of _children_ like any other attribute. This will override the default type from, e.g. the [React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react) if you use them.\n\ntsx\n\n`interface PropsType {`\n\n  `children: JSX.Element`\n\n  `name: string`\n\n`}`\n\n`class Component extends React.Component<PropsType, {}> {`\n\n  `render() {`\n\n    `return (`\n\n      `<h2>`\n\n        `{this.props.children}`\n\n      `</h2>`\n\n    `)`\n\n  `}`\n\n`}`\n\n`// OK`\n\n`<Component name=\"foo\">`\n\n  `<h1>Hello World</h1>`\n\n`</Component>`\n\n`// Error: children is of type JSX.Element not array of JSX.Element`\n\n`<Component name=\"bar\">`\n\n  `<h1>Hello World</h1>`\n\n  `<h2>Hello World</h2>`\n\n`</Component>`\n\n`// Error: children is of type JSX.Element not array of JSX.Element or string.`\n\n`<Component name=\"baz\">`\n\n  `<h1>Hello</h1>`\n\n  `World`\n\n`</Component>`\n\n## [](#the-jsx-result-type)The JSX result type\n\nBy default the result of a JSX expression is typed as `any`. You can customize the type by specifying the `JSX.Element` interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.\n\n## [](#the-jsx-function-return-type)The JSX function return type\n\nBy default, function components must return `JSX.Element | null`. However, this doesn’t always represent runtime behaviour. As of TypeScript 5.1, you can specify `JSX.ElementType` to override what is a valid JSX component type. Note that this doesn’t define what props are valid. The type of props is always defined by the first argument of the component that’s passed. The default looks something like this:\n\nts\n\n`namespace JSX {`\n\n    `export type ElementType =`\n\n        `// All the valid lowercase tags`\n\n        `keyof IntrinsicAttributes`\n\n        `// Function components`\n\n        `(props: any) => Element`\n\n        `// Class components`\n\n        `new (props: any) => ElementClass;`\n\n    `export interface IntrinsicAttributes extends /*...*/ {}`\n\n    `export type Element = /*...*/;`\n\n    `export type ElementClass = /*...*/;`\n\n`}`\n\n## [](#embedding-expressions)Embedding Expressions\n\nJSX allows you to embed expressions between tags by surrounding the expressions with curly braces (`{ }`).\n\ntsx\n\n`const a = (`\n\n  `<div>`\n\n    `{[\"foo\", \"bar\"].map((i) => (`\n\n      `<span>{i / 2}</span>`\n\n    `))}`\n\n  `</div>`\n\n`);`\n\nThe above code will result in an error since you cannot divide a string by a number. The output, when using the `preserve` option, looks like:\n\ntsx\n\n`const a = (`\n\n  `<div>`\n\n    `{[\"foo\", \"bar\"].map(function (i) {`\n\n      `return <span>{i / 2}</span>;`\n\n    `})}`\n\n  `</div>`\n\n`);`\n\n## [](#react-integration)React integration\n\nTo use JSX with React you should use the [React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react). These typings define the `JSX` namespace appropriately for use with React.\n\ntsx\n\n`/// <reference path=\"react.d.ts\" />`\n\n`interface Props {`\n\n  `foo: string;`\n\n`}`\n\n`class MyComponent extends React.Component<Props, {}> {`\n\n  `render() {`\n\n    `return <span>{this.props.foo}</span>;`\n\n  `}`\n\n`}`\n\n`<MyComponent foo=\"bar\" />; // ok`\n\n`<MyComponent foo={0} />; // error`\n\n### [](#configuring-jsx)Configuring JSX\n\nThere are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:\n\n*   [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n*   [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n*   [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)",
    "title": "TypeScript: Documentation - JSX",
    "description": "Using JSX with TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html",
    "markdown": "# TypeScript: Documentation - Namespaces and Modules\n\nThis post outlines the various ways to organize your code using modules and namespaces in TypeScript. We’ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.\n\nSee the [Modules](https://www.typescriptlang.org/docs/handbook/modules.html) documentation for more information about ES Modules. See the [Namespaces](https://www.typescriptlang.org/docs/handbook/namespaces.html) documentation for more information about TypeScript namespaces.\n\nNote: In _very_ old versions of TypeScript namespaces were called ‘Internal Modules’, these pre-date JavaScript module systems.\n\n## [](#using-modules)Using Modules\n\nModules can contain both code and declarations.\n\nModules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.\n\nIt is also worth noting that, for Node.js applications, modules are the default and **we recommended modules over namespaces in modern code**.\n\nStarting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.\n\n## [](#using-namespaces)Using Namespaces\n\nNamespaces are a TypeScript-specific way to organize code.  \nNamespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using [`outFile`](https://www.typescriptlang.org/tsconfig#outFile). Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as `<script>` tags in your HTML page.\n\nJust like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.\n\n## [](#pitfalls-of-namespaces-and-modules)Pitfalls of Namespaces and Modules\n\nIn this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them.\n\n### [](#-reference-ing-a-module)`/// <reference>`\\-ing a module\n\nA common mistake is to try to use the `/// <reference ... />` syntax to refer to a module file, rather than using an `import` statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an `import` (e.g. the `...` in `import x from \"...\";`, `import x = require(\"...\");`, etc.) path.\n\nThe compiler will try to find a `.ts`, `.tsx`, and then a `.d.ts` with the appropriate path. If a specific file could not be found, then the compiler will look for an _ambient module declaration_. Recall that these need to be declared in a `.d.ts` file.\n\n*   `myModules.d.ts`\n    \n    ts\n    \n    `// In a .d.ts file or .ts file that is not a module:`\n    \n    `declare module \"SomeModule\" {`\n    \n      `export function fn(): string;`\n    \n    `}`\n    \n*   `myOtherModule.ts`\n    \n    ts\n    \n    `/// <reference path=\"myModules.d.ts\" />`\n    \n    `import * as m from \"SomeModule\";`\n    \n\nThe reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the `node.d.ts` file that several of the TypeScript samples use is consumed.\n\n### [](#needless-namespacing)Needless Namespacing\n\nIf you’re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:\n\n*   `shapes.ts`\n    \n    ts\n    \n    `export namespace Shapes {`\n    \n      `export class Triangle {`\n    \n        `/* ... */`\n    \n      `}`\n    \n      `export class Square {`\n    \n        `/* ... */`\n    \n      `}`\n    \n    `}`\n    \n\nThe top-level namespace here `Shapes` wraps up `Triangle` and `Square` for no reason. This is confusing and annoying for consumers of your module:\n\n*   `shapeConsumer.ts`\n    \n    ts\n    \n    `import * as shapes from \"./shapes\";`\n    \n    `let t = new shapes.Shapes.Triangle(); // shapes.Shapes?`\n    \n\nA key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there’s no need to proactively wrap up the exported symbols in a namespace.\n\nTo reiterate why you shouldn’t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it’s unnecessary to use an additional module layer for exported objects.\n\nHere’s a revised example:\n\n*   `shapes.ts`\n    \n    ts\n    \n    `export class Triangle {`\n    \n      `/* ... */`\n    \n    `}`\n    \n    `export class Square {`\n    \n      `/* ... */`\n    \n    `}`\n    \n*   `shapeConsumer.ts`\n    \n    ts\n    \n    `import * as shapes from \"./shapes\";`\n    \n    `let t = new shapes.Triangle();`\n    \n\n### [](#trade-offs-of-modules)Trade-offs of Modules\n\nJust as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it’s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can’t use the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) option while targeting `commonjs` or `umd`, but with TypeScript 1.8 and later, [it’s possible](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile) to use [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) when targeting `amd` or `system`.",
    "title": "TypeScript: Documentation - Namespaces and Modules",
    "description": "How to organize code in TypeScript via modules or namespaces",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/namespaces.html",
    "markdown": "# TypeScript: Documentation - Namespaces\n\n> **A note about terminology:** It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with [ECMAScript 2015](https://www.ecma-international.org/ecma-262/6.0/)’s terminology, (namely that `module X {` is equivalent to the now-preferred `namespace X {`).\n\nThis post outlines the various ways to organize your code using namespaces (previously “internal modules”) in TypeScript. As we alluded in our note about terminology, “internal modules” are now referred to as “namespaces”. Additionally, anywhere the `module` keyword was used when declaring an internal module, the `namespace` keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.\n\n## [](#first-steps)First steps\n\nLet’s start with the program we’ll be using as our example throughout this page. We’ve written a small set of simplistic string validators, as you might write to check a user’s input on a form in a webpage or check the format of an externally-provided data file.\n\n## [](#validators-in-a-single-file)Validators in a single file\n\nts\n\n`interface StringValidator {`\n\n  `isAcceptable(s: string): boolean;`\n\n`}`\n\n`let lettersRegexp = /^[A-Za-z]+$/;`\n\n`let numberRegexp = /^[0-9]+$/;`\n\n`class LettersOnlyValidator implements StringValidator {`\n\n  `isAcceptable(s: string) {`\n\n    `return lettersRegexp.test(s);`\n\n  `}`\n\n`}`\n\n`class ZipCodeValidator implements StringValidator {`\n\n  `isAcceptable(s: string) {`\n\n    `return s.length === 5 && numberRegexp.test(s);`\n\n  `}`\n\n`}`\n\n`// Some samples to try`\n\n`let strings = [\"Hello\", \"98052\", \"101\"];`\n\n`// Validators to use`\n\n`let validators: { [s: string]: StringValidator } = {};`\n\n`validators[\"ZIP code\"] = new ZipCodeValidator();`\n\n`validators[\"Letters only\"] = new LettersOnlyValidator();`\n\n`// Show whether each string passed each validator`\n\n`for (let s of strings) {`\n\n  `for (let name in validators) {`\n\n    `let isMatch = validators[name].isAcceptable(s);`\n\n    ``console.log(`'${s}' ${isMatch ? \"matches\" : \"does not match\"} '${name}'.`);``\n\n  `}`\n\n`}`\n\n## [](#namespacing)Namespacing\n\nAs we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let’s wrap up our objects into a namespace.\n\nIn this example, we’ll move all validator-related entities into a namespace called `Validation`. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with `export`. Conversely, the variables `lettersRegexp` and `numberRegexp` are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. `Validation.LettersOnlyValidator`.\n\n## [](#namespaced-validators)Namespaced Validators\n\nts\n\n`namespace Validation {`\n\n  `export interface StringValidator {`\n\n    `isAcceptable(s: string): boolean;`\n\n  `}`\n\n  `const lettersRegexp = /^[A-Za-z]+$/;`\n\n  `const numberRegexp = /^[0-9]+$/;`\n\n  `export class LettersOnlyValidator implements StringValidator {`\n\n    `isAcceptable(s: string) {`\n\n      `return lettersRegexp.test(s);`\n\n    `}`\n\n  `}`\n\n  `export class ZipCodeValidator implements StringValidator {`\n\n    `isAcceptable(s: string) {`\n\n      `return s.length === 5 && numberRegexp.test(s);`\n\n    `}`\n\n  `}`\n\n`}`\n\n`// Some samples to try`\n\n`let strings = [\"Hello\", \"98052\", \"101\"];`\n\n`// Validators to use`\n\n`let validators: { [s: string]: Validation.StringValidator } = {};`\n\n`validators[\"ZIP code\"] = new Validation.ZipCodeValidator();`\n\n`validators[\"Letters only\"] = new Validation.LettersOnlyValidator();`\n\n`// Show whether each string passed each validator`\n\n`for (let s of strings) {`\n\n  `for (let name in validators) {`\n\n    `console.log(`\n\n      `` `\"${s}\" - ${ ``\n\n        `validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"`\n\n      `` } ${name}` ``\n\n    `);`\n\n  `}`\n\n`}`\n\n## [](#splitting-across-files)Splitting Across Files\n\nAs our application grows, we’ll want to split the code across multiple files to make it easier to maintain.\n\n## [](#multi-file-namespaces)Multi-file namespaces\n\nHere, we’ll split our `Validation` namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.\n\n##### [](#validationts)Validation.ts\n\nts\n\n`namespace Validation {`\n\n  `export interface StringValidator {`\n\n    `isAcceptable(s: string): boolean;`\n\n  `}`\n\n`}`\n\n##### [](#lettersonlyvalidatorts)LettersOnlyValidator.ts\n\nts\n\n`/// <reference path=\"Validation.ts\" />`\n\n`namespace Validation {`\n\n  `const lettersRegexp = /^[A-Za-z]+$/;`\n\n  `export class LettersOnlyValidator implements StringValidator {`\n\n    `isAcceptable(s: string) {`\n\n      `return lettersRegexp.test(s);`\n\n    `}`\n\n  `}`\n\n`}`\n\n##### [](#zipcodevalidatorts)ZipCodeValidator.ts\n\nts\n\n`/// <reference path=\"Validation.ts\" />`\n\n`namespace Validation {`\n\n  `const numberRegexp = /^[0-9]+$/;`\n\n  `export class ZipCodeValidator implements StringValidator {`\n\n    `isAcceptable(s: string) {`\n\n      `return s.length === 5 && numberRegexp.test(s);`\n\n    `}`\n\n  `}`\n\n`}`\n\n##### [](#testts)Test.ts\n\nts\n\n`/// <reference path=\"Validation.ts\" />`\n\n`/// <reference path=\"LettersOnlyValidator.ts\" />`\n\n`/// <reference path=\"ZipCodeValidator.ts\" />`\n\n`// Some samples to try`\n\n`let strings = [\"Hello\", \"98052\", \"101\"];`\n\n`// Validators to use`\n\n`let validators: { [s: string]: Validation.StringValidator } = {};`\n\n`validators[\"ZIP code\"] = new Validation.ZipCodeValidator();`\n\n`validators[\"Letters only\"] = new Validation.LettersOnlyValidator();`\n\n`// Show whether each string passed each validator`\n\n`for (let s of strings) {`\n\n  `for (let name in validators) {`\n\n    `console.log(`\n\n      `` `\"${s}\" - ${ ``\n\n        `validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"`\n\n      `` } ${name}` ``\n\n    `);`\n\n  `}`\n\n`}`\n\nOnce there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.\n\nFirst, we can use concatenated output using the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) option to compile all of the input files into a single JavaScript output file:\n\n`tsc --outFile sample.js Test.ts`\n\nThe compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:\n\n`tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts`\n\nAlternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we’ll need to use `<script>` tags on our webpage to load each emitted file in the appropriate order, for example:\n\n##### [](#mytestpagehtml-excerpt)MyTestPage.html (excerpt)\n\nhtml\n\n`<script src=\"Validation.js\" type=\"text/javascript\" />`\n\n`<script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />`\n\n`<script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />`\n\n`<script src=\"Test.js\" type=\"text/javascript\" />`\n\n## [](#aliases)Aliases\n\nAnother way that you can simplify working with namespaces is to use `import q = x.y.z` to create shorter names for commonly-used objects. Not to be confused with the `import x = require(\"name\")` syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.\n\nts\n\n`namespace Shapes {`\n\n  `export namespace Polygons {`\n\n    `export class Triangle {}`\n\n    `export class Square {}`\n\n  `}`\n\n`}`\n\n`import polygons = Shapes.Polygons;`\n\n`let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'`\n\nNotice that we don’t use the `require` keyword; instead we assign directly from the qualified name of the symbol we’re importing. This is similar to using `var`, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, `import` is a distinct reference from the original symbol, so changes to an aliased `var` will not be reflected in the original variable.\n\n## [](#working-with-other-javascript-libraries)Working with Other JavaScript Libraries\n\nTo describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.\n\nWe call declarations that don’t define an implementation “ambient”. Typically these are defined in `.d.ts` files. If you’re familiar with C/C++, you can think of these as `.h` files. Let’s look at a few examples.\n\n## [](#ambient-namespaces)Ambient Namespaces\n\nThe popular library D3 defines its functionality in a global object called `d3`. Because this library is loaded through a `<script>` tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:\n\n##### [](#d3dts-simplified-excerpt)D3.d.ts (simplified excerpt)\n\nts\n\n`declare namespace D3 {`\n\n  `export interface Selectors {`\n\n    `select: {`\n\n      `(selector: string): Selection;`\n\n      `(element: EventTarget): Selection;`\n\n    `};`\n\n  `}`\n\n  `export interface Event {`\n\n    `x: number;`\n\n    `y: number;`\n\n  `}`\n\n  `export interface Base extends Selectors {`\n\n    `event: Event;`\n\n  `}`\n\n`}`\n\n`declare var d3: D3.Base;`",
    "title": "TypeScript: Documentation - Namespaces",
    "description": "How TypeScript namespaces work",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/type-inference.html",
    "markdown": "# TypeScript: Documentation - Type Inference\n\nIn TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code\n\nts\n\n`let x = 3;`\n\n   `let x: number`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EGYDcAoA9GiEB6B+IA)\n\nThe type of the `x` variable is inferred to be `number`. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.\n\nIn most cases, type inference is straightforward. In the following sections, we’ll explore some of the nuances in how types are inferred.\n\n## [](#best-common-type)Best common type\n\nWhen a type inference is made from several expressions, the types of those expressions are used to calculate a “best common type”. For example,\n\nts\n\n`let x = [0, 1, null];`\n\n   `let x: (number | null)[]`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EG0AMAaCBGNA7ArsYAugNwBQA9GRBAHoD8QA)\n\nTo infer the type of `x` in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: `number` and `null`. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.\n\nBecause the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:\n\nts\n\n`let zoo = [new Rhino(), new Elephant(), new Snake()];`\n\n    `let zoo: (Rhino | Elephant | Snake)[]`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35BAF5QAG0qPAB3Ll4BAAoASgAaUE6e8ysbaCHR8cjo2KGAXQNixVAAPQB+IA)\n\nIdeally, we may want `zoo` to be inferred as an `Animal[]`, but because there is no object that is strictly of type `Animal` in the array, we make no inference about the array element type. To correct this, explicitly provide the type when no one type is a super type of all other candidates:\n\nts\n\n`let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];`\n\n    `let zoo: Animal[]`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35+NBlXAG0AXVAAXlA2qjwAdy5eAQAKAEoAGlAB4fMrG2hJmbnI6NjJjoNixVAAPQB+IA)\n\nWhen no best common type is found, the resulting inference is the union array type, `(Rhino | Elephant | Snake)[]`.\n\n## [](#contextual-typing)Contextual Typing\n\nType inference also works in “the other direction” in some cases in TypeScript. This is known as “contextual typing”. Contextual typing occurs when the type of an expression is implied by its location. For example:\n\nts\n\n`window.onmousedown = function (mouseEvent) {`\n\n  `console.log(mouseEvent.button);`\n\n  `console.log(mouseEvent.kangaroo);`\n\n`Property 'kangaroo' does not exist on type 'MouseEvent'.2339Property 'kangaroo' does not exist on type 'MouseEvent'.  };  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQB3ASwDsATOfAOjmIFs4BXRSc-Y0AXlADMHiBjAC6EaoABT0mkAKIA3SMUEBKUAG9coUPxqI4AG0iU9cAOYTGzOQsGUARg0GCaSgNwatO-YeNnJl+YqUANYAhsQmIfBwrrgAvi5AA)\n\nHere, the TypeScript type checker used the type of the `Window.onmousedown` function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the [type](https://developer.mozilla.org/docs/Web/API/MouseEvent) of the `mouseEvent` parameter, which does contain a `button` property, but not a `kangaroo` property.\n\nThis works because window already has `onmousedown` declared in its type:\n\nts\n\n`// Declares there is a global variable called 'window'`\n\n`declare var window: Window & typeof globalThis;`\n\n`// Which is declared as (simplified):`\n\n`interface Window extends GlobalEventHandlers {`\n\n  `// ...`\n\n`}`\n\n`// Which defines a lot of known handler events`\n\n`interface GlobalEventHandlers {`\n\n  `onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;`\n\n  `// ...`\n\n`}`\n\nTypeScript is smart enough to infer types in other contexts as well:\n\nts\n\n`window.onscroll = function (uiEvent) {`\n\n  `console.log(uiEvent.button);`\n\n`Property 'button' does not exist on type 'Event'.2339Property 'button' does not exist on type 'Event'.  };  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQB3ASwDsATOfAOjmMQGN4AbR0AXlADMBXYugF0I1QACi6EAogDdIxPgEpQAb1yhQdGojiNIlRnADmoidNmUARlz58acgNy4AvraA)\n\nBased on the fact that the above function is being assigned to `Window.onscroll`, TypeScript knows that `uiEvent` is a [UIEvent](https://developer.mozilla.org/docs/Web/API/UIEvent), and not a [MouseEvent](https://developer.mozilla.org/docs/Web/API/MouseEvent) like the previous example. `UIEvent` objects contain no `button` property, and so TypeScript will throw an error.\n\nIf this function were not in a contextually typed position, the function’s argument would implicitly have type `any`, and no error would be issued (unless you are using the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) option):\n\nts\n\n`const handler = function (uiEvent) {`\n\n  `console.log(uiEvent.button); // <- OK`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFDrSSVagAWZkAJstQE6gBeUgFdI6LKkagAFMNQBRAG7VIWAJSgA3rVCgGTaDwB0yaAHNZC5aqMAjYViyM1AblAhQAHgC0oAPIA0rQAvi5AA)\n\nWe can also explicitly give type information to the function’s argument to override any contextual type:\n\nts\n\n`window.onscroll = function (uiEvent: any) {`\n\n  `console.log(uiEvent.button); // <- Now, no error is given`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/O4SwdgJg9sB0VgM4GMBOUA2GAEBebAZgK5jIAuIC2AFESAKIBuApmGQFzYCGYAngJTYA3gChs2ZAkSZmsDFADmtBizawARkTJkE-ANzYA9IewAeALTYAcjAA02MFGzNU6VNhCJsCkKpEBfPSA)\n\nHowever, this code will log `undefined`, since `uiEvent` has no property called `button`.\n\nContextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:\n\nts\n\n`function createZoo(): Animal[] {`\n\n  `return [new Rhino(), new Elephant(), new Snake()];`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCdD9keH4qUERYPEwxAC1+fgAKAEo0GVcAbQBdd0U26G0NUBGqPAB3Ll4BAYAaUEWV8ysbaE3t5cjo2IGxg2YgA)\n\nIn this example, best common type has a set of four candidates: `Animal`, `Rhino`, `Elephant`, and `Snake`. Of these, `Animal` can be chosen by the best common type algorithm.",
    "title": "TypeScript: Documentation - Type Inference",
    "description": "How code flow analysis works in TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/symbols.html",
    "markdown": "# TypeScript: Documentation - Symbols\n\nStarting with ECMAScript 2015, `symbol` is a primitive data type, just like `number` and `string`.\n\n`symbol` values are created by calling the `Symbol` constructor.\n\nts\n\n`let sym1 = Symbol();`\n\n`let sym2 = Symbol(\"key\"); // optional string key`\n\nSymbols are immutable, and unique.\n\nts\n\n`let sym2 = Symbol(\"key\");`\n\n`let sym3 = Symbol(\"key\");`\n\n`sym2 === sym3; // false, symbols are unique`\n\nJust like strings, symbols can be used as keys for object properties.\n\nts\n\n`const sym = Symbol();`\n\n`let obj = {`\n\n  `[sym]: \"value\",`\n\n`};`\n\n`console.log(obj[sym]); // \"value\"`\n\nSymbols can also be combined with computed property declarations to declare object properties and class members.\n\nts\n\n`const getClassNameSymbol = Symbol();`\n\n`class C {`\n\n  `[getClassNameSymbol]() {`\n\n    `return \"C\";`\n\n  `}`\n\n`}`\n\n`let c = new C();`\n\n`let className = c[getClassNameSymbol](); // \"C\"`\n\n## [](#unique-symbol)`unique symbol`\n\nTo enable treating symbols as unique literals a special type `unique symbol` is available. `unique symbol` is a subtype of `symbol`, and are produced only from calling `Symbol()` or `Symbol.for()`, or from explicit type annotations. This type is only allowed on `const` declarations and `readonly static` properties, and in order to reference a specific unique symbol, you’ll have to use the `typeof` operator. Each reference to a unique symbol implies a completely unique identity that’s tied to a given declaration.\n\nts\n\n`declare const sym1: unique symbol;`\n\n`// sym2 can only be a constant reference.`\n\n`let sym2: unique symbol = Symbol();`\n\n`A variable whose type is a 'unique symbol' type must be 'const'.1332A variable whose type is a 'unique symbol' type must be 'const'.  // Works - refers to a unique symbol, but its identity is tied to 'sym1'.  let sym3: typeof sym1 = sym1;  // Also works.  class C {    static readonly StaticSymbol: unique symbol = Symbol();  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwGYMCYBQATSAYwBsBDaSUIuAO0QBdREBPAWzVQFdaBLARy5VWbAEZwSAbly4QzdtmplaoOiRahRVMtTqNlTSgDMYkWkUgA6XCUhMR2bn0HD24kqAC8oAMpuJABQAlNKyYADqCADWiKAAtKDGMLEMcKA6PAJC8mISADSaXEy8DLG8hLQMJRq8KbyQ+KCpoADkImgt1rb27BioDCwADpBwRjloXuOhcgCCJIhpAO7RiNakZIixAMKgAN64oMwMZFVEiZBk+GoaPsenfrkkTlmuj5MP7sHSAL5AA)\n\nBecause each `unique symbol` has a completely separate identity, no two `unique symbol` types are assignable or comparable to each other.\n\nts\n\n`const sym2 = Symbol();`\n\n`const sym3 = Symbol();`\n\n`if (sym2 === sym3) {`\n\n`This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.2367This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.    // ...  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqIgJ4C2aoAvKAMq0BGcANgBQCUA3IRLlKtDIxbsufQXgCWAM1DdqdRgyaqMvUAG88oUCFAA6M3gC+QA)\n\n## [](#well-known-symbols)Well-known Symbols\n\nIn addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.\n\nHere is a list of well-known symbols:\n\n### [](#symbolasynciterator)`Symbol.asyncIterator`\n\nA method that returns async iterator for an object, compatible to be used with for await..of loop.\n\n### [](#symbolhasinstance)`Symbol.hasInstance`\n\nA method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator.\n\n### [](#symbolisconcatspreadable)`Symbol.isConcatSpreadable`\n\nA Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.\n\n### [](#symboliterator)`Symbol.iterator`\n\nA method that returns the default iterator for an object. Called by the semantics of the for-of statement.\n\n### [](#symbolmatch)`Symbol.match`\n\nA regular expression method that matches the regular expression against a string. Called by the `String.prototype.match` method.\n\n### [](#symbolreplace)`Symbol.replace`\n\nA regular expression method that replaces matched substrings of a string. Called by the `String.prototype.replace` method.\n\n### [](#symbolsearch)`Symbol.search`\n\nA regular expression method that returns the index within a string that matches the regular expression. Called by the `String.prototype.search` method.\n\n### [](#symbolspecies)`Symbol.species`\n\nA function valued property that is the constructor function that is used to create derived objects.\n\n### [](#symbolsplit)`Symbol.split`\n\nA regular expression method that splits a string at the indices that match the regular expression. Called by the `String.prototype.split` method.\n\n### [](#symboltoprimitive)`Symbol.toPrimitive`\n\nA method that converts an object to a corresponding primitive value. Called by the `ToPrimitive` abstract operation.\n\n### [](#symboltostringtag)`Symbol.toStringTag`\n\nA String value that is used in the creation of the default string description of an object. Called by the built-in method `Object.prototype.toString`.\n\n### [](#symbolunscopables)`Symbol.unscopables`\n\nAn Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects.",
    "title": "TypeScript: Documentation - Symbols",
    "description": "Using the JavaScript Symbol primitive in TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html",
    "markdown": "# TypeScript: Documentation - Triple-Slash Directives\n\nTriple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.\n\nTriple-slash directives are **only** valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.\n\n## [](#-reference-path-)`/// <reference path=\"...\" />`\n\nThe `/// <reference path=\"...\" />` directive is the most common of this group. It serves as a declaration of _dependency_ between files.\n\nTriple-slash references instruct the compiler to include additional files in the compilation process.\n\nThey also serve as a method to order the output when using [`out`](https://www.typescriptlang.org/tsconfig#out) or [`outFile`](https://www.typescriptlang.org/tsconfig#outFile). Files are emitted to the output file location in the same order as the input after preprocessing pass.\n\n### [](#preprocessing-input-files)Preprocessing input files\n\nThe compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.\n\nThe process starts with a set of _root files_; these are the file names specified on the command-line or in the [`files`](https://www.typescriptlang.org/tsconfig#files) list in the `tsconfig.json` file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth-first manner, in the order they have been seen in the file.\n\nA triple-slash reference path is resolved relative to the containing file, if a relative path is used.\n\n### [](#errors)Errors\n\nIt is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.\n\n### [](#using---noresolve)Using `--noResolve`\n\nIf the compiler flag [`noResolve`](https://www.typescriptlang.org/tsconfig#noResolve) is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.\n\n## [](#-reference-types-)`/// <reference types=\"...\" />`\n\nSimilar to a `/// <reference path=\"...\" />` directive, which serves as a declaration of _dependency_, a `/// <reference types=\"...\" />` directive declares a dependency on a package.\n\nThe process of resolving these package names is similar to the process of resolving module names in an `import` statement. An easy way to think of triple-slash-reference-types directives are as an `import` for declaration packages.\n\nFor example, including `/// <reference types=\"node\" />` in a declaration file declares that this file uses names declared in `@types/node/index.d.ts`; and thus, this package needs to be included in the compilation along with the declaration file.\n\nUse these directives only when you’re authoring a `d.ts` file by hand.\n\nFor declaration files generated during compilation, the compiler will automatically add `/// <reference types=\"...\" />` for you; A `/// <reference types=\"...\" />` in a generated declaration file is added _if and only if_ the resulting file uses any declarations from the referenced package.\n\nFor declaring a dependency on an `@types` package in a `.ts` file, use [`types`](https://www.typescriptlang.org/tsconfig#types) on the command line or in your `tsconfig.json` instead. See [using `@types`, `typeRoots` and `types` in `tsconfig.json` files](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types) for more details.\n\n## [](#-reference-lib-)`/// <reference lib=\"...\" />`\n\nThis directive allows a file to explicitly include an existing built-in _lib_ file.\n\nBuilt-in _lib_ files are referenced in the same fashion as the [`lib`](https://www.typescriptlang.org/tsconfig#lib) compiler option in _tsconfig.json_ (e.g. use `lib=\"es2015\"` and not `lib=\"lib.es2015.d.ts\"`, etc.).\n\nFor declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like `Symbol` or `Iterable`, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.\n\nFor example, adding `/// <reference lib=\"es2017.string\" />` to one of the files in a compilation is equivalent to compiling with `--lib es2017.string`.\n\nts\n\n`/// <reference lib=\"es2017.string\" />`\n\n`\"foo\".padStart(4);`\n\n## [](#-reference-no-default-libtrue)`/// <reference no-default-lib=\"true\"/>`\n\nThis directive marks a file as a _default library_. You will see this comment at the top of `lib.d.ts` and its different variants.\n\nThis directive instructs the compiler to _not_ include the default library (i.e. `lib.d.ts`) in the compilation. The impact here is similar to passing [`noLib`](https://www.typescriptlang.org/tsconfig#noLib) on the command line.\n\nAlso note that when passing [`skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig#skipDefaultLibCheck), the compiler will only skip checking files with `/// <reference no-default-lib=\"true\"/>`.\n\n## [](#-amd-module-)`/// <amd-module />`\n\nBy default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. `r.js`).\n\nThe `amd-module` directive allows passing an optional module name to the compiler:\n\n##### [](#amdmodulets)amdModule.ts\n\nts\n\n`/// <amd-module name=\"NamedModule\"/>`\n\n`export class C {}`\n\nWill result in assigning the name `NamedModule` to the module as part of calling the AMD `define`:\n\n##### [](#amdmodulejs)amdModule.js\n\njs\n\n`define(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {`\n\n  `var C = (function () {`\n\n    `function C() {}`\n\n    `return C;`\n\n  `})();`\n\n  `exports.C = C;`\n\n`});`\n\n## [](#-amd-dependency-)`/// <amd-dependency />`\n\n> **Note**: this directive has been deprecated. Use `import \"moduleName\";` statements instead.\n\n`/// <amd-dependency path=\"x\" />` informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call.\n\nThe `amd-dependency` directive can also have an optional `name` property; this allows passing an optional name for an amd-dependency:\n\nts\n\n`/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>`\n\n`declare var moduleA: MyType;`\n\n`moduleA.callStuff();`\n\nGenerated JS code:\n\njs\n\n`define([\"require\", \"exports\", \"legacy/moduleA\"], function (`\n\n  `require,`\n\n  `exports,`\n\n  `moduleA`\n\n`) {`\n\n  `moduleA.callStuff();`\n\n`});`",
    "title": "TypeScript: Documentation - Triple-Slash Directives",
    "description": "How to use triple slash directives in TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/variable-declarations.html",
    "markdown": "# TypeScript: Documentation - Variable Declaration\n\n`let` and `const` are two relatively new concepts for variable declarations in JavaScript. [As we mentioned earlier](https://www.typescriptlang.org/docs/handbook/basic-types.html#a-note-about-let), `let` is similar to `var` in some respects, but allows users to avoid some of the common “gotchas” that users run into in JavaScript.\n\n`const` is an augmentation of `let` in that it prevents re-assignment to a variable.\n\nWith TypeScript being an extension of JavaScript, the language naturally supports `let` and `const`. Here we’ll elaborate more on these new declarations and why they’re preferable to `var`.\n\nIf you’ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you’re intimately familiar with all the quirks of `var` declarations in JavaScript, you might find it easier to skip ahead.\n\n## [](#var-declarations)`var` declarations\n\nDeclaring a variable in JavaScript has always traditionally been done with the `var` keyword.\n\nts\n\n`var a = 10;`\n\nAs you might’ve figured out, we just declared a variable named `a` with the value `10`.\n\nWe can also declare a variable inside of a function:\n\nts\n\n`function f() {`\n\n  `var message = \"Hello, world!\";`\n\n  `return message;`\n\n`}`\n\nand we can also access those same variables within other functions:\n\nts\n\n`function f() {`\n\n  `var a = 10;`\n\n  `return function g() {`\n\n    `var b = a + 1;`\n\n    `return b;`\n\n  `};`\n\n`}`\n\n`var g = f();`\n\n`g(); // returns '11'`\n\nIn this above example, `g` captured the variable `a` declared in `f`. At any point that `g` gets called, the value of `a` will be tied to the value of `a` in `f`. Even if `g` is called once `f` is done running, it will be able to access and modify `a`.\n\nts\n\n`function f() {`\n\n  `var a = 1;`\n\n  `a = 2;`\n\n  `var b = g();`\n\n  `a = 3;`\n\n  `return b;`\n\n  `function g() {`\n\n    `return a;`\n\n  `}`\n\n`}`\n\n`f(); // returns '2'`\n\n### [](#scoping-rules)Scoping rules\n\n`var` declarations have some odd scoping rules for those used to other languages. Take the following example:\n\nts\n\n`function f(shouldInitialize: boolean) {`\n\n  `if (shouldInitialize) {`\n\n    `var x = 10;`\n\n  `}`\n\n  `return x;`\n\n`}`\n\n`f(true); // returns '10'`\n\n`f(false); // returns 'undefined'`\n\nSome readers might do a double-take at this example. The variable `x` was declared _within the `if` block_, and yet we were able to access it from outside that block. That’s because `var` declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block. Some people call this _`var`\\-scoping_ or _function-scoping_. Parameters are also function scoped.\n\nThese scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:\n\nts\n\n`function sumMatrix(matrix: number[][]) {`\n\n  `var sum = 0;`\n\n  `for (var i = 0; i < matrix.length; i++) {`\n\n    `var currentRow = matrix[i];`\n\n    `for (var i = 0; i < currentRow.length; i++) {`\n\n      `sum += currentRow[i];`\n\n    `}`\n\n  `}`\n\n  `return sum;`\n\n`}`\n\nMaybe it was easy to spot out for some experienced JavaScript developers, but the inner `for`\\-loop will accidentally overwrite the variable `i` because `i` refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.\n\n### [](#variable-capturing-quirks)Variable capturing quirks\n\nTake a quick second to guess what the output of the following snippet is:\n\nts\n\n`for (var i = 0; i < 10; i++) {`\n\n  `setTimeout(function () {`\n\n    `console.log(i);`\n\n  `}, 100 * i);`\n\n`}`\n\nFor those unfamiliar, `setTimeout` will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).\n\nReady? Take a look:\n\n`10`\n\n`10`\n\n`10`\n\n`10`\n\n`10`\n\n`10`\n\n`10`\n\n`10`\n\n`10`\n\n`10`\n\nMany JavaScript developers are intimately familiar with this behavior, but if you’re surprised, you’re certainly not alone. Most people expect the output to be\n\n`0`\n\n`1`\n\n`2`\n\n`3`\n\n`4`\n\n`5`\n\n`6`\n\n`7`\n\n`8`\n\n`9`\n\nRemember what we mentioned earlier about variable capturing? Every function expression we pass to `setTimeout` actually refers to the same `i` from the same scope.\n\nLet’s take a minute to consider what that means. `setTimeout` will run a function after some number of milliseconds, _but only_ after the `for` loop has stopped executing; By the time the `for` loop has stopped executing, the value of `i` is `10`. So each time the given function gets called, it will print out `10`!\n\nA common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture `i` at each iteration:\n\nts\n\n`for (var i = 0; i < 10; i++) {`\n\n  `// capture the current state of 'i'`\n\n  `// by invoking a function with its current value`\n\n  `(function (i) {`\n\n    `setTimeout(function () {`\n\n      `console.log(i);`\n\n    `}, 100 * i);`\n\n  `})(i);`\n\n`}`\n\nThis odd-looking pattern is actually pretty common. The `i` in the parameter list actually shadows the `i` declared in the `for` loop, but since we named them the same, we didn’t have to modify the loop body too much.\n\n## [](#let-declarations)`let` declarations\n\nBy now you’ve figured out that `var` has some problems, which is precisely why `let` statements were introduced. Apart from the keyword used, `let` statements are written the same way `var` statements are.\n\nts\n\n`let hello = \"Hello!\";`\n\nThe key difference is not in the syntax, but in the semantics, which we’ll now dive into.\n\n### [](#block-scoping)Block-scoping\n\nWhen a variable is declared using `let`, it uses what some call _lexical-scoping_ or _block-scoping_. Unlike variables declared with `var` whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or `for`\\-loop.\n\nts\n\n`function f(input: boolean) {`\n\n  `let a = 100;`\n\n  `if (input) {`\n\n    `// Still okay to reference 'a'`\n\n    `let b = a + 1;`\n\n    `return b;`\n\n  `}`\n\n  `// Error: 'b' doesn't exist here`\n\n  `return b;`\n\n`}`\n\nHere, we have two local variables `a` and `b`. `a`’s scope is limited to the body of `f` while `b`’s scope is limited to the containing `if` statement’s block.\n\nVariables declared in a `catch` clause also have similar scoping rules.\n\nts\n\n`try {`\n\n  `throw \"oh no!\";`\n\n`} catch (e) {`\n\n  `console.log(\"Oh well.\");`\n\n`}`\n\n`// Error: 'e' doesn't exist here`\n\n`console.log(e);`\n\nAnother property of block-scoped variables is that they can’t be read or written to before they’re actually declared. While these variables are “present” throughout their scope, all points up until their declaration are part of their _temporal dead zone_. This is just a sophisticated way of saying you can’t access them before the `let` statement, and luckily TypeScript will let you know that.\n\nts\n\n`a++; // illegal to use 'a' before it's declared;`\n\n`let a;`\n\nSomething to note is that you can still _capture_ a block-scoped variable before it’s declared. The only catch is that it’s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won’t report this as an error.\n\nts\n\n`function foo() {`\n\n  `// okay to capture 'a'`\n\n  `return a;`\n\n`}`\n\n`// illegal call 'foo' before 'a' is declared`\n\n`// runtimes should throw an error here`\n\n`foo();`\n\n`let a;`\n\nFor more information on temporal dead zones, see relevant content on the [Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).\n\n### [](#re-declarations-and-shadowing)Re-declarations and Shadowing\n\nWith `var` declarations, we mentioned that it didn’t matter how many times you declared your variables; you just got one.\n\nts\n\n`function f(x) {`\n\n  `var x;`\n\n  `var x;`\n\n  `if (true) {`\n\n    `var x;`\n\n  `}`\n\n`}`\n\nIn the above example, all declarations of `x` actually refer to the _same_ `x`, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, `let` declarations are not as forgiving.\n\nts\n\n`let x = 10;`\n\n`let x = 20; // error: can't re-declare 'x' in the same scope`\n\nThe variables don’t necessarily need to both be block-scoped for TypeScript to tell us that there’s a problem.\n\nts\n\n`function f(x) {`\n\n  `let x = 100; // error: interferes with parameter declaration`\n\n`}`\n\n`function g() {`\n\n  `let x = 100;`\n\n  `var x = 100; // error: can't have both declarations of 'x'`\n\n`}`\n\nThat’s not to say that a block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.\n\nts\n\n`function f(condition, x) {`\n\n  `if (condition) {`\n\n    `let x = 100;`\n\n    `return x;`\n\n  `}`\n\n  `return x;`\n\n`}`\n\n`f(false, 0); // returns '0'`\n\n`f(true, 0); // returns '100'`\n\nThe act of introducing a new name in a more nested scope is called _shadowing_. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier `sumMatrix` function using `let` variables.\n\nts\n\n`function sumMatrix(matrix: number[][]) {`\n\n  `let sum = 0;`\n\n  `for (let i = 0; i < matrix.length; i++) {`\n\n    `var currentRow = matrix[i];`\n\n    `for (let i = 0; i < currentRow.length; i++) {`\n\n      `sum += currentRow[i];`\n\n    `}`\n\n  `}`\n\n  `return sum;`\n\n`}`\n\nThis version of the loop will actually perform the summation correctly because the inner loop’s `i` shadows `i` from the outer loop.\n\nShadowing should _usually_ be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.\n\n### [](#block-scoped-variable-capturing)Block-scoped variable capturing\n\nWhen we first touched on the idea of variable capturing with `var` declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an “environment” of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.\n\nts\n\n`function theCityThatAlwaysSleeps() {`\n\n  `let getCity;`\n\n  `if (true) {`\n\n    `let city = \"Seattle\";`\n\n    `getCity = function () {`\n\n      `return city;`\n\n    `};`\n\n  `}`\n\n  `return getCity();`\n\n`}`\n\nBecause we’ve captured `city` from within its environment, we’re still able to access it despite the fact that the `if` block finished executing.\n\nRecall that with our earlier `setTimeout` example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the `for` loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript.\n\n`let` declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope _per iteration_. Since this is what we were doing anyway with our IIFE, we can change our old `setTimeout` example to just use a `let` declaration.\n\nts\n\n`for (let i = 0; i < 10; i++) {`\n\n  `setTimeout(function () {`\n\n    `console.log(i);`\n\n  `}, 100 * i);`\n\n`}`\n\nand as expected, this will print out\n\n`0`\n\n`1`\n\n`2`\n\n`3`\n\n`4`\n\n`5`\n\n`6`\n\n`7`\n\n`8`\n\n`9`\n\n## [](#const-declarations)`const` declarations\n\n`const` declarations are another way of declaring variables.\n\nts\n\n`const numLivesForCat = 9;`\n\nThey are like `let` declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as `let`, but you can’t re-assign to them.\n\nThis should not be confused with the idea that the values they refer to are _immutable_.\n\nts\n\n`const numLivesForCat = 9;`\n\n`const kitty = {`\n\n  `name: \"Aurora\",`\n\n  `numLives: numLivesForCat,`\n\n`};`\n\n`// Error`\n\n`kitty = {`\n\n  `name: \"Danielle\",`\n\n  `numLives: numLivesForCat,`\n\n`};`\n\n`// all \"okay\"`\n\n`kitty.name = \"Rory\";`\n\n`kitty.name = \"Kitty\";`\n\n`kitty.name = \"Cat\";`\n\n`kitty.numLives--;`\n\nUnless you take specific measures to avoid it, the internal state of a `const` variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are `readonly`. The [chapter on Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html) has the details.\n\n## [](#let-vs-const)`let` vs. `const`\n\nGiven that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.\n\nApplying the [principle of least privilege](https://wikipedia.org/wiki/Principle_of_least_privilege), all declarations other than those you plan to modify should use `const`. The rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using `const` also makes code more predictable when reasoning about flow of data.\n\nUse your best judgement, and if applicable, consult the matter with the rest of your team.\n\nThe majority of this handbook uses `let` declarations.\n\n## [](#destructuring)Destructuring\n\nAnother ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see [the article on the Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment). In this section, we’ll give a short overview.\n\n### [](#array-destructuring)Array destructuring\n\nThe simplest form of destructuring is array destructuring assignment:\n\nts\n\n`let input = [1, 2];`\n\n`let [first, second] = input;`\n\n`console.log(first); // outputs 1`\n\n`console.log(second); // outputs 2`\n\nThis creates two new variables named `first` and `second`. This is equivalent to using indexing, but is much more convenient:\n\nts\n\n`first = input[0];`\n\n`second = input[1];`\n\nDestructuring works with already-declared variables as well:\n\nts\n\n`// swap variables`\n\n`[first, second] = [second, first];`\n\nAnd with parameters to a function:\n\nts\n\n`function f([first, second]: [number, number]) {`\n\n  `console.log(first);`\n\n  `console.log(second);`\n\n`}`\n\n`f([1, 2]);`\n\nYou can create a variable for the remaining items in a list using the syntax `...`:\n\nts\n\n`let [first, ...rest] = [1, 2, 3, 4];`\n\n`console.log(first); // outputs 1`\n\n`console.log(rest); // outputs [ 2, 3, 4 ]`\n\nOf course, since this is JavaScript, you can just ignore trailing elements you don’t care about:\n\nts\n\n`let [first] = [1, 2, 3, 4];`\n\n`console.log(first); // outputs 1`\n\nOr other elements:\n\nts\n\n`let [, second, , fourth] = [1, 2, 3, 4];`\n\n`console.log(second); // outputs 2`\n\n`console.log(fourth); // outputs 4`\n\n### [](#tuple-destructuring)Tuple destructuring\n\nTuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:\n\nts\n\n`let tuple: [number, string, boolean] = [7, \"hello\", true];`\n\n`let [a, b, c] = tuple; // a: number, b: string, c: boolean`\n\nIt’s an error to destructure a tuple beyond the range of its elements:\n\nts\n\n`let [a, b, c, d] = tuple; // Error, no element at index 3`\n\nAs with arrays, you can destructure the rest of the tuple with `...`, to get a shorter tuple:\n\nts\n\n`let [a, ...bc] = tuple; // bc: [string, boolean]`\n\n`let [a, b, c, ...d] = tuple; // d: [], the empty tuple`\n\nOr ignore trailing elements, or other elements:\n\nts\n\n`let [a] = tuple; // a: number`\n\n`let [, b] = tuple; // b: string`\n\n### [](#object-destructuring)Object destructuring\n\nYou can also destructure objects:\n\nts\n\n`let o = {`\n\n  `a: \"foo\",`\n\n  `b: 12,`\n\n  `c: \"bar\",`\n\n`};`\n\n`let { a, b } = o;`\n\nThis creates new variables `a` and `b` from `o.a` and `o.b`. Notice that you can skip `c` if you don’t need it.\n\nLike array destructuring, you can have assignment without declaration:\n\nts\n\n`({ a, b } = { a: \"baz\", b: 101 });`\n\nNotice that we had to surround this statement with parentheses. JavaScript normally parses a `{` as the start of block.\n\nYou can create a variable for the remaining items in an object using the syntax `...`:\n\nts\n\n`let { a, ...passthrough } = o;`\n\n`let total = passthrough.b + passthrough.c.length;`\n\n#### [](#property-renaming)Property renaming\n\nYou can also give different names to properties:\n\nts\n\n`let { a: newName1, b: newName2 } = o;`\n\nHere the syntax starts to get confusing. You can read `a: newName1` as ”`a` as `newName1`”. The direction is left-to-right, as if you had written:\n\nts\n\n`let newName1 = o.a;`\n\n`let newName2 = o.b;`\n\nConfusingly, the colon here does _not_ indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:\n\nts\n\n`let { a: newName1, b: newName2 }: { a: string; b: number } = o;`\n\n#### [](#default-values)Default values\n\nDefault values let you specify a default value in case a property is undefined:\n\nts\n\n`function keepWholeObject(wholeObject: { a: string; b?: number }) {`\n\n  `let { a, b = 1001 } = wholeObject;`\n\n`}`\n\nIn this example the `b?` indicates that `b` is optional, so it may be `undefined`. `keepWholeObject` now has a variable for `wholeObject` as well as the properties `a` and `b`, even if `b` is undefined.\n\n## [](#function-declarations)Function declarations\n\nDestructuring also works in function declarations. For simple cases this is straightforward:\n\nts\n\n`type C = { a: string; b?: number };`\n\n`function f({ a, b }: C): void {`\n\n  `// ...`\n\n`}`\n\nBut specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.\n\nts\n\n`function f({ a = \"\", b = 0 } = {}): void {`\n\n  `// ...`\n\n`}`\n\n`f();`\n\n> The snippet above is an example of type inference, explained earlier in the handbook.\n\nThen, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that `C` was defined with `b` optional:\n\nts\n\n`function f({ a, b = 0 } = { a: \"\" }): void {`\n\n  `// ...`\n\n`}`\n\n`f({ a: \"yes\" }); // ok, default b = 0`\n\n`f(); // ok, default to { a: \"\" }, which then defaults b = 0`\n\n`f({}); // error, 'a' is required if you supply an argument`\n\nUse destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets _really_ hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.\n\n## [](#spread)Spread\n\nThe spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:\n\nts\n\n`let first = [1, 2];`\n\n`let second = [3, 4];`\n\n`let bothPlus = [0, ...first, ...second, 5];`\n\nThis gives bothPlus the value `[0, 1, 2, 3, 4, 5]`. Spreading creates a shallow copy of `first` and `second`. They are not changed by the spread.\n\nYou can also spread objects:\n\nts\n\n`let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };`\n\n`let search = { ...defaults, food: \"rich\" };`\n\nNow `search` is `{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }`. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:\n\nts\n\n`let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };`\n\n`let search = { food: \"rich\", ...defaults };`\n\nThen the `food` property in `defaults` overwrites `food: \"rich\"`, which is not what we want in this case.\n\nObject spread also has a couple of other surprising limits. First, it only includes an objects’ [own, enumerable properties](https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties). Basically, that means you lose methods when you spread instances of an object:\n\nts\n\n`class C {`\n\n  `p = 12;`\n\n  `m() {}`\n\n`}`\n\n`let c = new C();`\n\n`let clone = { ...c };`\n\n`clone.p; // ok`\n\n`clone.m(); // error!`\n\nSecond, the TypeScript compiler doesn’t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.\n\n## [](#using-declarations)`using` declarations\n\n`using` declarations are an upcoming feature for JavaScript that are part of the [Stage 3 Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management) proposal. A `using` declaration is much like a `const` declaration, except that it couples the _lifetime_ of the value bound to the declaration with the _scope_ of the variable.\n\nWhen control exits the block containing a `using` declaration, the `[Symbol.dispose]()` method of the declared value is executed, which allows that value to perform cleanup:\n\nts\n\n`function f() {`\n\n  `using x = new C();`\n\n  `doSomethingWith(x);`\n\n``} // `x[Symbol.dispose]()` is called``\n\nAt runtime, this has an effect _roughly_ equivalent to the following:\n\nts\n\n`function f() {`\n\n  `const x = new C();`\n\n  `try {`\n\n    `doSomethingWith(x);`\n\n  `}`\n\n  `finally {`\n\n    `x[Symbol.dispose]();`\n\n  `}`\n\n`}`\n\n`using` declarations are extremely useful for avoiding memory leaks when working with JavaScript objects that hold on to native references like file handles\n\nts\n\n`{`\n\n  `using file = await openFile();`\n\n  `file.write(text);`\n\n  `doSomethingThatMayThrow();`\n\n``} // `file` is disposed, even if an error is thrown``\n\nor scoped operations like tracing\n\nts\n\n`function f() {`\n\n  `using activity = new TraceActivity(\"f\"); // traces entry into function`\n\n  `// ...`\n\n`} // traces exit of function`\n\nUnlike `var`, `let`, and `const`, `using` declarations do not support destructuring.\n\n### [](#null-and-undefined)`null` and `undefined`\n\nIt’s important to note that the value can be `null` or `undefined`, in which case nothing is disposed at the end of the block:\n\nts\n\n`{`\n\n  `using x = b ? new C() : null;`\n\n  `// ...`\n\n`}`\n\nwhich is _roughly_ equivalent to:\n\nts\n\n`{`\n\n  `const x = b ? new C() : null;`\n\n  `try {`\n\n    `// ...`\n\n  `}`\n\n  `finally {`\n\n    `x?.[Symbol.dispose]();`\n\n  `}`\n\n`}`\n\nThis allows you to conditionally acquire resources when declaring a `using` declaration without the need for complex branching or repetition.\n\n### [](#defining-a-disposable-resource)Defining a disposable resource\n\nYou can indicate the classes or objects you produce are disposable by implementing the `Disposable` interface:\n\nts\n\n`// from the default lib:`\n\n`interface Disposable {`\n\n  `[Symbol.dispose](): void;`\n\n`}`\n\n`// usage:`\n\n`class TraceActivity implements Disposable {`\n\n  `readonly name: string;`\n\n  `constructor(name: string) {`\n\n    `this.name = name;`\n\n    ``console.log(`Entering: ${name}`);``\n\n  `}`\n\n  `[Symbol.dispose](): void {`\n\n    ``console.log(`Exiting: ${name}`);``\n\n  `}`\n\n`}`\n\n`function f() {`\n\n  `using _activity = new TraceActivity(\"f\");`\n\n  `console.log(\"Hello world!\");`\n\n`}`\n\n`f();`\n\n`// prints:`\n\n`//   Entering: f`\n\n`//   Hello world!`\n\n`//   Exiting: f`\n\n## [](#await-using-declarations)`await using` declarations\n\nSome resources or operations may have cleanup that needs to be performed asynchronously. To accommodate this, the [Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management) proposal also introduces the `await using` declaration:\n\nts\n\n`async function f() {`\n\n  `await using x = new C();`\n\n``} // `await x[Symbol.asyncDispose]()` is invoked``\n\nAn `await using` declaration invokes, and _awaits_, its value’s `[Symbol.asyncDispose]()` method as control leaves the containing block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit, or a file stream flushing any pending writes to storage before it is closed.\n\nAs with `await`, `await using` can only be used in an `async` function or method, or at the top level of a module.\n\n### [](#defining-an-asynchronously-disposable-resource)Defining an asynchronously disposable resource\n\nJust as `using` relies on objects that are `Disposable`, an `await using` relies on objects that are `AsyncDisposable`:\n\nts\n\n`// from the default lib:`\n\n`interface AsyncDisposable {`\n\n  `[Symbol.asyncDispose]: PromiseLike<void>;`\n\n`}`\n\n`// usage:`\n\n`class DatabaseTransaction implements AsyncDisposable {`\n\n  `public success = false;`\n\n  `private db: Database | undefined;`\n\n  `private constructor(db: Database) {`\n\n    `this.db = db;`\n\n  `}`\n\n  `static async create(db: Database) {`\n\n    `await db.execAsync(\"BEGIN TRANSACTION\");`\n\n    `return new DatabaseTransaction(db);`\n\n  `}`\n\n  `async [Symbol.asyncDispose]() {`\n\n    `if (this.db) {`\n\n      `const db = this.db:`\n\n      `this.db = undefined;`\n\n      `if (this.success) {`\n\n        `await db.execAsync(\"COMMIT TRANSACTION\");`\n\n      `}`\n\n      `else {`\n\n        `await db.execAsync(\"ROLLBACK TRANSACTION\");`\n\n      `}`\n\n    `}`\n\n  `}`\n\n`}`\n\n`async function transfer(db: Database, account1: Account, account2: Account, amount: number) {`\n\n  `using tx = await DatabaseTransaction.create(db);`\n\n  `if (await debitAccount(db, account1, amount)) {`\n\n    `await creditAccount(db, account2, amount);`\n\n  `}`\n\n  `// if an exception is thrown before this line, the transaction will roll back`\n\n  `tx.success = true;`\n\n  `// now the transaction will commit`\n\n`}`\n\n### [](#await-using-vs-await)`await using` vs `await`\n\nThe `await` keyword that is part of the `await using` declaration only indicates that the _disposal_ of the resource is `await`\\-ed. It does _not_ `await` the value itself:\n\nts\n\n`{`\n\n  `await using x = getResourceSynchronously();`\n\n`` } // performs `await x[Symbol.asyncDispose]()` ``\n\n`{`\n\n  `await using y = await getResourceAsynchronously();`\n\n`` } // performs `await y[Symbol.asyncDispose]()` ``\n\n### [](#await-using-and-return)`await using` and `return`\n\nIt’s important to note that there is a small caveat with this behavior if you are using an `await using` declaration in an `async` function that returns a `Promise` without first `await`\\-ing it:\n\nts\n\n`function g() {`\n\n  `return Promise.reject(\"error!\");`\n\n`}`\n\n`async function f() {`\n\n  `await using x = new C();`\n\n  `` return g(); // missing an `await` ``\n\n`}`\n\nBecause the returned promise isn’t `await`\\-ed, it’s possible that the JavaScript runtime may report an unhandled rejection since execution pauses while `await`\\-ing the asynchronous disposal of `x`, without having subscribed to the returned promise. This is not a problem that is unique to `await using`, however, as this can also occur in an `async` function that uses `try..finally`:\n\nts\n\n`async function f() {`\n\n  `try {`\n\n    `return g(); // also reports an unhandled rejection`\n\n  `}`\n\n  `finally {`\n\n    `await somethingElse();`\n\n  `}`\n\n`}`\n\nTo avoid this situation, it is recommended that you `await` your return value if it may be a `Promise`:\n\nts\n\n`async function f() {`\n\n  `await using x = new C();`\n\n  `return await g();`\n\n`}`\n\n## [](#using-and-await-using-in-for-and-forof-statements)`using` and `await using` in `for` and `for..of` statements\n\nBoth `using` and `await using` can be used in a `for` statement:\n\nts\n\n`for (using x = getReader(); !x.eof; x.next()) {`\n\n  `// ...`\n\n`}`\n\nIn this case, the lifetime of `x` is scoped to the entire `for` statement and is only disposed when control leaves the loop due to `break`, `return`, `throw`, or when the loop condition is false.\n\nIn addition to `for` statements, both declarations can also be used in `for..of` statements:\n\nts\n\n`function * g() {`\n\n  `yield createResource1();`\n\n  `yield createResource2();`\n\n`}`\n\n`for (using x of g()) {`\n\n  `// ...`\n\n`}`\n\nHere, `x` is disposed at the end of _each iteration of the loop_, and is then reinitialized with the next value. This is especially useful when consuming resources produced one at a time by a generator.\n\n## [](#using-and-await-using-in-older-runtimes)`using` and `await using` in older runtimes\n\n`using` and `await using` declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for `Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in recent editions of NodeJS.",
    "title": "TypeScript: Documentation - Variable Declaration",
    "description": "How TypeScript handles variable declaration",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/modules/introduction.html",
    "markdown": "# TypeScript: Documentation - Modules - Introduction\n\nThis document is divided into four sections:\n\n1.  The first section develops the [**theory**](https://www.typescriptlang.org/docs/handbook/modules/theory.html) behind how TypeScript approaches modules. If you want to be able to write the correct module-related compiler options for any situation, reason about how to integrate TypeScript with other tools, or understand how TypeScript processes dependency packages, this is the place to start. While there are guides and reference pages on these topics, building an understanding of these fundamentals will make reading the guides easier, and give you a mental framework for dealing with real-world problems not specifically covered here.\n2.  The [**guides**](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html) show how to accomplish specific real-world tasks, starting with picking the right compilation settings for a new project. The guides are a good place to start both for beginners who want to get up and running as quickly as possible and for experts who already have a good grasp of the theory but want concrete guidance on a complicated task.\n3.  The [**reference**](https://www.typescriptlang.org/docs/handbook/modules/reference.html) section provides a more detailed look at the syntaxes and configurations presented in previous sections.\n4.  The [**appendices**](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html) cover complicated topics that deserve additional explanation in more detail than the theory or reference sections allow.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/modules-reference/Introduction.md) ❤\n\nContributors to this page:\n\nAB![Andrew Branch  (6)](https://gravatar.com/avatar/a5e386fec316551b6b8313a14995bdcb?s=32&&d=blank)\n\nLast updated: Jul 11, 2024",
    "title": "TypeScript: Documentation - Modules - Introduction",
    "description": "How TypeScript models JavaScript modules",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/type-compatibility.html",
    "markdown": "# TypeScript: Documentation - Type Compatibility\n\nType compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:\n\nts\n\n`interface Pet {`\n\n  `name: string;`\n\n`}`\n\n`class Dog {`\n\n  `name: string;`\n\n`}`\n\n`let pet: Pet;`\n\n`// OK, because of structural typing`\n\n`pet = new Dog();`\n\nIn nominally-typed languages like C# or Java, the equivalent code would be an error because the `Dog` class does not explicitly describe itself as being an implementer of the `Pet` interface.\n\nTypeScript’s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it’s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.\n\n## [](#a-note-on-soundness)A Note on Soundness\n\nTypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them.\n\n## [](#starting-out)Starting out\n\nThe basic rule for TypeScript’s structural type system is that `x` is compatible with `y` if `y` has at least the same members as `x`. For example consider the following code involving an interface named `Pet` which has a `name` property:\n\nts\n\n`interface Pet {`\n\n  `name: string;`\n\n`}`\n\n`let pet: Pet;`\n\n`// dog's inferred type is { name: string; owner: string; }`\n\n`let dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };`\n\n`pet = dog;`\n\nTo check whether `dog` can be assigned to `pet`, the compiler checks each property of `pet` to find a corresponding compatible property in `dog`. In this case, `dog` must have a member called `name` that is a string. It does, so the assignment is allowed.\n\nThe same rule for assignment is used when checking function call arguments:\n\nts\n\n`interface Pet {`\n\n  `name: string;`\n\n`}`\n\n`let dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };`\n\n`function greet(pet: Pet) {`\n\n  `console.log(\"Hello, \" + pet.name);`\n\n`}`\n\n`greet(dog); // OK`\n\nNote that `dog` has an extra `owner` property, but this does not create an error. Only members of the target type (`Pet` in this case) are considered when checking for compatibility. This comparison process proceeds recursively, exploring the type of each member and sub-member.\n\nBe aware, however, that object literals [may only specify known properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#excess-property-checks). For example, because we have explicitly specified that `dog` is of type `Pet`, the following code is invalid:\n\nts\n\n`let dog: Pet = { name: \"Lassie\", owner: \"Rudd Weatherwax\" }; // Error`\n\n## [](#comparing-two-functions)Comparing two functions\n\nWhile comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let’s start with a basic example of two functions that differ only in their parameter lists:\n\nts\n\n`let x = (a: number) => 0;`\n\n`let y = (b: number, s: string) => 0;`\n\n`y = x; // OK`\n\n`x = y; // Error`\n\nTo check if `x` is assignable to `y`, we first look at the parameter list. Each parameter in `x` must have a corresponding parameter in `y` with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of `x` has a corresponding compatible parameter in `y`, so the assignment is allowed.\n\nThe second assignment is an error, because `y` has a required second parameter that `x` does not have, so the assignment is disallowed.\n\nYou may be wondering why we allow ‘discarding’ parameters like in the example `y = x`. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, `Array#forEach` provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it’s very useful to provide a callback that only uses the first parameter:\n\nts\n\n`let items = [1, 2, 3];`\n\n`// Don't force these extra parameters`\n\n`items.forEach((item, index, array) => console.log(item));`\n\n`// Should be OK!`\n\n`items.forEach((item) => console.log(item));`\n\nNow let’s look at how return types are treated, using two functions that differ only by their return type:\n\nts\n\n`let x = () => ({ name: \"Alice\" });`\n\n`let y = () => ({ name: \"Alice\", location: \"Seattle\" });`\n\n`x = y; // OK`\n\n`y = x; // Error, because x() lacks a location property`\n\nThe type system enforces that the source function’s return type be a subtype of the target type’s return type.\n\n### [](#function-parameter-bivariance)Function Parameter Bivariance\n\nWhen comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:\n\nts\n\n`enum EventType {`\n\n  `Mouse,`\n\n  `Keyboard,`\n\n`}`\n\n`interface Event {`\n\n  `timestamp: number;`\n\n`}`\n\n`interface MyMouseEvent extends Event {`\n\n  `x: number;`\n\n  `y: number;`\n\n`}`\n\n`interface MyKeyEvent extends Event {`\n\n  `keyCode: number;`\n\n`}`\n\n`function listenEvent(eventType: EventType, handler: (n: Event) => void) {`\n\n  `/* ... */`\n\n`}`\n\n`// Unsound, but useful and common`\n\n`listenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + \",\" + e.y));`\n\n`// Undesirable alternatives in presence of soundness`\n\n`listenEvent(EventType.Mouse, (e: Event) =>`\n\n  `console.log((e as MyMouseEvent).x + \",\" + (e as MyMouseEvent).y)`\n\n`);`\n\n`listenEvent(EventType.Mouse, ((e: MyMouseEvent) =>`\n\n  `console.log(e.x + \",\" + e.y)) as (e: Event) => void);`\n\n`// Still disallowed (clear error). Type safety enforced for wholly incompatible types`\n\n`listenEvent(EventType.Mouse, (e: number) => console.log(e));`\n\nYou can have TypeScript raise errors when this happens via the compiler flag [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes).\n\n### [](#optional-parameters-and-rest-parameters)Optional Parameters and Rest Parameters\n\nWhen comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.\n\nWhen a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.\n\nThis is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing `undefined` in that position is equivalent for most functions.\n\nThe motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:\n\nts\n\n`function invokeLater(args: any[], callback: (...args: any[]) => void) {`\n\n  `/* ... Invoke callback with 'args' ... */`\n\n`}`\n\n`// Unsound - invokeLater \"might\" provide any number of arguments`\n\n`invokeLater([1, 2], (x, y) => console.log(x + \", \" + y));`\n\n`// Confusing (x and y are actually required) and undiscoverable`\n\n`invokeLater([1, 2], (x?, y?) => console.log(x + \", \" + y));`\n\n### [](#functions-with-overloads)Functions with overloads\n\nWhen a function has overloads, each overload in the target type must be matched by a compatible signature on the source type. This ensures that the source function can be called in all the same cases as the target function.\n\n## [](#enums)Enums\n\nEnums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,\n\nts\n\n`enum Status {`\n\n  `Ready,`\n\n  `Waiting,`\n\n`}`\n\n`enum Color {`\n\n  `Red,`\n\n  `Blue,`\n\n  `Green,`\n\n`}`\n\n`let status = Status.Ready;`\n\n`status = Color.Green; // Error`\n\n## [](#classes)Classes\n\nClasses work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.\n\nts\n\n`class Animal {`\n\n  `feet: number;`\n\n  `constructor(name: string, numFeet: number) {}`\n\n`}`\n\n`class Size {`\n\n  `feet: number;`\n\n  `constructor(numFeet: number) {}`\n\n`}`\n\n`let a: Animal;`\n\n`let s: Size;`\n\n`a = s; // OK`\n\n`s = a; // OK`\n\n### [](#private-and-protected-members-in-classes)Private and protected members in classes\n\nPrivate and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but _not_ with classes from a different inheritance hierarchy which otherwise have the same shape.\n\n## [](#generics)Generics\n\nBecause TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,\n\nts\n\n`interface Empty<T> {}`\n\n`let x: Empty<number>;`\n\n`let y: Empty<string>;`\n\n`x = y; // OK, because y matches structure of x`\n\nIn the above, `x` and `y` are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to `Empty<T>` shows how this works:\n\nts\n\n`interface NotEmpty<T> {`\n\n  `data: T;`\n\n`}`\n\n`let x: NotEmpty<number>;`\n\n`let y: NotEmpty<string>;`\n\n`x = y; // Error, because x and y are not compatible`\n\nIn this way, a generic type that has its type arguments specified acts just like a non-generic type.\n\nFor generic types that do not have their type arguments specified, compatibility is checked by specifying `any` in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.\n\nFor example,\n\nts\n\n`let identity = function <T>(x: T): T {`\n\n  `// ...`\n\n`};`\n\n`let reverse = function <U>(y: U): U {`\n\n  `// ...`\n\n`};`\n\n`identity = reverse; // OK, because (x: any) => any matches (y: any) => any`\n\n## [](#advanced-topics)Advanced Topics\n\n### [](#subtype-vs-assignment)Subtype vs Assignment\n\nSo far, we’ve used “compatible”, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from `any`, and to and from `enum` with corresponding numeric values.\n\nDifferent places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the `implements` and `extends` clauses.\n\n## [](#any-unknown-object-void-undefined-null-and-never-assignability)`any`, `unknown`, `object`, `void`, `undefined`, `null`, and `never` assignability\n\nThe following table summarizes assignability between some abstract types. Rows indicate what each is assignable to, columns indicate what is assignable to them. A ”✓” indicates a combination that is compatible only when [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off.\n\n|     | any | unknown | object | void | undefined | null | never |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| any → |     | ✓   | ✓   | ✓   | ✓   | ✓   | ✕   |\n| unknown → | ✓   |     | ✕   | ✕   | ✕   | ✕   | ✕   |\n| object → | ✓   | ✓   |     | ✕   | ✕   | ✕   | ✕   |\n| void → | ✓   | ✓   | ✕   |     | ✕   | ✕   | ✕   |\n| undefined → | ✓   | ✓   | ✓   | ✓   |     | ✓   | ✕   |\n| null → | ✓   | ✓   | ✓   | ✓   | ✓   |     | ✕   |\n| never → | ✓   | ✓   | ✓   | ✓   | ✓   | ✓   |     |\n\nReiterating [The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html):\n\n*   Everything is assignable to itself.\n*   `any` and `unknown` are the same in terms of what is assignable to them, different in that `unknown` is not assignable to anything except `any`.\n*   `unknown` and `never` are like inverses of each other. Everything is assignable to `unknown`, `never` is assignable to everything. Nothing is assignable to `never`, `unknown` is not assignable to anything (except `any`).\n*   `void` is not assignable to or from anything, with the following exceptions: `any`, `unknown`, `never`, `undefined`, and `null` (if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off, see table for details).\n*   When [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off, `null` and `undefined` are similar to `never`: assignable to most types, most types are not assignable to them. They are assignable to each other.\n*   When [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is on, `null` and `undefined` behave more like `void`: not assignable to or from anything, except for `any`, `unknown`, and `void` (`undefined` is always assignable to `void`).",
    "title": "TypeScript: Documentation - Type Compatibility",
    "description": "How type-checking works in TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/modules/theory.html",
    "markdown": "# TypeScript: Documentation - Modules - Theory\n\n## [](#scripts-and-modules-in-javascript)Scripts and modules in JavaScript\n\nIn the early days of JavaScript, when the language only ran in browsers, there were no modules, but it was still possible to split the JavaScript for a web page into multiple files by using multiple `script` tags in HTML:\n\nhtml\n\n`<html>`\n\n  `<head>`\n\n    `<script src=\"a.js\"></script>`\n\n    `<script src=\"b.js\"></script>`\n\n  `</head>`\n\n  `<body></body>`\n\n`</html>`\n\nThis approach had some downsides, especially as web pages grew larger and more complex. In particular, all scripts loaded onto the same page share the same scope—appropriately called the “global scope”—meaning the scripts had to be very careful not to overwrite each others’ variables and functions.\n\nAny system that solves this problem by giving files their own scope while still providing a way to make bits of code available to other files can be called a “module system.” (It may sound obvious to say that each file in a module system is called a “module,” but the term is often used to contrast with _script_ files, which run outside a module system, in a global scope.)\n\n> There are [many module systems](https://github.com/myshov/history-of-javascript/tree/master/4_evolution_of_js_modularity), and TypeScript [supports emitting several](https://www.typescriptlang.org/tsconfig/#module), but this documentation will focus on the two most important systems today: ECMAScript modules (ESM) and CommonJS (CJS).\n> \n> ECMAScript Modules (ESM) is the module system built into the language, supported in modern browsers and in Node.js since v12. It uses dedicated `import` and `export` syntax:\n> \n> js\n> \n> `// a.js`\n> \n> `export default \"Hello from a.js\";`\n> \n> js\n> \n> `// b.js`\n> \n> `import a from \"./a.js\";`\n> \n> `console.log(a); // 'Hello from a.js'`\n> \n> CommonJS (CJS) is the module system that originally shipped in Node.js, before ESM was part of the language specification. It’s still supported in Node.js alongside ESM. It uses plain JavaScript objects and functions named `exports` and `require`:\n> \n> js\n> \n> `// a.js`\n> \n> `exports.message = \"Hello from a.js\";`\n> \n> js\n> \n> `// b.js`\n> \n> `const a = require(\"./a\");`\n> \n> `console.log(a.message); // 'Hello from a.js'`\n\nAccordingly, when TypeScript detects that a file is a CommonJS or ECMAScript module, it starts by assuming that file will have its own scope. Beyond that, though, the compiler’s job gets a little more complicated.\n\n## [](#typescripts-job-concerning-modules)TypeScript’s job concerning modules\n\nThe TypeScript compiler’s chief goal is to prevent certain kinds of runtime errors by catching them at compile time. With or without modules involved, the compiler needs to know about the code’s intended runtime environment—what globals are available, for example. When modules are involved, there are several additional questions the compiler needs to answer in order to do its job. Let’s use a few lines of input code as an example to think about all the information needed to analyze it:\n\nts\n\n`import sayHello from \"greetings\";`\n\n`sayHello(\"world\");`\n\nTo check this file, the compiler needs to know the type of `sayHello` (is it a function that can accept one string argument?), which opens quite a few additional questions:\n\n1.  Will the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?\n2.  What _kind_ of module does the module system expect to find, given the file name it will load and its location on disk?\n3.  If output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?\n4.  Where will the module system look to find the module specified by `\"greetings\"`? Will the lookup succeed?\n5.  What kind of module is the file resolved by that lookup?\n6.  Does the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?\n7.  Once the `\"greetings\"` module has been analyzed, what piece of that module is bound to `sayHello`?\n\nNotice that all of these questions depend on characteristics of the _host_—the system that ultimately consumes the output JavaScript (or raw TypeScript, as the case may be) to direct its module loading behavior, typically either a runtime (like Node.js) or bundler (like Webpack).\n\nThe ECMAScript specification defines how ESM imports and exports link up with each other, but it doesn’t specify how the file lookup in (4), known as _module resolution_, happens, and it doesn’t say anything about other module systems like CommonJS. So runtimes and bundlers, especially those that want to support both ESM and CJS, have a lot of freedom to design their own rules. Consequently, the way TypeScript should answer the questions above can vary dramatically depending on where the code is intended to run. There’s no single right answer, so the compiler must be told the rules through configuration options.\n\nThe other key idea to keep in mind is that TypeScript almost always thinks about these questions in terms of its _output_ JavaScript files, not its _input_ TypeScript (or JavaScript!) files. Today, some runtimes and bundlers support loading TypeScript files directly, and in those cases, it doesn’t make sense to think about separate input and output files. Most of this document discusses cases where TypeScript files are compiled to JavaScript files, which in turn are loaded by the runtime module system. Examining these cases is essential for building an understanding of the compiler’s options and behavior—it’s easier to start there and simplify when thinking about esbuild, Bun, and other [TypeScript-first runtimes and bundlers](#module-resolution-for-bundlers-typescript-runtimes-and-nodejs-loaders). So for now, we can summarize TypeScript’s job when it comes to modules in terms of output files:\n\nUnderstand the **rules of the host** enough\n\n1.  to compile files into a valid **output module format**,\n2.  to ensure that imports in those **outputs** will **resolve successfully**, and\n3.  to know what **type** to assign to **imported names**.\n\n## [](#who-is-the-host)Who is the host?\n\nBefore we move on, it’s worth making sure we’re on the same page about the term _host_, because it will come up frequently. We defined it before as “the system that ultimately consumes the output code to direct its module loading behavior.” In other words, it’s the system outside of TypeScript that TypeScript’s module analysis tries to model:\n\n*   When the output code (whether produced by `tsc` or a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.\n*   When there is no “output code” because a runtime consumes TypeScript files directly, the runtime is still the host.\n*   When a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn’t know about anything that happens post-bundler.)\n*   If another transpiler, optimizer, or formatter runs on TypeScript’s outputs, it’s _not_ a host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.\n*   When loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser’s JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.\n*   The TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts.\n\n## [](#the-module-output-format)The module output format\n\nIn any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match. Sometimes, the host only _supports_ one kind of module—ESM in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12 and later accepts both CJS and ES modules, but uses file extensions and `package.json` files to determine what format each file should be, and throws an error if the file’s contents don’t match the expected format.\n\nThe `module` compiler option provides this information to the compiler. Its primary purpose is to control the module format of any JavaScript that gets emitted during compilation, but it also serves to inform the compiler about how the module kind of each file should be detected, how different module kinds are allowed to import each other, and whether features like `import.meta` and top-level `await` are available. So, even if a TypeScript project is using `noEmit`, choosing the right setting for `module` still matters. As we established earlier, the compiler needs an accurate understanding of the module system so it can type check (and provide IntelliSense for) imports. See [_Choosing compiler options_](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html) for guidance on choosing the right `module` setting for your project.\n\nThe available `module` settings are\n\n*   [**`node16`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext): Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.\n*   [**`nodenext`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext): Currently identical to `node16`, but will be a moving target reflecting the latest Node.js versions as Node.js’s module system evolves.\n*   [**`es2015`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Reflects the ES2015 language specification for JavaScript modules (the version that first introduced `import` and `export` to the language).\n*   [**`es2020`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Adds support for `import.meta` and `export * as ns from \"mod\"` to `es2015`.\n*   [**`es2022`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Adds support for top-level `await` to `es2020`.\n*   [**`esnext`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext): Currently identical to `es2022`, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.\n*   **[`commonjs`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#commonjs), [`system`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#system), [`amd`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#amd), and [`umd`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#umd)**: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation.\n\n> Node.js’s rules for module format detection and interoperability make it incorrect to specify `module` as `esnext` or `commonjs` for projects that run in Node.js, even if all files emitted by `tsc` are ESM or CJS, respectively. The only correct `module` settings for projects that intend to run in Node.js are `node16` and `nodenext`. While the emitted JavaScript for an all-ESM Node.js project might look identical between compilations using `esnext` and `nodenext`, the type checking can differ. See the [reference section on `nodenext`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext) for more details.\n\n### [](#module-format-detection)Module format detection\n\nNode.js understands both ES modules and CJS modules, but the format of each file is determined by its file extension and the `type` field of the first `package.json` file found in a search of the file’s directory and all ancestor directories:\n\n*   `.mjs` and `.cjs` files are always interpreted as ES modules and CJS modules, respectively.\n*   `.js` files are interpreted as ES modules if the nearest `package.json` file contains a `type` field with the value `\"module\"`. If there is no `package.json` file, or if the `type` field is missing or has any other value, `.js` files are interpreted as CJS modules.\n\nIf a file is determined to be an ES module by these rules, Node.js will not inject the CommonJS `module` and `require` objects into the file’s scope during evaluation, so a file that tries to use them will cause a crash. Conversely, if a file is determined to be a CJS module, `import` and `export` declarations in the file will cause a syntax error crash.\n\nWhen the `module` compiler option is set to `node16` or `nodenext`, TypeScript applies this same algorithm to the project’s _input_ files to determine the module kind of each corresponding _output_ file. Let’s look at how module formats are detected in an example project that uses `--module nodenext`:\n\n| Input file name | Contents | Output file name | Module kind | Reason |\n| --- | --- | --- | --- | --- |\n| `/package.json` | `{}` |     |     |     |\n| `/main.mts` |     | `/main.mjs` | ESM | File extension |\n| `/utils.cts` |     | `/utils.cjs` | CJS | File extension |\n| `/example.ts` |     | `/example.js` | CJS | No `\"type\": \"module\"` in `package.json` |\n| `/node_modules/pkg/package.json` | `{ \"type\": \"module\" }` |     |     |     |\n| `/node_modules/pkg/index.d.ts` |     |     | ESM | `\"type\": \"module\"` in `package.json` |\n| `/node_modules/pkg/index.d.cts` |     |     | CJS | File extension |\n\nWhen the input file extension is `.mts` or `.cts`, TypeScript knows to treat that file as an ES module or CJS module, respectively, because Node.js will treat the output `.mjs` file as an ES module or the output `.cjs` file as a CJS module. When the input file extension is `.ts`, TypeScript has to consult the nearest `package.json` file to determine the module format, because this is what Node.js will do when it encounters the output `.js` file. (Notice that the same rules apply to the `.d.cts` and `.d.ts` declaration files in the `pkg` dependency: though they will not produce an output file as part of this compilation, the presence of a `.d.ts` file _implies_ the existence of a corresponding `.js` file—perhaps created when the author of the `pkg` library ran `tsc` on an input `.ts` file of their own—which Node.js must interpret as an ES module, due to its `.js` extension and the presence of the `\"type\": \"module\"` field in `/node_modules/pkg/package.json`. Declaration files are covered in more detail in a [later section](#the-role-of-declaration-files).)\n\nThe detected module format of input files is used by TypeScript to ensure it emits the output syntax that Node.js expects in each output file. If TypeScript were to emit `/example.js` with `import` and `export` statements in it, Node.js would crash when parsing the file. If TypeScript were to emit `/main.mjs` with `require` calls, Node.js would crash during evaluation. Beyond emit, the module format is also used to determine rules for type checking and module resolution, which we’ll discuss in the following sections.\n\nIt’s worth mentioning again that TypeScript’s behavior in `--module node16` and `--module nodenext` is entirely motivated by Node.js’s behavior. Since TypeScript’s goal is to catch potential runtime errors at compile time, it needs a very accurate model of what will happen at runtime. This fairly complex set of rules for module kind detection is _necessary_ for checking code that will run in Node.js, but may be overly strict or just incorrect if applied to non-Node.js hosts.\n\n### [](#input-module-syntax)Input module syntax\n\nIt’s important to note that the _input_ module syntax seen in input source files is somewhat decoupled from the output module syntax emitted to JS files. That is, a file with an ESM import:\n\nts\n\n`import { sayHello } from \"greetings\";`\n\n`sayHello(\"world\");`\n\nmight be emitted in ESM format exactly as-is, or might be emitted as CommonJS:\n\nts\n\n`Object.defineProperty(exports, \"__esModule\", { value: true });`\n\n`const greetings_1 = require(\"greetings\");`\n\n`(0, greetings_1.sayHello)(\"world\");`\n\ndepending on the `module` compiler option (and any applicable [module format detection](#module-format-detection) rules, if the `module` option supports more than one kind of module). In general, this means that looking at the contents of an input file isn’t enough to determine whether it’s an ES module or a CJS module.\n\n> Today, most TypeScript files are authored using ESM syntax (`import` and `export` statements) regardless of the output format. This is largely a legacy of the long road ESM has taken to widespread support. ECMAScript modules were standardized in 2015, were supported in most browsers by 2017, and landed in Node.js v12 in 2019. During much of this window, it was clear that ESM was the future of JavaScript modules, but very few runtimes could consume it. Tools like Babel made it possible for JavaScript to be authored in ESM and downleveled to another module format that could be used in Node.js or browsers. TypeScript followed suit, adding support for ES module syntax and softly discouraging the use of the original CommonJS-inspired `import fs = require(\"fs\")` syntax in [the 1.5 release](https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/).\n> \n> The upside of this “author ESM, output anything” strategy was that TypeScript could use standard JavaScript syntax, making the authoring experience familiar to newcomers, and (theoretically) making it easy for projects to start targeting ESM outputs in the future. There are three significant downsides, which became fully apparent only after ESM and CJS modules were allowed to coexist and interoperate in Node.js:\n> \n> 1.  Early assumptions about how ESM/CJS interoperability would work in Node.js turned out to be wrong, and today, interoperability rules differ between Node.js and bundlers. Consequently, the configuration space for modules in TypeScript is large.\n> 2.  When the syntax in input files all looks like ESM, it’s easy for an author or code reviewer to lose track of what kind of module a file is at runtime. And because of Node.js’s interoperability rules, what kind of module each file is became very important.\n> 3.  When input files are written in ESM, the syntax in type declaration outputs (`.d.ts` files) looks like ESM too. But because the corresponding JavaScript files could have been emitted in any module format, TypeScript can’t tell what kind of module a file is just by looking at the contents of its type declarations. And again, because of the nature of ESM/CJS interoperability, TypeScript _has_ to know what kind of module everything is in order to provide correct types and prevent imports that will crash.\n> \n> In TypeScript 5.0, a new compiler option called `verbatimModuleSyntax` was introduced to help TypeScript authors know exactly how their `import` and `export` statements will be emitted. When enabled, the flag requires imports and exports in input files to be written in the form that will undergo the least amount of transformation before emit. So if a file will be emitted as ESM, imports and exports must be written in ESM syntax; if a file will be emitted as CJS, it must be written in the CommonJS-inspired TypeScript syntax (`import fs = require(\"fs\")` and `export = {}`). This setting is particularly recommended for Node.js projects that use mostly ESM, but have a select few CJS files. It is not recommended for projects that currently target CJS, but may want to target ESM in the future.\n\n### [](#esm-and-cjs-interoperability)ESM and CJS interoperability\n\nCan an ES module `import` a CommonJS module? If so, does a default import link to `exports` or `exports.default`? Can a CommonJS module `require` an ES module? CommonJS isn’t part of the ECMAScript specification, so runtimes, bundlers, and transpilers have been free to make up their own answers to these questions since ESM was standardized in 2015, and as such no standard set of interoperability rules exist. Today, most runtimes and bundlers broadly fall into one of three categories:\n\n1.  **ESM-only.** Some runtimes, like browser engines, only support what’s actually a part of the language: ECMAScript Modules.\n2.  **Bundler-like.** Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.\n3.  **Node.js.** In Node.js, CommonJS modules cannot load ES modules synchronously (with `require`); they can only load them asynchronously with dynamic `import()` calls. ES modules can default-import CJS modules, which always binds to `exports`. (This means that a default import of a Babel-like CJS output with `__esModule` behaves differently between Node.js and some bundlers.)\n\nTypeScript needs to know which of these rule sets to assume in order to provide correct types on (particularly `default`) imports and to error on imports that will crash at runtime. When the `module` compiler option is set to `node16` or `nodenext`, Node.js’s rules are enforced. All other `module` settings, combined with the [`esModuleInterop`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#esModuleInterop) option, result in bundler-like interop in TypeScript. (While using `--module esnext` does prevent you from _writing_ CommonJS modules, it does not prevent you from _importing_ them as dependencies. There’s currently no TypeScript setting that can guard against an ES module importing a CommonJS module, as would be appropriate for direct-to-browser code.)\n\n### [](#module-specifiers-are-not-transformed)Module specifiers are not transformed\n\nWhile the `module` compiler option can transform imports and exports in input files to different module formats in output files, the module _specifier_ (the string `from` which you `import`, or pass to `require`) is always emitted as-written. For example, an input like:\n\nts\n\n`import { add } from \"./math.mjs\";`\n\n`add(1, 2);`\n\nmight be emitted as either:\n\nts\n\n`import { add } from \"./math.mjs\";`\n\n`add(1, 2);`\n\nor:\n\nts\n\n`const math_1 = require(\"./math.mjs\");`\n\n`math_1.add(1, 2);`\n\ndepending on the `module` compiler option, but the module specifier will always be `\"./math.mjs\"`. There is no compiler option that enables transforming, substituting, or rewriting module specifiers. Consequently, module specifiers must be written in a way that works for the code’s target runtime or bundler, and it’s TypeScript’s job to understand those _output_\\-relative specifiers. The process of finding the file referenced by a module specifier is called _module resolution_.\n\n## [](#module-resolution)Module resolution\n\nLet’s return to our [first example](#typescripts-job-concerning-modules) and review what we’ve learned about it so far:\n\nts\n\n`import sayHello from \"greetings\";`\n\n`sayHello(\"world\");`\n\nSo far, we’ve discussed how the host’s module system and TypeScript’s `module` compiler option might impact this code. We know that the input syntax looks like ESM, but the output format depends on the `module` compiler option, potentially the file extension, and `package.json` `\"type\"` field. We also know that what `sayHello` gets bound to, and even whether the import is even allowed, may vary depending on the module kinds of this file and the target file. But we haven’t yet discussed how to _find_ the target file.\n\n### [](#module-resolution-is-host-defined)Module resolution is host-defined\n\nWhile the ECMAScript specification defines how to parse and interpret `import` and `export` statements, it leaves module resolution up to the host. If you’re creating a hot new JavaScript runtime, you’re free to create a module resolution scheme like:\n\nts\n\n`import monkey from \"🐒\"; // Looks for './eats/bananas.js'`\n\n`import cow from \"🐄\";    // Looks for './eats/grass.js'`\n\n`import lion from \"🦁\";   // Looks for './eats/you.js'`\n\nand still claim to implement “standards-compliant ESM.” Needless to say, TypeScript would have no idea what types to assign to `monkey`, `cow`, and `lion` without built-in knowledge of this runtime’s module resolution algorithm. Just as `module` informs the compiler about the host’s expected module format, `moduleResolution`, along with a few customization options, specify the algorithm the host uses to resolve module specifiers to files. This also clarifies why TypeScript doesn’t modify import specifiers during emit: the relationship between an import specifier and a file on disk (if one even exists) is host-defined, and TypeScript is not a host.\n\nThe available `moduleResolution` options are:\n\n*   [**`classic`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#classic): TypeScript’s oldest module resolution mode, this is unfortunately the default when `module` is set to anything other than `commonjs`, `node16`, or `nodenext`. It was probably made to provide best-effort resolution for a wide range of [RequireJS](https://requirejs.org/docs/api.html#packages) configurations. It should not be used for new projects (or even old projects that don’t use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.\n*   [**`node10`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node10-formerly-known-as-node): Formerly known as `node`, this is the unfortunate default when `module` is set to `commonjs`. It’s a pretty good model of Node.js versions older than v12, and sometimes it’s a passable approximation of how most bundlers do module resolution. It supports looking up packages from `node_modules`, loading directory `index.js` files, and omitting `.js` extensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it’s a very bad model of modern versions of Node.js. It should not be used for new projects.\n*   [**`node16`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext-1): This is the counterpart of `--module node16` and is set by default with that `module` setting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamic `import()` calls are not allowed to omit file extensions or `/index.js` suffixes, while module specifiers in `require` calls are. This module resolution mode understands and enforces this restriction where necessary, as determined by the [module format detection rules](#module-format-detection) instated by `--module node16`. (For `node16` and `nodenext`, `module` and `moduleResolution` go hand-in-hand: setting one to `node16` or `nodenext` while setting the other to something else has unsupported behavior and may be an error in the future.)\n*   [**`nodenext`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext-1): Currently identical to `node16`, this is the counterpart of `--module nodenext` and is set by default with that `module` setting. It’s intended to be a forward-looking mode that will support new Node.js module resolution features as they’re added.\n*   [**`bundler`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#bundler): Node.js v12 introduced some new module resolution features for importing npm packages—the `\"exports\"` and `\"imports\"` fields of `package.json`—and many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supports `package.json` `\"exports\"` and `\"imports\"` by default, but can be configured to ignore them. It requires setting `module` to `esnext`.\n\n### [](#typescript-imitates-the-hosts-module-resolution-but-with-types)TypeScript imitates the host’s module resolution, but with types\n\nRemember the three components of TypeScript’s [job](#typescripts-job-concerning-modules) concerning modules?\n\n1.  Compile files into a valid **output module format**\n2.  Ensure that imports in those **outputs** will **resolve successfully**\n3.  Know what **type** to assign to **imported names**.\n\nModule resolution is needed to accomplish last two. But when we spend most of our time working in input files, it can be easy to forget about (2)—that a key component of module resolution is validating that the imports or `require` calls in the output files, containing the [same module specifiers as the input files](#module-specifiers-are-not-transformed), will actually work at runtime. Let’s look at a new example with multiple files:\n\nts\n\n`// @Filename: math.ts`\n\n`export function add(a: number, b: number) {`\n\n  `return a + b;`\n\n`}`\n\n`// @Filename: main.ts`\n\n`import { add } from \"./math\";`\n\n`add(1, 2);`\n\nWhen we see the import from `\"./math\"`, it might be tempting to think, “This is how one TypeScript file refers to another. The compiler follows this (extensionless) path in order to assign a type to `add`.”\n\n![A simple flowchart diagram. A file (rectangle node) main.ts resolves (labeled arrow) through module specifier './math' to another file math.ts.](https://www.typescriptlang.org/c858b89407a2057ead56516c9a77c783/theory.md-1.svg)\n\nThis isn’t entirely wrong, but the reality is deeper. The resolution of `\"./math\"` (and subsequently, the type of `add`) need to reflect the reality of what happens at runtime to the _output_ files. A more robust way to think about this process would look like this:\n\n![A flowchart diagram with two groups of files: Input files and Output files. main.ts (an input file) maps to output file main.js, which resolves through the module specifier \"./math\" to math.js (another output file), which maps back to the input file math.ts.](https://www.typescriptlang.org/b1f11e84a45a07707dbe1bb284b2fbff/theory.md-2.svg)\n\nThis model makes it clear that for TypeScript, module resolution is mostly a matter of accurately modeling the host’s module resolution algorithm between output files, with a little bit of remapping applied to find type information. Let’s look at another example that appears unintuitive through the lens of the simple model, but makes perfect sense with the robust model:\n\nts\n\n`// @moduleResolution: node16`\n\n`// @rootDir: src`\n\n`// @outDir: dist`\n\n`// @Filename: src/math.mts`\n\n`export function add(a: number, b: number) {`\n\n  `return a + b;`\n\n`}`\n\n`// @Filename: src/main.mts`\n\n`import { add } from \"./math.mjs\";`\n\n`add(1, 2);`\n\nNode.js ESM `import` declarations use a strict module resolution algorithm that requires relative paths to include file extensions. When we only think about input files, it’s a little strange that `\"./math.mjs\"` seems to resolve to `math.mts`. Since we’re using an `outDir` to put compiled outputs in a different directory, `math.mjs` doesn’t even exist next to `main.mts`! Why should this resolve? With our new mental model, it’s no problem:\n\n![A flowchart diagram with identical structure to the one above. There are two groups of files: Input files and Output files. src/main.mts (an input file) maps to output file dist/main.mjs, which resolves through module specifier \"./math.mjs\" to dist/math.mjs (another output file), which maps back to input file src/math.mts.](https://www.typescriptlang.org/729e81e79e38af5bf41ddf97aba453d1/theory.md-3.svg)\n\nUnderstanding this mental model may not immediately eliminate the strangeness of seeing output file extensions in input files, and it’s natural to think in terms of shortcuts: _`\"./math.mjs\"` refers to the input file `math.mts`. I have to write the output extension, but the compiler knows to look for `.mts` when I write `.mjs`._ This shortcut is even how the compiler works internally, but the more robust mental model explains _why_ module resolution in TypeScript works this way: given the constraint that the module specifier in the output file will be [the same](#module-specifiers-are-not-transformed) as the module specifier in the input file, this is the only process that accomplishes our two goals of validating output files and assigning types.\n\n### [](#the-role-of-declaration-files)The role of declaration files\n\nIn the previous example, we saw the “remapping” part of module resolution working between input and output files. But what happens when we import library code? Even if the library was written in TypeScript, it may not have published its source code. If we can’t rely on mapping the library’s JavaScript files back to a TypeScript file, we can verify that our import works at runtime, but how do we accomplish our second goal of assigning types?\n\nThis is where declaration files (`.d.ts`, `.d.mts`, etc.) come into play. The best way to understand how declaration files are interpreted is to understand where they come from. When you run `tsc --declaration` on an input file, you get one output JavaScript file and one output declaration file:\n\n![A diagram showing the relationship between different file types. A .ts file (top) has two arrows labeled 'generates' flowing to a .js file (bottom left) and a .d.ts file (bottom right). Another arrow labeled 'implies' points from the .d.ts file to the .js file.](https://www.typescriptlang.org/fef70ad85e4ea4ef928cc62ddb67407b/declaration-files.svg)\n\nBecause of this relationship, the compiler _assumes_ that wherever it sees a declaration file, there is a corresponding JavaScript file that is perfectly described by the type information in the declaration file. For performance reasons, in every module resolution mode, the compiler always looks for TypeScript and declaration files first, and if it finds one, it doesn’t continue looking for the corresponding JavaScript file. If it finds a TypeScript input file, it knows a JavaScript file _will_ exist after compilation, and if it finds a declaration file, it knows a compilation (perhaps someone else’s) already happened and created a JavaScript file at the same time as the declaration file.\n\nThe declaration file tells the compiler not only that a JavaScript file exists, but also what its name and extension are:\n\n| Declaration file extension | JavaScript file extension | TypeScript file extension |\n| --- | --- | --- |\n| `.d.ts` | `.js` | `.ts` |\n| `.d.ts` | `.js` | `.tsx` |\n| `.d.mts` | `.mjs` | `.mts` |\n| `.d.cts` | `.cjs` | `.cts` |\n| `.d.*.ts` | `.*` |     |\n\nThe last row expresses that non-JS files can be typed with the `allowArbitraryExtensions` compiler option to support cases where the module system supports importing non-JS files as JavaScript objects. For example, a file named `styles.css` can be represented by a declaration file named `styles.d.css.ts`.\n\n> “But wait! Plenty of declaration files are written by hand, _not_ generated by `tsc`. Ever heard of DefinitelyTyped?” you might object. And it’s true—hand-writing declaration files, or even moving/copying/renaming them to represent outputs of an external build tool, is a dangerous, error-prone venture. DefinitelyTyped contributors and authors of typed libraries not using `tsc` to generate both JavaScript and declaration files should ensure that every JavaScript file has a sibling declaration file with the same name and matching extension. Breaking from this structure can lead to false-positive TypeScript errors for end users. The npm package [`@arethetypeswrong/cli`](https://www.npmjs.com/package/@arethetypeswrong/cli) can help catch and explain these errors before they’re published.\n\n### [](#module-resolution-for-bundlers-typescript-runtimes-and-nodejs-loaders)Module resolution for bundlers, TypeScript runtimes, and Node.js loaders\n\nSo far, we’ve really emphasized the distinction between _input files_ and _output files_. Recall that when specifying a file extension on a relative module specifier, TypeScript typically [makes you use the _output_ file extension](#typescript-imitates-the-hosts-module-resolution-but-with-types):\n\nts\n\n`// @Filename: src/math.ts`\n\n`export function add(a: number, b: number) {`\n\n  `return a + b;`\n\n`}`\n\n`// @Filename: src/main.ts`\n\n`import { add } from \"./math.ts\";`\n\n`//                  ^^^^^^^^^^^`\n\n`// An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled.`\n\nThis restriction applies since TypeScript [won’t rewrite the extension](#module-specifiers-are-not-transformed) to `.js`, and if `\"./math.ts\"` appears in an output JS file, that import won’t resolve to another JS file at runtime. TypeScript really wants to prevent you from generating an unsafe output JS file. But what if there _is_ no output JS file? What if you’re in one of these situations:\n\n*   You’re bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you’ve written to produce a bundle.\n*   You’re running this code directly in a TypeScript runtime like Deno or Bun.\n*   You’re using `ts-node`, `tsx`, or another transpiling loader for Node.\n\nIn these cases, you can turn on `noEmit` (or `emitDeclarationOnly`) and `allowImportingTsExtensions` to disable emitting unsafe JavaScript files and silence the error on `.ts`\\-extensioned imports.\n\nWith or without `allowImportingTsExtensions`, it’s still important to pick the most appropriate `moduleResolution` setting for the module resolution host. For bundlers and the Bun runtime, it’s `bundler`. These module resolvers were inspired by Node.js, but didn’t adopt the strict ESM resolution algorithm that [disables extension searching](#extension-searching-and-directory-index-files) that Node.js applies to imports. The `bundler` module resolution setting reflects this, enabling `package.json` `\"exports\"` support like `node16` and `nodenext`, while always allowing extensionless imports. See [_Choosing compiler options_](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html) for more guidance.\n\n### [](#module-resolution-for-libraries)Module resolution for libraries\n\nWhen compiling an app, you choose the `moduleResolution` option for a TypeScript project based on who the module resolution [host](#module-resolution-is-host-defined) is. When compiling a library, you don’t know where the output code will run, but you’d like it to run in as many places as possible. Using `\"module\": \"nodenext\"` (along with the implied [`\"moduleResolution\": \"nodenext\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext)) is the best bet for maximizing the compatibility of the output JavaScript’s module specifiers, since it will force you to comply with Node.js’s stricter rules for `import` module resolution. Let’s look at what would happen if a library were to compile with `\"moduleResolution\": \"bundler\"` (or worse, `\"node10\"`):\n\nts\n\n`export * from \"./utils\";`\n\nAssuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine with this code, so `\"moduleResolution\": \"bundler\"` doesn’t complain. Compiled with `\"module\": \"esnext\"`, the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n\n`Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js`\n\n`Did you mean to import ./utils.js?`\n\nOn the other hand, if we had written:\n\nts\n\n`export * from \"./utils.js\";`\n\nThis would produce output that works both in Node.js _and_ in bundlers.\n\nIn short, `\"moduleResolution\": \"bundler\"` is infectious, allowing code that only works in bundlers to be produced. Likewise, `\"moduleResolution\": \"nodenext\"` is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n\nOf course, this guidance can only apply in cases where the library ships outputs from `tsc`. If the library is being bundled _before_ shipping, `\"moduleResolution\": \"bundler\"` may be acceptable. Any build tool that changes the module format or module specifiers to produce the final build of the library bears the responsibility of ensuring the safety and compatibility of the product’s module code, and `tsc` can no longer contribute to that task, since it can’t know what module code will exist at runtime.",
    "title": "TypeScript: Documentation - Modules - Theory",
    "description": "How TypeScript models JavaScript modules",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/asp-net-core.html",
    "markdown": "# TypeScript: Documentation - ASP.NET Core\n\n## [](#install-aspnet-core-and-typescript)Install ASP.NET Core and TypeScript\n\nFirst, install [ASP.NET Core](https://dotnet.microsoft.com/apps/aspnet) if you need it. This quick-start guide requires Visual Studio 2015 or 2017.\n\nNext, if your version of Visual Studio does not already have the latest TypeScript, you can [install it](https://www.typescriptlang.org/index.html#download-links).\n\n## [](#create-a-new-project)Create a new project\n\n1.  Choose **File**\n2.  Choose **New Project** (Ctrl + Shift + N)\n3.  Search for **.NET Core** in the project search bar\n4.  Select **ASP.NET Core Web Application** and press the _Next_ button\n\n![Visual Studio Project Window Screenshot](https://www.typescriptlang.org/images/tutorials/aspnet/createwebapp.png)\n\n5.  Name your project and solution. After select the _Create_ button\n\n![Visual Studio New Project Window Screenshot](https://www.typescriptlang.org/images/tutorials/aspnet/namewebapp.png)\n\n6.  In the last window, select the **Empty** template and press the _Create_ button\n\n![Visual Studio Web Application Screenshot](https://www.typescriptlang.org/images/tutorials/aspnet/emptytemplate.png)\n\nRun the application and make sure that it works.\n\n![A screenshot of Edge showing \"Hello World\" as success](https://www.typescriptlang.org/images/tutorials/aspnet/workingsite.png)\n\n### [](#set-up-the-server)Set up the server\n\nOpen **Dependencies > Manage NuGet Packages > Browse.** Search and install `Microsoft.AspNetCore.StaticFiles` and `Microsoft.TypeScript.MSBuild`:\n\n![The Visual Studio search for Nuget](https://www.typescriptlang.org/images/tutorials/aspnet/downloaddependency.png)\n\nOpen up your `Startup.cs` file and edit your `Configure` function to look like this:\n\n`public void Configure(IApplicationBuilder app, IHostEnvironment env) {     if (env.IsDevelopment())     {         app.UseDeveloperExceptionPage();     }      app.UseDefaultFiles();     app.UseStaticFiles(); }`\n\nYou may need to restart VS for the red squiggly lines below `UseDefaultFiles` and `UseStaticFiles` to disappear.\n\n## [](#add-typescript)Add TypeScript\n\nNext we will add a new folder and call it `scripts`.\n\n![The Path of \"Add\" then \"New Folder\" in Visual Studio from a Web Project](https://www.typescriptlang.org/images/tutorials/aspnet/newfolder.png)\n\n![](https://www.typescriptlang.org/images/tutorials/aspnet/scripts.png)\n\n## [](#add-typescript-code)Add TypeScript code\n\nRight click on `scripts` and click **New Item**. Then choose **TypeScript File** and name the file `app.ts`\n\n![A highlight of the new folder](https://www.typescriptlang.org/images/tutorials/aspnet/tsfile.png)\n\n### [](#add-example-code)Add example code\n\nAdd the following code to the `app.ts` file.\n\nts\n\n`function sayHello() {`\n\n  `const compiler = (document.getElementById(\"compiler\") as HTMLInputElement)`\n\n    `.value;`\n\n  `const framework = (document.getElementById(\"framework\") as HTMLInputElement)`\n\n    `.value;`\n\n  ``return `Hello from ${compiler} and ${framework}!`;``\n\n`}`\n\n## [](#set-up-the-build)Set up the build\n\n_Configure the TypeScript compiler_\n\nFirst we need to tell TypeScript how to build. Right click on `scripts` and click **New Item**. Then choose **TypeScript Configuration File** and use the default name of `tsconfig.json`\n\n![A screenshot showing the new file dialogue with TypeScript JSON Config selected](https://www.typescriptlang.org/images/tutorials/aspnet/tsconfig.png)\n\nReplace the contents of the `tsconfig.json` file with:\n\n`{`\n\n  `\"\": {`\n\n    `\"\": true,`\n\n    `\"\": true,`\n\n    `\"\": true,`\n\n    `\"\": \"es6\"`\n\n  `},`\n\n  `\"\": [\"./app.ts\"],`\n\n  `\"compileOnSave\": true`\n\n`}`\n\n*   [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) : Do not emit outputs if any errors were reported.\n*   [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) : Raise error on expressions and declarations with an implied `any` type.\n*   [`sourceMap`](https://www.typescriptlang.org/tsconfig#sourceMap) : Generates corresponding `.map` file.\n*   [`target`](https://www.typescriptlang.org/tsconfig#target) : Specify ECMAScript target version.\n\nNote: `\"ESNext\"` targets latest supported\n\n[`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) is good idea whenever you’re writing new code — you can make sure that you don’t write any untyped code by mistake. `\"compileOnSave\"` makes it easy to update your code in a running web app.\n\n#### [](#set-up-npm)_Set up NPM_\n\nWe need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select **New Item**. Then choose **NPM Configuration File** and use the default name of `package.json`.\n\n![Screenshot of VS showing new file dialog with 'npm configuration file' selected](https://www.typescriptlang.org/images/tutorials/aspnet/packagejson.png)\n\nInside the `\"devDependencies\"` section of the `package.json` file, add _gulp_ and _del_\n\n`\"devDependencies\": {`\n\n    `\"gulp\": \"4.0.2\",`\n\n    `\"del\": \"5.1.0\"`\n\n`}`\n\nVisual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.\n\nAfter you should see an `npm` folder in your solution explorer\n\n![Screenshot of VS showing npm folder](https://www.typescriptlang.org/images/tutorials/aspnet/npm.png)\n\n#### [](#set-up-gulp)_Set up gulp_\n\nRight click on the project and click **New Item**. Then choose **JavaScript File** and use the name of `gulpfile.js`\n\njs\n\n`/// <binding AfterBuild='default' Clean='clean' />`\n\n`/*`\n\n`This file is the main entry point for defining Gulp tasks and using Gulp plugins.`\n\n`Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007`\n\n`*/`\n\n`var gulp = require(\"gulp\");`\n\n`var del = require(\"del\");`\n\n`var paths = {`\n\n  `scripts: [\"scripts/**/*.js\", \"scripts/**/*.ts\", \"scripts/**/*.map\"],`\n\n`};`\n\n`gulp.task(\"clean\", function () {`\n\n  `return del([\"wwwroot/scripts/**/*\"]);`\n\n`});`\n\n`gulp.task(\"default\", function (done) {`\n\n    `gulp.src(paths.scripts).pipe(gulp.dest(\"wwwroot/scripts\"));`\n\n    `done();`\n\n`});`\n\nThe first line tells Visual Studio to run the task ‘default’ after the build finishes. It will also run the ‘clean’ task when you ask Visual Studio to clean the build.\n\nNow right-click on `gulpfile.js` and click Task Runner Explorer.\n\n![Screenshot of right clicking on the \"Gulpfile.js\" with 'Task Runner Explorer' selected](https://www.typescriptlang.org/images/tutorials/aspnet/taskrunner.png)\n\nIf ‘default’ and ‘clean’ tasks don’t show up, refresh the explorer:\n\n![Screenshot of task explorer with \"Gulpfile.js\" in it](https://www.typescriptlang.org/images/tutorials/aspnet/taskrunnerrefresh.png)\n\n## [](#write-a-html-page)Write a HTML page\n\nRight click on the `wwwroot` folder (if you don’t see the folder try building the project) and add a New Item named `index.html` inside. Use the following code for `index.html`\n\n`<!DOCTYPE html>`\n\n`<html>`\n\n`<head>`\n\n    `<meta charset=\"utf-8\" />`\n\n    `<script src=\"scripts/app.js\"></script>`\n\n    `<title></title>`\n\n`</head>`\n\n`<body>`\n\n    `<div id=\"message\"></div>`\n\n    `<div>`\n\n        `Compiler: <input id=\"compiler\" value=\"TypeScript\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /><br />`\n\n        `Framework: <input id=\"framework\" value=\"ASP.NET\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" />`\n\n    `</div>`\n\n`</body>`\n\n`</html>`\n\n## [](#test)Test\n\n1.  Run the project\n2.  As you type on the boxes you should see the message appear/change!\n\n![A GIF of Edge showing the code you have just wrote](https://media.giphy.com/media/U3mTibRAx34DG3zhAN/giphy.gif)\n\n## [](#debug)Debug\n\n1.  In Edge, press F12 and click the Debugger tab.\n2.  Look in the first localhost folder, then scripts/app.ts\n3.  Put a breakpoint on the line with return.\n4.  Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.\n\n![An image showing the debugger running the code you have just wrote](https://www.typescriptlang.org/images/tutorials/aspnet/debugger.png)\n\nCongrats you’ve built your own .NET Core project with a TypeScript frontend.",
    "title": "TypeScript: Documentation - ASP.NET Core",
    "description": "Using TypeScript in ASP.NET Core",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/gulp.html",
    "markdown": "# TypeScript: Documentation - Gulp\n\nThis quick start guide will teach you how to build TypeScript with [gulp](https://gulpjs.com/) and then add [Browserify](https://browserify.org/), [terser](https://terser.org/), or [Watchify](https://github.com/substack/watchify) to the gulp pipeline. This guide also shows how to add [Babel](https://babeljs.io/) functionality using [Babelify](https://github.com/babel/babelify).\n\nWe assume that you’re already using [Node.js](https://nodejs.org/) with [npm](https://www.npmjs.com/).\n\n## [](#minimal-project)Minimal project\n\nLet’s start out with a new directory. We’ll name it `proj` for now, but you can change it to whatever you want.\n\nshell\n\n`mkdir proj`\n\n`cd proj`\n\nTo start, we’re going to structure our project in the following way:\n\n`proj/`\n\n   `├─ src/`\n\n   `└─ dist/`\n\nTypeScript files will start out in your `src` folder, run through the TypeScript compiler and end up in `dist`.\n\nLet’s scaffold this out:\n\nshell\n\n`mkdir src`\n\n`mkdir dist`\n\n### [](#initialize-the-project)Initialize the project\n\nNow we’ll turn this folder into an npm package.\n\nshell\n\n`npm init`\n\nYou’ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use `./dist/main.js`. You can always go back and change these in the `package.json` file that’s been generated for you.\n\n### [](#install-our-dependencies)Install our dependencies\n\nNow we can use `npm install` to install packages. First install `gulp-cli` globally (if you use a Unix system, you may need to prefix the `npm install` commands in this guide with `sudo`).\n\nshell\n\n`npm install -g gulp-cli`\n\nThen install `typescript`, `gulp` and `gulp-typescript` in your project’s dev dependencies. [Gulp-typescript](https://www.npmjs.com/package/gulp-typescript) is a gulp plugin for TypeScript.\n\nshell\n\n`npm install --save-dev typescript gulp@4.0.0 gulp-typescript`\n\n### [](#write-a-simple-example)Write a simple example\n\nLet’s write a Hello World program. In `src`, create the file `main.ts`:\n\nts\n\n`function hello(compiler: string) {`\n\n  ``console.log(`Hello from ${compiler}`);``\n\n`}`\n\n`hello(\"TypeScript\");`\n\nIn the project root, `proj`, create the file `tsconfig.json`:\n\n`{`\n\n  `\"\": [\"src/main.ts\"],`\n\n  `\"\": {`\n\n    `\"\": true,`\n\n    `\"\": \"es5\"`\n\n  `}`\n\n`}`\n\n### [](#create-a-gulpfilejs)Create a `gulpfile.js`\n\nIn the project root, create the file `gulpfile.js`:\n\njs\n\n`var gulp = require(\"gulp\");`\n\n`var ts = require(\"gulp-typescript\");`\n\n`var tsProject = ts.createProject(\"tsconfig.json\");`\n\n`gulp.task(\"default\", function () {`\n\n  `return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest(\"dist\"));`\n\n`});`\n\n### [](#test-the-resulting-app)Test the resulting app\n\nshell\n\n`gulp`\n\n`node dist/main.js`\n\nThe program should print “Hello from TypeScript!“.\n\n## [](#add-modules-to-the-code)Add modules to the code\n\nBefore we get to Browserify, let’s build our code out and add modules to the mix. This is the structure you’re more likely to use for a real app.\n\nCreate a file called `src/greet.ts`:\n\nts\n\n`export function sayHello(name: string) {`\n\n  ``return `Hello from ${name}`;``\n\n`}`\n\nNow change the code in `src/main.ts` to import `sayHello` from `greet.ts`:\n\nts\n\n`import { sayHello } from \"./greet\";`\n\n`console.log(sayHello(\"TypeScript\"));`\n\nFinally, add `src/greet.ts` to `tsconfig.json`:\n\n`{`\n\n  `\"\": [\"src/main.ts\", \"src/greet.ts\"],`\n\n  `\"\": {`\n\n    `\"\": true,`\n\n    `\"\": \"es5\"`\n\n  `}`\n\n`}`\n\nMake sure that the modules work by running `gulp` and then testing in Node:\n\nshell\n\n`gulp`\n\n`node dist/main.js`\n\nNotice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We’ll stick with CommonJS for this tutorial, but you could set `module` in the options object to change this.\n\n## [](#browserify)Browserify\n\nNow let’s move this project from Node to the browser. To do this, we’d like to bundle all our modules into one JavaScript file. Fortunately, that’s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.\n\nFirst, install browserify, [tsify](https://www.npmjs.com/package/tsify), and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called [vinyl](https://github.com/gulpjs/vinyl).\n\nshell\n\n`npm install --save-dev browserify tsify vinyl-source-stream`\n\n### [](#create-a-page)Create a page\n\nCreate a file in `src` named `index.html`:\n\nhtml\n\n`<!DOCTYPE html>`\n\n`<html>`\n\n  `<head>`\n\n    `<meta charset=\"UTF-8\" />`\n\n    `<title>Hello World!</title>`\n\n  `</head>`\n\n  `<body>`\n\n    `<p id=\"greeting\">Loading ...</p>`\n\n    `<script src=\"bundle.js\"></script>`\n\n  `</body>`\n\n`</html>`\n\nNow change `main.ts` to update the page:\n\nts\n\n`import { sayHello } from \"./greet\";`\n\n`function showHello(divName: string, name: string) {`\n\n  `const elt = document.getElementById(divName);`\n\n  `elt.innerText = sayHello(name);`\n\n`}`\n\n`showHello(\"greeting\", \"TypeScript\");`\n\nCalling `showHello` calls `sayHello` to change the paragraph’s text. Now change your gulpfile to the following:\n\njs\n\n`var gulp = require(\"gulp\");`\n\n`var browserify = require(\"browserify\");`\n\n`var source = require(\"vinyl-source-stream\");`\n\n`var tsify = require(\"tsify\");`\n\n`var paths = {`\n\n  `pages: [\"src/*.html\"],`\n\n`};`\n\n`gulp.task(\"copy-html\", function () {`\n\n  `return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));`\n\n`});`\n\n`gulp.task(`\n\n  `\"default\",`\n\n  `gulp.series(gulp.parallel(\"copy-html\"), function () {`\n\n    `return browserify({`\n\n      `basedir: \".\",`\n\n      `debug: true,`\n\n      `entries: [\"src/main.ts\"],`\n\n      `cache: {},`\n\n      `packageCache: {},`\n\n    `})`\n\n      `.plugin(tsify)`\n\n      `.bundle()`\n\n      `.pipe(source(\"bundle.js\"))`\n\n      `.pipe(gulp.dest(\"dist\"));`\n\n  `})`\n\n`);`\n\nThis adds the `copy-html` task and adds it as a dependency of `default`. That means any time `default` is run, `copy-html` has to run first. We’ve also changed `default` to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.\n\nAfter calling `bundle` we use `source` (our alias for vinyl-source-stream) to name our output bundle `bundle.js`.\n\nTest the page by running gulp and then opening `dist/index.html` in a browser. You should see “Hello from TypeScript” on the page.\n\nNotice that we specified `debug: true` to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside `main.ts`. When you refresh the page the breakpoint should pause the page and let you debug `greet.ts`.\n\n## [](#watchify-babel-and-terser)Watchify, Babel, and Terser\n\nNow that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.\n\n*   Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.\n    \n*   Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn’t support.\n    \n*   Terser compacts your code so that it takes less time to download.\n    \n\n### [](#watchify)Watchify\n\nWe’ll start with Watchify to provide background compilation:\n\nshell\n\n`npm install --save-dev watchify fancy-log`\n\nNow change your gulpfile to the following:\n\njs\n\n`var gulp = require(\"gulp\");`\n\n`var browserify = require(\"browserify\");`\n\n`var source = require(\"vinyl-source-stream\");`\n\n`var watchify = require(\"watchify\");`\n\n`var tsify = require(\"tsify\");`\n\n`var fancy_log = require(\"fancy-log\");`\n\n`var paths = {`\n\n  `pages: [\"src/*.html\"],`\n\n`};`\n\n`var watchedBrowserify = watchify(`\n\n  `browserify({`\n\n    `basedir: \".\",`\n\n    `debug: true,`\n\n    `entries: [\"src/main.ts\"],`\n\n    `cache: {},`\n\n    `packageCache: {},`\n\n  `}).plugin(tsify)`\n\n`);`\n\n`gulp.task(\"copy-html\", function () {`\n\n  `return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));`\n\n`});`\n\n`function bundle() {`\n\n  `return watchedBrowserify`\n\n    `.bundle()`\n\n    `.on(\"error\", fancy_log)`\n\n    `.pipe(source(\"bundle.js\"))`\n\n    `.pipe(gulp.dest(\"dist\"));`\n\n`}`\n\n`gulp.task(\"default\", gulp.series(gulp.parallel(\"copy-html\"), bundle));`\n\n`watchedBrowserify.on(\"update\", bundle);`\n\n`watchedBrowserify.on(\"log\", fancy_log);`\n\nThere are basically three changes here, but they require you to refactor your code a bit.\n\n1.  We wrapped our `browserify` instance in a call to `watchify`, and then held on to the result.\n2.  We called `watchedBrowserify.on('update', bundle);` so that Browserify will run the `bundle` function every time one of your TypeScript files changes.\n3.  We called `watchedBrowserify.on('log', fancy_log);` to log to the console.\n\nTogether (1) and (2) mean that we have to move our call to `browserify` out of the `default` task. And we have to give the function for `default` a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.\n\nNow when you run Gulp, it should start and stay running. Try changing the code for `showHello` in `main.ts` and saving it. You should see output that looks like this:\n\nshell\n\n`proj$ gulp`\n\n`[10:34:20] Using gulpfile ~/src/proj/gulpfile.js`\n\n`[10:34:20] Starting 'copy-html'...`\n\n`[10:34:20] Finished 'copy-html' after 26 ms`\n\n`[10:34:20] Starting 'default'...`\n\n`[10:34:21] 2824 bytes written (0.13 seconds)`\n\n`[10:34:21] Finished 'default' after 1.36 s`\n\n`[10:35:22] 2261 bytes written (0.02 seconds)`\n\n`[10:35:24] 2808 bytes written (0.05 seconds)`\n\n### [](#terser)Terser\n\nFirst install Terser. Since the point of Terser is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.\n\nshell\n\n`npm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps`\n\nNow change your gulpfile to the following:\n\njs\n\n`var gulp = require(\"gulp\");`\n\n`var browserify = require(\"browserify\");`\n\n`var source = require(\"vinyl-source-stream\");`\n\n`var terser = require(\"gulp-terser\");`\n\n`var tsify = require(\"tsify\");`\n\n`var sourcemaps = require(\"gulp-sourcemaps\");`\n\n`var buffer = require(\"vinyl-buffer\");`\n\n`var paths = {`\n\n  `pages: [\"src/*.html\"],`\n\n`};`\n\n`gulp.task(\"copy-html\", function () {`\n\n  `return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));`\n\n`});`\n\n`gulp.task(`\n\n  `\"default\",`\n\n  `gulp.series(gulp.parallel(\"copy-html\"), function () {`\n\n    `return browserify({`\n\n      `basedir: \".\",`\n\n      `debug: true,`\n\n      `entries: [\"src/main.ts\"],`\n\n      `cache: {},`\n\n      `packageCache: {},`\n\n    `})`\n\n      `.plugin(tsify)`\n\n      `.bundle()`\n\n      `.pipe(source(\"bundle.js\"))`\n\n      `.pipe(buffer())`\n\n      `.pipe(sourcemaps.init({ loadMaps: true }))`\n\n      `.pipe(terser())`\n\n      `.pipe(sourcemaps.write(\"./\"))`\n\n      `.pipe(gulp.dest(\"dist\"));`\n\n  `})`\n\n`);`\n\nNotice that `terser` itself has just one call — the calls to `buffer` and `sourcemaps` exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that `bundle.js` does get minified into an unreadable mess:\n\nshell\n\n`gulp`\n\n`cat dist/bundle.js`\n\n### [](#babel)Babel\n\nFirst install Babelify and the Babel preset for ES2015. Like Terser, Babelify mangles code, so we’ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of `.js`, `.es`, `.es6` and `.jsx` so we need to add the `.ts` extension as an option to Babelify.\n\nshell\n\n`npm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps`\n\nNow change your gulpfile to the following:\n\njs\n\n`var gulp = require(\"gulp\");`\n\n`var browserify = require(\"browserify\");`\n\n`var source = require(\"vinyl-source-stream\");`\n\n`var tsify = require(\"tsify\");`\n\n`var sourcemaps = require(\"gulp-sourcemaps\");`\n\n`var buffer = require(\"vinyl-buffer\");`\n\n`var paths = {`\n\n  `pages: [\"src/*.html\"],`\n\n`};`\n\n`gulp.task(\"copy-html\", function () {`\n\n  `return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));`\n\n`});`\n\n`gulp.task(`\n\n  `\"default\",`\n\n  `gulp.series(gulp.parallel(\"copy-html\"), function () {`\n\n    `return browserify({`\n\n      `basedir: \".\",`\n\n      `debug: true,`\n\n      `entries: [\"src/main.ts\"],`\n\n      `cache: {},`\n\n      `packageCache: {},`\n\n    `})`\n\n      `.plugin(tsify)`\n\n      `.transform(\"babelify\", {`\n\n        `presets: [\"es2015\"],`\n\n        `extensions: [\".ts\"],`\n\n      `})`\n\n      `.bundle()`\n\n      `.pipe(source(\"bundle.js\"))`\n\n      `.pipe(buffer())`\n\n      `.pipe(sourcemaps.init({ loadMaps: true }))`\n\n      `.pipe(sourcemaps.write(\"./\"))`\n\n      `.pipe(gulp.dest(\"dist\"));`\n\n  `})`\n\n`);`\n\nWe also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let’s modify `tsconfig.json`:\n\n`{`\n\n  `\"\": [\"src/main.ts\"],`\n\n  `\"\": {`\n\n    `\"\": true,`\n\n    `\"\": \"es2015\"`\n\n  `}`\n\n`}`\n\nBabel’s ES5 output should be very similar to TypeScript’s output for such a simple script.",
    "title": "TypeScript: Documentation - Gulp",
    "description": "Using TypeScript with Gulp",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/dom-manipulation.html",
    "markdown": "# TypeScript: Documentation - DOM Manipulation\n\n## [](#dom-manipulation)DOM Manipulation\n\n### [](#an-exploration-into-the-htmlelement-type)_An exploration into the `HTMLElement` type_\n\nIn the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.\n\nWebsites are made up of HTML and/or XML documents. These documents are static, they do not change. The _Document Object Model (DOM)_ is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop.\n\nTypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in _lib.dom.d.ts_, one stands out among the rest: `HTMLElement`. This type is the backbone for DOM manipulation with TypeScript.\n\n> You can explore the source code for the [DOM type definitions](https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts)\n\n## [](#basic-example)Basic Example\n\nGiven a simplified _index.html_ file:\n\nhtml\n\n`<!DOCTYPE html>`\n\n`<html lang=\"en\">`\n\n  `<head><title>TypeScript Dom Manipulation</title></head>`\n\n  `<body>`\n\n    `<div id=\"app\"></div>`\n\n    `<!-- Assume index.js is the compiled output of index.ts -->`\n\n    `<script src=\"index.js\"></script>`\n\n  `</body>`\n\n`</html>`\n\nLet’s explore a TypeScript script that adds a `<p>Hello, World!</p>` element to the `#app` element.\n\nts\n\n`// 1. Select the div element using the id property`\n\n`const app = document.getElementById(\"app\");`\n\n`// 2. Create a new <p></p> element programmatically`\n\n`const p = document.createElement(\"p\");`\n\n`// 3. Add the text content`\n\n`p.textContent = \"Hello, World!\";`\n\n`// 4. Append the p element to the div element`\n\n`app?.appendChild(p);`\n\nAfter compiling and running the _index.html_ page, the resulting HTML will be:\n\nhtml\n\n`<div id=\"app\">`\n\n  `<p>Hello, World!</p>`\n\n`</div>`\n\n## [](#the-document-interface)The `Document` Interface\n\nThe first line of the TypeScript code uses a global variable `document`. Inspecting the variable shows it is defined by the `Document` interface from the _lib.dom.d.ts_ file. The code snippet contains calls to two methods, `getElementById` and `createElement`.\n\n### [](#documentgetelementbyid)`Document.getElementById`\n\nThe definition for this method is as follows:\n\nts\n\n`getElementById(elementId: string): HTMLElement | null;`\n\nPass it an element id string and it will return either `HTMLElement` or `null`. This method introduces one of the most important types, `HTMLElement`. It serves as the base interface for every other element interface. For example, the `p` variable in the code example is of type `HTMLParagraphElement`. Also, take note that this method can return `null`. This is because the method can’t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new _optional chaining_ operator is used to call `appendChild`.\n\n### [](#documentcreateelement)`Document.createElement`\n\nThe definition for this method is (I have omitted the _deprecated_ definition):\n\nts\n\n`createElement<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];`\n\n`createElement(tagName: string, options?: ElementCreationOptions): HTMLElement;`\n\nThis is an overloaded function definition. The second overload is simplest and works a lot like the `getElementById` method does. Pass it any `string` and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.\n\nFor example `document.createElement('xyz')` returns a `<xyz></xyz>` element, clearly not an element that is specified by the HTML specification.\n\n> For those interested, you can interact with custom tag elements using the `document.getElementsByTagName`\n\nFor the first definition of `createElement`, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: `<K extends keyof HTMLElementTagNameMap>`. This expression defines a generic parameter `K` that is _constrained_ to the keys of the interface `HTMLElementTagNameMap`. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:\n\nts\n\n`interface HTMLElementTagNameMap {`\n\n    `\"a\": HTMLAnchorElement;`\n\n    `\"abbr\": HTMLElement;`\n\n    `\"address\": HTMLElement;`\n\n    `\"applet\": HTMLAppletElement;`\n\n    `\"area\": HTMLAreaElement;`\n\n        `...`\n\n`}`\n\nSome elements do not exhibit unique properties and so they just return `HTMLElement`, but other types do have unique properties and methods so they return their specific interface (which will extend from or implement `HTMLElement`).\n\nNow, for the remainder of the `createElement` definition: `(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]`. The first argument `tagName` is defined as the generic parameter `K`. The TypeScript interpreter is smart enough to _infer_ the generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to the `tagName` argument will be inferred as `K` and thus can be used throughout the remainder of the definition. This is exactly what happens; the return value `HTMLElementTagNameMap[K]` takes the `tagName` argument and uses it to return the corresponding type. This definition is how the `p` variable from the code snippet gets a type of `HTMLParagraphElement`. And if the code was `document.createElement('a')`, then it would be an element of type `HTMLAnchorElement`.\n\n## [](#the-node-interface)The `Node` interface\n\nThe `document.getElementById` function returns an `HTMLElement`. `HTMLElement` interface extends the `Element` interface which extends the `Node` interface. This prototypal extension allows for all `HTMLElements` to utilize a subset of standard methods. In the code snippet, we use a property defined on the `Node` interface to append the new `p` element to the website.\n\n### [](#nodeappendchild)`Node.appendChild`\n\nThe last line of the code snippet is `app?.appendChild(p)`. The previous, `document.getElementById`, section detailed that the _optional chaining_ operator is used here because `app` can potentially be null at runtime. The `appendChild` method is defined by:\n\nts\n\n`appendChild<T extends Node>(newChild: T): T;`\n\nThis method works similarly to the `createElement` method as the generic parameter `T` is inferred from the `newChild` argument. `T` is _constrained_ to another base interface `Node`.\n\n## [](#difference-between-children-and-childnodes)Difference between `children` and `childNodes`\n\nPreviously, this document details the `HTMLElement` interface extends from `Element` which extends from `Node`. In the DOM API there is a concept of _children_ elements. For example in the following HTML, the `p` tags are children of the `div` element\n\ntsx\n\n`<div>`\n\n  `<p>Hello, World</p>`\n\n  `<p>TypeScript!</p>`\n\n`</div>;`\n\n`const div = document.getElementsByTagName(\"div\")[0];`\n\n`div.children;`\n\n`// HTMLCollection(2) [p, p]`\n\n`div.childNodes;`\n\n`// NodeList(2) [p, p]`\n\nAfter capturing the `div` element, the `children` prop will return an `HTMLCollection` list containing the `HTMLParagraphElements`. The `childNodes` property will return a similar `NodeList` list of nodes. Each `p` tag will still be of type `HTMLParagraphElements`, but the `NodeList` can contain additional _HTML nodes_ that the `HTMLCollection` list cannot.\n\nModify the HTML by removing one of the `p` tags, but keep the text.\n\ntsx\n\n`<div>`\n\n  `<p>Hello, World</p>`\n\n  `TypeScript!`\n\n`</div>;`\n\n`const div = document.getElementsByTagName(\"div\")[0];`\n\n`div.children;`\n\n`// HTMLCollection(1) [p]`\n\n`div.childNodes;`\n\n`// NodeList(2) [p, text]`\n\nSee how both lists change. `children` now only contains the `<p>Hello, World</p>` element, and the `childNodes` contains a `text` node rather than two `p` nodes. The `text` part of the `NodeList` is the literal `Node` containing the text `TypeScript!`. The `children` list does not contain this `Node` because it is not considered an `HTMLElement`.\n\n## [](#the-queryselector-and-queryselectorall-methods)The `querySelector` and `querySelectorAll` methods\n\nBoth of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in _lib.dom.d.ts_ as:\n\nts\n\n`/**`\n\n `* Returns the first element that is a descendant of node that matches selectors.`\n\n `*/`\n\n`querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;`\n\n`querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;`\n\n`querySelector<E extends Element = Element>(selectors: string): E | null;`\n\n`/**`\n\n `* Returns all element descendants of node that match selectors.`\n\n `*/`\n\n`querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;`\n\n`querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;`\n\n`querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;`\n\nThe `querySelectorAll` definition is similar to `getElementsByTagName`, except it returns a new type: `NodeListOf`. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing `NodeListOf<E>` with `E[]` would result in a very similar user experience. `NodeListOf` only implements the following properties and methods: `length`, `item(index)`, `forEach((value, key, parent) => void)`, and numeric indexing. Additionally, this method returns a list of _elements_, not _nodes_, which is what `NodeList` was returning from the `.childNodes` method. While this may appear as a discrepancy, take note that interface `Element` extends from `Node`.\n\nTo see these methods in action modify the existing code to:\n\ntsx\n\n`<ul>`\n\n  `<li>First :)</li>`\n\n  `<li>Second!</li>`\n\n  `<li>Third times a charm.</li>`\n\n`</ul>;`\n\n`const first = document.querySelector(\"li\"); // returns the first li element`\n\n`const all = document.querySelectorAll(\"li\"); // returns the list of all li elements`\n\n## [](#interested-in-learning-more)Interested in learning more?\n\nThe best part about the _lib.dom.d.ts_ type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the `HTMLElement` interface is documented by this [HTMLElement page](https://developer.mozilla.org/docs/Web/API/HTMLElement) on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the [W3C Recommendation for HTMLElement](https://www.w3.org/TR/html52/dom.html#htmlelement).\n\nSources:\n\n*   [ECMA-262 Standard](http://www.ecma-international.org/ecma-262/10.0/index.html)\n*   [Introduction to the DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)",
    "title": "TypeScript: Documentation - DOM Manipulation",
    "description": "Using the DOM with TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/modules/reference.html",
    "markdown": "# TypeScript: Documentation - Modules - Reference\n\n## [](#module-syntax)Module syntax\n\nThe TypeScript compiler recognizes standard [ECMAScript module syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) in TypeScript and JavaScript files and many forms of [CommonJS syntax](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#commonjs-modules-are-supported) in JavaScript files.\n\nThere are also a few TypeScript-specific syntax extensions that can be used in TypeScript files and/or JSDoc comments.\n\n### [](#importing-and-exporting-typescript-specific-declarations)Importing and exporting TypeScript-specific declarations\n\nType aliases, interfaces, enums, and namespaces can be exported from a module with an `export` modifier, like any standard JavaScript declaration:\n\nts\n\n`// Standard JavaScript syntax...`\n\n`export function f() {}`\n\n`// ...extended to type declarations`\n\n`export type SomeType = /* ... */;`\n\n`export interface SomeInterface { /* ... */ }`\n\nThey can also be referenced in named exports, even alongside references to standard JavaScript declarations:\n\nts\n\n`export { f, SomeType, SomeInterface };`\n\nExported types (and other TypeScript-specific declarations) can be imported with standard ECMAScript imports:\n\nts\n\n`import { f, SomeType, SomeInterface } from \"./module.js\";`\n\nWhen using namespace imports or exports, exported types are available on the namespace when referenced in a type position:\n\nts\n\n`import * as mod from \"./module.js\";`\n\n`mod.f();`\n\n`mod.SomeType; // Property 'SomeType' does not exist on type 'typeof import(\"./module.js\")'`\n\n`let x: mod.SomeType; // Ok`\n\n### [](#type-only-imports-and-exports)Type-only imports and exports\n\nWhen emitting imports and exports to JavaScript, by default, TypeScript automatically elides (does not emit) imports that are only used in type positions and exports that only refer to types. Type-only imports and exports can be used to force this behavior and make the elision explicit. Import declarations written with `import type`, export declarations written with `export type { ... }`, and import or export specifiers prefixed with the `type` keyword are all guaranteed to be elided from the output JavaScript.\n\nts\n\n`// @Filename: main.ts`\n\n`import { f, type SomeInterface } from \"./module.js\";`\n\n`import type { SomeType } from \"./module.js\";`\n\n`class C implements SomeInterface {`\n\n  `constructor(p: SomeType) {`\n\n    `f();`\n\n  `}`\n\n`}`\n\n`export type { C };`\n\n`// @Filename: main.js`\n\n`import { f } from \"./module.js\";`\n\n`class C {`\n\n  `constructor(p) {`\n\n    `f();`\n\n  `}`\n\n`}`\n\nEven values can be imported with `import type`, but since they won’t exist in the output JavaScript, they can only be used in non-emitting positions:\n\nts\n\n`import type { f } from \"./module.js\";`\n\n`f(); // 'f' cannot be used as a value because it was imported using 'import type'`\n\n`let otherFunction: typeof f = () => {}; // Ok`\n\nA type-only import declaration may not declare both a default import and named bindings, since it appears ambiguous whether `type` applies to the default import or to the entire import declaration. Instead, split the import declaration into two, or use `default` as a named binding:\n\nts\n\n`import type fs, { BigIntOptions } from \"fs\";`\n\n`//          ^^^^^^^^^^^^^^^^^^^^^`\n\n`// Error: A type-only import can specify a default import or named bindings, but not both.`\n\n`import type { default as fs, BigIntOptions } from \"fs\"; // Ok`\n\n### [](#import-types)`import()` types\n\nTypeScript provides a type syntax similar to JavaScript’s dynamic `import` for referencing the type of a module without writing an import declaration:\n\nts\n\n`// Access an exported type:`\n\n`type WriteFileOptions = import(\"fs\").WriteFileOptions;`\n\n`// Access the type of an exported value:`\n\n`type WriteFileFunction = typeof import(\"fs\").writeFile;`\n\nThis is especially useful in JSDoc comments in JavaScript files, where it’s not possible to import types otherwise:\n\nts\n\n`/** @type {import(\"webpack\").Configuration} */`\n\n`module.exports = {`\n\n  `// ...`\n\n`}`\n\n### [](#export--and-import--require)`export =` and `import = require()`\n\nWhen emitting CommonJS modules, TypeScript files can use a direct analog of `module.exports = ...` and `const mod = require(\"...\")` JavaScript syntax:\n\nts\n\n`// @Filename: main.ts`\n\n`import fs = require(\"fs\");`\n\n`export = fs.readFileSync(\"...\");`\n\n`// @Filename: main.js`\n\n`\"use strict\";`\n\n`const fs = require(\"fs\");`\n\n`module.exports = fs.readFileSync(\"...\");`\n\nThis syntax was used over its JavaScript counterparts since variable declarations and property assignments could not refer to TypeScript types, whereas special TypeScript syntax could:\n\nts\n\n`// @Filename: a.ts`\n\n`interface Options { /* ... */ }`\n\n`module.exports = Options; // Error: 'Options' only refers to a type, but is being used as a value here.`\n\n`export = Options; // Ok`\n\n`// @Filename: b.ts`\n\n`const Options = require(\"./a\");`\n\n`const options: Options = { /* ... */ }; // Error: 'Options' refers to a value, but is being used as a type here.`\n\n`// @Filename: c.ts`\n\n`import Options = require(\"./a\");`\n\n`const options: Options = { /* ... */ }; // Ok`\n\n### [](#ambient-modules)Ambient modules\n\nTypeScript supports a syntax in script (non-module) files for declaring a module that exists in the runtime but has no corresponding file. These _ambient modules_ usually represent runtime-provided modules, like `\"fs\"` or `\"path\"` in Node.js:\n\nts\n\n`declare module \"path\" {`\n\n  `export function normalize(p: string): string;`\n\n  `export function join(...paths: any[]): string;`\n\n  `export var sep: string;`\n\n`}`\n\nOnce an ambient module is loaded into a TypeScript program, TypeScript will recognize imports of the declared module in other files:\n\nts\n\n`// 👇 Ensure the ambient module is loaded -`\n\n`//    may be unnecessary if path.d.ts is included`\n\n`//    by the project tsconfig.json somehow.`\n\n`/// <reference path=\"path.d.ts\" />`\n\n`import { normalize, join } from \"path\";`\n\nAmbient module declarations are easy to confuse with [module augmentations](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) since they use identical syntax. This module declaration syntax becomes a module augmentation when the file is a module, meaning it has a top-level `import` or `export` statement (or is affected by [`--moduleDetection force` or `auto`](https://www.typescriptlang.org/tsconfig#moduleDetection)):\n\nts\n\n`// Not an ambient module declaration anymore!`\n\n`export {};`\n\n`declare module \"path\" {`\n\n  `export function normalize(p: string): string;`\n\n  `export function join(...paths: any[]): string;`\n\n  `export var sep: string;`\n\n`}`\n\nAmbient modules may use imports inside the module declaration body to refer to other modules without turning the containing file into a module (which would make the ambient module declaration a module augmentation):\n\nts\n\n`declare module \"m\" {`\n\n  `// Moving this outside \"m\" would totally change the meaning of the file!`\n\n  `import { SomeType } from \"other\";`\n\n  `export function f(): SomeType;`\n\n`}`\n\nA _pattern_ ambient module contains a single `*` wildcard character in its name, matching zero or more characters in import paths. This can be useful for declaring modules provided by custom loaders:\n\nts\n\n`declare module \"*.html\" {`\n\n  `const content: string;`\n\n  `export default content;`\n\n`}`\n\n## [](#the-module-compiler-option)The `module` compiler option\n\nThis section discusses the details of each `module` compiler option value. See the [_Module output format_](https://www.typescriptlang.org/docs/handbook/modules/theory.html#the-module-output-format) theory section for more background on what the option is and how it fits into the overall compilation process. In brief, the `module` compiler option was historically only used to control the output module format of emitted JavaScript files. The more recent `node16` and `nodenext` values, however, describe a wide range of characteristics of Node.js’s module system, including what module formats are supported, how the module format of each file is determined, and how different module formats interoperate.\n\n### [](#node16-nodenext)`node16`, `nodenext`\n\nNode.js supports both CommonJS and ECMAScript modules, with specific rules for which format each file can be and how the two formats are allowed to interoperate. `node16` and `nodenext` describe the full range of behavior for Node.js’s dual-format module system, and **emit files in either CommonJS or ESM format**. This is different from every other `module` option, which are runtime-agnostic and force all output files into a single format, leaving it to the user to ensure the output is valid for their runtime.\n\n> A common misconception is that `node16` and `nodenext` only emit ES modules. In reality, `node16` and `nodenext` describe versions of Node.js that _support_ ES modules, not just projects that _use_ ES modules. Both ESM and CommonJS emit are supported, based on the [detected module format](#module-format-detection) of each file. Because `node16` and `nodenext` are the only `module` options that reflect the complexities of Node.js’s dual module system, they are the **only correct `module` options** for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.\n\n`node16` and `nodenext` are currently identical, with the exception that they [imply different `target` option values](#implied-and-enforced-options). If Node.js makes significant changes to its module system in the future, `node16` will be frozen while `nodenext` will be updated to reflect the new behavior.\n\n#### [](#module-format-detection)Module format detection\n\n*   `.mts`/`.mjs`/`.d.mts` files are always ES modules.\n*   `.cts`/`.cjs`/`.d.cts` files are always CommonJS modules.\n*   `.ts`/`.tsx`/`.js`/`.jsx`/`.d.ts` files are ES modules if the nearest ancestor package.json file contains `\"type\": \"module\"`, otherwise CommonJS modules.\n\nThe detected module format of input `.ts`/`.tsx`/`.mts`/`.cts` files determines the module format of the emitted JavaScript files. So, for example, a project consisting entirely of `.ts` files will emit all CommonJS modules by default under `--module nodenext`, and can be made to emit all ES modules by adding `\"type\": \"module\"` to the project package.json.\n\n#### [](#interoperability-rules)Interoperability rules\n\n*   **When an ES module references a CommonJS module:**\n    *   The `module.exports` of the CommonJS module is available as a default import to the ES module.\n    *   Properties (other than `default`) of the CommonJS module’s `module.exports` may or may not be available as named imports to the ES module. Node.js attempts to make them available via [static analysis](https://github.com/nodejs/cjs-module-lexer). TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See [#54018](https://github.com/microsoft/TypeScript/issues/54018) for more details.\n*   **When a CommonJS module references an ES module:**\n    *   `require` cannot reference an ES module. For TypeScript, this includes `import` statements in files that are [detected](#module-format-detection) to be CommonJS modules, since those `import` statements will be transformed to `require` calls in the emitted JavaScript.\n    *   A dynamic `import()` call may be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get from `import * as ns from \"./module.js\"` from another ES module).\n\n#### [](#emit)Emit\n\nThe emit format of each file is determined by the [detected module format](#module-format-detection) of each file. ESM emit is similar to [`--module esnext`](#es2015-es2020-es2022-esnext), but has a special transformation for `import x = require(\"...\")`, which is not allowed in `--module esnext`:\n\nts\n\n`// @Filename: main.ts`\n\n`import x = require(\"mod\");`\n\njs\n\n`// @Filename: main.js`\n\n`import { createRequire as _createRequire } from \"module\";`\n\n`const __require = _createRequire(import.meta.url);`\n\n`const x = __require(\"mod\");`\n\nCommonJS emit is similar to [`--module commonjs`](#commonjs), but dynamic `import()` calls are not transformed. Emit here is shown with `esModuleInterop` enabled:\n\nts\n\n`// @Filename: main.ts`\n\n`import fs from \"fs\"; // transformed`\n\n`const dynamic = import(\"mod\"); // not transformed`\n\njs\n\n`// @Filename: main.js`\n\n`\"use strict\";`\n\n`var __importDefault = (this && this.__importDefault) || function (mod) {`\n\n    `return (mod && mod.__esModule) ? mod : { \"default\": mod };`\n\n`};`\n\n`Object.defineProperty(exports, \"__esModule\", { value: true });`\n\n`const fs_1 = __importDefault(require(\"fs\")); // transformed`\n\n`const dynamic = import(\"mod\"); // not transformed`\n\n#### [](#implied-and-enforced-options)Implied and enforced options\n\n*   `--module nodenext` or `node16` implies and enforces the `moduleResolution` with the same name.\n*   `--module nodenext` implies `--target esnext`.\n*   `--module node16` implies `--target es2022`.\n*   `--module nodenext` or `node16` implies `--esModuleInterop`.\n\n#### [](#summary)Summary\n\n*   `node16` and `nodenext` are the only correct `module` options for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.\n*   `node16` and `nodenext` emit files in either CommonJS or ESM format, based on the [detected module format](#module-format-detection) of each file.\n*   Node.js’s interoperability rules between ESM and CJS are reflected in type checking.\n*   ESM emit transforms `import x = require(\"...\")` to a `require` call constructed from a `createRequire` import.\n*   CommonJS emit leaves dynamic `import()` calls untransformed, so CommonJS modules can asynchronously import ES modules.\n\n### [](#preserve)`preserve`\n\nIn `--module preserve` ([added](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-style `import x = require(\"...\")` and `export = ...` statements are emitted as CommonJS `require` and `module.exports`. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file).\n\nWhile it’s rare to need to mix imports and require calls in the same file, this `module` mode best reflects the capabilities of most modern bundlers, as well as the Bun runtime.\n\n> Why care about TypeScript’s `module` emit with a bundler or with Bun, where you’re likely also setting `noEmit`? TypeScript’s type checking and module resolution behavior are affected by the module format that it _would_ emit. Setting `module` gives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling. See [`--moduleResolution bundler`](#bundler) for more discussion.\n\n#### [](#examples)Examples\n\nts\n\n`import x, { y, z } from \"mod\";`\n\n`import mod = require(\"mod\");`\n\n`const dynamic = import(\"mod\");`\n\n`export const e1 = 0;`\n\n`export default \"default export\";`\n\njs\n\n`import x, { y, z } from \"mod\";`\n\n`const mod = require(\"mod\");`\n\n`const dynamic = import(\"mod\");`\n\n`export const e1 = 0;`\n\n`export default \"default export\";`\n\n#### [](#implied-and-enforced-options-1)Implied and enforced options\n\n*   `--module preserve` implies `--moduleResolution bundler`.\n*   `--module preserve` implies `--esModuleInterop`.\n\n> The option `--esModuleInterop` is enabled by default in `--module preserve` only for its [type checking](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#allowsyntheticdefaultimports-and-esmoduleinterop) behavior. Since imports never transform into require calls in `--module preserve`, `--esModuleInterop` does not affect the emitted JavaScript.\n\n### [](#es2015-es2020-es2022-esnext)`es2015`, `es2020`, `es2022`, `esnext`\n\n#### [](#summary-1)Summary\n\n*   Use `esnext` with `--moduleResolution bundler` for bundlers, Bun, and tsx.\n*   Do not use for Node.js. Use `node16` or `nodenext` with `\"type\": \"module\"` in package.json to emit ES modules for Node.js.\n*   `import mod = require(\"mod\")` is not allowed in non-declaration files.\n*   `es2020` adds support for `import.meta` properties.\n*   `es2022` adds support for top-level `await`.\n*   `esnext` is a moving target that may include support for Stage 3 proposals to ECMAScript modules.\n*   Emitted files are ES modules, but dependencies may be any format.\n\n#### [](#examples-1)Examples\n\nts\n\n`// @Filename: main.ts`\n\n`import x, { y, z } from \"mod\";`\n\n`import * as mod from \"mod\";`\n\n`const dynamic = import(\"mod\");`\n\n`console.log(x, y, z, mod, dynamic);`\n\n`export const e1 = 0;`\n\n`export default \"default export\";`\n\njs\n\n`// @Filename: main.js`\n\n`import x, { y, z } from \"mod\";`\n\n`import * as mod from \"mod\";`\n\n`const dynamic = import(\"mod\");`\n\n`console.log(x, y, z, mod, dynamic);`\n\n`export const e1 = 0;`\n\n`export default \"default export\";`\n\n### [](#commonjs)`commonjs`\n\n#### [](#summary-2)Summary\n\n*   You probably shouldn’t use this. Use `node16` or `nodenext` to emit CommonJS modules for Node.js.\n*   Emitted files are CommonJS modules, but dependencies may be any format.\n*   Dynamic `import()` is transformed to a Promise of a `require()` call.\n*   `esModuleInterop` affects the output code for default and namespace imports.\n\n#### [](#examples-2)Examples\n\n> Output is shown with `esModuleInterop: false`.\n\nts\n\n`// @Filename: main.ts`\n\n`import x, { y, z } from \"mod\";`\n\n`import * as mod from \"mod\";`\n\n`const dynamic = import(\"mod\");`\n\n`console.log(x, y, z, mod, dynamic);`\n\n`export const e1 = 0;`\n\n`export default \"default export\";`\n\njs\n\n`// @Filename: main.js`\n\n`\"use strict\";`\n\n`Object.defineProperty(exports, \"__esModule\", { value: true });`\n\n`exports.e1 = void 0;`\n\n`const mod_1 = require(\"mod\");`\n\n`const mod = require(\"mod\");`\n\n`const dynamic = Promise.resolve().then(() => require(\"mod\"));`\n\n`console.log(mod_1.default, mod_1.y, mod_1.z, mod);`\n\n`exports.e1 = 0;`\n\n`exports.default = \"default export\";`\n\nts\n\n`// @Filename: main.ts`\n\n`import mod = require(\"mod\");`\n\n`console.log(mod);`\n\n`export = {`\n\n    `p1: true,`\n\n    `p2: false`\n\n`};`\n\njs\n\n`// @Filename: main.js`\n\n`\"use strict\";`\n\n`const mod = require(\"mod\");`\n\n`console.log(mod);`\n\n`module.exports = {`\n\n    `p1: true,`\n\n    `p2: false`\n\n`};`\n\n### [](#system)`system`\n\n#### [](#summary-3)Summary\n\n*   Designed for use with the [SystemJS module loader](https://github.com/systemjs/systemjs).\n\n#### [](#examples-3)Examples\n\nts\n\n`// @Filename: main.ts`\n\n`import x, { y, z } from \"mod\";`\n\n`import * as mod from \"mod\";`\n\n`const dynamic = import(\"mod\");`\n\n`console.log(x, y, z, mod, dynamic);`\n\n`export const e1 = 0;`\n\n`export default \"default export\";`\n\njs\n\n`// @Filename: main.js`\n\n`System.register([\"mod\"], function (exports_1, context_1) {`\n\n    `\"use strict\";`\n\n    `var mod_1, mod, dynamic, e1;`\n\n    `var __moduleName = context_1 && context_1.id;`\n\n    `return {`\n\n        `setters: [`\n\n            `function (mod_1_1) {`\n\n                `mod_1 = mod_1_1;`\n\n                `mod = mod_1_1;`\n\n            `}`\n\n        `],`\n\n        `execute: function () {`\n\n            `dynamic = context_1.import(\"mod\");`\n\n            `console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);`\n\n            `exports_1(\"e1\", e1 = 0);`\n\n            `exports_1(\"default\", \"default export\");`\n\n        `}`\n\n    `};`\n\n`});`\n\n### [](#amd)`amd`\n\n#### [](#summary-4)Summary\n\n*   Designed for AMD loaders like RequireJS.\n*   You probably shouldn’t use this. Use a bundler instead.\n*   Emitted files are AMD modules, but dependencies may be any format.\n*   Supports `outFile`.\n\n#### [](#examples-4)Examples\n\nts\n\n`// @Filename: main.ts`\n\n`import x, { y, z } from \"mod\";`\n\n`import * as mod from \"mod\";`\n\n`const dynamic = import(\"mod\");`\n\n`console.log(x, y, z, mod, dynamic);`\n\n`export const e1 = 0;`\n\n`export default \"default export\";`\n\njs\n\n`// @Filename: main.js`\n\n`define([\"require\", \"exports\", \"mod\", \"mod\"], function (require, exports, mod_1, mod) {`\n\n    `\"use strict\";`\n\n    `Object.defineProperty(exports, \"__esModule\", { value: true });`\n\n    `exports.e1 = void 0;`\n\n    `const dynamic = new Promise((resolve_1, reject_1) => { require([\"mod\"], resolve_1, reject_1); });`\n\n    `console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);`\n\n    `exports.e1 = 0;`\n\n    `exports.default = \"default export\";`\n\n`});`\n\n### [](#umd)`umd`\n\n#### [](#summary-5)Summary\n\n*   Designed for AMD or CommonJS loaders.\n*   Does not expose a global variable like most other UMD wrappers.\n*   You probably shouldn’t use this. Use a bundler instead.\n*   Emitted files are UMD modules, but dependencies may be any format.\n\n#### [](#examples-5)Examples\n\nts\n\n`// @Filename: main.ts`\n\n`import x, { y, z } from \"mod\";`\n\n`import * as mod from \"mod\";`\n\n`const dynamic = import(\"mod\");`\n\n`console.log(x, y, z, mod, dynamic);`\n\n`export const e1 = 0;`\n\n`export default \"default export\";`\n\njs\n\n`// @Filename: main.js`\n\n`(function (factory) {`\n\n    `if (typeof module === \"object\" && typeof module.exports === \"object\") {`\n\n        `var v = factory(require, exports);`\n\n        `if (v !== undefined) module.exports = v;`\n\n    `}`\n\n    `else if (typeof define === \"function\" && define.amd) {`\n\n        `define([\"require\", \"exports\", \"mod\", \"mod\"], factory);`\n\n    `}`\n\n`})(function (require, exports) {`\n\n    `\"use strict\";`\n\n    `var __syncRequire = typeof module === \"object\" && typeof module.exports === \"object\";`\n\n    `Object.defineProperty(exports, \"__esModule\", { value: true });`\n\n    `exports.e1 = void 0;`\n\n    `const mod_1 = require(\"mod\");`\n\n    `const mod = require(\"mod\");`\n\n    `const dynamic = __syncRequire ? Promise.resolve().then(() => require(\"mod\")) : new Promise((resolve_1, reject_1) => { require([\"mod\"], resolve_1, reject_1); });`\n\n    `console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);`\n\n    `exports.e1 = 0;`\n\n    `exports.default = \"default export\";`\n\n`});`\n\n## [](#the-moduleresolution-compiler-option)The `moduleResolution` compiler option\n\nThis section describes module resolution features and processes shared by multiple `moduleResolution` modes, then specifies the details of each mode. See the [_Module resolution_](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution) theory section for more background on what the option is and how it fits into the overall compilation process. In brief, `moduleResolution` controls how TypeScript resolves _module specifiers_ (string literals in `import`/`export`/`require` statements) to files on disk, and should be set to match the module resolver used by the target runtime or bundler.\n\n### [](#common-features-and-processes)Common features and processes\n\n#### [](#file-extension-substitution)File extension substitution\n\nTypeScript always wants to resolve internally to a file that can provide type information, while ensuring that the runtime or bundler can use the same path to resolve to a file that provides a JavaScript implementation. For any module specifier that would, according to the `moduleResolution` algorithm specified, trigger a lookup of a JavaScript file in the runtime or bundler, TypeScript will first try to find a TypeScript implementation file or type declaration file with the same name and analagous file extension.\n\nRuntime lookup\n\nTypeScript lookup #1\n\nTypeScript lookup #2\n\nTypeScript lookup #3\n\nTypeScript lookup #4\n\nTypeScript lookup #5\n\n`/mod.js`\n\n`/mod.ts`\n\n`/mod.tsx`\n\n`/mod.d.ts`\n\n`/mod.js`\n\n`./mod.jsx`\n\n`/mod.mjs`\n\n`/mod.mts`\n\n`/mod.d.mts`\n\n`/mod.mjs`\n\n`/mod.cjs`\n\n`/mod.cts`\n\n`/mod.d.cts`\n\n`/mod.cjs`\n\nNote that this behavior is independent of the actual module specifier written in the import. This means that TypeScript can resolve to a `.ts` or `.d.ts` file even if the module specifier explicitly uses a `.js` file extension:\n\nts\n\n`import x from \"./mod.js\";`\n\n`// Runtime lookup: \"./mod.js\"`\n\n`// TypeScript lookup #1: \"./mod.ts\"`\n\n`// TypeScript lookup #2: \"./mod.d.ts\"`\n\n`// TypeScript lookup #3: \"./mod.js\"`\n\nSee [_TypeScript imitates the host’s module resolution, but with types_](https://www.typescriptlang.org/docs/handbook/modules/theory.html#typescript-imitates-the-hosts-module-resolution-but-with-types) for an explanation of why TypeScript’s module resolution works this way.\n\n#### [](#relative-file-path-resolution)Relative file path resolution\n\nAll of TypeScript’s `moduleResolution` algorithms support referencing a module by a relative path that includes a file extension (which will be substituted according to the [rules above](#file-extension-substitution)):\n\nts\n\n`// @Filename: a.ts`\n\n`export {};`\n\n`// @Filename: b.ts`\n\n`` import {} from \"./a.js\"; // ✅ Works in every `moduleResolution` ``\n\n#### [](#extensionless-relative-paths)Extensionless relative paths\n\nIn some cases, the runtime or bundler allows omitting a `.js` file extension from a relative path. TypeScript supports this behavior where the `moduleResolution` setting and the context indicate that the runtime or bundler supports it:\n\nts\n\n`// @Filename: a.ts`\n\n`export {};`\n\n`// @Filename: b.ts`\n\n`import {} from \"./a\";`\n\nIf TypeScript determines that the runtime will perform a lookup for `./a.js` given the module specifier `\"./a\"`, then `./a.js` will undergo [extension substitution](#file-extension-substitution), and resolve to the file `a.ts` in this example.\n\nExtensionless relative paths are not supported in `import` paths in Node.js, and are not always supported in file paths specified in package.json files. TypeScript currently never supports omitting a `.mjs`/`.mts` or `.cjs`/`.cts` file extension, even though some runtimes and bundlers do.\n\n#### [](#directory-modules-index-file-resolution)Directory modules (index file resolution)\n\nIn some cases, a directory, rather than a file, can be referenced as a module. In the simplest and most common case, this involves the runtime or bundler looking for an `index.js` file in a directory. TypeScript supports this behavior where the `moduleResolution` setting and the context indicate that the runtime or bundler supports it:\n\nts\n\n`// @Filename: dir/index.ts`\n\n`export {};`\n\n`// @Filename: b.ts`\n\n`import {} from \"./dir\";`\n\nIf TypeScript determines that the runtime will perform a lookup for `./dir/index.js` given the module specifier `\"./dir\"`, then `./dir/index.js` will undergo [extension substitution](#file-extension-substitution), and resolve to the file `dir/index.ts` in this example.\n\nDirectory modules may also contain a package.json file, where resolution of the [`\"main\"` and `\"types\"`](#packagejson-main-and-types) fields are supported, and take precedence over `index.js` lookups. The [`\"typesVersions\"`](#packagejson-typesversions) field is also supported in directory modules.\n\nNote that directory modules are not the same as [`node_modules` packages](#node_modules-package-lookups) and only support a subset of the features available to packages, and are not supported at all in some contexts. Node.js considers them a [legacy feature](https://nodejs.org/dist/latest-v20.x/docs/api/modules.html#folders-as-modules).\n\n#### [](#paths)`paths`\n\n##### [](#overview)Overview\n\nTypeScript offers a way to override the compiler’s module resolution for bare specifiers with the `paths` compiler option. While the feature was originally designed to be used with the AMD module loader (a means of running modules in the browser before ESM existed or bundlers were widely used), it still has uses today when a runtime or bundler supports module resolution features that TypeScript does not model. For example, when running Node.js with `--experimental-network-imports`, you can manually specify a local type definition file for a specific `https://` import:\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"module\": \"nodenext\",`\n\n    `\"paths\": {`\n\n      `\"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"]`\n\n    `}`\n\n  `}`\n\n`}`\n\nts\n\n``// Typed by ./node_modules/@types/lodash/index.d.ts due to `paths` entry``\n\n`import { add } from \"https://esm.sh/lodash@4.17.21\";`\n\nIt’s also common for apps built with bundlers to define convenience path aliases in their bundler configuration, and then inform TypeScript of those aliases with `paths`:\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"module\": \"esnext\",`\n\n    `\"moduleResolution\": \"bundler\",`\n\n    `\"paths\": {`\n\n      `\"@app/*\": [\"./src/*\"]`\n\n    `}`\n\n  `}`\n\n`}`\n\n##### [](#paths-does-not-affect-emit)`paths` does not affect emit\n\nThe `paths` option does _not_ change the import path in the code emitted by TypeScript. Consequently, it’s very easy to create path aliases that appear to work in TypeScript but will crash at runtime:\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"module\": \"nodenext\",`\n\n    `\"paths\": {`\n\n      `\"node-has-no-idea-what-this-is\": [\"./oops.ts\"]`\n\n    `}`\n\n  `}`\n\n`}`\n\nts\n\n`// TypeScript: ✅`\n\n`// Node.js: 💥`\n\n`import {} from \"node-has-no-idea-what-this-is\";`\n\nWhile it’s ok for bundled apps to set up `paths`, it’s very important that published libraries do _not_, since the emitted JavaScript will not work for consumers of the library without those users setting up the same aliases for both TypeScript and their bundler. Both libraries and apps can consider [package.json `\"imports\"`](#packagejson-imports-and-self-name-imports) as a standard replacement for convenience `paths` aliases.\n\n##### [](#paths-should-not-point-to-monorepo-packages-or-node_modules-packages)`paths` should not point to monorepo packages or node\\_modules packages\n\nWhile module specifiers that match `paths` aliases are bare specifiers, once the alias is resolved, module resolution proceeds on the resolved path as a relative path. Consequently, resolution features that happen for [`node_modules` package lookups](#node_modules-package-lookups), including package.json `\"exports\"` field support, do not take effect when a `paths` alias is matched. This can lead to surprising behavior if `paths` is used to point to a `node_modules` package:\n\nts\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"paths\": {`\n\n      `\"pkg\": [\"./node_modules/pkg/dist/index.d.ts\"],`\n\n      `\"pkg/*\": [\"./node_modules/pkg/*\"]`\n\n    `}`\n\n  `}`\n\n`}`\n\nWhile this configuration may simulate some of the behavior of package resolution, it overrides any `main`, `types`, `exports`, and `typesVersions` the package’s `package.json` file defines, and imports from the package may fail at runtime.\n\nThe same caveat applies to packages referencing each other in a monorepo. Instead of using `paths` to make TypeScript artificially resolve `\"@my-scope/lib\"` to a sibling package, it’s best to use workspaces via [npm](https://docs.npmjs.com/cli/v7/using-npm/workspaces), [yarn](https://classic.yarnpkg.com/en/docs/workspaces/), or [pnpm](https://pnpm.io/workspaces) to symlink your packages into `node_modules`, so both TypeScript and the runtime or bundler perform real `node_modules` package lookups. This is especially important if the monorepo packages will be published to npm—the packages will reference each other via `node_modules` package lookups once installed by users, and using workspaces allows you to test that behavior during local development.\n\n##### [](#relationship-to-baseurl)Relationship to `baseUrl`\n\nWhen [`baseUrl`](#baseurl) is provided, the values in each `paths` array are resolved relative to the `baseUrl`. Otherwise, they are resolved relative to the `tsconfig.json` file that defines them.\n\n##### [](#wildcard-substitutions)Wildcard substitutions\n\n`paths` patterns can contain a single `*` wildcard, which matches any string. The `*` token can then be used in the file path values to substitute the matched string:\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"paths\": {`\n\n      `\"@app/*\": [\"./src/*\"]`\n\n    `}`\n\n  `}`\n\n`}`\n\nWhen resolving an import of `\"@app/components/Button\"`, TypeScript will match on `@app/*`, binding `*` to `components/Button`, and then attempt to resolve the path `./src/components/Button` relative to the `tsconfig.json` path. The remainder of this lookup will follow the same rules as any other [relative path lookup](#relative-file-path-resolution) according to the `moduleResolution` setting.\n\nWhen multiple patterns match a module specifier, the pattern with the longest matching prefix before any `*` token is used:\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"paths\": {`\n\n      `\"*\": [\"./src/foo/one.ts\"],`\n\n      `\"foo/*\": [\"./src/foo/two.ts\"],`\n\n      `\"foo/bar\": [\"./src/foo/three.ts\"]`\n\n    `}`\n\n  `}`\n\n`}`\n\nWhen resolving an import of `\"foo/bar\"`, all three `paths` patterns match, but the last is used because `\"foo/bar\"` is longer than `\"foo/\"` and `\"\"`.\n\n##### [](#fallbacks)Fallbacks\n\nMultiple file paths can be provided for a path mapping. If resolution fails for one path, the next one in the array will be attempted until resolution succeeds or the end of the array is reached.\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"paths\": {`\n\n      `\"*\": [\"./vendor/*\", \"./types/*\"]`\n\n    `}`\n\n  `}`\n\n`}`\n\n#### [](#baseurl)`baseUrl`\n\n> `baseUrl` was designed for use with AMD module loaders. If you aren’t using an AMD module loader, you probably shouldn’t use `baseUrl`. Since TypeScript 4.1, `baseUrl` is no longer required to use [`paths`](#paths) and should not be used just to set the directory `paths` values are resolved from.\n\nThe `baseUrl` compiler option can be combined with any `moduleResolution` mode and specifies a directory that bare specifiers (module specifiers that don’t begin with `./`, `../`, or `/`) are resolved from. `baseUrl` has a higher precedence than [`node_modules` package lookups](#node_modules-package-lookups) in `moduleResolution` modes that support them.\n\nWhen performing a `baseUrl` lookup, resolution proceeds with the same rules as other relative path resolutions. For example, in a `moduleResolution` mode that supports [extensionless relative paths](#extensionless-relative-paths) a module specifier `\"some-file\"` may resolve to `/src/some-file.ts` if `baseUrl` is set to `/src`.\n\nResolution of relative module specifiers are never affected by the `baseUrl` option.\n\n#### [](#node_modules-package-lookups)`node_modules` package lookups\n\nNode.js treats module specifiers that aren’t relative paths, absolute paths, or URLs as references to packages that it looks up in `node_modules` subdirectories. Bundlers conveniently adopted this behavior to allow their users to use the same dependency management system, and often even the same dependencies, as they would in Node.js. All of TypeScript’s `moduleResolution` options except `classic` support `node_modules` lookups. (`classic` supports lookups in `node_modules/@types` when other means of resolution fail, but never looks for packages in `node_modules` directly.) Every `node_modules` package lookup has the following structure (beginning after higher precedence bare specifier rules, like `paths`, `baseUrl`, self-name imports, and package.json `\"imports\"` lookups have been exhausted):\n\n1.  For each ancestor directory of the importing file, if a `node_modules` directory exists within it:\n    1.  If a directory with the same name as the package exists within `node_modules`:\n        1.  Attempt to resolve types from the package directory.\n        2.  If a result is found, return it and stop the search.\n    2.  If a directory with the same name as the package exists within `node_modules/@types`:\n        1.  Attempt to resolve types from the `@types` package directory.\n        2.  If a result is found, return it and stop the search.\n2.  Repeat the previous search through all `node_modules` directories, but this time, allow JavaScript files as a result, and do not search in `@types` directories.\n\nAll `moduleResolution` modes (except `classic`) follow this pattern, while the details of how they resolve from a package directory, once located, differ, and are explained in the following sections.\n\n#### [](#packagejson-exports)package.json `\"exports\"`\n\nWhen `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and `resolvePackageJsonExports` is not disabled, TypeScript follows Node.js’s [package.json `\"exports\"` spec](https://nodejs.org/api/packages.html#packages_package_entry_points) when resolving from a package directory triggered by a [bare specifier `node_modules` package lookup](#node_modules-package-lookups).\n\nTypeScript’s implementation for resolving a module specifier through `\"exports\"` to a file path follows Node.js exactly. Once a file path is resolved, however, TypeScript will still [try multiple file extensions](#file-extension-substitution) in order to prioritize finding types.\n\nWhen resolving through [conditional `\"exports\"`](https://nodejs.org/api/packages.html#conditional-exports), TypeScript always matches the `\"types\"` and `\"default\"` conditions if present. Additionally, TypeScript will match a versioned types condition in the form `\"types@{selector}\"` (where `{selector}` is a `\"typesVersions\"`\\-compatible version selector) according to the same version-matching rules implemented in [`\"typesVersions\"`](#packagejson-typesversions). Other non-configurable conditions are dependent on the `moduleResolution` mode and specified in the following sections. Additional conditions can be configured to match with the `customConditions` compiler option.\n\nNote that the presence of `\"exports\"` prevents any subpaths not explicitly listed or matched by a pattern in `\"exports\"` from being resolved.\n\n##### [](#example-subpaths-conditions-and-extension-substitution)Example: subpaths, conditions, and extension substitution\n\nScenario: `\"pkg/subpath\"` is requested with conditions `[\"types\", \"node\", \"require\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\njson\n\n`{`\n\n  `\"name\": \"pkg\",`\n\n  `\"exports\": {`\n\n    `\".\": {`\n\n      `\"import\": \"./index.mjs\",`\n\n      `\"require\": \"./index.cjs\"`\n\n    `},`\n\n    `\"./subpath\": {`\n\n      `\"import\": \"./subpath/index.mjs\",`\n\n      `\"require\": \"./subpath/index.cjs\"`\n\n    `}`\n\n  `}`\n\n`}`\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./subpath\"` entry? **Yes.**\n3.  The value at `exports[\"./subpath\"]` is an object—it must be specifying conditions.\n4.  Does the first condition `\"import\"` match this request? **No.**\n5.  Does the second condition `\"require\"` match this request? **Yes.**\n6.  Does the path `\"./subpath/index.cjs\"` have a recognized TypeScript file extension? **No, so use extension substitution.**\n7.  Via [extension substitution](#file-extension-substitution), try the following paths, returning the first one that exists, or `undefined` otherwise:\n    1.  `./subpath/index.cts`\n    2.  `./subpath/index.d.cts`\n    3.  `./subpath/index.cjs`\n\nIf `./subpath/index.cts` or `./subpath.d.cts` exists, resolution is complete. Otherwise, resolution searches `node_modules/@types/pkg` and other `node_modules` directories in an attempt to resolve types, according to the [`node_modules` package lookups](#node_modules-package-lookups) rules. If no types are found, a second pass through all `node_modules` resolves to `./subpath/index.cjs` (assuming it exists), which counts as a successful resolution, but one that does not provide types, leading to `any`\\-typed imports and a `noImplicitAny` error if enabled.\n\n##### [](#example-explicit-types-condition)Example: explicit `\"types\"` condition\n\nScenario: `\"pkg/subpath\"` is requested with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\njson\n\n`{`\n\n  `\"name\": \"pkg\",`\n\n  `\"exports\": {`\n\n    `\"./subpath\": {`\n\n      `\"import\": {`\n\n        `\"types\": \"./types/subpath/index.d.mts\",`\n\n        `\"default\": \"./es/subpath/index.mjs\"`\n\n      `},`\n\n      `\"require\": {`\n\n        `\"types\": \"./types/subpath/index.d.cts\",`\n\n        `\"default\": \"./cjs/subpath/index.cjs\"`\n\n      `}`\n\n    `}`\n\n  `}`\n\n`}`\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./subpath\"` entry? **Yes.**\n3.  The value at `exports[\"./subpath\"]` is an object—it must be specifying conditions.\n4.  Does the first condition `\"import\"` match this request? **Yes.**\n5.  The value at `exports[\"./subpath\"].import` is an object—it must be specifying conditions.\n6.  Does the first condition `\"types\"` match this request? **Yes.**\n7.  Does the path `\"./types/subpath/index.d.mts\"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n8.  Return the path `\"./types/subpath/index.d.mts\"` if the file exists, `undefined` otherwise.\n\n##### [](#example-versioned-types-condition)Example: versioned `\"types\"` condition\n\nScenario: using TypeScript 4.7.5, `\"pkg/subpath\"` is requested with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\njson\n\n`{`\n\n  `\"name\": \"pkg\",`\n\n  `\"exports\": {`\n\n    `\"./subpath\": {`\n\n      `\"types@>=5.2\": \"./ts5.2/subpath/index.d.ts\",`\n\n      `\"types@>=4.6\": \"./ts4.6/subpath/index.d.ts\",`\n\n      `\"types\": \"./tsold/subpath/index.d.ts\",`\n\n      `\"default\": \"./dist/subpath/index.js\"`\n\n    `}`\n\n  `}`\n\n`}`\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./subpath\"` entry? **Yes.**\n3.  The value at `exports[\"./subpath\"]` is an object—it must be specifying conditions.\n4.  Does the first condition `\"types@>=5.2\"` match this request? **No, 4.7.5 is not greater than or equal to 5.2.**\n5.  Does the second condition `\"types@>=4.6\"` match this request? **Yes, 4.7.5 is greater than or equal to 4.6.**\n6.  Does the path `\"./ts4.6/subpath/index.d.ts\"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n7.  Return the path `\"./ts4.6/subpath/index.d.ts\"` if the file exists, `undefined` otherwise.\n\n##### [](#example-subpath-patterns)Example: subpath patterns\n\nScenario: `\"pkg/wildcard.js\"` is requested with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\njson\n\n`{`\n\n  `\"name\": \"pkg\",`\n\n  `\"type\": \"module\",`\n\n  `\"exports\": {`\n\n    `\"./*.js\": {`\n\n      `\"types\": \"./types/*.d.ts\",`\n\n      `\"default\": \"./dist/*.js\"`\n\n    `}`\n\n  `}`\n\n`}`\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./wildcard.js\"` entry? **No.**\n3.  Does any key with a `*` in it match `\"./wildcard.js\"`? **Yes, `\"./*.js\"` matches and sets `wildcard` to be the substitution.**\n4.  The value at `exports[\"./*.js\"]` is an object—it must be specifying conditions.\n5.  Does the first condition `\"types\"` match this request? **Yes.**\n6.  In `./types/*.d.ts`, replace `*` with the substitution `wildcard`. **`./types/wildcard.d.ts`**\n7.  Does the path `\"./types/wildcard.d.ts\"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n8.  Return the path `\"./types/wildcard.d.ts\"` if the file exists, `undefined` otherwise.\n\n##### [](#example-exports-block-other-subpaths)Example: `\"exports\"` block other subpaths\n\nScenario: `\"pkg/dist/index.js\"` is requested in a package directory with the following package.json:\n\njson\n\n`{`\n\n  `\"name\": \"pkg\",`\n\n  `\"main\": \"./dist/index.js\",`\n\n  `\"exports\": \"./dist/index.js\"`\n\n`}`\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  The value at `exports` is a string—it must be a file path for the package root (`\".\"`).\n3.  Is the request `\"pkg/dist/index.js\"` for the package root? **No, it has a subpath `dist/index.js`.**\n4.  Resolution fails; return `undefined`.\n\nWithout `\"exports\"`, the request could have succeeded, but the presence of `\"exports\"` prevents resolving any subpaths that cannot be matched through `\"exports\"`.\n\n#### [](#packagejson-typesversions)package.json `\"typesVersions\"`\n\nA [`node_modules` package](#node_modules-package-lookups) or [directory module](#directory-modules-index-file-resolution) may specify a `\"typesVersions\"` field in its package.json to redirect TypeScript’s resolution process according to the TypeScript compiler version, and for `node_modules` packages, according to the subpath being resolved. This allows package authors to include new TypeScript syntax in one set of type definitions while providing another set for backward compatibility with older TypeScript versions (through a tool like [downlevel-dts](https://github.com/sandersn/downlevel-dts)). `\"typesVersions\"` is supported in all `moduleResolution` modes; however, the field is not read in situations when [package.json `\"exports\"`](#packagejson-exports) are read.\n\n##### [](#example-redirect-all-requests-to-a-subdirectory)Example: redirect all requests to a subdirectory\n\nScenario: a module imports `\"pkg\"` using TypeScript 5.2, where `node_modules/pkg/package.json` is:\n\njson\n\n`{`\n\n  `\"name\": \"pkg\",`\n\n  `\"version\": \"1.0.0\",`\n\n  `\"types\": \"./index.d.ts\",`\n\n  `\"typesVersions\": {`\n\n    `\">=3.1\": {`\n\n      `\"*\": [\"ts3.1/*\"]`\n\n    `}`\n\n  `}`\n\n`}`\n\nResolution process:\n\n1.  (Depending on compiler options) Does `\"exports\"` exist? **No.**\n2.  Does `\"typesVersions\"` exist? **Yes.**\n3.  Is the TypeScript version `>=3.1`? **Yes. Remember the mapping `\"*\": [\"ts3.1/*\"]`.**\n4.  Are we resolving a subpath after the package name? **No, just the root `\"pkg\"`.**\n5.  Does `\"types\"` exist? **Yes.**\n6.  Does any key in `\"typesVersions\"` match `./index.d.ts`? **Yes, `\"*\"` matches and sets `index.d.ts` to be the substitution.**\n7.  In `ts3.1/*`, replace `*` with the substitution `./index.d.ts`: **`ts3.1/index.d.ts`**.\n8.  Does the path `./ts3.1/index.d.ts` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n9.  Return the path `./ts3.1/index.d.ts` if the file exists, `undefined` otherwise.\n\n##### [](#example-redirect-requests-for-a-specific-file)Example: redirect requests for a specific file\n\nScenario: a module imports `\"pkg\"` using TypeScript 3.9, where `node_modules/pkg/package.json` is:\n\njson\n\n`{`\n\n  `\"name\": \"pkg\",`\n\n  `\"version\": \"1.0.0\",`\n\n  `\"types\": \"./index.d.ts\",`\n\n  `\"typesVersions\": {`\n\n    `\"<4.0\": { \"index.d.ts\": [\"index.v3.d.ts\"] }`\n\n  `}`\n\n`}`\n\nResolution process:\n\n1.  (Depending on compiler options) Does `\"exports\"` exist? **No.**\n2.  Does `\"typesVersions\"` exist? **Yes.**\n3.  Is the TypeScript version `<4.0`? **Yes. Remember the mapping `\"index.d.ts\": [\"index.v3.d.ts\"]`.**\n4.  Are we resolving a subpath after the package name? **No, just the root `\"pkg\"`.**\n5.  Does `\"types\"` exist? **Yes.**\n6.  Does any key in `\"typesVersions\"` match `./index.d.ts`? **Yes, `\"index.d.ts\"` matches.**\n7.  Does the path `./index.v3.d.ts` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n8.  Return the path `./index.v3.d.ts` if the file exists, `undefined` otherwise.\n\n#### [](#packagejson-main-and-types)package.json `\"main\"` and `\"types\"`\n\nIf a directory’s [package.json `\"exports\"`](#packagejson-exports) field is not read (either due to compiler options, or because it is not present, or because the directory is being resolved as a [directory module](#directory-modules-index-file-resolution) instead of a [`node_modules` package](#node_modules-package-lookups)) and the module specifier does not have a subpath after the package name or package.json-containing directory, TypeScript will attempt to resolve from these package.json fields, in order, in an attempt to find the main module for the package or directory:\n\n*   `\"types\"`\n*   `\"typings\"` (legacy)\n*   `\"main\"`\n\nThe declaration file found at `\"types\"` is assumed to be an accurate representation of the implementation file found at `\"main\"`. If `\"types\"` and `\"typings\"` are not present or cannot be resolved, TypeScript will read the `\"main\"` field and perform [extension substitution](#file-extension-substitution) to find a declaration file.\n\nWhen publishing a typed package to npm, it’s recommended to include a `\"types\"` field even if [extension substitution](#file-extension-substitution) or [package.json `\"exports\"`](#packagejson-exports) make it unnecessary, because npm shows a TS icon on the package registry listing only if the package.json contains a `\"types\"` field.\n\n#### [](#package-relative-file-paths)Package-relative file paths\n\nIf neither [package.json `\"exports\"`](#packagejson-exports) nor [package.json `\"typesVersions\"`](#packagejson-typesversions) apply, subpaths of a bare package specifier resolve relative to the package directory, according to applicable [relative path](#relative-file-path-resolution) resolution rules. In modes that respect \\[package.json `\"exports\"`\\], this behavior is blocked by the mere presence of the `\"exports\"` field in the package’s package.json, even if the import fails to resolve through `\"exports\"`, as demonstrated in [an example above](#example-exports-block-other-subpaths). On the other hand, if the import fails to resolve through `\"typesVersions\"`, a package-relative file path resolution is attempted as a fallback.\n\nWhen package-relative paths are supported, they resolve under the same rules as any other relative path considering the `moduleResolution` mode and context. For example, in [`--moduleResolution nodenext`](#node16-nodenext-1), [directory modules](#directory-modules-index-file-resolution) and [extensionless paths](#extensionless-relative-paths) are only supported in `require` calls, not in `import`s:\n\nts\n\n`// @Filename: module.mts`\n\n``import \"pkg/dist/foo\";                // ❌ import, needs `.js` extension``\n\n`import \"pkg/dist/foo.js\";             // ✅`\n\n`import foo = require(\"pkg/dist/foo\"); // ✅ require, no extension needed`\n\n#### [](#packagejson-imports-and-self-name-imports)package.json `\"imports\"` and self-name imports\n\nWhen `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and `resolvePackageJsonImports` is not disabled, TypeScript will attempt to resolve import paths beginning with `#` through the `\"imports\"` field of the nearest ancestor package.json of the importing file. Similarly, when [package.json `\"exports\"` lookups](#packagejson-exports) are enabled, TypeScript will attempt to resolve import paths beginning with the current package name—that is, the value in the `\"name\"` field of the nearest ancestor package.json of the importing file—through the `\"exports\"` field of that package.json. Both of these features allow files in a package to import other files in the same package, replacing a relative import path.\n\nTypeScript follows Node.js’s resolution algorithm for [`\"imports\"`](https://nodejs.org/api/packages.html#subpath-imports) and [self references](https://nodejs.org/api/packages.html#self-referencing-a-package-using-its-name) exactly up until a file path is resolved. At that point, TypeScript’s resolution algorithm forks based on whether the package.json containing the `\"imports\"` or `\"exports\"` being resolved belongs to a `node_modules` dependency or the local project being compiled (i.e., its directory contains the tsconfig.json file for the project that contains the importing file):\n\n*   If the package.json is in `node_modules`, TypeScript will apply [extension substitution](#file-extension-substitution) to the file path if it doesn’t already have a recognized TypeScript file extension, and check for the existence of the resulting file paths.\n*   If the package.json is part of the local project, an additional remapping step is performed in order to find the _input_ TypeScript implementation file that will eventually produce the output JavaScript or declaration file path that was resolved from `\"imports\"`. Without this step, any compilation that resolves an `\"imports\"` path would be referencing output files from the _previous compilation_ instead of other input files that are intended to be included in the current compilation. This remapping uses the `outDir`/`declarationDir` and `rootDir` from the tsconfig.json, so using `\"imports\"` usually requires an explicit `rootDir` to be set.\n\nThis variation allows package authors to write `\"imports\"` and `\"exports\"` fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.\n\n##### [](#example-local-project-with-conditions)Example: local project with conditions\n\nScenario: `\"/src/main.mts\"` imports `\"#utils\"` with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:\n\njson\n\n`// tsconfig.json`\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"moduleResolution\": \"node16\",`\n\n    `\"resolvePackageJsonImports\": true,`\n\n    `\"rootDir\": \"./src\",`\n\n    `\"outDir\": \"./dist\"`\n\n  `}`\n\n`}`\n\njson\n\n`// package.json`\n\n`{`\n\n  `\"name\": \"pkg\",`\n\n  `\"imports\": {`\n\n    `\"#utils\": {`\n\n      `\"import\": \"./dist/utils.d.mts\",`\n\n      `\"require\": \"./dist/utils.d.cts\"`\n\n    `}`\n\n  `}`\n\n`}`\n\nResolution process:\n\n1.  Import path starts with `#`, try to resolve through `\"imports\"`.\n2.  Does `\"imports\"` exist in the nearest ancestor package.json? **Yes.**\n3.  Does `\"#utils\"` exist in the `\"imports\"` object? **Yes.**\n4.  The value at `imports[\"#utils\"]` is an object—it must be specifying conditions.\n5.  Does the first condition `\"import\"` match this request? **Yes.**\n6.  Should we attempt to map the output path to an input path? **Yes, because:**\n    *   Is the package.json in `node_modules`? **No, it’s in the local project.**\n    *   Is the tsconfig.json within the package.json directory? **Yes.**\n7.  In `./dist/utils.d.mts`, replace the `outDir` prefix with `rootDir`. **`./src/utils.d.mts`**\n8.  Replace the output extension `.d.mts` with the corresponding input extension `.mts`. **`./src/utils.mts`**\n9.  Return the path `\"./src/utils.mts\"` if the file exists.\n10.  Otherwise, return the path `\"./dist/utils.d.mts\"` if the file exists.\n\n##### [](#example-node_modules-dependency-with-subpath-pattern)Example: `node_modules` dependency with subpath pattern\n\nScenario: `\"/node_modules/pkg/main.mts\"` imports `\"#internal/utils\"` with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) with the package.json:\n\njson\n\n`// /node_modules/pkg/package.json`\n\n`{`\n\n  `\"name\": \"pkg\",`\n\n  `\"imports\": {`\n\n    `\"#internal/*\": {`\n\n      `\"import\": \"./dist/internal/*.mjs\",`\n\n      `\"require\": \"./dist/internal/*.cjs\"`\n\n    `}`\n\n  `}`\n\n`}`\n\nResolution process:\n\n1.  Import path starts with `#`, try to resolve through `\"imports\"`.\n2.  Does `\"imports\"` exist in the nearest ancestor package.json? **Yes.**\n3.  Does `\"#internal/utils\"` exist in the `\"imports\"` object? **No, check for pattern matches.**\n4.  Does any key with a `*` match `\"#internal/utils\"`? **Yes, `\"#internal/*\"` matches and sets `utils` to be the substitution.**\n5.  The value at `imports[\"#internal/*\"]` is an object—it must be specifying conditions.\n6.  Does the first condition `\"import\"` match this request? **Yes.**\n7.  Should we attempt to map the output path to an input path? **No, because the package.json is in `node_modules`.**\n8.  In `./dist/internal/*.mjs`, replace `*` with the substitution `utils`. **`./dist/internal/utils.mjs`**\n9.  Does the path `./dist/internal/utils.mjs` have a recognized TypeScript file extension? **No, try extension substitution.**\n10.  Via [extension substitution](#file-extension-substitution), try the following paths, returning the first one that exists, or `undefined` otherwise:\n    1.  `./dist/internal/utils.mts`\n    2.  `./dist/internal/utils.d.mts`\n    3.  `./dist/internal/utils.mjs`\n\n### [](#node16-nodenext-1)`node16`, `nodenext`\n\nThese modes reflect the module resolution behavior of Node.js v12 and later. (`node16` and `nodenext` are currently identical, but if Node.js makes significant changes to its module system in the future, `node16` will be frozen while `nodenext` will be updated to reflect the new behavior.) In Node.js, the resolution algorithm for ECMAScript imports is significantly different from the algorithm for CommonJS `require` calls. For each module specifier being resolved, the syntax and the [module format of the importing file](#module-format-detection) are first used to determine whether the module specifier will be in an `import` or `require` in the emitted JavaScript. That information is then passed into the module resolver to determine which resolution algorithm to use (and whether to use the `\"import\"` or `\"require\"` condition for package.json [`\"exports\"`](#packagejson-exports) or [`\"imports\"`](#packagejson-imports-and-self-name-imports)).\n\n> TypeScript files that are [determined to be in CommonJS format](#module-format-detection) may still use `import` and `export` syntax by default, but the emitted JavaScript will use `require` and `module.exports` instead. This means that it’s common to see `import` statements that are resolved using the `require` algorithm. If this causes confusion, the `verbatimModuleSyntax` compiler option can be enabled, which prohibits the use of `import` statements that would be emitted as `require` calls.\n\nNote that dynamic `import()` calls are always resolved using the `import` algorithm, according to Node.js’s behavior. However, `import()` types are resolved according to the format of the importing file (for backward compatibility with existing CommonJS-format type declarations):\n\nts\n\n`// @Filename: module.mts`\n\n``import x from \"./mod.js\";             // `import` algorithm due to file format (emitted as-written)``\n\n``import(\"./mod.js\");                   // `import` algorithm due to syntax (emitted as-written)``\n\n``type Mod = typeof import(\"./mod.js\"); // `import` algorithm due to file format``\n\n``import mod = require(\"./mod\");        // `require` algorithm due to syntax (emitted as `require`)``\n\n`// @Filename: commonjs.cts`\n\n``import x from \"./mod\";                // `require` algorithm due to file format (emitted as `require`)``\n\n``import(\"./mod.js\");                   // `import` algorithm due to syntax (emitted as-written)``\n\n``type Mod = typeof import(\"./mod\");    // `require` algorithm due to file format``\n\n``import mod = require(\"./mod\");        // `require` algorithm due to syntax (emitted as `require`)``\n\n#### [](#implied-and-enforced-options-2)Implied and enforced options\n\n*   `--moduleResolution node16` and `nodenext` must be paired with their [corresponding `module` value](#node16-nodenext).\n\n#### [](#supported-features)Supported features\n\nFeatures are listed in order of precedence.\n\n`import`\n\n`require`\n\n[`paths`](#paths)\n\n✅\n\n✅\n\n[`baseUrl`](#baseurl)\n\n✅\n\n✅\n\n[`node_modules` package lookups](#node_modules-package-lookups)\n\n✅\n\n✅\n\n[package.json `\"exports\"`](#packagejson-exports)\n\n✅ matches `types`, `node`, `import`\n\n✅ matches `types`, `node`, `require`\n\n[package.json `\"imports\"` and self-name imports](#packagejson-imports-and-self-name-imports)\n\n✅ matches `types`, `node`, `import`\n\n✅ matches `types`, `node`, `require`\n\n[package.json `\"typesVersions\"`](#packagejson-typesversions)\n\n✅\n\n✅\n\n[Package-relative paths](#package-relative-file-paths)\n\n✅ when `exports` not present\n\n✅ when `exports` not present\n\n[Full relative paths](#relative-file-path-resolution)\n\n✅\n\n✅\n\n[Extensionless relative paths](#extensionless-relative-paths)\n\n❌\n\n✅\n\n[Directory modules](#directory-modules-index-file-resolution)\n\n❌\n\n✅\n\n### [](#bundler)`bundler`\n\n`--moduleResolution bundler` attempts to model the module resolution behavior common to most JavaScript bundlers. In short, this means supporting all the behaviors traditionally associated with Node.js’s CommonJS `require` resolution algorithm like [`node_modules` lookups](#node_modules-package-lookups), [directory modules](#directory-modules-index-file-resolution), and [extensionless paths](#extensionless-relative-paths), while also supporting newer Node.js resolution features like [package.json `\"exports\"`](#packagejson-exports) and [package.json `\"imports\"`](#packagejson-imports-and-self-name-imports).\n\nIt’s instructive to think about the similarities and differences between `--moduleResolution bundler` and `--moduleResolution nodenext`, particularly in how they decide what conditions to use when resolving package.json `\"exports\"` or `\"imports\"`. Consider an import statement in a `.ts` file:\n\nts\n\n`// index.ts`\n\n`import { foo } from \"pkg\";`\n\nRecall that in `--module nodenext --moduleResolution nodenext`, the `--module` setting first [determines](#module-format-detection) whether the import will be emitted to the `.js` file as an `import` or `require` call, then passes that information to TypeScript’s module resolver, which decides whether to match `\"import\"` or `\"require\"` conditions in `\"pkg\"`’s package.json `\"exports\"` accordingly. Let’s assume that there’s no package.json in scope of this file. The file extension is `.ts`, so the output file extension will be `.js`, which Node.js will interpret as CommonJS, so TypeScript will emit this `import` as a `require` call. So, the module resolver will use the `require` condition as it resolves `\"exports\"` from `\"pkg\"`.\n\nThe same process happens in `--moduleResolution bundler`, but the rules for deciding whether to emit an `import` or `require` call for this import statement will be different, since `--moduleResolution bundler` necessitates using [`--module esnext`](#es2015-es2020-es2022-esnext) or [`--module preserve`](#preserve). In both of those modes, ESM `import` declarations always emit as ESM `import` declarations, so TypeScript’s module resolver will receive that information and use the `\"import\"` condition as it resolves `\"exports\"` from `\"pkg\"`.\n\nThis explanation may be somewhat unintuitive, since `--moduleResolution bundler` is usually used in combination with `--noEmit`—bundlers typically process raw `.ts` files and perform module resolution on untransformed `import`s or `require`s. However, for consistency, TypeScript still uses the hypothetical emit decided by `module` to inform module resolution and type checking. This makes [`--module preserve`](#preserve) the best choice whenever a runtime or bundler is operating on raw `.ts` files, since it implies no transformation. Under `--module preserve --moduleResolution bundler`, you can write imports and requires in the same file that will resolve with the `import` and `require` conditions, respectively:\n\nts\n\n`// index.ts`\n\n`import pkg1 from \"pkg\";       // Resolved with \"import\" condition`\n\n`import pkg2 = require(\"pkg\"); // Resolved with \"require\" condition`\n\n#### [](#implied-and-enforced-options-3)Implied and enforced options\n\n*   `--moduleResolution bundler` must be paired with `--module esnext` or `--module preserve`.\n*   `--moduleResolution bundler` implies `--allowSyntheticDefaultImports`.\n\n#### [](#supported-features-1)Supported features\n\n*   [`paths`](#paths) ✅\n*   [`baseUrl`](#baseurl) ✅\n*   [`node_modules` package lookups](#node_modules-package-lookups) ✅\n*   [package.json `\"exports\"`](#packagejson-exports) ✅ matches `types`, `import`/`require` depending on syntax\n*   [package.json `\"imports\"` and self-name imports](#packagejson-imports-and-self-name-imports) ✅ matches `types`, `import`/`require` depending on syntax\n*   [package.json `\"typesVersions\"`](#packagejson-typesversions) ✅\n*   [Package-relative paths](#package-relative-file-paths) ✅ when `exports` not present\n*   [Full relative paths](#relative-file-path-resolution) ✅\n*   [Extensionless relative paths](#extensionless-relative-paths) ✅\n*   [Directory modules](#directory-modules-index-file-resolution) ✅\n\n### [](#node10-formerly-known-as-node)`node10` (formerly known as `node`)\n\n`--moduleResolution node` was renamed to `node10` (keeping `node` as an alias for backward compatibility) in TypeScript 5.0. It reflects the CommonJS module resolution algorithm as it existed in Node.js versions earlier than v12. It should no longer be used.\n\n#### [](#supported-features-2)Supported features\n\n*   [`paths`](#paths) ✅\n*   [`baseUrl`](#baseurl) ✅\n*   [`node_modules` package lookups](#node_modules-package-lookups) ✅\n*   [package.json `\"exports\"`](#packagejson-exports) ❌\n*   [package.json `\"imports\"` and self-name imports](#packagejson-imports-and-self-name-imports) ❌\n*   [package.json `\"typesVersions\"`](#packagejson-typesversions) ✅\n*   [Package-relative paths](#package-relative-file-paths) ✅\n*   [Full relative paths](#relative-file-path-resolution) ✅\n*   [Extensionless relative paths](#extensionless-relative-paths) ✅\n*   [Directory modules](#directory-modules-index-file-resolution) ✅\n\n### [](#classic)`classic`\n\nDo not use `classic`.",
    "title": "TypeScript: Documentation - Modules - Reference",
    "description": "Module syntax and compiler options reference",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html",
    "markdown": "# TypeScript: Documentation - Migrating from JavaScript\n\nTypeScript doesn’t exist in a vacuum. It was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today. Converting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging. In this tutorial, we’re going to look at how you might start out. We assume you’ve read enough of the handbook to write new TypeScript code.\n\nIf you’re looking to convert a React project, we recommend looking at the [React Conversion Guide](https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide) first.\n\n## [](#setting-up-your-directories)Setting up your Directories\n\nIf you’re writing in plain JavaScript, it’s likely that you’re running your JavaScript directly, where your `.js` files are in a `src`, `lib`, or `dist` directory, and then run as desired.\n\nIf that’s the case, the files that you’ve written are going to be used as inputs to TypeScript, and you’ll run the outputs it produces. During our JS to TS migration, we’ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.\n\nYou might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.\n\nFrom this point on, we’re going to assume that your directory is set up something like this:\n\n`projectRoot`\n\n`├── src`\n\n`│   ├── file1.js`\n\n`│   └── file2.js`\n\n`├── built`\n\n`└── tsconfig.json`\n\nIf you have a `tests` folder outside of your `src` directory, you might have one `tsconfig.json` in `src`, and one in `tests` as well.\n\n## [](#writing-a-configuration-file)Writing a Configuration File\n\nTypeScript uses a file called `tsconfig.json` for managing your project’s options, such as which files you want to include, and what sorts of checking you want to perform. Let’s create a bare-bones one for our project:\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"outDir\": \"./built\",`\n\n    `\"allowJs\": true,`\n\n    `\"target\": \"es5\"`\n\n  `},`\n\n  `\"include\": [\"./src/**/*\"]`\n\n`}`\n\nHere we’re specifying a few things to TypeScript:\n\n1.  Read in any files it understands in the `src` directory (with [`include`](https://www.typescriptlang.org/tsconfig#include)).\n2.  Accept JavaScript files as inputs (with [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)).\n3.  Emit all of the output files in `built` (with [`outDir`](https://www.typescriptlang.org/tsconfig#outDir)).\n4.  Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using [`target`](https://www.typescriptlang.org/tsconfig#target)).\n\nAt this point, if you try running `tsc` at the root of your project, you should see output files in the `built` directory. The layout of files in `built` should look identical to the layout of `src`. You should now have TypeScript working with your project.\n\n## [](#early-benefits)Early Benefits\n\nEven at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like [VS Code](https://code.visualstudio.com/) or [Visual Studio](https://visualstudio.com/), you’ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:\n\n*   [`noImplicitReturns`](https://www.typescriptlang.org/tsconfig#noImplicitReturns) which prevents you from forgetting to return at the end of a function.\n*   [`noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch) which is helpful if you never want to forget a `break` statement between `case`s in a `switch` block.\n\nTypeScript will also warn about unreachable code and labels, which you can disable with [`allowUnreachableCode`](https://www.typescriptlang.org/tsconfig#allowUnreachableCode) and [`allowUnusedLabels`](https://www.typescriptlang.org/tsconfig#allowUnusedLabels) respectively.\n\nYou might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we’ll do our best to cover the gist of things.\n\n### [](#gulp)Gulp\n\nIf you’re using Gulp in some fashion, we have a tutorial on [using Gulp](https://www.typescriptlang.org/docs/handbook/gulp.html) with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.\n\n### [](#webpack)Webpack\n\nWebpack integration is pretty simple. You can use `ts-loader`, a TypeScript loader, combined with `source-map-loader` for easier debugging. Simply run\n\nshell\n\n`npm install ts-loader source-map-loader`\n\nand merge in options from the following into your `webpack.config.js` file:\n\njs\n\n`module.exports = {`\n\n  `entry: \"./src/index.ts\",`\n\n  `output: {`\n\n    `filename: \"./dist/bundle.js\",`\n\n  `},`\n\n  `// Enable sourcemaps for debugging webpack's output.`\n\n  `devtool: \"source-map\",`\n\n  `resolve: {`\n\n    `// Add '.ts' and '.tsx' as resolvable extensions.`\n\n    `extensions: [\"\", \".webpack.js\", \".web.js\", \".ts\", \".tsx\", \".js\"],`\n\n  `},`\n\n  `module: {`\n\n    `rules: [`\n\n      `// All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'.`\n\n      `{ test: /\\.tsx?$/, loader: \"ts-loader\" },`\n\n      `// All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.`\n\n      `{ test: /\\.js$/, loader: \"source-map-loader\" },`\n\n    `],`\n\n  `},`\n\n  `// Other options...`\n\n`};`\n\nIt’s important to note that ts-loader will need to run before any other loader that deals with `.js` files.\n\nYou can see an example of using Webpack in our [tutorial on React and Webpack](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html).\n\n## [](#moving-to-typescript-files)Moving to TypeScript Files\n\nAt this point, you’re probably ready to start using TypeScript files. The first step is to rename one of your `.js` files to `.ts`. If your file uses JSX, you’ll need to rename it to `.tsx`.\n\nFinished with that step? Great! You’ve successfully migrated a file from JavaScript to TypeScript!\n\nOf course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run `tsc --pretty`), you might see red squiggles on certain lines. You should think of these the same way you’d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.\n\nIf that sounds too lax for you, you can tighten that behavior up. If, for instance, you _don’t_ want TypeScript to compile to JavaScript in the face of errors, you can use the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.\n\nIf you plan on using the stricter settings that are available, it’s best to turn them on now (see [Getting Stricter Checks](#getting-stricter-checks) below). For instance, if you never want TypeScript to silently infer `any` for a type without you explicitly saying so, you can use [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.\n\n### [](#weeding-out-errors)Weeding out Errors\n\nLike we mentioned, it’s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you’ll have to explain what you’re trying to do a little better to TypeScript.\n\n#### [](#importing-from-modules)Importing from Modules\n\nYou might start out getting a bunch of errors like `Cannot find name 'require'.`, and `Cannot find name 'define'.`. In these cases, it’s likely that you’re using modules. While you can just convince TypeScript that these exist by writing out\n\nts\n\n`// For Node/CommonJS`\n\n`declare function require(path: string): any;`\n\nor\n\nts\n\n`// For RequireJS/AMD`\n\n`declare function define(...args: any[]): any;`\n\nit’s better to get rid of those calls and use TypeScript syntax for imports.\n\nFirst, you’ll need to enable some module system by setting TypeScript’s [`module`](https://www.typescriptlang.org/tsconfig#module) option. Valid options are `commonjs`, `amd`, `system`, and `umd`.\n\nIf you had the following Node/CommonJS code:\n\njs\n\n`var foo = require(\"foo\");`\n\n`foo.doStuff();`\n\nor the following RequireJS/AMD code:\n\njs\n\n`define([\"foo\"], function (foo) {`\n\n  `foo.doStuff();`\n\n`});`\n\nthen you would write the following TypeScript code:\n\nts\n\n`import foo = require(\"foo\");`\n\n`foo.doStuff();`\n\n#### [](#getting-declaration-files)Getting Declaration Files\n\nIf you started converting over to TypeScript imports, you’ll probably run into errors like `Cannot find module 'foo'.`. The issue here is that you likely don’t have _declaration files_ to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like `lodash`, you can just write\n\nshell\n\n`npm install -S @types/lodash`\n\nIf you’re using a module option other than `commonjs`, you’ll need to set your [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution) option to `node`.\n\nAfter that, you’ll be able to import lodash with no issues, and get accurate completions.\n\n#### [](#exporting-from-modules)Exporting from Modules\n\nTypically, exporting from a module involves adding properties to a value like `exports` or `module.exports`. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:\n\njs\n\n`module.exports.feedPets = function (pets) {`\n\n  `// ...`\n\n`};`\n\nyou could write that out as the following:\n\nts\n\n`export function feedPets(pets) {`\n\n  `// ...`\n\n`}`\n\nSometimes you’ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:\n\njs\n\n`var express = require(\"express\");`\n\n`var app = express();`\n\nYou might have previously written that like so:\n\njs\n\n`function foo() {`\n\n  `// ...`\n\n`}`\n\n`module.exports = foo;`\n\nIn TypeScript, you can model this with the `export =` construct.\n\nts\n\n`function foo() {`\n\n  `// ...`\n\n`}`\n\n`export = foo;`\n\n#### [](#too-manytoo-few-arguments)Too many/too few arguments\n\nYou’ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the `arguments` object instead of writing out any parameters:\n\njs\n\n`function myCoolFunction() {`\n\n  `if (arguments.length == 2 && !Array.isArray(arguments[1])) {`\n\n    `var f = arguments[0];`\n\n    `var arr = arguments[1];`\n\n    `// ...`\n\n  `}`\n\n  `// ...`\n\n`}`\n\n`myCoolFunction(`\n\n  `function (x) {`\n\n    `console.log(x);`\n\n  `},`\n\n  `[1, 2, 3, 4]`\n\n`);`\n\n`myCoolFunction(`\n\n  `function (x) {`\n\n    `console.log(x);`\n\n  `},`\n\n  `1,`\n\n  `2,`\n\n  `3,`\n\n  `4`\n\n`);`\n\nIn this case, we need to use TypeScript to tell any of our callers about the ways `myCoolFunction` can be called using function overloads.\n\nts\n\n`function myCoolFunction(f: (x: number) => void, nums: number[]): void;`\n\n`function myCoolFunction(f: (x: number) => void, ...nums: number[]): void;`\n\n`function myCoolFunction() {`\n\n  `if (arguments.length == 2 && !Array.isArray(arguments[1])) {`\n\n    `var f = arguments[0];`\n\n    `var arr = arguments[1];`\n\n    `// ...`\n\n  `}`\n\n  `// ...`\n\n`}`\n\nWe added two overload signatures to `myCoolFunction`. The first checks states that `myCoolFunction` takes a function (which takes a `number`), and then a list of `number`s. The second one says that it will take a function as well, and then uses a rest parameter (`...nums`) to state that any number of arguments after that need to be `number`s.\n\n#### [](#sequentially-added-properties)Sequentially Added Properties\n\nSome people find it more aesthetically pleasing to create an object and add properties immediately after like so:\n\njs\n\n`var options = {};`\n\n`options.color = \"red\";`\n\n`options.volume = 11;`\n\nTypeScript will say that you can’t assign to `color` and `volume` because it first figured out the type of `options` as `{}` which doesn’t have any properties. If you instead moved the declarations into the object literal themselves, you’d get no errors:\n\nts\n\n`let options = {`\n\n  `color: \"red\",`\n\n  `volume: 11,`\n\n`};`\n\nYou could also define the type of `options` and add a type assertion on the object literal.\n\nts\n\n`interface Options {`\n\n  `color: string;`\n\n  `volume: number;`\n\n`}`\n\n`let options = {} as Options;`\n\n`options.color = \"red\";`\n\n`options.volume = 11;`\n\nAlternatively, you can just say `options` has the type `any` which is the easiest thing to do, but which will benefit you the least.\n\n#### [](#any-object-and-)`any`, `Object`, and `{}`\n\nYou might be tempted to use `Object` or `{}` to say that a value can have any property on it because `Object` is, for most purposes, the most general type. However **`any` is actually the type you want to use** in those situations, since it’s the most _flexible_ type.\n\nFor instance, if you have something that’s typed as `Object` you won’t be able to call methods like `toLowerCase()` on it. Being more general usually means you can do less with a type, but `any` is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use `any`, you lose out on most of the error checking and editor support that TypeScript gives you.\n\nIf a decision ever comes down to `Object` and `{}`, you should prefer `{}`. While they are mostly the same, technically `{}` is a more general type than `Object` in certain esoteric cases.\n\n### [](#getting-stricter-checks)Getting Stricter Checks\n\nTypeScript comes with certain checks to give you more safety and analysis of your program. Once you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.\n\n#### [](#no-implicit-any)No Implicit `any`\n\nThere are certain cases where TypeScript can’t figure out what certain types should be. To be as lenient as possible, it will decide to use the type `any` in its place. While this is great for migration, using `any` means that you’re not getting any type safety, and you won’t get the same tooling support you’d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) option.\n\n#### [](#strict-null--undefined-checks)Strict `null` & `undefined` Checks\n\nBy default, TypeScript assumes that `null` and `undefined` are in the domain of every type. That means anything declared with the type `number` could be `null` or `undefined`. Since `null` and `undefined` are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) option to spare you the stress of worrying about these issues.\n\nWhen [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is enabled, `null` and `undefined` get their own types called `null` and `undefined` respectively. Whenever anything is _possibly_ `null`, you can use a union type with the original type. So for instance, if something could be a `number` or `null`, you’d write the type out as `number | null`.\n\nIf you ever have a value that TypeScript thinks is possibly `null`/`undefined`, but you know better, you can use the postfix `!` operator to tell it otherwise.\n\nts\n\n`declare var foo: string[] | null;`\n\n`foo.length; // error - 'foo' is possibly 'null'`\n\n`foo!.length; // okay - 'foo!' just has type 'string[]'`\n\nAs a heads up, when using [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), your dependencies may need to be updated to use [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) as well.\n\n#### [](#no-implicit-any-for-this)No Implicit `any` for `this`\n\nWhen you use the `this` keyword outside of classes, it has the type `any` by default. For instance, imagine a `Point` class, and imagine a function that we wish to add as a method:\n\nts\n\n`class Point {`\n\n  `constructor(public x, public y) {}`\n\n  `getDistance(p: Point) {`\n\n    `let dx = p.x - this.x;`\n\n    `let dy = p.y - this.y;`\n\n    `return Math.sqrt(dx ** 2 + dy ** 2);`\n\n  `}`\n\n`}`\n\n`// ...`\n\n`// Reopen the interface.`\n\n`interface Point {`\n\n  `distanceFromOrigin(): number;`\n\n`}`\n\n`Point.prototype.distanceFromOrigin = function () {`\n\n  `return this.getDistance({ x: 0, y: 0 });`\n\n`};`\n\nThis has the same problems we mentioned above - we could easily have misspelled `getDistance` and not gotten an error. For this reason, TypeScript has the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis) option. When that option is set, TypeScript will issue an error when `this` is used without an explicit (or inferred) type. The fix is to use a `this`\\-parameter to give an explicit type in the interface or in the function itself:\n\nts\n\n`Point.prototype.distanceFromOrigin = function (this: Point) {`\n\n  `return this.getDistance({ x: 0, y: 0 });`\n\n`};`",
    "title": "TypeScript: Documentation - Migrating from JavaScript",
    "description": "How to migrate from JavaScript to TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html",
    "markdown": "# TypeScript: Documentation - Using Babel with TypeScript\n\n## [](#babel-vs-tsc-for-typescript)Babel vs `tsc` for TypeScript\n\nWhen making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript?\n\nA lot of the time the answer is _“it depends”_, or _“someone may have decided for you”_ depending on the project. If you are building your project with an existing framework like [tsdx](https://tsdx.io/), [Angular](https://angular.io/), [NestJS](https://nestjs.com/) or any framework mentioned in the [Getting Started](https://www.typescriptlang.org/docs/home) then this decision is handled for you.\n\nHowever, a useful heuristic could be:\n\n*   Is your build output mostly the same as your source input files? Use `tsc`\n*   Do you need a build pipeline with multiple potential outputs? Use `babel` for transpiling and `tsc` for type checking\n\n## [](#babel-for-transpiling-tsc-for-types)Babel for transpiling, `tsc` for types\n\nThis is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript.\n\nThis technique is a hybrid approach, using Babel’s [preset-typescript](https://babeljs.io/docs/en/babel-preset-typescript) to generate your JS files, and then using TypeScript to do type checking and `.d.ts` file generation.\n\nBy using babel’s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code.\n\n#### [](#type-checking-and-dts-file-generation)Type Checking and d.ts file generation\n\nThe downside to using babel is that you don’t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code.\n\nIn addition to that, Babel cannot create `.d.ts` files for your TypeScript which can make it harder to work with your project if it is a library.\n\nTo fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a corresponding [`tsconfig.json`](https://www.typescriptlang.org/tsconfig) and ensuring these flags are enabled:\n\n`\"compilerOptions\": {`\n\n  `// Ensure that .d.ts files are created by tsc, but not .js files`\n\n  `\"\": true,`\n\n  `\"\": true,`\n\n  `// Ensure that Babel can safely transpile files in the TypeScript project`\n\n  `\"\": true`\n\n`}`\n\nFor more information on these flags:\n\n*   [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules)\n*   [`declaration`](https://www.typescriptlang.org/tsconfig#declaration), [`emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly)",
    "title": "TypeScript: Documentation - Using Babel with TypeScript",
    "description": "How to create a hybrid Babel + TypeScript project",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html",
    "markdown": "# TypeScript: Documentation - Introduction\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/2/basic-types.html) to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to [Modules .d.ts](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html).\n\nThe Declaration Files section is broken down into the following sections.\n\n## [](#declaration-reference)[Declaration Reference](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The [Declaration Reference](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html) section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\n## [](#library-structures)[Library Structures](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html)\n\nThe [Library Structures](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html) guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\n## [](#dos-and-donts)[Do’s and Don’ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)\n\nMany common mistakes in declaration files can be easily avoided. The [Do’s and Don’ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html) section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\n## [](#deep-dive)[Deep Dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the [Deep Dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html) section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\n## [](#publish-to-npm)[Publish to npm](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)\n\nThe [Publishing](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html) section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\n## [](#find-and-install-declaration-files)[Find and Install Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html)\n\nFor JavaScript library users, the [Consumption](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html) section offers a few simple steps to locate and install corresponding declaration files.",
    "title": "TypeScript: Documentation - Introduction",
    "description": "How to write a high-quality TypeScript Declaration (d.ts) file",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html",
    "markdown": "# TypeScript: Documentation - Declaration Reference\n\nThe purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.\n\nThese examples are ordered in approximately increasing order of complexity.\n\n## [](#objects-with-properties)Objects with Properties\n\n_Documentation_\n\n> The global variable `myLib` has a function `makeGreeting` for creating greetings, and a property `numberOfGreetings` indicating the number of greetings made so far.\n\n_Code_\n\nts\n\n`let result = myLib.makeGreeting(\"hello, world\");`\n\n`console.log(\"The computed greeting is:\" + result);`\n\n`let count = myLib.numberOfGreetings;`\n\n_Declaration_\n\nUse `declare namespace` to describe types or values accessed by dotted notation.\n\nts\n\n`declare namespace myLib {`\n\n  `function makeGreeting(s: string): string;`\n\n  `let numberOfGreetings: number;`\n\n`}`\n\n## [](#overloaded-functions)Overloaded Functions\n\n_Documentation_\n\nThe `getWidget` function accepts a number and returns a Widget, or accepts a string and returns a Widget array.\n\n_Code_\n\nts\n\n`let x: Widget = getWidget(43);`\n\n`let arr: Widget[] = getWidget(\"all of them\");`\n\n_Declaration_\n\nts\n\n`declare function getWidget(n: number): Widget;`\n\n`declare function getWidget(s: string): Widget[];`\n\n## [](#reusable-types-interfaces)Reusable Types (Interfaces)\n\n_Documentation_\n\n> When specifying a greeting, you must pass a `GreetingSettings` object. This object has the following properties:\n> \n> 1 - greeting: Mandatory string\n> \n> 2 - duration: Optional length of time (in milliseconds)\n> \n> 3 - color: Optional string, e.g. ‘#ff00ff’\n\n_Code_\n\nts\n\n`greet({`\n\n  `greeting: \"hello world\",`\n\n  `duration: 4000`\n\n`});`\n\n_Declaration_\n\nUse an `interface` to define a type with properties.\n\nts\n\n`interface GreetingSettings {`\n\n  `greeting: string;`\n\n  `duration?: number;`\n\n  `color?: string;`\n\n`}`\n\n`declare function greet(setting: GreetingSettings): void;`\n\n## [](#reusable-types-type-aliases)Reusable Types (Type Aliases)\n\n_Documentation_\n\n> Anywhere a greeting is expected, you can provide a `string`, a function returning a `string`, or a `Greeter` instance.\n\n_Code_\n\nts\n\n`function getGreeting() {`\n\n  `return \"howdy\";`\n\n`}`\n\n`class MyGreeter extends Greeter {}`\n\n`greet(\"hello\");`\n\n`greet(getGreeting);`\n\n`greet(new MyGreeter());`\n\n_Declaration_\n\nYou can use a type alias to make a shorthand for a type:\n\nts\n\n`type GreetingLike = string | (() => string) | MyGreeter;`\n\n`declare function greet(g: GreetingLike): void;`\n\n## [](#organizing-types)Organizing Types\n\n_Documentation_\n\n> The `greeter` object can log to a file or display an alert. You can provide LogOptions to `.log(...)` and alert options to `.alert(...)`\n\n_Code_\n\nts\n\n`const g = new Greeter(\"Hello\");`\n\n`g.log({ verbose: true });`\n\n`g.alert({ modal: false, title: \"Current Greeting\" });`\n\n_Declaration_\n\nUse namespaces to organize types.\n\nts\n\n`declare namespace GreetingLib {`\n\n  `interface LogOptions {`\n\n    `verbose?: boolean;`\n\n  `}`\n\n  `interface AlertOptions {`\n\n    `modal: boolean;`\n\n    `title?: string;`\n\n    `color?: string;`\n\n  `}`\n\n`}`\n\nYou can also create nested namespaces in one declaration:\n\nts\n\n`declare namespace GreetingLib.Options {`\n\n  `// Refer to via GreetingLib.Options.Log`\n\n  `interface Log {`\n\n    `verbose?: boolean;`\n\n  `}`\n\n  `interface Alert {`\n\n    `modal: boolean;`\n\n    `title?: string;`\n\n    `color?: string;`\n\n  `}`\n\n`}`\n\n## [](#classes)Classes\n\n_Documentation_\n\n> You can create a greeter by instantiating the `Greeter` object, or create a customized greeter by extending from it.\n\n_Code_\n\nts\n\n`const myGreeter = new Greeter(\"hello, world\");`\n\n`myGreeter.greeting = \"howdy\";`\n\n`myGreeter.showGreeting();`\n\n`class SpecialGreeter extends Greeter {`\n\n  `constructor() {`\n\n    `super(\"Very special greetings\");`\n\n  `}`\n\n`}`\n\n_Declaration_\n\nUse `declare class` to describe a class or class-like object. Classes can have properties and methods as well as a constructor.\n\nts\n\n`declare class Greeter {`\n\n  `constructor(greeting: string);`\n\n  `greeting: string;`\n\n  `showGreeting(): void;`\n\n`}`\n\n## [](#global-variables)Global Variables\n\n_Documentation_\n\n> The global variable `foo` contains the number of widgets present.\n\n_Code_\n\nts\n\n`console.log(\"Half the number of widgets is \" + foo / 2);`\n\n_Declaration_\n\nUse `declare var` to declare variables. If the variable is read-only, you can use `declare const`. You can also use `declare let` if the variable is block-scoped.\n\nts\n\n`/** The number of widgets present */`\n\n`declare var foo: number;`\n\n## [](#global-functions)Global Functions\n\n_Documentation_\n\n> You can call the function `greet` with a string to show a greeting to the user.\n\n_Code_\n\nts\n\n`greet(\"hello, world\");`\n\n_Declaration_\n\nUse `declare function` to declare functions.\n\nts\n\n`declare function greet(greeting: string): void;`",
    "title": "TypeScript: Documentation - Declaration Reference",
    "description": "How to create a d.ts file for a module",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html",
    "markdown": "# TypeScript: Documentation - Deep Dive\n\n## [](#declaration-file-theory-a-deep-dive)Declaration File Theory: A Deep Dive\n\nStructuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without `new` to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.\n\nBy reading this guide, you’ll have the tools to write complex declaration files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.\n\n## [](#key-concepts)Key Concepts\n\nYou can fully understand how to make any shape of declaration by understanding some key concepts of how TypeScript works.\n\n### [](#types)Types\n\nIf you’re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a _type_ is introduced with:\n\n*   A type alias declaration (`type sn = number | string;`)\n*   An interface declaration (`interface I { x: number[]; }`)\n*   A class declaration (`class C { }`)\n*   An enum declaration (`enum E { A, B, C }`)\n*   An `import` declaration which refers to a type\n\nEach of these declaration forms creates a new type name.\n\n### [](#values)Values\n\nAs with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example `let x = 5;` creates a value called `x`.\n\nAgain, being explicit, the following things create values:\n\n*   `let`, `const`, and `var` declarations\n*   A `namespace` or `module` declaration which contains a value\n*   An `enum` declaration\n*   A `class` declaration\n*   An `import` declaration which refers to a value\n*   A `function` declaration\n\n### [](#namespaces)Namespaces\n\nTypes can exist in _namespaces_. For example, if we have the declaration `let x: A.B.C`, we say that the type `C` comes from the `A.B` namespace.\n\nThis distinction is subtle and important — here, `A.B` is not necessarily a type or a value.\n\n## [](#simple-combinations-one-name-multiple-meanings)Simple Combinations: One name, multiple meanings\n\nGiven a name `A`, we might find up to three different meanings for `A`: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration `let m: A.A = A;`, `A` is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!\n\nThis may seem confusing, but it’s actually very convenient as long as we don’t excessively overload things. Let’s look at some useful aspects of this combining behavior.\n\n### [](#built-in-combinations)Built-in Combinations\n\nAstute readers will notice that, for example, `class` appeared in both the _type_ and _value_ lists. The declaration `class C { }` creates two things: a _type_ `C` which refers to the instance shape of the class, and a _value_ `C` which refers to the constructor function of the class. Enum declarations behave similarly.\n\n### [](#user-combinations)User Combinations\n\nLet’s say we wrote a module file `foo.d.ts`:\n\nts\n\n`export var SomeVar: { a: SomeType };`\n\n`export interface SomeType {`\n\n  `count: number;`\n\n`}`\n\nThen consumed it:\n\nts\n\n`import * as foo from \"./foo\";`\n\n`let x: foo.SomeType = foo.SomeVar.a;`\n\n`console.log(x.count);`\n\nThis works well enough, but we might imagine that `SomeType` and `SomeVar` were very closely related such that you’d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name `Bar`:\n\nts\n\n`export var Bar: { a: Bar };`\n\n`export interface Bar {`\n\n  `count: number;`\n\n`}`\n\nThis presents a very good opportunity for destructuring in the consuming code:\n\nts\n\n`import { Bar } from \"./foo\";`\n\n`let x: Bar = Bar.a;`\n\n`console.log(x.count);`\n\nAgain, we’ve used `Bar` as both a type and a value here. Note that we didn’t have to declare the `Bar` value as being of the `Bar` type — they’re independent.\n\n## [](#advanced-combinations)Advanced Combinations\n\nSome kinds of declarations can be combined across multiple declarations. For example, `class C { }` and `interface C { }` can co-exist and both contribute properties to the `C` types.\n\nThis is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as `namespace`s, types will conflict if they are declared with a type alias declaration (`type s = string`), and namespaces never conflict.\n\nLet’s see how this can be used.\n\n### [](#adding-using-an-interface)Adding using an `interface`\n\nWe can add additional members to an `interface` with another `interface` declaration:\n\nts\n\n`interface Foo {`\n\n  `x: number;`\n\n`}`\n\n`// ... elsewhere ...`\n\n`interface Foo {`\n\n  `y: number;`\n\n`}`\n\n`let a: Foo = ...;`\n\n`console.log(a.x + a.y); // OK`\n\nThis also works with classes:\n\nts\n\n`class Foo {`\n\n  `x: number;`\n\n`}`\n\n`// ... elsewhere ...`\n\n`interface Foo {`\n\n  `y: number;`\n\n`}`\n\n`let a: Foo = ...;`\n\n`console.log(a.x + a.y); // OK`\n\nNote that we cannot add to type aliases (`type s = string;`) using an interface.\n\n### [](#adding-using-a-namespace)Adding using a `namespace`\n\nA `namespace` declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.\n\nFor example, we can add a static member to a class:\n\nts\n\n`class C {}`\n\n`// ... elsewhere ...`\n\n`namespace C {`\n\n  `export let x: number;`\n\n`}`\n\n`let y = C.x; // OK`\n\nNote that in this example, we added a value to the _static_ side of `C` (its constructor function). This is because we added a _value_, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).\n\nWe could also add a namespaced type to a class:\n\nts\n\n`class C {}`\n\n`// ... elsewhere ...`\n\n`namespace C {`\n\n  `export interface D {}`\n\n`}`\n\n`let y: C.D; // OK`\n\nIn this example, there wasn’t a namespace `C` until we wrote the `namespace` declaration for it. The meaning `C` as a namespace doesn’t conflict with the value or type meanings of `C` created by the class.\n\nFinally, we could perform many different merges using `namespace` declarations. This isn’t a particularly realistic example, but shows all sorts of interesting behavior:\n\nts\n\n`namespace X {`\n\n  `export interface Y {}`\n\n  `export class Z {}`\n\n`}`\n\n`// ... elsewhere ...`\n\n`namespace X {`\n\n  `export var Y: number;`\n\n  `export namespace Z {`\n\n    `export class C {}`\n\n  `}`\n\n`}`\n\n`type X = string;`\n\nIn this example, the first block creates the following name meanings:\n\n*   A value `X` (because the `namespace` declaration contains a value, `Z`)\n*   A namespace `X` (because the `namespace` declaration contains a type, `Y`)\n*   A type `Y` in the `X` namespace\n*   A type `Z` in the `X` namespace (the instance shape of the class)\n*   A value `Z` that is a property of the `X` value (the constructor function of the class)\n\nThe second block creates the following name meanings:\n\n*   A value `Y` (of type `number`) that is a property of the `X` value\n*   A namespace `Z`\n*   A value `Z` that is a property of the `X` value\n*   A type `C` in the `X.Z` namespace\n*   A value `C` that is a property of the `X.Z` value\n*   A type `X`",
    "title": "TypeScript: Documentation - Deep Dive",
    "description": "How do d.ts files work, a deep dive",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html",
    "markdown": "# TypeScript: Documentation - Do's and Don'ts\n\n## [](#general-types)General Types\n\n### [](#number-string-boolean-symbol-and-object)`Number`, `String`, `Boolean`, `Symbol` and `Object`\n\n❌ **Don’t** ever use the types `Number`, `String`, `Boolean`, `Symbol`, or `Object` These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.\n\nts\n\n`/* WRONG */`\n\n`function reverse(s: String): String;`\n\n✅ **Do** use the types `number`, `string`, `boolean`, and `symbol`.\n\nts\n\n`/* OK */`\n\n`function reverse(s: string): string;`\n\nInstead of `Object`, use the non-primitive `object` type ([added in TypeScript 2.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type)).\n\n### [](#generics)Generics\n\n❌ **Don’t** ever have a generic type which doesn’t use its type parameter. See more details in [TypeScript FAQ page](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--).\n\n### [](#any)any\n\n❌ **Don’t** use `any` as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler _effectively_ treats `any` as “please turn off type checking for this thing”. It is similar to putting an `@ts-ignore` comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven’t migrated yet as `any`, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.\n\nIn cases where you don’t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use [`unknown`](https://www.typescriptlang.org/play/#example/unknown-and-never).\n\n## [](#callback-types)Callback Types\n\n### [](#return-types-of-callbacks)Return Types of Callbacks\n\n❌ **Don’t** use the return type `any` for callbacks whose value will be ignored:\n\nts\n\n`/* WRONG */`\n\n`function fn(x: () => any) {`\n\n  `x();`\n\n`}`\n\n✅ **Do** use the return type `void` for callbacks whose value will be ignored:\n\nts\n\n`/* OK */`\n\n`function fn(x: () => void) {`\n\n  `x();`\n\n`}`\n\n❔ **Why:** Using `void` is safer because it prevents you from accidentally using the return value of `x` in an unchecked way:\n\nts\n\n`function fn(x: () => void) {`\n\n  `var k = x(); // oops! meant to do something else`\n\n  `k.doSomething(); // error, but would be OK if the return type had been 'any'`\n\n`}`\n\n### [](#optional-parameters-in-callbacks)Optional Parameters in Callbacks\n\n❌ **Don’t** use optional parameters in callbacks unless you really mean it:\n\nts\n\n`/* WRONG */`\n\n`interface Fetcher {`\n\n  `getObject(done: (data: unknown, elapsedTime?: number) => void): void;`\n\n`}`\n\nThis has a very specific meaning: the `done` callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the `elapsedTime` parameter, but there’s no need to make the parameter optional to accomplish this — it’s always legal to provide a callback that accepts fewer arguments.\n\n✅ **Do** write callback parameters as non-optional:\n\nts\n\n`/* OK */`\n\n`interface Fetcher {`\n\n  `getObject(done: (data: unknown, elapsedTime: number) => void): void;`\n\n`}`\n\n### [](#overloads-and-callbacks)Overloads and Callbacks\n\n❌ **Don’t** write separate overloads that differ only on callback arity:\n\nts\n\n`/* WRONG */`\n\n`declare function beforeAll(action: () => void, timeout?: number): void;`\n\n`declare function beforeAll(`\n\n  `action: (done: DoneFn) => void,`\n\n  `timeout?: number`\n\n`): void;`\n\n✅ **Do** write a single overload using the maximum arity:\n\nts\n\n`/* OK */`\n\n`declare function beforeAll(`\n\n  `action: (done: DoneFn) => void,`\n\n  `timeout?: number`\n\n`): void;`\n\n❔ **Why:** It’s always legal for a callback to disregard a parameter, so there’s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.\n\n## [](#function-overloads)Function Overloads\n\n### [](#ordering)Ordering\n\n❌ **Don’t** put more general overloads before more specific overloads:\n\nts\n\n`/* WRONG */`\n\n`declare function fn(x: unknown): unknown;`\n\n`declare function fn(x: HTMLElement): number;`\n\n`declare function fn(x: HTMLDivElement): string;`\n\n`var myElem: HTMLDivElement;`\n\n`var x = fn(myElem); // x: unknown, wat?`\n\n✅ **Do** sort overloads by putting the more general signatures after more specific signatures:\n\nts\n\n`/* OK */`\n\n`declare function fn(x: HTMLDivElement): string;`\n\n`declare function fn(x: HTMLElement): number;`\n\n`declare function fn(x: unknown): unknown;`\n\n`var myElem: HTMLDivElement;`\n\n`var x = fn(myElem); // x: string, :)`\n\n❔ **Why:** TypeScript chooses the _first matching overload_ when resolving function calls. When an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called.\n\n### [](#use-optional-parameters)Use Optional Parameters\n\n❌ **Don’t** write several overloads that differ only in trailing parameters:\n\nts\n\n`/* WRONG */`\n\n`interface Example {`\n\n  `diff(one: string): number;`\n\n  `diff(one: string, two: string): number;`\n\n  `diff(one: string, two: string, three: boolean): number;`\n\n`}`\n\n✅ **Do** use optional parameters whenever possible:\n\nts\n\n`/* OK */`\n\n`interface Example {`\n\n  `diff(one: string, two?: string, three?: boolean): number;`\n\n`}`\n\nNote that this collapsing should only occur when all overloads have the same return type.\n\n❔ **Why:** This is important for two reasons.\n\nTypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, _and extraneous arguments are allowed_. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:\n\nts\n\n`function fn(x: (a: string, b: number, c: number) => void) {}`\n\n`var x: Example;`\n\n`// When written with overloads, OK -- used first overload`\n\n`// When written with optionals, correctly an error`\n\n`fn(x.diff);`\n\nThe second reason is when a consumer uses the “strict null checking” feature of TypeScript. Because unspecified parameters appear as `undefined` in JavaScript, it’s usually fine to pass an explicit `undefined` to a function with optional arguments. This code, for example, should be OK under strict nulls:\n\nts\n\n`var x: Example;`\n\n`// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'`\n\n`// When written with optionals, correctly OK`\n\n`x.diff(\"something\", true ? undefined : \"hour\");`\n\n### [](#use-union-types)Use Union Types\n\n❌ **Don’t** write overloads that differ by type in only one argument position:\n\nts\n\n`/* WRONG */`\n\n`interface Moment {`\n\n  `utcOffset(): number;`\n\n  `utcOffset(b: number): Moment;`\n\n  `utcOffset(b: string): Moment;`\n\n`}`\n\n✅ **Do** use union types whenever possible:\n\nts\n\n`/* OK */`\n\n`interface Moment {`\n\n  `utcOffset(): number;`\n\n  `utcOffset(b: number | string): Moment;`\n\n`}`\n\nNote that we didn’t make `b` optional here because the return types of the signatures differ.\n\n❔ **Why:** This is important for people who are “passing through” a value to your function:\n\nts\n\n`function fn(x: string): Moment;`\n\n`function fn(x: number): Moment;`\n\n`function fn(x: number | string) {`\n\n  `// When written with separate overloads, incorrectly an error`\n\n  `// When written with union types, correctly OK`\n\n  `return moment().utcOffset(x);`\n\n`}`",
    "title": "TypeScript: Documentation - Do's and Don'ts",
    "description": "Recommendations for writing d.ts files",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html",
    "markdown": "# TypeScript: Documentation - Library Structures\n\nBroadly speaking, the way you _structure_ your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you’ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.\n\nEach type of major library structuring pattern has a corresponding file in the [Templates](https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html) section. You can start with these templates to help you get going faster.\n\n## [](#identifying-kinds-of-libraries)Identifying Kinds of Libraries\n\nFirst, we’ll review the kinds of libraries TypeScript declaration files can represent. We’ll briefly show how each kind of library is _used_, how it is _written_, and list some example libraries from the real world.\n\nIdentifying the structure of a library is the first step in writing its declaration file. We’ll give hints on how to identify structure both based on its _usage_ and its _code_. Depending on the library’s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.\n\n### [](#what-should-you-look-for)What should you look for?\n\nQuestion to ask yourself while looking at a library you are trying to type.\n\n1.  How do you obtain the library?\n    \n    For example, can you _only_ get it through npm or only from a CDN?\n    \n2.  How would you import it?\n    \n    Does it add a global object? Does it use `require` or `import`/`export` statements?\n    \n\n### [](#smaller-samples-for-different-types-of-libraries)Smaller samples for different types of libraries\n\n### [](#modular-libraries)Modular Libraries\n\nAlmost every modern Node.js library falls into the module family. These type of libraries only work in a JS environment with a module loader. For example, `express` only works in Node.js and must be loaded using the CommonJS `require` function.\n\nECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of _importing_ a _module_. In JavaScript CommonJS (Node.js), for example, you would write\n\njs\n\n`var fs = require(\"fs\");`\n\nIn TypeScript or ES6, the `import` keyword serves the same purpose:\n\nts\n\n`import * as fs from \"fs\";`\n\nYou’ll typically see modular libraries include one of these lines in their documentation:\n\njs\n\n`var someLib = require(\"someLib\");`\n\nor\n\njs\n\n`define(..., ['someLib'], function(someLib) {`\n\n`});`\n\nAs with global modules, you might see these examples in the documentation of [a UMD](#umd) module, so be sure to check the code or documentation.\n\n#### [](#identifying-a-module-library-from-code)Identifying a Module Library from Code\n\nModular libraries will typically have at least some of the following:\n\n*   Unconditional calls to `require` or `define`\n*   Declarations like `import * as a from 'b';` or `export c;`\n*   Assignments to `exports` or `module.exports`\n\nThey will rarely have:\n\n*   Assignments to properties of `window` or `global`\n\n#### [](#templates-for-modules)Templates For Modules\n\nThere are four templates available for modules, [`module.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html), [`module-class.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html), [`module-function.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html) and [`module-plugin.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html).\n\nYou should first read [`module.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html) for an overview on the way they all work.\n\nThen use the template [`module-function.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html) if your module can be _called_ like a function:\n\njs\n\n`const x = require(\"foo\");`\n\n`// Note: calling 'x' as a function`\n\n`const y = x(42);`\n\nUse the template [`module-class.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html) if your module can be _constructed_ using `new`:\n\njs\n\n`const x = require(\"bar\");`\n\n`// Note: using 'new' operator on the imported variable`\n\n`const y = new x(\"hello\");`\n\nIf you have a module which when imported, makes changes to other modules use template [`module-plugin.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html):\n\njs\n\n`const jest = require(\"jest\");`\n\n`require(\"jest-matchers-files\");`\n\n### [](#global-libraries)Global Libraries\n\nA _global_ library is one that can be accessed from the global scope (i.e. without using any form of `import`). Many libraries simply expose one or more global variables for use. For example, if you were using [jQuery](https://jquery.com/), the `$` variable can be used by simply referring to it:\n\nts\n\n`$(() => {`\n\n  `console.log(\"hello!\");`\n\n`});`\n\nYou’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:\n\nhtml\n\n`<script src=\"http://a.great.cdn.for/someLib.js\"></script>`\n\nToday, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.\n\n#### [](#identifying-a-global-library-from-code)Identifying a Global Library from Code\n\nGlobal library code is usually extremely simple. A global “Hello, world” library might look like this:\n\njs\n\n`function createGreeting(s) {`\n\n  `return \"Hello, \" + s;`\n\n`}`\n\nor like this:\n\njs\n\n`// Web`\n\n`window.createGreeting = function (s) {`\n\n  `return \"Hello, \" + s;`\n\n`};`\n\n`// Node`\n\n`global.createGreeting = function (s) {`\n\n  `return \"Hello, \" + s;`\n\n`};`\n\n`// Potentially any runtime`\n\n`globalThis.createGreeting = function (s) {`\n\n  `return \"Hello, \" + s;`\n\n`};`\n\nWhen looking at the code of a global library, you’ll usually see:\n\n*   Top-level `var` statements or `function` declarations\n*   One or more assignments to `window.someName`\n*   Assumptions that DOM primitives like `document` or `window` exist\n\nYou _won’t_ see:\n\n*   Checks for, or usage of, module loaders like `require` or `define`\n*   CommonJS/Node.js-style imports of the form `var fs = require(\"fs\");`\n*   Calls to `define(...)`\n*   Documentation describing how to `require` or import the library\n\n#### [](#examples-of-global-libraries)Examples of Global Libraries\n\nBecause it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have _no_ dependencies) may still be global.\n\n#### [](#global-library-template)Global Library Template\n\nThe template file [`global.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html) defines an example library `myLib`. Be sure to read the [“Preventing Name Conflicts” footnote](#preventing-name-conflicts).\n\n### [](#umd)_UMD_\n\nA _UMD_ module is one that can _either_ be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as [Moment.js](https://momentjs.com/), are written this way. For example, in Node.js or using RequireJS, you would write:\n\nts\n\n`import moment = require(\"moment\");`\n\n`console.log(moment.format());`\n\nwhereas in a vanilla browser environment you would write:\n\njs\n\n`console.log(moment.format());`\n\n#### [](#identifying-a-umd-library)Identifying a UMD library\n\n[UMD modules](https://github.com/umdjs/umd) check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:\n\njs\n\n`(function (root, factory) {`\n\n    `if (typeof define === \"function\" && define.amd) {`\n\n        `define([\"libName\"], factory);`\n\n    `} else if (typeof module === \"object\" && module.exports) {`\n\n        `module.exports = factory(require(\"libName\"));`\n\n    `} else {`\n\n        `root.returnExports = factory(root.libName);`\n\n    `}`\n\n`}(this, function (b) {`\n\nIf you see tests for `typeof define`, `typeof window`, or `typeof module` in the code of a library, especially at the top of the file, it’s almost always a UMD library.\n\nDocumentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing `require`, and a “Using in the browser” example showing using a `<script>` tag to load the script.\n\n#### [](#examples-of-umd-libraries)Examples of UMD libraries\n\nMost popular libraries are now available as UMD packages. Examples include [jQuery](https://jquery.com/), [Moment.js](https://momentjs.com/), [lodash](https://lodash.com/), and many more.\n\n#### [](#template)Template\n\nUse the [`module-plugin.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html) template.\n\n## [](#consuming-dependencies)Consuming Dependencies\n\nThere are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.\n\n### [](#dependencies-on-global-libraries)Dependencies on Global Libraries\n\nIf your library depends on a global library, use a `/// <reference types=\"...\" />` directive:\n\nts\n\n`/// <reference types=\"someLib\" />`\n\n`function getThing(): someLib.thing;`\n\n### [](#dependencies-on-modules)Dependencies on Modules\n\nIf your library depends on a module, use an `import` statement:\n\nts\n\n`import * as moment from \"moment\";`\n\n`function getThing(): moment;`\n\n### [](#dependencies-on-umd-libraries)Dependencies on UMD libraries\n\n#### [](#from-a-global-library)From a Global Library\n\nIf your global library depends on a UMD module, use a `/// <reference types` directive:\n\nts\n\n`/// <reference types=\"moment\" />`\n\n`function getThing(): moment;`\n\n#### [](#from-a-module-or-umd-library)From a Module or UMD Library\n\nIf your module or UMD library depends on a UMD library, use an `import` statement:\n\nts\n\n`import * as someLib from \"someLib\";`\n\nDo _not_ use a `/// <reference` directive to declare a dependency to a UMD library!\n\n### [](#preventing-name-conflicts)Preventing Name Conflicts\n\nNote that it’s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to only declare types _namespaced_ by whatever global variable the library defines. For example, if the library defines the global value ‘cats’, you should write\n\nts\n\n`declare namespace cats {`\n\n  `interface KittySettings {}`\n\n`}`\n\nBut _not_\n\nts\n\n`// at top-level`\n\n`interface CatsKittySettings {}`\n\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\n### [](#the-impact-of-es6-on-module-call-signatures)The Impact of ES6 on Module Call Signatures\n\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\nts\n\n`import exp = require(\"express\");`\n\n`var app = exp();`\n\nIn ES6-compliant module loaders, the top-level object (here imported as `exp`) can only have properties; the top-level module object can _never_ be callable.\n\nThe most common solution here is to define a `default` export for a callable/constructable object; module loaders commonly detect this situation automatically and replace the top-level object with the `default` export. TypeScript can handle this for you, if you have [`\"esModuleInterop\": true`](https://www.typescriptlang.org/tsconfig/#esModuleInterop) in your tsconfig.json.",
    "title": "TypeScript: Documentation - Library Structures",
    "description": "How to structure your d.ts files",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html",
    "markdown": "# TypeScript: Documentation - Consumption\n\n## [](#downloading)Downloading\n\nGetting type declarations requires no tools apart from npm.\n\nAs an example, getting the declarations for a library like lodash takes nothing more than the following command\n\ncmd\n\n`npm install --save-dev @types/lodash`\n\nIt is worth noting that if the npm package already includes its declaration file as described in [Publishing](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html), downloading the corresponding `@types` package is not needed.\n\n## [](#consuming)Consuming\n\nFrom there you’ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.\n\nFor example, once you’ve `npm install`\\-ed your type declarations, you can use imports and write\n\nts\n\n`import * as _ from \"lodash\";`\n\n`_.padStart(\"Hello TypeScript!\", 20, \" \");`\n\nor if you’re not using modules, you can just use the global variable `_`.\n\nts\n\n`_.padStart(\"Hello TypeScript!\", 20, \" \");`\n\n## [](#searching)Searching\n\nFor the most part, type declaration packages should always have the same name as the package name on `npm`, but prefixed with `@types/`, but if you need, you can use the [Yarn package search](https://yarnpkg.com/) to find the package for your favorite library.\n\n> Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped [contribution guidelines page](https://definitelytyped.org/guides/contributing.html) for details.",
    "title": "TypeScript: Documentation - Consumption",
    "description": "How to download d.ts files for your project",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html",
    "markdown": "# TypeScript: Documentation - Publishing\n\nNow that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:\n\n1.  bundling with your npm package\n2.  publishing to the [@types organization](https://www.npmjs.com/~types) on npm.\n\nIf your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types via [`declaration`](https://www.typescriptlang.org/tsconfig#declaration).\n\nOtherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the `@types` organization on npm.\n\n## [](#including-declarations-in-your-npm-package)Including declarations in your npm package\n\nIf your package has a main `.js` file, you will need to indicate the main declaration file in your `package.json` file as well. Set the `types` property to point to your bundled declaration file. For example:\n\njson\n\n`{`\n\n  `\"name\": \"awesome\",`\n\n  `\"author\": \"Vandelay Industries\",`\n\n  `\"version\": \"1.0.0\",`\n\n  `\"main\": \"./lib/main.js\",`\n\n  `\"types\": \"./lib/main.d.ts\"`\n\n`}`\n\nNote that the `\"typings\"` field is synonymous with `types`, and could be used as well.\n\n## [](#dependencies)Dependencies\n\nAll dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the `\"dependencies\"` section in your `package.json`. For example, imagine we authored a package that used Browserify and TypeScript.\n\njson\n\n`{`\n\n  `\"name\": \"browserify-typescript-extension\",`\n\n  `\"author\": \"Vandelay Industries\",`\n\n  `\"version\": \"1.0.0\",`\n\n  `\"main\": \"./lib/main.js\",`\n\n  `\"types\": \"./lib/main.d.ts\",`\n\n  `\"dependencies\": {`\n\n    `\"browserify\": \"latest\",`\n\n    `\"@types/browserify\": \"latest\",`\n\n    `\"typescript\": \"next\"`\n\n  `}`\n\n`}`\n\nHere, our package depends on the `browserify` and `typescript` packages. `browserify` does not bundle its declaration files with its npm packages, so we needed to depend on `@types/browserify` for its declarations. `typescript`, on the other hand, packages its declaration files, so there was no need for any additional dependencies.\n\nOur package exposes declarations from each of those, so any user of our `browserify-typescript-extension` package needs to have these dependencies as well. For that reason, we used `\"dependencies\"` and not `\"devDependencies\"`, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used `devDependencies`.\n\n## [](#red-flags)Red flags\n\n### [](#-reference-path-)`/// <reference path=\"...\" />`\n\n_Don’t_ use `/// <reference path=\"...\" />` in your declaration files.\n\nts\n\n`/// <reference path=\"../typescript/lib/typescriptServices.d.ts\" />`\n\n`....`\n\n_Do_ use `/// <reference types=\"...\" />` instead.\n\nts\n\n`/// <reference types=\"typescript\" />`\n\n`....`\n\nMake sure to revisit the [Consuming dependencies](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#consuming-dependencies) section for more information.\n\n### [](#packaging-dependent-declarations)Packaging dependent declarations\n\nIf your type definitions depend on another package:\n\n*   _Don’t_ combine it with yours, keep each in their own file.\n*   _Don’t_ copy the declarations in your package either.\n*   _Do_ depend on the npm type declaration package if it doesn’t package its declaration files.\n\n## [](#version-selection-with-typesversions)Version selection with `typesVersions`\n\nWhen TypeScript opens a `package.json` file to figure out which files it needs to read, it first looks at a field called `typesVersions`.\n\n#### [](#folder-redirects-using-)Folder redirects (using `*`)\n\nA `package.json` with a `typesVersions` field might look like this:\n\njson\n\n`{`\n\n  `\"name\": \"package-name\",`\n\n  `\"version\": \"1.0.0\",`\n\n  `\"types\": \"./index.d.ts\",`\n\n  `\"typesVersions\": {`\n\n    `\">=3.1\": { \"*\": [\"ts3.1/*\"] }`\n\n  `}`\n\n`}`\n\nThis `package.json` tells TypeScript to first check the current version of TypeScript. If it’s 3.1 or later, TypeScript figures out the path you’ve imported relative to the package, and reads from the package’s `ts3.1` folder.\n\nThat’s what that `{ \"*\": [\"ts3.1/*\"] }` means - if you’re familiar with [path mapping](https://www.typescriptlang.org/tsconfig#paths), it works exactly like that.\n\nIn the above example, if we’re importing from `\"package-name\"`, TypeScript will try to resolve from `[...]/node_modules/package-name/ts3.1/index.d.ts` (and other relevant paths) when running in TypeScript 3.1. If we import from `package-name/foo`, we’ll try to look for `[...]/node_modules/package-name/ts3.1/foo.d.ts` and `[...]/node_modules/package-name/ts3.1/foo/index.d.ts`.\n\nWhat if we’re not running in TypeScript 3.1 in this example? Well, if none of the fields in `typesVersions` get matched, TypeScript falls back to the `types` field, so here TypeScript 3.0 and earlier will be redirected to `[...]/node_modules/package-name/index.d.ts`.\n\n#### [](#file-redirects)File redirects\n\nWhen you want to only change the resolution for a single file at a time, you can tell TypeScript the file to resolve differently by passing in the exact filenames:\n\njson\n\n`{`\n\n  `\"name\": \"package-name\",`\n\n  `\"version\": \"1.0.0\",`\n\n  `\"types\": \"./index.d.ts\",`\n\n  `\"typesVersions\": {`\n\n    `\"<4.0\": { \"index.d.ts\": [\"index.v3.d.ts\"] }`\n\n  `}`\n\n`}`\n\nOn TypeScript 4.0 and above, an import for `\"package-name\"` would resolve to `./index.d.ts` and for 3.9 and below `\"./index.v3.d.ts`.\n\nNote that redirections only affect the _external_ API of a package; import resolution within a project is not affected by `typesVersions`. For example, a `d.ts` file in the previous example containing `import * as foo from \"./index\"` will still map to `index.d.ts`, not `index.v3.d.ts`, whereas another package importing `import * as foo from \"package-name\"` _will_ get `index.v3.d.ts`.\n\n## [](#matching-behavior)Matching behavior\n\nThe way that TypeScript decides on whether a version of the compiler & language matches is by using Node’s [semver ranges](https://github.com/npm/node-semver#ranges).\n\n## [](#multiple-fields)Multiple fields\n\n`typesVersions` can support multiple fields where each field name is specified by the range to match on.\n\n`{`\n\n  `\"name\": \"package-name\",`\n\n  `\"version\": \"1.0\",`\n\n  `\"\": \"./index.d.ts\",`\n\n  `\"typesVersions\": {`\n\n    `\">=3.2\": { \"*\": [\"ts3.2/*\"] },`\n\n    `\">=3.1\": { \"*\": [\"ts3.1/*\"] }`\n\n  `}`\n\n`}`\n\nSince ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the `>=3.2` and the `>=3.1` matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.\n\n`{`\n\n  `\"name\": \"package-name\",`\n\n  `\"version\": \"1.0\",`\n\n  `\"\": \"./index.d.ts\",`\n\n  `\"typesVersions\": {`\n\n    `// NOTE: this doesn't work!`\n\n    `\">=3.1\": { \"*\": [\"ts3.1/*\"] },`\n\n    `\">=3.2\": { \"*\": [\"ts3.2/*\"] }`\n\n  `}`\n\n`}`\n\n## [](#publish-to-types)Publish to [@types](https://www.npmjs.com/~types)\n\nPackages under the [@types](https://www.npmjs.com/~types) organization are published automatically from [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) using the [types-publisher tool](https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher). To get your declarations published as an @types package, please submit a pull request to [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). You can find more details in the [contribution guidelines page](https://definitelytyped.github.io/guides/contributing.html).",
    "title": "TypeScript: Documentation - Publishing",
    "description": "How to get your d.ts files to users",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html",
    "markdown": "# TypeScript: Documentation - Creating .d.ts Files from .js files\n\n[With TypeScript 3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs), TypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax.\n\nThis set up means you can own the editor experience of TypeScript-powered editors without porting your project to TypeScript, or having to maintain .d.ts files in your codebase. TypeScript supports most JSDoc tags, you can find [the reference here](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#supported-jsdoc).\n\n## [](#setting-up-your-project-to-emit-dts-files)Setting up your Project to emit .d.ts files\n\nTo add creation of .d.ts files in your project, you will need to do up-to four steps:\n\n*   Add TypeScript to your dev dependencies\n*   Add a `tsconfig.json` to configure TypeScript\n*   Run the TypeScript compiler to generate the corresponding d.ts files for JS files\n*   (optional) Edit your package.json to reference the types\n\n### [](#adding-typescript)Adding TypeScript\n\nYou can learn how to do this in our [installation page](https://www.typescriptlang.org/download).\n\n### [](#tsconfig)TSConfig\n\nThe TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files. In this case, you will want a file like the following:\n\n`{`\n\n  `// Change this to match your project`\n\n  `\"\": [\"src/**/*\"],`\n\n  `\"\": {`\n\n    `// Tells TypeScript to read JS files, as`\n\n    `// normally they are ignored as source files`\n\n    `\"\": true,`\n\n    `// Generate d.ts files`\n\n    `\"\": true,`\n\n    `// This compiler run should`\n\n    `// only output d.ts files`\n\n    `\"\": true,`\n\n    `// Types should go into this directory.`\n\n    `// Removing this would place the .d.ts files`\n\n    `// next to the .js files`\n\n    `\"\": \"dist\",`\n\n    `// go to js file when using IDE functions like`\n\n    `// \"Go to Definition\" in VSCode`\n\n    `\"\": true`\n\n  `}`\n\n`}`\n\nYou can learn more about the options in the [tsconfig reference](https://www.typescriptlang.org/tsconfig). An alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command.\n\nsh\n\n`npx -p typescript tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types`\n\n## [](#run-the-compiler)Run the compiler\n\nYou can learn how to do this in our [installation page](https://www.typescriptlang.org/download). You want to make sure these files are included in your package if you have the files in your project’s `.gitignore`.\n\n## [](#editing-the-packagejson)Editing the package.json\n\nTypeScript replicates the node resolution for modules in a `package.json`, with an additional step for finding .d.ts files. Roughly, the resolution will first check the optional `types` field, then the `\"main\"` field, and finally will try `index.d.ts` in the root.\n\n| Package.json | Location of default .d.ts |\n| --- | --- |\n| No “types” field | checks “main”, then index.d.ts |\n| “types”: “main.d.ts” | main.d.ts |\n| “types”: “./dist/main.js” | ./dist/main.d.ts |\n\nIf absent, then “main” is used\n\n| Package.json | Location of default .d.ts |\n| --- | --- |\n| No “main” field | index.d.ts |\n| “main”:“index.js” | index.d.ts |\n| “main”:“./dist/index.js” | ./dist/index.d.ts |\n\n## [](#tips)Tips\n\nIf you’d like to write tests for your .d.ts files, try [tsd](https://github.com/SamVerschueren/tsd).",
    "title": "TypeScript: Documentation - Creating .d.ts Files from .js files",
    "description": "How to add d.ts generation to JavaScript projects",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html",
    "markdown": "# TypeScript: Documentation - Type Checking JavaScript Files\n\nHere are some notable differences on how checking works in `.js` files compared to `.ts` files.\n\n## [](#properties-are-inferred-from-assignments-in-class-bodies)Properties are inferred from assignments in class bodies\n\nES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.\n\nIn a `.js` file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it’s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.\n\njs\n\n`class C {`\n\n  `constructor() {`\n\n    `this.constructorOnly = 0;`\n\n    `this.constructorUnknown = undefined;`\n\n  `}`\n\n  `method() {`\n\n    `this.constructorOnly = false;`\n\n`Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.      this.constructorUnknown = \"plunkbat\"; // ok, constructorUnknown is string | undefined      this.methodOnly = \"ok\"; // ok, but methodOnly could also be undefined    }    method2() {      this.methodOnly = true; // also, ok, methodOnly's type is string | boolean | undefined    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZTS1IAbAQxRVAGFQBvNUUSPAOxQAXbAFdIgggAoAlBy7dQg6AEsUAOl4DhYidgDyfWgE9QAXlAAGANzzuS1Rv5DR4ggFU+CPngDufM6AifAAmsABmynywwTbcAL7yALawSnjBMnIKiirqms46BAbGAWH0tCiwsQr2uU7artgeXr7+5gBEAA60QQgARvSCbVagmHgIADQ8dS66Td5+oKqgzpEA5qAAPoEh4ZHRttkOyanBRSbtY0MjYGOTvSKCoMfQaWdTIrTBoGUoeKC9sG2oQiUWC8gS3GeaVIGU4WRqaihp0M50Uokq12+5Twk1uTxSL2RxgA5MxBEYOoClis+Ostr08HhaLB6P4tkFgXswfE0HEgA)\n\nIf properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don’t even have to give a value if it will be initialized later:\n\njs\n\n`class C {`\n\n  `constructor() {`\n\n    `/** @type {number | undefined} */`\n\n    `this.prop = undefined;`\n\n    `/** @type {number | undefined} */`\n\n    `this.count;`\n\n  `}`\n\n`}`\n\n`let c = new C();`\n\n`c.prop = 0; // OK`\n\n`c.count = \"string\";`\n\n`Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZTS1IAbAQxRVAGFQBvNUUSPAOxQAXbAFdIgggAoAlBy7dQwAFRKIggJ4AHWBz4iAtgCMcoAD6gRfACawAZgEs+sKwF9QS4PO6Do9lADpNfE1QAF4LaztHZwBuL0UVNS0ddj0jE3NLGwcnV3dPBVAfP39eS0E47hc0arRaWEEeMNAnAHdWGTjIQODmgAYYxTAAeQBpGlK8cuaAIiFsRwBzGZigA)\n\n## [](#constructor-functions-are-equivalent-to-classes)Constructor functions are equivalent to classes\n\nBefore ES2015, JavaScript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.\n\njs\n\n`function C() {`\n\n  `this.constructorOnly = 0;`\n\n  `this.constructorUnknown = undefined;`\n\n`}`\n\n`C.prototype.method = function () {`\n\n  `this.constructorOnly = false;`\n\n`Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.    this.constructorUnknown = \"plunkbat\"; // OK, the type is string | undefined  };  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgDYAOAZjOtNLQDMBXAO0gBcBLPN0AMIAKAJSgA3mlChO0bigB0kPik7YWXAgHk2AGwCeoALygADAG4pMuYuVtV6zdgCqbBGzwB3fifYATWCZuNlg-SwBfNAEFAAd8TjxOfRjYBQBbWFk8P2NQVg4ePlBRCStZeSUVNQ0E7B0DXKYAQ10UWEtpctsqx1rXdy8fUAAiGN12BAAjJs5h81BMLQBpABprWBlkjflQB2CAc1AAH1B-QODQtHDzIA)\n\n## [](#commonjs-modules-are-supported)CommonJS modules are supported\n\nIn a `.js` file, TypeScript understands the CommonJS module format. Assignments to `exports` and `module.exports` are recognized as export declarations. Similarly, `require` function calls are recognized as module imports. For example:\n\njs\n\n`` // same as `import module \"fs\"` ``\n\n`const fs = require(\"fs\");`\n\n`` // same as `export function readFile` ``\n\n`module.exports.readFile = function (f) {`\n\n  `return fs.readFileSync(f);`\n\n`};`\n\nThe module support in JavaScript is much more syntactically forgiving than TypeScript’s module support. Most combinations of assignments and declarations are supported.\n\n## [](#classes-functions-and-object-literals-are-namespaces)Classes, functions, and object literals are namespaces\n\nClasses are namespaces in `.js` files. This can be used to nest classes, for example:\n\njs\n\n`class C {}`\n\n`C.D = class {};`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8C+AoWA6AItAvNUkMyA3EA)\n\nAnd, for pre-ES2015 code, it can be used to simulate static methods:\n\njs\n\n`function Outer() {`\n\n  `this.y = 2;`\n\n`}`\n\n`Outer.Inner = function () {`\n\n  `this.yy = 2;`\n\n`};`\n\n`Outer.Inner();`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAeRFApgJwBQEpEDeAUIolABYwDOAdAJ6IC8iATANxEC+RRqGmNAJJgwWJolCRYCRHkIkylWnQbN2XDrzRYhIrHjZA)\n\nIt can also be used to create simple namespaces:\n\njs\n\n`var ns = {};`\n\n`ns.C = class {};`\n\n`ns.func = function () {};`\n\n`ns;`\n\n[Try](https://www.typescriptlang.org/play/#code/G4QwTgBAdgzhC8EDeBfA3AKFgOgMIIgGMAbEGOVTHAMwFcpCC6GAXASwHsoIAKASmToMWGGiA)\n\nOther variants are allowed as well:\n\njs\n\n`// IIFE`\n\n`var ns = (function (n) {`\n\n  `return n || {};`\n\n`})();`\n\n`ns.CONST = 1;`\n\n`// defaulting to global`\n\n`var assign =`\n\n  `assign ||`\n\n  `function () {`\n\n    `// code goes here`\n\n  `};`\n\n`assign.extra = 1;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEElwMQUQKAG4EMBOoB2BnUBeUAKAMwFd0BjAFwEsB7dA9ASlAG85RQUBTC4le+gB9BrAL4BuOKMb5GkrADoAwgHkAcgGUAKrlABGSXBCgAJl0JJiAG2roA5qAo1QdqzQBGSK4lSgkmTCo7ehx2PwCgoUEwknJqOgJmNg4OYzIaMxcaLmwACy5uMIk4f0DghS4ADwoUJF0DIA)\n\n## [](#object-literals-are-open-ended)Object literals are open-ended\n\nIn a `.ts` file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a `.js` file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:\n\njs\n\n`var obj = { a: 1 };`\n\n`obj.b = 2; // Allowed`\n\n[Try](https://www.typescriptlang.org/play/#code/G4QwTgBA9gRgVhAvBA3hEAuCBGCBfAbgChY4A6GJCAJgIgHp6IBBAG1agHcBTAEyA)\n\nObject literals behave as if they have an index signature `[x:string]: any` that allows them to be treated as open maps instead of closed objects.\n\nLike other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:\n\njs\n\n`/** @type {{a: number}} */`\n\n`var obj = { a: 1 };`\n\n`obj.b = 2;`\n\n`Property 'b' does not exist on type '{ a: number; }'.2339Property 'b' does not exist on type '{ a: number; }'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZyBODAKlogBcBPAB1lAG9OBDEgOwCuAWwBGOAL4TQtYGgBuPbKDyiAVqAC8XUH1ABGUBIDcaVWoB0orWWNA)\n\n## [](#null-undefined-and-empty-array-initializers-are-of-type-any-or-any)null, undefined, and empty array initializers are of type any or any\\[\\]\n\nAny variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with \\[\\] will have type any\\[\\], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.\n\njs\n\n`function Foo(i = null) {`\n\n  `if (!i) i = 1;`\n\n  `var j = undefined;`\n\n  `j = 2;`\n\n  `this.l = [];`\n\n`}`\n\n`var foo = new Foo();`\n\n`foo.l.push(foo.i);`\n\n`foo.l.push(\"end\");`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAMTnAFDRBeRYQA2BAlIgN4BQiiMwi6AhDKVrgIwDcViAbgIYAnRACscicABMApsBhgpErtVG4ATEsRQAFjADOAOgJiA2gF0uAXwoV+Q4GjHyA7ijTpiXe3EP6ADiF0tdC99Zk80H39A9AAiKTAJGI8gA)\n\n## [](#function-parameters-are-optional-by-default)Function parameters are optional by default\n\nSince there is no way to specify optionality on parameters in pre-ES2015 JavaScript, all function parameters in `.js` file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.\n\nIt is important to note that it is an error to call a function with too many arguments.\n\nFor instance:\n\njs\n\n`function bar(a, b) {`\n\n  `console.log(a + \" \" + b);`\n\n`}`\n\n`bar(1); // OK, second argument considered optional`\n\n`bar(1, 2);`\n\n`bar(1, 2, 3); // Error, too many arguments`\n\n`Expected 0-2 arguments, but got 3.2554Expected 0-2 arguments, but got 3.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEEUBcBOBLSbALlADMBDAGxVgzHFl1wHtcVSB2ABm4DZQPfqABMAVjEAWNGQCuAOyL4W80ACMKuABQUANOoCUoAN5pQoSCpQsqsAHRUWAcx2gA1KABEX94YDcaAC+aGga2gCMBn6gmADyANL6tJbyACagmk6yALaw8tgWVvipTLDpLAAO2Mry1KGaWuH6IlH1Ec36AMxRMWAAosxs+tgsLKDZFPIAnhm4Wbn5KEA)\n\nJSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax (`[` `]`) to express optionality. e.g.:\n\njs\n\n`/**`\n\n `* @param {string} [somebody] - Somebody's name.`\n\n `*/`\n\n`function sayHello(somebody) {`\n\n  `if (!somebody) {`\n\n    `somebody = \"John Doe\";`\n\n  `}`\n\n  `console.log(\"Hello \" + somebody);`\n\n`}`\n\n`sayHello();`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAHAhgJ0QW0gbwM4BdkCWAdgOYC+kA2tgPZoCmARjQCYCeAupALSQDKdJqzYBybJCLp6AOighg4AGYBXIgGNcBGkUjZEbABL0ANsZoAKWg2bsAlFiiQCiyOYCEVoXYeRfuwTZskAC8kABEAFI0ABY6ACI09GEA3I5kjmratMYyZiTmYUamNOGQANT+1sK2qengeoYmZuY1QA)\n\n## [](#var-args-parameter-declaration-inferred-from-use-of-arguments)Var-args parameter declaration inferred from use of `arguments`\n\nA function whose body has a reference to the `arguments` reference is implicitly considered to have a var-arg parameter (i.e. `(...arg: any[]) => any`). Use JSDoc var-arg syntax to specify the type of the arguments.\n\njs\n\n`/** @param {...number} args */`\n\n`function sum(/* numbers */) {`\n\n  `var total = 0;`\n\n  `for (var i = 0; i < arguments.length; i++) {`\n\n    `total += arguments[i];`\n\n  `}`\n\n  `return total;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEAcEMCdYFtwG8B0mB2BXJAjAU3gF9wEBzAZ3BGACgAzHLAYwBcBLAey3CrwAKUOFwFiNOgEo09cOABuCcO27tYAG3ABecAAYA3HPCNu8cIKXnOO-QfA2APOXgU8hLOyroNHiuwALe04AahCZVGN5VXUtEN1Kd08qAG1OAF0jeRJjeEJ2HHg+GM0jEiA)\n\n## [](#unspecified-type-parameters-default-to-any)Unspecified type parameters default to `any`\n\nSince there is no natural syntax for specifying generic type parameters in JavaScript, an unspecified type parameter defaults to `any`.\n\n### [](#in-extends-clause)In extends clause\n\nFor instance, `React.Component` is defined to have two type parameters, `Props` and `State`. In a `.js` file, there is no legal way to specify these in the extends clause. By default the type arguments will be `any`:\n\njs\n\n`import { Component } from \"react\";`\n\n`class MyComponent extends Component {`\n\n  `render() {`\n\n    `this.props.b; // Allowed, since this.props is of type any`\n\n  `}`\n\n`}`\n\nUse JSDoc `@augments` to specify the types explicitly. for instance:\n\njs\n\n`import { Component } from \"react\";`\n\n`/**`\n\n `* @augments {Component<{a: number}, State>}`\n\n `*/`\n\n`class MyComponent extends Component {`\n\n  `render() {`\n\n    `this.props.b; // Error: b does not exist on {a:number}`\n\n  `}`\n\n`}`\n\n### [](#in-jsdoc-references)In JSDoc references\n\nAn unspecified type argument in JSDoc defaults to any:\n\njs\n\n`/** @type{Array} */`\n\n`var x = [];`\n\n`x.push(1); // OK`\n\n`x.push(\"string\"); // OK, x is of type Array<any>`\n\n`/** @type{Array.<number>} */`\n\n`var y = [];`\n\n`y.push(1); // OK`\n\n`y.push(\"string\"); // Error, string is not assignable to number`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCmBvAggJ3QQ1gX3CMAFABuW64AHuALzgDaAugNxFGUB08ArgM4AWACgCMASmbhgwcAHkA0uy58hAIl7R0ASwB2AcxXjJ0+QBoq4Tb3AB7AGbg4ScBmywAPFm2wAfG1AQYBBQXHA43bW4AWwAjRHRvfEJScnBYWgYWNlglARFDKVkFbJ5ctQ0dfXzpAFFMa3QzdS09Cytta2hwLF5eTV1tLGiAG0QHa3AImLigA)\n\n### [](#in-function-calls)In function calls\n\nA call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to `any`. For example:\n\njs\n\n`var p = new Promise((resolve, reject) => {`\n\n  `reject();`\n\n`});`\n\n`p; // Promise<any>;`\n\nTo learn all of the features available in JSDoc, see [the reference](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html).",
    "title": "TypeScript: Documentation - Type Checking JavaScript Files",
    "description": "How to add type checking to JavaScript files using TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html",
    "markdown": "# TypeScript: Documentation - JS Projects Utilizing TypeScript\n\nThe type system in TypeScript has different levels of strictness when working with a codebase:\n\n*   A type-system based only on inference with JavaScript code\n*   Incremental typing in JavaScript [via JSDoc](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n*   Using `// @ts-check` in a JavaScript file\n*   TypeScript code\n*   TypeScript with [`strict`](https://www.typescriptlang.org/tsconfig#strict) enabled\n\nEach step represents a move towards a safer type-system, but not every project needs that level of verification.\n\n## [](#typescript-with-javascript)TypeScript with JavaScript\n\nThis is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename. The [homepage](https://www.typescriptlang.org/) has a list of editors which have TypeScript plugins.\n\n## [](#providing-type-hints-in-js-via-jsdoc)Providing Type Hints in JS via JSDoc\n\nIn a `.js` file, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax.\n\nJSDoc annotations come before a declaration will be used to set the type of that declaration. For example:\n\njs\n\n`/** @type {number} */`\n\n`var x;`\n\n`x = 0; // OK`\n\n`x = false; // OK?!`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeA7ArgWwEaIE4C+4IwAUAG4CG+4AHgNxll3gC84ADA+MMOAHkA0i3bgAZlQA2AZ0Q8+goQH4AhEA)\n\nYou can find the full list of supported JSDoc patterns [in JSDoc Supported Types](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html).\n\n## [](#ts-check)`@ts-check`\n\nThe last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project. To enable errors in your JavaScript files add: `// @ts-check` to the first line in your `.js` files to have TypeScript raise it as an error.\n\njs\n\n`// @ts-check`\n\n`/** @type {number} */`\n\n`var x;`\n\n`x = 0; // OK`\n\n`x = false; // Not OK`\n\n`Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcGcFoGMAWBTeBrAUCCyBOuB7XaALlACYBmc8rAKjokgE8AHZUAbwDsBXAWwBGeAL6g6wDADcAhrlAAPANwYMC0AF5QABiWhsAeQDSazaABmMgDbRke7ADkCkUMaA)\n\nIf you have a lot of JavaScript files you want to add errors to then you can switch to using a [`jsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html). You can skip checking some files by adding a `// @ts-nocheck` comment to files.\n\nTypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding `// @ts-ignore` or `// @ts-expect-error` on the preceding line.\n\njs\n\n`// @ts-check`\n\n`/** @type {number} */`\n\n`var x;`\n\n`x = 0; // OK`\n\n`// @ts-expect-error`\n\n`x = false; // Not OK`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcGcFoGMAWBTeBrAUMAVNikBPAB2VAG8A7AVwFsAjZAJwF9RtgMA3AQ0dAA8A3Bgz9QAXlAAGQaBCgA8gGksYKHGT8S8SLCaMA9o1ETQAM24AbaMlnyAcgciKlQA)\n\nTo learn more about how JavaScript is interpreted by TypeScript read [How TS Type Checks JS](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)",
    "title": "TypeScript: Documentation - JS Projects Utilizing TypeScript",
    "description": "How to add type checking to JavaScript files using TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/tsconfig-json.html",
    "markdown": "# TypeScript: Documentation - What is a tsconfig.json\n\n## [](#overview)Overview\n\nThe presence of a `tsconfig.json` file in a directory indicates that the directory is the root of a TypeScript project. The `tsconfig.json` file specifies the root files and the compiler options required to compile the project.\n\nJavaScript projects can use a `jsconfig.json` file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.\n\nA project is compiled in one of the following ways:\n\n## [](#using-tsconfigjson-or-jsconfigjson)Using `tsconfig.json` or `jsconfig.json`\n\n*   By invoking tsc with no input files, in which case the compiler searches for the `tsconfig.json` file starting in the current directory and continuing up the parent directory chain.\n*   By invoking tsc with no input files and a `--project` (or just `-p`) command line option that specifies the path of a directory containing a `tsconfig.json` file, or a path to a valid `.json` file containing the configurations.\n\nWhen input files are specified on the command line, `tsconfig.json` files are ignored.\n\n## [](#examples)Examples\n\nExample `tsconfig.json` files:\n\n*   Using the [`files`](https://www.typescriptlang.org/tsconfig#files) property\n    \n    `{`\n    \n      `\"\": {`\n    \n        `\"\": \"commonjs\",`\n    \n        `\"\": true,`\n    \n        `\"\": true,`\n    \n        `\"\": true,`\n    \n        `\"\": true`\n    \n      `},`\n    \n      `\"\": [`\n    \n        `\"core.ts\",`\n    \n        `\"sys.ts\",`\n    \n        `\"types.ts\",`\n    \n        `\"scanner.ts\",`\n    \n        `\"parser.ts\",`\n    \n        `\"utilities.ts\",`\n    \n        `\"binder.ts\",`\n    \n        `\"checker.ts\",`\n    \n        `\"emitter.ts\",`\n    \n        `\"program.ts\",`\n    \n        `\"commandLineParser.ts\",`\n    \n        `\"tsc.ts\",`\n    \n        `\"diagnosticInformationMap.generated.ts\"`\n    \n      `]`\n    \n    `}`\n    \n*   Using the [`include`](https://www.typescriptlang.org/tsconfig#include) and [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) properties\n    \n    `{`\n    \n      `\"\": {`\n    \n        `\"\": \"system\",`\n    \n        `\"\": true,`\n    \n        `\"\": true,`\n    \n        `\"\": true,`\n    \n        `\"\": \"../../built/local/tsc.js\",`\n    \n        `\"\": true`\n    \n      `},`\n    \n      `\"\": [\"src/**/*\"],`\n    \n      `\"\": [\"**/*.spec.ts\"]`\n    \n    `}`\n    \n\n## [](#tsconfig-bases)TSConfig Bases\n\nDepending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at [github.com/tsconfig/bases](https://github.com/tsconfig/bases/). These are `tsconfig.json` files which your project extends from which simplifies your `tsconfig.json` by handling the runtime support.\n\nFor example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module [`@tsconfig/node12`](https://www.npmjs.com/package/@tsconfig/node12):\n\n`{`\n\n  `\"\": \"@tsconfig/node12/tsconfig.json\",`\n\n  `\"\": {`\n\n    `\"\": true`\n\n  `},`\n\n  `\"\": [\"src/**/*\"],`\n\n  `\"\": [\"**/*.spec.ts\"]`\n\n`}`\n\nThis lets your `tsconfig.json` focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we’re hoping the community can add more for different environments.\n\n## [](#details)Details\n\nThe `\"compilerOptions\"` property can be omitted, in which case the compiler’s defaults are used. See our full list of supported [Compiler Options](https://www.typescriptlang.org/tsconfig).\n\n## [](#tsconfig-reference)TSConfig Reference\n\nTo learn more about the hundreds of configuration options in the [TSConfig Reference](https://www.typescriptlang.org/tsconfig).\n\n## [](#schema)Schema\n\nThe `tsconfig.json` Schema can be found at [the JSON Schema Store](http://json.schemastore.org/tsconfig).",
    "title": "TypeScript: Documentation - What is a tsconfig.json",
    "description": "Learn about how a TSConfig works",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html",
    "markdown": "# TypeScript: Documentation - JSDoc Reference\n\nThe list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.\n\nNote:\n\n*   Any tags which are not explicitly listed below (such as `@async`) are not yet supported.\n*   Only documentation tags are supported in TypeScript files. The rest of the tags are only supported in JavaScript files.\n\n#### [](#types)Types\n\n*   [`@type`](#type)\n*   [`@param`](#param-and-returns) (or [`@arg`](#param-and-returns) or [`@argument`](#param-and-returns))\n*   [`@returns`](#param-and-returns) (or [`@return`](#param-and-returns))\n*   [`@typedef`](#typedef-callback-and-param)\n*   [`@callback`](#typedef-callback-and-param)\n*   [`@template`](#template)\n*   [`@satisfies`](#satisfies)\n\n#### [](#classes)Classes\n\n*   [Property Modifiers](#property-modifiers) `@public`, `@private`, `@protected`, `@readonly`\n*   [`@override`](#override)\n*   [`@extends`](#extends) (or [`@augments`](#extends))\n*   [`@implements`](#implements)\n*   [`@class`](#constructor) (or [`@constructor`](#constructor))\n*   [`@this`](#this)\n\n#### [](#documentation)Documentation\n\nDocumentation tags work in both TypeScript and JavaScript.\n\n*   [`@deprecated`](#deprecated)\n*   [`@see`](#see)\n*   [`@link`](#link)\n\n#### [](#other)Other\n\n*   [`@enum`](#enum)\n*   [`@author`](#author)\n*   [Other supported patterns](#other-supported-patterns)\n*   [Unsupported patterns](#unsupported-patterns)\n*   [Unsupported tags](#unsupported-tags)\n\nThe meaning is usually the same, or a superset, of the meaning of the tag given at [jsdoc.app](https://jsdoc.app/). The code below describes the differences and gives some example usage of each tag.\n\n**Note:** You can use [the playground to explore JSDoc support](https://www.typescriptlang.org/play?useJavaScript=truee=4#example/jsdoc-support).\n\n## [](#types-1)Types\n\n### [](#type)`@type`\n\nYou can reference types with the “@type” tag. The type can be:\n\n1.  Primitive, like `string` or `number`.\n2.  Declared in a TypeScript declaration, either global or imported.\n3.  Declared in a JSDoc [`@typedef`](#typedef-callback-and-param) tag.\n\nYou can use most JSDoc type syntax and any TypeScript syntax, from [the most basic like `string`](https://www.typescriptlang.org/docs/handbook/2/basic-types.html) to [the most advanced, like conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html).\n\njs\n\n`/**`\n\n `* @type {string}`\n\n `*/`\n\n`var s;`\n\n`/** @type {Window} */`\n\n`var win;`\n\n`/** @type {PromiseLike<string>} */`\n\n`var promisedString;`\n\n`// You can specify an HTML Element with DOM properties`\n\n`/** @type {HTMLElement} */`\n\n`var myElement = document.querySelector(selector);`\n\n`element.dataset.myData = \"\";`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4Gd4CcCWAdgOYC+UIw4AbgIa6RYDc44oMCK6GA6kQCYB7AO6loVOg2FEWbMHCRpMABVyCAtviyoAMvgDWqADw4CJAHxjKNepGRrN2-gGU8RYrODBIATUEBXSABjWkJGNCD8ADNESFDIAAkAFQBZHUgAUQAbVHVUQnhIaXgAC0gAEQB5FLs1NFx4fFQsOQ5FbmS07Nz8+CsJW3VEbryCyABeSCEg-1H4ADoAR39UXERnVByg+EFcAAptLZ3cAEoWTZ6C+f5aeFptBaHy29oJyAAid6YgA)\n\n`@type` can specify a union type — for example, something can be either a string or a boolean.\n\njs\n\n`/**`\n\n `* @type {string | boolean}`\n\n `*/`\n\n`var sb;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4Gd4CcCWAdgOaQA+kARgPbUA2qAhoQL5QjDgBujukWlANxA)\n\nYou can specify array types using a variety of syntaxes:\n\njs\n\n`/** @type {number[]} */`\n\n`var ns;`\n\n`/** @type {Array.<number>} */`\n\n`var jsdoc;`\n\n`/** @type {Array<number>} */`\n\n`var nas;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeA7ArgWwEaIE4DaAugL7gjABQAbgIb7hoDOA3FaBDAsigIL58dWADoAPJlwEAfOUq0G4AFbMAJgHsAxu05Q4SVAKGwJ2PPlkVq9RmjpsgA)\n\nYou can also specify object literal types. For example, an object with properties ‘a’ (string) and ‘b’ (number) uses the following syntax:\n\njs\n\n`/** @type {{ a: string, b: number }} */`\n\n`var var9;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeLwEMBc4DO0AnASwDsBzAGnACMcSBXAW2sQPAF93wRgAoANwxtBBAJwBuIA)\n\nYou can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax.\n\njs\n\n`/**`\n\n ``* A map-like object that maps arbitrary `string` properties to `number`s.``\n\n `*`\n\n `* @type {Object.<string, number>}`\n\n `*/`\n\n`var stringToNumber;`\n\n`/** @type {Object.<number, object>} */`\n\n`var arrayLike;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUhBSC2BDADgWgDYEsDWBTSAewCMArPAYwBdIqALJG5FAZ0iQCdisqPOBPSAAMWvLADsA5kMgoOhFHg5UseNlULDxAVwTElIgHRQI0SAAEq-RZADeAeTKUqhgDyiOEyQBpIOvUoAfAC+JsDgAG6ckB5eACqEAHK6+hwA3ODgoDCW1gQOTtRu-qm+JOTUIdDhURzsHHz8ADK4eGlAA)\n\nThe preceding two types are equivalent to the TypeScript types `{ [x: string]: number }` and `{ [x: number]: any }`. The compiler understands both syntaxes.\n\nYou can specify function types using either TypeScript or Google Closure syntax:\n\njs\n\n`/** @type {function(string, boolean): number} Closure syntax */`\n\n`var sbn;`\n\n`/** @type {(s: string, b: boolean) => number} TypeScript syntax */`\n\n`var sbn2;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeAzArgOwMbQJYD2WAFAM7QBO+WA5gDTgBGhhANogIZYCUAXOCwYAtk0SUAvuADCbQmQyVkZWFmicAHuBDAAUADdOlcGSZYA3LtAQYCZCnICK1OoyYCW7Lr3ABeAHyCImKS4AAqdgDKONTw0Caq6lo6BkYmZgBM5kA)\n\nOr you can just use the unspecified `Function` type:\n\njs\n\n`/** @type {Function} */`\n\n`var fn7;`\n\n`/** @type {function} */`\n\n`var fn6;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeAxArgOwMbQJYD2WAvuCMAFABuAhgE7gBmWA7ANyWgQwLIpNseIqXJU6jFgDZ2QA)\n\nOther types from Closure also work:\n\njs\n\n`/**`\n\n `* @type {*} - can be 'any' type`\n\n `*/`\n\n`var star;`\n\n`/**`\n\n `* @type {?} - unknown type (same as 'any')`\n\n `*/`\n\n`var question;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4gL6QLSQDGAhgHaQBG6A5GYtZEmlCMOAG7EBOkAzvNwDc4UBGhwm6DAH5cBAK6kA1qQD2Ad3KTIACl7EAtumK9ItUvQCULNpx4BHean4BLVaUFA)\n\n#### [](#casts)Casts\n\nTypeScript borrows cast syntax from Google Closure. This lets you cast types to other types by adding a `@type` tag before any parenthesized expression.\n\njs\n\n`/**`\n\n `* @type {number | string}`\n\n `*/`\n\n`var numberOrString = Math.random() < 0.5 ? \"hello\" : 100;`\n\n`var typeAssertedNumber = /** @type {number} */ (numberOrString);`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4DsCuBbAI1QCdIAfSAZ3mIEssBzAXyhGHADcBDU3QkgPLEAyjXoNIAXkgBZLvAAWAOmJcsAEwD2eABQBKSAB5IABiUBWSAH5IAIgWoANo823IALkgBGEyYDcnDyQSGgAgpSUJPCo6gBy+ESk0qAwCCjo2AkkTNDAkDp8iUKidIx6fkA)\n\nYou can even cast to `const` just like TypeScript:\n\njs\n\n`let one = /** @type {const} */(1);`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBA9gdiEF4IHoBUqIAEwE8AO8A3gMawDOYAvhKsgBQCMAlANxA)\n\n#### [](#import-types)Import types\n\nYou can import declarations from other files using import types. This syntax is TypeScript-specific and differs from the JSDoc standard:\n\njs\n\n`// @filename: types.d.ts`\n\n`export type Pet = {`\n\n  `name: string,`\n\n`};`\n\n`// @filename: main.js`\n\n`/**`\n\n `* @param {import(\"./types\").Pet} p`\n\n `*/`\n\n`function walk(p) {`\n\n  ``console.log(`Walking ${p.name}...`);``\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKALgTwA7wDOAdACYnZEBQ8AHvgPYBO2OB8oACvGwLygA3tVCgU6LEWzNoiAOYAaagF8A3NWogIMBOMyhUyWSQBWNYACoLIixHzJmaIdFRNWACgBEJYHkJFPAEoSHmxlUHwbYGpIAFdEAGNsaEZEUAB3ZFgAa3d8QKERUATUokYEElhGOXcAAwB1LOzZOVAAEkF8Ej1lEj7awPVlIA)\n\nimport types can be used in type alias declarations:\n\njs\n\n`/**`\n\n `* @typedef {import(\"./types\").Pet} Pet`\n\n `*/`\n\n`/**`\n\n `* @type {Pet}`\n\n `*/`\n\n`var myPet;`\n\n`myPet.name;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKALgTwA7wDOAdACYnZEBQ8AHvgPYBO2OB8oACvGwLygA3tVCgU6LEWzNoiAOYAaagF8A3NRAQYCcZlCpkskgCsamgLSWAxgFdsl8xoBUTkU4h5CZeJCHRUTKwAFABEJMCexCEAlCQ82MrcvG7A1M6uoO7gkULxyinUAG7IzPq48eqo5bwkuqpAA)\n\nimport types can be used to get the type of a value from a module if you don’t know the type, or if it has a large type that is annoying to type:\n\njs\n\n`/**`\n\n `* @type {typeof import(\"./accounts\").userAccount}`\n\n `*/`\n\n`var x = require(\"./accounts\").userAccount;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZBjHB7AV0QBcBnAOgBMLyAoeADwAd8AnE0AxMzws+GwCCeIqVABeUAG86oUCnRYARADk08ZQBo52KlTbwyZFUMR6DRstt2teyWAGF8VTKGU35BYiTYBPFU9QZlhkRHgSQJ15Mj9eeFQo3QBzB2RGAPcg4mgAN0EBJIBfAG46EAgYBEU3VGRoRAoAKzJysABaTpxCEk728oAqAbkBiBI-ZngZccn8SFBoVFYOAAplCmBcb1JrAEoKfkERbZIikeA6XOQ2UEZJUEMAR0JoQzWNrbFyZX3D4VEfCUgA)\n\n### [](#param-and-returns)`@param` and `@returns`\n\n`@param` uses the same type syntax as `@type`, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:\n\njs\n\n`// Parameters may be declared in a variety of syntactic forms`\n\n`/**`\n\n `* @param {string}  p1 - A string param.`\n\n `* @param {string=} p2 - An optional param (Google Closure syntax)`\n\n `* @param {string} [p3] - Another optional param (JSDoc syntax).`\n\n `* @param {string} [p4=\"test\"] - An optional param with a default value`\n\n `* @returns {string} This is the result`\n\n `*/`\n\n`function stringsStringStrings(p1, p2, p3, p4) {`\n\n  `// TODO`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAUEMCdIWwKYBcHQM6jpAnqARgqACYIDGANjAkaAJYB2okoAbjLcrgPYBmoa2ekkikktUqB5docNAChgAKkVzQi0AAEADjHigA3miTQGAcwC+oUFoCMoALSgAgv2NnruuADpV67Z4MjE3pTAF5LLQAmB2dGLi0xLnpIcg9YOFAACgBxLi5TckIAYXIuNABXaEIBIUgADwBKX00ddMC3EMsAbS0AZgBdGKd6LiQAC1RQeMTk1Na9TIApAGUAES4JGuFGnzUWgMMOi1AegBZQgCIUIwvBx2GphNoklLS9AHdacaZiBB5IcrkJCsFLlBDNDRVJCVegYQ7BY4AFTGtAwqNA40IVQqQN8wDkPHK9FEz0YQTMaGWRypCLQmVsABprJEmX1WacGgZVKAQKBEQB5Vb8uTmIA)\n\nLikewise, for the return type of a function:\n\njs\n\n`/**`\n\n `* @return {PromiseLike<string>}`\n\n `*/`\n\n`function ps() {}`\n\n`/**`\n\n `* @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'`\n\n `*/`\n\n`function ab() {}`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAnApgFwK7wHaQN4AV4D2AtgJYDOiAMiQNaIA8Zy8JGA5gHwC+UIw4AM1QYAxshIEsABzIAKAJQ4e4UBGhwkaTGRzZIAQwBckJi3YAaSACNjGVESuJ4kLl0gBaSAFl9AT0ioFJAA5Ago6BhkwQY6AO6IADYJMSFhWhjBvPxCouKSBlYKSkA)\n\n### [](#typedef-callback-and-param)`@typedef`, `@callback`, and `@param`\n\nYou can define complex types with `@typedef`. Similar syntax works with `@param`.\n\njs\n\n`/**`\n\n `* @typedef {Object} SpecialType - creates a new type named 'SpecialType'`\n\n `* @property {string} prop1 - a string property of SpecialType`\n\n `* @property {number} prop2 - a number property of SpecialType`\n\n `* @property {number=} prop3 - an optional number property of SpecialType`\n\n `* @prop {number} [prop4] - an optional number property of SpecialType`\n\n `* @prop {number} [prop5=42] - an optional number property of SpecialType with default`\n\n `*/`\n\n`/** @type {SpecialType} */`\n\n`var specialTypeObject;`\n\n`specialTypeObject.prop3;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKYBNUDNIG8DyARgFaoDG8AvpAMppkCWAhgDYAqKqkAtJGQE6om8VAGdITSADtUAd0hI00pgFsMkAOR1yzdpw1QYsZPwD2afkjyj4-BlIDm1E+YCMPCZBt3HkFxatTHG1GVg40Qzh-VEtEPCkAVxVCGOczZAAmD0lE5Ji-dJjA4PpdcNRI40LY+KSU-gBeNPMAZmypSHN4BlMpVmk6-OiaoNpSsM5K-1q8-moAbX8AFgBdds7kbt7+3PqC8yK40ZCyyego9Jn6hf8AVgaljLXeJg6unr6WAdn9gKOSnQTJSyBjwAAWkEwWCYCRY8EMwHA4FARkUXFwJyBqGoIERADcmPwvOM9GgiKQKABucCiEnlcnkeAAOn8LUpQA)\n\nYou can use either `object` or `Object` on the first line.\n\njs\n\n`/**`\n\n `* @typedef {object} SpecialType1 - creates a new type named 'SpecialType1'`\n\n `* @property {string} prop1 - a string property of SpecialType1`\n\n `* @property {number} prop2 - a number property of SpecialType1`\n\n `* @property {number=} prop3 - an optional number property of SpecialType1`\n\n `*/`\n\n`/** @type {SpecialType1} */`\n\n`var specialTypeObject1;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKYBNUDNIG8D2ARgFaoDG8AvpAMppkCWAhgDYAqKqAjJALSRkATqibxUAZ0hNIAO1QB3SEjSymAWwyQA5HXLN2nLlqgxYyQfjSCkecfEEMZAc2rnLPftLsPnkN1Zt8HF1GVg40LhM4f1RrRDwZAFc1QljXC2QAJj4pWWTUwT8M2MDg+n1w7iizYriE-NiAXnTLAGYcphlIS3gGfBlWPJTYossS+KDacrDDE2BwcFBTZVQ8EIrDahB5gDcmQvFpgzQAeRJyeC4AbiA)\n\n`@param` allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:\n\njs\n\n`/**`\n\n `* @param {Object} options - The shape is the same as SpecialType above`\n\n `* @param {string} options.prop1`\n\n `* @param {number} options.prop2`\n\n `* @param {number=} options.prop3`\n\n `* @param {number} [options.prop4]`\n\n `* @param {number} [options.prop5=42]`\n\n `*/`\n\n`function special(options) {`\n\n  `return (options.prop4 || 1001) + options.prop5;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAHAhgJ0QW0gbwPICMBWApgMYAuAvpAPbykCWVAdgM6QC0kAKgBaGTPdE8PnVale-dH0SsAysOJ1EAG04BPYZES4qAN0JQYCFOizNSyOowDmlGvSbMAdPGQ0AjIbhJUGTIwBXNFxCZDtaBhYXN3gAJi9jXyxA4NCAXnCHKNcaAGYEn1N-IJCwyABte0jnHPgAFgBdApM-FNLKSojHaJoAVjS62KboYHAAMwDGMkj+BSVlAAoqxwBKLChIZEJSAORGSCWu7Ji6yAAfM8h3AAZr9zWAamojmpjegG5wciA)\n\n`@callback` is similar to `@typedef`, but it specifies a function type instead of an object type:\n\njs\n\n`/**`\n\n `* @callback Predicate`\n\n `* @param {string} data`\n\n `* @param {number} [index]`\n\n `* @returns {boolean}`\n\n `*/`\n\n`/** @type {Predicate} */`\n\n`const ok = (s) => !(s.length % 2);`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBBjAhgG2QI0fA1pACgJwFMATASyQBdCoZYAHRfRAW0gG8BnC-UgOwHMAvpGKIKiGnAZNWbXgFdmaQvmEBtPsUIAPALqTYRCvPy8O7NAHtLyQol6CawcOFC0KATzqF2BEuTFCYRBneEszCkhLHABeSAAKDgBKSBiAPkgAQkSAOlsBCgALSABSSAAmJIBuIA)\n\nOf course, any of these types can be declared using TypeScript syntax in a single-line `@typedef`:\n\njs\n\n`/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */`\n\n`/** @typedef {(data: string, index?: number) => boolean} Predicate */`\n\n### [](#template)`@template`\n\nYou can declare type parameters with the `@template` tag. This lets you make functions, classes, or types that are generic:\n\njs\n\n`/**`\n\n `* @template T`\n\n `* @param {T} x - A generic parameter that flows through to the return type`\n\n `* @returns {T}`\n\n `*/`\n\n`function id(x) {`\n\n  `return x;`\n\n`}`\n\n`const a = id(\"string\");`\n\n`const b = id(123);`\n\n`const c = id({});`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIBUoyyqYBOmykA3rgL6QAekAtJAIKQDmiAdoiQJYBjSMTLJESEpHgALbJABm6APYB3AM7SZJZQFcOM6cq2JIJCbpLdpAT1SICcc-EvdN1GgWDgFu7oPh+ZWt+ABMACnoASiooMwsrBgBucE9wQWD1eEhMSABeSDDwgCIsgW4OYqiUjLdsgCN8woiARgAmAGZq9Mzs4QKiyhpqoA)\n\nUse comma or multiple tags to declare multiple type parameters:\n\njs\n\n`/**`\n\n `* @template T,U,V`\n\n `* @template W,X`\n\n `*/`\n\nYou can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:\n\njs\n\n`/**`\n\n `* @template {string} K - K must be a string or string literal`\n\n `* @template {{ serious(): string }} Seriousalizable - must have a serious method`\n\n `* @param {K} key`\n\n `* @param {Seriousalizable} object`\n\n `*/`\n\n`function seriousalize(key, object) {`\n\n  `// ????`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIG8DO8ATgJYB2A5gL6QDSkAtHZMgK6GQBGikmkhpSpAD2RfsXIVI6EkiKZ0UGAhQZsPXLn6JSw9gAoAlAC5xgqVRoBlHST34FJAF6ZO6HkzYcAFpgBuPHz4tvYsiPDewgAmSnComPLIeLQ0ANaIAJ6xsPGJeDa67I4ubog0wpwAVogAxvBKwOAAZqxkdXZk2oUOMk6I+ukZADQiVbXwhnhQkMDAkAD8i-PgVEA)\n\nFinally, you can specify a default for a type parameter:\n\njs\n\n`/** @template [T=object] */`\n\n`class Cache {`\n\n    `/** @param {T} initial */`\n\n    `constructor(initial) {`\n\n    `}`\n\n`}`\n\n`let c = new Cache()`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcFMFsAOAbAhncBtAKgXgPYBGAVrAMbQC64IwAUGWgM5PgDCqZAFrOAN51wQ8KAiREqAE6p4-bAF9wASwB2S6EtTIa9YeDL4VTaJICuFfJIAUq9ZuQBKfoOHy6b5LGj7wucCtgAd3ZOHisHIA)\n\n### [](#satisfies)`@satisfies`\n\n`@satisfies` provides access to the postfix [operator `satisfies`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html) in TypeScript. Satisfies is used to declare that a value implements a type but does not affect the type of the value.\n\njs\n\n`// @ts-check`\n\n`/**`\n\n `* @typedef {\"hello world\" | \"Hello, world\"} WelcomeMessage`\n\n `*/`\n\n`/** @satisfies {WelcomeMessage} */`\n\n`const message = \"hello world\"`\n\n        `const message: \"hello world\"`\n\n`/** @satisfies {WelcomeMessage} */`\n\n`Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.1360Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.  const failingMessage = \"Hello world!\"  /** @type {WelcomeMessage} */  const messageUsingType = \"hello world\"               const messageUsingType: WelcomeMessage  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwGYBsAGAUCBAC6IC0AxgBaTkDWBAVA3qA8QJ4AOkAJpAGagA3gCJqAG3FxQAdwTieI0AB9QIgBKRJcADSz5igL6gA6lvJwAtpACykRIgCGAc0gsGwPIzbgnRAJaI-P72wmbiFtZ2Di6Qxh54FgB2iESg1jGuoAC8ahJS+tAKIgRgoOWgAHoA-F7ATBB+gcGhQuGRtvZOrvGeyamg-I7+4v5JztHdkDlqmtqFCgCEJd4c3GHmVp2Zcax9cClpGVMAqohjzgAqXNO5YloFckWKpRXlNUA)\n\n## [](#classes-1)Classes\n\nClasses can be declared as ES6 classes.\n\njs\n\n`class C {`\n\n  `/**`\n\n   `* @param {number} data`\n\n   `*/`\n\n  `constructor(data) {`\n\n    `// property types can be inferred`\n\n    `this.name = \"foo\";`\n\n    `// or set explicitly`\n\n    `/** @type {string | null} */`\n\n    `this.title = null;`\n\n    `// or simply annotated, if they're set elsewhere`\n\n    `/** @type {number} */`\n\n    `this.size;`\n\n    `this.initialize(data); // Should error, initializer expects a string`\n\n  `}`\n\n  `/**`\n\n   `* @param {string} s`\n\n   `*/`\n\n  `initialize = function (s) {`\n\n    `this.size = s.length;`\n\n  `};`\n\n`}`\n\n`var c = new C(0);`\n\n`// C should only be called with new, but`\n\n`// because it is JavaScript, this is allowed and`\n\n`// considered an 'any'.`\n\n`var result = C(1);`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8BQ1oHoBUGWo9AAgA5gBOYAtogHYCu5ARgKYkC+0AJmAC5g7QZocwAPZUIXEjWBdhJABSceASkR90aaIRLDCzLgE9oB3TGBgq0JtACWVAGbMSjdmq4ALaxAB0VCo2gAvNAARHbCwsEA3EhqaBqy0BCMXNCMAB6EINbA1lwg+rFYBMb+COIktgDm0AA+0LQgIGwCrh7eXLkg-kENINGx8SSJ1uSZhuZUwjxczgA0NnZGboz6AOROicmpIEkA7stOhXj4JdR0TKz8gqio7p5eENYAXoz9N0v3trnWYFkvCtwwEpIupoABlNzCGggdipEjaEjzL4dX7PZipDKMaQwMCJCRVHAsHCYbA3Y7EMiUMr4qiVNgQPgtVDIn5-brQOw0KjSayiaByCAqZDvO7eR4vQKJLxdWnuaKoFjRIlIABupGgwElVEYuzgcgADMCYnE4IlIdDYaJ8pZ-GZGs5oLtcm56jr5vQaFwkCamGYaEkbClPNAAFJgNVg4AVQhceaimw4xrCXYO8wuE0iMTWdjMVMWVbmNZeVXqpwQaEpIKwOQARmBQA)\n\nThey can also be declared as constructor functions; use [`@constructor`](#constructor) along with [`@this`](#this) for this.\n\n### [](#property-modifiers)Property Modifiers\n\n`@public`, `@private`, and `@protected` work exactly like `public`, `private`, and `protected` in TypeScript:\n\njs\n\n`// @ts-check`\n\n`class Car {`\n\n  `constructor() {`\n\n    `/** @private */`\n\n    `this.identifier = 100;`\n\n  `}`\n\n  `printIdentifier() {`\n\n    `console.log(this.identifier);`\n\n  `}`\n\n`}`\n\n`const c = new Car();`\n\n`console.log(c.identifier);`\n\n`Property 'identifier' is private and only accessible within class 'Car'.2341Property 'identifier' is private and only accessible within class 'Car'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAUCBAC6IC0AxgBaTkDWee5ANgIaKKgDCL0oA3nlChycAHaIi0AK7kiCABQBKfoKGhgAKg0QADtACWANxZFIoDcFVCilfYgB0+gCaRRRfQDN9MUAF5QOAAMgQDcqgC+DEJ6+m4Aki5unt7QSipqwmKIcEyQ9kxwAObyNnaOie5eMIphQpGRjFlEwn6gopAA7lw8SmEi4jl5BcXk5a6VKTVAA)\n\n*   `@public` is always implied and can be left off, but means that a property can be reached from anywhere.\n*   `@private` means that a property can only be used within the containing class.\n*   `@protected` means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.\n\n`@public`, `@private`, and `@protected` do not work in constructor functions.\n\n### [](#readonly)`@readonly`\n\nThe `@readonly` modifier ensures that a property is only ever written to during initialization.\n\njs\n\n`// @ts-check`\n\n`class Car {`\n\n  `constructor() {`\n\n    `/** @readonly */`\n\n    `this.identifier = 100;`\n\n  `}`\n\n  `printIdentifier() {`\n\n    `console.log(this.identifier);`\n\n  `}`\n\n`}`\n\n`const c = new Car();`\n\n`console.log(c.identifier);`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUCBAC6IC0AxgBaTkDWee5ANgIaKKgDCL0oA3nlChycAHaIi0AK7kiCABQBKfoKGhgAKg0RokFgBMxTAJ6gNwVUKKUAlogB0N-ZFFEbAMxsxQAXlABGHBwAblUAXwYhAAdoG1cASWdXDy9oJRU1YTFEOCZIeyY4AHN5aztHJLdPGEVQoQiIxmyiYV9QUUgAdy4eJVCRcVz8wpLyCpcq1NqgA)\n\n### [](#override)`@override`\n\n`@override` works the same way as in TypeScript; use it on methods that override a method from a base class:\n\njs\n\n`export class C {`\n\n  `m() { }`\n\n`}`\n\n`class D extends C {`\n\n  `/** @override */`\n\n  `m() { }`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAYwDYEMDOa4GE4G8BQccAtgBQCUecAvvrcupgCJygzAB2AJpjgUQHoAVELgABCADdgUKAEsuwOEIGESFKrWpA)\n\nSet `noImplicitOverride: true` in tsconfig to check overrides.\n\n### [](#extends)`@extends`\n\nWhen JavaScript classes extend a generic base class, there is no JavaScript syntax for passing a type argument. The `@extends` tag allows this:\n\njs\n\n`/**`\n\n `* @template T`\n\n `* @extends {Set<T>}`\n\n `*/`\n\n`class SortableSet extends Set {`\n\n  `// ...`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIBUoyyIAeSAdgCYDOkA3gMqLwA8uAfAL4HDgDGWVGvQD2AJ3iYARukSN4kEuWqQ5dKJGDBIAOl3gOQA)\n\nNote that `@extends` only works with classes. Currently, there is no way for a constructor function to extend a class.\n\n### [](#implements)`@implements`\n\nIn the same way, there is no JavaScript syntax for implementing a TypeScript interface. The `@implements` tag works just like in TypeScript:\n\njs\n\n`/** @implements {Print} */`\n\n`class TextBook {`\n\n  `print() {`\n\n    `// TODO`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEEsFsAcA2BTWyB2AXAzuA3gAoBO0WAvuCMAFADGiAhtrgCrIAemAQgPY8DW+auHDwSWABQBKISJHBg4FgHkAIsuHgy1MkA)\n\n### [](#constructor)`@constructor`\n\nThe compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a `@constructor` tag:\n\njs\n\n`/**`\n\n `* @constructor`\n\n `* @param {number} data`\n\n `*/`\n\n`function C(data) {`\n\n  `// property types can be inferred`\n\n  `this.name = \"foo\";`\n\n  `// or set explicitly`\n\n  `/** @type {string | null} */`\n\n  `this.title = null;`\n\n  `// or simply annotated, if they're set elsewhere`\n\n  `/** @type {number} */`\n\n  `this.size;`\n\n  `this.initialize(data);`\n\n`Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.  }  /**   * @param {string} s   */  C.prototype.initialize = function (s) {    this.size = s.length;  };  var c = new C(0);  c.size;  var result = C(1);  Value of type 'typeof C' is not callable. Did you mean to include 'new'?2348Value of type 'typeof C' is not callable. Did you mean to include 'new'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGYAWAVjKoA4MAqJtUJiSPAOxQBdsAV0h8CbDuAAOAQ2zSAtqADe3QfIBGOAL6gAJtL7TxwNADNB3EQEseoAMIAKfYYCUytqEyT8knHwCeoAG+KKCQ0tygmqBW3KY42LC6HnzQVigAdNwKsKAAvKAARKZ4eIUA3GgemASgKLB8oLAAHpIANlaQVnxt-tUsEMG5SvzYsQDmoAA+oKptbTpMJqBBaZl83W25BXNtldVgtShW8u2BEdx4hnxJADQxpquw-gDkiXUNTW31AO5wif0JENlKoNNp2MtVukMscAF6wfYrVLQ2LdKzSDrwpwGaQuSpaZisdgQGRyRQjAQTHToCFoOwZbxXK7+XwZVEbDFWeH5UDmSwbWwOFBuJQpNYwrnbOoZLbccapfH7ABusjCPO4sB+9gcAAY8WhIBL4crVYkUII2o0Co4AIx4oA)\n\n> Note: Error messages only show up in JS codebases with [a JSConfig](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) and [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs) enabled.\n\nWith `@constructor`, `this` is checked inside the constructor function `C`, so you will get suggestions for the `initialize` method and an error if you pass it a number. Your editor may also show warnings if you call `C` instead of constructing it.\n\nUnfortunately, this means that constructor functions that are also callable cannot use `@constructor`.\n\n### [](#this)`@this`\n\nThe compiler can usually figure out the type of `this` when it has some context to work with. When it doesn’t, you can explicitly specify the type of `this` with `@this`:\n\njs\n\n`/**`\n\n `* @this {HTMLElement}`\n\n `* @param {*} e`\n\n `*/`\n\n`function callbackForLater(e) {`\n\n  `this.clientHeight = parseInt(e); // should be fine!`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAFgSwM6QN4AkAqBZAGQFEAbAUwFsyA7eAXyhlgAcBDAJ1YsxDsjMbBwAMwCu1AMbxkAe2qQJrEiQBGrCQGsAYjPYFW8MuwAUZAJSYokJGgB0EkshrwsZZAHNE8SAF5IbdlQyAElaUzMAbkhgYEhURBlREgATSBUySGFkajIAQnA6IA)\n\n## [](#documentation-1)Documentation\n\n### [](#deprecated)`@deprecated`\n\nWhen a function, method, or property is deprecated you can let users know by marking it with a `/** @deprecated */` JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed in a strike-through style ~like this~.\n\njs\n\n`/** @deprecated */`\n\n`const apiV1 = {};`\n\n`const apiV2 = {};`\n\n`apiV;`\n\n*   `apiV1`\n*   `apiV2`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFDAFSYgEwKYAO8+AxgIYAu+uomwap0kKlo5hAlgGoCMoAXlABvAL4BuRs1bsu3AEyCREtGg49JIUAD0APqqA)\n\n### [](#see)`@see`\n\n`@see` lets you link to other names in your program:\n\nts\n\n`type Box<T> = { t: T }`\n\n`/** @see Box for implementation details */`\n\n`type Boxify<T> = { [K in keyof T]: Box<T> };`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeVgBcUKUAvgFAD0AVNVAAIDOE08CUAZnAE5QCWAWzAAbCAIgA7YAENgfOBKgATCDL7DGUapXKhIsRHw4hUGbHgDaAaX6KA1hBBwOxALpE2psgG4gA)\n\nSome editors will turn `Box` into a link to make it easy to jump there and back.\n\n### [](#link)`@link`\n\n`@link` is like `@see`, except that it can be used inside other tags:\n\nts\n\n`type Box<T> = { t: T }`\n\n`/** @returns A {@link Box} containing the parameter. */`\n\n`function box<U>(u: U): Box<U> {`\n\n  `return { t: u };`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeVgBcUKUAvgFAD0AVNVAAIBOEwArowHYDOUAgrvQA2ASw4BrWIlJQAxnA7AAhqNEBzfAAtoYRY0UBbFhEYA6KNUrkAZqw4zgw+VABGiJAFU0AClZF3ASiJ4ZE9ccigoZjZOXHwiVjIAbnJSIA)\n\n## [](#other-1)Other\n\n### [](#enum)`@enum`\n\nThe `@enum` tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in JavaScript, it does not allow other members. `@enum` is intended for compatibility with Google Closure’s `@enum` tag.\n\njs\n\n`/** @enum {number} */`\n\n`const JSDocState = {`\n\n  `BeginningOfLine: 0,`\n\n  `SawAsterisk: 1,`\n\n  `SavingComments: 2,`\n\n`};`\n\n`JSDocState.SawAsterisk;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEFMDsFcC24DeDECNoCcC+4RgAoAYwHtYBnAF3ACkBlAETJIeoENrpwBeVIuHAAhaAHMAlrFhSxAeQBmAGSnQAXOAAMAGkHgGHAO4BBGjgmUA1hoCMuoQYBusgMJlEiONUoaATLtwAbiIiRhY2Tm4AOgMTM2wLS0CgA)\n\nNote that `@enum` is quite different from, and much simpler than, TypeScript’s `enum`. However, unlike TypeScript’s enums, `@enum` can have any type:\n\njs\n\n`/** @enum {function(number): number} */`\n\n`const MathFuncs = {`\n\n  `add1: (n) => n + 1,`\n\n  `id: (n) => -n,`\n\n  `sub1: (n) => n - 1,`\n\n`};`\n\n`MathFuncs.add1;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEFMDsFcC24DeAzesDGAXAlgPawAUCiARtAE4CUAXOGZVQL7gjABQWRAzjuACyAQxwALAGKYsvcAF5UncOGEATVQEYGpGvIB8jcAGpwGgDRLweVdti65BgLSwLy3vHJbwO-YcemLFgBuTk4RcSlsXgA6NU0goA)\n\nYou can specify the author of an item with `@author`:\n\nts\n\n`/**`\n\n `* Welcome to awesome.ts`\n\n `* @author Ian Awesome <i.am.awesome@example.com>`\n\n `*/`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUh1BTANgYwPYFt6QC6sgQwHd4BnDeAOmxKhgAF8BXbAC1QCdIBJfAO0gCCxMpkgAeAJYV86acPJ14ADxkAHRJTToAfLWBA)\n\nRemember to surround the email address with angle brackets. Otherwise, `@example` will be parsed as a new tag.\n\n### [](#other-supported-patterns)Other supported patterns\n\njs\n\n`var someObj = {`\n\n  `/**`\n\n   `* @param {string} param1 - JSDocs on property assignments work`\n\n   `*/`\n\n  `x: function (param1) {},`\n\n`};`\n\n`/**`\n\n `* As do jsdocs on variable assignments`\n\n `* @return {Window}`\n\n `*/`\n\n`let someFunc = function () {};`\n\n`/**`\n\n `* And class methods`\n\n `* @param {string} greeting The greeting to use`\n\n `*/`\n\n`Foo.prototype.sayHi = (greeting) => console.log(\"Hi!\");`\n\n`/**`\n\n `* And arrow function expressions`\n\n `* @param {number} x - A multiplier`\n\n `*/`\n\n`let myArrow = (x) => x * x;`\n\n`/**`\n\n `* Which means it works for function components in JSX too`\n\n `* @param {{a: string, b: number}} props - Some param`\n\n `*/`\n\n`var fc = (props) => <div>{props.a.charAt(0)}</div>;`\n\n`/**`\n\n `* A parameter can be a class constructor, using Google Closure syntax.`\n\n `*`\n\n `* @param {{new(...args: any[]): object}} C - The class to register`\n\n `*/`\n\n`function registerClass(C) {}`\n\n`/**`\n\n `* @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')`\n\n `*/`\n\n`function fn10(p1) {}`\n\n`/**`\n\n `* @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')`\n\n `*/`\n\n`function fn9(p1) {`\n\n  `return p1.join();`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBiD29oG8C+AoA9J6BafwArgC767oBuYATtBPALYCmA8gEYBW0AvCutNEwAqIfwFDoAAQAONMAxQRi1AJYA7AOapos6vICMeaACkAygBF4wGPDU7q8aU2rEAntEgQVGtczXEYAHd4agBrMWghTDEADwAuaAAzQjVgYhVbaAAKXQMAShRUABp0VABudCwRfgkAQRgAEyQOCCbraEyqVTA2ECYPKG9fJn8IGqlqJmJCajtkAHV1JsCMSOi+4jpGJlgU4B4kvfTMrIK0CqrRSOhatQboUE9oZmIAC3gGseuZOQVkJVUmm0GkmU3UGmgABVXv0QUwwZpoMQkIQIEwatEEPAAHTSBzItxObEQMCuAASKgOWThCI0BW4AD4HrZ6H1sSB4BosgAiCkAQm5eQuwiudTuHmoDkCh1SxzsTBieKYgxZ4x+ej+akIDDYzm0MSMtWehBA6WkIBUzgx6A2z1ctUl8GlvCyMXpTINEhiwuq13mrxUwFezyYYDUMBUm2CYRgiRCMrSGTswEY0lsIwC0HUJlMAA0kYg1bk-sgwAkAeCitA2AktTq9do8Y4YLhoKZtjpftaukl9i6m9IIO7oAAeBoqCgM5ADiDYsDYoM0WrELIABjyqBHmHHk59opunY1U2cDzD1f6YAe4CgzPDykIaRCVdR4OgAHFEBo+tAAMIciAzP0ECuP4YAxNiNRFr8KDIGoTCBFk2JITQGgQAkYauAA2gAunkCTwJwTBpKg2g-kY0L9I8N7ItAkwaCoShWms6DJLKSa0Uw9GMdQf6eFkP5nBglxQRqKBIcSyjgo2hitkaADkkxKHJEoQlkNB6K4BTwIkdCSZos7ZMoobEEw9yQNAckYXJeTWqxiaZIkaj6KuOT6IJlQiiJ8hiUhFZAjoMkHgpyrEMpKHZOppJaTpfmodihmTGAJlmTAllqK41m2Uc7GOQAnK5ZxiJM0yzAF2IcPA6inBUqBAA)\n\n### [](#unsupported-patterns)Unsupported patterns\n\nPostfix equals on a property type in an object literal type doesn’t specify an optional property:\n\njs\n\n`/**`\n\n `* @type {{ a: string, b: number= }}`\n\n `*/`\n\n`var wrong;`\n\n`/**`\n\n `* Use postfix question on the property name instead:`\n\n `* @type {{ a: string, b?: number }}`\n\n `*/`\n\n`var right;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4cgQwFyQDO8ATgJYB2A5gDSQBGBFArgLb2okC8kAvr1BDBwANxwlIAdxIB7agG5woCNEgBVQumQziAMzIAPSAEdmqYmTmQr8ABZbZaEkkgUcrdJWKocAEzyCcEhomNj4RKSUtAwA-ExsHBL8gsJiEuRUtvDyQA)\n\nNullable types only have meaning if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is on:\n\njs\n\n`/**`\n\n `* @type {?number}`\n\n `* With strictNullChecks: true  -- number | null`\n\n `* With strictNullChecks: false -- number`\n\n `*/`\n\n`var nullable;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4H4B2BXAWwCNUAnAXyhgHUBLeAC0gGd5TaBjeAOTwBs+AYQaoOAa2YAuSGzzpIAWgWR8xMpAA+K-nyqQ6jFm048dw0ROkAzAIZ9m6JdrWkqwcADcbpbQJtE+VABuIA)\n\nThe TypeScript-native syntax is a union type:\n\njs\n\n`/**`\n\n `* @type {number | null}`\n\n `* With strictNullChecks: true  -- number | null`\n\n `* With strictNullChecks: false -- number`\n\n `*/`\n\n`var unionNullable;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4DsCuBbAI1QCdIAfSXAGyoF8oYB1AS3gAtIBneY5gY3gA5HDQDCbVHwDWnAFyQeOdJAC0KyviKkK1Kg0gt2XHvyEiq4yTPkAzAIZVO6NRsIkGwcADc7pHFmYAeyxhGjsCKlQAbiA)\n\nNon-nullable types have no meaning and are treated just as their original type:\n\njs\n\n`/**`\n\n `* @type {!number}`\n\n `* Just has type number`\n\n `*/`\n\n`var normal;`\n\n[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4EIB2BXAWwCNUAnAXyhgCk8BneSACwEM7Ik1J9iyrhwANxaluAe1IEWAGwDcQA)\n\nUnlike JSDoc’s type system, TypeScript only allows you to mark types as containing null or not. There is no explicit non-nullability — if strictNullChecks is on, then `number` is not nullable. If it is off, then `number` is nullable.\n\n### [](#unsupported-tags)Unsupported tags\n\nTypeScript ignores any unsupported JSDoc tags.\n\nThe following tags have open issues to support them:\n\n*   `@memberof` ([issue #7237](https://github.com/Microsoft/TypeScript/issues/7237))\n*   `@yields` ([issue #23857](https://github.com/Microsoft/TypeScript/issues/23857))\n*   `@member` ([issue #56674](https://github.com/microsoft/TypeScript/issues/56674))\n\n### [](#legacy-type-synonyms)Legacy type synonyms\n\nA number of common types are given aliases for compatibility with old JavaScript code. Some of the aliases are the same as existing types, although most of those are rarely used. For example, `String` is treated as an alias for `string`. Even though `String` is a type in TypeScript, old JSDoc often uses it to mean `string`. Besides, in TypeScript, the capitalized versions of primitive types are wrapper types — almost always a mistake to use. So the compiler treats these types as synonyms based on usage in old JSDoc:\n\n*   `String -> string`\n*   `Number -> number`\n*   `Boolean -> boolean`\n*   `Void -> void`\n*   `Undefined -> undefined`\n*   `Null -> null`\n*   `function -> Function`\n*   `array -> Array<any>`\n*   `promise -> Promise<any>`\n*   `Object -> any`\n*   `object -> any`\n\nThe last four aliases are turned off when `noImplicitAny: true`:\n\n*   `object` and `Object` are built-in types, although `Object` is rarely used.\n*   `array` and `promise` are not built-in, but might be declared somewhere in your program.",
    "title": "TypeScript: Documentation - JSDoc Reference",
    "description": "What JSDoc does TypeScript-powered JavaScript support?",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html",
    "markdown": "# TypeScript: Documentation - Compiler Options in MSBuild\n\n## [](#overview)Overview\n\nWhen you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways. Either via a `tsconfig.json` or via the project settings.\n\n## [](#using-a-tsconfigjson)Using a `tsconfig.json`\n\nWe recommend using a `tsconfig.json` for your project when possible. To add one to an existing project, add a new item to your project which is called a “TypeScript JSON Configuration File” in modern versions of Visual Studio.\n\nThe new `tsconfig.json` will then be used as the source of truth for TypeScript-specific build information like files and configuration. You can learn [about how TSConfigs works here](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) and there is a [comprehensive reference here](https://www.typescriptlang.org/tsconfig).\n\n## [](#using-project-settings)Using Project Settings\n\nYou can also define the configuration for TypeScript inside you project’s settings. This is done by editing the XML in your `.csproj` to define `PropertyGroups` which describe how the build can work:\n\nxml\n\n`<PropertyGroup>`\n\n  `<TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError>`\n\n  `<TypeScriptNoImplicitReturns>true</TypeScriptNoImplicitReturns>`\n\n`</PropertyGroup>`\n\nThere is a series of mappings for common TypeScript settings, these are settings which map directly to [TypeScript cli options](https://www.typescriptlang.org/docs/handbook/compiler-options.html) and are used to help you write a more understandable project file. You can use the [TSConfig reference](https://www.typescriptlang.org/tsconfig) to get more information on what values and defaults are for each mapping.\n\n### CLI Mappings\n\n| MSBuild Config Name | TSC Flag |\n| --- | --- |\n| `<TypeScriptAllowJS>` | `[--allowJs](https://www.typescriptlang.org/tsconfig/#allowJs)` |\n| Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. |     |     |\n| `<TypeScriptRemoveComments>` | `[--removeComments](https://www.typescriptlang.org/tsconfig/#removeComments)` |\n| Disable emitting comments. |     |     |\n| `<TypeScriptNoImplicitAny>` | `[--noImplicitAny](https://www.typescriptlang.org/tsconfig/#noImplicitAny)` |\n| Enable error reporting for expressions and declarations with an implied `any` type.. |     |     |\n| `<TypeScriptGeneratesDeclarations>` | `[--declaration](https://www.typescriptlang.org/tsconfig/#declaration)` |\n| Generate .d.ts files from TypeScript and JavaScript files in your project. |     |     |\n| `<TypeScriptModuleKind>` | `[--module](https://www.typescriptlang.org/tsconfig/#module)` |\n| Specify what module code is generated. |     |     |\n| `<TypeScriptJSXEmit>` | `[--jsx](https://www.typescriptlang.org/tsconfig/#jsx)` |\n| Specify what JSX code is generated. |     |     |\n| `<TypeScriptOutDir>` | `[--outDir](https://www.typescriptlang.org/tsconfig/#outDir)` |\n| Specify an output folder for all emitted files. |     |     |\n| `<TypeScriptSourceMap>` | `[--sourcemap](https://www.typescriptlang.org/tsconfig/#sourcemap)` |\n| Create source map files for emitted JavaScript files. |     |     |\n| `<TypeScriptTarget>` | `[--target](https://www.typescriptlang.org/tsconfig/#target)` |\n| Set the JavaScript language version for emitted JavaScript and include compatible library declarations. |     |     |\n| `<TypeScriptNoResolve>` | `[--noResolve](https://www.typescriptlang.org/tsconfig/#noResolve)` |\n| Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project. |     |     |\n| `<TypeScriptMapRoot>` | `[--mapRoot](https://www.typescriptlang.org/tsconfig/#mapRoot)` |\n| Specify the location where debugger should locate map files instead of generated locations. |     |     |\n| `<TypeScriptSourceRoot>` | `[--sourceRoot](https://www.typescriptlang.org/tsconfig/#sourceRoot)` |\n| Specify the root path for debuggers to find the reference source code. |     |     |\n| `<TypeScriptCharset>` | `[--charset](https://www.typescriptlang.org/tsconfig/#charset)` |\n| No longer supported. In early versions, manually set the text encoding for reading files. |     |     |\n| `<TypeScriptEmitBOM>` | `[--emitBOM](https://www.typescriptlang.org/tsconfig/#emitBOM)` |\n| Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. |     |     |\n| `<TypeScriptNoLib>` | `[--noLib](https://www.typescriptlang.org/tsconfig/#noLib)` |\n| Disable including any library files, including the default lib.d.ts. |     |     |\n| `<TypeScriptPreserveConstEnums>` | `[--preserveConstEnums](https://www.typescriptlang.org/tsconfig/#preserveConstEnums)` |\n| Disable erasing `const enum` declarations in generated code. |     |     |\n| `<TypeScriptSuppressImplicitAnyIndexErrors>` | `[--suppressImplicitAnyIndexErrors](https://www.typescriptlang.org/tsconfig/#suppressImplicitAnyIndexErrors)` |\n| Suppress `noImplicitAny` errors when indexing objects that lack index signatures. |     |     |\n| `<TypeScriptNoEmitHelpers>` | `[--noEmitHelpers](https://www.typescriptlang.org/tsconfig/#noEmitHelpers)` |\n| Disable generating custom helper functions like `__extends` in compiled output. |     |     |\n| `<TypeScriptInlineSourceMap>` | `[--inlineSourceMap](https://www.typescriptlang.org/tsconfig/#inlineSourceMap)` |\n| Include sourcemap files inside the emitted JavaScript. |     |     |\n| `<TypeScriptInlineSources>` | `[--inlineSources](https://www.typescriptlang.org/tsconfig/#inlineSources)` |\n| Include source code in the sourcemaps inside the emitted JavaScript. |     |     |\n| `<TypeScriptNewLine>` | `[--newLine](https://www.typescriptlang.org/tsconfig/#newLine)` |\n| Set the newline character for emitting files. |     |     |\n| `<TypeScriptIsolatedModules>` | `[--isolatedModules](https://www.typescriptlang.org/tsconfig/#isolatedModules)` |\n| Ensure that each file can be safely transpiled without relying on other imports. |     |     |\n| `<TypeScriptEmitDecoratorMetadata>` | `[--emitDecoratorMetadata](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata)` |\n| Emit design-type metadata for decorated declarations in source files. |     |     |\n| `<TypeScriptRootDir>` | `[--rootDir](https://www.typescriptlang.org/tsconfig/#rootDir)` |\n| Specify the root folder within your source files. |     |     |\n| `<TypeScriptExperimentalDecorators>` | `[--experimentalDecorators](https://www.typescriptlang.org/tsconfig/#experimentalDecorators)` |\n| Enable experimental support for TC39 stage 2 draft decorators. |     |     |\n| `<TypeScriptModuleResolution>` | `[--moduleResolution](https://www.typescriptlang.org/tsconfig/#moduleResolution)` |\n| Specify how TypeScript looks up a file from a given module specifier. |     |     |\n| `<TypeScriptSuppressExcessPropertyErrors>` | `[--suppressExcessPropertyErrors](https://www.typescriptlang.org/tsconfig/#suppressExcessPropertyErrors)` |\n| Disable reporting of excess property errors during the creation of object literals. |     |     |\n| `<TypeScriptReactNamespace>` | `[--reactNamespace](https://www.typescriptlang.org/tsconfig/#reactNamespace)` |\n| Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. |     |     |\n| `<TypeScriptSkipDefaultLibCheck>` | `[--skipDefaultLibCheck](https://www.typescriptlang.org/tsconfig/#skipDefaultLibCheck)` |\n| Skip type checking .d.ts files that are included with TypeScript. |     |     |\n| `<TypeScriptAllowUnusedLabels>` | `[--allowUnusedLabels](https://www.typescriptlang.org/tsconfig/#allowUnusedLabels)` |\n| Disable error reporting for unused labels. |     |     |\n| `<TypeScriptNoImplicitReturns>` | `[--noImplicitReturns](https://www.typescriptlang.org/tsconfig/#noImplicitReturns)` |\n| Enable error reporting for codepaths that do not explicitly return in a function. |     |     |\n| `<TypeScriptNoFallthroughCasesInSwitch>` | `[--noFallthroughCasesInSwitch](https://www.typescriptlang.org/tsconfig/#noFallthroughCasesInSwitch)` |\n| Enable error reporting for fallthrough cases in switch statements. |     |     |\n| `<TypeScriptAllowUnreachableCode>` | `[--allowUnreachableCode](https://www.typescriptlang.org/tsconfig/#allowUnreachableCode)` |\n| Disable error reporting for unreachable code. |     |     |\n| `<TypeScriptForceConsistentCasingInFileNames>` | `[--forceConsistentCasingInFileNames](https://www.typescriptlang.org/tsconfig/#forceConsistentCasingInFileNames)` |\n| Ensure that casing is correct in imports. |     |     |\n| `<TypeScriptAllowSyntheticDefaultImports>` | `[--allowSyntheticDefaultImports](https://www.typescriptlang.org/tsconfig/#allowSyntheticDefaultImports)` |\n| Allow 'import x from y' when a module doesn't have a default export. |     |     |\n| `<TypeScriptNoImplicitUseStrict>` | `[--noImplicitUseStrict](https://www.typescriptlang.org/tsconfig/#noImplicitUseStrict)` |\n| Disable adding 'use strict' directives in emitted JavaScript files. |     |     |\n| `<TypeScriptLib>` | `[--lib](https://www.typescriptlang.org/tsconfig/#lib)` |\n| Specify a set of bundled library declaration files that describe the target runtime environment. |     |     |\n| `<TypeScriptBaseUrl>` | `[--baseUrl](https://www.typescriptlang.org/tsconfig/#baseUrl)` |\n| Specify the base directory to resolve bare specifier module names. |     |     |\n| `<TypeScriptDeclarationDir>` | `[--declarationDir](https://www.typescriptlang.org/tsconfig/#declarationDir)` |\n| Specify the output directory for generated declaration files. |     |     |\n| `<TypeScriptNoImplicitThis>` | `[--noImplicitThis](https://www.typescriptlang.org/tsconfig/#noImplicitThis)` |\n| Enable error reporting when `this` is given the type `any`. |     |     |\n| `<TypeScriptSkipLibCheck>` | `[--skipLibCheck](https://www.typescriptlang.org/tsconfig/#skipLibCheck)` |\n| Skip type checking all .d.ts files. |     |     |\n| `<TypeScriptStrictNullChecks>` | `[--strictNullChecks](https://www.typescriptlang.org/tsconfig/#strictNullChecks)` |\n| When type checking, take into account `null` and `undefined`. |     |     |\n| `<TypeScriptNoUnusedLocals>` | `[--noUnusedLocals](https://www.typescriptlang.org/tsconfig/#noUnusedLocals)` |\n| Enable error reporting when a local variables aren't read. |     |     |\n| `<TypeScriptNoUnusedParameters>` | `[--noUnusedParameters](https://www.typescriptlang.org/tsconfig/#noUnusedParameters)` |\n| Raise an error when a function parameter isn't read |     |     |\n| `<TypeScriptAlwaysStrict>` | `[--alwaysStrict](https://www.typescriptlang.org/tsconfig/#alwaysStrict)` |\n| Ensure 'use strict' is always emitted. |     |     |\n| `<TypeScriptImportHelpers>` | `[--importHelpers](https://www.typescriptlang.org/tsconfig/#importHelpers)` |\n| Allow importing helper functions from tslib once per project, instead of including them per-file. |     |     |\n| `<TypeScriptJSXFactory>` | `[--jsxFactory](https://www.typescriptlang.org/tsconfig/#jsxFactory)` |\n| Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h' |     |     |\n| `<TypeScriptStripInternal>` | `[--stripInternal](https://www.typescriptlang.org/tsconfig/#stripInternal)` |\n| Disable emitting declarations that have `@internal` in their JSDoc comments. |     |     |\n| `<TypeScriptCheckJs>` | `[--checkJs](https://www.typescriptlang.org/tsconfig/#checkJs)` |\n| Enable error reporting in type-checked JavaScript files. |     |     |\n| `<TypeScriptDownlevelIteration>` | `[--downlevelIteration](https://www.typescriptlang.org/tsconfig/#downlevelIteration)` |\n| Emit more compliant, but verbose and less performant JavaScript for iteration. |     |     |\n| `<TypeScriptStrict>` | `[--strict](https://www.typescriptlang.org/tsconfig/#strict)` |\n| Enable all strict type checking options. |     |     |\n| `<TypeScriptNoStrictGenericChecks>` | `[--noStrictGenericChecks](https://www.typescriptlang.org/tsconfig/#noStrictGenericChecks)` |\n| Disable strict checking of generic signatures in function types. |     |     |\n| `<TypeScriptPreserveSymlinks>` | `[--preserveSymlinks](https://www.typescriptlang.org/tsconfig/#preserveSymlinks)` |\n| Disable resolving symlinks to their realpath. This correlates to the same flag in node. |     |     |\n| `<TypeScriptStrictFunctionTypes>` | `[--strictFunctionTypes](https://www.typescriptlang.org/tsconfig/#strictFunctionTypes)` |\n| When assigning functions, check to ensure parameters and the return values are subtype-compatible. |     |     |\n| `<TypeScriptStrictPropertyInitialization>` | `[--strictPropertyInitialization](https://www.typescriptlang.org/tsconfig/#strictPropertyInitialization)` |\n| Check for class properties that are declared but not set in the constructor. |     |     |\n| `<TypeScriptESModuleInterop>` | `[--esModuleInterop](https://www.typescriptlang.org/tsconfig/#esModuleInterop)` |\n| Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. |     |     |\n| `<TypeScriptEmitDeclarationOnly>` | `[--emitDeclarationOnly](https://www.typescriptlang.org/tsconfig/#emitDeclarationOnly)` |\n| Only output d.ts files and not JavaScript files. |     |     |\n| `<TypeScriptKeyofStringsOnly>` | `[--keyofStringsOnly](https://www.typescriptlang.org/tsconfig/#keyofStringsOnly)` |\n| Make keyof only return strings instead of string, numbers or symbols. Legacy option. |     |     |\n| `<TypeScriptUseDefineForClassFields>` | `[--useDefineForClassFields](https://www.typescriptlang.org/tsconfig/#useDefineForClassFields)` |\n| Emit ECMAScript-standard-compliant class fields. |     |     |\n| `<TypeScriptDeclarationMap>` | `[--declarationMap](https://www.typescriptlang.org/tsconfig/#declarationMap)` |\n| Create sourcemaps for d.ts files. |     |     |\n| `<TypeScriptResolveJsonModule>` | `[--resolveJsonModule](https://www.typescriptlang.org/tsconfig/#resolveJsonModule)` |\n| Enable importing .json files |     |     |\n| `<TypeScriptStrictBindCallApply>` | `[--strictBindCallApply](https://www.typescriptlang.org/tsconfig/#strictBindCallApply)` |\n| Check that the arguments for `bind`, `call`, and `apply` methods match the original function. |     |     |\n| `<TypeScriptNoEmitOnError>` | `[--noEmitOnError](https://www.typescriptlang.org/tsconfig/#noEmitOnError)` |\n| Disable emitting files if any type checking errors are reported. |     |     |\n\n### [](#additional-flags)Additional Flags\n\nBecause the MSBuild system passes arguments directly to the TypeScript CLI, you can use the option `TypeScriptAdditionalFlags` to provide specific flags which don’t have a mapping above.\n\nFor example, this would turn on [`noPropertyAccessFromIndexSignature`](https://www.typescriptlang.org/tsconfig#noPropertyAccessFromIndexSignature):\n\nxml\n\n`<TypeScriptAdditionalFlags> $(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature</TypeScriptAdditionalFlags>`\n\n### [](#debug-and-release-builds)Debug and Release Builds\n\nYou can use PropertyGroup conditions to define different sets of configurations. For example, a common task is stripping comments and sourcemaps in production. In this example, we define a debug and release property group which have different TypeScript configurations:\n\nxml\n\n`<PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">`\n\n  `<TypeScriptRemoveComments>false</TypeScriptRemoveComments>`\n\n  `<TypeScriptSourceMap>true</TypeScriptSourceMap>`\n\n`</PropertyGroup>`\n\n`<PropertyGroup Condition=\"'$(Configuration)' == 'Release'\">`\n\n  `<TypeScriptRemoveComments>true</TypeScriptRemoveComments>`\n\n  `<TypeScriptSourceMap>false</TypeScriptSourceMap>`\n\n`</PropertyGroup>`\n\n`<Import`\n\n    `Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"`\n\n    `Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />`\n\n### [](#toolsversion)ToolsVersion\n\nThe value of `<TypeScriptToolsVersion>1.7</TypeScriptToolsVersion>` property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.\n\nIf `TypeScriptToolsVersion` is not specified, the latest compiler version installed on the machine will be used to build.\n\nUsers using newer versions of TS, will see a prompt to upgrade their project on first load.\n\n### [](#typescriptcompileblocked)TypeScriptCompileBlocked\n\nIf you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set `<TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>` in your project. This should give you all the editing support, but not the build when you hit F5.\n\n### [](#typescriptenableincrementalmsbuild-typescript-42-beta-and-later)TypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)\n\nBy default, MSBuild will attempt to only run the TypeScript compiler when the project’s source files have been updated since the last compilation. However, if this behavior is causing issues, such as when TypeScript’s [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) option is enabled, set `<TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild>` to ensure the TypeScript compiler is invoked with every run of MSBuild.",
    "title": "TypeScript: Documentation - Compiler Options in MSBuild",
    "description": "Which compiler options are available in MSBuild projects.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/compiler-options.html",
    "markdown": "# TypeScript: Documentation - tsc CLI Options\n\n## [](#using-the-cli)Using the CLI\n\nRunning `tsc` locally will compile the closest project defined by a `tsconfig.json`, or you can compile a set of TypeScript files by passing in a glob of files you want. When input files are specified on the command line, `tsconfig.json` files are ignored.\n\nsh\n\n`# Run a compile based on a backwards look through the fs for a tsconfig.json`\n\n`tsc`\n\n`# Emit JS for just the index.ts with the compiler defaults`\n\n`tsc index.ts`\n\n`# Emit JS for any .ts files in the folder src, with the default settings`\n\n`tsc src/*.ts`\n\n`# Emit files referenced in with the compiler settings from tsconfig.production.json`\n\n`tsc --project tsconfig.production.json`\n\n`# Emit d.ts files for a js file with showing compiler options which are booleans`\n\n`tsc index.js --declaration --emitDeclarationOnly`\n\n`# Emit a single .js file from two files via compiler options which take string arguments`\n\n`tsc app.ts util.ts --target esnext --outfile index.js`\n\n## [](#compiler-options)Compiler Options\n\n**If you’re looking for more information about the compiler options in a tsconfig, check out the [TSConfig Reference](https://www.typescriptlang.org/tsconfig)**\n\n### CLI Commands\n\n| Flag | Type |\n| --- | --- |\n| `--all` | `boolean` |\n| Show all compiler options. |     |     |\n| `--generateTrace` | `string` |\n| Generates an event trace and a list of types. |     |     |\n| `--help` | `boolean` |\n| Gives local information for help on the CLI. |     |     |\n| `--init` | `boolean` |\n| Initializes a TypeScript project and creates a tsconfig.json file. |     |     |\n| `--listFilesOnly` | `boolean` |\n| Print names of files that are part of the compilation and then stop processing. |     |     |\n| `--locale` | `string` |\n| Set the language of the messaging from TypeScript. This does not affect emit. |     |     |\n| `--project` | `string` |\n| Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'. |     |     |\n| `--showConfig` | `boolean` |\n| Print the final configuration instead of building. |     |     |\n| `--version` | `boolean` |\n| Print the compiler's version. |     |     |\n\n### Build Options\n\n| Flag | Type |\n| --- | --- |\n| `--build` | `boolean` |\n| Build one or more projects and their dependencies, if out of date |     |     |\n| `--clean` | `boolean` |\n| Delete the outputs of all projects. |     |     |\n| `--dry` | `boolean` |\n| Show what would be built (or deleted, if specified with '--clean') |     |     |\n| `[--force](https://www.typescriptlang.org/tsconfig/#force)` | `boolean` |\n| Build all projects, including those that appear to be up to date. |     |     |\n| `[--verbose](https://www.typescriptlang.org/tsconfig/#verbose)` | `boolean` |\n| Enable verbose logging. |     |     |\n\n### Watch Options\n\n| Flag | Type |\n| --- | --- |\n| `[--excludeDirectories](https://www.typescriptlang.org/tsconfig/#excludeDirectories)` | `list` |\n| Remove a list of directories from the watch process. |     |     |\n| `[--excludeFiles](https://www.typescriptlang.org/tsconfig/#excludeFiles)` | `list` |\n| Remove a list of files from the watch mode's processing. |     |     |\n| `[--fallbackPolling](https://www.typescriptlang.org/tsconfig/#fallbackPolling)` | `fixedinterval`, `priorityinterval`, `dynamicpriority`, or `fixedchunksize` |\n| Specify what approach the watcher should use if the system runs out of native file watchers. |     |     |\n| `[--synchronousWatchDirectory](https://www.typescriptlang.org/tsconfig/#synchronousWatchDirectory)` | `boolean` |\n| Synchronously call callbacks and update the state of directory watchers on platforms that don\\`t support recursive watching natively. |     |     |\n| `--watch` | `boolean` |\n| Watch input files. |     |     |\n| `[--watchDirectory](https://www.typescriptlang.org/tsconfig/#watchDirectory)` | `usefsevents`, `fixedpollinginterval`, `dynamicprioritypolling`, or `fixedchunksizepolling` |\n| Specify how directories are watched on systems that lack recursive file-watching functionality. |     |     |\n| `[--watchFile](https://www.typescriptlang.org/tsconfig/#watchFile)` | `fixedpollinginterval`, `prioritypollinginterval`, `dynamicprioritypolling`, `fixedchunksizepolling`, `usefsevents`, or `usefseventsonparentdirectory` |\n| Specify how the TypeScript watch mode works. |     |     |\n\n### Compiler Flags\n\n| Flag | Type | Default |\n| --- | --- | --- |\n| `[--allowArbitraryExtensions](https://www.typescriptlang.org/tsconfig/#allowArbitraryExtensions)` | `boolean` | `false` |\n| Enable importing files with any extension, provided a declaration file is present. |     |     |\n| `[--allowImportingTsExtensions](https://www.typescriptlang.org/tsconfig/#allowImportingTsExtensions)` | `boolean` | `false` |\n| Allow imports to include TypeScript file extensions. |     |     |\n| `[--allowJs](https://www.typescriptlang.org/tsconfig/#allowJs)` | `boolean` | `false` |\n| Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. |     |     |\n| `[--allowSyntheticDefaultImports](https://www.typescriptlang.org/tsconfig/#allowSyntheticDefaultImports)` | `boolean` | `true` if [`esModuleInterop`](#esModuleInterop) is enabled, [`module`](#module) is `system`, or [`moduleResolution`](#module-resolution) is `bundler`; `false` otherwise. |\n| Allow 'import x from y' when a module doesn't have a default export. |     |     |\n| `[--allowUmdGlobalAccess](https://www.typescriptlang.org/tsconfig/#allowUmdGlobalAccess)` | `boolean` | `false` |\n| Allow accessing UMD globals from modules. |     |     |\n| `[--allowUnreachableCode](https://www.typescriptlang.org/tsconfig/#allowUnreachableCode)` | `boolean` |     |\n| Disable error reporting for unreachable code. |     |     |\n| `[--allowUnusedLabels](https://www.typescriptlang.org/tsconfig/#allowUnusedLabels)` | `boolean` |     |\n| Disable error reporting for unused labels. |     |     |\n| `[--alwaysStrict](https://www.typescriptlang.org/tsconfig/#alwaysStrict)` | `boolean` | `true` if [`strict`](#strict); `false` otherwise. |\n| Ensure 'use strict' is always emitted. |     |     |\n| `[--assumeChangesOnlyAffectDirectDependencies](https://www.typescriptlang.org/tsconfig/#assumeChangesOnlyAffectDirectDependencies)` | `boolean` | `false` |\n| Have recompiles in projects that use [`incremental`](#incremental) and `watch` mode assume that changes within a file will only affect files directly depending on it. |     |     |\n| `[--baseUrl](https://www.typescriptlang.org/tsconfig/#baseUrl)` | `string` |     |\n| Specify the base directory to resolve bare specifier module names. |     |     |\n| `[--charset](https://www.typescriptlang.org/tsconfig/#charset)` | `string` | `utf8` |\n| No longer supported. In early versions, manually set the text encoding for reading files. |     |     |\n| `[--checkJs](https://www.typescriptlang.org/tsconfig/#checkJs)` | `boolean` | `false` |\n| Enable error reporting in type-checked JavaScript files. |     |     |\n| `[--composite](https://www.typescriptlang.org/tsconfig/#composite)` | `boolean` | `false` |\n| Enable constraints that allow a TypeScript project to be used with project references. |     |     |\n| `[--customConditions](https://www.typescriptlang.org/tsconfig/#customConditions)` | `list` |     |\n| Conditions to set in addition to the resolver-specific defaults when resolving imports. |     |     |\n| `[--declaration](https://www.typescriptlang.org/tsconfig/#declaration)` | `boolean` | `true` if [`composite`](#composite); `false` otherwise. |\n| Generate .d.ts files from TypeScript and JavaScript files in your project. |     |     |\n| `[--declarationDir](https://www.typescriptlang.org/tsconfig/#declarationDir)` | `string` |     |\n| Specify the output directory for generated declaration files. |     |     |\n| `[--declarationMap](https://www.typescriptlang.org/tsconfig/#declarationMap)` | `boolean` | `false` |\n| Create sourcemaps for d.ts files. |     |     |\n| `[--diagnostics](https://www.typescriptlang.org/tsconfig/#diagnostics)` | `boolean` | `false` |\n| Output compiler performance information after building. |     |     |\n| `[--disableReferencedProjectLoad](https://www.typescriptlang.org/tsconfig/#disableReferencedProjectLoad)` | `boolean` | `false` |\n| Reduce the number of projects loaded automatically by TypeScript. |     |     |\n| `[--disableSizeLimit](https://www.typescriptlang.org/tsconfig/#disableSizeLimit)` | `boolean` | `false` |\n| Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server. |     |     |\n| `[--disableSolutionSearching](https://www.typescriptlang.org/tsconfig/#disableSolutionSearching)` | `boolean` | `false` |\n| Opt a project out of multi-project reference checking when editing. |     |     |\n| `[--disableSourceOfProjectReferenceRedirect](https://www.typescriptlang.org/tsconfig/#disableSourceOfProjectReferenceRedirect)` | `boolean` | `false` |\n| Disable preferring source files instead of declaration files when referencing composite projects. |     |     |\n| `[--downlevelIteration](https://www.typescriptlang.org/tsconfig/#downlevelIteration)` | `boolean` | `false` |\n| Emit more compliant, but verbose and less performant JavaScript for iteration. |     |     |\n| `[--emitBOM](https://www.typescriptlang.org/tsconfig/#emitBOM)` | `boolean` | `false` |\n| Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. |     |     |\n| `[--emitDeclarationOnly](https://www.typescriptlang.org/tsconfig/#emitDeclarationOnly)` | `boolean` | `false` |\n| Only output d.ts files and not JavaScript files. |     |     |\n| `[--emitDecoratorMetadata](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata)` | `boolean` | `false` |\n| Emit design-type metadata for decorated declarations in source files. |     |     |\n| `[--esModuleInterop](https://www.typescriptlang.org/tsconfig/#esModuleInterop)` | `boolean` | `true` if [`module`](#module) is `node16` or `nodenext`; `false` otherwise. |\n| Emit additional JavaScript to ease support for importing CommonJS modules. This enables [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports) for type compatibility. |     |     |\n| `[--exactOptionalPropertyTypes](https://www.typescriptlang.org/tsconfig/#exactOptionalPropertyTypes)` | `boolean` | `false` |\n| Interpret optional property types as written, rather than adding `undefined`. |     |     |\n| `[--experimentalDecorators](https://www.typescriptlang.org/tsconfig/#experimentalDecorators)` | `boolean` | `false` |\n| Enable experimental support for TC39 stage 2 draft decorators. |     |     |\n| `[--explainFiles](https://www.typescriptlang.org/tsconfig/#explainFiles)` | `boolean` | `false` |\n| Print files read during the compilation including why it was included. |     |     |\n| `[--extendedDiagnostics](https://www.typescriptlang.org/tsconfig/#extendedDiagnostics)` | `boolean` | `false` |\n| Output more detailed compiler performance information after building. |     |     |\n| `[--forceConsistentCasingInFileNames](https://www.typescriptlang.org/tsconfig/#forceConsistentCasingInFileNames)` | `boolean` | `true` |\n| Ensure that casing is correct in imports. |     |     |\n| `[--generateCpuProfile](https://www.typescriptlang.org/tsconfig/#generateCpuProfile)` | `string` | `profile.cpuprofile` |\n| Emit a v8 CPU profile of the compiler run for debugging. |     |     |\n| `[--importHelpers](https://www.typescriptlang.org/tsconfig/#importHelpers)` | `boolean` | `false` |\n| Allow importing helper functions from tslib once per project, instead of including them per-file. |     |     |\n| `[--importsNotUsedAsValues](https://www.typescriptlang.org/tsconfig/#importsNotUsedAsValues)` | `remove`, `preserve`, or `error` | `remove` |\n| Specify emit/checking behavior for imports that are only used for types. |     |     |\n| `[--incremental](https://www.typescriptlang.org/tsconfig/#incremental)` | `boolean` | `true` if [`composite`](#composite); `false` otherwise. |\n| Save .tsbuildinfo files to allow for incremental compilation of projects. |     |     |\n| `[--inlineSourceMap](https://www.typescriptlang.org/tsconfig/#inlineSourceMap)` | `boolean` | `false` |\n| Include sourcemap files inside the emitted JavaScript. |     |     |\n| `[--inlineSources](https://www.typescriptlang.org/tsconfig/#inlineSources)` | `boolean` | `false` |\n| Include source code in the sourcemaps inside the emitted JavaScript. |     |     |\n| `[--isolatedDeclarations](https://www.typescriptlang.org/tsconfig/#isolatedDeclarations)` | `boolean` | `false` |\n| Require sufficient annotation on exports so other tools can trivially generate declaration files. |     |     |\n| `[--isolatedModules](https://www.typescriptlang.org/tsconfig/#isolatedModules)` | `boolean` | `true` if [`verbatimModuleSyntax`](#verbatimModuleSyntax); `false` otherwise. |\n| Ensure that each file can be safely transpiled without relying on other imports. |     |     |\n| `[--jsx](https://www.typescriptlang.org/tsconfig/#jsx)` | `preserve`, `react`, `react-native`, `react-jsx`, or `react-jsxdev` |     |\n| Specify what JSX code is generated. |     |     |\n| `[--jsxFactory](https://www.typescriptlang.org/tsconfig/#jsxFactory)` | `string` | `React.createElement` |\n| Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. |     |     |\n| `[--jsxFragmentFactory](https://www.typescriptlang.org/tsconfig/#jsxFragmentFactory)` | `string` | `React.Fragment` |\n| Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. |     |     |\n| `[--jsxImportSource](https://www.typescriptlang.org/tsconfig/#jsxImportSource)` | `string` | `react` |\n| Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`. |     |     |\n| `[--keyofStringsOnly](https://www.typescriptlang.org/tsconfig/#keyofStringsOnly)` | `boolean` | `false` |\n| Make keyof only return strings instead of string, numbers or symbols. Legacy option. |     |     |\n| `[--lib](https://www.typescriptlang.org/tsconfig/#lib)` | `list` |     |\n| Specify a set of bundled library declaration files that describe the target runtime environment. |     |     |\n| `[--listEmittedFiles](https://www.typescriptlang.org/tsconfig/#listEmittedFiles)` | `boolean` | `false` |\n| Print the names of emitted files after a compilation. |     |     |\n| `[--listFiles](https://www.typescriptlang.org/tsconfig/#listFiles)` | `boolean` | `false` |\n| Print all of the files read during the compilation. |     |     |\n| `[--mapRoot](https://www.typescriptlang.org/tsconfig/#mapRoot)` | `string` |     |\n| Specify the location where debugger should locate map files instead of generated locations. |     |     |\n| `[--maxNodeModuleJsDepth](https://www.typescriptlang.org/tsconfig/#maxNodeModuleJsDepth)` | `number` | `0` |\n| Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with [`allowJs`](#allowJs). |     |     |\n| `[--module](https://www.typescriptlang.org/tsconfig/#module)` | `none`, `commonjs`, `amd`, `umd`, `system`, `es6`/`es2015`, `es2020`, `es2022`, `esnext`, `node16`, `nodenext`, or `preserve` | `CommonJS` if [`target`](#target) is `ES3` or `ES5`; `ES6`/`ES2015` otherwise. |\n| Specify what module code is generated. |     |     |\n| `[--moduleDetection](https://www.typescriptlang.org/tsconfig/#moduleDetection)` | `legacy`, `auto`, or `force` | \"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules. |\n| Specify what method is used to detect whether a file is a script or a module. |     |     |\n| `[--moduleResolution](https://www.typescriptlang.org/tsconfig/#moduleResolution)` | `classic`, `node10`/`node`, `node16`, `nodenext`, or `bundler` | `Classic` if [`module`](#module) is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if [`module`](#module) is `node16` or `nodenext`; `Node` otherwise. |\n| Specify how TypeScript looks up a file from a given module specifier. |     |     |\n| `[--moduleSuffixes](https://www.typescriptlang.org/tsconfig/#moduleSuffixes)` | `list` |     |\n| List of file name suffixes to search when resolving a module. |     |     |\n| `[--newLine](https://www.typescriptlang.org/tsconfig/#newLine)` | `crlf` or `lf` | `lf` |\n| Set the newline character for emitting files. |     |     |\n| `[--noCheck](https://www.typescriptlang.org/tsconfig/#noCheck)` | `boolean` | `false` |\n| Disable full type checking (only critical parse and emit errors will be reported). |     |     |\n| `[--noEmit](https://www.typescriptlang.org/tsconfig/#noEmit)` | `boolean` | `false` |\n| Disable emitting files from a compilation. |     |     |\n| `[--noEmitHelpers](https://www.typescriptlang.org/tsconfig/#noEmitHelpers)` | `boolean` | `false` |\n| Disable generating custom helper functions like `__extends` in compiled output. |     |     |\n| `[--noEmitOnError](https://www.typescriptlang.org/tsconfig/#noEmitOnError)` | `boolean` | `false` |\n| Disable emitting files if any type checking errors are reported. |     |     |\n| `[--noErrorTruncation](https://www.typescriptlang.org/tsconfig/#noErrorTruncation)` | `boolean` | `false` |\n| Disable truncating types in error messages. |     |     |\n| `[--noFallthroughCasesInSwitch](https://www.typescriptlang.org/tsconfig/#noFallthroughCasesInSwitch)` | `boolean` | `false` |\n| Enable error reporting for fallthrough cases in switch statements. |     |     |\n| `[--noImplicitAny](https://www.typescriptlang.org/tsconfig/#noImplicitAny)` | `boolean` | `true` if [`strict`](#strict); `false` otherwise. |\n| Enable error reporting for expressions and declarations with an implied `any` type. |     |     |\n| `[--noImplicitOverride](https://www.typescriptlang.org/tsconfig/#noImplicitOverride)` | `boolean` | `false` |\n| Ensure overriding members in derived classes are marked with an override modifier. |     |     |\n| `[--noImplicitReturns](https://www.typescriptlang.org/tsconfig/#noImplicitReturns)` | `boolean` | `false` |\n| Enable error reporting for codepaths that do not explicitly return in a function. |     |     |\n| `[--noImplicitThis](https://www.typescriptlang.org/tsconfig/#noImplicitThis)` | `boolean` | `true` if [`strict`](#strict); `false` otherwise. |\n| Enable error reporting when `this` is given the type `any`. |     |     |\n| `[--noImplicitUseStrict](https://www.typescriptlang.org/tsconfig/#noImplicitUseStrict)` | `boolean` | `false` |\n| Disable adding 'use strict' directives in emitted JavaScript files. |     |     |\n| `[--noLib](https://www.typescriptlang.org/tsconfig/#noLib)` | `boolean` | `false` |\n| Disable including any library files, including the default lib.d.ts. |     |     |\n| `[--noPropertyAccessFromIndexSignature](https://www.typescriptlang.org/tsconfig/#noPropertyAccessFromIndexSignature)` | `boolean` | `false` |\n| Enforces using indexed accessors for keys declared using an indexed type. |     |     |\n| `[--noResolve](https://www.typescriptlang.org/tsconfig/#noResolve)` | `boolean` | `false` |\n| Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project. |     |     |\n| `[--noStrictGenericChecks](https://www.typescriptlang.org/tsconfig/#noStrictGenericChecks)` | `boolean` | `false` |\n| Disable strict checking of generic signatures in function types. |     |     |\n| `[--noUncheckedIndexedAccess](https://www.typescriptlang.org/tsconfig/#noUncheckedIndexedAccess)` | `boolean` | `false` |\n| Add `undefined` to a type when accessed using an index. |     |     |\n| `[--noUnusedLocals](https://www.typescriptlang.org/tsconfig/#noUnusedLocals)` | `boolean` | `false` |\n| Enable error reporting when local variables aren't read. |     |     |\n| `[--noUnusedParameters](https://www.typescriptlang.org/tsconfig/#noUnusedParameters)` | `boolean` | `false` |\n| Raise an error when a function parameter isn't read. |     |     |\n| `[--out](https://www.typescriptlang.org/tsconfig/#out)` | `string` |     |\n| Deprecated setting. Use [`outFile`](#outFile) instead. |     |     |\n| `[--outDir](https://www.typescriptlang.org/tsconfig/#outDir)` | `string` |     |\n| Specify an output folder for all emitted files. |     |     |\n| `[--outFile](https://www.typescriptlang.org/tsconfig/#outFile)` | `string` |     |\n| Specify a file that bundles all outputs into one JavaScript file. If [`declaration`](#declaration) is true, also designates a file that bundles all .d.ts output. |     |     |\n| `[--paths](https://www.typescriptlang.org/tsconfig/#paths)` | `object` |     |\n| Specify a set of entries that re-map imports to additional lookup locations. |     |     |\n| `[--plugins](https://www.typescriptlang.org/tsconfig/#plugins)` | `list` |     |\n| Specify a list of language service plugins to include. |     |     |\n| `[--preserveConstEnums](https://www.typescriptlang.org/tsconfig/#preserveConstEnums)` | `boolean` | `true` if [`isolatedModules`](#isolatedModules); `false` otherwise. |\n| Disable erasing `const enum` declarations in generated code. |     |     |\n| `[--preserveSymlinks](https://www.typescriptlang.org/tsconfig/#preserveSymlinks)` | `boolean` | `false` |\n| Disable resolving symlinks to their realpath. This correlates to the same flag in node. |     |     |\n| `[--preserveValueImports](https://www.typescriptlang.org/tsconfig/#preserveValueImports)` | `boolean` | `false` |\n| Preserve unused imported values in the JavaScript output that would otherwise be removed. |     |     |\n| `[--preserveWatchOutput](https://www.typescriptlang.org/tsconfig/#preserveWatchOutput)` | `boolean` | `false` |\n| Disable wiping the console in watch mode. |     |     |\n| `[--pretty](https://www.typescriptlang.org/tsconfig/#pretty)` | `boolean` | `true` |\n| Enable color and formatting in TypeScript's output to make compiler errors easier to read. |     |     |\n| `[--reactNamespace](https://www.typescriptlang.org/tsconfig/#reactNamespace)` | `string` | `React` |\n| Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. |     |     |\n| `[--removeComments](https://www.typescriptlang.org/tsconfig/#removeComments)` | `boolean` | `false` |\n| Disable emitting comments. |     |     |\n| `[--resolveJsonModule](https://www.typescriptlang.org/tsconfig/#resolveJsonModule)` | `boolean` | `false` |\n| Enable importing .json files. |     |     |\n| `[--resolvePackageJsonExports](https://www.typescriptlang.org/tsconfig/#resolvePackageJsonExports)` | `boolean` | `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false` |\n| Use the package.json 'exports' field when resolving package imports. |     |     |\n| `[--resolvePackageJsonImports](https://www.typescriptlang.org/tsconfig/#resolvePackageJsonImports)` | `boolean` | `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false` |\n| Use the package.json 'imports' field when resolving imports. |     |     |\n| `[--rootDir](https://www.typescriptlang.org/tsconfig/#rootDir)` | `string` | Computed from the list of input files. |\n| Specify the root folder within your source files. |     |     |\n| `[--rootDirs](https://www.typescriptlang.org/tsconfig/#rootDirs)` | `list` | Computed from the list of input files. |\n| Allow multiple folders to be treated as one when resolving modules. |     |     |\n| `[--skipDefaultLibCheck](https://www.typescriptlang.org/tsconfig/#skipDefaultLibCheck)` | `boolean` | `false` |\n| Skip type checking .d.ts files that are included with TypeScript. |     |     |\n| `[--skipLibCheck](https://www.typescriptlang.org/tsconfig/#skipLibCheck)` | `boolean` | `false` |\n| Skip type checking all .d.ts files. |     |     |\n| `[--sourceMap](https://www.typescriptlang.org/tsconfig/#sourceMap)` | `boolean` | `false` |\n| Create source map files for emitted JavaScript files. |     |     |\n| `[--sourceRoot](https://www.typescriptlang.org/tsconfig/#sourceRoot)` | `string` |     |\n| Specify the root path for debuggers to find the reference source code. |     |     |\n| `[--strict](https://www.typescriptlang.org/tsconfig/#strict)` | `boolean` | `false` |\n| Enable all strict type-checking options. |     |     |\n| `[--strictBindCallApply](https://www.typescriptlang.org/tsconfig/#strictBindCallApply)` | `boolean` | `true` if [`strict`](#strict); `false` otherwise. |\n| Check that the arguments for `bind`, `call`, and `apply` methods match the original function. |     |     |\n| `[--strictFunctionTypes](https://www.typescriptlang.org/tsconfig/#strictFunctionTypes)` | `boolean` | `true` if [`strict`](#strict); `false` otherwise. |\n| When assigning functions, check to ensure parameters and the return values are subtype-compatible. |     |     |\n| `[--strictNullChecks](https://www.typescriptlang.org/tsconfig/#strictNullChecks)` | `boolean` | `true` if [`strict`](#strict); `false` otherwise. |\n| When type checking, take into account `null` and `undefined`. |     |     |\n| `[--strictPropertyInitialization](https://www.typescriptlang.org/tsconfig/#strictPropertyInitialization)` | `boolean` | `true` if [`strict`](#strict); `false` otherwise. |\n| Check for class properties that are declared but not set in the constructor. |     |     |\n| `[--stripInternal](https://www.typescriptlang.org/tsconfig/#stripInternal)` | `boolean` | `false` |\n| Disable emitting declarations that have `@internal` in their JSDoc comments. |     |     |\n| `[--suppressExcessPropertyErrors](https://www.typescriptlang.org/tsconfig/#suppressExcessPropertyErrors)` | `boolean` | `false` |\n| Disable reporting of excess property errors during the creation of object literals. |     |     |\n| `[--suppressImplicitAnyIndexErrors](https://www.typescriptlang.org/tsconfig/#suppressImplicitAnyIndexErrors)` | `boolean` | `false` |\n| Suppress [`noImplicitAny`](#noImplicitAny) errors when indexing objects that lack index signatures. |     |     |\n| `[--target](https://www.typescriptlang.org/tsconfig/#target)` | `es3`, `es5`, `es6`/`es2015`, `es2016`, `es2017`, `es2018`, `es2019`, `es2020`, `es2021`, `es2022`, `es2023`, or `esnext` | `ES3` |\n| Set the JavaScript language version for emitted JavaScript and include compatible library declarations. |     |     |\n| `[--traceResolution](https://www.typescriptlang.org/tsconfig/#traceResolution)` | `boolean` | `false` |\n| Log paths used during the [`moduleResolution`](#moduleResolution) process. |     |     |\n| `[--tsBuildInfoFile](https://www.typescriptlang.org/tsconfig/#tsBuildInfoFile)` | `string` | `.tsbuildinfo` |\n| The file to store `.tsbuildinfo` incremental build information in. |     |     |\n| `[--typeRoots](https://www.typescriptlang.org/tsconfig/#typeRoots)` | `list` |     |\n| Specify multiple folders that act like `./node_modules/@types`. |     |     |\n| `[--types](https://www.typescriptlang.org/tsconfig/#types)` | `list` |     |\n| Specify type package names to be included without being referenced in a source file. |     |     |\n| `[--useDefineForClassFields](https://www.typescriptlang.org/tsconfig/#useDefineForClassFields)` | `boolean` | `true` if [`target`](#target) is `ES2022` or higher, including `ESNext`; `false` otherwise. |\n| Emit ECMAScript-standard-compliant class fields. |     |     |\n| `[--useUnknownInCatchVariables](https://www.typescriptlang.org/tsconfig/#useUnknownInCatchVariables)` | `boolean` | `true` if [`strict`](#strict); `false` otherwise. |\n| Default catch clause variables as `unknown` instead of `any`. |     |     |\n| `[--verbatimModuleSyntax](https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax)` | `boolean` | `false` |\n| Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. |     |     |\n\n*   Every option is fully explained in the [TSConfig Reference](https://www.typescriptlang.org/tsconfig).\n*   Learn how to use a [`tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) file.\n*   Learn how to work in an [MSBuild project](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html).",
    "title": "TypeScript: Documentation - tsc CLI Options",
    "description": "A very high-level overview of the CLI compiler options for tsc",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html",
    "markdown": "# TypeScript: Documentation - Indexed Access Types\n\nWe can use an _indexed access type_ to look up a specific property on another type:\n\nts\n\n`type Person = { age: number; name: string; alive: boolean };`\n\n`type Age = Person[\"age\"];`\n\n     `type Age = number`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUKEhQAgkUywEKVAG0ARIQi6AuvID0pqJYB6AfiA)\n\nThe indexing type is itself a type, so we can use unions, `keyof`, or other types entirely:\n\nts\n\n`type I1 = Person[\"age\" | \"name\"];`\n\n     `type I1 = string | number`\n\n`type I2 = Person[keyof Person];`\n\n     `type I2 = string | number | boolean`\n\n`type AliveOrName = \"alive\" | \"name\";`\n\n`type I3 = Person[AliveOrName];`\n\n     `type I3 = string | boolean`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBJAIyZYCFKgDaAIkIQbUAD5QbqJg4C68pVD8A9AH45PXBoQwAmMzgkNCsAawgQZAAzc1jUb0VlAODQgwBBAWEAeXgAOQ8zO2KHZ1d3Zht5fXCAZmiLOKKhCDLK5izfXKA)\n\nYou’ll even see an error if you try to index a property that doesn’t exist:\n\nts\n\n`type I1 = Person[\"alve\"];`\n\n`Property 'alve' does not exist on type 'Person'.2339Property 'alve' does not exist on type 'Person'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAXATwAdJQAFGROAO1AF5QBvUAQwHNJUaBXAWwBGMANygarPl1CJ80AJY12o1gBs5ANykC4cFZFZ0AvsNwhQAWksBjHvkvmCJMgEkAjAwpVaAbQBEqzV8AXWEgA)\n\nAnother example of indexing with an arbitrary type is using `number` to get the type of an array’s elements. We can combine this with `typeof` to conveniently capture the element type of an array literal:\n\nts\n\n`const MyArray = [`\n\n  `{ name: \"Alice\", age: 15 },`\n\n  `{ name: \"Bob\", age: 23 },`\n\n  `{ name: \"Eve\", age: 38 },`\n\n`];`\n\n`type Person = typeof MyArray[number];`\n\n       `type Person = {     name: string;     age: number; }`\n\n`type Age = typeof MyArray[number][\"age\"];`\n\n     `type Age = number`\n\n`// Or`\n\n`type Age2 = Person[\"age\"];`\n\n      `type Age2 = number`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAsgTwIICcUEMEwLwwNoBQMMA3jGOgLYCmAXDAERIA2AlsNQwDQzoDmdGAEYArDAC+XIqXJVBDAEIgARt14D6AJgDMEqcTIUa9BgFEAbpx79B2gBx6CAXQDcBAlAQAHajAAK1CgQ4Dgwnj4gAGbwyGiYeGAArpTKga4EAPQZxDAAegD8Ht6+SAKh4dRRMagYCAnJqShOeAw2DOlZOQWZ2QDyKEU+MKXUmqEBQeAtbR3ZxAVAA)\n\nYou can only use types when indexing, meaning you can’t use a `const` to make a variable reference:\n\nts\n\n`const key = \"age\";`\n\n`type Age = Person[key];`\n\n`Type 'key' cannot be used as an index type.   'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?2538   2749Type 'key' cannot be used as an index type.   'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMAOdB2AFgE4AoAFwE8AHSUABRkTgDtQBeUAb1AEMBzSKhYBXALYAjGAG5QLXmKGhE5aAEsW-WbwA2agG5KJcODsi82AX2mkQoALSOAxiPKP7pJ6xWgA1pEoOUAAiAUhgmypaUABBQSDGJFYAbX9KAF1pIA)\n\nHowever, you can use a type alias for a similar style of refactor:\n\nts\n\n`type key = \"age\";`\n\n`type Age = Person[key];`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBrCCExQARIQjn5+6AEEiZuEjQBtYyAC6dIA)",
    "title": "TypeScript: Documentation - Indexed Access Types",
    "description": "Using Type['a'] syntax to access a subset of a type.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/project-references.html",
    "markdown": "# TypeScript: Documentation - Project References\n\nProject references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.\n\nBy doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.\n\nWe’re also introducing a new mode for `tsc`, the `--build` flag, that works hand in hand with project references to enable faster TypeScript builds.\n\n## [](#an-example-project)An Example Project\n\nLet’s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, `converter` and `units`, and a corresponding test file for each:\n\n`/`\n\n`├── src/`\n\n`│   ├── converter.ts`\n\n`│   └── units.ts`\n\n`├── test/`\n\n`│   ├── converter-tests.ts`\n\n`│   └── units-tests.ts`\n\n`└── tsconfig.json`\n\nThe test files import the implementation files and do some testing:\n\nts\n\n`// converter-tests.ts`\n\n`import * as converter from \"../src/converter\";`\n\n`assert.areEqual(converter.celsiusToFahrenheit(0), 32);`\n\nPreviously, this structure was rather awkward to work with if you used a single tsconfig file:\n\n*   It was possible for the implementation files to import the test files\n*   It wasn’t possible to build `test` and `src` at the same time without having `src` appear in the output folder name, which you probably don’t want\n*   Changing just the _internals_ in the implementation files required _typechecking_ the tests again, even though this wouldn’t ever cause new errors\n*   Changing just the tests required typechecking the implementation again, even if nothing changed\n\nYou could use multiple tsconfig files to solve _some_ of those problems, but new ones would appear:\n\n*   There’s no built-in up-to-date checking, so you end up always running `tsc` twice\n*   Invoking `tsc` twice incurs more startup time overhead\n*   `tsc -w` can’t run on multiple config files at once\n\nProject references can solve all of these problems and more.\n\n## [](#what-is-a-project-reference)What is a Project Reference?\n\n`tsconfig.json` files have a new top-level property, [`references`](https://www.typescriptlang.org/tsconfig#references). It’s an array of objects that specifies projects to reference:\n\njs\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `// The usual`\n\n    `},`\n\n    `\"references\": [`\n\n        `{ \"path\": \"../src\" }`\n\n    `]`\n\n`}`\n\nThe `path` property of each reference can point to a directory containing a `tsconfig.json` file, or to the config file itself (which may have any name).\n\nWhen you reference a project, new things happen:\n\n*   Importing modules from a referenced project will instead load its _output_ declaration file (`.d.ts`)\n*   If the referenced project produces an [`outFile`](https://www.typescriptlang.org/tsconfig#outFile), the output file `.d.ts` file’s declarations will be visible in this project\n*   Build mode (see below) will automatically build the referenced project if needed\n\nBy separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.\n\n## [](#composite)`composite`\n\nReferenced projects must have the new [`composite`](https://www.typescriptlang.org/tsconfig#composite) setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the [`composite`](https://www.typescriptlang.org/tsconfig#composite) flag changes a few things:\n\n*   The [`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir) setting, if not explicitly set, defaults to the directory containing the `tsconfig` file\n*   All implementation files must be matched by an [`include`](https://www.typescriptlang.org/tsconfig#include) pattern or listed in the [`files`](https://www.typescriptlang.org/tsconfig#files) array. If this constraint is violated, `tsc` will inform you which files weren’t specified\n*   [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) must be turned on\n\n## [](#declarationmap)`declarationMap`\n\nWe’ve also added support for [declaration source maps](https://github.com/Microsoft/TypeScript/issues/14479). If you enable [`declarationMap`](https://www.typescriptlang.org/tsconfig#declarationMap), you’ll be able to use editor features like “Go to Definition” and Rename to transparently navigate and edit code across project boundaries in supported editors.\n\n## [](#prepend-with-outfile)`prepend` with `outFile`\n\nYou can also enable prepending the output of a dependency using the `prepend` option in a reference:\n\njs\n\n   `\"references\": [`\n\n       `{ \"path\": \"../utils\", \"prepend\": true }`\n\n   `]`\n\nPrepending a project will include the project’s output above the output of the current project. All output files (`.js`, `.d.ts`, `.js.map`, `.d.ts.map`) will be emitted correctly.\n\n`tsc` will only ever use existing files on disk to do this process, so it’s possible to create a project where a correct output file can’t be generated because some project’s output would be present more than once in the resulting file. For example:\n\ntxt\n\n   `A`\n\n  `^ ^`\n\n `/   \\`\n\n`B     C`\n\n `^   ^`\n\n  `\\ /`\n\n   `D`\n\nIt’s important in this situation to not prepend at each reference, because you’ll end up with two copies of `A` in the output of `D` - this can lead to unexpected results.\n\n## [](#caveats-for-project-references)Caveats for Project References\n\nProject references have a few trade-offs you should be aware of.\n\nBecause dependent projects make use of `.d.ts` files that are built from their dependencies, you’ll either have to check in certain build outputs _or_ build a project after cloning it before you can navigate the project in an editor without seeing spurious errors.\n\nWhen using VS Code (since TS 3.7) we have a behind-the-scenes in-memory `.d.ts` generation process that should be able to mitigate this, but it has some perf implications. For very large composite projects you might want to disable this using [disableSourceOfProjectReferenceRedirect option](https://www.typescriptlang.org/tsconfig#disableSourceOfProjectReferenceRedirect).\n\nAdditionally, to preserve compatibility with existing build workflows, `tsc` will _not_ automatically build dependencies unless invoked with the `--build` switch. Let’s learn more about `--build`.\n\n## [](#build-mode-for-typescript)Build Mode for TypeScript\n\nA long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the `--build` flag with `tsc`. This is effectively a new entry point for `tsc` that behaves more like a build orchestrator than a simple compiler.\n\nRunning `tsc --build` (`tsc -b` for short) will do the following:\n\n*   Find all referenced projects\n*   Detect if they are up-to-date\n*   Build out-of-date projects in the correct order\n\nYou can provide `tsc -b` with multiple config file paths (e.g. `tsc -b src test`). Just like `tsc -p`, specifying the config file name itself is unnecessary if it’s named `tsconfig.json`.\n\n### [](#tsc--b-commandline)`tsc -b` Commandline\n\nYou can specify any number of config files:\n\nshell\n\n `> tsc -b                            # Use the tsconfig.json in the current directory`\n\n `> tsc -b src                        # Use src/tsconfig.json`\n\n `> tsc -b foo/prd.tsconfig.json bar  # Use foo/prd.tsconfig.json and bar/tsconfig.json`\n\nDon’t worry about ordering the files you pass on the commandline - `tsc` will re-order them if needed so that dependencies are always built first.\n\nThere are also some flags specific to `tsc -b`:\n\n*   [`--verbose`](https://www.typescriptlang.org/tsconfig#verbose): Prints out verbose logging to explain what’s going on (may be combined with any other flag)\n*   `--dry`: Shows what would be done but doesn’t actually build anything\n*   `--clean`: Deletes the outputs of the specified projects (may be combined with `--dry`)\n*   [`--force`](https://www.typescriptlang.org/tsconfig#force): Act as if all projects are out of date\n*   `--watch`: Watch mode (may not be combined with any flag except [`--verbose`](https://www.typescriptlang.org/tsconfig#verbose))\n\n## [](#caveats)Caveats\n\nNormally, `tsc` will produce outputs (`.js` and `.d.ts`) in the presence of syntax or type errors, unless [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you’d only see it _once_ because a subsequent build would skip building the now up-to-date project. For this reason, `tsc -b` effectively acts as if [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) is enabled for all projects.\n\nIf you check in any build outputs (`.js`, `.d.ts`, `.d.ts.map`, etc.), you may need to run a [`--force`](https://www.typescriptlang.org/tsconfig#force) build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.\n\n## [](#msbuild)MSBuild\n\nIf you have an msbuild project, you can enable build mode by adding\n\nxml\n\n    `<TypeScriptBuildMode>true</TypeScriptBuildMode>`\n\nto your proj file. This will enable automatic incremental build as well as cleaning.\n\nNote that as with `tsconfig.json` / `-p`, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.\n\nSome teams have set up msbuild-based workflows wherein tsconfig files have the same _implicit_ graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use `msbuild` with `tsc -p` along with project references; these are fully interoperable.\n\n## [](#guidance)Guidance\n\n### [](#overall-structure)Overall Structure\n\nWith more `tsconfig.json` files, you’ll usually want to use [Configuration file inheritance](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.\n\nAnother good practice is to have a “solution” `tsconfig.json` file that simply has [`references`](https://www.typescriptlang.org/tsconfig#references) to all of your leaf-node projects and sets [`files`](https://www.typescriptlang.org/tsconfig#files) to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty [`files`](https://www.typescriptlang.org/tsconfig#files) array if you have at least one `reference` in a `tsconfig.json` file.\n\nThis presents a simple entry point; e.g. in the TypeScript repo we simply run `tsc -b src` to build all endpoints because we list all the subprojects in `src/tsconfig.json`\n\nYou can see these patterns in the TypeScript repo - see `src/tsconfig_base.json`, `src/tsconfig.json`, and `src/tsc/tsconfig.json` as key examples.\n\n### [](#structuring-for-relative-modules)Structuring for relative modules\n\nIn general, not much is needed to transition a repo using relative modules. Simply place a `tsconfig.json` file in each subdirectory of a given parent folder, and add `reference`s to these config files to match the intended layering of the program. You will need to either set the [`outDir`](https://www.typescriptlang.org/tsconfig#outDir) to an explicit subfolder of the output folder, or set the [`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir) to the common root of all project folders.\n\n### [](#structuring-for-outfiles)Structuring for outFiles\n\nLayout for compilations using [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) is more flexible because relative paths don’t matter as much. One thing to keep in mind is that you’ll generally want to not use `prepend` until the “last” project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some “library” projects and some “endpoint” projects; “endpoint” projects are kept as small as possible and pull in only the libraries they need.",
    "title": "TypeScript: Documentation - Project References",
    "description": "How to split up a large TypeScript project",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/keyof-types.html",
    "markdown": "# TypeScript: Documentation - Keyof Type Operator\n\n## [](#the-keyof-type-operator)The `keyof` type operator\n\nThe `keyof` operator takes an object type and produces a string or numeric literal union of its keys. The following type `P` is the same type as `type P = \"x\" | \"y\"`:\n\nts\n\n`type Point = { x: number; y: number };`\n\n`type P = keyof Point;`\n\n    `type P = keyof Point`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbygDwFxRICuAtgEYQBOA3FCAceVVAL7UBQoks6UA1hBBwAZrEQoOAeklRZAPQD8QA)\n\nIf the type has a `string` or `number` index signature, `keyof` will return those types instead:\n\nts\n\n`type Arrayish = { [n: number]: unknown };`\n\n`type A = keyof Arrayish;`\n\n    `type A = number`\n\n`type Mapish = { [k: string]: boolean };`\n\n`type M = keyof Mapish;`\n\n    `type M = string | number`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnAhiAlgZwBZQLxQN5QDaAdgFxTECuAtgEYRwC65lxA1sQPYDuxUAvgG4AUKEiwcUNhBCcAZrATJ0GEQHo1ULQD0A-MNHhoAWURgVkgoTbk0wOCmIBzZlFqdOAGwiI+Qw+LGktKyCqbmmOqaOrpAA)\n\nNote that in this example, `M` is `string | number` — this is because JavaScript object keys are always coerced to a string, so `obj[0]` is always the same as `obj[\"0\"]`.\n\n`keyof` types become especially useful when combined with mapped types, which we’ll learn more about later.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/Keyof%20Type%20Operator.md) ❤\n\nContributors to this page:\n\nLast updated: Jul 11, 2024",
    "title": "TypeScript: Documentation - Keyof Type Operator",
    "description": "Using the keyof operator in type contexts.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
    "markdown": "# TypeScript: Documentation - Generics\n\nA major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.\n\nIn languages like C# and Java, one of the main tools in the toolbox for creating reusable components is _generics_, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.\n\n## [](#hello-world-of-generics)Hello World of Generics\n\nTo start off, let’s do the “hello world” of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the `echo` command.\n\nWithout generics, we would either have to give the identity function a specific type:\n\nts\n\n`function identity(arg: number): number {`\n\n  `return arg;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkTBAFsAjNQgSnMtvsQG8AoRRQtKEISRFiAbk4BfIA)\n\nOr, we could describe the identity function using the `any` type:\n\nts\n\n`function identity(arg: any): any {`\n\n  `return arg;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkXzGwEpzLtEBvAKEUULShEKSOIG5mAXyA)\n\nWhile using `any` is certainly generic in that it will cause the function to accept any and all types for the type of `arg`, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.\n\nInstead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a _type variable_, a special kind of variable that works on types rather than values.\n\nts\n\n`function identity<Type>(arg: Type): Type {`\n\n  `return arg;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA)\n\nWe’ve now added a type variable `Type` to the identity function. This `Type` allows us to capture the type the user provides (e.g. `number`), so that we can use that information later. Here, we use `Type` again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.\n\nWe say that this version of the `identity` function is generic, as it works over a range of types. Unlike using `any`, it’s also just as precise (i.e., it doesn’t lose any information) as the first `identity` function that used numbers for the argument and return type.\n\nOnce we’ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:\n\nts\n\n`let output = identity<string>(\"myString\");`\n\n      `let output: string`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwcuAM5RqMMLQoAiALbYAyvce0XLKQV+YP4APQB+IA)\n\nHere we explicitly set `Type` to be `string` as one of the arguments to the function call, denoted using the `<>` around the arguments rather than `()`.\n\nThe second way is also perhaps the most common. Here we use _type argument inference_ — that is, we want the compiler to set the value of `Type` for us automatically based on the type of the argument we pass in:\n\nts\n\n`let output = identity(\"myString\");`\n\n      `let output: string`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwc5AEQBbbAGUo1GGFo2WUhf1-8AegD8QA)\n\nNotice that we didn’t have to explicitly pass the type in the angle brackets (`<>`); the compiler just looked at the value `\"myString\"`, and set `Type` to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.\n\n## [](#working-with-generic-type-variables)Working with Generic Type Variables\n\nWhen you begin to use generics, you’ll notice that when you create generic functions like `identity`, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.\n\nLet’s take our `identity` function from earlier:\n\nts\n\n`function identity<Type>(arg: Type): Type {`\n\n  `return arg;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA)\n\nWhat if we want to also log the length of the argument `arg` to the console with each call? We might be tempted to write this:\n\nts\n\n`function loggingIdentity<Type>(arg: Type): Type {`\n\n  `console.log(arg.length);`\n\n`Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.    return arg;  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA)\n\nWhen we do, the compiler will give us an error that we’re using the `.length` member of `arg`, but nowhere have we said that `arg` has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a `number` instead, which does not have a `.length` member.\n\nLet’s say that we’ve actually intended this function to work on arrays of `Type` rather than `Type` directly. Since we’re working with arrays, the `.length` member should be available. We can describe this just like we would create arrays of other types:\n\nts\n\n`function loggingIdentity<Type>(arg: Type[]): Type[] {`\n\n  `console.log(arg.length);`\n\n  `return arg;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkWroG0BdAJRceBAYgDeAKESIICAM5xkBAHSo0LduqJooAC0EBuGYlYEoIVkjZoTAXyA)\n\nYou can read the type of `loggingIdentity` as “the generic function `loggingIdentity` takes a type parameter `Type`, and an argument `arg` which is an array of `Type`s, and returns an array of `Type`s.” If we passed in an array of numbers, we’d get an array of numbers back out, as `Type` would bind to `number`. This allows us to use our generic type variable `Type` as part of the types we’re working with, rather than the whole type, giving us greater flexibility.\n\nWe can alternatively write the sample example this way:\n\nts\n\n`function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {`\n\n  `console.log(arg.length); // Array has a .length, so no more error`\n\n  `return arg;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkQEFXXmK1OvQCUXXv0G0GiAN4AoRIggIAznGQEAdKjQt2OomigALEQG5EAeis8+AxCearEzRIeymANInWIwcIgAtnCsBIgEfKGKiGFQIKxIbGjm8gC+QA)\n\nYou may already be familiar with this style of type from other languages. In the next section, we’ll cover how you can create your own generic types like `Array<Type>`.\n\n## [](#generic-types)Generic Types\n\nIn previous sections, we created generic identity functions that worked over a range of types. In this section, we’ll explore the type of the functions themselves and how to create generic interfaces.\n\nThe type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:\n\nts\n\n`function identity<Type>(arg: Type): Type {`\n\n  `return arg;`\n\n`}`\n\n`let myIdentity: <Type>(arg: Type) => Type = identity;`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIwLEyVOu30tEAXlJN955JqzYJQA)\n\nWe could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.\n\nts\n\n`function identity<Type>(arg: Type): Type {`\n\n  `return arg;`\n\n`}`\n\n`let myIdentity: <Input>(arg: Input) => Input = identity;`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHI1xqwREFArjG+w1BaIAvKUTmjN5JqzYJQA)\n\nWe can also write the generic type as a call signature of an object literal type:\n\nts\n\n`function identity<Type>(arg: Type): Type {`\n\n  `return arg;`\n\n`}`\n\n`let myIdentity: { <Type>(arg: Type): Type } = identity;`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIy6ICxMlTrtDbJocTTEAXmSas2CUA)\n\nWhich leads us to writing our first generic interface. Let’s take the object literal from the previous example and move it to an interface:\n\nts\n\n`interface GenericIdentityFn {`\n\n  `<Type>(arg: Type): Type;`\n\n`}`\n\n`function identity<Type>(arg: Type): Type {`\n\n  `return arg;`\n\n`}`\n\n`let myIdentity: GenericIdentityFn = identity;`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDERkBvAKGWQB4AVEgBwgD4AKOKAcwBcyFuwCUQkRADcNAL40aMAK4gERAPaVgBcMRLM2nHvwmHxww9TrIoEMEqiVefGfJoAbO8gC2JfIT0hdEwobH9dUgpkAF5kbQDSKSA)\n\nIn a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we’re generic over (e.g. `Dictionary<string>` rather than just `Dictionary`). This makes the type parameter visible to all the other members of the interface.\n\nts\n\n`interface GenericIdentityFn<Type> {`\n\n  `(arg: Type): Type;`\n\n`}`\n\n`function identity<Type>(arg: Type): Type {`\n\n  `return arg;`\n\n`}`\n\n`let myIdentity: GenericIdentityFn<number> = identity;`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDEQAeAFRIAcIA+ZAbwChlkAKOKAcwBcyWgwCUQkRADcbAL5s2MAK4gERAPYhkwAuGIka9Jj34Sj44UdYdkUCGCVQtvPjPlsANveQBbEvkJ9IXRMKGwAvVIKShAlHwAjaGYAXm1dIlIpIA)\n\nNotice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use `GenericIdentityFn`, we now will also need to specify the corresponding type argument (here: `number`), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.\n\nIn addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.\n\n## [](#generic-classes)Generic Classes\n\nA generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (`<>`) following the name of the class.\n\nts\n\n`class GenericNumber<NumType> {`\n\n  `zeroValue: NumType;`\n\n  `add: (x: NumType, y: NumType) => NumType;`\n\n`}`\n\n`let myGenericNumber = new GenericNumber<number>();`\n\n`myGenericNumber.zeroValue = 0;`\n\n`myGenericNumber.add = function (x, y) {`\n\n  `return x + y;`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAgWw8aFAWfipaeh4OWHdQWgB3Sho6JCiualZokWNnHVDwlMZMugA6OVglFTxYgAY8sOTI4tgSg31Y9CZqZHh5alAzW35XSWlYIKZYftNQAGo7Xy0gA)\n\nThis is a pretty literal use of the `GenericNumber` class, but you may have noticed that nothing is restricting it to only use the `number` type. We could have instead used `string` or even more complex objects.\n\nts\n\n`let stringNumeric = new GenericNumber<string>();`\n\n`stringNumeric.zeroValue = \"\";`\n\n`stringNumeric.add = function (x, y) {`\n\n  `return x + y;`\n\n`};`\n\n`console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAiFAAWmDEJmhgwIJsPGhQGARqAHMeOiR3UFoAd0oaVMZWDlhOePgkkWNnHRKklPoAOjlYJRU8dIAiNqq4UuTWPLqDfXT0JmpkeHlqUDNbfldJaVgYplgp01AAajtfHSJJyHlouux5RONq3pZ+wfPumr76xubsVVs26DwYNudKoA)\n\nJust as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.\n\nAs we cover in [our section on classes](https://www.typescriptlang.org/docs/handbook/2/classes.html), a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter.\n\n## [](#generic-constraints)Generic Constraints\n\nIf you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have _some_ knowledge about what capabilities that set of types will have. In our `loggingIdentity` example, we wanted to be able to access the `.length` property of `arg`, but the compiler could not prove that every type had a `.length` property, so it warns us that we can’t make this assumption.\n\nts\n\n`function loggingIdentity<Type>(arg: Type): Type {`\n\n  `console.log(arg.length);`\n\n`Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.    return arg;  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA)\n\nInstead of working with any and all types, we’d like to constrain this function to work with any and all types that _also_  have the `.length` property. As long as the type has this member, we’ll allow it, but it’s required to have at least this member. To do so, we must list our requirement as a constraint on what `Type` can be.\n\nTo do so, we’ll create an interface that describes our constraint. Here, we’ll create an interface that has a single `.length` property and then we’ll use this interface and the `extends` keyword to denote our constraint:\n\nts\n\n`interface Lengthwise {`\n\n  `length: number;`\n\n`}`\n\n`function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {`\n\n  `console.log(arg.length); // Now we know it has a .length property, so no more error`\n\n  `return arg;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHcuZAB6eOQAOXE8ZDwUAGsQNORgMGQcOAs4ZCisXGQ9KHEDKA0AGmRApnFkVnEoQyhaqF9usGYoKSdMHl4gA)\n\nBecause the generic function is now constrained, it will no longer work over any and all types:\n\nts\n\n`loggingIdentity(3);`\n\n`Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKADKREDmJAFgO4GJ0DeeoUABsmrNqiIBXALYAjGAG48AXzx5ykotRIE4RYXGbNizAJIATJjpIBPADwAVGwAc6kAB5ki5xA1HsuHgA+AApKaGZUJ1cASiiXPgFQaj1EOBEAOiFDMIis-zYYpUFoSBJJaH1w5iVVEFAAWibqSRImhrxsoxMLKwJbEIwioA)\n\nInstead, we need to pass in values whose type has all the required properties:\n\nts\n\n`loggingIdentity({ length: 10, value: 3 });`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHceSigIMGYoKSdMHn4AekzkAFp8hGYwfNyyMNl5ZVVgDXsSamjGAEYABgAaZAA3OCpmCEYAZmReWKA)\n\n## [](#using-type-parameters-in-generic-constraints)Using Type Parameters in Generic Constraints\n\nYou can declare a type parameter that is constrained by another type parameter. For example, here we’d like to get a property from an object given its name. We’d like to ensure that we’re not accidentally grabbing a property that does not exist on the `obj`, so we’ll place a constraint between the two types:\n\nts\n\n`function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {`\n\n  `return obj[key];`\n\n`}`\n\n`let x = { a: 1, b: 2, c: 3, d: 4 };`\n\n`getProperty(x, \"a\");`\n\n`getProperty(x, \"m\");`\n\n`Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAOaQUAK8ADjBQJ4A8AKlw4AaUAGlIXUJAAeFSCQAmiUAGsJcAqAEcAfAAo4AIwBWqbZBFquqcVwCUoAN55QoaEyLQ6R4wG0rALoA3HgAvnh4ADZMoNKgALxOoACGqACMIoaoaCJkqBgiCqhYoKEheIws7JxcetIiAETJDXYhlaxwHNDcdY0Ati1BQA)\n\n## [](#using-class-types-in-generics)Using Class Types in Generics\n\nWhen creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,\n\nts\n\n`function create<Type>(c: { new (): Type }): Type {`\n\n  `return new c();`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBATgUwIZTQHgCoCeADmgHwAUEAXIgN6JhoDui5AlDYSYgL4eJc0dAFCJE6KCBRJGLCOwDcwnkA)\n\nA more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.\n\nts\n\n`class BeeKeeper {`\n\n  `hasMask: boolean = true;`\n\n`}`\n\n`class ZooKeeper {`\n\n  `nametag: string = \"Mikle\";`\n\n`}`\n\n`class Animal {`\n\n  `numLegs: number = 4;`\n\n`}`\n\n`class Bee extends Animal {`\n\n  `numLegs = 6;`\n\n  `keeper: BeeKeeper = new BeeKeeper();`\n\n`}`\n\n`class Lion extends Animal {`\n\n  `keeper: ZooKeeper = new ZooKeeper();`\n\n`}`\n\n`function createInstance<A extends Animal>(c: new () => A): A {`\n\n  `return new c();`\n\n`}`\n\n`createInstance(Lion).keeper.nametag;`\n\n`createInstance(Bee).keeper.hasMask;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgBCeeA0tQA56ygDeBooAFqQLKkDWaAEYB7EdjyYAdqAC8oOAFc8AbgIBfAkRJlQALTF08jZmw5TMAWzzRMAczQwEUu3NAAiHvH4T3azdqk5ACCUvCWOKzsoFKKlgAyeHaQaLGWQkxuACz+WsRBlNSgeAAe0HhSACYhYRHYUeZxicluAGxqHPwMTGhUtN3M8lJ4AO6F-cZMABQAlLmBuvHwIjKl5VU14ZFmoF2TsGgGIkYmbsNjRyfTcxpa6IpSyMsyiLCS5QCSUjDSiHgAPMFimUKtVQKEttgAHxTRCpUagWZyKHgmZoIE7N7QRSwGTnUCIWbzV7vPBfH6PPBTJYrGYAOj2JjpFmstjsahJmE+31slKmfXpjKYdO4kD4kH4KiAA)\n\nThis pattern is used to power the [mixins](https://www.typescriptlang.org/docs/handbook/mixins.html) design pattern.\n\n## [](#generic-parameter-defaults)Generic Parameter Defaults\n\nBy declaring a default for a generic type parameter, you make it optional to specify the corresponding type argument. For example, a function which creates a new `HTMLElement`. Calling the function with no arguments generates a `HTMLDivElement`; calling the function with an element as the first argument generates an element of the argument’s type. You can optionally pass a list of children as well. Previously you would have to define the function as:\n\nts\n\n`declare function create(): Container<HTMLDivElement, HTMLDivElement[]>;`\n\n`declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;`\n\n`declare function create<T extends HTMLElement, U extends HTMLElement>(`\n\n  `element: T,`\n\n  `children: U[]`\n\n`): Container<T, U[]>;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQAFAEou8JGgw4AErgBZABkAEVQANwBRZjYkQn9gsKiY9mAAbQBdEj4DIxNoCysbOwEHJzwGAA8nBDEAZygEoOjWVJJnJlbObndYRBR0LDxCXEzs-UNjU0LrWwR7CEcICohq9nrGwOaUuOIqmo2mltjgdv5Ok64CfmFRCSliTJpezwGfYcesniA)\n\nWith generic parameter defaults we can reduce it to:\n\nts\n\n`declare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(`\n\n  `element?: T,`\n\n  `children?: U`\n\n`): Container<T, U>;`\n\n`const div = create();`\n\n      `const div: Container<HTMLDivElement, HTMLDivElement[]>`\n\n`const p = create(new HTMLParagraphElement());`\n\n     `const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQ8DAB5OEYgM5QAErgBZABkAUWY2JAo-QKCAEVQANzDWdmBCIjcPb2jg5IjgAG0AXSjcYpIACn4mFKQAfi4CfmFRCXYG4hoASi54JDQMHAJiEgUBRC9gKDFEqIEHJwquvmV6egA9OpoacYRJqDA5hYgKjAB3HKCABRNkAHNMZDAhPNSl5aUVNc2gA)\n\nA generic parameter default follows the following rules:\n\n*   A type parameter is deemed optional if it has a default.\n*   Required type parameters must not follow optional type parameters.\n*   Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.\n*   When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.\n*   If a default type is specified and inference cannot choose a candidate, the default type is inferred.\n*   A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.\n*   A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.",
    "title": "TypeScript: Documentation - Generics",
    "description": "Types which take parameters",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/typeof-types.html",
    "markdown": "# TypeScript: Documentation - Typeof Type Operator\n\n## [](#the-typeof-type-operator)The `typeof` type operator\n\nJavaScript already has a `typeof` operator you can use in an _expression_ context:\n\nts\n\n`// Prints \"string\"`\n\n`console.log(typeof \"Hello world\");`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAUCcEsDsBcDOoBEj41gcxQKAMYD2sihANgKYB0ZhWAFPAJ4AOFhAZqgBIVm2gA7oUhkAJigCUAbiA)\n\nTypeScript adds a `typeof` operator you can use in a _type_ context to refer to the _type_ of a variable or property:\n\nts\n\n`let s = \"hello\";`\n\n`let n: typeof s;`\n\n   `let n: string`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzhC8ECIAWJjAPYINwChSQDsAuCMATwAcR0AzaXAegYggD0B+IA)\n\nThis isn’t very useful for basic types, but combined with other type operators, you can use `typeof` to conveniently express many patterns. For an example, let’s start by looking at the predefined type `ReturnType<T>`. It takes a _function type_ and produces its return type:\n\nts\n\n`type Predicate = (x: unknown) => boolean;`\n\n`type K = ReturnType<Predicate>;`\n\n    `type K = boolean`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgThAJgSwMYENjQLxQBQAeAXFAK4B2A1uQPYDu5AlFNgHxQBGNNANhOuQDcAKFCQoAaRZQAShGCk45ACrgIAHnhI0mCKxEB6A1BMA9APxA)\n\nIf we try to use `ReturnType` on a function name, we see an instructive error:\n\nts\n\n`function f() {`\n\n  `return { x: 10, y: 3 };`\n\n`}`\n\n`type P = ReturnType<f>;`\n\n`'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?2749'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYAsBOAUAGYCuAdgMYAuAlnCaAQBQCUoA3nqKNJBUdHa1AAPVAEYADABpQAT1QBmUAF8A3HiV4KMgA6RQABVABeUACUefEgBUdkADwEAfCqA)\n\nRemember that _values_ and _types_ aren’t the same thing. To refer to the _type_ that the _value `f`_ has, we use `typeof`:\n\nts\n\n`function f() {`\n\n  `return { x: 10, y: 3 };`\n\n`}`\n\n`type P = ReturnType<typeof f>;`\n\n    `type P = {     x: number;     y: number; }`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFASkQbwFCMQJwFMoR8lNEAPALkQEYAGAGkQE9aBmRAXwG5tu2KKwAOhRAAVEAXkQAlYqTAAVUYQA8wsXGDIAfPwD0hvIgB6AfiA)\n\n### [](#limitations)Limitations\n\nTypeScript intentionally limits the sorts of expressions you can use `typeof` on.\n\nSpecifically, it’s only legal to use `typeof` on identifiers (i.e. variable names) or their properties. This helps avoid the confusing trap of writing code you think is executing, but isn’t:\n\nts\n\n`// Meant to use = ReturnType<typeof msgbox>`\n\n`let shouldContinue: typeof msgbox(\"Are you sure you want to continue?\");`\n\n`',' expected.1005',' expected.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYMFYBQATSAYwBsBDaSUIuAO0QBdQBbRAcwCM4APVACgAO8ZgIapG0AJa02ASlABeAHygucEpDK0A3LhCgGATwFVWnHotBbDu-QFoHRAK4MHdvWACym2kwZxQJ0QqBVAAJUgGJ2haABVjSAAeIxM4ADMWdi5uJVwNJkQACzgnEnwAYToGaSdIVBTIdMzzbj4AIgBBSlBDEtBEaKpep1AAdy0-AJpfGsgAfjbZbSA)",
    "title": "TypeScript: Documentation - Typeof Type Operator",
    "description": "Using the typeof operator in type contexts.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-3.html",
    "markdown": "# TypeScript: Documentation - TypeScript 1.3\n\n## [](#protected)Protected\n\nThe new `protected` modifier in classes works like it does in familiar languages like C++, C#, and Java. A `protected` member of a class is visible only inside subclasses of the class in which it is declared:\n\nts\n\n`class Thing {`\n\n  `protected doSomething() {`\n\n    `/* ... */`\n\n  `}`\n\n`}`\n\n`class MyThing extends Thing {`\n\n  `public myMethod() {`\n\n    `// OK, can access protected member from subclass`\n\n    `this.doSomething();`\n\n  `}`\n\n`}`\n\n`var t = new MyThing();`\n\n`t.doSomething(); // Error, cannot call protected member from outside class`\n\n## [](#tuple-types)Tuple types\n\nTuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a `string` at position 0 and a `number` at position 1:\n\nts\n\n`// Declare a tuple type`\n\n`var x: [string, number];`\n\n`// Initialize it`\n\n`x = [\"hello\", 10]; // OK`\n\n`// Initialize it incorrectly`\n\n`x = [10, \"hello\"]; // Error`\n\nWhen accessing an element with a known index, the correct type is retrieved:\n\nts\n\n`console.log(x[0].substr(1)); // OK`\n\n`console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'`\n\nNote that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:\n\nts\n\n`x[3] = \"world\"; // OK`\n\n`console.log(x[5].toString()); // OK, 'string' and 'number' both have toString`\n\n`x[6] = true; // Error, boolean isn't number or string`",
    "title": "TypeScript: Documentation - TypeScript 1.3",
    "description": "TypeScript 1.3 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html",
    "markdown": "# TypeScript: Documentation - Conditional Types\n\nAt the heart of most useful programs, we have to make decisions based on input. JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. _Conditional types_ help describe the relation between the types of inputs and outputs.\n\nts\n\n`interface Animal {`\n\n  `live(): void;`\n\n`}`\n\n`interface Dog extends Animal {`\n\n  `woof(): void;`\n\n`}`\n\n`type Example1 = Dog extends Animal ? number : string;`\n\n        `type Example1 = number`\n\n`type Example2 = RegExp extends Animal ? number : string;`\n\n        `type Example2 = string`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwChlkdgA3CACgEoAuZcge2ABMBuQgX0NElkQoAIkwDmyCAA9IIVgGc0GbHiIkA7kyYxaDZm049CYAJ4AHFAFFJcTKZwQAjMgC8yEeKkz5irLmQB+ZBAAV0wAI2hkBjkwKFBRTgB6RJJkAD1-QiMzS2tbewAmF2QAJQhRK1MJaQhZBXRfPECQ8Mjo2PiklJIMoA)\n\nConditional types take a form that looks a little like conditional expressions (`condition ? trueExpression : falseExpression`) in JavaScript:\n\nts\n\n  `SomeType extends OtherType ? TrueType : FalseType;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgChRIoB5YACwgCdVTNcDi0pkaBXFVxvIk6ADEsAGwDO3Btj4tSMYBwBmiqOkJQoAek1QAtPoDGHYPt3rYiSdAgAPYBBwATMeSq160APxtOVqAC4oYXErfCA)\n\nWhen the type on the left of the `extends` is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).\n\nFrom the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not `Dog extends Animal` and pick `number` or `string`! But the power of conditional types comes from using them with generics.\n\nFor example, let’s take the following `createLabel` function:\n\nts\n\n`interface IdLabel {`\n\n  `id: number /* some fields */;`\n\n`}`\n\n`interface NameLabel {`\n\n  `name: string /* other fields */;`\n\n`}`\n\n`function createLabel(id: number): IdLabel;`\n\n`function createLabel(name: string): NameLabel;`\n\n`function createLabel(nameOrId: string | number): IdLabel | NameLabel;`\n\n`function createLabel(nameOrId: string | number): IdLabel | NameLabel {`\n\n  `throw \"unimplemented\";`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbJIw6IBGGA8QyBFAg4SA0CAApKGnomaABKGgwQ-Ck3Dy8fPwCgiETQ3X4DI1M45FV1XAJk909vX39A4PL8XL0AeSgMAuMQMwAfWkZmYoTG5D7S7MbK1JqM+onNZv42ju5C7tH+6KghrBGxvUTiMmRrKB4Ad2QAIndgBgAHfAh+cAh0K+cgA)\n\nThese overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:\n\n1.  If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.\n2.  We have to create three overloads: one for each case when we’re _sure_ of the type (one for `string` and one for `number`), and one for the most general case (taking a `string | number`). For every new type `createLabel` can handle, the number of overloads grows exponentially.\n\nInstead, we can encode that logic in a conditional type:\n\nts\n\n`type NameOrId<T extends number | string> = T extends number`\n\n  `? IdLabel`\n\n  `: NameLabel;`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbNatkAWk8I6YT+5JgAJ4ADip6APJQGAA8ACrIEAAekCAitIzMyAA+3EamAHzIALzI8UkpafRM0GTIAPxoWLgEtTSq6s34EkA)\n\nWe can then use that conditional type to simplify our overloads down to a single function with no overloads.\n\nts\n\n`function createLabel<T extends number | string>(idOrName: T): NameOrId<T> {`\n\n  `throw \"unimplemented\";`\n\n`}`\n\n`let a = createLabel(\"typescript\");`\n\n   `let a: NameLabel`\n\n`let b = createLabel(2.8);`\n\n   `let b: IdLabel`\n\n`let c = createLabel(Math.random() ? \"hello\" : 42);`\n\n`let c: NameLabel | IdLabel`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbLABPAA4q9AeSgYAPAAqyBAAHpAgIrSMzMgAPtxGpgB8yAC8yMFhEVH0TNBkyAD8aFi4BIU0qurl+FKsrMgAtC0IdGAtTSQwdCAIYMA8IMgIUBBwkBoEQSHhEJGiebEJhsYgJskAFJS+1fqZAJRVPn7oQanayNZQPADuyABEvcAM7vgQ-OAQ6A-OJCTvMDIODpEZjCYQKb4TYPNyeLijYDuMAPA71RrIAB6RX+gOQOFBo3Gk1qmwATAA6AAcaJIDXI2NxECBCEJ4JJmk2AFkJlYKVA4JE+JsDsVHjZ8PgeA9kDQACxk2n0rFFIA)\n\n### [](#conditional-type-constraints)Conditional Type Constraints\n\nOften, the checks in a conditional type will provide us with some new information. Just like narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against.\n\nFor example, let’s take the following:\n\nts\n\n`type MessageOf<T> = T[\"message\"];`\n\n`Type '\"message\"' cannot be used to index type 'T'.2536Type '\"message\"' cannot be used to index type 'T'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMA2AUAC4CeADpKALKSKICGA5pAPIBmAPACoB8oAvKBwDaAIgC21Oo2EBdANxA)\n\nIn this example, TypeScript errors because `T` isn’t known to have a property called `message`. We could constrain `T`, and TypeScript would no longer complain:\n\nts\n\n`type MessageOf<T extends { message: unknown }> = T[\"message\"];`\n\n`interface Email {`\n\n  `message: string;`\n\n`}`\n\n`type EmailMessageContents = MessageOf<Email>;`\n\n              `type EmailMessageContents = string`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshDO8CGBzCB5AZgHgCpQgA9gIA7AE3igG8oBbBZNALigFdSBrUgewHdSUAL4A+KAF4ouANoAiBolQRZAXQDcAKA0BLUiQBOmJAGNoAUTpJtAGxoao9Rktbxg+3Sk1CtoSFAtW1nCKaADCPHpkwFSSwUwYOAE2IpoA9KkOUAB6APxAA)\n\nHowever, what if we wanted `MessageOf` to take any type, and default to something like `never` if a `message` property isn’t available? We can do this by moving the constraint out and introducing a conditional type:\n\nts\n\n`type MessageOf<T> = T extends { message: unknown } ? T[\"message\"] : never;`\n\n`interface Email {`\n\n  `message: string;`\n\n`}`\n\n`interface Dog {`\n\n  `bark(): void;`\n\n`}`\n\n`type EmailMessageContents = MessageOf<Email>;`\n\n              `type EmailMessageContents = string`\n\n`type DogMessageContents = MessageOf<Dog>;`\n\n             `type DogMessageContents = never`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshDO8CGBzCB5AZgHgCoD4oBeKXKCAD2AgDsATeKAbygFsFk0AuKAVxoDWNAPYB3GlAC+UAPykA2gCJ2iVBEUBdKDxoQAbhABOAbgBQpgJY1qhzEgDG0AKKskFgDbNTUNhzU94YEMrFDNJcysbO0coABFhFC8fACMkQwEACgBKHj1hCzow81BIKBc3dzhVNABhYWtaYEYSKs4MHHKPfDMAeh6fKAA9GWLwaHiUVrU6hutm2D80LGwJ7tM+geGgA)\n\nWithin the true branch, TypeScript knows that `T` _will_ have a `message` property.\n\nAs another example, we could also write a type called `Flatten` that flattens array types to their element types, but leaves them alone otherwise:\n\nts\n\n`type Flatten<T> = T extends any[] ? T[number] : T;`\n\n`// Extracts out the element type.`\n\n`type Str = Flatten<string[]>;`\n\n     `type Str = string`\n\n`// Leaves the type alone.`\n\n`type Num = Flatten<number>;`\n\n     `type Num = number`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYgNgQ2MCA7APAFQHxQLxSZQQAeKqAJgM5QKogDaAulAPyEOoCuAtgEYQATiwBchANwAoSQHoZUAKJlBCAMbAaAey7AowABbQIcCDzS7QkAHSTL0AMrBB+WImRp0VJwEtUAc2ZsKTkoUIA9VmkQgBkIBAA3CBoDaDtaOE1UCBs0gDleF3gkcnRufiEg2Xlw1iA)\n\nWhen `Flatten` is given an array type, it uses an indexed access with `number` to fetch out `string[]`’s element type. Otherwise, it just returns the type it was given.\n\n### [](#inferring-within-conditional-types)Inferring Within Conditional Types\n\nWe just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.\n\nConditional types provide us with a way to infer from types we compare against in the true branch using the `infer` keyword. For example, we could have inferred the element type in `Flatten` instead of fetching it out “manually” with an indexed access type:\n\nts\n\n`type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYgNgQ2MCA7APAFXBAfFAXim0iggA8VUATAZygEEAnJhEdAS1QDMImoAkigC2+APyCRUAFzEcAbiA)\n\nHere, we used the `infer` keyword to declaratively introduce a new generic type variable named `Item` instead of specifying how to retrieve the element type of `Type` within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.\n\nWe can write some useful helper type aliases using the `infer` keyword. For example, for simple cases, we can extract the return type out from function types:\n\nts\n\n`type GetReturnType<Type> = Type extends (...args: never[]) => infer Return`\n\n  `? Return`\n\n  `: never;`\n\n`type Num = GetReturnType<() => number>;`\n\n     `type Num = number`\n\n`type Str = GetReturnType<(x: string) => string>;`\n\n     `type Str = string`\n\n`type Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]>;`\n\n      `type Bools = boolean[]`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hwCV4FcBOA7AKuCAebkAfFALxQHQQAewE6AJgM5QAUAdBwIaoDmjAXFHQQAbhFQBtALoBKUsQCW6AGbioSYGnQAoKFAD86lBl1RBwsagDc27aEhQAcsgC2pWPA1aKuFnJLE6K4ARuKENgD0EXpQAHr6tvbQAMrAqO5wiMZYOL5UgoxpSjz+xIWoxeHaUTHxiThQAEIA9s0ANsxkmV4YPiycgsGtbRCc6AA0UMGDw6PopVOzY9JVNXrxQA)\n\nWhen inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the _last_ signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.\n\nts\n\n`declare function stringOrNum(x: string): number;`\n\n`declare function stringOrNum(x: number): string;`\n\n`declare function stringOrNum(x: string | number): string | number;`\n\n`type T1 = ReturnType<typeof stringOrNum>;`\n\n     `type T1 = string | number`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwGcMYtUBzAeRgDlkBbACgA8AuQ40sgSjdXoCMQMANwAoUJFgIU6bHnYlyVWo1bw+dQTB4LOYidDhI0mXPiKLKNeszYXO8AD7qBQnffJOXmoWNEYATwAHBAAVAEZ4AF54ACUQDGQYVFDgkAAeQJCcRF0lazoAPjEAehL4CoA9AH4gA)\n\n## [](#distributive-conditional-types)Distributive Conditional Types\n\nWhen conditional types act on a generic type, they become _distributive_ when given a union type. For example, take the following:\n\nts\n\n`type ToArray<Type> = Type extends any ? Type[] : never;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcQA)\n\nIf we plug a union type into `ToArray`, then the conditional type will be applied to each member of that union.\n\nts\n\n`type ToArray<Type> = Type extends any ? Type[] : never;`\n\n`type StrArrOrNumArr = ToArray<string | number>;`\n\n           `type StrArrOrNumArr = string[] | number[]`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcAKEmhIUAMrAkyJAHkkAOQCuAWxWFYiFOgx0lASyoBzKAB9BugEZjcUgPRuoXgHqsgA)\n\nWhat happens here is that `ToArray` distributes on:\n\nts\n\n  `string | number;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBBe8Dy8ByBXAts+UAvAFBRQD05UAtLQMZbC3WlQDOCAlgHYDmUAHyjdcAIwjwA3EA)\n\nand maps over each member type of the union, to what is effectively:\n\nts\n\n  `ToArray<string> | ToArray<number>;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcAKFCQoAZWBJkSAPJIAcgFcAtssKSoUAPRGoAWgsBjTcAtmDsRCnQY6igJZUA5vgA+j5RcqHQAjMVxxIA)\n\nwhich leaves us with:\n\nts\n\n  `string[] | number[];`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBBe8Dy8ByBXAts+UAvAFBRQD05UAtLQMZbC3WlQDOCAlgHYDmA2gF0oAHyjdcAIwjwhAbiA)\n\nTypically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the `extends` keyword with square brackets.\n\nts\n\n`type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;`\n\n`// 'ArrOfStrOrNum' is no longer a union.`\n\n`type ArrOfStrOrNum = ToArrayNonDist<string | number>;`\n\n          `type ArrOfStrOrNum = (string | number)[]`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgHJwHYBECWAzsADwzgQB8UAvFANrmQC6UEAHsBNgCaEOpsIVgH5YFeqwBcUbBABuEJAG4AUKoD0GqAHJkSAPIAzAMrBDSDAFcAtjqhFZcKABscAcyVRUUK9nw4AHSqoJBQ+sZmFtY2tLCIKOhYeESkxEj42O5QAD6ytgBGSpRqWlDlAHoiQA)",
    "title": "TypeScript: Documentation - Conditional Types",
    "description": "Create types which act like if statements in the type system.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/mapped-types.html",
    "markdown": "# TypeScript: Documentation - Mapped Types\n\nWhen you don’t want to repeat yourself, sometimes a type needs to be based on another type.\n\nMapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time:\n\nts\n\n`type OnlyBoolsAndHorses = {`\n\n  `[key: string]: boolean | Horse;`\n\n`};`\n\n`const conforms: OnlyBoolsAndHorses = {`\n\n  `del: true,`\n\n  `rodney: false,`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAEg9gJwM7QLxQN4F8DcAoAegKgFoyBjAV2DJL1EigHkA7AGxACE442kBBFgBN4yCEijoMeKFADaAawggAXFCTAEASxYBzALpqARjzYQAhiygAfWIhT5cePOTgsNUVywBmiALZIaqwc3LwCwqIoElIyUEIQbGqalBAANLEIcEIsymre5nxpeLhAA)\n\nA mapped type is a generic type which uses a union of `PropertyKey`s (frequently created [via a `keyof`](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)) to iterate through keys to create a type:\n\nts\n\n`type OptionsFlags<Type> = {`\n\n  `[Property in keyof Type]: boolean;`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+GoA)\n\nIn this example, `OptionsFlags` will take all the properties from the type `Type` and change their values to be a boolean.\n\nts\n\n`type Features = {`\n\n  `darkMode: () => void;`\n\n  `newUserProfile: () => void;`\n\n`};`\n\n`type FeatureOptions = OptionsFlags<Features>;`\n\n           `type FeatureOptions = {     darkMode: boolean;     newUserProfile: boolean; }`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+WgPR6oAWhMBjAK7ATR+qEhQMa4OfYQ01OoygATHO0EAskjeEPIAFACU1JQAbkgI3lpMKBAA7gCqaBDsHOIIquFRVLHxiTpatmQOTi4QcIio7jT1yOjY+ESOOM6uaOT6hkwAegD8QA)\n\n### [](#mapping-modifiers)Mapping Modifiers\n\nThere are two additional modifiers which can be applied during mapping: `readonly` and `?` which affect mutability and optionality respectively.\n\nYou can remove or add these modifiers by prefixing with `-` or `+`. If you don’t add a prefix, then `+` is assumed.\n\nts\n\n`// Removes 'readonly' attributes from a type's properties`\n\n`type CreateMutable<Type> = {`\n\n  `-readonly [Property in keyof Type]: Type[Property];`\n\n`};`\n\n`type LockedAccount = {`\n\n  `readonly id: string;`\n\n  `readonly name: string;`\n\n`};`\n\n`type UnlockedAccount = CreateMutable<LockedAccount>;`\n\n           `type UnlockedAccount = {     id: string;     name: string; }`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHIBOkCGATWA7AGwE9VQsAXC9ASwCMBXC5UAM3VmnNAuIAdIqFHw4D0FGsgBQvAaADCmSpACyTLHUKQAPABV+kAHygAvKADeU0KAC0SvEWKgA2gAVRkcU5r5QAa0hiWFZQfQEAXQAuUIM3Dy9wgG4pAF9kmQNQABlYAGMAnABBXNzYBnwKUwsrUHsCElAaHGikah8Ac2TrOsdQfCxoSBa2-E7U9NlIUABVIjyC4tLyyrNFbGY1Cg0tbRz8yCKSsorDZJBrUAA9AH4gA)\n\nts\n\n`// Removes 'optional' attributes from a type's properties`\n\n`type Concrete<Type> = {`\n\n  `[Property in keyof Type]-?: Type[Property];`\n\n`};`\n\n`type MaybeUser = {`\n\n  `id: string;`\n\n  `name?: string;`\n\n  `age?: number;`\n\n`};`\n\n`type User = Concrete<MaybeUser>;`\n\n      `type User = {     id: string;     name: string;     age: number; }`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHJYAcAuBLWA7AQwBtVRCssAnHAIwFctlQAzK2ac0LATw0lQoM7flVzIAUL36gAwgQDGVSEwA8AFT6QAfKAC8oAN4TQoANoAFEZDE9QOfKADWkHrBahN-ALoBaAPwAXJ5alta23gDcEgC+0VJaoACyhDy0kACqSDb6Rib2ACbBSNQOAObRpkTQkEGgJTT4FfmEZbXB+PTQ6VTRcRIJMlk5BvL4SiqQqilpmdlU2tEgpqAAev5AA)\n\n## [](#key-remapping-via-as)Key Remapping via `as`\n\nIn TypeScript 4.1 and onwards, you can re-map keys in mapped types with an `as` clause in a mapped type:\n\nts\n\n`type MappedTypeWithNewProperties<Type> = {`\n\n    `[Properties in keyof Type as NewKeyType]: Type[Properties]`\n\n`}`\n\nYou can leverage features like [template literal types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html) to create new property names from prior ones:\n\nts\n\n`type Getters<Type> = {`\n\n    ``[Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]``\n\n`};`\n\n`interface Person {`\n\n    `name: string;`\n\n    `age: number;`\n\n    `location: string;`\n\n`}`\n\n`type LazyPerson = Getters<Person>;`\n\n         `type LazyPerson = {     getName: () => string;     getAge: () => number;     getLocation: () => string; }`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hzAgJwM4B4Aq4ID4oF4oBvAKCnKgG0AFJAe0iVCgEsA7KAawhDoDMoWSFACGKKAAMA5vAAkRAMIiwLYCIA2LAF4Q0KYEnZSoAMii0GyUDgC+EgLoAuKAAoAlATxCINeo1D2JDYA3CQk7IhIfCIAxtDUyCh0HKQUUGwiALYQzvqGbFKhaSIyzmwArpkARshFFOp0MSLALMm5BkahNmGgwgAyIlogCajJBLDwkegjSWw4oQD0CxQAegD8QA)\n\nYou can filter out keys by producing `never` via a conditional type:\n\nts\n\n`// Remove the 'kind' property`\n\n`type RemoveKindField<Type> = {`\n\n    `[Property in keyof Type as Exclude<Property, \"kind\">]: Type[Property]`\n\n`};`\n\n`interface Circle {`\n\n    `kind: \"circle\";`\n\n    `radius: number;`\n\n`}`\n\n`type KindlessCircle = RemoveKindField<Circle>;`\n\n           `type KindlessCircle = {     radius: number; }`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdKgC4AskHIDWBLAdgCYagAOATrCZGcgJ4BQdVEMCkA0vgQGI6QA2BADwAVWlQB8oALygA3vVBLQAbQAKFKjVqh8oLJFqwAZqDHMAhgGdQAUQAeAY34BXApCEbK1OgBpQAES4hAESALoAXGbikOqaPrRh9AC+ANz09PjI1MYWjkgAwjhkzkgKyvpcUQGOxaUB6RVkFgQ4LlZReC7QAEbU6ckZTEichPyQVlZFJeMyLHCIozx8gkLTpRLpIMoAegD8QA)\n\nYou can map over arbitrary unions, not just unions of `string | number | symbol`, but unions of any type:\n\nts\n\n`type EventConfig<Events extends { kind: string }> = {`\n\n    `[E in Events as E[\"kind\"]]: (event: E) => void;`\n\n`}`\n\n`type SquareEvent = { kind: \"square\", x: number, y: number };`\n\n`type CircleEvent = { kind: \"circle\", radius: number };`\n\n`type Config = EventConfig<SquareEvent | CircleEvent>`\n\n       `type Config = {     square: (event: SquareEvent) => void;     circle: (event: CircleEvent) => void; }`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogbhAdsAwge0QMwJYHMA88SwAzlBAB7BIAmZA3lANbaI0BcUJwATq7lAC+APigBeKPQBQUWVADaMKK1gJkZAIZkY8gEQs2ugLpHOACghrgnGAEpxouGmw0A3FMFSpoSFADKAI4Arho8EETI4pLMrBxQuiTBoRC6ADRQFJyIQQC2AEYQPOkgWbkFPELuPtAo2DwAxgA24VZRjAZxuvV1TSnpPBo02EEkpfmFlV7VUOhYeFERqBg4BIEhYYtQAD4zPc2LwlIA9EdyAHoA-EA)\n\n### [](#further-exploration)Further Exploration\n\nMapped types work well with other features in this type manipulation section, for example here is [a mapped type using a conditional type](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) which returns either a `true` or `false` depending on whether an object has the property `pii` set to the literal `true`:\n\nts\n\n`type ExtractPII<Type> = {`\n\n  `[Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;`\n\n`};`\n\n`type DBFields = {`\n\n  `id: { format: \"incrementing\" };`\n\n  `name: { type: string; pii: true };`\n\n`};`\n\n`type ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;`\n\n                 `type ObjectsNeedingGDPRDeletion = {     id: false;     name: true; }`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogHsATgQwMbAAoEksB4Aq4EAfFALxQDeAUFFANoaID2kioUAlgHZQDWEEMwBmUQpAC6ALjFFGLNqAlQICCNwAmAZypQwnTjKQBXaAF8oAfignoM4cgA2WiAG5qZ99VCQoAEQAhADFOCEdtcipaLg0ZSihhZkQAW2RgGQAiHlRECGT1YB4AcwyoT2juZHy4myIZLSRi1z0DI0RTMvdy7yIoAHkAIwArCHQtADkICA1igHE-DAAlPzCIQuZeCngkNEwcXECQsO1idwB6M7ooAD1LIA)",
    "title": "TypeScript: Documentation - Mapped Types",
    "description": "Generating types by re-using an existing type.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html",
    "markdown": "# TypeScript: Documentation - Modules - Choosing Compiler Options\n\n## [](#im-writing-an-app)I’m writing an app\n\nA single tsconfig.json can only represent a single environment, both in terms of what globals are available and in terms of how modules behave. If your app contains server code, DOM code, web worker code, test code, and code to be shared by all of those, each of those should have its own tsconfig.json, connected with [project references](https://www.typescriptlang.org/docs/handbook/project-references.html#handbook-content). Then, use this guide once for each tsconfig.json. For library-like projects within an app, especially ones that need to run in multiple runtime environments, use the “[I’m writing a library](#im-writing-a-library)” section.\n\n### [](#im-using-a-bundler)I’m using a bundler\n\nIn addition to adopting the following settings, it’s also recommended _not_ to set `{ \"type\": \"module\" }` or use `.mts` files in bundler projects for now. [Some bundlers](https://andrewbranch.github.io/interop-test/#synthesizing-default-exports-for-cjs-modules) adopt different ESM/CJS interop behavior under these circumstances, which TypeScript cannot currently analyze with `\"moduleResolution\": \"bundler\"`. See [issue #54102](https://github.com/microsoft/TypeScript/issues/54102) for more information.\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `// This is not a complete template; it only`\n\n    `// shows relevant module-related settings.`\n\n    `// Be sure to set other important options`\n\n    ``// like `target`, `lib`, and `strict`.``\n\n    `// Required`\n\n    `\"module\": \"esnext\",`\n\n    `\"moduleResolution\": \"bundler\",`\n\n    `\"esModuleInterop\": true,`\n\n    `// Consult your bundler’s documentation`\n\n    `\"customConditions\": [\"module\"],`\n\n    `// Recommended`\n\n    `` \"noEmit\": true, // or `emitDeclarationOnly` ``\n\n    `\"allowImportingTsExtensions\": true,`\n\n    `\"allowArbitraryExtensions\": true,`\n\n    `` \"verbatimModuleSyntax\": true, // or `isolatedModules` ``\n\n  `}`\n\n`}`\n\n### [](#im-compiling-and-running-the-outputs-in-nodejs)I’m compiling and running the outputs in Node.js\n\nRemember to set `\"type\": \"module\"` or use `.mts` files if you intend to emit ES modules.\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `// This is not a complete template; it only`\n\n    `// shows relevant module-related settings.`\n\n    `// Be sure to set other important options`\n\n    ``// like `target`, `lib`, and `strict`.``\n\n    `// Required`\n\n    `\"module\": \"nodenext\",`\n\n    ``// Implied by `\"module\": \"nodenext\"`:``\n\n    `// \"moduleResolution\": \"nodenext\",`\n\n    `// \"esModuleInterop\": true,`\n\n    `// \"target\": \"esnext\",`\n\n    `// Recommended`\n\n    `\"verbatimModuleSyntax\": true,`\n\n  `}`\n\n`}`\n\n### [](#im-using-ts-node)I’m using ts-node\n\nts-node attempts to be compatible with the same code and the same tsconfig.json settings that can be used to [compile and run the JS outputs in Node.js](#im-compiling-and-running-the-outputs-in-node). Refer to [ts-node documentation](https://typestrong.org/ts-node/) for more details.\n\n### [](#im-using-tsx)I’m using tsx\n\nWhereas ts-node makes minimal modifications to Node.js’s module system by default, [tsx](https://github.com/esbuild-kit/tsx) behaves more like a bundler, allowing extensionless/index module specifiers and arbitrary mixing of ESM and CJS. Use the same settings for tsx as you [would for a bundler](#im-using-a-bundler).\n\n### [](#im-writing-es-modules-for-the-browser-with-no-bundler-or-module-compiler)I’m writing ES modules for the browser, with no bundler or module compiler\n\nTypeScript does not currently have options dedicated to this scenario, but you can approximate them by using a combination of the `nodenext` ESM module resolution algorithm and `paths` as a substitute for URL and import map support.\n\njson\n\n`// tsconfig.json`\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `// This is not a complete template; it only`\n\n    `// shows relevant module-related settings.`\n\n    `// Be sure to set other important options`\n\n    ``// like `target`, `lib`, and `strict`.``\n\n    ``// Combined with `\"type\": \"module\"` in a local package.json,``\n\n    `// this enforces including file extensions on relative path imports.`\n\n    `\"module\": \"nodenext\",`\n\n    `\"paths\": {`\n\n      `// Point TS to local types for remote URLs:`\n\n      `\"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"],`\n\n      `// Optional: point bare specifier imports to an empty file`\n\n      `// to prohibit importing from node_modules specifiers not listed here:`\n\n      `\"*\": [\"./empty-file.ts\"]`\n\n    `}`\n\n  `}`\n\n`}`\n\nThis setup allows explicitly listed HTTPS imports to use locally-installed type declaration files, while erroring on imports that would normally resolve in node\\_modules:\n\nts\n\n`import {} from \"lodash\";`\n\n`//             ^^^^^^^^`\n\n`// File '/project/empty-file.ts' is not a module. ts(2306)`\n\nAlternatively, you can use [import maps](https://github.com/WICG/import-maps) to explicitly map a list of bare specifiers to URLs in the browser, while relying on `nodenext`’s default node\\_modules lookups, or on `paths`, to direct TypeScript to type declaration files for those bare specifier imports:\n\nhtml\n\n`<script type=\"importmap\">`\n\n`{`\n\n  `\"imports\": {`\n\n    `\"lodash\": \"https://esm.sh/lodash@4.17.21\"`\n\n  `}`\n\n`}`\n\n`</script>`\n\nts\n\n`import {} from \"lodash\";`\n\n`// Browser: https://esm.sh/lodash@4.17.21`\n\n`// TypeScript: ./node_modules/@types/lodash/index.d.ts`\n\n## [](#im-writing-a-library)I’m writing a library\n\nChoosing compilation settings as a library author is a fundamentally different process from choosing settings as an app author. When writing an app, settings are chosen that reflect the runtime environment or bundler—typically a single entity with known behavior. When writing a library, you would ideally check your code under _all possible_ library consumer compilation settings. Since this is impractical, you can instead use the strictest possible settings, since satisfying those tends to satisfy all others.\n\njson\n\n`{`\n\n  `\"compilerOptions\": {`\n\n    `\"module\": \"node16\",`\n\n    `\"target\": \"es2020\", // set to the *lowest* target you support`\n\n    `\"strict\": true,`\n\n    `\"verbatimModuleSyntax\": true,`\n\n    `\"declaration\": true,`\n\n    `\"sourceMap\": true,`\n\n    `\"declarationMap\": true`\n\n  `}`\n\n`}`\n\nLet’s examine why we picked each of these settings:\n\n*   **`module: \"node16\"`**. When a codebase is compatible with Node.js’s module system, it almost always works in bundlers as well. If you’re using a third-party emitter to emit ESM outputs, ensure that you set `\"type\": \"module\"` in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let’s look at what would happen if a library were to compile with `\"moduleResolution\": \"bundler\"`:\n    \n    ts\n    \n    `export * from \"./utils\";`\n    \n    Assuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine with this code, so `\"moduleResolution\": \"bundler\"` doesn’t complain. Compiled with `\"module\": \"esnext\"`, the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n    \n    `Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js`\n    \n    `Did you mean to import ./utils.js?`\n    \n    On the other hand, if we had written:\n    \n    ts\n    \n    `export * from \"./utils.js\";`\n    \n    This would produce output that works both in Node.js _and_ in bundlers.\n    \n    In short, `\"moduleResolution\": \"bundler\"` is infectious, allowing code that only works in bundlers to be produced. Likewise, `\"moduleResolution\": \"nodenext\"` is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n    \n*   **`target: \"es2020\"`**. Setting this value to the _lowest_ ECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Since `target` also implies a corresponding value for `lib`, this also ensures you don’t access globals that may not be available in older environments.\n    \n*   **`strict: true`**. Without this, you may write type-level code that ends up in your output `.d.ts` files and errors when a consumer compiles with `strict` enabled. For example, this `extends` clause:\n    \n    ts\n    \n    `export interface Super {`\n    \n      `foo: string;`\n    \n    `}`\n    \n    `export interface Sub extends Super {`\n    \n      `foo: string | undefined;`\n    \n    `}`\n    \n    is only an error under `strictNullChecks`. On the other hand, it’s very difficult to write code that errors only when `strict` is _disabled_, so it’s highly recommended for libraries to compile with `strict`.\n    \n*   **`verbatimModuleSyntax: true`**. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user’s value of `esModuleInterop` or `allowSyntheticDefaultImports`. Previously, it was often suggested that libraries compile without `esModuleInterop`, since its use in libraries could force users to adopt it too. However, it’s also possible to write imports that only work _without_ `esModuleInterop`, so neither value for the setting guarantees portability for libraries. `verbatimModuleSyntax` does provide such a guarantee.[1](#fn-1) Second, it prevents the use of `export default` in modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix on [ESM/CJS Interop](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#library-code-needs-special-considerations) for more details.\n    \n*   **`declaration: true`** emits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information.\n    \n*   **`sourceMap: true`** and **`declarationMap: true`** emit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (`.ts`) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it’s up to you whether to include them.\n    \n\n### [](#considerations-for-bundling-libraries)Considerations for bundling libraries\n\nIf you’re using a bundler to emit your library, then all your (non-externalized) imports will be processed by the bundler with known behavior, not by your users’ unknowable environments. In this case, you can use `\"module\": \"esnext\"` and `\"moduleResolution\": \"bundler\"`, but only with two caveats:\n\n1.  TypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it’s common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user’s environment. To model this in TypeScript, you would want to process bundled imports with `\"moduleResolution\": \"bundler\"` and externalized imports with `\"moduleResolution\": \"nodenext\"` (or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using `\"moduleResolution\": \"bundler\"` may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using `\"moduleResolution\": \"nodenext\"` may impose overly strict requirements on bundled imports.\n    \n2.  You must ensure that your declaration files get bundled as well. Recall the [first rule of declaration files](https://www.typescriptlang.org/docs/handbook/modules/theory.html#the-role-of-declaration-files): every declaration file represents exactly one JavaScript file. If you use `\"moduleResolution\": \"bundler\"` and use a bundler to emit an ESM bundle while using `tsc` to emit many individual declaration files, your declaration files may cause errors when consumed under `\"module\": \"nodenext\"`. For example, an input file like:\n    \n    ts\n    \n    `import { Component } from \"./extensionless-relative-import\";`\n    \n    will have its import erased by the JS bundler, but produce a declaration file with an identical import statement. That import statement, however, will contain an invalid module specifier in Node.js, since it’s missing a file extension. For Node.js users, TypeScript will error on the declaration file and infect types referencing `Component` with `any`, assuming the dependency will crash at runtime.\n    \n    If your TypeScript bundler does not produce bundled declaration files, use `\"moduleResolution\": \"nodenext\"` to ensure that the imports preserved in your declaration files will be compatible with end-users’ TypeScript settings. Even better, consider not bundling your library.\n    \n\n### [](#notes-on-dual-emit-solutions)Notes on dual-emit solutions\n\nA single TypeScript compilation (whether emitting or just type checking) assumes that each input file will only produce one output file. Even if `tsc` isn’t emitting anything, the type checking it performs on imported names rely on knowledge about how the output file will behave at runtime, based on the module- and emit-related options set in the tsconfig.json. While third-party emitters are generally safe to use in combination with `tsc` type checking as long as `tsc` can be configured to understand what the other emitter will emit, any solution that emits two different sets of outputs with different module formats while only type checking once leaves (at least) one of the outputs unchecked. Because external dependencies may expose different APIs to CommonJS and ESM consumers, there’s no configuration you can use to guarantee in a single compilation that both outputs will be type-safe. In practice, most dependencies follow best practices and dual-emit outputs work. Running tests and [static analysis](https://npmjs.com/package/@arethetypeswrong/cli) against all output bundles before publishing significantly reduces the chance of a serious problem going unnoticed.",
    "title": "TypeScript: Documentation - Modules - Choosing Compiler Options",
    "description": "How to choose compiler options that reflect your module environment",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html",
    "markdown": "# TypeScript: Documentation - Template Literal Types\n\nTemplate literal types build on [string literal types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types), and have the ability to expand into many strings via unions.\n\nThey have the same syntax as [template literal strings in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), but are used in type positions. When used with concrete literal types, a template literal produces a new string literal type by concatenating the contents.\n\nts\n\n`type World = \"world\";`\n\n``type Greeting = `hello ${World}`;``\n\n        `type Greeting = \"hello world\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6g9gJwDYBMoF4oCIDujVYDcAUMaJFAOIIQTACWAdgOYZQAGAFhEknFABIA3vGQoAvuxIB6aVHkA9APxA)\n\nWhen a union is used in the interpolated position, the type is the set of every possible string literal that could be represented by each union member:\n\nts\n\n`type EmailLocaleIDs = \"welcome_email\" | \"email_heading\";`\n\n`type FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\";`\n\n``type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;``\n\n          `type AllLocaleIDs = \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnzF4aAEEUdGxcAhJyKAADABIAb3h+XVCDblVHHRD9EgBfZiRRSIUAeiKoMoA9AH4gA)\n\nFor each interpolated position in the template literal, the unions are cross multiplied:\n\nts\n\n``type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;``\n\n`type Lang = \"en\" | \"ja\" | \"pt\";`\n\n``type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;``\n\n            `type LocaleMessageIDs = \"en_welcome_email_id\" | \"en_email_heading_id\" | \"en_footer_title_id\" | \"en_footer_sendoff_id\" | \"ja_welcome_email_id\" | \"ja_email_heading_id\" | \"ja_footer_title_id\" | \"ja_footer_sendoff_id\" | \"pt_welcome_email_id\" | \"pt_email_heading_id\" | \"pt_footer_title_id\" | \"pt_footer_sendoff_id\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnyA9D6gAtEFYAK7AQQGK4NAAgijo2LgEJORQAAYAJADe8Py6SQbcqo46ifokAL7MSKJpCkrQaAjSqZSudlQAVggdlGDA3lHK+XgAshDExAhSyYbp2U3SVdlxCXqzFXW+-lBQAHoA-EA)\n\nWe generally recommend that people use ahead-of-time generation for large string unions, but this is useful in smaller cases.\n\n### [](#string-unions-in-types)String Unions in Types\n\nThe power in template literals comes when defining a new string based on information inside a type.\n\nConsider the case where a function (`makeWatchedObject`) adds a new function called `on()` to a passed object. In JavaScript, its call might look like: `makeWatchedObject(baseObject)`. We can imagine the base object as looking like:\n\nts\n\n`const passedObject = {`\n\n  `firstName: \"Saoirse\",`\n\n  `lastName: \"Ronan\",`\n\n  `age: 26,`\n\n`};`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AA4CGKKApgCYDyARgFZkb4C8oA3mqKAGYCWquAHJEAtmQBcoAEQBlItH7kpAGk6gANiSGiJ0gErYikFWqIBzXQCYAbKoC+AbiA)\n\nThe `on` function that will be added to the base object expects two arguments, an `eventName` (a `string`) and a `callback` (a `function`).\n\nThe `eventName` should be of the form `attributeInThePassedObject + \"Changed\"`; thus, `firstNameChanged` as derived from the attribute `firstName` in the base object.\n\nThe `callback` function, when called:\n\n*   Should be passed a value of the type associated with the name `attributeInThePassedObject`; thus, since `firstName` is typed as `string`, the callback for the `firstNameChanged` event expects a `string` to be passed to it at call time. Similarly events associated with `age` should expect to be called with a `number` argument\n*   Should have `void` return type (for simplicity of demonstration)\n\nThe naive function signature of `on()` might thus be: `on(eventName: string, callback: (newValue: any) => void)`. However, in the preceding description, we identified important type constraints that we’d like to document in our code. Template Literal types let us bring these constraints into our code.\n\nts\n\n`const person = makeWatchedObject({`\n\n  `firstName: \"Saoirse\",`\n\n  `lastName: \"Ronan\",`\n\n  `age: 26,`\n\n`});`\n\n``// makeWatchedObject has added `on` to the anonymous Object``\n\n`person.on(\"firstNameChanged\", (newValue) => {`\n\n  ``console.log(`firstName was changed to ${newValue}!`);``\n\n`});`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABMCmBjANgIbxagBmArpDgC4CW0koAtgQNZYDqB1OAFlhgDyAIwBWuagApoYgFygCkAJ4BKeYqUBuNCFABaAznLUDetDgYpqoAA5ZUDUAF5mbTtz4CR4mpIDeaKBktKjUAHIETFjyAEQAygTQIShYMQA0gaCEVhFRsQBKDIrpmQQA5tGgAEwAbBkAviraOmAs7Fw8-EJiEqC8BCgKGNgYoAAGDGOg1NDT-AowykzQ5IPeEmhodg6QAHQMkjGkyeGRWADC-ZAVGOmgkpBYAO4AagR45FgqzgB8oAFBCyQFDQPBYXZ4aBlSRjY6hXIkJ4DUB8RQ3aazAAkfker3en3qAEIxk00I1NEA)\n\nNotice that `on` listens on the event `\"firstNameChanged\"`, not just `\"firstName\"`. Our naive specification of `on()` could be made more robust if we were to ensure that the set of eligible event names was constrained by the union of attribute names in the watched object with “Changed” added at the end. While we are comfortable with doing such a calculation in JavaScript i.e. ``Object.keys(passedObject).map(x => `${x}Changed`)``, template literals _inside the type system_ provide a similar approach to string manipulation:\n\nts\n\n`type PropEventSource<Type> = {`\n\n    ``on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;``\n\n`};`\n\n``/// Create a \"watched object\" with an `on` method``\n\n`/// so that you can watch for changes to properties.`\n\n`declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGAFBOlgHIBDALYQAXFAAGAEgYBnYHACWGAOZQAZFADWEEAgBmUCpAC+AYQAWA1RAAmEgDRRCAgDauARgMJbxnDBAA7gBqbnhiUNYgAJR0NKgIirbR4glJANxMJplMAPT5UGZwEALA0AJQAESBpYQWduweAFYQhMCVUIGKwBaRGJIcElAiPQi2eQWyCFA9pVB6eM7WnbW9+ghwzlY2sjPTYIiQcMCKELIAdEy2ra4CxVD6eBhtihzDAjoA6qt2APLNrWA5EoVE4CGa4mMEBSRkoGlghzQmBw+CIpChVHSQA)\n\nWith this, we can build something that errors when given the wrong property:\n\nts\n\n`const person = makeWatchedObject({`\n\n  `firstName: \"Saoirse\",`\n\n  `lastName: \"Ronan\",`\n\n  `age: 26`\n\n`});`\n\n`person.on(\"firstNameChanged\", () => {});`\n\n`// Prevent easy human error (using the key instead of the event name)`\n\n`person.on(\"firstName\", () => {});`\n\n`Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.2345Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.  // It's typo-resistant  person.on(\"frstNameChanged\", () => {});  Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.2345Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAArwkCiAbpAHYEDKcArtAMaQA8AKqUgA+UAF5QAbzyhZoOIwAUkBswByAQwC2kVAAMAJJMQFoAS0YBzUADJQAa0hE4AM1CCyAXwDCACw1WkAAmegA0oFwaADZRAEYaXPaoioyQAO4AatHsuqABRACU4qJ0cGZBBail5QDceJ51eEGQXFEa0OQu7IxcBGYKoFoajgDqGgRcvsEA8rEAVi0EAsKKcPOo-JXutpTU9EysHNx8-MJ1IKAAtNdc7ATXl3hcCiagZEgDEkOj45Mz84tFNJZC4zEgCJodKgAEQsDRlJCQaGhGSgNomSG5aEAJQUAWRqI0llyaAAbPUCo13ogFAA6BSKaGg8GYvwBYlBZGgRRFMSiSSeSl4PAXKgqA6gSAaRBEUC+dhDRiS2AIbnsRAWawEKYOJygCwmKVBeRubXkcXMUCMbSQAp4al0hlMsEYm1cnnFKSCxoXACSBAA5IhQMQSHBLh0NSYAgR7TAaYx6UomSybWzApzwh6+V7KUA)\n\n### [](#inference-with-template-literals)Inference with Template Literals\n\nNotice that we did not benefit from all the information provided in the original passed object. Given change of a `firstName` (i.e. a `firstNameChanged` event), we should expect that the callback will receive an argument of type `string`. Similarly, the callback for a change to `age` should receive a `number` argument. We’re naively using `any` to type the `callback`’s argument. Again, template literal types make it possible to ensure an attribute’s data type will be the same type as that attribute’s callback’s first argument.\n\nThe key insight that makes this possible is this: we can use a function with a generic such that:\n\n1.  The literal used in the first argument is captured as a literal type\n2.  That literal type can be validated as being in the union of valid attributes in the generic\n3.  The type of the validated attribute can be looked up in the generic’s structure using Indexed Access\n4.  This typing information can _then_ be applied to ensure the argument to the callback function is of the same type\n\nts\n\n`type PropEventSource<Type> = {`\n\n    `on<Key extends string & keyof Type>`\n\n        ``(eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void): void;``\n\n`};`\n\n`declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;`\n\n`const person = makeWatchedObject({`\n\n  `firstName: \"Saoirse\",`\n\n  `lastName: \"Ronan\",`\n\n  `age: 26`\n\n`});`\n\n`person.on(\"firstNameChanged\", newName => {`\n\n                                `(parameter) newName: string`\n\n    ``console.log(`new name is ${newName.toUpperCase()}`);``\n\n`});`\n\n`person.on(\"ageChanged\", newAge => {`\n\n                          `(parameter) newAge: number`\n\n    `if (newAge < 0) {`\n\n        `console.warn(\"warning! negative age\");`\n\n    `}`\n\n`})`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGJA0hCFBAA9gmACYBnKGOBwAlhgDmUAGRQA1rwQAzKBUhUWbQwAoI6LADkAhgFsIALigADACQMeIAL4BhABaWFECKOADRQhJYANhEARpaEqg5GGBAA7gBqkXj2OpQA2u4AugCUdDSoCDIiRQ7llQDcTB4NTCIQhBGWcNCaeBiEwDIcUNaW6gDqlsCEPoEA8tEAVm3A5JRURgiLDroQ1TmQyrCIKGY4+ESkO1TNhBxSUJBwYkP0I+OT03OLy0bMrJoyJ7AKy2BwAImwlgqTwgYOCBg6UhB2TBACUOP44QZLPJsgAmABsjSKzUezwwADoOEYwQCgcjfP5cSI4VBkilkaVGAZWAB6XmGQVC4WsAB6AH4eWE7ggIhAKREEPIjI52WybNAZBJXOzkRTgAgAKpgR5eSxiCBGIoeRwk4mkiBPDhUjA0nEQRkBFmhdkAQVxXL+bH5ItDUAlUpk2iSqX90BIUAADCUg0LbhhnnKKSlOq6wTm4Bg5PIAIRsiDySYydBQd1gu2GDzEoA)\n\nHere we made `on` into a generic method.\n\nWhen a user calls with the string `\"firstNameChanged\"`, TypeScript will try to infer the right type for `Key`. To do that, it will match `Key` against the content before `\"Changed\"` and infer the string `\"firstName\"`. Once TypeScript figures that out, the `on` method can fetch the type of `firstName` on the original object, which is `string` in this case. Similarly, when called with `\"ageChanged\"`, TypeScript finds the type for the property `age` which is `number`.\n\nInference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways.\n\n## [](#intrinsic-string-manipulation-types)Intrinsic String Manipulation Types\n\nTo help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and can’t be found in the `.d.ts` files included with TypeScript.\n\n### [](#uppercasestringtype)`Uppercase<StringType>`\n\nConverts each character in the string to the uppercase version.\n\n##### [](#example)Example\n\nts\n\n`type Greeting = \"Hello, world\"`\n\n`type ShoutyGreeting = Uppercase<Greeting>`\n\n           `type ShoutyGreeting = \"HELLO, WORLD\"`\n\n`` type ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}` ``\n\n`type MainID = ASCIICacheKey<\"my_app\">`\n\n       `type MainID = \"ID-MY_APP\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigGUALUgV1HkQoM2KAFUwkOAGMAhgGcIAHgFI06AHxMA9Fqh6AegH4mLcNACC7AMIBJG1ZlTOEANIQQi9sDhQIAD2AIVHo5KDlvNXURAAMbABEAWgASAG9xSVkFT291AF9o0zYAWRk0eJFLW3tHZzcPXABbEAB9GQlcTR09KCMgA)\n\n### [](#lowercasestringtype)`Lowercase<StringType>`\n\nConverts each character in the string to the lowercase equivalent.\n\n##### [](#example-1)Example\n\nts\n\n`type Greeting = \"Hello, world\"`\n\n`type QuietGreeting = Lowercase<Greeting>`\n\n          `type QuietGreeting = \"hello, world\"`\n\n`` type ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}` ``\n\n`type MainID = ASCIICacheKey<\"MY_APP\">`\n\n       `type MainID = \"id-my_app\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigEUBXZJeRFDNigAZUlQhwAxgEMAzhAA8fJGnQA+JgHpNUXQD0A-ExbhoAQQDKAYQCSNq9MkALCAGkIIBReBwoEAB7AEKj0slCyPqpqQgAGyPQAtAAkAN6i4lJyit5wagC+MSZsALLSaDYAIkKWtvaOLu6euMUAmgD6ZgAKnbga2rpQhkA)\n\n### [](#capitalizestringtype)`Capitalize<StringType>`\n\nConverts the first character in the string to an uppercase equivalent.\n\n##### [](#example-2)Example\n\nts\n\n`type LowercaseGreeting = \"hello, world\";`\n\n`type Greeting = Capitalize<LowercaseGreeting>;`\n\n        `type Greeting = \"Hello, world\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAMg9gdwgJwMYEMDOEDiyITACWAdgOZQC8UARABYQA2jcANFAnMowCY0DcAKFCQoeAsXJUoAYXRgiwdIyIAvCAB54SNFlz5CpMgD4hAejNQrAPQD8QA)\n\n### [](#uncapitalizestringtype)`Uncapitalize<StringType>`\n\nConverts the first character in the string to a lowercase equivalent.\n\n##### [](#example-3)Example\n\nts\n\n`type UppercaseGreeting = \"HELLO WORLD\";`\n\n`type UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;`\n\n              `type UncomfortableGreeting = \"hELLO WORLD\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAqmkCcDGBDAzhA4giFgEsA7AcygF4oAiACQFEAZegeSgHUmAlegEUoG4AUKEixCSAPYBbAGbiEwFACMANlhx4ipCjDEow+BcvwAvCAB44iVBmy4CJAHyCA9M6juAegH4gA)\n\nTechnical details on the intrinsic string manipulation types\n\nThe code, as of TypeScript 4.1, for these intrinsic functions uses the JavaScript string runtime functions directly for manipulation and are not locale aware.\n\n`   function applyStringMapping(symbol: Symbol, str: string) {     switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {         case IntrinsicTypeKind.Uppercase: return str.toUpperCase();         case IntrinsicTypeKind.Lowercase: return str.toLowerCase();         case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);         case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);     }     return str; }   `",
    "title": "TypeScript: Documentation - Template Literal Types",
    "description": "Generating mapping types which change properties via template literal strings.",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-1.html",
    "markdown": "# TypeScript: Documentation - TypeScript 1.1\n\n## [](#performance-improvements)Performance Improvements\n\nThe 1.1 compiler is typically around 4x faster than any previous release. See [this blog post for some impressive charts.](https://web.archive.org/web/20141007020020/http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx)\n\n## [](#better-module-visibility-rules)Better Module Visibility Rules\n\nTypeScript now only strictly enforces the visibility of types in modules if the [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) flag is provided. This is very useful for Angular scenarios, for example:\n\nts\n\n`module MyControllers {`\n\n  `interface ZooScope extends ng.IScope {`\n\n    `animals: Animal[];`\n\n  `}`\n\n  `export class ZooController {`\n\n    `// Used to be an error (cannot expose ZooScope), but now is only`\n\n    `// an error when trying to generate .d.ts files`\n\n    `constructor(public $scope: ZooScope) {}`\n\n    `/* more code */`\n\n  `}`\n\n`}`\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%201.1.md) ❤\n\nContributors to this page:\n\nLast updated: Jul 11, 2024",
    "title": "TypeScript: Documentation - TypeScript 1.1",
    "description": "TypeScript 1.1 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html",
    "markdown": "# TypeScript: Documentation - Modules - ESM/CJS Interoperability\n\nIt’s 2015, and you’re writing an ESM-to-CJS transpiler. There’s no specification for how to do this; all you have is a specification of how ES modules are supposed to interact with each other, knowledge of how CommonJS modules interact with each other, and a knack for figuring things out. Consider an exporting ES module:\n\nts\n\n`export const A = {};`\n\n`export const B = {};`\n\n`export default \"Hello, world!\";`\n\nHow would you turn this into a CommonJS module? Recalling that default exports are just named exports with special syntax, there seems to be only one choice:\n\nts\n\n`exports.A = {};`\n\n`exports.B = {};`\n\n`exports.default = \"Hello, world!\";`\n\nThis is a nice analog, and it lets you implement a similar on the importing side:\n\nts\n\n`import hello, { A, B } from \"./module\";`\n\n`console.log(hello, A, B);`\n\n`// transpiles to:`\n\n`const module_1 = require(\"./module\");`\n\n`console.log(module_1.default, module_1.A, module_1.B);`\n\nSo far, everything in CJS-world matches up one-to-one with everything in ESM-world. Extending the equivalence above one step further, we can see that we also have:\n\nts\n\n`import * as mod from \"./module\";`\n\n`console.log(mod.default, mod.A, mod.B);`\n\n`// transpiles to:`\n\n`const mod = require(\"./module\");`\n\n`console.log(mod.default, mod.A, mod.B);`\n\nYou might notice that in this scheme, there’s no way to write an ESM export that produces an output where `exports` is assigned a function, class, or primitive:\n\nts\n\n`// @Filename: exports-function.js`\n\n`module.exports = function hello() {`\n\n  `console.log(\"Hello, world!\");`\n\n`};`\n\nBut existing CommonJS modules frequently take this form. How might an ESM import, processed with our transpiler, access this module? We just established that a namespace import (`import *`) transpiles to a plain `require` call, so we can support an input like:\n\nts\n\n`import * as hello from \"./exports-function\";`\n\n`hello();`\n\n`// transpiles to:`\n\n`const hello = require(\"./exports-function\");`\n\n`hello();`\n\nOur output works at runtime, but we have a compliance problem: according to the JavaScript specification, a namespace import always resolves to a [_Module Namespace Object_](https://tc39.es/ecma262/#sec-module-namespace-objects), that is, an object whose members are the exports of the module. In this case, `require` would return the function `hello`, but `import *` can never return a function. The correspondence we assumed appears invalid.\n\nIt’s worth taking a step back here and clarifying what the _goal_ is. As soon as modules landed in the ES2015 specification, transpilers emerged with support for downleveling ESM to CJS, allowing users to adopt the new syntax long before runtimes implemented support for it. There was even a sense that writing ESM code was a good way to “future-proof” new projects. For this to be true, there needed to be a seamless migration path from executing the transpilers’ CJS output to executing the ESM input natively once runtimes developed support for it. The goal was to find a way to downlevel ESM to CJS that would allow any or all of those transpiled outputs to be replaced by their true ESM inputs in a future runtime, with no observable change in behavior.\n\nBy following the specification, it was easy enough for transpilers to find a set of transformations that made the semantics of their transpiled CommonJS outputs match the specified semantics of their ESM inputs (arrows represent imports):\n\n![A flowchart with two similar flows side-by-side. Left: ESM. Right: ESM transpiled to CJS. In the ESM flow: \"Importing module\" flows to \"Imported module\" through arrow labeled \"specified behavior\". In the ESM transpiled to CJS flow: \"Importing module\" flows to \"Imported module\" through arrow labeled \"designed based on spec\".](https://www.typescriptlang.org/d789cdf9a8f7f88a40e9e703e0698245/esm-cjs-interop.md-1.svg)\n\nHowever, CommonJS modules (written as CommonJS, not as ESM transpiled to CommonJS) were already well-established in the Node.js ecosystem, so it was inevitable that modules written as ESM and transpiled to CJS would start “importing” modules written as CommonJS. The behavior for this interoperability, though, was not specified by ES2015, and didn’t yet exist in any real runtime.\n\n![A flowchart with three areas side-by-side. Left: ESM. Middle: True CJS. Right: ESM transpiled to CJS. Left: ESM \"Importing module\" flows to ESM \"Imported module\" through arrow labeled \"specified behavior,\" and to True CJS \"Imported module\" through dotted arrow labeled \"unspecified behavior.\" Right: ESM transpiled to CJS \"Importing module\" flows to ESM transpiled to CJS \"Imported module\" through arrow labeled \"designed based on spec,\" and to True CJS \"Imported module\" through dotted arrow labeled \"❓🤷‍♂️❓\"](https://www.typescriptlang.org/f935787a9210481bf751b445c081f07b/esm-cjs-interop.md-2.svg)\n\nEven if transpiler authors did nothing, a behavior would emerge from the existing semantics between the `require` calls they emitted in transpiled code and the `exports` defined in existing CJS modules. And to allow users to transition seamlessly from transpiled ESM to true ESM once their runtime supported it, that behavior would have to match the one the runtime chose to implement.\n\nGuessing what interop behavior runtimes would support wasn’t limited to ESM importing “true CJS” modules either. Whether ESM would be able to recognize ESM-transpiled-from-CJS as distinct from CJS, and whether CJS would be able to `require` ES modules, were also unspecified. Even whether ESM imports would use the same module resolution algorithm as CJS `require` calls was unknowable. All these variables would have to be predicted correctly in order to give transpiler users a seamless migration path toward native ESM.\n\n## [](#allowsyntheticdefaultimports-and-esmoduleinterop)`allowSyntheticDefaultImports` and `esModuleInterop`\n\nLet’s return to our specification compliance problem, where `import *` transpiles to `require`:\n\nts\n\n`// Invalid according to the spec:`\n\n`import * as hello from \"./exports-function\";`\n\n`hello();`\n\n`// but the transpilation works:`\n\n`const hello = require(\"./exports-function\");`\n\n`hello();`\n\nWhen TypeScript first added support for writing and transpiling ES modules, the compiler addressed this problem by issuing an error on any namespace import of a module whose `exports` was not a namespace-like object:\n\nts\n\n`import * as hello from \"./exports-function\";`\n\n`// TS2497              ^^^^^^^^^^^^^^^^^^^^`\n\n`// External module '\"./exports-function\"' resolves to a non-module entity`\n\n`// and cannot be imported using this construct.`\n\nThe only workaround was for users to go back to using the older TypeScript import syntax representing a CommonJS `require`:\n\nts\n\n`import hello = require(\"./exports-function\");`\n\nForcing users to revert to non-ESM syntax was essentially an admission that “we don’t know how or if a CJS module like `\"./exports-function\"` will be accessible with ESM imports in the future, but we know it _can’t_ be with `import *`, even though it will work at runtime in the transpilation scheme we’re using.” It doesn’t meet the goal of allowing this file to be migrated to real ESM without changes, but neither does the alternative of allowing the `import *` to link to a function. This is still the behavior in TypeScript today when `allowSyntheticDefaultImports` and `esModuleInterop` are disabled.\n\n> Unfortunately, this is a slight oversimplification—TypeScript didn’t fully avoid the compliance issue with this error, because it allowed namespace imports of functions to work, and retain their call signatures, as long as the function declaration merged with a namespace declaration—even if the namespace was empty. So while a module exporting a bare function was recognized as a “non-module entity”:\n> \n> ts\n> \n> `declare function $(selector: string): any;`\n> \n> ``export = $; // Cannot `import *` this 👍``\n> \n> A should-be-meaningless change allowed the invalid import to type check without errors:\n> \n> ts\n> \n> `declare namespace $ {}`\n> \n> `declare function $(selector: string): any;`\n> \n> ``export = $; // Allowed to `import *` this and call it 😱``\n\nMeanwhile, other transpilers were coming up with a way to solve the same problem. The thought process went something like this:\n\n1.  To import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don’t make sense here.\n2.  Most likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modules _always_ link directly to the whole `exports`, rather than only doing so if the `exports` is a function or primitive.\n3.  So, a default import of a true CJS module should work just like a `require` call. But we’ll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpile `export default \"hello\"` to `exports.default = \"hello\"` and have a default import of _that_ module link to `exports.default`. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).\n4.  When we transpile an ES module to CJS, let’s add a special extra field to the output:\n    \n    ts\n    \n    `exports.A = {};`\n    \n    `exports.B = {};`\n    \n    `exports.default = \"Hello, world!\";`\n    \n    `// Extra special flag!`\n    \n    `exports.__esModule = true;`\n    \n    that we can check for when we transpile a default import:\n    \n    ts\n    \n    `// import hello from \"./module\";`\n    \n    `const _mod = require(\"./module\");`\n    \n    `const hello = _mod.__esModule ? _mod.default : _mod;`\n    \n\nThe `__esModule` flag first appeared in Traceur, then in Babel, SystemJS, and Webpack shortly after. TypeScript added the `allowSyntheticDefaultImports` in 1.8 to allow the type checker to link default imports directly to the `exports`, rather than the `exports.default`, of any module types that lacked an `export default` declaration. The flag didn’t modify how imports or exports were emitted, but it allowed default imports to reflect how other transpilers would treat them. Namely, it allowed a default import to be used to resolve to “non-module entities,” where `import *` was an error:\n\nts\n\n`// Error:`\n\n`import * as hello from \"./exports-function\";`\n\n`// Old workaround:`\n\n`import hello = require(\"./exports-function\");`\n\n``// New way, with `allowSyntheticDefaultImports`:``\n\n`import hello from \"./exports-function\";`\n\nThis was usually enough to let Babel and Webpack users write code that already worked in those systems without TypeScript complaining, but it was only a partial solution, leaving a few issues unsolved:\n\n1.  Babel and others varied their default import behavior on whether an `__esModule` property was found on the target module, but `allowSyntheticDefaultImports` only enabled a _fallback_ behavior when no default export was found in the target module’s types. This created an inconsistency if the target module had an `__esModule` flag but _no_ default export. Transpilers and bundlers would still link a default import of such a module to its `exports.default`, which would be `undefined`, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can’t be linked. But with `allowSyntheticDefaultImports`, TypeScript would think a default import of such an import links to the whole `exports` object, allowing named exports to be accessed as its properties.\n2.  `allowSyntheticDefaultImports` didn’t change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type:\n    \n    ts\n    \n    `// @Filename: exportEqualsObject.d.ts`\n    \n    `declare const obj: object;`\n    \n    `export = obj;`\n    \n    `// @Filename: main.ts`\n    \n    `import objDefault from \"./exportEqualsObject\";`\n    \n    `import * as objNamespace from \"./exportEqualsObject\";`\n    \n    `// This should be true at runtime, but TypeScript gives an error:`\n    \n    `objNamespace.default === objDefault;`\n    \n    `//           ^^^^^^^ Property 'default' does not exist on type 'typeof import(\"./exportEqualsObject\")'.`\n    \n3.  Most importantly, `allowSyntheticDefaultImports` did not change the JavaScript emitted by `tsc`. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting `--module commonjs` with `tsc` and running in Node.js. If they encountered an error with `import *`, it may have appeared as if enabling `allowSyntheticDefaultImports` would fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node.\n\nTypeScript introduced the `esModuleInterop` flag in 2.7, which refined the type checking of imports to address the remaining inconsistencies between TypeScript’s analysis and the interop behavior used in existing transpilers and bundlers, and critically, adopted the same `__esModule`\\-conditional CommonJS emit that transpilers had adopted years before. (Another new emit helper for `import *` ensured the result was always an object, with call signatures stripped, fully resolving the specification compliance issue that the aforementioned “resolves to a non-module entity” error didn’t quite sidestep.) Finally, with the new flag enabled, TypeScript’s type checking, TypeScript’s emit, and the rest of the transpiling and bundling ecosystem were in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps, plausibly adoptable by Node.\n\n## [](#interop-in-nodejs)Interop in Node.js\n\nNode.js shipped support for ES modules unflagged in v12. Like the bundlers and transpilers began doing years before, Node.js gave CommonJS modules a “synthetic default export” of their `exports` object, allowing the entire module contents to be accessed with a default import from ESM:\n\nts\n\n`// @Filename: export.cjs`\n\n`module.exports = { hello: \"world\" };`\n\n`// @Filename: import.mjs`\n\n`import greeting from \"./export.cjs\";`\n\n`greeting.hello; // \"world\"`\n\nThat’s one win for seamless migration! Unfortunately, the similarities mostly end there.\n\n### [](#no-__esmodule-detection-the-double-default-problem)No `__esModule` detection (the “double default” problem)\n\nNode.js wasn’t able to respect the `__esModule` marker to vary its default import behavior. So a transpiled module with a “default export” behaves one way when “imported” by another transpiled module, and another way when imported by a true ES module in Node.js:\n\nts\n\n`// @Filename: node_modules/dependency/index.js`\n\n`exports.__esModule = true;`\n\n`exports.default = function doSomething() { /*...*/ }`\n\n`// @Filename: transpile-vs-run-directly.{js/mjs}`\n\n`import doSomething from \"dependency\";`\n\n`// Works after transpilation, but not a function in Node.js ESM:`\n\n`doSomething();`\n\n`// Doesn't exist after trasnpilation, but works in Node.js ESM:`\n\n`doSomething.default();`\n\nWhile the transpiled default import only makes the synthetic default export if the target module lacks an `__esModule` flag, Node.js _always_ synthesizes a default export, creating a “double default” on the transpiled module.\n\n### [](#unreliable-named-exports)Unreliable named exports\n\nIn addition to making a CommonJS module’s `exports` object available as a default import, Node.js attempts to find properties of `exports` to make available as named imports. This behavior matches bundlers and transpilers when it works; however, Node.js uses [syntactic analysis](https://github.com/nodejs/cjs-module-lexer) to synthesize named exports before any code executes, whereas transpiled modules resolve their named imports at runtime. The result is that imports from CJS modules that work in transpiled modules may not work in Node.js:\n\nts\n\n`// @Filename: named-exports.cjs`\n\n`exports.hello = \"world\";`\n\n`exports[\"worl\" + \"d\"] = \"hello\";`\n\n`// @Filename: transpile-vs-run-directly.{js/mjs}`\n\n`import { hello, world } from \"./named-exports.cjs\";`\n\n``// `hello` works, but `world` is missing in Node.js 💥``\n\n`import mod from \"./named-exports.cjs\";`\n\n`mod.world;`\n\n`// Accessing properties from the default always works ✅`\n\n### [](#cannot-require-a-true-es-module)Cannot `require` a true ES module\n\nTrue CommonJS modules can `require` an ESM-transpiled-to-CJS module, since they’re both CommonJS at runtime. But in Node.js, `require` crashes if it resolves to an ES module. This means published libraries cannot migrate from transpiled modules to true ESM without breaking their CommonJS (true or transpiled) consumers:\n\nts\n\n`// @Filename: node_modules/dependency/index.js`\n\n`export function doSomething() { /* ... */ }`\n\n`// @Filename: dependent.js`\n\n`import { doSomething } from \"dependency\";`\n\n`// ✅ Works if dependent and dependency are both transpiled`\n\n`// ✅ Works if dependent and dependency are both true ESM`\n\n`// ✅ Works if dependent is true ESM and dependency is transpiled`\n\n`// 💥 Crashes if dependent is transpiled and dependency is true ESM`\n\n### [](#different-module-resolution-algorithms)Different module resolution algorithms\n\nNode.js introduced a new module resolution algorithm for resolving ESM imports that differed significantly from the long-standing algorithm for resolving `require` calls. While not directly related to interop between CJS and ES modules, this difference was one more reason why a seamless migration from transpiled modules to true ESM might not be possible:\n\nts\n\n`// @Filename: add.js`\n\n`export function add(a, b) {`\n\n  `return a + b;`\n\n`}`\n\n`// @Filename: math.js`\n\n`export * from \"./add\";`\n\n`//            ^^^^^^^`\n\n`// Works when transpiled to CJS,`\n\n`// but would have to be \"./add.js\"`\n\n`// in Node.js ESM.`\n\n## [](#conclusions)Conclusions\n\nClearly, a seamless migration from transpiled modules to ESM isn’t possible, at least in Node.js. Where does this leave us?\n\n### [](#setting-the-right-module-compiler-option-is-critical)Setting the right `module` compiler option is critical\n\nSince interoperability rules differ between hosts, TypeScript can’t offer correct checking behavior unless it understands what kind of module is represented by each file it sees, and what set of rules to apply to them. This is the purpose of the `module` compiler option. (In particular, code that is intended to run in Node.js is subject to stricter rules than code that will be processed by a bundler. The compiler’s output is not checked for Node.js compatibility unless `module` is set to `node16` or `nodenext`.)\n\n### [](#applications-with-commonjs-code-should-always-enable-esmoduleinterop)Applications with CommonJS code should always enable `esModuleInterop`\n\nIn a TypeScript _application_ (as opposed to a library that others may consume) where `tsc` is used to emit JavaScript files, whether `esModuleInterop` is enabled doesn’t have major consequences. The way you write imports for certain kinds of modules will change, but TypeScript’s checking and emit are in sync, so error-free code should be safe to run in either mode. The downside of leaving `esModuleInterop` disabled in this case is that it allows you to write JavaScript code with semantics that clearly violate the ECMAScript specification, confusing intuitions about namespace imports and making it harder to migrate to running ES modules in the future.\n\nIn an application that gets processed by a third-party transpiler or bundler, on the other hand, enabling `esModuleInterop` is more important. All major bundlers and transpilers use an `esModuleInterop`\\-like emit strategy, so TypeScript needs to adjust its checking to match. (The compiler always reasons about what will happen in the JavaScript files that `tsc` would emit, so even if another tool is being used in place of `tsc`, emit-affecting compiler options should still be set to match the output of that tool as closely as possible.)\n\n`allowSyntheticDefaultImports` without `esModuleInterop` should be avoided. It changes the compiler’s checking behavior without changing the code emitted by `tsc`, allowing potentially unsafe JavaScript to be emitted. Additionally, the checking changes it introduces are an incomplete version of the ones introduced by `esModuleInterop`. Even if `tsc` isn’t being used for emit, it’s better to enable `esModuleInterop` than `allowSyntheticDefaultImports`.\n\nSome people object to the inclusion of the `__importDefault` and `__importStar` helper functions included in `tsc`’s JavaScript output when `esModuleInterop` is enabled, either because it marginally increases the output size on disk or because the interop algorithm employed by the helpers seems to misrepresent Node.js’s interop behavior by checking for `__esModule`, leading to the hazards discussed earlier. Both of these objections can be addressed, at least partially, without accepting the flawed checking behavior exhibited with `esModuleInterop` disabled. First, the `importHelpers` compiler option can be used to import the helper functions from `tslib` rather than inlining them into each file that needs them. To discuss the second objection, let’s look at a final example:\n\nts\n\n`// @Filename: node_modules/transpiled-dependency/index.js`\n\n`exports.__esModule = true;`\n\n`exports.default = function doSomething() { /* ... */ };`\n\n`exports.something = \"something\";`\n\n`// @Filename: node_modules/true-cjs-dependency/index.js`\n\n`module.exports = function doSomethingElse() { /* ... */ };`\n\n`// @Filename: src/sayHello.ts`\n\n`export default function sayHello() { /* ... */ }`\n\n`export const hello = \"hello\";`\n\n`// @Filename: src/main.ts`\n\n`import doSomething from \"transpiled-dependency\";`\n\n`import doSomethingElse from \"true-cjs-dependency\";`\n\n`import sayHello from \"./sayHello.js\";`\n\nAssume we’re compiling `src` to CommonJS for use in Node.js. Without `allowSyntheticDefaultImports` or `esModuleInterop`, the import of `doSomethingElse` from `\"true-cjs-dependency\"` is an error, and the others are not. To fix the error without changing any compiler options, you could change the import to `import doSomethingElse = require(\"true-cjs-dependency\")`. However, depending on how the types for the module (not shown) are written, you may also be able to write and call a namespace import, which would be a language-level specification violation. With `esModuleInterop`, none of the imports shown are errors (and all are callable), but the invalid namespace import would be caught.\n\nWhat would change if we decided to migrate `src` to true ESM in Node.js (say, add `\"type\": \"module\"` to our root package.json)? The first import, `doSomething` from `\"transpiled-dependency\"`, would no longer be callable—it exhibits the “double default” problem, where we’d have to call `doSomething.default()` rather than `doSomething()`. (TypeScript understands and catches this under `--module node16` and `nodenext`.) But notably, the _second_ import of `doSomethingElse`, which needed `esModuleInterop` to work when compiling to CommonJS, works fine in true ESM.\n\nIf there’s something to complain about here, it’s not what `esModuleInterop` does with the second import. The changes it makes, both allowing the default import and preventing callable namespace imports, are exactly in line with Node.js’s real ESM/CJS interop strategy, and made migration to real ESM easier. The problem, if there is one, is that `esModuleInterop` seems to fail at giving us a seamless migration path for the _first_ import. But this problem was not introduced by enabling `esModuleInterop`; the first import was completely unaffected by it. Unfortunately, this problem cannot be solved without breaking the semantic contract between `main.ts` and `sayHello.ts`, because the CommonJS output of `sayHello.ts` looks structurally identical to `transpiled-dependency/index.js`. If `esModuleInterop` changed the way the transpiled import of `doSomething` works to be identical to the way it would work in Node.js ESM, it would change the behavior of the `sayHello` import in the same way, making the input code violate ESM semantics (thus still preventing the `src` directory from being migrated to ESM without changes).\n\nAs we’ve seen, there is no seamless migration path from transpiled modules to true ESM. But `esModuleInterop` is one step in the right direction. For those who still prefer to minimize module syntax transformations and the inclusion of the import helper functions, enabling `verbatimModuleSyntax` is a better choice than disabling `esModuleInterop`. `verbatimModuleSyntax` enforces that the `import mod = require(\"mod\")` and `export = ns` syntax be used in CommonJS-emitting files, avoiding all the kinds of import ambiguity we’ve discussed, at the cost of ease of migration to true ESM.\n\n### [](#library-code-needs-special-considerations)Library code needs special considerations\n\nLibraries that ship as CommonJS should avoid using default exports, since the way those transpiled exports can be accessed varies between different tools and runtimes, and some of those ways will look confusing to users. A default export, transpiled to CommonJS by `tsc`, is accessible in Node.js as the default property of a default import:\n\njs\n\n`import pkg from \"pkg\";`\n\n`pkg.default();`\n\nin most bundlers or transpiled ESM as the default import itself:\n\njs\n\n`import pkg from \"pkg\";`\n\n`pkg();`\n\nand in vanilla CommonJS as the default property of a `require` call:\n\njs\n\n`const pkg = require(\"pkg\");`\n\n`pkg.default();`\n\nUsers will detect a misconfigured module smell if they have to access the `.default` property of a default import, and if they’re trying to write code that will run both in Node.js and a bundler, they might be stuck. Some third-party TypeScript transpilers expose options that change the way default exports are emitted to mitigate this difference, but they don’t produce their own declaration (`.d.ts`) files, so that creates a mismatch between the runtime behavior and the type checking, further confusing and frustrating users. Instead of using default exports, libraries that need to ship as CommonJS should use `export =` for modules that have a single main export, or named exports for modules that have multiple exports:\n\ndiff\n\n`- export default function doSomething() { /* ... */ }`\n\n`+ export = function doSomething() { /* ... */ }`\n\nLibraries (that ship declaration files) should also take extra care to ensure the types they write are error-free under a wide range of compiler options. For example, it’s possible to write one interface that extends another in such a way that it only compiles successfully when `strictNullChecks` is disabled. If a library were to publish types like that, it would force all their users to disable `strictNullChecks` too. `esModuleInterop` can allow type declarations to contain similarly “infectious” default imports:\n\nts\n\n`// @Filename: /node_modules/dependency/index.d.ts`\n\n`import express from \"express\";`\n\n`declare function doSomething(req: express.Request): any;`\n\n`export = doSomething;`\n\nSuppose this default import _only_ works with `esModuleInterop` enabled, and causes an error when a user without that option references this file. The user should _probably_ enable `esModuleInterop` anyway, but it’s generally seen as bad form for libraries to make their configurations infectious like this. It would be much better for the library to ship a declaration file like:\n\nts\n\n`import express = require(\"express\");`\n\n`// ...`\n\nExamples like this have led to conventional wisdom that says libraries should _not_ enable `esModuleInterop`. This advice is a reasonable start, but we’ve looked at examples where the type of a namespace import changes, potentially _introducing_ an error, when enabling `esModuleInterop`. So whether libraries compile with or without `esModuleInterop`, they run the risk of writing syntax that makes their choice infectious.\n\nLibrary authors who want to go above and beyond to ensure maximum compatibility would do well to validate their declaration files against a matrix of compiler options. But using `verbatimModuleSyntax` completely sidesteps the issue with `esModuleInterop` by forcing CommonJS-emitting files to use CommonJS-style import and export syntax. Additionally, since `esModuleInterop` only affects CommonJS, as more libraries move to ESM-only publishing over time, the relevance of this issue will decline.",
    "title": "TypeScript: Documentation - Modules - ESM/CJS Interoperability",
    "description": "A detailed look at interoperability between ES modules and CommonJS modules",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html",
    "markdown": "# TypeScript: Documentation - Modules .d.ts\n\n## [](#comparing-javascript-to-an-example-dts)Comparing JavaScript to an example DTS\n\n## [](#common-commonjs-patterns)Common CommonJS Patterns\n\nA module using CommonJS patterns uses `module.exports` to describe the exported values. For example, here is a module which exports a function and a numerical constant:\n\njs\n\n`const maxInterval = 12;`\n\n`function getArrayLength(arr) {`\n\n  `return arr.length;`\n\n`}`\n\n`module.exports = {`\n\n  `getArrayLength,`\n\n  `maxInterval,`\n\n`};`\n\nThis can be described by the following `.d.ts`:\n\nts\n\n`export function getArrayLength(arr: any[]): number;`\n\n`export const maxInterval: 12;`\n\nThe TypeScript playground can show you the `.d.ts` equivalent for JavaScript code. You can [try it yourself here](https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA).\n\nThe `.d.ts` syntax intentionally looks like [ES Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) syntax. ES Modules was ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:\n\njs\n\n`export function getArrayLength(arr) {`\n\n  `return arr.length;`\n\n`}`\n\nThis would have the following `.d.ts` equivalent:\n\nts\n\n`export function getArrayLength(arr: any[]): number;`\n\n### [](#default-exports)Default Exports\n\nIn CommonJS you can export any value as the default export, for example here is a regular expression module:\n\njs\n\n`module.exports = /hello( world)?/;`\n\nWhich can be described by the following .d.ts:\n\nts\n\n`declare const helloWorld: RegExp;`\n\n`export default helloWorld;`\n\nOr a number:\n\njs\n\n`module.exports = 3.142;`\n\nts\n\n`declare const pi: number;`\n\n`export default pi;`\n\nOne style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added and are included in the export.\n\njs\n\n`function getArrayLength(arr) {`\n\n  `return arr.length;`\n\n`}`\n\n`getArrayLength.maxInterval = 12;`\n\n`module.exports = getArrayLength;`\n\nWhich can be described with:\n\nts\n\n`export default function getArrayLength(arr: any[]): number;`\n\n`export const maxInterval: 12;`\n\nNote that using `export default` in your .d.ts files requires [`esModuleInterop: true`](https://www.typescriptlang.org/tsconfig#esModuleInterop) to work. If you can’t have `esModuleInterop: true` in your project, such as when you’re submitting a PR to Definitely Typed, you’ll have to use the `export=` syntax instead. This older syntax is harder to use but works everywhere. Here’s how the above example would have to be written using `export=`:\n\nts\n\n`declare function getArrayLength(arr: any[]): number;`\n\n`declare namespace getArrayLength {`\n\n  `declare const maxInterval: 12;`\n\n`}`\n\n`export = getArrayLength;`\n\nSee [Module: Functions](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html) for details of how that works, and the [Modules reference](https://www.typescriptlang.org/docs/handbook/modules.html) page.\n\n## [](#handling-many-consuming-import)Handling Many Consuming Import\n\nThere are many ways to import a module in modern consuming code:\n\nts\n\n`const fastify = require(\"fastify\");`\n\n`const { fastify } = require(\"fastify\");`\n\n`import fastify = require(\"fastify\");`\n\n`import * as Fastify from \"fastify\";`\n\n`import { fastify, FastifyInstance } from \"fastify\";`\n\n`import fastify from \"fastify\";`\n\n`import fastify, { FastifyInstance } from \"fastify\";`\n\nCovering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:\n\njs\n\n`class FastifyInstance {}`\n\n`function fastify() {`\n\n  `return new FastifyInstance();`\n\n`}`\n\n`fastify.FastifyInstance = FastifyInstance;`\n\n`// Allows for { fastify }`\n\n`fastify.fastify = fastify;`\n\n`// Allows for strict ES Module support`\n\n`fastify.default = fastify;`\n\n`// Sets the default export`\n\n`module.exports = fastify;`\n\n## [](#types-in-modules)Types in Modules\n\nYou may want to provide a type for JavaScript code which does not exist\n\njs\n\n`function getArrayMetadata(arr) {`\n\n  `return {`\n\n    `length: getArrayLength(arr),`\n\n    `firstObject: arr[0],`\n\n  `};`\n\n`}`\n\n`module.exports = {`\n\n  `getArrayMetadata,`\n\n`};`\n\nThis can be described with:\n\nts\n\n`export type ArrayMetadata = {`\n\n  `length: number;`\n\n  `firstObject: any | undefined;`\n\n`};`\n\n`export function getArrayMetadata(arr: any[]): ArrayMetadata;`\n\nThis example is a good case for [using generics](https://www.typescriptlang.org/docs/handbook/generics.html#generic-types) to provide richer type information:\n\nts\n\n`export type ArrayMetadata<ArrType> = {`\n\n  `length: number;`\n\n  `firstObject: ArrType | undefined;`\n\n`};`\n\n`export function getArrayMetadata<ArrType>(`\n\n  `arr: ArrType[]`\n\n`): ArrayMetadata<ArrType>;`\n\nNow the type of the array propagates into the `ArrayMetadata` type.\n\nThe types which are exported can then be re-used by consumers of the modules using either `import` or `import type` in TypeScript code or [JSDoc imports](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types).\n\n### [](#namespaces-in-module-code)Namespaces in Module Code\n\nTrying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn’t provide enough tools to describe the exports then you can use `namespaces`.\n\nFor example, you may have complex enough types to describe that you choose to namespace them inside your `.d.ts`:\n\nts\n\n`// This represents the JavaScript class which would be available at runtime`\n\n`export class API {`\n\n  `constructor(baseURL: string);`\n\n  `getInfo(opts: API.InfoRequest): API.InfoResponse;`\n\n`}`\n\n`// This namespace is merged with the API class and allows for consumers, and this file`\n\n`// to have types which are nested away in their own sections.`\n\n`declare namespace API {`\n\n  `export interface InfoRequest {`\n\n    `id: string;`\n\n  `}`\n\n  `export interface InfoResponse {`\n\n    `width: number;`\n\n    `height: number;`\n\n  `}`\n\n`}`\n\nTo understand how namespaces work in `.d.ts` files read the [`.d.ts` deep dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html).\n\n### [](#optional-global-usage)Optional Global Usage\n\nYou can use `export as namespace` to declare that your module will be available in the global scope in UMD contexts:\n\nts\n\n`export as namespace moduleName;`\n\n## [](#reference-example)Reference Example\n\nTo give you an idea of how all these pieces can come together, here is a reference `.d.ts` to start with when making a new module\n\nts\n\n`// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]`\n\n`// Project: [~THE PROJECT NAME~]`\n\n`// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>`\n\n`/*~ This is the module template file. You should rename it to index.d.ts`\n\n `*~ and place it in a folder with the same name as the module.`\n\n `*~ For example, if you were writing a file for \"super-greeter\", this`\n\n `*~ file should be 'super-greeter/index.d.ts'`\n\n `*/`\n\n`/*~ If this module is a UMD module that exposes a global variable 'myLib' when`\n\n `*~ loaded outside a module loader environment, declare that global here.`\n\n `*~ Otherwise, delete this declaration.`\n\n `*/`\n\n`export as namespace myLib;`\n\n`/*~ If this module exports functions, declare them like so.`\n\n `*/`\n\n`export function myFunction(a: string): string;`\n\n`export function myOtherFunction(a: number): number;`\n\n`/*~ You can declare types that are available via importing the module */`\n\n`export interface SomeType {`\n\n  `name: string;`\n\n  `length: number;`\n\n  `extras?: string[];`\n\n`}`\n\n`/*~ You can declare properties of the module using const, let, or var */`\n\n`export const myField: number;`\n\n### [](#library-file-layout)Library file layout\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\n`myLib`\n\n  `+---- index.js`\n\n  `+---- foo.js`\n\n  `+---- bar`\n\n         `+---- index.js`\n\n         `+---- baz.js`\n\nThese could be imported as\n\njs\n\n`var a = require(\"myLib\");`\n\n`var b = require(\"myLib/foo\");`\n\n`var c = require(\"myLib/bar\");`\n\n`var d = require(\"myLib/bar/baz\");`\n\nYour declaration files should thus be\n\n`@types/myLib`\n\n  `+---- index.d.ts`\n\n  `+---- foo.d.ts`\n\n  `+---- bar`\n\n         `+---- index.d.ts`\n\n         `+---- baz.d.ts`\n\n### [](#testing-your-types)Testing your types\n\nIf you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:\n\n> 1.  Create a new folder in `node_modules/@types/[libname]`\n> 2.  Create an `index.d.ts` in that folder, and copy the example in\n> 3.  See where your usage of the module breaks, and start to fill out the index.d.ts\n> 4.  When you’re happy, clone [DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped) and follow the instructions in the README.\n\nOtherwise\n\n> 1.  Create a new file in the root of your source tree: `[libname].d.ts`\n> 2.  Add `declare module \"[libname]\" { }`\n> 3.  Add the template inside the braces of the declare module, and see where your usage breaks",
    "title": "TypeScript: Documentation - Modules .d.ts",
    "description": "",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html",
    "markdown": "# TypeScript: Documentation - Module: Plugin\n\nFor example, when you want to work with JavaScript code which extends another library.\n\nts\n\n`import { greeter } from \"super-greeter\";`\n\n`// Normal Greeter API`\n\n`greeter(2);`\n\n`greeter(\"Hello world\");`\n\n`// Now we extend the object with a new function at runtime`\n\n`import \"hyper-super-greeter\";`\n\n`greeter.hyperGreet();`\n\nThe definition for “super-greeter”:\n\nts\n\n`/*~ This example shows how to have multiple overloads for your function */`\n\n`export interface GreeterFunction {`\n\n  `(name: string): void`\n\n  `(time: number): void`\n\n`}`\n\n`/*~ This example shows how to export a function specified by an interface */`\n\n`export const greeter: GreeterFunction;`\n\nWe can extend the existing module like the following:\n\nts\n\n`// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]`\n\n`// Project: [~THE PROJECT NAME~]`\n\n`// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>`\n\n`/*~ This is the module plugin template file. You should rename it to index.d.ts`\n\n `*~ and place it in a folder with the same name as the module.`\n\n `*~ For example, if you were writing a file for \"super-greeter\", this`\n\n `*~ file should be 'super-greeter/index.d.ts'`\n\n `*/`\n\n`/*~ On this line, import the module which this module adds to */`\n\n`import { greeter } from \"super-greeter\";`\n\n`/*~ Here, declare the same module as the one you imported above`\n\n `*~ then we expand the existing declaration of the greeter function`\n\n `*/`\n\n`export module \"super-greeter\" {`\n\n  `export interface GreeterFunction {`\n\n    `/** Greets even better! */`\n\n    `hyperGreet(): void;`\n\n  `}`\n\n`}`\n\nThis uses [declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)\n\n## [](#the-impact-of-es6-on-module-plugins)The Impact of ES6 on Module Plugins\n\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.",
    "title": "TypeScript: Documentation - Module: Plugin",
    "description": "",
    "languageCode": "en"
  }
]