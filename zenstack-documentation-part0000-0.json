[{
  "url": "https://zenstack.dev/docs/",
  "markdown": "# Welcome to ZenStack | ZenStack\n\nHey üëã, I'm glad you found us here.\n\nIf you are using TypeScript to build APIs or web apps above a SQL database, you are in the right place. ZenStack is an open-source toolkit built above [Prisma](https://prisma.io/) - the most popular ORM for Node.js. ZenStack pushes Prisma's power to a new level and boosts the development efficiency of every layer of your stack - from access control, to API development, and all the way up to the frontend.\n\nSome of the most common use cases of ZenStack include:\n\n*   Multi-tenant SaaS\n*   Applications with complex access control requirements\n*   CRUD-intensive API or web apps\n\nZenStack is not opinionated about your choice of framework. It can be used with any of them.\n\n## Features[‚Äã](https://zenstack.dev/docs/welcome#features \"Direct link to Features\")\n\n*   ORM with built-in access control, data validation, polymorphic relations, and more\n    \n*   Auto-generated CRUD API - RESTful & tRPC\n    \n*   Auto-generated OpenAPI documentation\n    \n*   Auto-generated frontend data query hooks - SWR & TanStack Query\n    \n*   Integrations with popular authentication services and full-stack/backend frameworks\n    \n*   A plugin system for great extensibility\n    \n\n## Find the Learning Path That Fits You[‚Äã](https://zenstack.dev/docs/welcome#find-the-learning-path-that-fits-you \"Direct link to Find the Learning Path That Fits You\")\n\nZenStack is a comprehensive toolkit that touches a wide range of topics. For most developers, we'd highly recommend you start with the [The Complete Guide](https://zenstack.dev/docs/the-complete-guide) to build a solid understanding of each layer of ZenStack's functionalities. The guide is designed to lay out concepts gradually and lead you through the learning journey from using ZenStack just as a better ORM, to leveraging its total power in full-stack development. The guide is pretty long, but trust me you'll enjoy the reading üòâ.\n\nIf you're the kind of inpatient developer who wants to get your hand dirty ASAP, you can also jump straight to the [Quick Start](https://zenstack.dev/docs/category/quick-start) guide. It shows how to quickly set up a ZenStack project targeting the framework of your choice.\n\n## Other Resources[‚Äã](https://zenstack.dev/docs/welcome#other-resources \"Direct link to Other Resources\")\n\n*   [Recipes](https://zenstack.dev/docs/category/recipes/) - Mini guides for completing specific tasks using ZenStack\n*   [Sample Catalog](https://zenstack.dev/docs/sample-catalog) - A catalog of sample projects using different frameworks\n*   [Reference](https://zenstack.dev/docs/category/reference/) - Detailed documentation for the DSL, CLI, APIs, and plugins\n*   [FAQ](https://zenstack.dev/docs/faq) - Frequently asked questions\n\nReady to roll? Let's get started üöÄ",
  "title": "Welcome to ZenStack | ZenStack",
  "description": "Welcome to ZenStack",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/category/reference",
  "markdown": "# Reference | ZenStack\n\n[\n\n## üìÑÔ∏è Added PrismaClient APIs\n\nAPIs ZenStack adds to the PrismaClient\n\n](https://zenstack.dev/docs/reference/prisma-client-ext)",
  "title": "Reference | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/welcome",
  "markdown": "# Welcome to ZenStack | ZenStack\n\nHey üëã, I'm glad you found us here.\n\nIf you are using TypeScript to build APIs or web apps above a SQL database, you are in the right place. ZenStack is an open-source toolkit built above [Prisma](https://prisma.io/) - the most popular ORM for Node.js. ZenStack pushes Prisma's power to a new level and boosts the development efficiency of every layer of your stack - from access control, to API development, and all the way up to the frontend.\n\nSome of the most common use cases of ZenStack include:\n\n*   Multi-tenant SaaS\n*   Applications with complex access control requirements\n*   CRUD-intensive API or web apps\n\nZenStack is not opinionated about your choice of framework. It can be used with any of them.\n\n## Features[‚Äã](https://zenstack.dev/docs/1.x/welcome#features \"Direct link to Features\")\n\n*   ORM with built-in access control and data validation\n    \n*   Auto-generated CRUD API - RESTful & tRPC\n    \n*   Auto-generated OpenAPI documentation\n    \n*   Auto-generated frontend data query hooks - SWR & TanStack Query\n    \n*   Integrations with popular authentication services and full-stack/backend frameworks\n    \n*   A plugin system for great extensibility\n    \n\n## Find the Learning Path That Fits You[‚Äã](https://zenstack.dev/docs/1.x/welcome#find-the-learning-path-that-fits-you \"Direct link to Find the Learning Path That Fits You\")\n\nZenStack is a comprehensive toolkit that touches a wide range of topics. For most developers, we'd highly recommend you start with the [The Complete Guide](https://zenstack.dev/docs/1.x/the-complete-guide) to build a solid understanding of each layer of ZenStack's functionalities. The guide is designed to lay out concepts gradually and lead you through the learning journey from using ZenStack just as a better ORM, to leveraging its total power in full-stack development. The guide is pretty long, but trust me you'll enjoy the reading üòâ.\n\nIf you're the kind of inpatient developer who wants to get your hand dirty ASAP, you can also jump straight to the [Quick Start](https://zenstack.dev/docs/1.x/category/quick-start) guide. It shows how to quickly set up a ZenStack project targeting the framework of your choice.\n\n## Other Resources[‚Äã](https://zenstack.dev/docs/1.x/welcome#other-resources \"Direct link to Other Resources\")\n\n*   [Recipes](https://zenstack.dev/docs/1.x/category/recipes/) - Mini guides for completing specific tasks using ZenStack\n*   [Sample Catalog](https://zenstack.dev/docs/1.x/sample-catalog) - A catalog of sample projects using different frameworks\n*   [Reference](https://zenstack.dev/docs/1.x/category/reference/) - Detailed documentation for the DSL, CLI, APIs, and plugins\n*   [FAQ](https://zenstack.dev/docs/1.x/faq) - Frequently asked questions\n\nReady to roll? Let's get started üöÄ",
  "title": "Welcome to ZenStack | ZenStack",
  "description": "Welcome to ZenStack",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/install",
  "markdown": "# Installing ZenStack | ZenStack\n\nVersion: 2.x\n\nYou can install ZenStack to your project using one of the following methods.\n\n### Using `zenstack init`[‚Äã](https://zenstack.dev/docs/install#using-zenstack-init \"Direct link to using-zenstack-init\")\n\nThe easiest way to install ZenStack is to use the `zenstack init` command. In an existing TypeScript project folder, run the following command:\n\nThe \"init\" command does the following things for you:\n\n1.  Install Prisma if it's not already installed.\n2.  Install the `zenstack` CLI package as a dev dependency.\n3.  Install the `@zenstackhq/runtime` package - used for enhancing `PrismaClient` at the runtime.\n4.  Copy the `prisma/schema.prisma` file to `schema.zmodel` if it exists; otherwise, create a new template `schema.zmodel` file.\n\nYou can always manually complete the steps above if you have a special project setup that the \"init\" command doesn't work with.\n\nAfter the initialization, please remember that you should edit the `schema.zmodel` moving forward. The `prisma/schema.prisma` file will be automatically regenerated when you run `zenstack generate`.\n\n### Manually[‚Äã](https://zenstack.dev/docs/install#manually \"Direct link to Manually\")\n\nThe following steps show how to install using \"npm\" as package manager. Replace it with the one you use for your project (like pnpm or yarn).\n\n1.  Make sure Prisma is installed\n    \n2.  Install the `zenstack` CLI package as a dev dependency\n    \n    ```\n    npm install --save-dev zenstack@latest\n    ```\n    \n3.  Install the `@zenstackhq/runtime` package as a regular dependency\n    \n    ```\n    npm install @zenstackhq/runtime@latest\n    ```\n    \n4.  Bootstrap ZModel from Prisma schema\n    \n    If you have a Prisma schema file, copy it to `schema.zmodel` in the project root folder. Remember, you should edit the `schema.zmodel` moving forward. The `prisma/schema.prisma` file will automatically regenerate when you run `zenstack generate`.\n    \n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Installing ZenStack | ZenStack",
  "description": "Installation",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/category/quick-start",
  "markdown": "# Quick Start | ZenStack\n\n[\n\n## üìÑÔ∏è Next.js (pages router)\n\nStep-by-step guide for building a blogging app with Next.js (pages router).\n\n](https://zenstack.dev/docs/quick-start/nextjs)",
  "title": "Quick Start | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/quick-start/nextjs-app-router",
  "markdown": "# Next.js (app router) | ZenStack\n\n## Get Started With Next.js (app router)\n\nLet's have some fun by creating a simple blogging app. You'll see how effortless it is to have a secure backend service without actually coding it.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-nextjs-app-dir).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new project[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#1-create-a-new-project \"Direct link to 1. Create a new project\")\n\nThe easiest way to create a Next.js project with boilerplates is with `create-t3-app`. Run the following command to create a new project with Prisma, NextAuth and TailwindCSS.\n\n```\nnpx create-t3-app@latest --prisma --nextAuth --tailwind --appRouter --CI my-blog-appcd my-blog-app\n```\n\nRemove `DISCORD_CLIENT_ID` and `DISCORD_CLIENT_SECRET` related code from `src/env.js`, since we're not going to use Discord for authentication. After that, start the dev server:\n\nIf everything works, you should have a running Next.js app at [http://localhost:3000](http://localhost:3000/).\n\n![](https://zenstack.dev/img/t3app.png)\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\n### 3\\. Preparing the User model for authentication[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#3-preparing-the-user-model-for-authentication \"Direct link to 3. Preparing the User model for authentication\")\n\nFirst, in `schema.zmodel`, make a few changes to the `User` model:\n\n/schema.zmodel\n\n```\nmodel User {  id            String    @id @default(cuid())  name          String?  email         String?   @unique  emailVerified DateTime?  password      String @password @omit  image         String?  accounts      Account[]  sessions      Session[]  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)  // only the user can update or delete their own profile  @@allow('update,delete', auth() == this)}\n```\n\nFor simplicity, we'll use username/password-based authentication in this project. In the code above, we added a `password` field to support it, together with two access policy rules to control the permissions of this model.\n\ntip\n\n1.  `@password` is a ZenStack attribute that marks a field to be hashed (using [bcryptjs](https://www.npmjs.com/package/bcryptjs)) before saving.\n2.  `@omit` indicates the field should be dropped when returned from a query.\n\ninfo\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/the-complete-guide/part1/access-policy) for more details.\n\nNow run `zenstack generate` and `prisma db push` to flush the changes to the Prisma schema and database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 4\\. Configure NextAuth to use credential-based auth[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#4-configure-nextauth-to-use-credential-based-auth \"Direct link to 4. Configure NextAuth to use credential-based auth\")\n\nNow let's update `/src/server/auth.ts` to the content below to use credentials auth and JWT-based session:\n\n/src/server/auth.ts\n\n```\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";import type { PrismaClient } from \"@prisma/client\";import { compare } from \"bcryptjs\";import {  getServerSession,  type DefaultSession,  type NextAuthOptions,} from \"next-auth\";import { type Adapter } from \"next-auth/adapters\";import CredentialsProvider from \"next-auth/providers/credentials\";import { db } from \"~/server/db\";/** * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session` * object and keep type safety. * * @see https://next-auth.js.org/getting-started/typescript#module-augmentation */declare module \"next-auth\" {  interface Session extends DefaultSession {    user: {      id: string;    } & DefaultSession[\"user\"];  }}/** * Options for NextAuth.js used to configure adapters, providers, callbacks, etc. * * @see https://next-auth.js.org/configuration/options */export const authOptions: NextAuthOptions = {  session: {    strategy: \"jwt\",  },  callbacks: {    session({ session, token }) {      if (session.user) {        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion        session.user.id = token.sub!;      }      return session;    },  },  adapter: PrismaAdapter(db) as Adapter,  providers: [    CredentialsProvider({      credentials: {        email: { type: \"email\" },        password: { type: \"password\" },      },      authorize: authorize(db),    }),    /**     * ...add more providers here.     *     * Most other providers require a bit more work than the Discord provider. For example, the     * GitHub provider requires you to add the `refresh_token_expires_in` field to the Account     * model. Refer to the NextAuth.js docs for the provider you want to use. Example:     *     * @see https://next-auth.js.org/providers/github     */  ],};function authorize(prisma: PrismaClient) {  return async (    credentials: Record<\"email\" | \"password\", string> | undefined,  ) => {    if (!credentials) throw new Error(\"Missing credentials\");    if (!credentials.email)      throw new Error('\"email\" is required in credentials');    if (!credentials.password)      throw new Error('\"password\" is required in credentials');    const maybeUser = await prisma.user.findFirst({      where: { email: credentials.email },      select: { id: true, email: true, password: true },    });    if (!maybeUser?.password) return null;    // verify the input password with stored hash    const isValid = await compare(credentials.password, maybeUser.password);    if (!isValid) return null;    return { id: maybeUser.id, email: maybeUser.email };  };}/** * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file. * * @see https://next-auth.js.org/configuration/nextjs */export const getServerAuthSession = () => getServerSession(authOptions);\n```\n\nFinally, add a `NEXTAUTH_SECRET` environment variable in .env file and set it to an arbitrary value (use a complex secret in production and don't check it into git):\n\n### 5\\. Mount CRUD service & generate hooks[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#5-mount-crud-service--generate-hooks \"Direct link to 5. Mount CRUD service & generate hooks\")\n\nZenStack has built-in support for Next.js and can provide database CRUD services automagically, so you don't need to write it yourself.\n\nFirst install the `@zenstackhq/server`, `@tanstack/react-query`, and `@zenstackhq/tanstack-query` packages:\n\n```\nnpm install @zenstackhq/server@latest @tanstack/react-querynpm install -D @zenstackhq/tanstack-query@latest\n```\n\nLet's mount it to the `/api/model/[...path]` endpoint. Create a `/src/app/api/model/[...path]/route.ts` file and fill in the content below:\n\n/src/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { enhance } from \"@zenstackhq/runtime\";import { NextRequestHandler } from \"@zenstackhq/server/next\";import { getServerAuthSession } from \"~/server/auth\";import { db } from \"~/server/db\";// create an enhanced Prisma client with user contextasync function getPrisma() {  const session = await getServerAuthSession();  return enhance(db, { user: session?.user });}const handler = NextRequestHandler({ getPrisma, useAppDir: true });export {  handler as DELETE,  handler as GET,  handler as PATCH,  handler as POST,  handler as PUT,};\n```\n\nThe `/api/model` route is now ready to access database query and mutation requests. However, manually calling the service will be tedious. Fortunately, ZenStack can automatically generate React data query hooks for you.\n\nLet's enable it by adding the following snippet at the top level to `schema.zmodel`:\n\n/schema.zmodel\n\n```\nplugin hooks {  provider = '@zenstackhq/tanstack-query'  target = 'react'  version = 'v5'  output = \"./src/lib/hooks\"}\n```\n\nNow run `zenstack generate` again; you'll find the hooks generated under `/src/lib/hooks` folder:\n\nNow we're ready to implement the signup/signin flow.\n\n### 6\\. Set up context providers[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#6-set-up-context-providers \"Direct link to 6. Set up context providers\")\n\nNextAuth and React Query require context providers to be set up. Create a `/src/app/providers.tsx` file with the following content:\n\n/src/app/providers.tsx\n\n```\n\"use client\";import { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";import { SessionProvider } from \"next-auth/react\";import type { ReactNode } from \"react\";const queryClient = new QueryClient();export default function Providers({ children }: { children: ReactNode }) {  return (    <QueryClientProvider client={queryClient}>      <SessionProvider>{children}</SessionProvider>    </QueryClientProvider>  );}\n```\n\nThen, update `/src/app/layout.tsx` to install the query client provider:\n\n/src/app/layout.tsx\n\n```\n\"use client\";import \"~/styles/globals.css\";import { Inter } from \"next/font/google\";import Providers from \"./providers\";const inter = Inter({  subsets: [\"latin\"],  variable: \"--font-sans\",});export default function RootLayout({  children,}: {  children: React.ReactNode;}) {  return (    <html lang=\"en\">      <body className={`font-sans ${inter.variable}`}>        <Providers>{children}</Providers>      </body>    </html>  );}\n```\n\ninfo\n\nWe've only done the minimum setup to get React Query to work with NextJS's app router. For more more in-depth background and setup, please refer to React Query's official documentation about [Advanced Server Rendering](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).\n\n### 7\\. Implement Signup/Signin[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#7-implement-signupsignin \"Direct link to 7. Implement Signup/Signin\")\n\nNow let's implement the signup/signin pages. First, create a new page `/src/app/signup/page.tsx`:\n\n/src/app/signup/page.tsx\n\n```\n\"use client\";import type { NextPage } from \"next\";import { signIn } from \"next-auth/react\";import { useRouter } from \"next/navigation\";import { useState, type FormEvent } from \"react\";import { useCreateUser } from \"~/lib/hooks\";const Signup: NextPage = () => {  const [email, setEmail] = useState(\"\");  const [password, setPassword] = useState(\"\");  const { mutateAsync: signup } = useCreateUser();  const router = useRouter();  async function onSignup(e: FormEvent) {    e.preventDefault();    try {      await signup({ data: { email, password } });      // eslint-disable-next-line @typescript-eslint/no-explicit-any    } catch (err: any) {      console.error(err);      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access      if (err.info?.prisma && err.info?.code === \"P2002\") {        // P2002 is Prisma's error code for unique constraint violations        alert(\"User already exists\");      } else {        alert(\"An unknown error occurred\");      }      return;    }    // signin to create a session    await signIn(\"credentials\", { redirect: false, email, password });    router.push(\"/\");  }  return (    <div className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">      <h1 className=\"text-5xl font-extrabold text-white\">Sign up</h1>      <form        className=\"mt-16 flex flex-col gap-8 text-2xl\"        onSubmit={(e) => void onSignup(e)}      >        <div>          <label htmlFor=\"email\" className=\"inline-block w-32 text-white\">            Email          </label>          <input            id=\"email\"            type=\"email\"            value={email}            onChange={(e) => setEmail(e.currentTarget.value)}            className=\"ml-4 w-72 rounded border p-2\"          />        </div>        <div>          <label htmlFor=\"password\" className=\"inline-block w-32 text-white \">            Password          </label>          <input            id=\"password\"            type=\"password\"            value={password}            onChange={(e) => setPassword(e.currentTarget.value)}            className=\"ml-4 w-72 rounded border p-2\"          />        </div>        <input          type=\"submit\"          value=\"Create account\"          className=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"        />      </form>    </div>  );};export default Signup;\n```\n\nIn the code above, we used the auto-generated `useCreateUser` hooks to create new `User` entities.\n\ntip\n\n1.  The services backing the hooks are governed by the access policies we defined. Here the `create` call can succeed because we explicitly allowed it in the `User` model. By default, all operations are forbidden.\n2.  The `password` field is automatically hashed. You can confirm it using a sqlite inspection tool to browse the `prisma/db.sqlite` database file.\n\nTry visiting [http://localhost:3000/signup](http://localhost:3000/signup) and creating a new user. It should look like this:\n\n![](https://zenstack.dev/img/tutorial-signup-form.png)\n\nSimilarly, create the signin page `/src/app/signin/page.tsx`:\n\n/src/app/signin/page.tsx\n\n```\n\"use client\";import type { NextPage } from \"next\";import { signIn } from \"next-auth/react\";import { useRouter } from \"next/navigation\";import { useState, type FormEvent } from \"react\";const Signin: NextPage = () => {  const [email, setEmail] = useState(\"\");  const [password, setPassword] = useState(\"\");  const router = useRouter();  async function onSignin(e: FormEvent) {    e.preventDefault();    const result = await signIn(\"credentials\", {      redirect: false,      email,      password,    });    if (result?.ok) {      router.push(\"/\");    } else {      alert(\"Signin failed\");    }  }  return (    <div className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">      <h1 className=\"text-5xl font-extrabold text-white\">Login</h1>      <form        className=\"mt-16 flex flex-col gap-8 text-2xl\"        onSubmit={(e) => void onSignin(e)}      >        <div>          <label htmlFor=\"email\" className=\"inline-block w-32  text-white\">            Email          </label>          <input            id=\"email\"            type=\"email\"            value={email}            onChange={(e) => setEmail(e.currentTarget.value)}            className=\"ml-4 w-72 rounded border p-2\"          />        </div>        <div>          <label htmlFor=\"password\" className=\"inline-block w-32  text-white\">            Password          </label>          <input            id=\"password\"            type=\"password\"            value={password}            onChange={(e) => setPassword(e.currentTarget.value)}            className=\"ml-4 w-72 rounded border p-2\"          />        </div>        <input          type=\"submit\"          value=\"Sign me in\"          className=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"        />      </form>    </div>  );};export default Signin;\n```\n\n### 8\\. Prepare the Post model[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#8-prepare-the-post-model \"Direct link to 8. Prepare the Post model\")\n\nNow let's update the `Post` model to add access policies.\n\n/schema.zmodel\n\n```\nmodel Post {  id Int @id @default(autoincrement())  name String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  published Boolean @default(false)  createdBy User @relation(fields: [createdById], references: [id])  createdById String @default(auth().id)  @@index([name])  // author has full access  @@allow('all', auth() == createdBy)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\ninfo\n\nThe \"createdById\" field as a `@default()` attribute with `auth().id` value. The field will be automatically assigned with the current user's ID when creating a new record. See [here](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#using-auth-in-default) for more details.\n\nDon't forget to regenerate and push schema changes to the database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 9\\. Build up the home page[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#9-build-up-the-home-page \"Direct link to 9. Build up the home page\")\n\nNow let's replace `/src/app/page.tsx` with the content below and use it for viewing and managing posts.\n\n/src/app/page.tsx\n\n```\n\"use client\";import type { Post } from \"@prisma/client\";import { type NextPage } from \"next\";import { signOut, useSession } from \"next-auth/react\";import Link from \"next/link\";import { useRouter } from \"next/navigation\";import {  useFindManyPost,  useCreatePost,  useUpdatePost,  useDeletePost,} from \"../lib/hooks\";type AuthUser = { id: string; email?: string | null };const Welcome = ({ user }: { user: AuthUser }) => {  const router = useRouter();  async function onSignout() {    await signOut({ redirect: false });    router.push(\"/signin\");  }  return (    <div className=\"flex gap-4\">      <h3 className=\"text-lg\">Welcome back, {user?.email}</h3>      <button        className=\"text-gray-300 underline\"        onClick={() => void onSignout()}      >        Signout      </button>    </div>  );};const SigninSignup = () => {  return (    <div className=\"flex gap-4 text-2xl\">      <Link href=\"/signin\" className=\"rounded-lg border px-4 py-2\">        Signin      </Link>      <Link href=\"/signup\" className=\"rounded-lg border px-4 py-2\">        Signup      </Link>    </div>  );};const Posts = ({ user }: { user: AuthUser }) => {  // Post crud hooks  const { mutateAsync: createPost } = useCreatePost();  const { mutateAsync: updatePost } = useUpdatePost();  const { mutateAsync: deletePost } = useDeletePost();  // list all posts that're visible to the current user, together with their authors  const { data: posts } = useFindManyPost({    include: { createdBy: true },    orderBy: { createdAt: \"desc\" },  });  async function onCreatePost() {    const name = prompt(\"Enter post name\");    if (name) {      await createPost({ data: { name } });    }  }  async function onTogglePublished(post: Post) {    await updatePost({      where: { id: post.id },      data: { published: !post.published },    });  }  async function onDelete(post: Post) {    await deletePost({ where: { id: post.id } });  }  return (    <div className=\"container flex flex-col text-white\">      <button        className=\"rounded border border-white p-2 text-lg\"        onClick={() => void onCreatePost()}      >        + Create Post      </button>      <ul className=\"container mt-8 flex flex-col gap-2\">        {posts?.map((post) => (          <li key={post.id} className=\"flex items-end justify-between gap-4\">            <p className={`text-2xl ${!post.published ? \"text-gray-400\" : \"\"}`}>              {post.name}              <span className=\"text-lg\"> by {post.createdBy.email}</span>            </p>            <div className=\"flex w-32 justify-end gap-1 text-left\">              <button                className=\"underline\"                onClick={() => void onTogglePublished(post)}              >                {post.published ? \"Unpublish\" : \"Publish\"}              </button>              <button className=\"underline\" onClick={() => void onDelete(post)}>                Delete              </button>            </div>          </li>        ))}      </ul>    </div>  );};const Home: NextPage = () => {  const { data: session, status } = useSession();  if (status === \"loading\") return <p>Loading ...</p>;  return (    <main className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">      <div className=\"container flex flex-col items-center justify-center gap-12 px-4 py-16 text-white\">        <h1 className=\"text-5xl font-extrabold\">My Awesome Blog</h1>        {session?.user ? (          // welcome & blog posts          <div className=\"flex flex-col\">            <Welcome user={session.user} />            <section className=\"mt-10\">              <Posts user={session.user} />            </section>          </div>        ) : (          // if not logged in          <SigninSignup />        )}      </div>    </main>  );};export default Home;\n```\n\n## Verifying the result[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#verifying-the-result \"Direct link to Verifying the result\")\n\nRestart the dev server and try creating a few posts. You should see something like the following:\n\n![](https://zenstack.dev/img/tutorial-blog-posts.png)\n\nThe code looks a bit long because we tucked all UI components directly into the page. As you can see, querying and mutating `Post` entities are fairly straightforward, the generated hooks. When mutation happens, e.g. a new post is created, data refetching is also triggered automatically.\n\nTry opening an incognito browser window and signing up for a separate account. You should find that the published posts are visible, as we specified with access policies.\n\n![](https://zenstack.dev/img/tutorial-blog-posts-readable.png)\n\nSince we haven't hidden \"Unpublish\" and \"Delete\" buttons for posts not owned by the current user, you can still click them even for posts not owned to you, but it will end up with a 403 error:\n\n![network error](https://zenstack.dev/assets/images/tutorial-post-update-denied-6678fc0a9b958064f56f02cb3f7f3c3a.png)\n\n```\n{    \"prisma\": true,    \"rejectedByPolicy\": true,    \"code\": \"P2004\",    \"message\": \"denied by policy: post entities failed 'update' check, 1 entities failed policy check\"}\n```\n\nYou can catch the error and render a nice message to the user.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/quick-start/nextjs-app-router#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple blogging app without writing a single line of backend code. Pretty cool, isn't it?\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-nextjs-app-dir). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/category/reference) and [Guides](https://zenstack.dev/docs/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Next.js (app router) | ZenStack",
  "description": "Step-by-step guide for building a blogging app with Next.js (app router).",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/quick-start/nextjs",
  "markdown": "# Next.js (pages router) | ZenStack\n\n## Get Started With Next.js\n\nLet's have some fun by creating a simple blogging app. You'll see how effortless it is to have a secure backend service without actually coding it.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-nextjs).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new project[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#1-create-a-new-project \"Direct link to 1. Create a new project\")\n\nThe easiest way to create a Next.js project with boilerplates is with `create-t3-app`. Run the following command to create a new project with Prisma, NextAuth and TailwindCSS.\n\n```\nnpx create-t3-app@latest --prisma --nextAuth --tailwind --CI my-blog-appcd my-blog-app\n```\n\nRemove `DISCORD_CLIENT_ID` and `DISCORD_CLIENT_SECRET` related code from `src/env.js`, since we're not going to use Discord for authentication. After that, start the dev server:\n\nIf everything works, you should have a running Next.js app at [http://localhost:3000](http://localhost:3000/).\n\n![](https://zenstack.dev/img/t3app.png)\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\n### 3\\. Preparing the User model for authentication[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#3-preparing-the-user-model-for-authentication \"Direct link to 3. Preparing the User model for authentication\")\n\nFirst, in `schema.zmodel`, make a few changes to the `User` model:\n\n/schema.zmodel\n\n```\nmodel User {  id            String    @id @default(cuid())  name          String?  email         String?   @unique  emailVerified DateTime?  password      String @password @omit  image         String?  accounts      Account[]  sessions      Session[]  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)  // only the user can update or delete their own profile  @@allow('update,delete', auth() == this)}\n```\n\nFor simplicity, we'll use username/password-based authentication in this project. In the code above, we added a `password` field to support it, together with two access policy rules to control the permissions of this model.\n\ntip\n\n1.  `@password` is a ZenStack attribute that marks a field to be hashed (using [bcryptjs](https://www.npmjs.com/package/bcryptjs)) before saving.\n2.  `@omit` indicates the field should be dropped when returned from a query.\n\ninfo\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/the-complete-guide/part1/access-policy) for more details.\n\nNow run `zenstack generate` and `prisma db push` to flush the changes to the Prisma schema and database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 4\\. Configure NextAuth to use credential-based auth[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#4-configure-nextauth-to-use-credential-based-auth \"Direct link to 4. Configure NextAuth to use credential-based auth\")\n\nNow let's update `/src/server/auth.ts` to the content below to use credentials auth and JWT-based session:\n\n/src/server/auth.ts\n\n```\nimport { PrismaAdapter } from '@next-auth/prisma-adapter';import type { PrismaClient } from '@prisma/client';import { compare } from 'bcryptjs';import type { GetServerSidePropsContext } from 'next';import NextAuth, { getServerSession, type DefaultSession, type NextAuthOptions } from 'next-auth';import CredentialsProvider from 'next-auth/providers/credentials';import { db } from './db';/** * Module augmentation for `next-auth` types. * Allows us to add custom properties to the `session` object and keep type * safety. * * @see https://next-auth.js.org/getting-started/typescript#module-augmentation **/declare module 'next-auth' {    interface Session extends DefaultSession {        user: {            id: string;        } & DefaultSession['user'];    }}/** * Options for NextAuth.js used to configure adapters, providers, callbacks, * etc. * * @see https://next-auth.js.org/configuration/options **/export const authOptions: NextAuthOptions = {    session: {        strategy: 'jwt',    },    // Include user.id on session    callbacks: {        session({ session, token }) {            if (session.user) {                session.user.id = token.sub!;            }            return session;        },    },    // Configure one or more authentication providers    adapter: PrismaAdapter(db),    providers: [        CredentialsProvider({            credentials: {                email: { type: 'email' },                password: { type: 'password' },            },            authorize: authorize(db),        }),    ],};function authorize(prisma: PrismaClient) {    return async (credentials: Record<'email' | 'password', string> | undefined) => {        if (!credentials) throw new Error('Missing credentials');        if (!credentials.email) throw new Error('\"email\" is required in credentials');        if (!credentials.password) throw new Error('\"password\" is required in credentials');        const maybeUser = await prisma.user.findFirst({            where: { email: credentials.email },            select: { id: true, email: true, password: true },        });        if (!maybeUser || !maybeUser.password) return null;        // verify the input password with stored hash        const isValid = await compare(credentials.password, maybeUser.password);        if (!isValid) return null;        return { id: maybeUser.id, email: maybeUser.email };    };}/** * Wrapper for `getServerSession` so that you don't need to import the * `authOptions` in every file. * * @see https://next-auth.js.org/configuration/nextjs **/export const getServerAuthSession = (ctx: {    req: GetServerSidePropsContext['req'];    res: GetServerSidePropsContext['res'];}) => {    return getServerSession(ctx.req, ctx.res, authOptions);};export default NextAuth(authOptions);\n```\n\nFinally, add a `NEXTAUTH_SECRET` environment variable in .env file and set it to an arbitrary value (use a complex secret in production and don't check it into git):\n\n### 5\\. Mount CRUD service & generate hooks[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#5-mount-crud-service--generate-hooks \"Direct link to 5. Mount CRUD service & generate hooks\")\n\nZenStack has built-in support for Next.js and can provide database CRUD services automagically, so you don't need to write it yourself.\n\nFirst install the `@zenstackhq/server` and `@zenstackhq/swr` packages:\n\n```\nnpm install @zenstackhq/server swrnpm install -D  @zenstackhq/swr\n```\n\nLet's mount it to the `/api/model/[...path]` endpoint. Create a `/src/pages/api/model/[...path].ts` file and fill in the content below:\n\n/src/pages/api/model/\\[...path\\].ts\n\n```\nimport { NextRequestHandler } from '@zenstackhq/server/next';import { enhance } from '@zenstackhq/runtime';import type { NextApiRequest, NextApiResponse } from 'next';import { getServerAuthSession } from '../../../server/auth';import { prisma } from '../../../server/db';async function getPrisma(req: NextApiRequest, res: NextApiResponse) {    const session = await getServerAuthSession({ req, res });    // create a wrapper of Prisma client that enforces access policy,    // data validation, and @password, @omit behaviors    return enhance(prisma, { user: session?.user });}export default NextRequestHandler({ getPrisma });\n```\n\nThe `/api/model` route is now ready to access database query and mutation requests. However, manually calling the service will be tedious. Fortunately, ZenStack can automatically generate React hooks for you.\n\nLet's enable it by adding the following snippet at the top level to `schema.zmodel`:\n\n```\nplugin hooks {  provider = '@zenstackhq/swr'  output = \"./src/lib/hooks\"}\n```\n\nNow run `zenstack generate` again; you'll find the hooks generated under `/src/lib/hooks` folder:\n\nNow we're ready to implement the signup/signin flow.\n\n### 6\\. Implement Signup/Signin[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#6-implement-signupsignin \"Direct link to 6. Implement Signup/Signin\")\n\nNow let's implement the signup/signin pages. First, create a new page `/src/pages/signup.tsx`:\n\n/src/pages/signup.tsx\n\n```\n/* eslint-disable @typescript-eslint/no-explicit-any *//* eslint-disable @typescript-eslint/no-unsafe-member-access */import type { NextPage } from 'next';import { signIn } from 'next-auth/react';import Router from 'next/router';import { useState, type FormEvent } from 'react';import { useCreateUser } from \"../lib/hooks\";const Signup: NextPage = () => {    const [email, setEmail] = useState('');    const [password, setPassword] = useState('');    const { trigger: signup } = useCreateUser();    async function onSignup(e: FormEvent) {        e.preventDefault();        try {            await signup({ data: { email, password } });        } catch (err: any) {            console.error(err);            if (err.info?.prisma && err.info?.code === 'P2002') {                // P2002 is Prisma's error code for unique constraint violations                alert('User alread exists');            } else {                alert('An unknown error occurred');            }            return;        }        // signin to create a session        await signIn('credentials', { redirect: false, email, password });        await Router.push('/');    }    return (        <div className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">            <h1 className=\"text-5xl font-extrabold text-white\">Sign up</h1>            <form className=\"mt-16 flex flex-col gap-8 text-2xl\" onSubmit={(e) => void onSignup(e)}>                <div>                    <label htmlFor=\"email\" className=\"inline-block w-32 text-white\">                        Email                    </label>                    <input                        id=\"email\"                        type=\"email\"                        value={email}                        onChange={(e) => setEmail(e.currentTarget.value)}                        className=\"ml-4 w-72 rounded border p-2\"                    />                </div>                <div>                    <label htmlFor=\"password\" className=\"inline-block w-32 text-white \">                        Password                    </label>                    <input                        id=\"password\"                        type=\"password\"                        value={password}                        onChange={(e) => setPassword(e.currentTarget.value)}                        className=\"ml-4 w-72 rounded border p-2\"                    />                </div>                <input                    type=\"submit\"                    value=\"Create account\"                    className=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"                />            </form>        </div>    );};export default Signup;\n```\n\nIn the code above, we used the auto-generated `useCreateUser` hooks to create new `User` entities.\n\ntip\n\n1.  The services backing the hooks are governed by the access policies we defined. Here the `create` call can succeed because we explicitly allowed it in the `User` model. By default, all operations are forbidden.\n2.  The `password` field is automatically hashed. You can confirm it using a sqlite inspection tool to browse the `prisma/db.sqlite` database file.\n\nTry visiting [http://localhost:3000/signup](http://localhost:3000/signup) and creating a new user. It should look like this:\n\n![](https://zenstack.dev/img/tutorial-signup-form.png)\n\nSimilarly, create the signin page `/src/pages/signin.tsx`:\n\n/src/pages/signin.tsx\n\n```\nimport type { NextPage } from 'next';import { signIn } from 'next-auth/react';import Router from 'next/router';import { useState, type FormEvent } from 'react';const Signin: NextPage = () => {    const [email, setEmail] = useState('');    const [password, setPassword] = useState('');    async function onSignin(e: FormEvent) {        e.preventDefault();        const result = await signIn('credentials', {            redirect: false,            email,            password,        });        if (result?.ok) {            await Router.push('/');        } else {            alert('Signin failed');        }    }    return (        <div className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">            <h1 className=\"text-5xl font-extrabold text-white\">Login</h1>            <form className=\"mt-16 flex flex-col gap-8 text-2xl\" onSubmit={(e) => void onSignin(e)}>                <div>                    <label htmlFor=\"email\" className=\"inline-block w-32  text-white\">                        Email                    </label>                    <input                        id=\"email\"                        type=\"email\"                        value={email}                        onChange={(e) => setEmail(e.currentTarget.value)}                        className=\"ml-4 w-72 rounded border p-2\"                    />                </div>                <div>                    <label htmlFor=\"password\" className=\"inline-block w-32  text-white\">                        Password                    </label>                    <input                        id=\"password\"                        type=\"password\"                        value={password}                        onChange={(e) => setPassword(e.currentTarget.value)}                        className=\"ml-4 w-72 rounded border p-2\"                    />                </div>                <input                    type=\"submit\"                    value=\"Sign me in\"                    className=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"                />            </form>        </div>    );};export default Signin;\n```\n\n### 7\\. Prepare the Post model[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#7-prepare-the-post-model \"Direct link to 7. Prepare the Post model\")\n\nNow let's create a `Post` model. We'll use it to store blog posts.\n\n/schema.zmodel\n\n```\nmodel Post {  id        String @id @default(cuid())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String  published Boolean @default(false)  author    User @relation(fields: [authorId], references: [id])  authorId  String @default(auth().id)  // author has full access  @@allow('all', auth() == author)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\ninfo\n\nThe \"authorId\" field as a `@default()` attribute with `auth().id` value. The field will be automatically assigned with the current user's ID when creating a new record. See [here](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#using-auth-in-default) for more details.\n\n`User` and `Post` model has a one-to-many relation. We can establish it by adding a `posts` relation field to the `User` model.\n\n/schema.zmodel\n\n```\nmodel User {    id            String    @id @default(cuid())    name          String?    email         String?   @unique    emailVerified DateTime?    password      String @password @omit    posts         Post[]    image         String?    accounts      Account[]    sessions      Session[]    // everyone can signup, and user profile is also publicly readable    @@allow('create,read', true)    // only the user can update or delete their own profile    @@allow('update,delete', auth() == this)}\n```\n\nDon't forget to regenerate and push schema changes to the database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 8\\. Build up the home page[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#8-build-up-the-home-page \"Direct link to 8. Build up the home page\")\n\nNow let's replace `/src/pages/index.tsx` with the content below and use it for viewing and managing posts.\n\n/src/pages/index.tsx\n\n```\nimport type { Post } from '@prisma/client';import { type NextPage } from 'next';import { signOut, useSession } from 'next-auth/react';import Link from 'next/link';import Router from 'next/router';import {  useCreatePost,  useDeletePost,  useFindManyPost,  useUpdatePost,} from \"../lib/hooks\";type AuthUser = { id: string; email?: string | null };const Welcome = ({ user }: { user: AuthUser }) => {    async function onSignout() {        await signOut({ redirect: false });        await Router.push('/signin');    }    return (        <div className=\"flex gap-4\">            <h3 className=\"text-lg\">Welcome back, {user?.email}</h3>            <button className=\"text-gray-300 underline\" onClick={() => void onSignout()}>                Signout            </button>        </div>    );};const SigninSignup = () => {    return (        <div className=\"flex gap-4 text-2xl\">            <Link href=\"/signin\" className=\"rounded-lg border px-4 py-2\">                Signin            </Link>            <Link href=\"/signup\" className=\"rounded-lg border px-4 py-2\">                Signup            </Link>        </div>    );};const Posts = ({ user }: { user: AuthUser }) => {    // Post crud hooks    const { trigger: createPost } = useCreatePost();    const { trigger: updatePost } = useUpdatePost();    const { trigger: deletePost } = useDeletePost();    // list all posts that're visible to the current user, together with their authors    const { data: posts } = useFindManyPost({        include: { author: true },        orderBy: { createdAt: 'desc' },    });    async function onCreatePost() {        const title = prompt('Enter post title');        if (title) {            await createPost({ data: { title } });        }    }    async function onTogglePublished(post: Post) {        await updatePost({            where: { id: post.id },            data: { published: !post.published },        });    }    async function onDelete(post: Post) {        await deletePost({ where: { id: post.id } });    }    return (        <div className=\"container flex flex-col text-white\">            <button className=\"rounded border border-white p-2 text-lg\" onClick={() => void onCreatePost()}>                + Create Post            </button>            <ul className=\"container mt-8 flex flex-col gap-2\">                {posts?.map((post) => (                    <li key={post.id} className=\"flex items-end justify-between gap-4\">                        <p className={`text-2xl ${!post.published ? 'text-gray-400' : ''}`}>                            {post.title}                            <span className=\"text-lg\"> by {post.author.email}</span>                        </p>                        <div className=\"flex w-32 justify-end gap-1 text-left\">                            <button className=\"underline\" onClick={() => void onTogglePublished(post)}>                                {post.published ? 'Unpublish' : 'Publish'}                            </button>                            <button className=\"underline\" onClick={() => void onDelete(post)}>                                Delete                            </button>                        </div>                    </li>                ))}            </ul>        </div>    );};const Home: NextPage = () => {    const { data: session, status } = useSession();    if (status === 'loading') return <p>Loading ...</p>;    return (        <main className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">            <div className=\"container flex flex-col items-center justify-center gap-12 px-4 py-16 text-white\">                <h1 className=\"text-5xl font-extrabold\">My Awesome Blog</h1>                {session?.user ? (                    // welcome & blog posts                    <div className=\"flex flex-col\">                        <Welcome user={session.user} />                        <section className=\"mt-10\">                            <Posts user={session.user} />                        </section>                    </div>                ) : (                    // if not logged in                    <SigninSignup />                )}            </div>        </main>    );};export default Home;\n```\n\n## Verifying the result[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#verifying-the-result \"Direct link to Verifying the result\")\n\nRestart the dev server and try creating a few posts. You should see something like the following:\n\n![](https://zenstack.dev/img/tutorial-blog-posts.png)\n\nThe code looks a bit long because we tucked all UI components directly into the page. As you can see, querying and mutating `Post` entities are fairly straightforward, the generated hooks. When mutation happens, e.g. a new post is created, data refetching is also triggered automatically.\n\nTry opening an incognito browser window and signing up for a separate account. You should find that the published posts are visible, as we specified with access policies.\n\n![](https://zenstack.dev/img/tutorial-blog-posts-readable.png)\n\nSince we haven't hidden \"Unpublish\" and \"Delete\" buttons for posts not owned by the current user, you can still click them even for posts not owned to you, but it will end up with a 403 error:\n\n![network error](https://zenstack.dev/assets/images/tutorial-post-update-denied-6678fc0a9b958064f56f02cb3f7f3c3a.png)\n\n```\n{    \"prisma\": true,    \"rejectedByPolicy\": true,    \"code\": \"P2004\",    \"message\": \"denied by policy: post entities failed 'update' check, 1 entities failed policy check\"}\n```\n\nYou can catch the error and render a nice message to the user.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/quick-start/nextjs#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple blogging app without writing a single line of backend code. Pretty cool, isn't it?\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-nextjs). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/category/reference) and [Guides](https://zenstack.dev/docs/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Next.js (pages router) | ZenStack",
  "description": "Step-by-step guide for building a blogging app with Next.js (pages router).",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/quick-start/sveltekit",
  "markdown": "# SvelteKit | ZenStack\n\n## Get Started With SvelteKit\n\nLet's have some fun by creating a simple blogging app. You'll see how effortless it is to have a secure backend service without actually coding it.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-sveltekit).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new project[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#1-create-a-new-project \"Direct link to 1. Create a new project\")\n\nThe easiest way to create a SvelteKit project with boilerplates is with `npm create svelte`. Run the following command to create a new project:\n\n```\nnpm create svelte@latest my-blog-app\n```\n\nChoose the following options when prompted:\n\n*   Which Svelte app template?\n    \n    Skeleton project\n    \n*   Add type checking with TypeScript?\n    \n    Yes, using TypeScript syntax\n    \n*   Select additional options (use arrow keys/space bar)\n    \n    Add ESLint for code linting, Add Prettier for code formatting\n    \n\n### 2\\. Configure TailwindCSS[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#2-configure-tailwindcss \"Direct link to 2. Configure TailwindCSS\")\n\nFollow the guide [here](https://tailwindcss.com/docs/guides/sveltekit) to add TailwindCSS to your project.\n\n### 3\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#3-initialize-the-project-for-zenstack \"Direct link to 3. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack. Inside your project directory, run the following command:\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\nReplace the `User` and `Post` models in the `/schema.zmodel` file with the following content:\n\n/schema.zmodel\n\n```\nmodel User {    id String @id @default(cuid())    email String @unique @email    password String @password @omit @length(8, 16)    posts Post[]    // everybody can signup    @@allow('create,read', true)    // full access by self    @@allow('all', auth() == this)}model Post {    id String @id @default(cuid())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    title String @length(1, 256)    published Boolean @default(false)    author User? @relation(fields: [authorId], references: [id])    authorId String? @default(auth().id)    // allow read for all signin users    @@allow('read', auth() != null && published)    // full access by author    @@allow('all', author == auth())}\n```\n\ninfo\n\nThe \"authorId\" field as a `@default()` attribute with `auth().id` value. The field will be automatically assigned with the current user's ID when creating a new record. See [here](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#using-auth-in-default) for more details.\n\ntip\n\n1.  `@password` is a ZenStack attribute that marks a field to be hashed (using [bcryptjs](https://www.npmjs.com/package/bcryptjs)) before saving.\n2.  `@omit` indicates the field should be dropped when returned from a query.\n\ninfo\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/the-complete-guide/part1/access-policy) for more details.\n\nNow run `zenstack generate` and `prisma db push` to flush the changes to the Prisma schema and database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n```\nnpm add jsonwebtoken bcryptjsnpm add -D @types/jsonwebtoken @types/bcryptjs\n```\n\n### 5\\. Set up environment variables[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#5-set-up-environment-variables \"Direct link to 5. Set up environment variables\")\n\nCreate a \".env\" file under the root directory of your project and add the following content:\n\ninfo\n\nIn a real-world application, you should use a strong secret.\n\n### 6\\. Create database and auth utilities[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#6-create-database-and-auth-utilities \"Direct link to 6. Create database and auth utilities\")\n\nCreate a `/src/lib/db.ts` file with the following content:\n\n/src/lib/db.ts\n\n```\nimport { PrismaClient } from '@prisma/client';export const prisma = new PrismaClient();\n```\n\nCreate a `/src/lib/auth.ts` file with the following content:\n\n/src/lib/auth.ts\n\n```\nimport { env } from '$env/dynamic/private';import type { User } from '@prisma/client';import jwt from 'jsonwebtoken';export const JWT_TOKEN_COOKIE_NAME = 'ZenStack-Blog-Token';export function createToken(user: User) {\treturn jwt.sign(\t\t{\t\t\tsub: user.id,\t\t\temail: user.email\t\t},\t\tenv.JWT_SECRET,\t\t{ expiresIn: '7d' }\t);}\n```\n\n### 7\\. Create a signup page[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#7-create-a-signup-page \"Direct link to 7. Create a signup page\")\n\ninfo\n\nFor real-world applications you should usually use a framework or service instead of building your own authentication solution. But since authentication is not the focus of this guide, we'll just implement a minimal email/password-based auth.\n\nCreate a `/src/routes/signup/+page.svelte` file with the following content:\n\n/src/routes/signup/+page.svelte\n\n```\n<script lang=\"ts\">    import { enhance } from '$app/forms';    import type { ActionData } from './$types';    export let form: ActionData;</script><div class=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">    <h1 class=\"text-5xl font-extrabold text-white\">Sign up</h1>    <form class=\"mt-16 flex flex-col gap-8 text-2xl\" method=\"post\" use:enhance>        {#if form?.dup}            <p class=\"text-red-600 my-2\">Email aready registered!</p>        {/if}        <div>            <label for=\"email\" class=\"inline-block w-32 text-white\"> Email </label>            <input                id=\"email\"                name=\"email\"                type=\"email\"                value={form?.email ?? ''}                class=\"ml-4 w-72 rounded border p-2\"            />        </div>        <div>            <label for=\"password\" class=\"inline-block w-32 text-white\"> Password </label>            <input id=\"password\" name=\"password\" type=\"password\" class=\"ml-4 w-72 rounded border p-2\" />        </div>        <input            type=\"submit\"            value=\"Create account\"            class=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"        />        <div class=\"mt-2 text-base font-medium text-gray-300\">            Already have an account?{' '}            <a href=\"/signin\" class=\"text-primary-700 underline\"> Login here </a>        </div>    </form></div>\n```\n\nThen create its server-side form handler `/src/routes/signup/+page.server.ts` with the following content:\n\n/src/routes/signup/+page.server.ts\n\n```\nimport { createToken, JWT_TOKEN_COOKIE_NAME } from '$lib/auth';import { fail, redirect, type Actions } from '@sveltejs/kit';import { isPrismaClientKnownRequestError, enhance } from '@zenstackhq/runtime';import { prisma } from '../../lib/db';export const actions = {    default: async ({ request, cookies }) => {        const data = await request.formData();        const email = data.get('email');        const password = data.get('password');        if (typeof email !== 'string' || typeof password !== 'string') {            return fail(400, { email, password, missing: true });        }        const db = enhance(prisma);        try {            // create the user together with a default space            const user = await db.user.create({                data: {                    email,                    password                }            });            // sign a JWT token and set it as a cookie            const token = createToken(user);            cookies.set(JWT_TOKEN_COOKIE_NAME, token, {                httpOnly: true,                expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),                path: '/'            });        } catch (err) {            if (isPrismaClientKnownRequestError(err) && err.code === 'P2002') {                // duplicated email                return fail(400, { email, password, dup: true });            } else {                throw err;            }        }        throw redirect(303, `/`);    }} satisfies Actions;\n```\n\nNow start the dev server by running:\n\nHit [http://localhost:5173/signup](http://localhost:5173/signup) and you should see the signup page like:\n\n![](https://zenstack.dev/img/get-started/sveltekit/signup.png)\n\nCreate an account to continue.\n\n### 8\\. Create a signin page[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#8-create-a-signin-page \"Direct link to 8. Create a signin page\")\n\nCreate a `/src/routes/signin/+page.svelte` file with the following content:\n\n/src/routes/signin/+page.svelte\n\n```\n<script lang=\"ts\">\timport { enhance } from '$app/forms';\timport type { ActionData } from '../signin/$types';\texport let form: ActionData;</script><div class=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">    <h1 class=\"text-5xl font-extrabold text-white\">Login</h1>    <form class=\"mt-16 flex flex-col gap-8 text-2xl\" method=\"post\" use:enhance>        {#if form?.invalid}            <p class=\"text-red-600 my-2\">Invalid credentials</p>        {/if}        <div>            <label for=\"email\" class=\"inline-block w-32 text-white\"> Email </label>            <input                id=\"email\"                name=\"email\"                type=\"email\"                value={form?.email ?? ''}                class=\"ml-4 w-72 rounded border p-2\"            />        </div>        <div>            <label for=\"password\" class=\"inline-block w-32 text-white\"> Password </label>            <input id=\"password\" name=\"password\" type=\"password\" class=\"ml-4 w-72 rounded border p-2\" />        </div>        <input            type=\"submit\"            value=\"Sign in to my account\"            class=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"        />        <div class=\"mt-2 text-base font-medium text-gray-300\">            Don't have an account yet?{' '}            <a href=\"/signup\" class=\"text-primary-700 underline\"> Signup here </a>        </div>    </form></div>\n```\n\nThen create its server-side form handler `/src/routes/signin/+page.server.ts` with the following content:\n\n/src/routes/signin/+page.server.ts\n\n```\nimport { JWT_TOKEN_COOKIE_NAME, createToken } from '$lib/auth';import { prisma } from '$lib/db';import { fail, redirect, type Actions } from '@sveltejs/kit';import bcrypt from 'bcryptjs';export const actions = {    default: async ({ request, cookies }) => {        const data = await request.formData();        const email = data.get('email');        const password = data.get('password');        if (typeof email !== 'string' || typeof password !== 'string') {            return fail(400, { email, password, missing: true });        }        const user = await prisma.user.findFirst({            where: { email }        });        if (!user || !bcrypt.compareSync(password, user.password)) {            return fail(401, { email, password, invalid: true });        }        const token = createToken(user);        cookies.set(JWT_TOKEN_COOKIE_NAME, token, {            httpOnly: true,            expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),            path: '/'        });        throw redirect(303, `/`);    }} satisfies Actions;\n```\n\nHit [http://localhost:5173/signin](http://localhost:5173/signin) and you should see the signin page like:\n\n![](https://zenstack.dev/img/get-started/sveltekit/signin.png)\n\nTry signing in with the account you just created.\n\n### 9\\. Create a server hook to add user and his corresponding db to context[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#9-create-a-server-hook-to-add-user-and-his-corresponding-db-to-context \"Direct link to 9. Create a server hook to add user and his corresponding db to context\")\n\nUse a [server hook](https://kit.svelte.dev/docs/hooks#server-hooks) to intercept requests, extract JWT token and decode it to user identity, create an access-policy-aware Prisma wrapper with the identity, and add both the user and db to the request context. When building the rest of pages in our app, we can fetch them directly from the `locals` context.\n\nFirst, update `/src/app.d.ts` to include `user` and `db` fields in the request context's typing:\n\n/src/app.d.ts\n\n```\nimport type { PrismaClient, User } from '@prisma/client';declare global {    namespace App {        interface Locals {            user?: User;            db: PrismaClient;        }    }}export {};\n```\n\nThen create server hooks `/src/hooks.server.ts`:\n\n/src/hooks.server.ts\n\n```\nimport { env } from '$env/dynamic/private';import { JWT_TOKEN_COOKIE_NAME } from '$lib/auth';import { prisma } from '$lib/db';import type { Handle } from '@sveltejs/kit';import { enhance } from '@zenstackhq/runtime';import jwt from 'jsonwebtoken';const auth = (async ({ event, resolve }) => {    const token = event.cookies.get(JWT_TOKEN_COOKIE_NAME);    if (token) {        try {            const decoded = jwt.verify(token, env.JWT_SECRET);            const user = await prisma.user.findUnique({                where: { id: decoded.sub as string }            });            if (user) {                event.locals.user = user;            } else {                console.warn('User not found:', decoded.sub);                event.cookies.delete(JWT_TOKEN_COOKIE_NAME, { path: '/' });            }        } catch {            event.cookies.delete(JWT_TOKEN_COOKIE_NAME, { path: '/' });        }    }    // create an enhanced PrismaClient that recognizes access policies    event.locals.db = enhance(prisma, {        user: event.locals.user ? { id: event.locals.user.id } : undefined    });    return resolve(event);}) satisfies Handle;export const handle = auth;\n```\n\n### 10\\. Build the post list page[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#10-build-the-post-list-page \"Direct link to 10. Build the post list page\")\n\nFinally we've got to build the main page of our app. For the sake of simplicity, we'll just put all UI directly in the page without further extracting components.\n\nReplace `/src/routes/+page.svelte` with the following content:\n\n/src/routes/+page.svelte\n\n```\n<script lang=\"ts\">    import { enhance } from '$app/forms';    import type { ActionData, PageData } from './$types';    export let data: PageData;    export let form: ActionData;</script><main class=\"flex flex-col min-h-screen items-center justify-center gap-12 px-4 py-16 text-white bg-gradient-to-b from-[#2e026d] to-[#15162c]\">    <h1 class=\"text-5xl font-extrabold\">My Awesome Blog</h1>    {#if data.user}        <div class=\"flex flex-col\">            <div class=\"flex gap-4\">                <h3 class=\"text-lg\">Welcome back, {data.user.email}</h3>                <form method=\"post\" action=\"?/signOut\">                    <button type=\"submit\" class=\"text-gray-300 underline\">Sign out</button>                </form>            </div>            <section class=\"mt-10 container flex flex-col text-white\">                <!-- create post -->                <form method=\"post\" action=\"?/create\" use:enhance>                    <input                        name=\"title\"                        type=\"text\"                        placeholder=\"Post title\"                        required                        class=\"text-lg text-black px-4 py-2 rounded mr-2\"                    />                    <button class=\"rounded border border-white px-4 py-2 text-lg\" type=\"submit\"                        >+ Create</button                    >                </form>                <!-- post list -->                <ul class=\"container mt-8 flex flex-col gap-2\">                    {#each data.posts as post (post.id)}                        <li class=\"flex items-end justify-between gap-4\">                            <!-- post info -->                            <p class={`text-2xl ${!post.published ? 'text-gray-400' : ''}`}>                                {post.title}                                <span class=\"text-lg\"> by {post.author.email}</span>                            </p>                            <!-- post management -->                            <div class=\"flex w-32 justify-end gap-1 text-left\">                                <form method=\"post\" action=\"?/togglePublish\" use:enhance>                                    <input type=\"hidden\" name=\"id\" value={post.id} />                                    <button class=\"underline\" type=\"submit\">                                        {post.published ? 'Unpublish' : 'Publish'}                                    </button>                                </form>                                <form method=\"post\" action=\"?/delete\" use:enhance>                                    <input type=\"hidden\" name=\"id\" value={post.id} />                                    <button class=\"underline\" type=\"submit\">Delete</button>                                </form>                            </div>                        </li>                    {/each}                </ul>                {#if form?.error}                    <p class=\"text-red-500 mt-4\">{form.error}</p>                {/if}            </section>        </div>    {:else}        <div class=\"flex gap-4 text-2xl\">            <a href=\"/signin\" class=\"rounded-lg border px-4 py-2\">Signin</a>            <a href=\"/signup\" class=\"rounded-lg border px-4 py-2\">Signup</a>        </div>    {/if}</main>\n```\n\nThen create a `/src/routes/+page.server.ts` file to handle page data loading and form actions:\n\n/src/routes/+page.server.ts\n\n```\nimport type { PageServerLoad } from './$types';import { fail, type Actions, redirect } from '@sveltejs/kit';import { JWT_TOKEN_COOKIE_NAME } from '$lib/auth';export const load: PageServerLoad = async ({ locals }) => {    const posts = await locals.db.post.findMany({ include: { author: true } });    return {        user: locals.user,        posts    };};export const actions: Actions = {    create: async ({ request, locals }) => {        const data = await request.formData();        const title = data.get('title');        if (typeof title !== 'string') {            return fail(400, { missing: true });        }        await locals.db.post.create({ data: { title } });        return { success: true };    },    togglePublish: async ({ request, locals }) => {        const data = await request.formData();        const postId = data.get('id');        if (typeof postId !== 'string') {            return fail(400, { missing: true });        }        const post = await locals.db.post.findUnique({ where: { id: postId } });        if (!post) {            return fail(404, { notFound: true });        }        try {            await locals.db.post.update({ where: { id: postId }, data: { published: !post.published } });            return { success: true };        } catch (err) {            // error can be thrown for reasons like access policy violation            return { error: `${err}` };        }    },    delete: async ({ request, locals }) => {        const data = await request.formData();        const postId = data.get('id');        if (typeof postId !== 'string') {            return fail(400, { missing: true });        }        try {            await locals.db.post.delete({ where: { id: postId } });            return { success: true };        } catch (err) {            // error can be thrown for reasons like access policy violation            return { error: `${err}` };        }    },    signOut: async ({ cookies }) => {        cookies.delete(JWT_TOKEN_COOKIE_NAME);        throw redirect(303, '/signin');    }};\n```\n\ntip\n\n‚ö°Ô∏è Here's the important thing:\n\nAs you can see, our server-side code doesn't contain any authorization logic. Yet our backend is still secure thanks to the access policies we defined in `schema.zmodel`. The enhanced Prisma client (fetched from `locals.db`) enforces that necessary filters and checks are injected when calling into the underlying Prisma client. Your ZModel is the **single source of truth** for access control.\n\n## Verifying the result[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#verifying-the-result \"Direct link to Verifying the result\")\n\nNow our app is complete and let's verify the result. Create two posts with your current account, and publish one of them:\n\n![](https://zenstack.dev/img/get-started/sveltekit/yiming-posts.png)\n\nNow, open a new incognito window and sign up a new account _[emily@zenstack.dev](mailto:emily@zenstack.dev)_. \"Post1\" should appear in her list, since our access policy allows all users to read published posts.\n\n![](https://zenstack.dev/img/get-started/sveltekit/emily-posts.png)\n\nWe didn't do any UI blocking to prevent Emily from unpublishing or deleting other people's posts; however, if she tries to do so, the operation will be rejected by the server-side code:\n\n![](https://zenstack.dev/img/get-started/sveltekit/update-error.png)\n\nIn a real application you can catch the error and render a proper message to the user.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/quick-start/sveltekit#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple but secure blogging app without writing any authorization logic. Pretty cool, isn't it?\n\nIn this tutorial, we used ZenStack only on the SSR side (loader and actions) of SvelteKit, but its power doesn't stop there. There're two more things worth your attention that enable more advanced scenarios:\n\n*   The [`@zenstackhq/server/sveltekit`](https://zenstack.dev/docs/reference/server-adapters/sveltekit) server adapter provides a SvelteKit hooks handler that installs an automatic CRUD API for database operations.\n    \n*   The [`@zenstackhq/tanstack-query`](https://zenstack.dev/docs/reference/plugins/tanstack-query) plugin provides automatic generation of client-side query and mutation hooks for consuming the afore-mentioned CRUD API.\n    \n\nThese two features combined allow you to build a typical SPA (CSR + API). You can also freely mix and match SSR and CSR as you wish.\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-sveltekit). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/category/reference) and [Recipes](https://zenstack.dev/docs/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "SvelteKit | ZenStack",
  "description": "Step-by-step guide for building a blogging app with SvelteKit.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/quick-start/nuxt",
  "markdown": "# Nuxt | ZenStack\n\n## Get Started With Nuxt (V3)\n\nNuxt is an excellent full-stack framework built around Vue.js. It provides the structure and facilities that help you build complete web apps with ease. In this tutorial, we'll demonstrate how to build a simple blogging app. You'll see how effortless it is to build a fully secure application with Nuxt and ZenStack combined.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-nuxt).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/quick-start/nuxt#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/quick-start/nuxt#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/quick-start/nuxt#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Creating a new project[‚Äã](https://zenstack.dev/docs/quick-start/nuxt#1-creating-a-new-project \"Direct link to 1. Creating a new project\")\n\nAlthough authentication is not the focus of the project, we need a basic signup/signin system to get going. The [Nuxt with Local Auth](https://github.com/nuxt/examples/tree/main/auth/local) sample can serve as a good starter.\n\nFirst, make a copy of the project using [degit](https://github.com/Rich-Harris/degit), install dependencies, and start the dev server:\n\n```\nnpx degit nuxt/examples/auth/local my-nuxt-blogcd my-nuxt-blognpm installnpm run dev\n```\n\nIf everything works, you should have a running Nuxt app at [http://localhost:3000](http://localhost:3000/).\n\n![](https://zenstack.dev/img/get-started/nuxt/initial.png)\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/quick-start/nuxt#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack. The CLI will also install Prisma dependencies too.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\nThe CLI generates a template `schema.zmodel` file containing data schema and access policies, which almost already satisfies our requirements. We only need to make some small tweaks to it:\n\n1.  Add a `name` field to the `User` model\n2.  Make the `User` model readable by all users\n\n/schema.zmodel\n\n```\nmodel User {    id String @id @default(cuid())    email String @unique @email+   name String?    password String @password @omit @length(8, 16)    posts Post[]    // everybody can signup    @@allow('create', true)+   // user profiles are public+   @@allow('read', true)    // full access by self    @@allow('all', auth() == this)}\n```\n\nLast, run `zenstack` CLI to regenerate Prisma schema, and sync it to the database:\n\n```\nnpx zenstack generatenpx prisma db push\n```\n\n### 3\\. Implementing authentication[‚Äã](https://zenstack.dev/docs/quick-start/nuxt#3-implementing-authentication \"Direct link to 3. Implementing authentication\")\n\nThe sample project already contains the basic structure for authentication APIs and UI, however it's not connected to the database yet. Let's do that now.\n\nFirst, create a `/server/prisma.ts` file to create and export a PrismaClient instance:\n\n/server/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client';export const prisma = new PrismaClient();\n```\n\nThen, replace the content of `/auth/server/utils/db.ts` with the following:\n\n/auth/server/utils/db.ts\n\n```\nimport type { User } from '@prisma/client';import { prisma } from '~/server/prisma';export async function findUserByEmail(email: string) {    return prisma.user.findUnique({ where: { email } });}export async function createUser(user: Omit<User, 'id'>) {    return prisma.user.create({        data: user,    });}\n```\n\nNow when user signs up or logs in, Prisma is used to create and retrive user data from the database.\n\nFinally, restart the dev server, and you should be able to create user account and login now.\n\n![](https://zenstack.dev/img/get-started/nuxt/signup.png)\n\n### 4\\. Mount CRUD service & generate hooks[‚Äã](https://zenstack.dev/docs/quick-start/nuxt#4-mount-crud-service--generate-hooks \"Direct link to 4. Mount CRUD service & generate hooks\")\n\nLet's take a review of the `Post` model in `schema.zmodel`:\n\n/schema.zmodel\n\n```\nmodel Post {    id String @id @default(cuid())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    title String @length(1, 256)    content String    published Boolean @default(false)    author User @relation(fields: [authorId], references: [id])    authorId String @default(auth().id)    // allow read for all signin users    @@allow('read', auth() != null && published)    // full access by author    @@allow('all', author == auth())}\n```\n\ninfo\n\nThe \"authorId\" field as a `@default()` attribute with `auth().id` value. The field will be automatically assigned with the current user's ID when creating a new record. See [here](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#using-auth-in-default) for more details.\n\nNotice how the access policies are defined in the schema to control who has what access to the data? To enforce these policies, we'll need to create an \"enhanced\" PrismaClient, like:\n\n```\nimport { enhance } from '@zenstackhq/runtime';const db = enhance(prisma, { user: ... });\n```\n\nAll CRUD calls made via the enhanced client will be subject to the access policies. Since the ORM is already secured, ZenStack can automatically mount a set of CRUD APIs onto your Nuxt app. To achieve it, first install an extra server adapter package:\n\n```\nnpm install @zenstackhq/server\n```\n\nThen, create a `/server/api/model/[...].ts` file with the following content:\n\n/server/api/model/\\[...\\].ts\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { createEventHandler } from '@zenstackhq/server/nuxt';import { prisma } from '~/server/prisma';export default createEventHandler({    getPrisma: async (event) => {        const session = await useAuthSession(event);        return enhance(prisma, {            user: session.data.id ? { id: session.data.id } : undefined,        });    },});\n```\n\ninfo\n\nThe \"\\[...\\].ts\" file name convention creates a \"catch all\" event handler that handles all requests sent to the `/api/model` endpoint and its descendants.\n\nThe CRUD APIs for all your models are now mounted to the `/api/model` endpoint.\n\n## 5\\. Generating client hooks\n\nWe can write frontend code to consume the CRUD APIs, but that would be quite boring. Instead, let's use a plugin to generate them for us. First, install the `@zenstackhq/tanstack-query` plugin package:\n\n```\nnpm install @tanstack/vue-query --forcenpm install -D @zenstackhq/tanstack-query\n```\n\ninfo\n\nThe `--force` flag is required due to a misconfigured dependency in `@tanstack/vue-query`.\n\nThen, add the following snippet to `schema.zmodel`:\n\n/schema.zmodel\n\n```\nplugin hooks {    provider = '@zenstackhq/tanstack-query'    target = 'vue'    output = 'lib/hooks'}\n```\n\nFinally, rerun `zenstack` CLI to trigger the generation:\n\nThe TanStack Query hooks will be generated under `/lib/hooks` and ready to be used in our frontend code.\n\n## 6\\. Building the home page\n\nWith all the preparation work done, we can build the page for creating and listing posts now!\n\nFirst, enable \"@tanstack/vue-query\" in the app by creating a plugin under `/plugins/vue-query.ts`:\n\n/plugins/vue-query.ts\n\n```\nimport { VueQueryPlugin, QueryClient } from '@tanstack/vue-query';export default defineNuxtPlugin((nuxt) => {    const queryClient = new QueryClient();    nuxt.vueApp.use(VueQueryPlugin, { queryClient });});\n```\n\nAlso, add the following `<script setup>` code to `/app.vue` to configure the API endpoint used by the query hooks:\n\n/app.vue\n\n```\n<script setup lang=\"ts\">import { provideHooksContext } from './lib/hooks';// Provide tanstack-query context// Use an absolute endpoint so server-side fetch works tooprovideHooksContext({    endpoint: 'http://localhost:3000/api/model',});</script>\n```\n\nThen, create a `Post` component under `/components/Post.vue` for rendering a single post:\n\n/components/Post.vue\n\n```\n<script setup lang=\"ts\">import { useDeletePost, useUpdatePost } from '~/lib/hooks';const props = defineProps({    id: String,    title: String,    author: {        type: Object,        default: () => ({ email: '' }),    },    published: Boolean,});const updatePost = useUpdatePost();const deletePost = useDeletePost();const onTogglePublish = async () => {    try {        await updatePost.mutateAsync({            where: { id: props.id },            data: { published: !props.published },        });    } catch (err: any) {        alert(err.info?.message ?? err);    }};const onDelete = async () => {    try {        await deletePost.mutateAsync({ where: { id: props.id } });    } catch (err: any) {        alert(err.info?.message ?? err);    }};</script><template>    <div class=\"flex justify-center\">        <div class=\"min-w-80\">            <span class=\"mr-4 text-lg font-semibold\">{{ title }}</span            ><span>by {{ author.email }}</span>        </div>        <div class=\"ml-8 space-x-2\">            <NButton @click=\"onTogglePublish\">{{                published ? 'Unpublish' : 'Publish'            }}</NButton>            <NButton @click=\"onDelete\">Delete</NButton>        </div>    </div></template>\n```\n\nFinally, update the content of `/pages/index.vue` to the following:\n\n/pages/index.vue\n\n```\n<script setup lang=\"ts\">import { useFindManyPost, useCreatePost } from '~/lib/hooks';const title = ref('');const createPost = useCreatePost();const onCreatePost = async () => {    try {        await createPost.mutateAsync({            data: {                title: title.value,                content: 'My awesome content',            },        });        title.value = '';    } catch (err: any) {        alert(err.info?.message ?? err);    }};const { data: posts } = useFindManyPost({ include: { author: true } });</script><template>    <h1 class=\"text-2xl font-bold my-4\">My Awesome Blog</h1>    <div v-if=\"session?.id\">        <div class=\"flex justify-center\">            <NTextInput                v-model=\"title\"                placeholder=\"Title\"                class=\"w-1/2 mr-4\"                @keyup.enter=\"onCreatePost\"            />            <NButton @click=\"onCreatePost\">Create Post</NButton>        </div>        <ul v-if=\"posts\" class=\"py-8 space-y-2\">            <li v-for=\"post in posts\" :key=\"post.id\">                <Post v-bind=\"post\" />            </li>        </ul>    </div></template>\n```\n\n### 5\\. Testing the app[‚Äã](https://zenstack.dev/docs/quick-start/nuxt#5-testing-the-app \"Direct link to 5. Testing the app\")\n\nNow you can create and manage posts in the home page.\n\n![](https://zenstack.dev/img/get-started/nuxt/posts.png)\n\nTry signing up another account in an incognito browser tab and publish a post. That post should be visible to the previous account too. Our policy rules are at work.\n\nYou may have noticed that a user can publish, unpublish, or delete other user's posts from the UI. That's because we haven't implemented any conditional rendering logic yet. However, if you try to do that, the server side will reject the request and keep the data safe. In a real application, you'll want to capture the error and show a proper message to the user.\n\n![](https://zenstack.dev/img/get-started/nuxt/rejected.png)\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/quick-start/nuxt#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple blogging app without writing a single backend API. Pretty cool, isn't it?\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-nuxt). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/category/reference) and [Guides](https://zenstack.dev/docs/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Nuxt | ZenStack",
  "description": "Step-by-step guide for building a blogging app with Nuxt V3.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/quick-start/remix-run",
  "markdown": "# Remix.run | ZenStack\n\n## Get Started With Remix.run\n\nRemix is an excellent framework that allows you to easily collocate data loading and mutation server-side logic with your client-side code. Let's have some fun by creating a simple blogging app. You'll see how effortless it is to build a fully secure application with Remix and ZenStack combined.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-remix).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new project[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#1-create-a-new-project \"Direct link to 1. Create a new project\")\n\nThe easiest way to create a Remix project with boilerplates is with `create-remix`. Run the following command to create a new project. When prompted, choose the following:\n\n*   Typescript or Javascript? **Typescript**\n*   Do you want me to run `npm install`? **Yes**\n\n```\nnpx create-remix@latest --template remix-run/indie-stack my-blog-appcd my-blog-appnpm run dev\n```\n\nIf everything works, you should have a running Remix app at [http://localhost:3000](http://localhost:3000/).\n\n![](https://zenstack.dev/img/remix-start.png)\n\nNow sign up for a new account to continue.\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\n### 3\\. Prepare the Blog model[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#3-prepare-the-blog-model \"Direct link to 3. Prepare the Blog model\")\n\nThe template project already contains a `Note` model. Let's repurpose it to be a `Post` model. Rename it from `Note` to `Post`, and add a `published` field to store if the post is published or not. Also add access control rules with `@@allow` attribute to authorize requests.\n\n/schema.zmodel\n\n```\nmodel Post {  id String @id @default(cuid())  title String  body String  published Boolean @default(false)  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)  userId String @default(auth().id)  // author has full access  @@allow('all', auth() == user)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\ninfo\n\nThe \"userId\" field as a `@default()` attribute with `auth().id` value. The field will be automatically assigned with the current user's ID when creating a new record. See [here](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#using-auth-in-default) for more details.\n\ninfo\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/the-complete-guide/part1/access-policy) for more details.\n\nAlso we need to rename the relation in the `User` model from `notes` to `posts`.\n\n/schema.zmodel\n\n```\nmodel User {  id String @id @default(cuid())  email String @unique  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  password Password?  posts Post[]}\n```\n\nNow let's regenerate `schema.prisma` and push schema changes to the database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 4\\. Clean up unused files[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#4-clean-up-unused-files \"Direct link to 4. Clean up unused files\")\n\nRemove a few files and folders that are not needed anymore:\n\n*   /app/models/note.server.ts\n*   /app/routes/note.tsx\n*   /app/routes/notes\n\n### 5\\. Build up the blog homepage[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#5-build-up-the-blog-homepage \"Direct link to 5. Build up the blog homepage\")\n\nFirst add a helper method to `/app/db.server.ts` to get an access-policy-enabled prisma client. We'll use this wrapper to manipulate the `Post` model.\n\n/app/db.server.ts\n\n```\nimport { enhance } from '@zenstackhq/runtime';export function getEnhancedPrisma(userId: string) {    return enhance(prisma, { user: { id: userId } });}\n```\n\nCreate `/app/models/post.server.ts` with the following content:\n\n```\nimport type { User } from '@prisma/client';import { getEnhancedPrisma } from '~/db.server';export function getPosts({ userId }: { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.findMany({        orderBy: { updatedAt: 'desc' },    });}\n```\n\nNotice that we don't need to filter the posts by user id? Still at runtime, only posts belonging to the current user will be returned. This is because of the access policy we previously defined in the `Post` model.\n\nLet's create a new page at `/app/routes/posts.tsx` for listing and managing our blog posts.\n\n/app/routes/posts.tsx\n\n```\nimport type { LoaderArgs } from '@remix-run/node';import { json } from '@remix-run/node';import { Form, Link, NavLink, Outlet, useLoaderData } from '@remix-run/react';import { getPosts } from '~/models/post.server';import { requireUserId } from '~/session.server';import { useUser } from '~/utils';export async function loader({ request }: LoaderArgs) {    const userId = await requireUserId(request);    const posts = await getPosts({ userId });    return json({ posts });}export default function PostsPage() {    const data = useLoaderData<typeof loader>();    const user = useUser();    return (        <div className=\"flex h-full min-h-screen flex-col\">            <header className=\"flex items-center justify-between bg-slate-800 p-4 text-white\">                <h1 className=\"text-3xl font-bold\">                    <Link to=\".\">Posts</Link>                </h1>                <p>{user.email}</p>                <Form action=\"/logout\" method=\"post\">                    <button                        type=\"submit\"                        className=\"rounded bg-slate-600 py-2 px-4 text-blue-100 hover:bg-blue-500 active:bg-blue-600\"                    >                        Logout                    </button>                </Form>            </header>            <main className=\"flex h-full bg-white\">                <div className=\"h-full w-80 border-r bg-gray-50\">                    <Link to=\"new\" className=\"block p-4 text-xl text-blue-500\">                        + New Post                    </Link>                    <hr />                    {data.posts.length === 0 ? (                        <p className=\"p-4\">No posts yet</p>                    ) : (                        <ol>                            {data.posts.map((post) => (                                <li key={post.id}>                                    <NavLink                                        className={({ isActive }) =>                                            `block border-b p-4 text-xl ${isActive ? 'bg-white' : ''}`                                        }                                        to={post.id}                                    >                                        üìù {post.title}                                    </NavLink>                                </li>                            ))}                        </ol>                    )}                </div>                <div className=\"flex-1 p-6\">                    <Outlet />                </div>            </main>        </div>    );}\n```\n\nRestart your dev server and hit [http://localhost:3000/posts](http://localhost:3000/posts), you should see something like this:\n\n![](https://zenstack.dev/img/remix-posts.png)\n\n### 6\\. Build up the create post page[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#6-build-up-the-create-post-page \"Direct link to 6. Build up the create post page\")\n\nFirst add a function to `/app/models/post.server.ts` for creating a new post.\n\n/app/models/post.server.ts\n\n```\nimport type { Post } from '@prisma/client';export function createPost({ body, title, userId }: Post & { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.create({        data: { title, body },    });}\n```\n\nAdd `/app/routes/posts/new.tsx` with the following content:\n\n/app/routes/posts/new.tsx\n\n```\nimport type { ActionArgs } from '@remix-run/node';import { json, redirect } from '@remix-run/node';import { Form, useActionData } from '@remix-run/react';import * as React from 'react';import { createPost } from '~/models/post.server';import { requireUserId } from '~/session.server';export async function action({ request }: ActionArgs) {    const userId = await requireUserId(request);    const formData = await request.formData();    const title = formData.get('title');    const body = formData.get('body');    if (typeof title !== 'string' || title.length === 0) {        return json({ errors: { title: 'Title is required', body: null } }, { status: 400 });    }    if (typeof body !== 'string' || body.length === 0) {        return json({ errors: { title: null, body: 'Body is required' } }, { status: 400 });    }    const post = await createPost({ title, body, userId });    return redirect(`/posts/${post.id}`);}export default function NewPostPage() {    const actionData = useActionData<typeof action>();    const titleRef = React.useRef<HTMLInputElement>(null);    const bodyRef = React.useRef<HTMLTextAreaElement>(null);    React.useEffect(() => {        if (actionData?.errors?.title) {            titleRef.current?.focus();        } else if (actionData?.errors?.body) {            bodyRef.current?.focus();        }    }, [actionData]);    return (        <Form            method=\"post\"            style={{                display: 'flex',                flexDirection: 'column',                gap: 8,                width: '100%',            }}        >            <div>                <label className=\"flex w-full flex-col gap-1\">                    <span>Title: </span>                    <input                        ref={titleRef}                        name=\"title\"                        className=\"flex-1 rounded-md border-2 border-blue-500 px-3 text-lg leading-loose\"                        aria-invalid={actionData?.errors?.title ? true : undefined}                        aria-errormessage={actionData?.errors?.title ? 'title-error' : undefined}                    />                </label>                {actionData?.errors?.title && (                    <div className=\"pt-1 text-red-700\" id=\"title-error\">                        {actionData.errors.title}                    </div>                )}            </div>            <div>                <label className=\"flex w-full flex-col gap-1\">                    <span>Body: </span>                    <textarea                        ref={bodyRef}                        name=\"body\"                        rows={8}                        className=\"w-full flex-1 rounded-md border-2 border-blue-500 py-2 px-3 text-lg leading-6\"                        aria-invalid={actionData?.errors?.body ? true : undefined}                        aria-errormessage={actionData?.errors?.body ? 'body-error' : undefined}                    />                </label>                {actionData?.errors?.body && (                    <div className=\"pt-1 text-red-700\" id=\"body-error\">                        {actionData.errors.body}                    </div>                )}            </div>            <div className=\"text-right\">                <button                    type=\"submit\"                    className=\"rounded bg-blue-500 py-2 px-4 text-white hover:bg-blue-600 focus:bg-blue-400\"                >                    Save                </button>            </div>        </Form>    );}\n```\n\n### 7\\. Build up the post details page[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#7-build-up-the-post-details-page \"Direct link to 7. Build up the post details page\")\n\nFirst add a few functions to `/app/models/post.server.ts` for manipulating a single post.\n\n/app/models/post.server.ts\n\n```\nexport function getPost({    id,    userId,}: Pick<Post, 'id'> & {    userId: User['id'];}) {    return getEnhancedPrisma(userId).post.findUnique({        where: { id },    });}export function deletePost({ id, userId }: Pick<Post, 'id'> & { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.delete({        where: { id },    });}export function publishPost({ id, userId }: Pick<Post, 'id'> & { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.update({        where: { id },        data: { published: true },    });}export function unpublishPost({ id, userId }: Pick<Post, 'id'> & { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.update({        where: { id },        data: { published: false },    });}\n```\n\nCreate `/app/routes/posts/$postId.tsx` with the following content:\n\n```\nimport type { ActionArgs, LoaderArgs } from '@remix-run/node';import { json, redirect } from '@remix-run/node';import { Form, useCatch, useLoaderData } from '@remix-run/react';import invariant from 'tiny-invariant';import { deletePost, getPost, publishPost, unpublishPost } from '~/models/post.server';import { requireUserId } from '~/session.server';export async function loader({ request, params }: LoaderArgs) {    const userId = await requireUserId(request);    invariant(params.postId, 'await not found');    const post = await getPost({ userId, id: params.postId });    if (!post) {        throw new Response('Not Found', { status: 404 });    }    return json({ post });}export async function action({ request, params }: ActionArgs) {    const userId = await requireUserId(request);    invariant(params.postId, 'postId not found');    const intent = (await request.formData()).get('intent');    switch (intent) {        case 'delete':            await deletePost({ userId, id: params.postId });            return redirect('/posts');        case 'publish':            await publishPost({ userId, id: params.postId });            return null;        case 'unpublish':            await unpublishPost({ userId, id: params.postId });            return null;    }}export default function PostDetailsPage() {    const data = useLoaderData<typeof loader>();    return (        <div>            <h3 className=\"text-2xl font-bold\">                {data.post.title} {!data.post.published && <span className=\"text-base font-normal italic\">Draft</span>}            </h3>            <p className=\"py-6\">{data.post.body}</p>            <hr className=\"my-4\" />            <div className=\"flex gap-2\">                <Form method=\"post\">                    <input type=\"hidden\" name=\"intent\" value=\"delete\" />                    <button                        type=\"submit\"                        className=\"rounded bg-blue-500  py-2 px-4 text-white hover:bg-blue-600 focus:bg-blue-400\"                    >                        Delete                    </button>                </Form>                <Form method=\"post\">                    <input type=\"hidden\" name=\"intent\" value={data.post.published ? 'unpublish' : 'publish'} />                    <button                        type=\"submit\"                        className=\"rounded bg-blue-500  py-2 px-4 text-white hover:bg-blue-600 focus:bg-blue-400\"                    >                        {data.post.published ? 'Unpublish' : 'Publish'}                    </button>                </Form>            </div>        </div>    );}export function ErrorBoundary({ error }: { error: Error }) {    console.error(error);    return <div>An unexpected error occurred: {error.message}</div>;}export function CatchBoundary() {    const caught = useCatch();    if (caught.status === 404) {        return <div>Post not found</div>;    }    throw new Error(`Unexpected caught response with status: ${caught.status}`);}\n```\n\nThen, add `/app/routes/posts/index.tsx` to show default content when no post is selected:\n\n/app/routes/posts/index.tsx\n\n```\nimport { Link } from '@remix-run/react';export default function PostIndexPage() {    return (        <p>            No post selected. Select a post on the left, or{' '}            <Link to=\"new\" className=\"text-blue-500 underline\">                create a new post.            </Link>        </p>    );}\n```\n\nFinally, update `/app/routes/index.tsx` to change the main link to our posts page:\n\n/app/routes/index.tsx\n\n```\n<Link    to=\"/posts\"    className=\"flex items-center justify-center rounded-md border border-transparent bg-white px-4 py-3 text-base font-medium text-yellow-700 shadow-sm hover:bg-yellow-50 sm:px-8\">    View Posts for {user.email}</Link>\n```\n\n### 8\\. Test it out![‚Äã](https://zenstack.dev/docs/quick-start/remix-run#8-test-it-out \"Direct link to 8. Test it out!\")\n\nüéâ Congratulations! You've made a simple blogging app without manually implementing any access control logic. Now test it out and see if you can create posts and manage them.\n\n![](https://zenstack.dev/img/remix-test-it.png)\n\nSince we haven't hidden \"Unpublish\" and \"Delete\" buttons for posts not owned by the current user, you can still click them even for posts not owned to you, but it will end up with an error. Even if you forget to block certain actions from the frontend, our access control logic will still prevent them from happening.\n\n![](https://zenstack.dev/img/remix-forbidden.png)\n\nYou can catch the error and render a nice message to the user.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/quick-start/remix-run#wrap-up \"Direct link to Wrap up\")\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-remix). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/category/reference) and [Guides](https://zenstack.dev/docs/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Remix.run | ZenStack",
  "description": "Step-by-step guide for building a blogging app with Remix.run.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/quick-start/nestjs",
  "markdown": "# NestJS | ZenStack\n\n## Get Started With NestJS\n\nNestJS is one of the most popular Node.js/TypeScript backend frameworks for building APIs. ZenStack provides a module for easily integrating with NestJS applications that use Prisma ORM. With the integration, you'll have access to an enhanced Prisma service with built-in access control, while continue enjoying the same Prisma APIs that you're familiar with.\n\nLet's see how it works by creating a simple blogging API. You can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-nestjs).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Users can create posts for themselves.\n2.  Post owner can update their own posts.\n3.  Users cannot make changes to posts that do not belong to them.\n4.  Published posts can be viewed by everyone.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new NestJS project[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#1-create-a-new-nestjs-project \"Direct link to 1. Create a new NestJS project\")\n\n```\nnpx @nestjs/cli@latest new -p npm my-blog-appcd my-blog-app\n```\n\n### 2\\. Set up Prisma[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#2-set-up-prisma \"Direct link to 2. Set up Prisma\")\n\n```\nnpm install -D prismanpx prisma init\n```\n\nThis will create a Prisma schema under `prisma/schema.prisma`. Replace its content with the following:\n\n/prisma/schema.prisma\n\n```\ndatasource db {  provider = \"sqlite\"  url = \"file:./dev.db\"}generator client {  provider = \"prisma-client-js\"}model User {  id Int @id() @default(autoincrement())  name String  posts Post[]}model Post {  id Int @id() @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt()  title String  published Boolean @default(false)  author User @relation(fields: [authorId], references: [id])  authorId Int @default(auth().id)}\n```\n\nNow, generate `PrismaClient` and push the schema to the database:\n\n```\nnpx prisma generatenpx prisma db push\n```\n\nCreate a `PrismaService` which will be injected into the API controllers later.\n\n/src/prisma.service.ts\n\n```\nimport { Injectable, OnModuleInit } from '@nestjs/common';import { PrismaClient } from '@prisma/client';@Injectable()export class PrismaService extends PrismaClient implements OnModuleInit {  async onModuleInit() {    await this.$connect();  }}\n```\n\nFinally, add the `PrismaService` to the app module as a provider:\n\n/src/app.module.ts\n\n```\nimport { PrismaService } from './prisma.service';@Module({  imports: [],  controllers: [AppController],  providers: [PrismaService],})export class AppModule {}\n```\n\n### 3\\. Create CRUD controllers[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#3-create-crud-controllers \"Direct link to 3. Create CRUD controllers\")\n\nNow let's create the CRUD API controller for `User` and `Post` models. In a real application, you'll want to have `UserService` and `PostService` to encapsulate database operations. For simplicity, we'll put everything in the controller here.\n\n/src/app.controller.ts\n\n```\nimport { Body, Controller, Get, Param, Post, Put } from '@nestjs/common';import { PrismaService } from './prisma.service';@Controller()export class AppController {  constructor(private readonly prismaService: PrismaService) {}  @Post('users')  async signup(@Body() userData: { name: string }) {    return this.prismaService.user.create({ data: userData });  }  @Get('posts')  async getAllPosts() {    return this.prismaService.post.findMany();  }  @Post('posts')  async createDraft(@Body() postData: { title: string; authorId: number }) {    return this.prismaService.post.create({      data: postData,    });  }  @Put('posts/publish/:id')  async publishPost(@Param('id') id: string) {    return this.prismaService.post.update({      where: { id: Number(id) },      data: { published: true },    });  }}\n```\n\nNow, we can start the dev server:\n\nLet's make a few requests to create a user and two posts:\n\n```\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"name\": \"Joey\"}' localhost:3000/userscurl -X POST -H \"Content-Type: application/json\" -d '{\"title\": \"My first post\", \"authorId\": 1}' localhost:3000/postscurl -X POST -H \"Content-Type: application/json\" -d '{\"title\": \"My second post\", \"authorId\": 1}' localhost:3000/postscurl localhost:3000/posts\n```\n\nThe result should look like:\n\n```\n[  {    \"authorId\" : 1,    \"createdAt\" : \"2024-03-27T18:16:27.289Z\",    \"id\" : 1,    \"published\" : false,    \"title\" : \"My first post\",    \"updatedAt\" : \"2024-03-27T18:16:27.289Z\"  },  {    \"authorId\" : 1,    \"createdAt\" : \"2024-03-27T18:16:35.302Z\",    \"id\" : 2,    \"published\" : false,    \"title\" : \"My second post\",    \"updatedAt\" : \"2024-03-27T18:16:35.302Z\"  }]\n```\n\n### 4\\. Set up authentication[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#4-set-up-authentication \"Direct link to 4. Set up authentication\")\n\nOur basic CRUD APIs are up and running. However it's not secured yet. Protecting an API involves two parts: authentication (identifying who's making the request) and authorization (deciding if the requester is allowed to perform the operation).\n\nLet's deal with authentication first. NestJS has [detailed documentation](https://docs.nestjs.com/security/authentication) for implementing authentication. In this guide, we'll simply use a fake one that directly passes user ID in a HTTP header. To allow services and controllers to access the authenticatd user, we'll use the [nestjs-cls](https://www.npmjs.com/package/nestjs-cls) package to put the user information into Node.js's [AsyncLocalStorage](https://nodejs.org/api/async_context.html#async_context_class_asynclocalstorage).\n\nFirst, install the `nestjs-cls` package:\n\nThen, mount the CLS module:\n\n/src/app.module.ts\n\n```\nimport { ClsModule, ClsService } from 'nestjs-cls';@Module({  imports: [    ClsModule.forRoot({      global: true,      middleware: {        mount: true,      },    }),  ],  ...})export class AppModule {}\n```\n\nNow, let's create a NestJS interceptor to extract the user ID from the HTTP header and put it into the CLS context:\n\n/src/auth.interceptor.ts\n\n```\nimport {  CallHandler,  ExecutionContext,  Injectable,  NestInterceptor,} from '@nestjs/common';import { ClsService } from 'nestjs-cls';@Injectable()export class AuthInterceptor implements NestInterceptor {  constructor(private readonly cls: ClsService) {}  async intercept(context: ExecutionContext, next: CallHandler) {    const request = context.switchToHttp().getRequest();    const userId = request.headers['x-user-id'];    if (userId) {      this.cls.set('auth', { id: Number(userId) });    }    return next.handle();  }}\n```\n\nThen, add the interceptor to `AppModule`:\n\n/src/app.module.ts\n\n```\nimport { APP_INTERCEPTOR } from '@nestjs/core';import { AuthInterceptor } from './auth.interceptor';@Module({  ...  providers: [    PrismaService,    {      provide: APP_INTERCEPTOR,      useClass: AuthInterceptor,    },  ],})export class AppModule {}\n```\n\nNow we will be able to inject the `ClsService` into the controllers and services as needed to fetch the current authenticated user.\n\n### 5\\. Set up ZenStack[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#5-set-up-zenstack \"Direct link to 5. Set up ZenStack\")\n\nZenStack allows you to define access policies inside your data schema. Let's install it first.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\nAdd the following access policies to the `User` and `Post` models:\n\n/schema.zmodel\n\n```\nmodel User {  id Int @id() @default(autoincrement())  name String  posts Post[]  // anyone can sign up, and user profiles are public  @@allow('create,read', true)  // users have full access to their own profile  @@allow('all', auth() == this)}model Post {  id Int @id() @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt()  title String  published Boolean @default(false)  author User? @relation(fields: [authorId], references: [id])  authorId Int?  // author has full access  @@allow('all', auth() == author)  // published posts are readable to all  @@allow('read', published)}\n```\n\ninfo\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/the-complete-guide/part1/access-policy) for more details.\n\nNow regenerate `PrismaClient` and other supporting files needed by ZenStack:\n\n### 6\\. Use ZenStack in the controller[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#6-use-zenstack-in-the-controller \"Direct link to 6. Use ZenStack in the controller\")\n\nOne of the main things ZenStack does is to create an \"enhanced\" `PrismaClient` that automatically enforces access policies. To do that, simply call the `enhance` API with an existing client and a user context:\n\n```\nconst enhancedPrisma = enhance(prisma, { user: ... });\n```\n\nIn a NestJS application, since everything is a dependency injection, we need to create the enhanced client in a DI-compatible way. Fortunately, ZenStack offers a module to make such integration easy. First, install the server adapter package:\n\n```\nnpm install @zenstackhq/server@latest\n```\n\nThen, register the `ZenStackModule` onto the app module:\n\n/src/app.module.ts\n\n```\nimport { ZenStackModule } from '@zenstackhq/server/nestjs';import { enhance } from '@zenstackhq/runtime';@Module({  imports: [    ...    ZenStackModule.registerAsync({      useFactory: (prisma: PrismaService, cls: ClsService) => {        return {          getEnhancedPrisma: () => enhance(prisma, { user: cls.get('auth') }),        };      },      inject: [PrismaService, ClsService],      extraProviders: [PrismaService],    }),  ],  ...})export class AppModule {}\n```\n\nNote that the `ZenStackModule` registration is done with a factory function that returns a config used for creating an enhanced prisma service. The config contains a callback function where you should create and return an enhanced `PrismaClient`. It'll be called each time a Prisma method is invoked. It's important to fetch the auth data inside the callback so that it correctly returns the data bound to the current request context.\n\ninfo\n\nThe enhanced clients are lightweighted Javascript proxies. They are cheap to create and don't incur new connections to the database.\n\nThe `ZenStackModule` provides an enhanced `PrismaService` with the token name `ENHANCED_PRISMA`. You can use both the regular `PrismaService` and enhanced one in your services and controllers. To use the regular prisma client, simply inject the `PrismaService` as usual. To use the enhanced one, inject it with token name `ENHANCED_PRISMA`.\n\nLet's change our controller to use the enhanced prisma service:\n\n/src/app.controller.ts\n\n```\nimport { ENHANCED_PRISMA } from '@zenstackhq/server/nestjs';@Controller()export class AppController {  constructor(    @Inject(ENHANCED_PRISMA) private readonly prismaService: PrismaService,  ) {}  ...}\n```\n\n### 7\\. Test the secured API[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#7-test-the-secured-api \"Direct link to 7. Test the secured API\")\n\nNow, restart the dev server, and let's make a few requests to see if the access policies are enforced.\n\n*   Listing posts without a user identity should return an empty array:\n    \n    ```\n    curl localhost:3000/posts\n    ```\n    \n*   Listing posts with a user identity should return all posts owned by the user:\n    \n    ```\n    curl -H \"x-user-id:1\" localhost:3000/posts\n    ```\n    \n    ```\n    [  {    \"authorId\" : 1,    \"createdAt\" : \"2024-03-27T18:16:27.289Z\",    \"id\" : 1,    \"published\" : false,    \"title\" : \"My first post\",    \"updatedAt\" : \"2024-03-27T18:16:27.289Z\"  },  {    \"authorId\" : 1,    \"createdAt\" : \"2024-03-27T18:16:35.302Z\",    \"id\" : 2,    \"published\" : false,    \"title\" : \"My second post\",    \"updatedAt\" : \"2024-03-27T18:16:35.302Z\"  }]\n    ```\n    \n*   Published posts are readable to all:\n    \n    First, publish a post with its owner's identity.\n    \n    ```\n    curl -X PUT -H \"x-user-id:1\" localhost:3000/posts/publish/1\n    ```\n    \n    ```\n    {  \"authorId\" : 1,  \"createdAt\" : \"2024-03-27T18:16:27.289Z\",  \"id\" : 1,  \"published\" : true,  \"title\" : \"My first post\",  \"updatedAt\" : \"2024-03-27T18:42:19.043Z\"}\n    ```\n    \n    Then, list all posts without a user identity:\n    \n    ```\n    curl localhost:3000/posts\n    ```\n    \n    ```\n    {  \"authorId\" : 1,  \"createdAt\" : \"2024-03-27T18:16:27.289Z\",  \"id\" : 1,  \"published\" : true,  \"title\" : \"My first post\",  \"updatedAt\" : \"2024-03-27T18:42:19.043Z\"}\n    ```\n    \n\n## Wrap up[‚Äã](https://zenstack.dev/docs/quick-start/nestjs#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple but secure blogging API without writing any authorization code. Pretty cool, isn't it?\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-nestjs). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/category/reference) and [Guides](https://zenstack.dev/docs/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "NestJS | ZenStack",
  "description": "Steps for using ZenStack in a NestJS application.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/quick-start/backend",
  "markdown": "# Backend-only Usage | ZenStack\n\nZenStack gives you a pleasant type-safe approach for calling your database \"directly\" from the frontend without coding a backend. Moreover, even if you're only building the backend side of an app, it can still help by defining access policies right inside your data model. This results in a security model that's both easier to maintain and more reliable than a manually implemented one.\n\nLet's have some fun by creating a simple blogging service with Express.js. You can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-express).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/quick-start/backend#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Users can create posts for themselves.\n2.  Post owner can update/publish/unpublish/delete their own posts.\n3.  Users cannot make changes to posts that do not belong to them.\n4.  Published posts can be viewed by all users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/quick-start/backend#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/quick-start/backend#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new Prisma project[‚Äã](https://zenstack.dev/docs/quick-start/backend#1-create-a-new-prisma-project \"Direct link to 1. Create a new Prisma project\")\n\nPrisma has a nice sample project for Express.js. Let's use it as a starting point:\n\n```\nnpx degit prisma/prisma-examples/typescript/rest-express my-blog-appcd my-blog-appnpm install\n```\n\nNext, let's initialize the database with seed data and start the dev server:\n\n```\nnpx prisma db pushnpx prisma db seednpm run dev\n```\n\nYour server should be listening on port 3000 for RESTful requests.\n\nLet's add a simple API to list all posts:\n\n/src/index.ts\n\n```\napp.get(`/post`, async (req, res) => {    const post = await prisma.post.findMany({        include: { author: true },    });    res.json(post);});\n```\n\nRestart the server and verify it works by:\n\nYou should see a list of posts like this:\n\n```\n[    {        \"id\": 1,        \"createdAt\": \"2023-01-14T06:46:52.628Z\",        \"updatedAt\": \"2023-01-14T06:46:52.628Z\",        \"title\": \"Join the Prisma Slack\",        \"content\": \"https://slack.prisma.io\",        \"published\": true,        \"viewCount\": 0,        \"authorId\": 1,        \"author\": { \"id\": 1, \"email\": \"alice@prisma.io\", \"name\": \"Alice\" }    },    ...]\n```\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/quick-start/backend#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\n### 3\\. Add access policies[‚Äã](https://zenstack.dev/docs/quick-start/backend#3-add-access-policies \"Direct link to 3. Add access policies\")\n\nOur bootstrapped `schema.zmodel` file already has a `User` and a `Post` model defined. However, they don't carry any access policies. So if you use a plain Prisma client in the backend code, anyone can do anything to any data unless you write some custom authorization logic.\n\nYou need two things to secure it up:\n\n1.  Implement an authentication mechanism to identify the current user.\n2.  Implement authorization to control who can take which actions to what data.\n\n#1 can usually be achieved by requiring a session cookie or a JWT token. For simplicity, we'll skip this part in the tutorial and just pass user id in a plain `X-USER-ID` header. We'll focus on #2 and utilize ZenStack to implement authorization without manually coding it.\n\nLet's add the following access policies to the `User` and `Post` model to implement the requirements we laid out previously:\n\n/schema.zmodel\n\n```\nmodel User {    id Int @id() @default(autoincrement())    email String @unique()    name String?    posts Post[]    // make user profile public    @@allow('read', true)}model Post {    id Int @id() @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    title String    content String?    published Boolean @default(false)    viewCount Int @default(0)    author User? @relation(fields: [authorId], references: [id])    authorId Int? @default(auth().id)    // author has full access    @@allow('all', auth() == author)    // logged-in users can view published posts    @@allow('read', auth() != null && published)}\n```\n\ninfo\n\nThe \"authorId\" field as a `@default()` attribute with `auth().id` value. The field will be automatically assigned with the current user's ID when creating a new record. See [here](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#using-auth-in-default) for more details.\n\ninfo\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/the-complete-guide/part1/access-policy) for more details.\n\nNow flush the changes to the Prisma schema and database schema:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 4\\. Secure the APIs[‚Äã](https://zenstack.dev/docs/quick-start/backend#4-secure-the-apis \"Direct link to 4. Secure the APIs\")\n\nNow let's secure up our APIs, leveraging the access policies.\n\nFirst, add a simple middleware to require `X-USER-ID` header (to simulate authentication). Make sure the following code is inserted above all express routes so it can be applied to all endpoints.\n\n/src/index.ts\n\n```\napp.use((req, res, next) => {    const userId = req.header('X-USER-ID');    if (!userId || Number.isNaN(parseInt(userId))) {        res.status(403).json({ error: 'unauthorized' });    } else {        next();    }});\n```\n\nNext, add two helper methods to get a Prisma client that's bound to the current user identity:\n\n/src/index.ts\n\n```\nimport { Request } from 'express';import { enhance } from '@zenstackhq/runtime';function getUserId(req: Request) {    return parseInt(req.header('X-USER-ID')!);}// Gets a Prisma client bound to the current user identityfunction getPrisma(req: Request) {    const userId = getUserId(req);    const user = Number.isNaN(userId) ? undefined : { id: userId };    return enhance(prisma, { user });}\n```\n\ntip\n\n`enhance` is a ZenStack runtime API that wraps a Prisma client and enhances it with access policy checks.\n\nThen, change our `POST /post` API to use extracted user id instead of passing in user email in the body when creating a new post:\n\n/src/index.ts\n\n```\napp.post(`/post`, async (req, res) => {    const { title, content } = req.body;    const result = await prisma.post.create({        data: { title, content },    });    res.json(result);});\n```\n\nFinally, change all code that uses `prisma` to `getPrisma(req)`. Here I'm showing only one occurrence:\n\n/src/index.ts\n\n```\napp.get(`/post`, async (req, res) => {    const post = await getPrisma(req).post.findMany({        include: { author: true },    });    res.json(post);});\n```\n\nNote that you don't need to change your Prisma query because the wrapped Prisma client has exactly the same API as the original Prisma client.\n\n### 5\\. Test the secured backend[‚Äã](https://zenstack.dev/docs/quick-start/backend#5-test-the-secured-backend \"Direct link to 5. Test the secured backend\")\n\nNow, restart the server and hit the `/post` endpoint again directly. You should get a 403 error because the middleware rejected it:\n\n```\ncurl -I localhost:3000/post\n```\n\n```\n  HTTP/1.1 403 Forbidden  X-Powered-By: Express  Content-Type: application/json; charset=utf-8  Content-Length: 24  ETag: W/\"18-gH7/fIZxPCVRh6TuPVNAgHt/40I\"  Date: Sat, 14 Jan 2023 08:08:10 GMT  Connection: keep-alive  Keep-Alive: timeout=5\n```\n\nWe can make it work by specifying `X-USER-ID` header:\n\n```\ncurl -H \"X-USER-ID: 1\" localhost:3000/post\n```\n\nLet's create a new unpublished post for user#1:\n\n```\ncurl --request POST \\    -H \"X-USER-ID: 1\" -H \"Content-Type: application/json\" \\    -d '{\"title\": \"My new post\", \"content\": \"Some awesome content\"}' \\    localhost:3000/post\n```\n\n, and hit `/post` API again with user#1:\n\n```\ncurl -H \"X-USER-ID: 1\" localhost:3000/post\n```\n\nYou should see in the result the newly created post:\n\n```\n[    ...    {        \"id\": 4,        \"createdAt\": \"2023-01-14T08:42:56.833Z\",        \"updatedAt\": \"2023-01-14T08:42:56.833Z\",        \"title\": \"My new post\",        \"content\": \"Some awesome content\",        \"published\": false,        \"viewCount\": 0,        \"authorId\": 1,        \"author\": { \"id\": 1, \"email\": \"alice@prisma.io\", \"name\": \"Alice\" }    }]\n```\n\nHowever, if you hit `/post` API with user#2:\n\n```\ncurl -H \"X-USER-ID: 2\" localhost:3000/post\n```\n\n, you won't see the new post because it's not published yet. Our access policies are at work.\n\nFeel free to play more with updating and deleting posts with different user ids and see if the policies work as expected.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/quick-start/backend#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple but secure blogging service without writing any authorization code. Pretty cool, isn't it?\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-express). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/category/reference) and [Guides](https://zenstack.dev/docs/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Backend-only Usage | ZenStack",
  "description": "Steps for using ZenStack only in backend development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/",
  "markdown": "# ZenStack: The Complete Guide | ZenStack\n\n## Introduction[‚Äã](https://zenstack.dev/docs/the-complete-guide/#introduction \"Direct link to Introduction\")\n\nWelcome to _The Complete Guide of ZenStack_. This guide is designed to systematically introduce the key concepts in ZenStack and guide you through how to use its essential features.\n\n## Sample Project[‚Äã](https://zenstack.dev/docs/the-complete-guide/#sample-project \"Direct link to Sample Project\")\n\nThroughout the guide, we'll learn the key concepts and features by gradually building a sample project. The project is a multi-tenant Todo app, which allows users to create and join \"Spaces\", and collaborate with users in the same space by creating and managing Todo Lists.\n\nHere are the detailed requirements:\n\n*   Email/password based signin/signup.\n*   `Space` for multi-tenancy management. Users can join multiple spaces, and a space can have many users.\n*   Users can be of \"USER\" or \"ADMIN\" role in a space. Space admins can manage space members.\n*   Users can manage Todo lists and items in spaces they belong to.\n*   Public Todo lists are accessible to all space members. Private lists are only accessible to the owner and space admins.\n\nThe app is not too complex but covers many important aspects of a modern multi-tenant web application. You can find the complete source code of the project at [https://github.com/zenstackhq/the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample). It contains several branches, each corresponding to the end state of a part of the guide. For example, you can use branch \"part1\" as the starting point of your study of Part II.\n\nHands-on indicator\n\nMany chapters include hands-on sections where we gradually build the sample project. They are all marked with üõ†Ô∏è symbol.\n\nYou can have a preview of the fully completed version below:\n\n[![Sample Todo App](https://zenstack.dev/assets/images/todo-app-splash-82ad67e1e0212042dee7539b851f451d.png)](https://zenstack-todo.vercel.app/)\n\n## Organization[‚Äã](https://zenstack.dev/docs/the-complete-guide/#organization \"Direct link to Organization\")\n\nZenStack consists of several layers of functionalities, each depends on the previous one. These layers are explained in detail in the following four parts. In each part, we'll add more functionalities to our Todo app and eventually finish it by the end of the guide.\n\n### Part I: Supercharged ORM[‚Äã](https://zenstack.dev/docs/the-complete-guide/#part-i-supercharged-orm \"Direct link to Part I: Supercharged ORM\")\n\nThe first layer works as an extension to Prisma ORM - both for the schema language and the runtime PrismaClient. We made several extensions to the Prisma Schema Language to make it possible to express more than just the database schema. For example, you can attach access policies to the data models. At runtime, ZenStack creates a transparent proxy around PrismaClient to add extra behavior to it - one of the best examples is the automatic access control enforcement.\n\nThe extension to Prisma ORM is the foundation of ZenStack and enables all other features above it. These features are also agnostic to the framework you use for the backend. It's simply a drop-in replacement for Prisma.\n\nIn this part of the guide, we'll finish building the schema of the sample project - including the data models, access policies, and data validation rules. There's no API or UI yet, but the business logic will be mostly complete.\n\n[Go to Part I](https://zenstack.dev/docs/the-complete-guide/part1)\n\n### Part II: Plugin System[‚Äã](https://zenstack.dev/docs/the-complete-guide/#part-ii-plugin-system \"Direct link to Part II: Plugin System\")\n\nZenStack adopts a plugin-based architecture for great extensibility. The plugin system allows you to add new features to ZenStack without modifying the core codebase. In fact, most built-in features of ZenStack are implemented as plugins.\n\nIn this part of the guide, you'll see how to use plugins to achieve various goals, and we'll also build a simple plugin for our Todo app from scratch.\n\n[Go to Part II](https://zenstack.dev/docs/the-complete-guide/part2)\n\n### Part III: Automatic CRUD API[‚Äã](https://zenstack.dev/docs/the-complete-guide/#part-iii-automatic-crud-api \"Direct link to Part III: Automatic CRUD API\")\n\nDevelopers build APIs to support the client side of their applications. One of the most common type of APIs is CRUD - Create, Read, Update, and Delete. Building CRUD APIs is a tedious task but error-prone at the same time.\n\nSince ZenStack already secures data access at the ORM layer, as we learned from the previous part, it can automatically generate CRUD APIs for you. You'll learn about the details in this part of the guide.\n\nIn this part of the guide, we'll add a CRUD API layer to our Todo app and turn it into a fully functional backend service.\n\n[Go to Part III](https://zenstack.dev/docs/the-complete-guide/part3)\n\n### Part IV: Frontend Data Query[‚Äã](https://zenstack.dev/docs/the-complete-guide/#part-iv-frontend-data-query \"Direct link to Part IV: Frontend Data Query\")\n\nModern web apps often use data query libraries (like [TanStack Query](https://tanstack.com/query) and [SWR](https://swr.vercel.app/)) to fetch data from the backend. These libraries help you build reactive data binding UI with ease.\n\nZenStack can generate hooks code that talks to the automatic CRUD API introduced in the previous part, targeting these libraries. The hooks help you implement front-end data queries with minimum code and complete type safety. Part IV focuses on this topic.\n\nIn this part of the guide, we'll use the generated data query hooks to build a frontend UI for our Todo app. We'll finally complete our full-stack Todo application!\n\n[Go to Part IV](https://zenstack.dev/docs/the-complete-guide/part4)",
  "title": "ZenStack: The Complete Guide | ZenStack",
  "description": "The Complete Guide of ZenStack",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/category/recipes",
  "markdown": "# Recipes | ZenStack\n\n[\n\n## üìÑÔ∏è Debugging and Troubleshooting\n\nZenStack's access policies are powerful, but when the rules get complex, it can be challenging to reason why an operation is being allowed or denied. This guide lists some techniques for debugging and troubleshooting.\n\n](https://zenstack.dev/docs/guides/debugging)",
  "title": "Recipes | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/upgrade-v2",
  "markdown": "# Upgrading to V2 | ZenStack\n\nWe're excited to announce the release of ZenStack V2 üéâ!\n\nWhile V1 focused on implementing an access control layer around Prisma, V2 is more ambitious and desires to solve some deeper problems in modeling a database-centric application while continuing to improve the overall developer experience.\n\nThis document outlines the first batch of new features, together with breaking changes and upgrade instructions. More goodies will land in the future V2 series releases. Enjoy, and please [share your feedback](https://discord.gg/Ykhr738dUe)!\n\n## What's New[‚Äã](https://zenstack.dev/docs/upgrade-v2#whats-new \"Direct link to What's New\")\n\n### 1\\. Polymorphic Relations[‚Äã](https://zenstack.dev/docs/upgrade-v2#1-polymorphic-relations \"Direct link to 1. Polymorphic Relations\")\n\nPolymorphic relations allows you to model relations over an \"abstract interface\". This feature is inspired by the following Prisma issues:\n\n*   [Support for a Union type](https://github.com/prisma/prisma/issues/2505)\n*   [Support for Polymorphic Associations](https://github.com/prisma/prisma/issues/1644)\n\nSee the [Polymorphic Relations](https://zenstack.dev/docs/guides/polymorphism) recipe for more information.\n\n### 2\\. Using `auth()` in `@default()`[‚Äã](https://zenstack.dev/docs/upgrade-v2#2-using-auth-in-default \"Direct link to 2-using-auth-in-default\")\n\nYou can now use the `auth()` function inside the `@default()` attribute. A very common use case is to automatically assign foreign key field when creating entities with relation with the current user. In ZenStack V1, you needed to explicitly assign foreign key value even though the enhanced `PrismaClient` already implies a current user:\n\nschema.zmodel\n\n```\nmodel User {  id Int @default(autoincrement())}model Post {  id Int @default(autoincrement())  title String  owner User @relation(fields: [ownerId], references: [id])  ownerId Int}\n```\n\n```\nconst db = enhance(prisma, { user });await db.post.create({  data: {   owner: { connect: { id: user.id } },   title: 'Post1'  }})\n```\n\nWith this feature, you can update the schema to:\n\nschema.zmodel\n\n```\nmodel User {  id Int @default(autoincrement())}model Post {  id Int @default(autoincrement())  title String  owner User @relation(fields: [ownerId], references: [id])  ownerId Int @default(auth().id) // <- assign ownerId automatically}\n```\n\nand when creating a `Post`, you don't need to explicitly connect `owner` anymore.\n\n```\nconst db = enhance(prisma, { user });await db.post.create({ data: { title: 'Post1' } });\n```\n\n### 3\\. Fine-grained Optimistic Updates[‚Äã](https://zenstack.dev/docs/upgrade-v2#3-fine-grained-optimistic-updates \"Direct link to 3. Fine-grained Optimistic Updates\")\n\nPreviously the ZenStack-generated data query hooks (TanStack Query and SWR) support automatic optimistic updates. When a mutation executes, the hooks analyzes what queries are potentially affected and try to compute an optimistically updated piece of data, and use it to update the query cache. This feature is very useful in many cases, but it can't cover all cases. For example, if you create an entity and connect it to a related entity at the same time, the automatic optimistic logic doesn't know how to compute the relation (if it's used in a related query).\n\nIn V2, we introduce a `optimisticUpdateProvider` callback for the caller to decide how to compute the optimistic data for a mutation, for every query cache entry. Here's how to use it:\n\n```\nuseCreatePost({  optimisticUpdateProvider: ({ queryModel, queryOperation, queryArgs, currentData, mutationArgs }) => {    return { kind: 'Update', data: ... /* computed result */ };  }});\n```\n\nSee more information \\[here\\]:\n\nThe callback is invoked for each query cache entry. You can use the return value to control if to use the optimistic data you computed, skip the update, or leave it to the automatic logic.\n\n### 4\\. Prisma-Like Schema Formatting[‚Äã](https://zenstack.dev/docs/upgrade-v2#4-prisma-like-schema-formatting \"Direct link to 4. Prisma-Like Schema Formatting\")\n\nWe've heard your feedback: the way how Prisma formats the schema code makes it more readable. Now ZenStack's IDE extensions and the CLI `format` command resemble Prisma's behavior and format fields into a tabular form.\n\n![ZModel Formatting](https://zenstack.dev/img/zmodel-format-light.png)![ZModel Formatting](https://zenstack.dev/img/zmodel-format-dark.png)\n\nYou can switch back to the old behavior in the extension settings (VSCode only).\n\n### 5\\. Edge Runtime Support (Preview)[‚Äã](https://zenstack.dev/docs/upgrade-v2#5-edge-runtime-support-preview \"Direct link to 5. Edge Runtime Support (Preview)\")\n\nWe've updated the `@zenstackhq/runtime` package to be compatible with Vercel Edge Runtime and Cloudflare Workers. See [this documentation](https://zenstack.dev/docs/guides/edge) for more details.\n\n### 6\\. Permission Checker API (Preview)[‚Äã](https://zenstack.dev/docs/upgrade-v2#6-permission-checker-api-preview \"Direct link to 6. Permission Checker API (Preview)\")\n\nZenStack's access policies prevent unauthorized users to query or mutate data. However, there are cases where you simply want to check if an operation is permitted without actually executing it. For example, you might want to show or hide a button based on the user's permission.\n\nThe new permission checker API allows to check a user's permission without querying the database.\n\n```\nconst db = enhance(prisma, { user: getCurrentUser() });// check if the current user can read published postsawait canRead = await db.post.check({  operation: 'read',  where: { published: true }});\n```\n\nPlease check [this guide](https://zenstack.dev/docs/guides/check-permission) for more details.\n\n## Upgrading[‚Äã](https://zenstack.dev/docs/upgrade-v2#upgrading \"Direct link to Upgrading\")\n\n### NPM Packages[‚Äã](https://zenstack.dev/docs/upgrade-v2#npm-packages \"Direct link to NPM Packages\")\n\nTo upgrade, update your project's dependencies of `zenstack` and `@zenstackhq/*` packages to the `@latest` tag.\n\n```\nnpm i -D zenstack@latestnpm i @zenstackhq/runtime@latest...\n```\n\n### IDE Extensions[‚Äã](https://zenstack.dev/docs/upgrade-v2#ide-extensions \"Direct link to IDE Extensions\")\n\nPlease upgrade VSCode extension and JetBrains plugin to the latest version.\n\n## Breaking Changes[‚Äã](https://zenstack.dev/docs/upgrade-v2#breaking-changes \"Direct link to Breaking Changes\")\n\nThe following sections list breaking changes introduced in ZenStack V2 and guide for upgrading your project.\n\n### 1\\. ZModel Schema[‚Äã](https://zenstack.dev/docs/upgrade-v2#1-zmodel-schema \"Direct link to 1. ZModel Schema\")\n\n*   #### No more access to declarations from indirectly imported schemas[‚Äã](https://zenstack.dev/docs/upgrade-v2#no-more-access-to-declarations-from-indirectly-imported-schemas \"Direct link to No more access to declarations from indirectly imported schemas\")\n    \n    V1 had an unintended behavior that you can access a declaration without importing the ZModel file where it's declared, as long as the schema is indirectly imported.\n    \n    The behavior is changed in V2. If you use a declaration from another ZModel, you'll need to explicitly import it.\n    \n    Please note that this implies if you use `auth()` function in access policies, you'll need to import the ZModel where the `User` model (or the model marked with `@@auth`) so that `auth()` can be resolved. If you feel it causes extra imports in too many schema files, please leave your feedback in [this GitHub issue](https://github.com/zenstackhq/zenstack/issues/1388).\n    \n\n### 2\\. Runtime[‚Äã](https://zenstack.dev/docs/upgrade-v2#2-runtime \"Direct link to 2. Runtime\")\n\n*   #### Unified `enhance` API[‚Äã](https://zenstack.dev/docs/upgrade-v2#unified-enhance-api \"Direct link to unified-enhance-api\")\n    \n    In V1, there were several `withXXX` APIs (like `withPolicy`, `withOmit`, etc.) that help you create enhanced PrismaClient instances with specific enhancements. These APIs are now deprecated and unified to the single `enhance` API. You can use the `kinds` option to control what enhancements to apply:\n    \n    ```\n    const db = enhance(prisma, { user }, { kinds: ['policy', 'omit'] })\n    ```\n    \n    By default, all enhancements are enabled.\n    \n*   #### Changes to the `enhance` API[‚Äã](https://zenstack.dev/docs/upgrade-v2#changes-to-the-enhance-api \"Direct link to changes-to-the-enhance-api\")\n    \n    One of the main changes in V2 is that the `enhance` API is now generated, by default into the `node_modules/.zenstack` package, together with other supporting modules. The `@zenstackhq/runtime/enhance` module is simply a reexport of `.zenstack/enhance`. This change allows us to customize the API of the enhanced `PrismaClient` based on the enhancements enabled.\n    \n    The change also simplifies the way how the `enhance` API is used when you specify a custom output location (usually for checking in the generated files with the source tree). For example, if you use the \"--output\" CLI switch to output to \"./.zenstack\" folder:\n    \n    ```\n    npx zenstack generate --output ./.zenstack\n    ```\n    \n    You can import the `enhance` API directly from the output location and use it without any other changes:\n    \n    ```\n    import { enhance } from './.zenstack/enhance';const db = enhance(...);\n    ```\n    \n    Several options of the `enhance` API are also removed because they are no more needed:\n    \n    *   policy\n    *   modelMeta\n    *   zodSchemas\n    *   loadPath\n    \n    These options were for guiding ZenStack to load the generated modules from a custom location. They are not needed anymore because the generated `enhance` API can always load them from relative paths.\n    \n    Another major benefit of generating `enhance` is the `user` context object is now strongly typed. The CLI statically analyzes the ZModel schema to identify the fields accessed through `auth()` (including multi-level accesses into relation fields), and use that information to type the `user` object. This helps you to identify missing or incorrectly typed fields and avoid unexpected runtime behavior.\n    \n*   #### Strict typing for the user context[‚Äã](https://zenstack.dev/docs/upgrade-v2#strict-typing-for-the-user-context \"Direct link to Strict typing for the user context\")\n    \n    The `enhance` API now analyzes the fields accessed through `auth()` in ZModel access policies and use that to derive a strong typed `user` context. For example, if your ZModel looks like:\n    \n    ```\n    model Post {  id Int @id  ...  @@allow('all', auth().role == ADMIN)}\n    ```\n    \n    You'll get an compile-time error if you pass an `user` object without the `role` field:\n    \n    ```\n    const db = enhance(prisma, { user: { id: userId }}); // <- `role` field is required\n    ```\n    \n*   #### Prisma version below 5.0.0 is not supported anymore[‚Äã](https://zenstack.dev/docs/upgrade-v2#prisma-version-below-500-is-not-supported-anymore \"Direct link to Prisma version below 5.0.0 is not supported anymore\")\n    \n    Supporting both Prisma V4 and V5 caused quite some complexities. We decided to require Prisma 5.0.0 and above for ZenStack V2. This also makes it possible to make ZenStack's runtime compatible with Edge environments (TBD).\n    \n\n### 3\\. CLI[‚Äã](https://zenstack.dev/docs/upgrade-v2#3-cli \"Direct link to 3. CLI\")\n\n*   #### Removed support of CLI config file[‚Äã](https://zenstack.dev/docs/upgrade-v2#removed-support-of-cli-config-file \"Direct link to Removed support of CLI config file\")\n    \n    The \"--config\" switch and the \"zenstack.config.json\" file are removed. They weren't doing anything useful and were only kept in V1 for backward compatibility reasons.\n    \n    We may introduce a new config file format in the future.\n    \n\n### 4\\. Server Adapter[‚Äã](https://zenstack.dev/docs/upgrade-v2#4-server-adapter \"Direct link to 4. Server Adapter\")\n\n*   #### HTTP status code `422` is used to represent data validation errors[‚Äã](https://zenstack.dev/docs/upgrade-v2#http-status-code-422-is-used-to-represent-data-validation-errors \"Direct link to http-status-code-422-is-used-to-represent-data-validation-errors\")\n    \n    In V1, when a [data validation](https://zenstack.dev/docs/reference/zmodel-language#data-validation) error happens (due to violation of rules represented by `@email`, `@length`, `@@validate` etc.), the server adapters used `403` to represent such error. This is changed in V2 to use `422` to align with the [HTTP status code definition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422).\n    \n*   #### The deprecated `useSuperJSON` initialization options is removed[‚Äã](https://zenstack.dev/docs/upgrade-v2#the-deprecated-usesuperjson-initialization-options-is-removed \"Direct link to the-deprecated-usesuperjson-initialization-options-is-removed\")\n    \n    The server adapters always use SuperJSON for serialization and deserialization.\n    \n\n### 5\\. Plugins[‚Äã](https://zenstack.dev/docs/upgrade-v2#5-plugins \"Direct link to 5. Plugins\")\n\nwarning\n\nAll plugins now automatically clean up the output directory before generating new files. Please make sure not to mix manually created files with the generated ones to to avoid data loss.\n\n#### 5.1 Zod Plugin[‚Äã](https://zenstack.dev/docs/upgrade-v2#51-zod-plugin \"Direct link to 5.1 Zod Plugin\")\n\n*   ##### Changes to the optionality of `[Model]Schema` schema[‚Äã](https://zenstack.dev/docs/upgrade-v2#changes-to-the-optionality-of-modelschema-schema \"Direct link to changes-to-the-optionality-of-modelschema-schema\")\n    \n    In V1, the generated `[Model]Schema` schema has all fields marked optional. This is changed in V2 to respect the optionality of fields as they are declared in ZModel.\n    \n\n#### 5.2. SWR Plugin[‚Äã](https://zenstack.dev/docs/upgrade-v2#52-swr-plugin \"Direct link to 5.2. SWR Plugin\")\n\n*   ##### Legacy mutation functions are removed[‚Äã](https://zenstack.dev/docs/upgrade-v2#legacy-mutation-functions-are-removed \"Direct link to Legacy mutation functions are removed\")\n    \n    In V1, the SWR plugin used to generate a set of legacy mutation functions via the `useMutate[Model]` hook. These functions (together with the hook) are removed in V2. You should use the individual mutation hooks instead.\n    \n    Old code:\n    \n    ```\n    import { useMutatePost } from '@lib/hooks';const { createPost } = useMutatePost();await createPost({ data: {...} });\n    ```\n    \n    New code:\n    \n    ```\n    import { useCreatePost } from '@lib/hooks';const { trigger: createPost, isMutating } = useCreatePost();await createPost({ data: {...} })\n    ```\n    \n*   ##### The `initialData` query option is removed[‚Äã](https://zenstack.dev/docs/upgrade-v2#the-initialdata-query-option-is-removed \"Direct link to the-initialdata-query-option-is-removed\")\n    \n    Use the `fallbackData` option instead.\n    \n\n#### 5.3. TanStack Query Plugin[‚Äã](https://zenstack.dev/docs/upgrade-v2#53-tanstack-query-plugin \"Direct link to 5.3. TanStack Query Plugin\")\n\n*   ##### Default target version is now \"v5\".[‚Äã](https://zenstack.dev/docs/upgrade-v2#default-target-version-is-now-v5 \"Direct link to Default target version is now \"v5\".\")\n    \n    In V1 the default target version was TanStack Query V4.\n    \n*   ##### Generated hooks got simplified parameters[‚Äã](https://zenstack.dev/docs/upgrade-v2#generated-hooks-got-simplified-parameters \"Direct link to Generated hooks got simplified parameters\")\n    \n    The query and mutation hooks generated in V1 had a few parameters like `invalidateQueries` and `optimisticUpdate`. These parameters are merged into the `options` parameter. The `options` parameter is used for configuring both tanstack-query and the additional behavior of ZenStack.\n    \n    Old code:\n    \n    ```\n    useFindManyPost(  { where: { ... } }, /* query args */  undefined, /* tanstack-query options */  false /* opt-out optimistic update*/);useCreatePost(  undefined /* tanstack-query options */,  false, /* whether to automatically invalidate related queries */  true /* whether to optimistically update related queries */)\n    ```\n    \n    New code:\n    \n    ```\n    useFindManyPost({ where: { ... } }, { optimisticUpdate: false });useCreatePost({ invalidateQueries: false, optimisticUpdate: true });\n    ```",
  "title": "Upgrading to V2 | ZenStack",
  "description": "How to upgrade to ZenStack v2",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/faq",
  "markdown": "# üôãüèª FAQ | ZenStack\n\n### Is ZenStack implemented with Postgres RLS (row-level-security)?[‚Äã](https://zenstack.dev/docs/faq#is-zenstack-implemented-with-postgres-rls-row-level-security \"Direct link to Is ZenStack implemented with Postgres RLS (row-level-security)?\")\n\nNo, it is not implemented with Postgres RLS. Instead, ZenStack applies access control rules by injecting into Prisma's query arguments and (in certain scenarios) conducting post-query filtering. The choice brings several benefits:\n\n1.  Database agnostic: ZenStack works with any database that Prisma supports.\n2.  No need to create migrations when changing access control rules.\n3.  A significantly simpler syntax for access control rules compared to SQL RLS.\n4.  Collocating access control rules with the data model.\n\n### Does using ZenStack introduce more connections to my databases?[‚Äã](https://zenstack.dev/docs/faq#does-using-zenstack-introduce-more-connections-to-my-databases \"Direct link to Does using ZenStack introduce more connections to my databases?\")\n\nNo. It's common to create enhanced PrismaClient wrappers per request (for binding to different user identity). Under the hood all such wrappers share the same PrismaClient instance and thus the same database connection.\n\n### Is ZenStack framework-agnostic?[‚Äã](https://zenstack.dev/docs/faq#is-zenstack-framework-agnostic \"Direct link to Is ZenStack framework-agnostic?\")\n\nYes, ZenStack is framework-agnostic. The core of ZenStack's runtime is a transparent proxy wrapping a PrismaClient, so it can be used in any framework that can run Prisma. ZenStack already provides adapters for popular frameworks like [Next.js](https://zenstack.dev/docs/reference/server-adapters/next) and [Fastify](https://zenstack.dev/docs/reference/server-adapters/fastify), and more are being made. It's also easy to write your own adapters.\n\n### How to use ZenStack in a monorepo setup?[‚Äã](https://zenstack.dev/docs/faq#how-to-use-zenstack-in-a-monorepo-setup \"Direct link to How to use ZenStack in a monorepo setup?\")\n\nTo use ZenStack in a monorepo setup (e.g., pnpm workspace), run `zenstack init` in the package where `schema.prisma` resides (usually also where the global `prisma` instance is exported). There's no need to install ZenStack-related packages at the workspace level.\n\n### Is ZModel fully compatible with Prisma Schema?[‚Äã](https://zenstack.dev/docs/faq#is-zmodel-fully-compatible-with-prisma-schema \"Direct link to Is ZModel fully compatible with Prisma Schema?\")\n\nThe ZModel language is designed to be a superset of Prisma Schema. The major extension that ZModel made to Prisma schema today are:\n\n*   [Custom attributes](https://zenstack.dev/docs/reference/zmodel-language#custom-attributes-and-functions)\n*   [Plugins](https://zenstack.dev/docs/category/plugins)\n\nUsing a separate DSL gives us the flexibility to add more extensions in the future; however, the goal is to maintain the \"superset\" positioning, i.e., every valid `schema.prisma` is a valid `schema.zmodel`.\n\nIn practice, you may run into problems that the `schema.prisma` generated by ZenStack triggers validation errors in `prisma` CLI. This is because Prisma CLI has many validation rules, some quite subtle. We try to replicate those rules in `zenstack` CLI, but it's more of a best-effort approach. Fortunately, the errors reported by `prisma` CLI usually give pretty good hints on what to change in `schema.zmodel`.\n\nWe will continue improving the parity between ZModel and Prisma Schema regarding validation rules.\n\n### Does ZenStack require a specific Prisma version?[‚Äã](https://zenstack.dev/docs/faq#does-zenstack-require-a-specific-prisma-version \"Direct link to Does ZenStack require a specific Prisma version?\")\n\nNo. ZenStack references Prisma as a peer dependency and works with Prisma 5.0.0 and above.\n\n### Does ZenStack work with Prisma migration?[‚Äã](https://zenstack.dev/docs/faq#does-zenstack-work-with-prisma-migration \"Direct link to Does ZenStack work with Prisma migration?\")\n\nYes. When you run `zenstack generate` it generates a standard Prisma schema file that can be used with Prisma migration.\n\n### Are there any other IDE integrations besides VSCode?[‚Äã](https://zenstack.dev/docs/faq#are-there-any-other-ide-integrations-besides-vscode \"Direct link to Are there any other IDE integrations besides VSCode?\")\n\nYes, ZenStack has integrations with VSCode and JetBrains IDEs. Please see [here](https://zenstack.dev/docs/guides/ide) for ore details.\n\n### Does ZenStack work with Prisma Client Extensions?[‚Äã](https://zenstack.dev/docs/faq#does-zenstack-work-with-prisma-client-extensions \"Direct link to Does ZenStack work with Prisma Client Extensions?\")\n\nThe short answer is it works in most cases. Please refer to [this guide](https://zenstack.dev/docs/guides/client-extensions) for more details.",
  "title": "üôãüèª FAQ | ZenStack",
  "description": "ZenStack FAQ.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/category/reference",
  "markdown": "# Reference | ZenStack\n\n[\n\n## üìÑÔ∏è ZModel Language\n\nZModel language references\n\n](https://zenstack.dev/docs/1.x/reference/zmodel-language)",
  "title": "Reference | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/sample-catalog",
  "markdown": "# A Catalog of Sample Projects\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "A Catalog of Sample Projects | ZenStack",
  "description": "The ZenStack team maintains the following three series of sample projects.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/cli",
  "markdown": "# ZenStack CLI Reference | ZenStack\n\n## Usage[‚Äã](https://zenstack.dev/docs/reference/cli#usage \"Direct link to Usage\")\n\n```\nzenstack [options] [command]Œ∂ ZenStack is a Prisma power pack for building full-stack apps.Documentation: https://zenstack.dev.Options:  -v --version           display CLI version  -h, --help             display help for commandCommands:  info [path]            Get information of installed ZenStack and related packages.  init [options] [path]  Initialize an existing project for ZenStack.  generate [options]     Generates RESTful API and Typescript client for your data model.  repl [options]         Start a REPL session.  format [options]       Format a ZenStack schema file.  help [command]         Display help for a command.\n```\n\n## Sub Commands[‚Äã](https://zenstack.dev/docs/reference/cli#sub-commands \"Direct link to Sub Commands\")\n\n### init[‚Äã](https://zenstack.dev/docs/reference/cli#init \"Direct link to init\")\n\nInitializes an existing project to use ZenStack.\n\n```\nzenstack init [options] [path]\n```\n\n#### Arguments[‚Äã](https://zenstack.dev/docs/reference/cli#arguments \"Direct link to Arguments\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| path | Project path | current folder |\n\n#### Options[‚Äã](https://zenstack.dev/docs/reference/cli#options \"Direct link to Options\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| \\--prisma | location of Prisma schema file to bootstrap from | <project path>/prisma/schema.prisma |\n| \\-p, --package-manager | package manager to use: \"npm\", \"yarn\", or \"pnpm\" | auto detect |\n| \\--no-version-check | do not check for new versions of ZenStack | false |\n\n#### Examples[‚Äã](https://zenstack.dev/docs/reference/cli#examples \"Direct link to Examples\")\n\nInitialize current folder with default settings.\n\nInitialize \"myapp\" folder with custom package manager and schema location.\n\n```\nnpx zenstack init -p pnpm --prisma prisma/my.schema myapp\n```\n\n### generate[‚Äã](https://zenstack.dev/docs/reference/cli#generate \"Direct link to generate\")\n\nGenerates Prisma schema and other artifacts as specified by \"plugin\"s in ZModel.\n\n```\nzenstack generate [options]\n```\n\n#### Arguments[‚Äã](https://zenstack.dev/docs/reference/cli#arguments-1 \"Direct link to Arguments\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| path | Project path | current folder |\n\n#### Options[‚Äã](https://zenstack.dev/docs/reference/cli#options-1 \"Direct link to Options\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| \\--schema | schema file (with extension .zmodel) | ./schema.zmodel |\n| \\-o, --output <path> | default output directory for TS/JS files generated by built-in plugins | node\\_modules/.zenstack |\n| \\--no-default-plugins | do not automatically run built-in plugins | false |\n| \\--no-compile | do not compile the output of built-in plugins | false |\n| \\--no-version-check | do not check for new versions of ZenStack | false |\n\nYou can also specify the ZModel schema location in the \"package.json\" file of your project like the following:\n\npackage.json\n\n```\n{  \"zenstack\": {    \"schema\": \"./db/schema.zmodel\"  }}\n```\n\n#### Examples[‚Äã](https://zenstack.dev/docs/reference/cli#examples-1 \"Direct link to Examples\")\n\nGenerate with default settings.\n\nGenerate with custom schema location.\n\n```\nnpx zenstack generate --schema src/my.zmodel\n```\n\n### repl[‚Äã](https://zenstack.dev/docs/reference/cli#repl \"Direct link to repl\")\n\nStarts a REPL session. You should run the command inside the package where you ran `zenstack generate`.\n\nYou can call PrismaClient methods interactively in the REPL session. The following variables are available in the REPL session.\n\n*   `prisma`\n    \n    The original PrismaClient instance (without ZenStack enhancement).\n    \n*   `db`\n    \n    The ZenStack enhanced PrismaClient instance.\n    \n\nYou don't need to `await` the Prisma method call result. The REPL session will automatically await and print the result.\n\n#### Options[‚Äã](https://zenstack.dev/docs/reference/cli#options-2 \"Direct link to Options\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| \\--debug | Enable debug output. Can be toggled on the fly in the repl session with the \".debug\" command. | false |\n| \\--table | Enable table format. Can be toggled on the fly in the repl session with the \".table\" command. | false |\n| \\--prisma-client | Path to load PrismaClient module. | \"./node\\_modules/.prisma/client\" |\n\n#### Repl Commands[‚Äã](https://zenstack.dev/docs/reference/cli#repl-commands \"Direct link to Repl Commands\")\n\nYou can use the following commands in the REPL session.\n\n*   `.debug [on|off]`\n    \n    Toggle debug output.\n    \n*   `.table [on|off]`\n    \n    Toggle table format.\n    \n*   `.auth [user object]`\n    \n    Set current user. E.g.: `.auth { id: 1 }`. Run the command without argument to reset to anonymous user.\n    \n\n#### Examples[‚Äã](https://zenstack.dev/docs/reference/cli#examples-2 \"Direct link to Examples\")\n\nStart the session:\n\nInside the session:\n\n```\n> prisma.user.findMany()[  {    id: '7aa301d2-7a29-4e1e-a041-822913a3ea78',    createdAt: 2023-09-05T04:04:43.793Z,    updatedAt: 2023-09-05T04:04:43.793Z,    email: 'yiming@whimslab.io',    ...  }]> .auth { id: '7aa301d2-7a29-4e1e-a041-822913a3ea78' }Auth user: { id: '7aa301d2-7a29-4e1e-a041-822913a3ea78' }. Use \".auth\" to switch to anonymous.> .tableTable output: true> db.list.findMany({select: { title: true, private: true}})‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ (index) ‚îÇ                       title                        ‚îÇ private ‚îÇ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§‚îÇ    0    ‚îÇ                        'L1'                        ‚îÇ  false  ‚îÇ‚îÇ    1    ‚îÇ               'Wonderful new world'                ‚îÇ  false  ‚îÇ‚îÇ    2    ‚îÇ 'Model for a space in which users can collaborate' ‚îÇ  false  ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### format[‚Äã](https://zenstack.dev/docs/reference/cli#format \"Direct link to format\")\n\nFormat a ZenStack schema file.\n\n```\nzenstack format [options]\n```\n\n#### Options[‚Äã](https://zenstack.dev/docs/reference/cli#options-3 \"Direct link to Options\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| \\--schema | schema file (with extension .zmodel) | ./schema.zmodel |\n\nYou can also specify the ZModel schema location in the \"package.json\" file of your project like the following:\n\npackage.json\n\n```\n{  \"zenstack\": {    \"schema\": \"./db/schema.zmodel\"  }}\n```\n\n### info[‚Äã](https://zenstack.dev/docs/reference/cli#info \"Direct link to info\")\n\nGet information of installed ZenStack and related packages.\n\n```\nzenstack info [options] [path]\n```\n\n#### Arguments[‚Äã](https://zenstack.dev/docs/reference/cli#arguments-2 \"Direct link to Arguments\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| path | Project path | current folder |",
  "title": "ZenStack CLI Reference | ZenStack",
  "description": "CLI references",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/runtime-api",
  "markdown": "# Runtime API Reference | ZenStack\n\nVersion: 2.x\n\nThis document provides references for runtime APIs exported from the `@zenstackhq/runtime` package.\n\n### enhance[‚Äã](https://zenstack.dev/docs/reference/runtime-api#enhance \"Direct link to enhance\")\n\n#### Description[‚Äã](https://zenstack.dev/docs/reference/runtime-api#description \"Direct link to Description\")\n\nCreates an enhanced wrapper for a `PrismaClient`. The return value has the same APIs as the original `PrismaClient`.\n\n#### Signature[‚Äã](https://zenstack.dev/docs/reference/runtime-api#signature \"Direct link to Signature\")\n\n```\nfunction enhance<DbClient extends object>(    prisma: DbClient,    context?: EnhancementContext,    options?: EnhancementOptions): DbClient;\n```\n\n##### Parameter `prisma`[‚Äã](https://zenstack.dev/docs/reference/runtime-api#parameter-prisma \"Direct link to parameter-prisma\")\n\nThe PrismaClient instance to enhance.\n\n##### Parameter `context`[‚Äã](https://zenstack.dev/docs/reference/runtime-api#parameter-context \"Direct link to parameter-context\")\n\nThe context to for evaluating access policies with the following typing.\n\n```\ntype EnhancementContext = {    user?: Record<string, unknown>};\n```\n\n| Field | Description |\n| --- | --- |\n| user | The user object that provides value for the `auth()` function call in access policies. If provided. Its shape should be consistent with the `User` model in your ZModel, with all fields optional except for id field(s). Pass `undefined` to represent an anonymous user, and the `auth()` function call will evaluate to `null` in that case. |\n\n##### Parameter `options`[‚Äã](https://zenstack.dev/docs/reference/runtime-api#parameter-options \"Direct link to parameter-options\")\n\nOptions with the following typing.\n\n```\ntype TransactionIsolationLevel =    | 'ReadUncommitted'    | 'ReadCommitted'    | 'RepeatableRead'    | 'Snapshot'    | 'Serializable';type EnhancementOptions = {    kinds?: EnhancementKind[];    logPrismaQuery?: boolean;    errorTransformer?: ErrorTransformer;    transactionMaxWait?: number;    transactionTimeout?: number;    transactionIsolationLevel?: TransactionIsolationLevel;};\n```\n\n| Field | Description | Default |\n| --- | --- | --- |\n| kinds | The kinds of enhancements to apply. By default all enhancements are applied. See [the next section](https://zenstack.dev/docs/reference/runtime-api#enhancement-kinds) for more details. | All enhancement kinds |\n| logPrismaQuery | Whether to log queries sent to Prisma client. Log will be emitted with \"info\" level, so please make sure you [turn that level on](https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/logging#log-to-stdout) when creating Prisma client | false |\n| errorTransformer | A function for transforming error thrown by the enhanced `PrismaClient` into a custom one. |     |\n| transactionMaxWait | The `maxWait` option (in ms) passed to `prisma.$transaction()` call for transactions initiated by ZenStack. | Database default |\n| transactionTimeout | The `timeout` option (in ms) passed to `prisma.$transaction()` call for transactions initiated by ZenStack. | Database default |\n| transactionIsolationLevel | The `isolationLevel` option passed to `prisma.$transaction()` call for transactions initiated by ZenStack. | Database default |\n\n#### Enhancement Kinds[‚Äã](https://zenstack.dev/docs/reference/runtime-api#enhancement-kinds \"Direct link to Enhancement Kinds\")\n\nHere are the kinds of enhancements available:\n\n*   `policy`\n    \n    Enforces model-level and field-level access policies defined with `@@allow`, `@@deny`, `@allow`, and `@deny`.\n    \n*   `validation`\n    \n    Validates create and update input data against rules defined with [data validation attributes](https://zenstack.dev/docs/reference/zmodel-language#data-validation).\n    \n*   `delegate`\n    \n    Support for modeling [polymorphic relations](https://zenstack.dev/docs/guides/polymorphism) with delegated types pattern.\n    \n*   `password`\n    \n    Automatically hashes fields marked with the `@password` attribute using `bcryptjs` before saving to the database.\n    \n*   `omit`\n    \n    Automatically omits fields marked with the `@omit` attribute from read results.\n    \n\n#### Example[‚Äã](https://zenstack.dev/docs/reference/runtime-api#example \"Direct link to Example\")\n\n```\nconst session = getSession();const enhancedClient = enhance(prisma,  { user: session.user },  { kinds: ['policy', 'password']});\n```\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Runtime API Reference | ZenStack",
  "description": "Runtime API references",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/prisma-client-ext",
  "markdown": "# Added PrismaClient APIs | ZenStack\n\nZenStack's enhancement to PrismaClient not only alters its existing APIs' behavior, but also adds new APIs.\n\nThis API is added to each model in the PrismaClient.\n\nChecks if the current user is allowed to perform the specified operation on the model based on the access policies in ZModel. The check is done via pure logical inference and doesn't query the database.\n\ndanger\n\nPermission checking is an approximation and can be over-permissive. You MUST NOT trust it and circumvent the real access control mechanism (e.g., calling raw Prisma CRUD operations without further authorization checks).\n\n```\nconst db = enhance(prisma, { user: getCurrentUser() });// check if the current user can read published postsawait canRead = await db.post.check({  operation: 'read',  where: { published: true }});\n```",
  "title": "Added PrismaClient APIs | ZenStack",
  "description": "APIs ZenStack adds to the PrismaClient",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/zmodel-language",
  "markdown": "# ZModel Language Reference | ZenStack\n\n## Overview[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#overview \"Direct link to Overview\")\n\n**ZModel**, the modeling DSL of ZenStack, is the main concept you'll deal with when using this toolkit. The ZModel syntax is a superset of [Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema). Therefore, every valid Prisma schema is a valid ZModel.\n\ninfo\n\nWe made that choice to extend the Prisma schema for several reasons:\n\n*   Creating a new ORM adds little value to the community. Instead, extending Prisma - the overall best ORM toolkit for Typescript - sounds more sensible.\n    \n*   Prisma's schema language is simple and intuitive.\n    \n*   Extending an existing popular language lowers the learning curve compared to inventing a new one.\n    \n\nHowever, the standard capability of Prisma schema doesn't allow us to build the functionalities we want in a natural way, so we made a few extensions to the language by adding the following:\n\n1.  Custom attributes\n2.  Custom attribute functions\n3.  Built-in attributes and functions for defining access policies\n4.  Built-in attributes for defining field validation rules\n5.  Utility attributes like `@password` and `@omit`\n6.  Multi-schema files support\n\nSome of these extensions have been asked for by the Prisma community for some time, so we hope that ZenStack can be helpful even just as an extensible version of Prisma.\n\nThis section provides detailed descriptions of all aspects of the ZModel language, so you don't have to jump over to Prisma's documentation for extra learning.\n\n## Import[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#import \"Direct link to Import\")\n\nZModel allows to import other ZModel files. This is useful when you want to split your schema into multiple files for better organization. Under the hood, it will recursively merge all the imported schemas, and generate a single Prisma schema file for the Prisma CLI to consume.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#syntax \"Direct link to Syntax\")\n\n```\nimport [IMPORT_SPECIFICATION]\n```\n\n*   **\\[IMPORT\\_SPECIFICATION\\]**: Path to the ZModel file to be imported. It can be:\n    \n    *   An absolute path, e.g., \"/path/to/user\".\n    *   A relative path, e.g., \"./user\".\n    *   A module resolved to an installed NPM package, e.g., \"my-package/base\".\n    \n    If the import specification doesn't end with \".zmodel\", the resolver will automatically append it. Once a file is imported, all the declarations in that file will be included in the building process.\n    \n\n### Examples[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#examples \"Direct link to Examples\")\n\n```\n// there is a file called \"user.zmodel\" in the same directoryimport \"user\"\n```\n\n## Data source[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#data-source \"Direct link to Data source\")\n\nEvery model needs to include exactly one `datasource` declaration, providing information on how to connect to the underlying database.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#syntax-1 \"Direct link to Syntax\")\n\n```\ndatasource [NAME] {    provider = [PROVIDER]    url = [DB_URL]}\n```\n\n*   **\\[NAME\\]**:\n    \n    Name of the data source. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`. Name is only informational and serves no other purposes.\n    \n*   **\\[PROVIDER\\]**:\n    \n    Name of database connector. Valid values:\n    \n    *   sqlite\n    *   postgresql\n    *   mysql\n    *   sqlserver\n    *   cockroachdb\n*   **\\[DB\\_URL\\]**:\n    \n    Database connection string. Either a plain string or an invocation of `env` function to fetch from an environment variable.\n    \n\n### Examples[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#examples-1 \"Direct link to Examples\")\n\n```\ndatasource db {    provider = \"postgresql\"    url = \"postgresql://postgres:abc123@localhost:5432/todo?schema=public\"}\n```\n\nIt's highly recommended that you not commit sensitive database connection strings into source control. Alternatively, you can load it from an environment variable:\n\n```\ndatasource db {    provider = \"postgresql\"    url = env(\"DATABASE_URL\")}\n```\n\n### Supported databases[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#supported-databases \"Direct link to Supported databases\")\n\nZenStack uses [Prisma](https://prisma.io/ \":target=_blank\") to talk to databases, so all relational databases supported by Prisma are also supported by ZenStack.\n\nHere's a list for your reference:\n\nDatabase\n\nVersion\n\nPostgreSQL\n\n9.6\n\nPostgreSQL\n\n10\n\nPostgreSQL\n\n11\n\nPostgreSQL\n\n12\n\nPostgreSQL\n\n13\n\nPostgreSQL\n\n14\n\nPostgreSQL\n\n15\n\nMySQL\n\n5.6\n\nMySQL\n\n5.7\n\nMySQL\n\n8\n\nMariaDB\n\n10\n\nSQLite\n\n\\*\n\nAWS Aurora\n\n\\*\n\nAWS Aurora Serverless\n\n\\*\n\nMicrosoft SQL Server\n\n2022\n\nMicrosoft SQL Server\n\n2019\n\nMicrosoft SQL Server\n\n2017\n\nAzure SQL\n\n\\*\n\nCockroachDB\n\n21.2.4+\n\nYou can find the orignal list [here](https://www.prisma.io/docs/reference/database-reference/supported-databases \":target=_blank\").\n\n## Generator[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#generator \"Direct link to Generator\")\n\nGenerators are used for creating assets (usually code) from a Prisma schema. Check [here](https://www.prisma.io/docs/concepts/components/prisma-schema/generators) for a list of official and community generators.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#syntax-2 \"Direct link to Syntax\")\n\n```\ngenerator [GENERATOR_NAME] {    [OPTION]*}\n```\n\n*   **\\[GENERATOR\\_NAME\\]**\n    \n    Name of the generator. Needs to be unique in the entire model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[OPTION\\]**\n    \n    A generator configuration option, in form of \"\\[NAME\\] = \\[VALUE\\]\". A generator needs to have at least a \"provider\" option that specify its provider.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#example \"Direct link to Example\")\n\n```\ngenerator client {  provider = \"prisma-client-js\"  output   = \"./generated/prisma-client-js\"\n```\n\n## Plugin[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#plugin \"Direct link to Plugin\")\n\nPlugins are ZenStack's extensibility mechanism. It's usage is similar to [Generator](https://zenstack.dev/docs/reference/zmodel-language#generator). Users can define their own plugins to generate artifacts from the ZModel schema. Plugins differ from generators mainly in the following ways:\n\n*   They have a cleaner interface without the complexity of JSON-RPC.\n*   They use an easier-to-program AST representation than generators.\n*   They have access to language features that ZenStack adds to Prisma, like custom attributes and functions.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#syntax-3 \"Direct link to Syntax\")\n\n```\nplugin [PLUGIN_NAME] {    [OPTION]*}\n```\n\n*   **\\[PLUGIN\\_NAME\\]**\n    \n    Name of the plugin. Needs to be unique in the entire model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[OPTION\\]**\n    \n    A plugin configuration option, in form of \"\\[NAME\\] = \\[VALUE\\]\". A plugin needs to have at least a \"provider\" option that specify its provider.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#example-1 \"Direct link to Example\")\n\n```\nplugin swr {    provider = '@zenstackhq/swr'    output = 'lib/hooks'}\n```\n\n## Enum[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#enum \"Direct link to Enum\")\n\nEnums are container declarations for grouping constant identifiers. You can use them to express concepts like user roles, product categories, etc.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#syntax-4 \"Direct link to Syntax\")\n\n```\nenum [ENUM_NAME] {    [FIELD]*}\n```\n\n*   **\\[ENUM\\_NAME\\]**\n    \n    Name of the enum. Needs to be unique in the entire model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[FIELD\\]**\n    \n    Field identifier. Needs to be unique in the model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#example-2 \"Direct link to Example\")\n\n```\nenum UserRole {    USER    ADMIN}\n```\n\n## Model[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#model \"Direct link to Model\")\n\nModels represent the business entities of your application. A model inherits all fields and attributes from extended abstract models. Abstract models are eliminated in the generated prisma schema file.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#syntax-5 \"Direct link to Syntax\")\n\n```\n(abstract)? model [NAME] (extends [ABSTRACT_MODEL_NAME](,[ABSTRACT_MODEL_NAME])*)? {    [FIELD]*}\n```\n\n*   **\\[abstract\\]**:\n    \n    Optional. If present, the model is marked as abstract would not be mapped to a database table. Abstract models are only used as base classes for other models.\n    \n*   **\\[NAME\\]**:\n    \n    Name of the model. Needs to be unique in the entire model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[FIELD\\]**:\n    \n    Arbitrary number of fields. See [next section](https://zenstack.dev/docs/reference/zmodel-language#field) for details.\n    \n*   **\\[ABSTRACT\\_MODEL\\_NAME\\]**:\n    \n    Name of an abstract model.\n    \n\n### Note[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#note \"Direct link to Note\")\n\nA model must include a field marked with `@id` attribute. The `id` field serves as a unique identifier for a model entity and is mapped to the database table's primary key.\n\nSee [here](https://zenstack.dev/docs/reference/zmodel-language#attribute) for more details about attributes.\n\n### Example[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#example-3 \"Direct link to Example\")\n\n```\nabstract model Basic {    id String @id    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt}model User extends Basic {    name String }\n```\n\nThe generated prisma file only contains one `User` model:\n\n```\nmodel User {    id String @id    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    name String @id}\n```\n\n## Attribute[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#attribute \"Direct link to Attribute\")\n\nAttributes decorate fields and models and attach extra behaviors or constraints to them.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#syntax-6 \"Direct link to Syntax\")\n\n#### Field attribute[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#field-attribute \"Direct link to Field attribute\")\n\nField attribute name is prefixed by a single `@`.\n\n```\nid String @[ATTR_NAME](ARGS)?\n```\n\n*   **\\[ATTR\\_NAME\\]**\n\nAttribute name. See [below](https://zenstack.dev/docs/reference/zmodel-language#predefined-attributes) for a full list of attributes.\n\n*   **\\[ARGS\\]**\n\nSee [attribute arguments](https://zenstack.dev/docs/reference/zmodel-language#arguments).\n\n#### Model attribute[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#model-attribute \"Direct link to Model attribute\")\n\nField attribute name is prefixed double `@@`.\n\n```\nmodel Model {    @@[ATTR_NAME](ARGS)?}\n```\n\n*   **\\[ATTR\\_NAME\\]**\n\nAttribute name. See [below](https://zenstack.dev/docs/reference/zmodel-language#predefined-attributes) for a full list of attributes.\n\n*   **\\[ARGS\\]**\n\nSee [attribute arguments](https://zenstack.dev/docs/reference/zmodel-language#arguments).\n\n### Arguments[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#arguments \"Direct link to Arguments\")\n\nAttribute can be declared with a list of parameters and applied with a comma-separated list of arguments.\n\nArguments are mapped to parameters by position or by name. For example, for the `@default` attribute declared as:\n\n```\nattribute @default(_ value: ContextType)\n```\n\n, the following two ways of applying it are equivalent:\n\n```\npublished Boolean @default(value: false)\n```\n\n```\npublished Boolean @default(false)\n```\n\n### Parameter types[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#parameter-types \"Direct link to Parameter types\")\n\nAttribute parameters are typed. The following types are supported:\n\n*   Int\n    \n    Integer literal can be passed as argument.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @password(saltLength: Int?, salt: String?)\n    ```\n    \n    application:\n    \n    ```\n    password String @password(saltLength: 10)\n    ```\n    \n*   String\n    \n    String literal can be passed as argument.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @id(map: String?)\n    ```\n    \n    application:\n    \n    ```\n    id String @id(map: \"_id\")\n    ```\n    \n*   Boolean\n    \n    Boolean literal or expression can be passed as argument.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @@allow(_ operation: String, _ condition: Boolean)\n    ```\n    \n    application:\n    \n    ```\n    @@allow(\"read\", true)@@allow(\"update\", auth() != null)\n    ```\n    \n*   ContextType\n    \n    A special type that represents the type of the field onto which the attribute is attached.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @default(_ value: ContextType)\n    ```\n    \n    application:\n    \n    ```\n    f1 String @default(\"hello\")f2 Int @default(1)\n    ```\n    \n*   FieldReference\n    \n    References to fields defined in the current model.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @relation(    _ name: String?,    fields: FieldReference[]?,    references: FieldReference[]?,    onDelete: ReferentialAction?,    onUpdate: ReferentialAction?,    map: String?)\n    ```\n    \n    application:\n    \n    ```\n    model Model {    ...    // [ownerId] is a list of FieldReference    owner Owner @relation(fields: [ownerId], references: [id])    ownerId}\n    ```\n    \n*   Enum\n    \n    Attribute parameter can also be typed as predefined enum.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @relation(    _ name: String?,    fields: FieldReference[]?,    references: FieldReference[]?,    // ReferentialAction is a predefined enum    onDelete: ReferentialAction?,    onUpdate: ReferentialAction?,    map: String?)\n    ```\n    \n    application:\n    \n    ```\n    model Model {    // 'Cascade' is a predefined enum value    owner Owner @relation(..., onDelete: Cascade)}\n    ```\n    \n\nAn attribute parameter can be typed as any of the types above, a list of the above type, or an optional of the types above.\n\n```\n    model Model {        ...        f1 String        f2 String        // a list of FieldReference        @@unique([f1, f2])    }\n```\n\n### Attribute functions[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#attribute-functions \"Direct link to Attribute functions\")\n\nAttribute functions are used for providing values for attribute arguments, e.g., current `DateTime`, an autoincrement `Int`, etc. They can be used in place of attribute arguments, like:\n\n```\nmodel Model {    ...    serial Int @default(autoincrement())    createdAt DateTime @default(now())}\n```\n\nYou can find a list of predefined attribute functions [here](https://zenstack.dev/docs/reference/zmodel-language#predefined-attribute-functions).\n\n### Predefined attributes[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#predefined-attributes \"Direct link to Predefined attributes\")\n\n#### Field attributes[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#field-attributes \"Direct link to Field attributes\")\n\n##### @id[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#id \"Direct link to @id\")\n\n```\nattribute @id(map: String?)\n```\n\nDefines an ID on the model.\n\n_Params_:\n\nName\n\nDescription\n\nmap\n\nThe name of the underlying primary key constraint in the database\n\n##### @default[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#default \"Direct link to @default\")\n\n```\nattribute @default(_ value: ContextType)\n```\n\nDefines a default value for a field.\n\n_Params_:\n\nName\n\nDescription\n\nvalue\n\nThe default value expression\n\n##### @unique[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#unique \"Direct link to @unique\")\n\n```\nattribute @unique(map: String?)\n```\n\nDefines a unique constraint for this field.\n\n_Params_:\n\nName\n\nDescription\n\nmap\n\nThe name of the underlying primary key constraint in the database\n\n##### @relation[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#relation \"Direct link to @relation\")\n\n```\nattribute @relation(    _ name: String?,    fields: FieldReference[]?,     references: FieldReference[]?,     onDelete: ReferentialAction?,    onUpdate: ReferentialAction?,    map: String?)\n```\n\nDefines meta information about a relation.\n\n_Params_:\n\nName\n\nDescription\n\nname\n\nThe name of the relationship\n\nfields\n\nA list of fields defined in the current model\n\nreferences\n\nA list of fields of the model on the other side of the relation\n\nonDelete\n\nReferential action to take on delete. See details [here](https://zenstack.dev/docs/reference/zmodel-language#referential-action).\n\nonUpdate\n\nReferential action to take on update. See details [here](https://zenstack.dev/docs/reference/zmodel-language#referential-action).\n\n##### @map[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#map \"Direct link to @map\")\n\n```\nattribute @map(_ name: String)\n```\n\nMaps a field name or enum value from the schema to a column with a different name in the database.\n\n_Params_:\n\nName\n\nDescription\n\nmap\n\nThe name of the underlying column in the database\n\n##### @updatedAt[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#updatedat \"Direct link to @updatedAt\")\n\nAutomatically stores the time when a record was last updated.\n\n##### @ignore[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#ignore \"Direct link to @ignore\")\n\nExclude a field from the Prisma Client (for example, a field that you do not want Prisma users to update).\n\n##### @allow[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#allow \"Direct link to @allow\")\n\n```\nattribute @allow(_ operation: String, _ condition: Boolean)\n```\n\nDefines an access policy that allows the annotated field to be read or updated. Read more about access policies [here](https://zenstack.dev/docs/reference/zmodel-language#access-policy).\n\n_Params_:\n\nName\n\nDescription\n\noperation\n\nComma separated list of operations to control, including `\"read\"` and `\"update\"`. Pass `\"all\"` as an abbreviation for including all operations.\n\ncondition\n\nBoolean expression indicating if the operations should be allowed\n\n##### @deny[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#deny \"Direct link to @deny\")\n\n```\nattribute @deny(_ operation: String, _ condition: Boolean)\n```\n\nDefines an access policy that denies the annotated field to be read or updated. Read more about access policies [here](https://zenstack.dev/docs/reference/zmodel-language#access-policy).\n\n_Params_:\n\nName\n\nDescription\n\noperation\n\nComma separated list of operations to control, including `\"read\"` and `\"update\"`. Pass `\"all\"` as an abbreviation for including all operations.\n\ncondition\n\nBoolean expression indicating if the operations should be denied\n\n##### @password[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#password \"Direct link to @password\")\n\n```\nattribute @password(saltLength: Int?, salt: String?)\n```\n\nIndicates that the field is a password field and needs to be hashed before persistence.\n\n_NOTE_: ZenStack uses the \"bcryptjs\" library to hash passwords. You can use the `saltLength` parameter to configure the cost of hashing or use `salt` parameter to provide an explicit salt. By default, a salt length of 12 is used. See [here](https://www.npmjs.com/package/bcryptjs \":target=blank\") for more details.\n\n_Params_:\n\nName\n\nDescription\n\nsaltLength\n\nThe length of salt to use (cost factor for the hash function)\n\nsalt\n\nThe salt to use (a pregenerated valid salt)\n\n##### @omit[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#omit \"Direct link to @omit\")\n\nIndicates that the field should be omitted when read from the generated services. Commonly used together with `@password` attribute.\n\n##### @prisma.passthrough[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#prismapassthrough \"Direct link to @prisma.passthrough\")\n\n```\nattribute @prisma.passthrough(_ text: String)\n```\n\nA utility attribute for passing arbitrary text to the generated Prisma schema. This is useful as a workaround for dealing with discrepancies between Prisma schema and ZModel.\n\n_Params_:\n\nName\n\nDescription\n\ntext\n\nText to passthrough to Prisma schema\n\nE.g., the following ZModel content:\n\n```\nmodel User {    id Int @id @default(autoincrement())    name String @prisma.passthrough(\"@unique\")}\n```\n\nwil be translated to the following Prisma schema:\n\n```\nmodel User {    id Int @id @default(autoincrement())    name String @unique}\n```\n\n#### Model attributes[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#model-attributes \"Direct link to Model attributes\")\n\n##### @@id[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#id-1 \"Direct link to @@id\")\n\n```\nattribute @@id(_ fields: FieldReference[], name: String?, map: String?)\n```\n\nDefines a multi-field ID (composite ID) on the model.\n\n_Params_:\n\nName\n\nDescription\n\nfields\n\nA list of fields defined in the current model\n\nname\n\nThe name that the Client API will expose for the argument covering all fields\n\nmap\n\nThe name of the underlying primary key constraint in the database\n\n##### @@unique[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#unique-1 \"Direct link to @@unique\")\n\n```\nattribute @@unique(_ fields: FieldReference[], name: String?, map: String?)\n```\n\nDefines a compound unique constraint for the specified fields.\n\n_Params_:\n\nName\n\nDescription\n\nfields\n\nA list of fields defined in the current model\n\nname\n\nThe name of the unique combination of fields\n\nmap\n\nThe name of the underlying unique constraint in the database\n\n##### @@schema[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#schema \"Direct link to @@schema\")\n\n```\nattribute @@schema(_ name: String)\n```\n\nSpecifies the database schema to use in a [multi-schema setup](https://www.prisma.io/docs/guides/database/multi-schema).\n\n_Params_:\n\nName\n\nDescription\n\nname\n\nThe name of the database schema\n\n##### @@index[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#index \"Direct link to @@index\")\n\n```\nattribute @@index(_ fields: FieldReference[], map: String?)\n```\n\nDefines an index in the database.\n\n_Params_:\n\nName\n\nDescription\n\nfields\n\nA list of fields defined in the current model\n\nmap\n\nThe name of the underlying index in the database\n\n##### @@map[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#map-1 \"Direct link to @@map\")\n\n```\nattribute @@map(_ name: String)\n```\n\nMaps the schema model name to a table with a different name, or an enum name to a different underlying enum in the database.\n\n_Params_:\n\nName\n\nDescription\n\nname\n\nThe name of the underlying table or enum in the database\n\n##### @@ignore[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#ignore-1 \"Direct link to @@ignore\")\n\nExclude a model from the Prisma Client (for example, a model that you do not want Prisma users to update).\n\n##### @@allow[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#allow-1 \"Direct link to @@allow\")\n\n```\nattribute @@allow(_ operation: String, _ condition: Boolean)\n```\n\nDefines an access policy that allows a set of operations when the given condition is true. Read more about access policies [here](https://zenstack.dev/docs/reference/zmodel-language#access-policy).\n\n_Params_:\n\nName\n\nDescription\n\noperation\n\nComma separated list of operations to control, including `\"create\"`, `\"read\"`, `\"update\"`, and `\"delete\"`. Pass `\"all\"` as an abbriviation for including all operations.\n\ncondition\n\nBoolean expression indicating if the operations should be allowed\n\n##### @@deny[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#deny-1 \"Direct link to @@deny\")\n\n```\nattribute @@deny(_ operation: String, _ condition: Boolean)\n```\n\nDefines an access policy that denies a set of operations when the given condition is true. Read more about access policies [here](https://zenstack.dev/docs/reference/zmodel-language#access-policy).\n\n_Params_:\n\nName\n\nDescription\n\noperation\n\nComma separated list of operations to control, including `\"create\"`, `\"read\"`, `\"update\"`, and `\"delete\"`. Pass `\"all\"` as an abbreviation for including all operations.\n\ncondition\n\nBoolean expression indicating if the operations should be denied\n\n##### @@auth[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#auth \"Direct link to @@auth\")\n\nSpecify the model for resolving `auth()` function call in access policies. By default, the model named \"User\" is used. You can use this attribute to override the default behavior. A Zmodel can have at most one model with this attribute.\n\n##### @@auth[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#auth-1 \"Direct link to @@auth\")\n\n```\nattribute @@delegate(_ discriminator: FieldReference)\n```\n\nMarks a model to be a delegated type. Used for [modeling a polymorphic hierarchy](https://zenstack.dev/docs/guides/polymorphism).\n\n_Params_:\n\nName\n\nDescription\n\ndiscriminator\n\nA `String` or `enum` field in the same model used to store the name of the concrete model that inherit from this base model.\n\n##### @@prisma.passthrough[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#prismapassthrough-1 \"Direct link to @@prisma.passthrough\")\n\n```\nattribute @@prisma.passthrough(_ text: String)\n```\n\nA utility attribute for passing arbitrary text to the generated Prisma schema. This is useful as a workaround for dealing with discrepancies between Prisma schema and ZModel.\n\n_Params_:\n\nName\n\nDescription\n\ntext\n\nText to passthrough to Prisma schema\n\nE.g., the following ZModel content:\n\n```\nmodel User {    id Int @id @default(autoincrement())    name String    @@prisma.passthrough(\"@@unique([name])\")}\n```\n\nwil be translated to the following Prisma schema:\n\n```\nmodel User {    id Int @id @default(autoincrement())    name String    @@unique([name])}\n```\n\n### Predefined attribute functions[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#predefined-attribute-functions \"Direct link to Predefined attribute functions\")\n\n##### uuid()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#uuid \"Direct link to uuid()\")\n\n```\nfunction uuid(): String {}\n```\n\nGenerates a globally unique identifier based on the UUID spec.\n\n##### cuid()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#cuid \"Direct link to cuid()\")\n\n```\nfunction cuid(): String {}\n```\n\nGenerates a globally unique identifier based on the [CUID](https://github.com/ericelliott/cuid) spec.\n\n##### now()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#now \"Direct link to now()\")\n\n```\nfunction now(): DateTime {}\n```\n\nGets current date-time.\n\n##### autoincrement()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#autoincrement \"Direct link to autoincrement()\")\n\n```\nfunction autoincrement(): Int {}\n```\n\nCreates a sequence of integers in the underlying database and assign the incremented values to the ID values of the created records based on the sequence.\n\n##### dbgenerated()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#dbgenerated \"Direct link to dbgenerated()\")\n\n```\nfunction dbgenerated(expr: String): Any {}\n```\n\nRepresents default values that cannot be expressed in the Prisma schema (such as random()).\n\n##### auth()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#auth-2 \"Direct link to auth()\")\n\nGets the current login user. The return type of the function is the `User` model defined in the current ZModel.\n\n##### future()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#future \"Direct link to future()\")\n\n```\nfunction future(): Any {}\n```\n\nGets the \"post-update\" state of an entity. Only valid when used in a \"update\" access policy. Read more about access policies [here](https://zenstack.dev/docs/reference/zmodel-language#access-policy).\n\n##### contains()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#contains \"Direct link to contains()\")\n\n```\n    function contains(field: String, search: String, caseInSensitive: Boolean?): Boolean {}\n```\n\nChecks if the given field contains the search string. The search string is case-sensitive by default. Use `caseInSensitive` to toggle the case sensitivity.\n\nEquivalent to Prisma's [contains](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#contains) operator.\n\n##### search()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#search \"Direct link to search()\")\n\n```\nfunction search(field: String, search: String): Boolean {}\n```\n\nChecks if the given field contains the search string using [full-text-search](https://www.prisma.io/docs/concepts/components/prisma-client/full-text-search).\n\nEquivalent to Prisma's [search](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#search) operator.\n\n##### startsWith()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#startswith \"Direct link to startsWith()\")\n\n```\nfunction startsWith(field: String, search: String): Boolean {}\n```\n\nChecks if the given field starts with the search string.\n\nEquivalent to Prisma's [startsWith](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#startswith) operator.\n\n##### endsWith()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#endswith \"Direct link to endsWith()\")\n\n```\nfunction endsWith(field: String, search: String): Boolean {}\n```\n\nChecks if the given field ends with the search string.\n\nEquivalent to Prisma's [endsWith](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#endswith) operator.\n\n##### has()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#has \"Direct link to has()\")\n\n```\nfunction has(field: Any[], search: Any): Boolean {}\n```\n\nCheck if the given field (list) contains the search value.\n\nEquivalent to Prisma's [has](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#has) operator.\n\n##### hasEvery()[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#hasevery \"Direct link to hasEvery()\")\n\n```\nfunction hasEvery(field: Any[], search: Any[]): Boolean {}\n```\n\nCheck if the given field (list) contains every element of the search list.\n\nEquivalent to Prisma's [hasEvery](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#hasevery) operator.\n\n##### hasSome[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#hassome \"Direct link to hasSome\")\n\n```\nfunction hasSome(field: Any[], search: Any[]): Boolean {}\n```\n\nCheck if the given field (list) contains at least one element of the search list.\n\nEquivalent to Prisma's [hasSome](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#hassome) operator.\n\n##### isEmpty[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#isempty \"Direct link to isEmpty\")\n\n```\nfunction isEmpty(field: Any[]): Boolean {}\n```\n\nCheck if the given field (list) is empty.\n\nEquivalent to Prisma's [isEmpty](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#isempty) operator.\n\n### Examples[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#examples-2 \"Direct link to Examples\")\n\nHere're some examples on using field and model attributes:\n\n```\nmodel User {    // unique id field with a default UUID value    id String @id @default(uuid())    // require email field to be unique    email String @unique    // password is hashed with bcrypt with length of 16, omitted when returned from the CRUD services    password String @password(saltLength: 16) @omit    // default to current date-time    createdAt DateTime @default(now())    // auto-updated when the entity is modified    updatedAt DateTime @updatedAt    // mapping to a different column name in database    description String @map(\"desc\")    // mapping to a different table name in database    @@map(\"users\")    // use @@index to specify fields to create database index for    @@index([email])    // use @@allow to specify access policies    @@allow(\"create,read\", true)    // use auth() to reference the current user    // use future() to access the \"post-update\" state    @@allow(\"update\", auth() == this && future().email == email)}\n```\n\n### Custom attributes and functions[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#custom-attributes-and-functions \"Direct link to Custom attributes and functions\")\n\nYou can find examples of custom attributes and functions in [ZModel Standard Library](https://github.com/zenstackhq/zenstack/blob/main/packages/schema/src/res/stdlib.zmodel).\n\n## Field[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#field \"Direct link to Field\")\n\nFields are typed members of models.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#syntax-7 \"Direct link to Syntax\")\n\n```\nmodel Model {    [FIELD_NAME] [FIELD_TYPE] (FIELD_ATTRIBUTES)?}\n```\n\n*   **\\[FIELD\\_NAME\\]**\n    \n    Name of the field. Needs to be unique in the containing model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[FIELD\\_TYPE\\]**\n    \n    Type of the field. Can be a scalar type or a reference to another model.\n    \n    The following scalar types are supported:\n    \n    *   String\n    *   Boolean\n    *   Int\n    *   BigInt\n    *   Float\n    *   Decimal\n    *   Json\n    *   Bytes\n    *   [Unsupported types](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#unsupported-types)\n    \n    A field's type can be any of the scalar or reference type, a list of the aforementioned type (suffixed with `[]`), or an optional of the aforementioned type (suffixed with `?`).\n    \n*   **\\[FIELD\\_ATTRIBUTES\\]**\n    \n    Field attributes attach extra behaviors or constraints to the field. See [Attribute](https://zenstack.dev/docs/reference/zmodel-language#attribute) for more information.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#example-4 \"Direct link to Example\")\n\n```\nmodel Post {    // \"id\" field is a mandatory unique identifier of this model    id String @id @default(uuid())    // fields can be DateTime    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    // or string    title String    // or integer    viewCount Int @default(0)    // and optional    content String?    // and a list too    tags String[]    // and can reference another model too    comments Comment[]}\n```\n\n## Relation[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#relation-1 \"Direct link to Relation\")\n\nRelations are connections among models. There're three types of relations:\n\n*   One-to-one\n*   One-to-many\n*   Many-to-many\n\nRelations are expressed with a pair of fields and together with the special `@relation` field attribute. One side of the relation field carries the `@relation` attribute to indicate how the connection is established.\n\n### One-to-one relation[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#one-to-one-relation \"Direct link to One-to-one relation\")\n\nThe _owner_ side of the relation declares an optional field typed as the model of the _owned_ side of the relation.\n\nOn the _owned_ side, a reference field is declared with `@relation` attribute, together with a **foreign key** field storing the id of the owner entity.\n\n```\nmodel User {    id String @id    profile Profile?}model Profile {    id String @id    user User @relation(fields: [userId], references: [id])    userId String @unique}\n```\n\n### One-to-many relation[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#one-to-many-relation \"Direct link to One-to-many relation\")\n\nThe _owner_ side of the relation declares a list field typed as the model of the _owned_ side of the relation.\n\nOn the _owned_ side, a reference field is declared with `@relation` attribute, together with a **foreign key** field storing the id of the owner entity.\n\n```\nmodel User {    id String @id    posts Post[]}model Post {    id String @id    author User? @relation(fields: [authorId], references: [id])    authorId String?}\n```\n\n### Many-to-many relation[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#many-to-many-relation \"Direct link to Many-to-many relation\")\n\nA _join model_ is declared to connect the two sides of the relation using two one-to-one relations.\n\nEach side of the relation then establishes a one-to-many relation with the _join model_.\n\n```\nmodel Space {    id String @id    // one-to-many with the \"join-model\"    members Membership[]}// Membership is the \"join-model\" between User and Spacemodel Membership {    id String @id()    // one-to-many from Space    space Space @relation(fields: [spaceId], references: [id])    spaceId String    // one-to-many from User    user User @relation(fields: [userId], references: [id])    userId String    // a user can be member of a space for only once    @@unique([userId, spaceId])}model User {    id String @id    // one-to-many with the \"join-model\"    membership Membership[]}\n```\n\n### Self-relations[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#self-relations \"Direct link to Self-relations\")\n\nA relation field referencing its own model is called \"self-relation\". ZModel's represents self-relation in the same way as Prisma does. Please refer to the [Prisma documentation](https://www.prisma.io/docs/concepts/components/prisma-schema/relations/self-relations) for more details.\n\n### Referential action[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#referential-action \"Direct link to Referential action\")\n\nWhen defining a relation, you can specify what happens when one side of a relation is updated or deleted. See [Referential action](https://zenstack.dev/docs/reference/zmodel-language#referential-action) for details.\n\n## Access policy[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#access-policy \"Direct link to Access policy\")\n\n### Model-level policy[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#model-level-policy \"Direct link to Model-level policy\")\n\nModel-level access policies are defined with `@@allow` and `@@deny` attributes. They specify the eligibility of an operation over a model entity. The signatures of the attributes are:\n\n*   `@@allow`\n    \n    ```\n        attribute @@allow(_ operation: String, _ condition: Boolean)\n    ```\n    \n    _Params_:\n    \n    Name\n    \n    Description\n    \n    operation\n    \n    Comma separated list of operations to control, including `\"create\"`, `\"read\"`, `\"update\"`, and `\"delete\"`. Pass `\"all\"` as an abbreviation for including all operations.\n    \n    condition\n    \n    Boolean expression indicating if the operations should be allowed\n    \n*   `@@deny`\n    \n    ```\n        attribute @@deny(_ operation: String, _ condition: Boolean)\n    ```\n    \n    _Params_:\n    \n    Name\n    \n    Description\n    \n    operation\n    \n    Comma separated list of operations to control, including `\"create\"`, `\"read\"`, `\"update\"`, and `\"delete\"`. Pass `\"all\"` as an abbreviation for including all operations.\n    \n    condition\n    \n    Boolean expression indicating if the operations should be denied\n    \n\n### Field-level policy[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#field-level-policy \"Direct link to Field-level policy\")\n\nField-level access policies are defined with `@allow` and `@deny` attributes. They control whether the annotated field can be read or updated. If a field fails \"read\" check, it'll be deleted when returned. If a field is set to be updated but fails \"update\" check, the update operation will be rejected.\n\nNote that it's not allowed to put \"update\" rule on relation fields, because whether an entity can be updated shouldn't be determined indirectly by a relation, but directly by the entity itself. However, you can put \"update\" rule on a foreign key field to control how a a relation can be updated.\n\nThe signatures of the attributes are:\n\n*   `@allow`\n    \n    ```\n        attribute @allow(_ operation: String, _ condition: Boolean, _ override: Boolean?)\n    ```\n    \n    _Params_:\n    \n    Name\n    \n    Description\n    \n    Default\n    \n    operation\n    \n    Comma separated list of operations to control, including `\"read\"` and `\"update\"`. Pass `\"all\"` as an abbreviation for including all operations.\n    \n    condition\n    \n    Boolean expression indicating if the operations should be allowed\n    \n    override\n    \n    Boolean indicating if the field-level policy should override model-level ones. See [here](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/field-level#overriding-model-level-policies) for more details.\n    \n    false\n    \n*   `@deny`\n    \n    ```\n        attribute @deny(_ operation: String, _ condition: Boolean)\n    ```\n    \n    _Params_:\n    \n    Name\n    \n    Description\n    \n    operation\n    \n    Comma separated list of operations to control, including \\`\\`\"read\"`and`\"update\"`. Pass` \"all\"\\` as an abbreviation for including all operations.\n    \n    condition\n    \n    Boolean expression indicating if the operations should be denied\n    \n\n### Policy expressions[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#policy-expressions \"Direct link to Policy expressions\")\n\nPolicy rules use boolean expressions to make verdicts. ZModel provides a set of literals and operators for constructing expressions of arbitrary complexity.\n\n```\nExpression ::= Literal | Array | This | Null | Reference | MemberAccess | Invocation | Binary | Unary | CollectionPredicateLiteral ::= String | Number | BooleanArray ::= \"[\" Expression [, Expression]* \"]\"This ::= \"this\"Null ::= \"null\"Reference ::= IdentifierMemberAccess ::= Expression \".\" IdentifierOperator_Precedence#tableBinary ::= Expression (\"==\" | \"!=\" | \">\" | \"<\" | \">=\" | \"<=\" | \"&&\" | \"||\" || \"in\")Unary ::= \"!\" ExpressionCollectionPredicate ::= Expression (\"?\" | \"!\" | \"^\") \"[\" Expression \"]\"\n```\n\nBinary operator precedence follows [Javascript's rules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/).\n\nCollection predicate expressions are used for reaching into relation fields. You can find more details [here](https://zenstack.dev/docs/reference/zmodel-language#collection-predicate-expressions).\n\n### Using authentication in policy rules[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#using-authentication-in-policy-rules \"Direct link to Using authentication in policy rules\")\n\nIt's very common to use the current login user to verdict if an operation should be permitted. Therefore, ZenStack provides a built-in `auth()` attribute function that evaluates to the `User` entity corresponding to the current user. To use the function, your ZModel file must define a `User` model or a model marked with the `@@auth` attribute.\n\nYou can use `auth()` to:\n\n*   Check if a user is logged in\n    \n    ```\n    @@deny('all', auth() == null)\n    ```\n    \n*   Access user's fields\n    \n    ```\n    @@allow('update', auth().role == 'ADMIN')\n    ```\n    \n*   Compare user identity\n    \n    ```\n    // owner is a relation field to User model@@allow('update', auth() == owner)\n    ```\n    \n\n### Accessing relation fields in policy[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#accessing-relation-fields-in-policy \"Direct link to Accessing relation fields in policy\")\n\nAs you've seen in the examples above, you can access fields from relations in policy expressions. For example, to express \"a user can be read by any user sharing a space\" in the `User` model, you can directly read into its `membership` field.\n\n```\n    @@allow('read', membership?[space.members?[user == auth()]])\n```\n\nIn most cases, when you use a \"to-many\" relation in a policy rule, you'll use \"Collection Predicate\" to express a condition. See [next section](https://zenstack.dev/docs/reference/zmodel-language#collection-predicate-expressions) for details.\n\n### Collection predicate expressions[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#collection-predicate-expressions \"Direct link to Collection predicate expressions\")\n\nCollection predicate expressions are boolean expressions used to express conditions over a list. It's mainly designed for building policy rules for \"to-many\" relations. It has three forms of syntaxes:\n\n*   Any\n    \n    Any element in `collection` matches `condition`\n    \n*   All\n    \n    All elements in `collection` match `condition`\n    \n*   None\n    \n    None element in `collection` matches `condition`\n    \n\nThe `condition` expression has direct access to fields defined in the model of `collection`. E.g.:\n\n```\n    @@allow('read', members?[user == auth()])\n```\n\n, in condition `user == auth()`, `user` refers to the `user` field in model `Membership`, because the collection `members` is resolved to `Membership` model.\n\nAlso, collection predicates can be nested to express complex conditions involving multi-level relation lookup. E.g.:\n\n```\n    @@allow('read', membership?[space.members?[user == auth()]])\n```\n\nIn this example, `user` refers to `user` field of `Membership` model because `space.members` is resolved to `Membership` model.\n\n### Combining multiple rules[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#combining-multiple-rules \"Direct link to Combining multiple rules\")\n\nA model can contain an arbitrary number of policy rules. The logic of combining model-level rules is as follows:\n\n*   The operation is rejected if any of the conditions in `@@deny` rules evaluate to `true`.\n*   Otherwise, the operation is permitted if any of the conditions in `@@allow` rules evaluate to `true`.\n*   Otherwise, the operation is rejected.\n\nA field can also contain an arbitrary number of policy rules. The logic of combining field-level rules is as follows:\n\n*   The operation is rejected if any of the conditions in `@deny` rules evaluate to `true`.\n*   Otherwise, if there exists any `@allow` rule and at least one of them evaluates to `true`, the operation is permitted.\n*   Otherwise, if there exists any `@allow` rule but none one of them evaluates to `true`, the operation is rejected.\n*   Otherwise, the operation is permitted.\n\nPlease note the difference between model-level and field-level rules. Model-level access are by-default denied, while field-level access are by-default allowed.\n\n### Pre-update vs. post-update[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#pre-update-vs-post-update \"Direct link to Pre-update vs. post-update\")\n\nWhen an access policy rule is applied to a mutate operation, the entities under operation have a \"pre\" and \"post\" state. For a \"create\" rule, its \"pre\" state is empty, so the rule implicitly refers to the \"post\" state. For a \"delete\" rule, its \"post\" state is empty, so the rule implicitly refers to the \"pre\" state.\n\nHowever, for \"update\" rules it is ambiguous; both the \"pre\" and the \"post\" states exist. By default, for \"update\" rules, fields referenced in the expressions refer to the \"pre\" state, and you can use the `future()` function to refer to the \"post\" state explicitly.\n\nIn the following example, the \"update\" rule uses `future()` to ensure an update cannot alter the post's owner.\n\n```\nmodel Post {    id String @id @default(uuid())    title String @length(1, 100)    author User @relation(fields: [authorId], references: [id], onDelete: Cascade)    authorId String    // update can only be done by the author, and is not allowed to change author    @@allow('update', author == auth() && future().author == author)}\n```\n\ninfo\n\nThe `future()` function is not supported in field-level access policies. To express post-update rules, put them into model-level policies.\n\n### Examples[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#examples-3 \"Direct link to Examples\")\n\n#### A simple example with Post model[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#a-simple-example-with-post-model \"Direct link to A simple example with Post model\")\n\n```\nmodel Post {    // reject all operations if user's not logged in    @@deny('all', auth() == null)    // allow all operations if the entity's owner matches the current user    @@allow('all', auth() == owner)    // posts are readable to anyone    @allow('read', true)}\n```\n\n#### A more complex example with multi-user spaces[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#a-more-complex-example-with-multi-user-spaces \"Direct link to A more complex example with multi-user spaces\")\n\n```\nmodel Space {    id String @id    members Membership[]    owner User @relation(fields: [ownerId], references: [id])    ownerId String    // require login    @@deny('all', auth() == null)    // everyone can create a space    @@allow('create', true)    // owner can do everything    @@allow('all', auth() == owner)    // any user in the space can read the space    //    // Here the <collection>?[condition] syntax is called    // \"Collection Predicate\", used to check if any element    // in the \"collection\" matches the \"condition\"    @@allow('read', members?[user == auth()])}// Membership is the \"join-model\" between User and Spacemodel Membership {    id String @id()    // one-to-many from Space    space Space @relation(fields: [spaceId], references: [id])    spaceId String    // one-to-many from User    user User @relation(fields: [userId], references: [id])    userId String    // a user can be member of a space for only once    @@unique([userId, spaceId])    // require login    @@deny('all', auth() == null)    // space owner can create/update/delete    @@allow('create,update,delete', space.owner == auth())    // user can read entries for spaces which he's a member of    @@allow('read', space.members?[user == auth()])}model User {    id String @id    email String @unique    membership Membership[]    ownedSpaces Space[]    // allow signup    @@allow('create', true)    // user can do everything to herself; note that \"this\" represents    // the current entity    @@allow('all', auth() == this)    // can be read by users sharing a space    @@allow('read', membership?[space.members?[user == auth()]])}\n```\n\n## Data validation[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#data-validation \"Direct link to Data validation\")\n\n### Overview[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#overview-1 \"Direct link to Overview\")\n\nData validation is used for attaching constraints to field values. Unlike access policies, field validation rules cannot access the current user with the `auth()` function and are only checked for 'create' and 'update' operations. The main purpose of field validation is to ensure data integrity and consistency, not for access control.\n\nThe [`@core/zod`](https://zenstack.dev/docs/reference/plugins/zod) plugin recognizes the validation attributes and includes them into the generated Zod schemas.\n\n### Field-level validation attributes[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#field-level-validation-attributes \"Direct link to Field-level validation attributes\")\n\nThe following attributes can be used to attach validation rules to individual fields:\n\n#### String[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#string \"Direct link to String\")\n\n*   `@length(_ min: Int?, _ max: Int?, _ message: String?)`\n    \n    Validates length of a string field.\n    \n*   `@startsWith(_ text: String, _ message: String?)`\n    \n    Validates a string field value starts with the given text.\n    \n*   `@endsWith(_ text: String, _ message: String?)`\n    \n    Validates a string field value ends with the given text.\n    \n*   `@contains(_text: String, _ message: String?)`\n    \n    Validates a string field value contains the given text.\n    \n*   `@email(_ message: String?)`\n    \n    Validates a string field value is a valid email address.\n    \n*   `@url(_ message: String?)`\n    \n    Validates a string field value is a valid url.\n    \n*   `@datetime(_ message: String?)`\n    \n    Validates a string field value is a valid ISO datetime.\n    \n*   `@regex(_ regex: String, _ message: String?)`\n    \n    Validates a string field value matches a regex.\n    \n*   `@trim(_ value: String)`\n    \n    Trims whitespace.\n    \n*   `@lower(_ value: String)`\n    \n    Converts to lowercase.\n    \n*   `@upper(_ value: String)`\n    \n    Converts to uppercase.\n    \n\ninfo\n\nAttributes `@trim`, `@lower`, and `@upper` are actually \"transformation\" instead of \"validation\". They make sure the values are transformed before storing into the database.\n\n#### Number[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#number \"Direct link to Number\")\n\n*   `@gt(_ value: Int, _ message: String?)`\n    \n    Validates a number field is greater than the given value.\n    \n*   `@gte(_ value: Int, _ message: String?)`\n    \n    Validates a number field is greater than or equal to the given value.\n    \n*   `@lt(_ value: Int, _ message: String?)`\n    \n    Validates a number field is less than the given value.\n    \n*   `@lte(_ value: Int, _ message: String?)`\n    \n    Validates a number field is less than or equal to the given value.\n    \n\n### Model-level validation attributes[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#model-level-validation-attributes \"Direct link to Model-level validation attributes\")\n\nYou can use the `@@validate` attribute to attach validation rules to a model.\n\n```\n@@validate(_ value: Boolean, _ message: String?)\n```\n\nModel-level rules can reference multiple fields, use relation operators (`==`, `!=`, `>`, `>=`, `<`, `<=`) to compare fields, use boolean operators (`&&`, `||`, and `!`) to compose conditions, and can use the following functions to evaluate conditions for fields:\n\n*   `function length(field: String, min: Int, max: Int?): Boolean`\n    \n    Validates length of a string field.\n    \n*   `function regex(field: String, regex: String): Boolean`\n    \n    Validates a string field value matches a regex.\n    \n*   `function email(field: String): Boolean`\n    \n    Validates a string field value is a valid email address.\n    \n*   `function datetime(field: String): Boolean`\n    \n    Validates a string field value is a valid ISO datetime.\n    \n*   `function url(field: String)`\n    \n    Validates a string field value is a valid url.\n    \n*   `function contains(field: String, search: String, caseInSensitive: Boolean?): Boolean`\n    \n    Validates a string field contains the search string.\n    \n*   `function startsWith(field: String, search: String): Boolean`\n    \n    Validates a string field starts with the search string.\n    \n*   `function endsWith(field: String, search: String): Boolean`\n    \n    Validates a string field ends with the search string.\n    \n*   `function has(field: Any[], search: Any): Boolean`\n    \n    Validates a list field contains the search value.\n    \n*   `function hasEvery(field: Any[], search: Any[]): Boolean`\n    \n    Validates a list field contains every element in the search list.\n    \n*   `function hasSome(field: Any[], search: Any[]): Boolean`\n    \n    Validates a list field contains some elements in the search list.\n    \n*   `function isEmpty(field: Any[]): Boolean`\n    \n    Validates a list field is null or empty.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#example-5 \"Direct link to Example\")\n\n```\nmodel User {    id String @id    handle String @regex(\"^[0-9a-zA-Z]{4,16}$\")    email String? @email @endsWith(\"@myorg.com\", \"must be an email from myorg.com\")    profileImage String? @url    age Int @gte(18)    activated Boolean @default(false)    @@validate(!activated || email != null, \"activated user must have an email\")}\n```\n\n## Referential action[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#referential-action-1 \"Direct link to Referential action\")\n\n### Overview[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#overview-2 \"Direct link to Overview\")\n\nWhen defining a relation, you can use referential action to control what happens when one side of a relation is updated or deleted by setting the `onDelete` and `onUpdate` parameters in the `@relation` attribute.\n\n```\nattribute @relation(    _ name: String?,    fields: FieldReference[]?,    references: FieldReference[]?,    onDelete: ReferentialAction?,    onUpdate: ReferentialAction?,    map: String?)\n```\n\nThe `ReferentialAction` enum is defined as:\n\n```\nenum ReferentialAction {    Cascade    Restrict    NoAction    SetNull    SetDefault}\n```\n\n*   `Cascade`\n    \n    *   **onDelete**: deleting a referenced record will trigger the deletion of referencing record.\n        \n    *   **onUpdate**: updates the relation scalar fields if the referenced scalar fields of the dependent record are updated.\n        \n*   `Restrict`\n    \n    *   **onDelete**: prevents the deletion if any referencing records exist.\n    *   **onUpdate**: prevents the identifier of a referenced record from being changed.\n*   `NoAction`\n    \n    Similar to 'Restrict', the difference between the two is dependent on the database being used.\n    \n    See details [here](https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions#noaction \":target=blank\")\n    \n*   `SetNull`\n    \n    *   **onDelete**: the scalar field of the referencing object will be set to NULL.\n    *   **onUpdate**: when updating the identifier of a referenced object, the scalar fields of the referencing objects will be set to NULL.\n*   `SetDefault`\n    \n    *   **onDelete**: the scalar field of the referencing object will be set to the fields default value.\n    *   **onUpdate**: the scalar field of the referencing object will be set to the fields default value.\n\n### Example[‚Äã](https://zenstack.dev/docs/reference/zmodel-language#example-6 \"Direct link to Example\")\n\n```\nmodel User {    id String @id    profile Profile?}model Profile {    id String @id    user @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)    userId String @unique}\n```",
  "title": "ZModel Language Reference | ZenStack",
  "description": "ZModel language references",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/category/plugins",
  "markdown": "# Plugins | ZenStack\n\n[\n\n## üìÑÔ∏è @zenstackhq/tanstack-query\n\nPlugin for generating Tanstack Query query and mutation hooks\n\n](https://zenstack.dev/docs/reference/plugins/tanstack-query)",
  "title": "Plugins | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/category/server-adapters",
  "markdown": "# Server Adapters | ZenStack\n\nVersion: 2.x\n\n[\n\n## üìÑÔ∏è Next.js\n\nAdapter for integrating with Next.js\n\n](https://zenstack.dev/docs/reference/server-adapters/next)\n\n[\n\n## üìÑÔ∏è Nuxt\n\nAdapter for integrating with Nuxt\n\n](https://zenstack.dev/docs/reference/server-adapters/nuxt)\n\n[\n\n## üìÑÔ∏è SvelteKit\n\nAdapter for integrating with SvelteKit\n\n](https://zenstack.dev/docs/reference/server-adapters/sveltekit)\n\n[\n\n## üìÑÔ∏è Express.js\n\nAdapter for integrating with Express.js\n\n](https://zenstack.dev/docs/reference/server-adapters/express)\n\n[\n\n## üìÑÔ∏è Fastify\n\nAdapter for integrating with Fastify\n\n](https://zenstack.dev/docs/reference/server-adapters/fastify)\n\n[\n\n## üìÑÔ∏è NestJS\n\nAdapter for integrating with NestJS\n\n](https://zenstack.dev/docs/reference/server-adapters/nestjs)\n\n[\n\n## üóÉÔ∏è API Handlers\n\n2 items\n\n](https://zenstack.dev/docs/reference/server-adapters/api-handlers/)",
  "title": "Server Adapters | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/limitations",
  "markdown": "# Limitations | ZenStack\n\nThis section lists the current limitations of ZenStack.\n\n### Sequential operations transaction[‚Äã](https://zenstack.dev/docs/reference/limitations#sequential-operations-transaction \"Direct link to Sequential operations transaction\")\n\n[Sequential operations transaction](https://www.prisma.io/docs/concepts/components/prisma-client/transactions#sequential-prisma-client-operations) is not supported by enhanced Prisma clients yet.\n\nAs a workaround, use [interactive transactions](https://www.prisma.io/docs/concepts/components/prisma-client/transactions#interactive-transactions) instead.\n\n### MongoDB is not supported[‚Äã](https://zenstack.dev/docs/reference/limitations#mongodb-is-not-supported \"Direct link to MongoDB is not supported\")\n\nRight now, the focus of this project is SQL databases, and there's no plan to support MongoDB in the near future.\n\n### Cloudflare D1 database is not supported[‚Äã](https://zenstack.dev/docs/reference/limitations#cloudflare-d1-database-is-not-supported \"Direct link to Cloudflare D1 database is not supported\")\n\nPrisma doesn't support interactive transactions with D1 databases. ZenStack relies on the feature to enforce access policies in certain cases.",
  "title": "Limitations | ZenStack",
  "description": "Current limitations",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/error-handling",
  "markdown": "# Error Handling | ZenStack\n\nZenStack's enhancements to Prisma clients are transparent proxies, so normal errors thrown from a Prisma client simply pass through, and you can handle them the same way as you do in a regular Prisma project. It's good to read these references from Prisma:\n\nThe enhanced Prisma client can throw extra errors when an operation is rejected by [access policies](https://zenstack.dev/docs/reference/zmodel-language#access-policy) or its data fails [validation rules](https://zenstack.dev/docs/reference/zmodel-language#data-validation). To keep a consistent programming experience, a `PrismaClientKnownRequestError` is thrown with code [`P2004`](https://www.prisma.io/docs/reference/api-reference/error-reference#p2004) is used in such cases:\n\n```\nthrow new PrismaClientKnownRequestError(message, {    clientVersion: getVersion(),    code: 'P2004',    meta: ...});\n```\n\nThe error contains a `meta` field providing more information about the error. It contains the following fields:",
  "title": "Error Handling | ZenStack",
  "description": "Error handling",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/install",
  "markdown": "# Installing ZenStack | ZenStack\n\nVersion: 1.x\n\nYou can install ZenStack to your project using one of the following methods.\n\n### Using `zenstack init`[‚Äã](https://zenstack.dev/docs/1.x/install#using-zenstack-init \"Direct link to using-zenstack-init\")\n\nThe easiest way to install ZenStack is to use the `zenstack init` command. In an existing TypeScript project folder, run the following command:\n\nThe \"init\" command does the following things for you:\n\n1.  Install Prisma if it's not already installed.\n2.  Install the `zenstack` CLI package as a dev dependency.\n3.  Install the `@zenstackhq/runtime` package - used for enhancing `PrismaClient` at the runtime.\n4.  Copy the `prisma/schema.prisma` file to `schema.zmodel` if it exists; otherwise, create a new template `schema.zmodel` file.\n\nYou can always manually complete the steps above if you have a special project setup that the \"init\" command doesn't work with.\n\nAfter the initialization, please remember that you should edit the `schema.zmodel` moving forward. The `prisma/schema.prisma` file will be automatically regenerated when you run `zenstack generate`.\n\n### Manually[‚Äã](https://zenstack.dev/docs/1.x/install#manually \"Direct link to Manually\")\n\nThe following steps show how to install using \"npm\" as package manager. Replace it with the one you use for your project (like pnpm or yarn).\n\n1.  Make sure Prisma is installed\n    \n2.  Install the `zenstack` CLI package as a dev dependency\n    \n    ```\n    npm install --save-dev zenstack@1\n    ```\n    \n3.  Install the `@zenstackhq/runtime` package as a regular dependency\n    \n    ```\n    npm install @zenstackhq/runtime@1\n    ```\n    \n4.  Bootstrap ZModel from Prisma schema\n    \n    If you have a Prisma schema file, copy it to `schema.zmodel` in the project root folder. Remember, you should edit the `schema.zmodel` moving forward. The `prisma/schema.prisma` file will automatically regenerate when you run `zenstack generate`.\n    \n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Installing ZenStack | ZenStack",
  "description": "Installation",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/telemetry",
  "markdown": "# Telemetry | ZenStack\n\nZenStack CLI and VSCode extension sends anonymous telemetry for analyzing usage stats and finding bugs.\n\nWe don't collect any telemetry at the runtime of apps built with ZenStack.\n\nWe appreciate that you keep the telemetry ON so we can keep improving the toolkit. We follow the [Console Do Not Track](https://consoledonottrack.com/ \":target=blank\") convention, and you can turn off the telemetry by setting the environment variable `DO_NOT_TRACK` to `1`:\n\n```\nDO_NOT_TRACK=1 npx zenstack ...\n```",
  "title": "Telemetry | ZenStack",
  "description": "Telemetry",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/category/quick-start",
  "markdown": "# Quick Start | ZenStack\n\n[\n\n## üìÑÔ∏è Next.js (pages router)\n\nStep-by-step guide for building a blogging app with Next.js (pages router).\n\n](https://zenstack.dev/docs/1.x/quick-start/nextjs)",
  "title": "Quick Start | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/quick-start/nuxt",
  "markdown": "# Nuxt | ZenStack\n\n## Get Started With Nuxt (V3)\n\nNuxt is an excellent full-stack framework built around Vue.js. It provides the structure and facilities that help you build complete web apps with ease. In this tutorial, we'll demonstrate how to build a simple blogging app. You'll see how effortless it is to build a fully secure application with Nuxt and ZenStack combined.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-nuxt).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nuxt#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nuxt#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nuxt#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Creating a new project[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nuxt#1-creating-a-new-project \"Direct link to 1. Creating a new project\")\n\nAlthough authentication is not the focus of the project, we need a basic signup/signin system to get going. The [Nuxt with Local Auth](https://github.com/nuxt/examples/tree/main/auth/local) sample can serve as a good starter.\n\nFirst, make a copy of the project using [degit](https://github.com/Rich-Harris/degit), install dependencies, and start the dev server:\n\n```\nnpx degit nuxt/examples/auth/local my-nuxt-blogcd my-nuxt-blognpm installnpm run dev\n```\n\nIf everything works, you should have a running Nuxt app at [http://localhost:3000](http://localhost:3000/).\n\n![](https://zenstack.dev/img/get-started/nuxt/initial.png)\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nuxt#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack. The CLI will also install Prisma dependencies too.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\nThe CLI generates a template `schema.zmodel` file containing data schema and access policies, which almost already satisfies our requirements. We only need to make some small tweaks to it:\n\n1.  Add a `name` field to the `User` model\n2.  Make the `User` model readable by all users\n\n/schema.zmodel\n\n```\nmodel User {    id String @id @default(cuid())    email String @unique @email+   name String?    password String @password @omit @length(8, 16)    posts Post[]    // everybody can signup    @@allow('create', true)+   // user profiles are public+   @@allow('read', true)    // full access by self    @@allow('all', auth() == this)}\n```\n\nLast, run `zenstack` CLI to regenerate Prisma schema, and sync it to the database:\n\n```\nnpx zenstack generatenpx prisma db push\n```\n\n### 3\\. Implementing authentication[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nuxt#3-implementing-authentication \"Direct link to 3. Implementing authentication\")\n\nThe sample project already contains the basic structure for authentication APIs and UI, however it's not connected to the database yet. Let's do that now.\n\nFirst, create a `/server/prisma.ts` file to create and export a PrismaClient instance:\n\n/server/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client';export const prisma = new PrismaClient();\n```\n\nThen, replace the content of `/auth/server/utils/db.ts` with the following:\n\n/auth/server/utils/db.ts\n\n```\nimport type { User } from '@prisma/client';import { prisma } from '~/server/prisma';export async function findUserByEmail(email: string) {    return prisma.user.findUnique({ where: { email } });}export async function createUser(user: Omit<User, 'id'>) {    return prisma.user.create({        data: user,    });}\n```\n\nNow when user signs up or logs in, Prisma is used to create and retrive user data from the database.\n\nFinally, restart the dev server, and you should be able to create user account and login now.\n\n![](https://zenstack.dev/img/get-started/nuxt/signup.png)\n\n### 4\\. Mount CRUD service & generate hooks[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nuxt#4-mount-crud-service--generate-hooks \"Direct link to 4. Mount CRUD service & generate hooks\")\n\nLet's take a review of the `Post` model in `schema.zmodel`:\n\n/schema.zmodel\n\n```\nmodel Post {    id String @id @default(cuid())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    title String @length(1, 256)    content String    published Boolean @default(false)    author User @relation(fields: [authorId], references: [id])    authorId String    // allow read for all signin users    @@allow('read', auth() != null && published)    // full access by author    @@allow('all', author == auth())}\n```\n\nNotice how the access policies are defined in the schema to control who has what access to the data? To enforce these policies, we'll need to create an \"enhanced\" PrismaClient, like:\n\n```\nimport { enhance } from '@zenstackhq/runtime';const db = enhance(prisma, { user: ... });\n```\n\nAll CRUD calls made via the enhanced client will be subject to the access policies. Since the ORM is already secured, ZenStack can automatically mount a set of CRUD APIs onto your Nuxt app. To achieve it, first install an extra server adapter package:\n\n```\nnpm install @zenstackhq/server\n```\n\nThen, create a `/server/api/model/[...].ts` file with the following content:\n\n/server/api/model/\\[...\\].ts\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { createEventHandler } from '@zenstackhq/server/nuxt';import { prisma } from '~/server/prisma';export default createEventHandler({    getPrisma: async (event) => {        const session = await useAuthSession(event);        return enhance(prisma, {            user: session.data.id ? { id: session.data.id } : undefined,        });    },});\n```\n\ninfo\n\nThe \"\\[...\\].ts\" file name convention creates a \"catch all\" event handler that handles all requests sent to the `/api/model` endpoint and its descendants.\n\nThe CRUD APIs for all your models are now mounted to the `/api/model` endpoint.\n\n## 5\\. Generating client hooks\n\nWe can write frontend code to consume the CRUD APIs, but that would be quite boring. Instead, let's use a plugin to generate them for us. First, install the `@zenstackhq/tanstack-query` plugin package:\n\n```\nnpm install @tanstack/vue-query --forcenpm install -D @zenstackhq/tanstack-query\n```\n\ninfo\n\nThe `--force` flag is required due to a misconfigured dependency in `@tanstack/vue-query`.\n\nThen, add the following snippet to `schema.zmodel`:\n\n/schema.zmodel\n\n```\nplugin hooks {    provider = '@zenstackhq/tanstack-query'    target = 'vue'    output = 'lib/hooks'}\n```\n\nFinally, rerun `zenstack` CLI to trigger the generation:\n\nThe TanStack Query hooks will be generated under `/lib/hooks` and ready to be used in our frontend code.\n\n## 6\\. Building the home page\n\nWith all the preparation work done, we can build the page for creating and listing posts now!\n\nFirst, enable \"@tanstack/vue-query\" in the app by creating a plugin under `/plugins/vue-query.ts`:\n\n/plugins/vue-query.ts\n\n```\nimport { VueQueryPlugin, QueryClient } from '@tanstack/vue-query';export default defineNuxtPlugin((nuxt) => {    const queryClient = new QueryClient();    nuxt.vueApp.use(VueQueryPlugin, { queryClient });});\n```\n\nAlso, add the following `<script setup>` code to `/app.vue` to configure the API endpoint used by the query hooks:\n\n/app.vue\n\n```\n<script setup lang=\"ts\">import { provideHooksContext } from './lib/hooks';// Provide tanstack-query context// Use an absolute endpoint so server-side fetch works tooprovideHooksContext({    endpoint: 'http://localhost:3000/api/model',});</script>\n```\n\nThen, create a `Post` component under `/components/Post.vue` for rendering a single post:\n\n/components/Post.vue\n\n```\n<script setup lang=\"ts\">import { useDeletePost, useUpdatePost } from '~/lib/hooks';const props = defineProps({    id: String,    title: String,    author: {        type: Object,        default: () => ({ email: '' }),    },    published: Boolean,});const updatePost = useUpdatePost();const deletePost = useDeletePost();const onTogglePublish = async () => {    try {        await updatePost.mutateAsync({            where: { id: props.id },            data: { published: !props.published },        });    } catch (err: any) {        alert(err.info?.message ?? err);    }};const onDelete = async () => {    try {        await deletePost.mutateAsync({ where: { id: props.id } });    } catch (err: any) {        alert(err.info?.message ?? err);    }};</script><template>    <div class=\"flex justify-center\">        <div class=\"min-w-80\">            <span class=\"mr-4 text-lg font-semibold\">{{ title }}</span            ><span>by {{ author.email }}</span>        </div>        <div class=\"ml-8 space-x-2\">            <NButton @click=\"onTogglePublish\">{{                published ? 'Unpublish' : 'Publish'            }}</NButton>            <NButton @click=\"onDelete\">Delete</NButton>        </div>    </div></template>\n```\n\nFinally, update the content of `/pages/index.vue` to the following:\n\n/pages/index.vue\n\n```\n<script setup lang=\"ts\">import { useFindManyPost, useCreatePost } from '~/lib/hooks';const title = ref('');const createPost = useCreatePost();const { session } = useAuth();const onCreatePost = async () => {    try {        await createPost.mutateAsync({            data: {                author: { connect: { id: session.value!.id } },                title: title.value,                content: 'My awesome content',            },        });        title.value = '';    } catch (err: any) {        alert(err.info?.message ?? err);    }};const { data: posts } = useFindManyPost({ include: { author: true } });</script><template>    <h1 class=\"text-2xl font-bold my-4\">My Awesome Blog</h1>    <div v-if=\"session?.id\">        <div class=\"flex justify-center\">            <NTextInput                v-model=\"title\"                placeholder=\"Title\"                class=\"w-1/2 mr-4\"                @keyup.enter=\"onCreatePost\"            />            <NButton @click=\"onCreatePost\">Create Post</NButton>        </div>        <ul v-if=\"posts\" class=\"py-8 space-y-2\">            <li v-for=\"post in posts\" :key=\"post.id\">                <Post v-bind=\"post\" />            </li>        </ul>    </div></template>\n```\n\n### 5\\. Testing the app[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nuxt#5-testing-the-app \"Direct link to 5. Testing the app\")\n\nNow you can create and manage posts in the home page.\n\n![](https://zenstack.dev/img/get-started/nuxt/posts.png)\n\nTry signing up another account in an incognito browser tab and publish a post. That post should be visible to the previous account too. Our policy rules are at work.\n\nYou may have noticed that a user can publish, unpublish, or delete other user's posts from the UI. That's because we haven't implemented any conditional rendering logic yet. However, if you try to do that, the server side will reject the request and keep the data safe. In a real application, you'll want to capture the error and show a proper message to the user.\n\n![](https://zenstack.dev/img/get-started/nuxt/rejected.png)\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nuxt#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple blogging app without writing a single backend API. Pretty cool, isn't it?\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-nuxt/tree/v1). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/1.x/category/reference) and [Guides](https://zenstack.dev/docs/1.x/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Nuxt | ZenStack",
  "description": "Step-by-step guide for building a blogging app with Nuxt V3.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/quick-start/nextjs",
  "markdown": "# Next.js (pages router) | ZenStack\n\n## Get Started With Next.js (pages router)\n\nLet's have some fun by creating a simple blogging app. You'll see how effortless it is to have a secure backend service without actually coding it.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-nextjs).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new project[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#1-create-a-new-project \"Direct link to 1. Create a new project\")\n\nThe easiest way to create a Next.js project with boilerplates is with `create-t3-app`. Run the following command to create a new project with Prisma, NextAuth and TailwindCSS.\n\n```\nnpx create-t3-app@latest --prisma --nextAuth --tailwind --CI my-blog-appcd my-blog-app\n```\n\nRemove `DISCORD_CLIENT_ID` and `DISCORD_CLIENT_SECRET` related code from `src/env.js`, since we're not going to use Discord for authentication. After that, start the dev server:\n\nIf everything works, you should have a running Next.js app at [http://localhost:3000](http://localhost:3000/).\n\n![](https://zenstack.dev/img/t3app.png)\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\n### 3\\. Preparing the User model for authentication[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#3-preparing-the-user-model-for-authentication \"Direct link to 3. Preparing the User model for authentication\")\n\nFirst, in `schema.zmodel`, make a few changes to the `User` model:\n\n/schema.zmodel\n\n```\nmodel User {  id            String    @id @default(cuid())  name          String?  email         String?   @unique  emailVerified DateTime?  password      String @password @omit  image         String?  accounts      Account[]  sessions      Session[]  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)  // only the user can update or delete their own profile  @@allow('update,delete', auth() == this)}\n```\n\nFor simplicity, we'll use username/password-based authentication in this project. In the code above, we added a `password` field to support it, together with two access policy rules to control the permissions of this model.\n\ntip\n\n1.  `@password` is a ZenStack attribute that marks a field to be hashed (using [bcryptjs](https://www.npmjs.com/package/bcryptjs)) before saving.\n2.  `@omit` indicates the field should be dropped when returned from a query.\n\ntip\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy) for more details.\n\nNow run `zenstack generate` and `prisma db push` to flush the changes to the Prisma schema and database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 4\\. Configure NextAuth to use credential-based auth[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#4-configure-nextauth-to-use-credential-based-auth \"Direct link to 4. Configure NextAuth to use credential-based auth\")\n\nNow let's update `/src/server/auth.ts` to the content below to use credentials auth and JWT-based session:\n\n/src/server/auth.ts\n\n```\nimport { PrismaAdapter } from '@next-auth/prisma-adapter';import type { PrismaClient } from '@prisma/client';import { compare } from 'bcryptjs';import type { GetServerSidePropsContext } from 'next';import NextAuth, { getServerSession, type DefaultSession, type NextAuthOptions } from 'next-auth';import CredentialsProvider from 'next-auth/providers/credentials';import { db } from './db';/** * Module augmentation for `next-auth` types. * Allows us to add custom properties to the `session` object and keep type * safety. * * @see https://next-auth.js.org/getting-started/typescript#module-augmentation **/declare module 'next-auth' {    interface Session extends DefaultSession {        user: {            id: string;        } & DefaultSession['user'];    }}/** * Options for NextAuth.js used to configure adapters, providers, callbacks, * etc. * * @see https://next-auth.js.org/configuration/options **/export const authOptions: NextAuthOptions = {    session: {        strategy: 'jwt',    },    // Include user.id on session    callbacks: {        session({ session, token }) {            if (session.user) {                session.user.id = token.sub!;            }            return session;        },    },    // Configure one or more authentication providers    adapter: PrismaAdapter(db),    providers: [        CredentialsProvider({            credentials: {                email: { type: 'email' },                password: { type: 'password' },            },            authorize: authorize(db),        }),    ],};function authorize(prisma: PrismaClient) {    return async (credentials: Record<'email' | 'password', string> | undefined) => {        if (!credentials) throw new Error('Missing credentials');        if (!credentials.email) throw new Error('\"email\" is required in credentials');        if (!credentials.password) throw new Error('\"password\" is required in credentials');        const maybeUser = await prisma.user.findFirst({            where: { email: credentials.email },            select: { id: true, email: true, password: true },        });        if (!maybeUser || !maybeUser.password) return null;        // verify the input password with stored hash        const isValid = await compare(credentials.password, maybeUser.password);        if (!isValid) return null;        return { id: maybeUser.id, email: maybeUser.email };    };}/** * Wrapper for `getServerSession` so that you don't need to import the * `authOptions` in every file. * * @see https://next-auth.js.org/configuration/nextjs **/export const getServerAuthSession = (ctx: {    req: GetServerSidePropsContext['req'];    res: GetServerSidePropsContext['res'];}) => {    return getServerSession(ctx.req, ctx.res, authOptions);};export default NextAuth(authOptions);\n```\n\nFinally, add a `NEXTAUTH_SECRET` environment variable in .env file and set it to an arbitrary value (use a complex secret in production and don't check it into git):\n\n### 5\\. Mount CRUD service & generate hooks[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#5-mount-crud-service--generate-hooks \"Direct link to 5. Mount CRUD service & generate hooks\")\n\nZenStack has built-in support for Next.js and can provide database CRUD services automagically, so you don't need to write it yourself.\n\nFirst install the `@zenstackhq/server` and `@zenstackhq/swr` packages:\n\n```\nnpm install @zenstackhq/server swrnpm install -D  @zenstackhq/swr\n```\n\nLet's mount it to the `/api/model/[...path]` endpoint. Create a `/src/pages/api/model/[...path].ts` file and fill in the content below:\n\n/src/pages/api/model/\\[...path\\].ts\n\n```\nimport { NextRequestHandler } from '@zenstackhq/server/next';import { enhance } from '@zenstackhq/runtime';import type { NextApiRequest, NextApiResponse } from 'next';import { getServerAuthSession } from '../../../server/auth';import { prisma } from '../../../server/db';async function getPrisma(req: NextApiRequest, res: NextApiResponse) {    const session = await getServerAuthSession({ req, res });    // create a wrapper of Prisma client that enforces access policy,    // data validation, and @password, @omit behaviors    return enhance(prisma, { user: session?.user });}export default NextRequestHandler({ getPrisma });\n```\n\nThe `/api/model` route is now ready to access database query and mutation requests. However, manually calling the service will be tedious. Fortunately, ZenStack can automatically generate React hooks for you.\n\nLet's enable it by adding the following snippet at the top level to `schema.zmodel`:\n\n```\nplugin hooks {  provider = '@zenstackhq/swr'  output = \"./src/lib/hooks\"}\n```\n\nNow run `zenstack generate` again; you'll find the hooks generated under `/src/lib/hooks` folder:\n\nNow we're ready to implement the signup/signin flow.\n\n### 6\\. Implement Signup/Signin[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#6-implement-signupsignin \"Direct link to 6. Implement Signup/Signin\")\n\nNow let's implement the signup/signin pages. First, create a new page `/src/pages/signup.tsx`:\n\n/src/pages/signup.tsx\n\n```\n/* eslint-disable @typescript-eslint/no-explicit-any *//* eslint-disable @typescript-eslint/no-unsafe-member-access */import type { NextPage } from 'next';import { signIn } from 'next-auth/react';import Router from 'next/router';import { useState, type FormEvent } from 'react';import { useMutateUser } from '../lib/hooks';const Signup: NextPage = () => {    const [email, setEmail] = useState('');    const [password, setPassword] = useState('');    const { createUser: signup } = useMutateUser();    async function onSignup(e: FormEvent) {        e.preventDefault();        try {            await signup({ data: { email, password } });        } catch (err: any) {            console.error(err);            if (err.info?.prisma && err.info?.code === 'P2002') {                // P2002 is Prisma's error code for unique constraint violations                alert('User alread exists');            } else {                alert('An unknown error occurred');            }            return;        }        // signin to create a session        await signIn('credentials', { redirect: false, email, password });        await Router.push('/');    }    return (        <div className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">            <h1 className=\"text-5xl font-extrabold text-white\">Sign up</h1>            <form className=\"mt-16 flex flex-col gap-8 text-2xl\" onSubmit={(e) => void onSignup(e)}>                <div>                    <label htmlFor=\"email\" className=\"inline-block w-32 text-white\">                        Email                    </label>                    <input                        id=\"email\"                        type=\"email\"                        value={email}                        onChange={(e) => setEmail(e.currentTarget.value)}                        className=\"ml-4 w-72 rounded border p-2\"                    />                </div>                <div>                    <label htmlFor=\"password\" className=\"inline-block w-32 text-white \">                        Password                    </label>                    <input                        id=\"password\"                        type=\"password\"                        value={password}                        onChange={(e) => setPassword(e.currentTarget.value)}                        className=\"ml-4 w-72 rounded border p-2\"                    />                </div>                <input                    type=\"submit\"                    value=\"Create account\"                    className=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"                />            </form>        </div>    );};export default Signup;\n```\n\nIn the code above, we used the auto-generated `useMutateUser` hooks to create new `User` entities.\n\ntip\n\n1.  The services backing the hooks are governed by the access policies we defined. Here the `create` call can succeed because we explicitly allowed it in the `User` model. By default, all operations are forbidden.\n2.  The `password` field is automatically hashed. You can confirm it using a sqlite inspection tool to browse the `prisma/db.sqlite` database file.\n\nTry visiting [http://localhost:3000/signup](http://localhost:3000/signup) and creating a new user. It should look like this:\n\n![](https://zenstack.dev/img/tutorial-signup-form.png)\n\nSimilarly, create the signin page `/src/pages/signin.tsx`:\n\n/src/pages/signin.tsx\n\n```\nimport type { NextPage } from 'next';import { signIn } from 'next-auth/react';import Router from 'next/router';import { useState, type FormEvent } from 'react';const Signin: NextPage = () => {    const [email, setEmail] = useState('');    const [password, setPassword] = useState('');    async function onSignin(e: FormEvent) {        e.preventDefault();        const result = await signIn('credentials', {            redirect: false,            email,            password,        });        if (result?.ok) {            await Router.push('/');        } else {            alert('Signin failed');        }    }    return (        <div className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">            <h1 className=\"text-5xl font-extrabold text-white\">Login</h1>            <form className=\"mt-16 flex flex-col gap-8 text-2xl\" onSubmit={(e) => void onSignin(e)}>                <div>                    <label htmlFor=\"email\" className=\"inline-block w-32  text-white\">                        Email                    </label>                    <input                        id=\"email\"                        type=\"email\"                        value={email}                        onChange={(e) => setEmail(e.currentTarget.value)}                        className=\"ml-4 w-72 rounded border p-2\"                    />                </div>                <div>                    <label htmlFor=\"password\" className=\"inline-block w-32  text-white\">                        Password                    </label>                    <input                        id=\"password\"                        type=\"password\"                        value={password}                        onChange={(e) => setPassword(e.currentTarget.value)}                        className=\"ml-4 w-72 rounded border p-2\"                    />                </div>                <input                    type=\"submit\"                    value=\"Sign me in\"                    className=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"                />            </form>        </div>    );};export default Signin;\n```\n\n### 7\\. Prepare the Blog model[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#7-prepare-the-blog-model \"Direct link to 7. Prepare the Blog model\")\n\nNow let's create a `Blog` model. We'll use it to store blog posts.\n\n/schema.zmodel\n\n```\nmodel Post {  id        String @id @default(cuid())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String  published Boolean @default(false)  author    User @relation(fields: [authorId], references: [id])  authorId  String  // author has full access  @@allow('all', auth() == author)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\n`User` and `Post` model has a one-to-many relation. We can establish it by adding a `posts` relation field to the `User` model.\n\n/schema.zmodel\n\n```\nmodel User {    id            String    @id @default(cuid())    name          String?    email         String?   @unique    emailVerified DateTime?    password      String @password @omit    posts         Post[]    image         String?    accounts      Account[]    sessions      Session[]    // everyone can signup, and user profile is also publicly readable    @@allow('create,read', true)    // only the user can update or delete their own profile    @@allow('update,delete', auth() == this)}\n```\n\nDon't forget to regenerate and push schema changes to the database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 8\\. Build up the home page[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#8-build-up-the-home-page \"Direct link to 8. Build up the home page\")\n\nNow let's replace `/src/pages/index.tsx` with the content below and use it for viewing and managing posts.\n\n/src/pages/index.tsx\n\n```\nimport type { Post } from '@prisma/client';import { type NextPage } from 'next';import { signOut, useSession } from 'next-auth/react';import Link from 'next/link';import Router from 'next/router';import { useFindManyPost, useMutatePost } from '../lib/hooks';type AuthUser = { id: string; email?: string | null };const Welcome = ({ user }: { user: AuthUser }) => {    async function onSignout() {        await signOut({ redirect: false });        await Router.push('/signin');    }    return (        <div className=\"flex gap-4\">            <h3 className=\"text-lg\">Welcome back, {user?.email}</h3>            <button className=\"text-gray-300 underline\" onClick={() => void onSignout()}>                Signout            </button>        </div>    );};const SigninSignup = () => {    return (        <div className=\"flex gap-4 text-2xl\">            <Link href=\"/signin\" className=\"rounded-lg border px-4 py-2\">                Signin            </Link>            <Link href=\"/signup\" className=\"rounded-lg border px-4 py-2\">                Signup            </Link>        </div>    );};const Posts = ({ user }: { user: AuthUser }) => {    // Post crud hooks    const { createPost, updatePost, deletePost } = useMutatePost();    // list all posts that're visible to the current user, together with their authors    const { data: posts } = useFindManyPost({        include: { author: true },        orderBy: { createdAt: 'desc' },    });    async function onCreatePost() {        const title = prompt('Enter post title');        if (title) {            await createPost({ data: { title, authorId: user.id } });        }    }    async function onTogglePublished(post: Post) {        await updatePost({            where: { id: post.id },            data: { published: !post.published },        });    }    async function onDelete(post: Post) {        await deletePost({ where: { id: post.id } });    }    return (        <div className=\"container flex flex-col text-white\">            <button className=\"rounded border border-white p-2 text-lg\" onClick={() => void onCreatePost()}>                + Create Post            </button>            <ul className=\"container mt-8 flex flex-col gap-2\">                {posts?.map((post) => (                    <li key={post.id} className=\"flex items-end justify-between gap-4\">                        <p className={`text-2xl ${!post.published ? 'text-gray-400' : ''}`}>                            {post.title}                            <span className=\"text-lg\"> by {post.author.email}</span>                        </p>                        <div className=\"flex w-32 justify-end gap-1 text-left\">                            <button className=\"underline\" onClick={() => void onTogglePublished(post)}>                                {post.published ? 'Unpublish' : 'Publish'}                            </button>                            <button className=\"underline\" onClick={() => void onDelete(post)}>                                Delete                            </button>                        </div>                    </li>                ))}            </ul>        </div>    );};const Home: NextPage = () => {    const { data: session, status } = useSession();    if (status === 'loading') return <p>Loading ...</p>;    return (        <main className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">            <div className=\"container flex flex-col items-center justify-center gap-12 px-4 py-16 text-white\">                <h1 className=\"text-5xl font-extrabold\">My Awesome Blog</h1>                {session?.user ? (                    // welcome & blog posts                    <div className=\"flex flex-col\">                        <Welcome user={session.user} />                        <section className=\"mt-10\">                            <Posts user={session.user} />                        </section>                    </div>                ) : (                    // if not logged in                    <SigninSignup />                )}            </div>        </main>    );};export default Home;\n```\n\n## Verifying the result[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#verifying-the-result \"Direct link to Verifying the result\")\n\nRestart the dev server and try creating a few posts. You should see something like the following:\n\n![](https://zenstack.dev/img/tutorial-blog-posts.png)\n\nThe code looks a bit long because we tucked all UI components directly into the page. As you can see, querying and mutating `Post` entities are fairly straightforward, the generated hooks. When mutation happens, e.g. a new post is created, data refetching is also triggered automatically.\n\nTry opening an incognito browser window and signing up for a separate account. You should find that the published posts are visible, as we specified with access policies.\n\n![](https://zenstack.dev/img/tutorial-blog-posts-readable.png)\n\nSince we haven't hidden \"Unpublish\" and \"Delete\" buttons for posts not owned by the current user, you can still click them even for posts not owned to you, but it will end up with a 403 error:\n\n![network error](https://zenstack.dev/assets/images/tutorial-post-update-denied-6678fc0a9b958064f56f02cb3f7f3c3a.png)\n\n```\n{    \"prisma\": true,    \"rejectedByPolicy\": true,    \"code\": \"P2004\",    \"message\": \"denied by policy: post entities failed 'update' check, 1 entities failed policy check\"}\n```\n\nYou can catch the error and render a nice message to the user.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/1.x/quick-start/nextjs#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple blogging app without writing a single line of backend code. Pretty cool, isn't it?\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-nextjs/tree/v1). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/1.x/category/reference) and [Guides](https://zenstack.dev/docs/1.x/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Next.js (pages router) | ZenStack",
  "description": "Step-by-step guide for building a blogging app with Next.js (pages router).",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/quick-start/next-app-router",
  "markdown": "# Next.js (app router) | ZenStack\n\n## Get Started With Next.js (app router)\n\nLet's have some fun by creating a simple blogging app. You'll see how effortless it is to have a secure backend service without actually coding it.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-nextjs-app-dir).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new project[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#1-create-a-new-project \"Direct link to 1. Create a new project\")\n\nThe easiest way to create a Next.js project with boilerplates is with `create-t3-app`. Run the following command to create a new project with Prisma, NextAuth and TailwindCSS.\n\n```\nnpx create-t3-app@latest --prisma --nextAuth --tailwind --appRouter --CI my-blog-appcd my-blog-app\n```\n\nRemove `DISCORD_CLIENT_ID` and `DISCORD_CLIENT_SECRET` related code from `src/env.js`, since we're not going to use Discord for authentication. After that, start the dev server:\n\nIf everything works, you should have a running Next.js app at [http://localhost:3000](http://localhost:3000/).\n\n![](https://zenstack.dev/img/t3app.png)\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\nNext, add the following configuration to the `next.config.js` file:\n\n/next.config.js\n\n```\nconst config = {  experimental: {    serverComponentsExternalPackages: [\"@zenstackhq/runtime\"],  }};\n```\n\ninfo\n\nThe extra configuration is needed because the package `@zenstackhq/runtime` is not yet fully compatible with NextJS's server component bundler. We'll resolve this issue in a future release.\n\n### 3\\. Preparing the User model for authentication[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#3-preparing-the-user-model-for-authentication \"Direct link to 3. Preparing the User model for authentication\")\n\nFirst, in `schema.zmodel`, make a few changes to the `User` model:\n\n/schema.zmodel\n\n```\nmodel User {  id            String    @id @default(cuid())  name          String?  email         String?   @unique  emailVerified DateTime?  password      String @password @omit  image         String?  accounts      Account[]  sessions      Session[]  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)  // only the user can update or delete their own profile  @@allow('update,delete', auth() == this)}\n```\n\nFor simplicity, we'll use username/password-based authentication in this project. In the code above, we added a `password` field to support it, together with two access policy rules to control the permissions of this model.\n\ntip\n\n1.  `@password` is a ZenStack attribute that marks a field to be hashed (using [bcryptjs](https://www.npmjs.com/package/bcryptjs)) before saving.\n2.  `@omit` indicates the field should be dropped when returned from a query.\n\ntip\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy) for more details.\n\nNow run `zenstack generate` and `prisma db push` to flush the changes to the Prisma schema and database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 4\\. Configure NextAuth to use credential-based auth[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#4-configure-nextauth-to-use-credential-based-auth \"Direct link to 4. Configure NextAuth to use credential-based auth\")\n\nNow let's update `/src/server/auth.ts` to the content below to use credentials auth and JWT-based session:\n\n/src/server/auth.ts\n\n```\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";import type { PrismaClient } from \"@prisma/client\";import { compare } from \"bcryptjs\";import {  getServerSession,  type DefaultSession,  type NextAuthOptions,} from \"next-auth\";import { type Adapter } from \"next-auth/adapters\";import CredentialsProvider from \"next-auth/providers/credentials\";import { db } from \"~/server/db\";/** * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session` * object and keep type safety. * * @see https://next-auth.js.org/getting-started/typescript#module-augmentation */declare module \"next-auth\" {  interface Session extends DefaultSession {    user: {      id: string;    } & DefaultSession[\"user\"];  }}/** * Options for NextAuth.js used to configure adapters, providers, callbacks, etc. * * @see https://next-auth.js.org/configuration/options */export const authOptions: NextAuthOptions = {  session: {    strategy: \"jwt\",  },  callbacks: {    session({ session, token }) {      if (session.user) {        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion        session.user.id = token.sub!;      }      return session;    },  },  adapter: PrismaAdapter(db) as Adapter,  providers: [    CredentialsProvider({      credentials: {        email: { type: \"email\" },        password: { type: \"password\" },      },      authorize: authorize(db),    }),    /**     * ...add more providers here.     *     * Most other providers require a bit more work than the Discord provider. For example, the     * GitHub provider requires you to add the `refresh_token_expires_in` field to the Account     * model. Refer to the NextAuth.js docs for the provider you want to use. Example:     *     * @see https://next-auth.js.org/providers/github     */  ],};function authorize(prisma: PrismaClient) {  return async (    credentials: Record<\"email\" | \"password\", string> | undefined,  ) => {    if (!credentials) throw new Error(\"Missing credentials\");    if (!credentials.email)      throw new Error('\"email\" is required in credentials');    if (!credentials.password)      throw new Error('\"password\" is required in credentials');    const maybeUser = await prisma.user.findFirst({      where: { email: credentials.email },      select: { id: true, email: true, password: true },    });    if (!maybeUser?.password) return null;    // verify the input password with stored hash    const isValid = await compare(credentials.password, maybeUser.password);    if (!isValid) return null;    return { id: maybeUser.id, email: maybeUser.email };  };}/** * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file. * * @see https://next-auth.js.org/configuration/nextjs */export const getServerAuthSession = () => getServerSession(authOptions);\n```\n\nFinally, add a `NEXTAUTH_SECRET` environment variable in .env file and set it to an arbitrary value (use a complex secret in production and don't check it into git):\n\n### 5\\. Mount CRUD service & generate hooks[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#5-mount-crud-service--generate-hooks \"Direct link to 5. Mount CRUD service & generate hooks\")\n\nZenStack has built-in support for Next.js and can provide database CRUD services automagically, so you don't need to write it yourself.\n\nFirst install the `@zenstackhq/server`, `@tanstack/react-query`, and `@zenstackhq/tanstack-query` packages:\n\n```\nnpm install @zenstackhq/server @tanstack/react-querynpm install -D @zenstackhq/tanstack-query\n```\n\nLet's mount it to the `/api/model/[...path]` endpoint. Create a `/src/app/api/model/[...path]/route.ts` file and fill in the content below:\n\n/src/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { enhance } from \"@zenstackhq/runtime\";import { NextRequestHandler } from \"@zenstackhq/server/next\";import { getServerAuthSession } from \"~/server/auth\";import { db } from \"~/server/db\";// create an enhanced Prisma client with user contextasync function getPrisma() {  const session = await getServerAuthSession();  return enhance(db, { user: session?.user });}const handler = NextRequestHandler({ getPrisma, useAppDir: true });export {  handler as DELETE,  handler as GET,  handler as PATCH,  handler as POST,  handler as PUT,};\n```\n\nThe `/api/model` route is now ready to access database query and mutation requests. However, manually calling the service will be tedious. Fortunately, ZenStack can automatically generate React data query hooks for you.\n\nLet's enable it by adding the following snippet at the top level to `schema.zmodel`:\n\n/schema.zmodel\n\n```\nplugin hooks {  provider = '@zenstackhq/tanstack-query'  target = 'react'  version = 'v5'  output = \"./src/lib/hooks\"}\n```\n\nNow run `zenstack generate` again; you'll find the hooks generated under `/src/lib/hooks` folder:\n\nNow we're ready to implement the signup/signin flow.\n\n### 6\\. Set up context providers[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#6-set-up-context-providers \"Direct link to 6. Set up context providers\")\n\nNextAuth and React Query require context providers to be set up. Create a `/src/app/providers.tsx` file with the following content:\n\n/src/app/providers.tsx\n\n```\n\"use client\";import { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";import { SessionProvider } from \"next-auth/react\";import type { ReactNode } from \"react\";const queryClient = new QueryClient();export default function Providers({ children }: { children: ReactNode }) {  return (    <QueryClientProvider client={queryClient}>      <SessionProvider>{children}</SessionProvider>    </QueryClientProvider>  );}\n```\n\nThen, update `/src/app/layout.tsx` to install the query client provider:\n\n/src/app/layout.tsx\n\n```\n\"use client\";import \"~/styles/globals.css\";import { Inter } from \"next/font/google\";import Providers from \"./providers\";const inter = Inter({  subsets: [\"latin\"],  variable: \"--font-sans\",});export default function RootLayout({  children,}: {  children: React.ReactNode;}) {  return (    <html lang=\"en\">      <body className={`font-sans ${inter.variable}`}>        <Providers>{children}</Providers>      </body>    </html>  );}\n```\n\ninfo\n\nWe've only done the minimum setup to get React Query to work with NextJS's app router. For more more in-depth background and setup, please refer to React Query's official documentation about [Advanced Server Rendering](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).\n\n### 7\\. Implement Signup/Signin[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#7-implement-signupsignin \"Direct link to 7. Implement Signup/Signin\")\n\nNow let's implement the signup/signin pages. First, create a new page `/src/app/signup/page.tsx`:\n\n/src/app/signup/page.tsx\n\n```\n\"use client\";import type { NextPage } from \"next\";import { signIn } from \"next-auth/react\";import { useRouter } from \"next/navigation\";import { useState, type FormEvent } from \"react\";import { useCreateUser } from \"~/lib/hooks\";const Signup: NextPage = () => {  const [email, setEmail] = useState(\"\");  const [password, setPassword] = useState(\"\");  const { mutateAsync: signup } = useCreateUser();  const router = useRouter();  async function onSignup(e: FormEvent) {    e.preventDefault();    try {      await signup({ data: { email, password } });      // eslint-disable-next-line @typescript-eslint/no-explicit-any    } catch (err: any) {      console.error(err);      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access      if (err.info?.prisma && err.info?.code === \"P2002\") {        // P2002 is Prisma's error code for unique constraint violations        alert(\"User already exists\");      } else {        alert(\"An unknown error occurred\");      }      return;    }    // signin to create a session    await signIn(\"credentials\", { redirect: false, email, password });    router.push(\"/\");  }  return (    <div className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">      <h1 className=\"text-5xl font-extrabold text-white\">Sign up</h1>      <form        className=\"mt-16 flex flex-col gap-8 text-2xl\"        onSubmit={(e) => void onSignup(e)}      >        <div>          <label htmlFor=\"email\" className=\"inline-block w-32 text-white\">            Email          </label>          <input            id=\"email\"            type=\"email\"            value={email}            onChange={(e) => setEmail(e.currentTarget.value)}            className=\"ml-4 w-72 rounded border p-2\"          />        </div>        <div>          <label htmlFor=\"password\" className=\"inline-block w-32 text-white \">            Password          </label>          <input            id=\"password\"            type=\"password\"            value={password}            onChange={(e) => setPassword(e.currentTarget.value)}            className=\"ml-4 w-72 rounded border p-2\"          />        </div>        <input          type=\"submit\"          value=\"Create account\"          className=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"        />      </form>    </div>  );};export default Signup;\n```\n\nIn the code above, we used the auto-generated `useCreateUser` hooks to create new `User` entities.\n\ntip\n\n1.  The services backing the hooks are governed by the access policies we defined. Here the `create` call can succeed because we explicitly allowed it in the `User` model. By default, all operations are forbidden.\n2.  The `password` field is automatically hashed. You can confirm it using a sqlite inspection tool to browse the `prisma/db.sqlite` database file.\n\nTry visiting [http://localhost:3000/signup](http://localhost:3000/signup) and creating a new user. It should look like this:\n\n![](https://zenstack.dev/img/tutorial-signup-form.png)\n\nSimilarly, create the signin page `/src/app/signin/page.tsx`:\n\n/src/app/signin/page.tsx\n\n```\n\"use client\";import type { NextPage } from \"next\";import { signIn } from \"next-auth/react\";import { useRouter } from \"next/navigation\";import { useState, type FormEvent } from \"react\";const Signin: NextPage = () => {  const [email, setEmail] = useState(\"\");  const [password, setPassword] = useState(\"\");  const router = useRouter();  async function onSignin(e: FormEvent) {    e.preventDefault();    const result = await signIn(\"credentials\", {      redirect: false,      email,      password,    });    if (result?.ok) {      router.push(\"/\");    } else {      alert(\"Signin failed\");    }  }  return (    <div className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">      <h1 className=\"text-5xl font-extrabold text-white\">Login</h1>      <form        className=\"mt-16 flex flex-col gap-8 text-2xl\"        onSubmit={(e) => void onSignin(e)}      >        <div>          <label htmlFor=\"email\" className=\"inline-block w-32  text-white\">            Email          </label>          <input            id=\"email\"            type=\"email\"            value={email}            onChange={(e) => setEmail(e.currentTarget.value)}            className=\"ml-4 w-72 rounded border p-2\"          />        </div>        <div>          <label htmlFor=\"password\" className=\"inline-block w-32  text-white\">            Password          </label>          <input            id=\"password\"            type=\"password\"            value={password}            onChange={(e) => setPassword(e.currentTarget.value)}            className=\"ml-4 w-72 rounded border p-2\"          />        </div>        <input          type=\"submit\"          value=\"Sign me in\"          className=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"        />      </form>    </div>  );};export default Signin;\n```\n\n### 8\\. Prepare the Post model[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#8-prepare-the-post-model \"Direct link to 8. Prepare the Post model\")\n\nNow let's update the `Post` model to add access policies.\n\n/schema.zmodel\n\n```\nmodel Post {  id Int @id @default(autoincrement())  name String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  published Boolean @default(false)  createdBy User @relation(fields: [createdById], references: [id])  createdById String  @@index([name])  // author has full access  @@allow('all', auth() == createdBy)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\nDon't forget to regenerate and push schema changes to the database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 9\\. Build up the home page[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#9-build-up-the-home-page \"Direct link to 9. Build up the home page\")\n\nNow let's replace `/src/app/page.tsx` with the content below and use it for viewing and managing posts.\n\n/src/app/page.tsx\n\n```\n\"use client\";import type { Post } from \"@prisma/client\";import { type NextPage } from \"next\";import { signOut, useSession } from \"next-auth/react\";import Link from \"next/link\";import { useRouter } from \"next/navigation\";import {  useFindManyPost,  useCreatePost,  useUpdatePost,  useDeletePost,} from \"../lib/hooks\";type AuthUser = { id: string; email?: string | null };const Welcome = ({ user }: { user: AuthUser }) => {  const router = useRouter();  async function onSignout() {    await signOut({ redirect: false });    router.push(\"/signin\");  }  return (    <div className=\"flex gap-4\">      <h3 className=\"text-lg\">Welcome back, {user?.email}</h3>      <button        className=\"text-gray-300 underline\"        onClick={() => void onSignout()}      >        Signout      </button>    </div>  );};const SigninSignup = () => {  return (    <div className=\"flex gap-4 text-2xl\">      <Link href=\"/signin\" className=\"rounded-lg border px-4 py-2\">        Signin      </Link>      <Link href=\"/signup\" className=\"rounded-lg border px-4 py-2\">        Signup      </Link>    </div>  );};const Posts = ({ user }: { user: AuthUser }) => {  // Post crud hooks  const { mutateAsync: createPost } = useCreatePost();  const { mutateAsync: updatePost } = useUpdatePost();  const { mutateAsync: deletePost } = useDeletePost();  // list all posts that're visible to the current user, together with their authors  const { data: posts } = useFindManyPost({    include: { createdBy: true },    orderBy: { createdAt: \"desc\" },  });  async function onCreatePost() {    const name = prompt(\"Enter post name\");    if (name) {      await createPost({        data: { name, createdBy: { connect: { id: user.id } } },      });    }  }  async function onTogglePublished(post: Post) {    await updatePost({      where: { id: post.id },      data: { published: !post.published },    });  }  async function onDelete(post: Post) {    await deletePost({ where: { id: post.id } });  }  return (    <div className=\"container flex flex-col text-white\">      <button        className=\"rounded border border-white p-2 text-lg\"        onClick={() => void onCreatePost()}      >        + Create Post      </button>      <ul className=\"container mt-8 flex flex-col gap-2\">        {posts?.map((post) => (          <li key={post.id} className=\"flex items-end justify-between gap-4\">            <p className={`text-2xl ${!post.published ? \"text-gray-400\" : \"\"}`}>              {post.name}              <span className=\"text-lg\"> by {post.createdBy.email}</span>            </p>            <div className=\"flex w-32 justify-end gap-1 text-left\">              <button                className=\"underline\"                onClick={() => void onTogglePublished(post)}              >                {post.published ? \"Unpublish\" : \"Publish\"}              </button>              <button className=\"underline\" onClick={() => void onDelete(post)}>                Delete              </button>            </div>          </li>        ))}      </ul>    </div>  );};const Home: NextPage = () => {  const { data: session, status } = useSession();  if (status === \"loading\") return <p>Loading ...</p>;  return (    <main className=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">      <div className=\"container flex flex-col items-center justify-center gap-12 px-4 py-16 text-white\">        <h1 className=\"text-5xl font-extrabold\">My Awesome Blog</h1>        {session?.user ? (          // welcome & blog posts          <div className=\"flex flex-col\">            <Welcome user={session.user} />            <section className=\"mt-10\">              <Posts user={session.user} />            </section>          </div>        ) : (          // if not logged in          <SigninSignup />        )}      </div>    </main>  );};export default Home;\n```\n\n## Verifying the result[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#verifying-the-result \"Direct link to Verifying the result\")\n\nRestart the dev server and try creating a few posts. You should see something like the following:\n\n![](https://zenstack.dev/img/tutorial-blog-posts.png)\n\nThe code looks a bit long because we tucked all UI components directly into the page. As you can see, querying and mutating `Post` entities are fairly straightforward, the generated hooks. When mutation happens, e.g. a new post is created, data refetching is also triggered automatically.\n\nTry opening an incognito browser window and signing up for a separate account. You should find that the published posts are visible, as we specified with access policies.\n\n![](https://zenstack.dev/img/tutorial-blog-posts-readable.png)\n\nSince we haven't hidden \"Unpublish\" and \"Delete\" buttons for posts not owned by the current user, you can still click them even for posts not owned to you, but it will end up with a 403 error:\n\n![network error](https://zenstack.dev/assets/images/tutorial-post-update-denied-6678fc0a9b958064f56f02cb3f7f3c3a.png)\n\n```\n{    \"prisma\": true,    \"rejectedByPolicy\": true,    \"code\": \"P2004\",    \"message\": \"denied by policy: post entities failed 'update' check, 1 entities failed policy check\"}\n```\n\nYou can catch the error and render a nice message to the user.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/1.x/quick-start/next-app-router#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple blogging app without writing a single line of backend code. Pretty cool, isn't it?\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-nextjs-app-dir/tree/v1). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/1.x/category/reference) and [Guides](https://zenstack.dev/docs/1.x/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Next.js (app router) | ZenStack",
  "description": "Step-by-step guide for building a blogging app with Next.js (app router).",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/quick-start/sveltekit",
  "markdown": "# SvelteKit | ZenStack\n\n## Get Started With SvelteKit\n\nLet's have some fun by creating a simple blogging app. You'll see how effortless it is to have a secure backend service without actually coding it.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-sveltekit).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new project[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#1-create-a-new-project \"Direct link to 1. Create a new project\")\n\nThe easiest way to create a SvelteKit project with boilerplates is with `npm create svelte`. Run the following command to create a new project:\n\n```\nnpm create svelte@latest my-blog-app\n```\n\nChoose the following options when prompted:\n\n*   Which Svelte app template?\n    \n    Skeleton project\n    \n*   Add type checking with TypeScript?\n    \n    Yes, using TypeScript syntax\n    \n*   Select additional options (use arrow keys/space bar)\n    \n    Add ESLint for code linting, Add Prettier for code formatting\n    \n\n### 2\\. Configure TailwindCSS[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#2-configure-tailwindcss \"Direct link to 2. Configure TailwindCSS\")\n\nFollow the guide [here](https://tailwindcss.com/docs/guides/sveltekit) to add TailwindCSS to your project.\n\n### 3\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#3-initialize-the-project-for-zenstack \"Direct link to 3. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack. Inside your project directory, run the following command:\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\nReplace the `User` and `Post` models in the `/schema.zmodel` file with the following content:\n\n/schema.zmodel\n\n```\nmodel User {    id String @id @default(cuid())    email String @unique @email    password String @password @omit @length(8, 16)    posts Post[]    // everybody can signup    @@allow('create,read', true)    // full access by self    @@allow('all', auth() == this)}model Post {    id String @id @default(cuid())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    title String @length(1, 256)    published Boolean @default(false)    author User? @relation(fields: [authorId], references: [id])    authorId String?    // allow read for all signin users    @@allow('read', auth() != null && published)    // full access by author    @@allow('all', author == auth())}\n```\n\ntip\n\n1.  `@password` is a ZenStack attribute that marks a field to be hashed (using [bcryptjs](https://www.npmjs.com/package/bcryptjs)) before saving.\n2.  `@omit` indicates the field should be dropped when returned from a query.\n\ntip\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy) for more details.\n\nNow run `zenstack generate` and `prisma db push` to flush the changes to the Prisma schema and database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n```\nnpm add jsonwebtoken bcryptjsnpm add -D @types/jsonwebtoken @types/bcryptjs\n```\n\n### 5\\. Set up environment variables[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#5-set-up-environment-variables \"Direct link to 5. Set up environment variables\")\n\nCreate a \".env\" file under the root directory of your project and add the following content:\n\ninfo\n\nIn a real-world application, you should use a strong secret.\n\n### 6\\. Create database and auth utilities[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#6-create-database-and-auth-utilities \"Direct link to 6. Create database and auth utilities\")\n\nCreate a `/src/lib/db.ts` file with the following content:\n\n/src/lib/db.ts\n\n```\nimport { PrismaClient } from '@prisma/client';export const prisma = new PrismaClient();\n```\n\nCreate a `/src/lib/auth.ts` file with the following content:\n\n/src/lib/auth.ts\n\n```\nimport { env } from '$env/dynamic/private';import type { User } from '@prisma/client';import jwt from 'jsonwebtoken';export const JWT_TOKEN_COOKIE_NAME = 'ZenStack-Blog-Token';export function createToken(user: User) {\treturn jwt.sign(\t\t{\t\t\tsub: user.id,\t\t\temail: user.email\t\t},\t\tenv.JWT_SECRET,\t\t{ expiresIn: '7d' }\t);}\n```\n\n### 7\\. Create a signup page[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#7-create-a-signup-page \"Direct link to 7. Create a signup page\")\n\ninfo\n\nFor real-world applications you should usually use a framework or service instead of building your own authentication solution. But since authentication is not the focus of this guide, we'll just implement a minimal email/password-based auth.\n\nCreate a `/src/routes/signup/+page.svelte` file with the following content:\n\n/src/routes/signup/+page.svelte\n\n```\n<script lang=\"ts\">    import { enhance } from '$app/forms';    import type { ActionData } from './$types';    export let form: ActionData;</script><div class=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">    <h1 class=\"text-5xl font-extrabold text-white\">Sign up</h1>    <form class=\"mt-16 flex flex-col gap-8 text-2xl\" method=\"post\" use:enhance>        {#if form?.dup}            <p class=\"text-red-600 my-2\">Email aready registered!</p>        {/if}        <div>            <label for=\"email\" class=\"inline-block w-32 text-white\"> Email </label>            <input                id=\"email\"                name=\"email\"                type=\"email\"                value={form?.email ?? ''}                class=\"ml-4 w-72 rounded border p-2\"            />        </div>        <div>            <label for=\"password\" class=\"inline-block w-32 text-white\"> Password </label>            <input id=\"password\" name=\"password\" type=\"password\" class=\"ml-4 w-72 rounded border p-2\" />        </div>        <input            type=\"submit\"            value=\"Create account\"            class=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"        />        <div class=\"mt-2 text-base font-medium text-gray-300\">            Already have an account?{' '}            <a href=\"/signin\" class=\"text-primary-700 underline\"> Login here </a>        </div>    </form></div>\n```\n\nThen create its server-side form handler `/src/routes/signup/+page.server.ts` with the following content:\n\n/src/routes/signup/+page.server.ts\n\n```\nimport { createToken, JWT_TOKEN_COOKIE_NAME } from '$lib/auth';import { fail, redirect, type Actions } from '@sveltejs/kit';import { isPrismaClientKnownRequestError, enhance } from '@zenstackhq/runtime';import { prisma } from '../../lib/db';export const actions = {    default: async ({ request, cookies }) => {        const data = await request.formData();        const email = data.get('email');        const password = data.get('password');        if (typeof email !== 'string' || typeof password !== 'string') {            return fail(400, { email, password, missing: true });        }        const db = enhance(prisma);        try {            // create the user together with a default space            const user = await db.user.create({                data: {                    email,                    password                }            });            // sign a JWT token and set it as a cookie            const token = createToken(user);            cookies.set(JWT_TOKEN_COOKIE_NAME, token, {                httpOnly: true,                expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),                path: '/'            });        } catch (err) {            if (isPrismaClientKnownRequestError(err) && err.code === 'P2002') {                // duplicated email                return fail(400, { email, password, dup: true });            } else {                throw err;            }        }        throw redirect(303, `/`);    }} satisfies Actions;\n```\n\nNow start the dev server by running:\n\nHit [http://localhost:5173/signup](http://localhost:5173/signup) and you should see the signup page like:\n\n![](https://zenstack.dev/img/get-started/sveltekit/signup.png)\n\nCreate an account to continue.\n\n### 8\\. Create a signin page[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#8-create-a-signin-page \"Direct link to 8. Create a signin page\")\n\nCreate a `/src/routes/signin/+page.svelte` file with the following content:\n\n/src/routes/signin/+page.svelte\n\n```\n<script lang=\"ts\">\timport { enhance } from '$app/forms';\timport type { ActionData } from '../signin/$types';\texport let form: ActionData;</script><div class=\"flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]\">    <h1 class=\"text-5xl font-extrabold text-white\">Login</h1>    <form class=\"mt-16 flex flex-col gap-8 text-2xl\" method=\"post\" use:enhance>        {#if form?.invalid}            <p class=\"text-red-600 my-2\">Invalid credentials</p>        {/if}        <div>            <label for=\"email\" class=\"inline-block w-32 text-white\"> Email </label>            <input                id=\"email\"                name=\"email\"                type=\"email\"                value={form?.email ?? ''}                class=\"ml-4 w-72 rounded border p-2\"            />        </div>        <div>            <label for=\"password\" class=\"inline-block w-32 text-white\"> Password </label>            <input id=\"password\" name=\"password\" type=\"password\" class=\"ml-4 w-72 rounded border p-2\" />        </div>        <input            type=\"submit\"            value=\"Sign in to my account\"            class=\"cursor-pointer rounded border border-gray-500 py-4 text-white\"        />        <div class=\"mt-2 text-base font-medium text-gray-300\">            Don't have an account yet?{' '}            <a href=\"/signup\" class=\"text-primary-700 underline\"> Signup here </a>        </div>    </form></div>\n```\n\nThen create its server-side form handler `/src/routes/signin/+page.server.ts` with the following content:\n\n/src/routes/signin/+page.server.ts\n\n```\nimport { JWT_TOKEN_COOKIE_NAME, createToken } from '$lib/auth';import { prisma } from '$lib/db';import { fail, redirect, type Actions } from '@sveltejs/kit';import bcrypt from 'bcryptjs';export const actions = {    default: async ({ request, cookies }) => {        const data = await request.formData();        const email = data.get('email');        const password = data.get('password');        if (typeof email !== 'string' || typeof password !== 'string') {            return fail(400, { email, password, missing: true });        }        const user = await prisma.user.findFirst({            where: { email }        });        if (!user || !bcrypt.compareSync(password, user.password)) {            return fail(401, { email, password, invalid: true });        }        const token = createToken(user);        cookies.set(JWT_TOKEN_COOKIE_NAME, token, {            httpOnly: true,            expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),            path: '/'        });        throw redirect(303, `/`);    }} satisfies Actions;\n```\n\nHit [http://localhost:5173/signin](http://localhost:5173/signin) and you should see the signin page like:\n\n![](https://zenstack.dev/img/get-started/sveltekit/signin.png)\n\nTry signing in with the account you just created.\n\n### 9\\. Create a server hook to add user and his corresponding db to context[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#9-create-a-server-hook-to-add-user-and-his-corresponding-db-to-context \"Direct link to 9. Create a server hook to add user and his corresponding db to context\")\n\nUse a [server hook](https://kit.svelte.dev/docs/hooks#server-hooks) to intercept requests, extract JWT token and decode it to user identity, create an access-policy-aware Prisma wrapper with the identity, and add both the user and db to the request context. When building the rest of pages in our app, we can fetch them directly from the `locals` context.\n\nFirst, update `/src/app.d.ts` to include `user` and `db` fields in the request context's typing:\n\n/src/app.d.ts\n\n```\nimport type { PrismaClient, User } from '@prisma/client';declare global {    namespace App {        interface Locals {            user?: User;            db: PrismaClient;        }    }}export {};\n```\n\nThen create server hooks `/src/hooks.server.ts`:\n\n/src/hooks.server.ts\n\n```\nimport { env } from '$env/dynamic/private';import { JWT_TOKEN_COOKIE_NAME } from '$lib/auth';import { prisma } from '$lib/db';import type { Handle } from '@sveltejs/kit';import { enhance } from '@zenstackhq/runtime';import jwt from 'jsonwebtoken';const auth = (async ({ event, resolve }) => {    const token = event.cookies.get(JWT_TOKEN_COOKIE_NAME);    if (token) {        try {            const decoded = jwt.verify(token, env.JWT_SECRET);            const user = await prisma.user.findUnique({                where: { id: decoded.sub as string }            });            if (user) {                event.locals.user = user;            } else {                console.warn('User not found:', decoded.sub);                event.cookies.delete(JWT_TOKEN_COOKIE_NAME, { path: '/' });            }        } catch {            event.cookies.delete(JWT_TOKEN_COOKIE_NAME, { path: '/' });        }    }    // create an enhanced PrismaClient that recognizes access policies    event.locals.db = enhance(prisma, {        user: event.locals.user ? { id: event.locals.user.id } : undefined    });    return resolve(event);}) satisfies Handle;export const handle = auth;\n```\n\n### 10\\. Build the post list page[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#10-build-the-post-list-page \"Direct link to 10. Build the post list page\")\n\nFinally we've got to build the main page of our app. For the sake of simplicity, we'll just put all UI directly in the page without further extracting components.\n\nReplace `/src/routes/+page.svelte` with the following content:\n\n/src/routes/+page.svelte\n\n```\n<script lang=\"ts\">    import { enhance } from '$app/forms';    import type { ActionData, PageData } from './$types';    export let data: PageData;    export let form: ActionData;</script><main class=\"flex flex-col min-h-screen items-center justify-center gap-12 px-4 py-16 text-white bg-gradient-to-b from-[#2e026d] to-[#15162c]\">    <h1 class=\"text-5xl font-extrabold\">My Awesome Blog</h1>    {#if data.user}        <div class=\"flex flex-col\">            <div class=\"flex gap-4\">                <h3 class=\"text-lg\">Welcome back, {data.user.email}</h3>                <form method=\"post\" action=\"?/signOut\">                    <button type=\"submit\" class=\"text-gray-300 underline\">Sign out</button>                </form>            </div>            <section class=\"mt-10 container flex flex-col text-white\">                <!-- create post -->                <form method=\"post\" action=\"?/create\" use:enhance>                    <input                        name=\"title\"                        type=\"text\"                        placeholder=\"Post title\"                        required                        class=\"text-lg text-black px-4 py-2 rounded mr-2\"                    />                    <button class=\"rounded border border-white px-4 py-2 text-lg\" type=\"submit\"                        >+ Create</button                    >                </form>                <!-- post list -->                <ul class=\"container mt-8 flex flex-col gap-2\">                    {#each data.posts as post (post.id)}                        <li class=\"flex items-end justify-between gap-4\">                            <!-- post info -->                            <p class={`text-2xl ${!post.published ? 'text-gray-400' : ''}`}>                                {post.title}                                <span class=\"text-lg\"> by {post.author.email}</span>                            </p>                            <!-- post management -->                            <div class=\"flex w-32 justify-end gap-1 text-left\">                                <form method=\"post\" action=\"?/togglePublish\" use:enhance>                                    <input type=\"hidden\" name=\"id\" value={post.id} />                                    <button class=\"underline\" type=\"submit\">                                        {post.published ? 'Unpublish' : 'Publish'}                                    </button>                                </form>                                <form method=\"post\" action=\"?/delete\" use:enhance>                                    <input type=\"hidden\" name=\"id\" value={post.id} />                                    <button class=\"underline\" type=\"submit\">Delete</button>                                </form>                            </div>                        </li>                    {/each}                </ul>                {#if form?.error}                    <p class=\"text-red-500 mt-4\">{form.error}</p>                {/if}            </section>        </div>    {:else}        <div class=\"flex gap-4 text-2xl\">            <a href=\"/signin\" class=\"rounded-lg border px-4 py-2\">Signin</a>            <a href=\"/signup\" class=\"rounded-lg border px-4 py-2\">Signup</a>        </div>    {/if}</main>\n```\n\nThen create a `/src/routes/+page.server.ts` file to handle page data loading and form actions:\n\n/src/routes/+page.server.ts\n\n```\nimport type { PageServerLoad } from './$types';import { fail, type Actions, redirect } from '@sveltejs/kit';import { JWT_TOKEN_COOKIE_NAME } from '$lib/auth';export const load: PageServerLoad = async ({ locals }) => {    const posts = await locals.db.post.findMany({ include: { author: true } });    return {        user: locals.user,        posts    };};export const actions: Actions = {    create: async ({ request, locals }) => {        const data = await request.formData();        const title = data.get('title');        if (typeof title !== 'string') {            return fail(400, { missing: true });        }        await locals.db.post.create({            data: { title, author: { connect: { id: locals.user?.id } } }        });        return { success: true };    },    togglePublish: async ({ request, locals }) => {        const data = await request.formData();        const postId = data.get('id');        if (typeof postId !== 'string') {            return fail(400, { missing: true });        }        const post = await locals.db.post.findUnique({ where: { id: postId } });        if (!post) {            return fail(404, { notFound: true });        }        try {            await locals.db.post.update({ where: { id: postId }, data: { published: !post.published } });            return { success: true };        } catch (err) {            // error can be thrown for reasons like access policy violation            return { error: `${err}` };        }    },    delete: async ({ request, locals }) => {        const data = await request.formData();        const postId = data.get('id');        if (typeof postId !== 'string') {            return fail(400, { missing: true });        }        try {            await locals.db.post.delete({ where: { id: postId } });            return { success: true };        } catch (err) {            // error can be thrown for reasons like access policy violation            return { error: `${err}` };        }    },    signOut: async ({ cookies }) => {        cookies.delete(JWT_TOKEN_COOKIE_NAME);        throw redirect(303, '/signin');    }};\n```\n\ntip\n\n‚ö°Ô∏è Here's the important thing:\n\nAs you can see, our server-side code doesn't contain any authorization logic. Yet our backend is still secure thanks to the access policies we defined in `schema.zmodel`. The enhanced Prisma client (fetched from `locals.db`) enforces that necessary filters and checks are injected when calling into the underlying Prisma client. Your ZModel is the **single source of truth** for access control.\n\n## Verifying the result[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#verifying-the-result \"Direct link to Verifying the result\")\n\nNow our app is complete and let's verify the result. Create two posts with your current account, and publish one of them:\n\n![](https://zenstack.dev/img/get-started/sveltekit/yiming-posts.png)\n\nNow, open a new incognito window and sign up a new account _[emily@zenstack.dev](mailto:emily@zenstack.dev)_. \"Post1\" should appear in her list, since our access policy allows all users to read published posts.\n\n![](https://zenstack.dev/img/get-started/sveltekit/emily-posts.png)\n\nWe didn't do any UI blocking to prevent Emily from unpublishing or deleting other people's posts; however, if she tries to do so, the operation will be rejected by the server-side code:\n\n![](https://zenstack.dev/img/get-started/sveltekit/update-error.png)\n\nIn a real application you can catch the error and render a proper message to the user.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/1.x/quick-start/sveltekit#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple but secure blogging app without writing any authorization logic. Pretty cool, isn't it?\n\nIn this tutorial, we used ZenStack only on the SSR side (loader and actions) of SvelteKit, but its power doesn't stop there. There're two more things worth your attention that enable more advanced scenarios:\n\n*   The [`@zenstackhq/server/sveltekit`](https://zenstack.dev/docs/1.x/reference/server-adapters/sveltekit) server adapter provides a SvelteKit hooks handler that installs an automatic CRUD API for database operations.\n    \n*   The [`@zenstackhq/tanstack-query`](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query) plugin provides automatic generation of client-side query and mutation hooks for consuming the afore-mentioned CRUD API.\n    \n\nThese two features combined allow you to build a typical SPA (CSR + API). You can also freely mix and match SSR and CSR as you wish.\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-sveltekit/tree/v1). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/1.x/category/reference) and [Recipes](https://zenstack.dev/docs/1.x/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "SvelteKit | ZenStack",
  "description": "Step-by-step guide for building a blogging app with SvelteKit.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/quick-start/remix-run",
  "markdown": "# Remix.run | ZenStack\n\n## Get Started With Remix.run\n\nRemix is an excellent framework that allows you to easily collocate data loading and mutation server-side logic with your client-side code. Let's have some fun by creating a simple blogging app. You'll see how effortless it is to build a fully secure application with Remix and ZenStack combined.\n\nYou can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-remix).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Email/password-based signin/signup.\n2.  Users can create posts for themselves.\n3.  Post owners can update/publish/unpublish/delete their own posts.\n4.  Users cannot make changes to posts that do not belong to them.\n5.  Published posts can be viewed by all logged-in users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new project[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#1-create-a-new-project \"Direct link to 1. Create a new project\")\n\nThe easiest way to create a Remix project with boilerplates is with `create-remix`. Run the following command to create a new project. When prompted, choose the following:\n\n*   Typescript or Javascript? **Typescript**\n*   Do you want me to run `npm install`? **Yes**\n\n```\nnpx create-remix@latest --template remix-run/indie-stack my-blog-appcd my-blog-appnpm run dev\n```\n\nIf everything works, you should have a running Remix app at [http://localhost:3000](http://localhost:3000/).\n\n![](https://zenstack.dev/img/remix-start.png)\n\nNow sign up for a new account to continue.\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\n### 3\\. Prepare the Blog model[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#3-prepare-the-blog-model \"Direct link to 3. Prepare the Blog model\")\n\nThe template project already contains a `Note` model. Let's repurpose it to be a `Post` model. Rename it from `Note` to `Post`, and add a `published` field to store if the post is published or not. Also add access control rules with `@@allow` attribute to authorize requests.\n\n/schema.zmodel\n\n```\nmodel Post {  id String @id @default(cuid())  title String  body String  published Boolean @default(false)  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)  userId String  // author has full access  @@allow('all', auth() == user)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\ntip\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy) for more details.\n\nAlso we need to rename the relation in the `User` model from `notes` to `posts`.\n\n/schema.zmodel\n\n```\nmodel User {  id String @id @default(cuid())  email String @unique  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  password Password?  posts Post[]}\n```\n\nNow let's regenerate `schema.prisma` and push schema changes to the database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 4\\. Clean up unused files[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#4-clean-up-unused-files \"Direct link to 4. Clean up unused files\")\n\nRemove a few files and folders that are not needed anymore:\n\n*   /app/models/note.server.ts\n*   /app/routes/note.tsx\n*   /app/routes/notes\n\n### 5\\. Build up the blog homepage[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#5-build-up-the-blog-homepage \"Direct link to 5. Build up the blog homepage\")\n\nFirst add a helper method to `/app/db.server.ts` to get an access-policy-enabled prisma client. We'll use this wrapper to manipulate the `Post` model.\n\n/app/db.server.ts\n\n```\nimport { enhance } from '@zenstackhq/runtime';export function getEnhancedPrisma(userId: string) {    return enhance(prisma, { user: { id: userId } });}\n```\n\nCreate `/app/models/post.server.ts` with the following content:\n\n```\nimport type { User } from '@prisma/client';import { getEnhancedPrisma } from '~/db.server';export function getPosts({ userId }: { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.findMany({        orderBy: { updatedAt: 'desc' },    });}\n```\n\nNotice that we don't need to filter the posts by user id? Still at runtime, only posts belonging to the current user will be returned. This is because of the access policy we previously defined in the `Post` model.\n\nLet's create a new page at `/app/routes/posts.tsx` for listing and managing our blog posts.\n\n/app/routes/posts.tsx\n\n```\nimport type { LoaderArgs } from '@remix-run/node';import { json } from '@remix-run/node';import { Form, Link, NavLink, Outlet, useLoaderData } from '@remix-run/react';import { getPosts } from '~/models/post.server';import { requireUserId } from '~/session.server';import { useUser } from '~/utils';export async function loader({ request }: LoaderArgs) {    const userId = await requireUserId(request);    const posts = await getPosts({ userId });    return json({ posts });}export default function PostsPage() {    const data = useLoaderData<typeof loader>();    const user = useUser();    return (        <div className=\"flex h-full min-h-screen flex-col\">            <header className=\"flex items-center justify-between bg-slate-800 p-4 text-white\">                <h1 className=\"text-3xl font-bold\">                    <Link to=\".\">Posts</Link>                </h1>                <p>{user.email}</p>                <Form action=\"/logout\" method=\"post\">                    <button                        type=\"submit\"                        className=\"rounded bg-slate-600 py-2 px-4 text-blue-100 hover:bg-blue-500 active:bg-blue-600\"                    >                        Logout                    </button>                </Form>            </header>            <main className=\"flex h-full bg-white\">                <div className=\"h-full w-80 border-r bg-gray-50\">                    <Link to=\"new\" className=\"block p-4 text-xl text-blue-500\">                        + New Post                    </Link>                    <hr />                    {data.posts.length === 0 ? (                        <p className=\"p-4\">No posts yet</p>                    ) : (                        <ol>                            {data.posts.map((post) => (                                <li key={post.id}>                                    <NavLink                                        className={({ isActive }) =>                                            `block border-b p-4 text-xl ${isActive ? 'bg-white' : ''}`                                        }                                        to={post.id}                                    >                                        üìù {post.title}                                    </NavLink>                                </li>                            ))}                        </ol>                    )}                </div>                <div className=\"flex-1 p-6\">                    <Outlet />                </div>            </main>        </div>    );}\n```\n\nRestart your dev server and hit [http://localhost:3000/posts](http://localhost:3000/posts), you should see something like this:\n\n![](https://zenstack.dev/img/remix-posts.png)\n\n### 6\\. Build up the create post page[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#6-build-up-the-create-post-page \"Direct link to 6. Build up the create post page\")\n\nFirst add a function to `/app/models/post.server.ts` for creating a new post.\n\n/app/models/post.server.ts\n\n```\nimport type { Post } from '@prisma/client';export function createPost({ body, title, userId }: Post & { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.create({        data: {            title,            body,            user: {                connect: {                    id: userId,                },            },        },    });}\n```\n\nAdd `/app/routes/posts/new.tsx` with the following content:\n\n/app/routes/posts/new.tsx\n\n```\nimport type { ActionArgs } from '@remix-run/node';import { json, redirect } from '@remix-run/node';import { Form, useActionData } from '@remix-run/react';import * as React from 'react';import { createPost } from '~/models/post.server';import { requireUserId } from '~/session.server';export async function action({ request }: ActionArgs) {    const userId = await requireUserId(request);    const formData = await request.formData();    const title = formData.get('title');    const body = formData.get('body');    if (typeof title !== 'string' || title.length === 0) {        return json({ errors: { title: 'Title is required', body: null } }, { status: 400 });    }    if (typeof body !== 'string' || body.length === 0) {        return json({ errors: { title: null, body: 'Body is required' } }, { status: 400 });    }    const post = await createPost({ title, body, userId });    return redirect(`/posts/${post.id}`);}export default function NewPostPage() {    const actionData = useActionData<typeof action>();    const titleRef = React.useRef<HTMLInputElement>(null);    const bodyRef = React.useRef<HTMLTextAreaElement>(null);    React.useEffect(() => {        if (actionData?.errors?.title) {            titleRef.current?.focus();        } else if (actionData?.errors?.body) {            bodyRef.current?.focus();        }    }, [actionData]);    return (        <Form            method=\"post\"            style={{                display: 'flex',                flexDirection: 'column',                gap: 8,                width: '100%',            }}        >            <div>                <label className=\"flex w-full flex-col gap-1\">                    <span>Title: </span>                    <input                        ref={titleRef}                        name=\"title\"                        className=\"flex-1 rounded-md border-2 border-blue-500 px-3 text-lg leading-loose\"                        aria-invalid={actionData?.errors?.title ? true : undefined}                        aria-errormessage={actionData?.errors?.title ? 'title-error' : undefined}                    />                </label>                {actionData?.errors?.title && (                    <div className=\"pt-1 text-red-700\" id=\"title-error\">                        {actionData.errors.title}                    </div>                )}            </div>            <div>                <label className=\"flex w-full flex-col gap-1\">                    <span>Body: </span>                    <textarea                        ref={bodyRef}                        name=\"body\"                        rows={8}                        className=\"w-full flex-1 rounded-md border-2 border-blue-500 py-2 px-3 text-lg leading-6\"                        aria-invalid={actionData?.errors?.body ? true : undefined}                        aria-errormessage={actionData?.errors?.body ? 'body-error' : undefined}                    />                </label>                {actionData?.errors?.body && (                    <div className=\"pt-1 text-red-700\" id=\"body-error\">                        {actionData.errors.body}                    </div>                )}            </div>            <div className=\"text-right\">                <button                    type=\"submit\"                    className=\"rounded bg-blue-500 py-2 px-4 text-white hover:bg-blue-600 focus:bg-blue-400\"                >                    Save                </button>            </div>        </Form>    );}\n```\n\n### 7\\. Build up the post details page[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#7-build-up-the-post-details-page \"Direct link to 7. Build up the post details page\")\n\nFirst add a few functions to `/app/models/post.server.ts` for manipulating a single post.\n\n/app/models/post.server.ts\n\n```\nexport function getPost({    id,    userId,}: Pick<Post, 'id'> & {    userId: User['id'];}) {    return getEnhancedPrisma(userId).post.findUnique({        where: { id },    });}export function deletePost({ id, userId }: Pick<Post, 'id'> & { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.delete({        where: { id },    });}export function publishPost({ id, userId }: Pick<Post, 'id'> & { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.update({        where: { id },        data: { published: true },    });}export function unpublishPost({ id, userId }: Pick<Post, 'id'> & { userId: User['id'] }) {    return getEnhancedPrisma(userId).post.update({        where: { id },        data: { published: false },    });}\n```\n\nCreate `/app/routes/posts/$postId.tsx` with the following content:\n\n```\nimport type { ActionArgs, LoaderArgs } from '@remix-run/node';import { json, redirect } from '@remix-run/node';import { Form, useCatch, useLoaderData } from '@remix-run/react';import invariant from 'tiny-invariant';import { deletePost, getPost, publishPost, unpublishPost } from '~/models/post.server';import { requireUserId } from '~/session.server';export async function loader({ request, params }: LoaderArgs) {    const userId = await requireUserId(request);    invariant(params.postId, 'await not found');    const post = await getPost({ userId, id: params.postId });    if (!post) {        throw new Response('Not Found', { status: 404 });    }    return json({ post });}export async function action({ request, params }: ActionArgs) {    const userId = await requireUserId(request);    invariant(params.postId, 'postId not found');    const intent = (await request.formData()).get('intent');    switch (intent) {        case 'delete':            await deletePost({ userId, id: params.postId });            return redirect('/posts');        case 'publish':            await publishPost({ userId, id: params.postId });            return null;        case 'unpublish':            await unpublishPost({ userId, id: params.postId });            return null;    }}export default function PostDetailsPage() {    const data = useLoaderData<typeof loader>();    return (        <div>            <h3 className=\"text-2xl font-bold\">                {data.post.title} {!data.post.published && <span className=\"text-base font-normal italic\">Draft</span>}            </h3>            <p className=\"py-6\">{data.post.body}</p>            <hr className=\"my-4\" />            <div className=\"flex gap-2\">                <Form method=\"post\">                    <input type=\"hidden\" name=\"intent\" value=\"delete\" />                    <button                        type=\"submit\"                        className=\"rounded bg-blue-500  py-2 px-4 text-white hover:bg-blue-600 focus:bg-blue-400\"                    >                        Delete                    </button>                </Form>                <Form method=\"post\">                    <input type=\"hidden\" name=\"intent\" value={data.post.published ? 'unpublish' : 'publish'} />                    <button                        type=\"submit\"                        className=\"rounded bg-blue-500  py-2 px-4 text-white hover:bg-blue-600 focus:bg-blue-400\"                    >                        {data.post.published ? 'Unpublish' : 'Publish'}                    </button>                </Form>            </div>        </div>    );}export function ErrorBoundary({ error }: { error: Error }) {    console.error(error);    return <div>An unexpected error occurred: {error.message}</div>;}export function CatchBoundary() {    const caught = useCatch();    if (caught.status === 404) {        return <div>Post not found</div>;    }    throw new Error(`Unexpected caught response with status: ${caught.status}`);}\n```\n\nThen, add `/app/routes/posts/index.tsx` to show default content when no post is selected:\n\n/app/routes/posts/index.tsx\n\n```\nimport { Link } from '@remix-run/react';export default function PostIndexPage() {    return (        <p>            No post selected. Select a post on the left, or{' '}            <Link to=\"new\" className=\"text-blue-500 underline\">                create a new post.            </Link>        </p>    );}\n```\n\nFinally, update `/app/routes/index.tsx` to change the main link to our posts page:\n\n/app/routes/index.tsx\n\n```\n<Link    to=\"/posts\"    className=\"flex items-center justify-center rounded-md border border-transparent bg-white px-4 py-3 text-base font-medium text-yellow-700 shadow-sm hover:bg-yellow-50 sm:px-8\">    View Posts for {user.email}</Link>\n```\n\n### 8\\. Test it out![‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#8-test-it-out \"Direct link to 8. Test it out!\")\n\nüéâ Congratulations! You've made a simple blogging app without manually implementing any access control logic. Now test it out and see if you can create posts and manage them.\n\n![](https://zenstack.dev/img/remix-test-it.png)\n\nSince we haven't hidden \"Unpublish\" and \"Delete\" buttons for posts not owned by the current user, you can still click them even for posts not owned to you, but it will end up with an error. Even if you forget to block certain actions from the frontend, our access control logic will still prevent them from happening.\n\n![](https://zenstack.dev/img/remix-forbidden.png)\n\nYou can catch the error and render a nice message to the user.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/1.x/quick-start/remix-run#wrap-up \"Direct link to Wrap up\")\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-remix/tree/v1). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/1.x/category/reference) and [Guides](https://zenstack.dev/docs/1.x/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Remix.run | ZenStack",
  "description": "Step-by-step guide for building a blogging app with Remix.run.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/",
  "markdown": "# ZenStack: The Complete Guide | ZenStack\n\n## Introduction[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/#introduction \"Direct link to Introduction\")\n\nWelcome to _The Complete Guide of ZenStack_. This guide is designed to systematically introduce the key concepts in ZenStack and guide you through how to use its essential features.\n\n## Sample Project[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/#sample-project \"Direct link to Sample Project\")\n\nThroughout the guide, we'll learn the key concepts and features by gradually building a sample project. The project is a multi-tenant Todo app, which allows users to create and join \"Spaces\", and collaborate with users in the same space by creating and managing Todo Lists.\n\nHere are the detailed requirements:\n\n*   Email/password based signin/signup.\n*   `Space` for multi-tenancy management. Users can join multiple spaces, and a space can have many users.\n*   Users can be of \"USER\" or \"ADMIN\" role in a space. Space admins can manage space members.\n*   Users can manage Todo lists and items in spaces they belong to.\n*   Public Todo lists are accessible to all space members. Private lists are only accessible to the owner and space admins.\n\nThe app is not too complex but covers many important aspects of a modern multi-tenant web application. You can find the complete source code of the project at [https://github.com/zenstackhq/the-complete-guide-sample/tree/v1](https://github.com/zenstackhq/the-complete-guide-sample/tree/v1). It contains several branches, each corresponding to the end state of a part of the guide. For example, you can use branch \"part1\" as the starting point of your study of Part II.\n\nHands-on indicator\n\nMany chapters include hands-on sections where we gradually build the sample project. They are all marked with üõ†Ô∏è symbol.\n\nYou can have a preview of the fully completed version below:\n\n[![Sample Todo App](https://zenstack.dev/assets/images/todo-app-splash-82ad67e1e0212042dee7539b851f451d.png)](https://zenstack-todo.vercel.app/)\n\n## Organization[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/#organization \"Direct link to Organization\")\n\nZenStack consists of several layers of functionalities, each depends on the previous one. These layers are explained in detail in the following four parts. In each part, we'll add more functionalities to our Todo app and eventually finish it by the end of the guide.\n\n### Part I: Supercharged ORM[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/#part-i-supercharged-orm \"Direct link to Part I: Supercharged ORM\")\n\nThe first layer works as an extension to Prisma ORM - both for the schema language and the runtime PrismaClient. We made several extensions to the Prisma Schema Language to make it possible to express more than just the database schema. For example, you can attach access policies to the data models. At runtime, ZenStack creates a transparent proxy around PrismaClient to add extra behavior to it - one of the best examples is the automatic access control enforcement.\n\nThe extension to Prisma ORM is the foundation of ZenStack and enables all other features above it. These features are also agnostic to the framework you use for the backend. It's simply a drop-in replacement for Prisma.\n\nIn this part of the guide, we'll finish building the schema of the sample project - including the data models, access policies, and data validation rules. There's no API or UI yet, but the business logic will be mostly complete.\n\n[Go to Part I](https://zenstack.dev/docs/1.x/the-complete-guide/part1)\n\n### Part II: Plugin System[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/#part-ii-plugin-system \"Direct link to Part II: Plugin System\")\n\nZenStack adopts a plugin-based architecture for great extensibility. The plugin system allows you to add new features to ZenStack without modifying the core codebase. In fact, most built-in features of ZenStack are implemented as plugins.\n\nIn this part of the guide, you'll see how to use plugins to achieve various goals, and we'll also build a simple plugin for our Todo app from scratch.\n\n[Go to Part II](https://zenstack.dev/docs/1.x/the-complete-guide/part2)\n\n### Part III: Automatic CRUD API[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/#part-iii-automatic-crud-api \"Direct link to Part III: Automatic CRUD API\")\n\nDevelopers build APIs to support the client side of their applications. One of the most common type of APIs is CRUD - Create, Read, Update, and Delete. Building CRUD APIs is a tedious task but error-prone at the same time.\n\nSince ZenStack already secures data access at the ORM layer, as we learned from the previous part, it can automatically generate CRUD APIs for you. You'll learn about the details in this part of the guide.\n\nIn this part of the guide, we'll add a CRUD API layer to our Todo app and turn it into a fully functional backend service.\n\n[Go to Part III](https://zenstack.dev/docs/1.x/the-complete-guide/part3)\n\n### Part IV: Frontend Data Query[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/#part-iv-frontend-data-query \"Direct link to Part IV: Frontend Data Query\")\n\nModern web apps often use data query libraries (like [TanStack Query](https://tanstack.com/query) and [SWR](https://swr.vercel.app/)) to fetch data from the backend. These libraries help you build reactive data binding UI with ease.\n\nZenStack can generate hooks code that talks to the automatic CRUD API introduced in the previous part, targeting these libraries. The hooks help you implement front-end data queries with minimum code and complete type safety. Part IV focuses on this topic.\n\nIn this part of the guide, we'll use the generated data query hooks to build a frontend UI for our Todo app. We'll finally complete our full-stack Todo application!\n\n[Go to Part IV](https://zenstack.dev/docs/1.x/the-complete-guide/part4)",
  "title": "ZenStack: The Complete Guide | ZenStack",
  "description": "The Complete Guide of ZenStack",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/quick-start/backend",
  "markdown": "# Backend-only Usage | ZenStack\n\nZenStack gives you a pleasant type-safe approach for calling your database \"directly\" from the frontend without coding a backend. Moreover, even if you're only building the backend side of an app, it can still help by defining access policies right inside your data model. This results in a security model that's both easier to maintain and more reliable than a manually implemented one.\n\nLet's have some fun by creating a simple blogging service with Express.js. You can find the final build result [here](https://github.com/zenstackhq/docs-tutorial-express).\n\n## Requirements[‚Äã](https://zenstack.dev/docs/1.x/quick-start/backend#requirements \"Direct link to Requirements\")\n\nOur target app should meet the following requirements:\n\n1.  Users can create posts for themselves.\n2.  Post owner can update/publish/unpublish/delete their own posts.\n3.  Users cannot make changes to posts that do not belong to them.\n4.  Published posts can be viewed by all users.\n\nLet's get started üöÄ.\n\n## Prerequisite[‚Äã](https://zenstack.dev/docs/1.x/quick-start/backend#prerequisite \"Direct link to Prerequisite\")\n\n1.  Make sure you have Node.js 18 or above installed.\n2.  Install the [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) for editing data models.\n\n## Building the app[‚Äã](https://zenstack.dev/docs/1.x/quick-start/backend#building-the-app \"Direct link to Building the app\")\n\n### 1\\. Create a new Prisma project[‚Äã](https://zenstack.dev/docs/1.x/quick-start/backend#1-create-a-new-prisma-project \"Direct link to 1. Create a new Prisma project\")\n\nPrisma has a nice sample project for Express.js. Let's use it as a starting point:\n\n```\nnpx degit prisma/prisma-examples/typescript/rest-express my-blog-appcd my-blog-appnpm install\n```\n\nNext, let's initialize the database with seed data and start the dev server:\n\n```\nnpx prisma db pushnpx prisma db seednpm run dev\n```\n\nYour server should be listening on port 3000 for RESTful requests.\n\nLet's add a simple API to list all posts:\n\n/src/index.ts\n\n```\napp.get(`/post`, async (req, res) => {    const post = await prisma.post.findMany({        include: { author: true },    });    res.json(post);});\n```\n\nRestart the server and verify it works by:\n\nYou should see a list of posts like this:\n\n```\n[    {        \"id\": 1,        \"createdAt\": \"2023-01-14T06:46:52.628Z\",        \"updatedAt\": \"2023-01-14T06:46:52.628Z\",        \"title\": \"Join the Prisma Slack\",        \"content\": \"https://slack.prisma.io\",        \"published\": true,        \"viewCount\": 0,        \"authorId\": 1,        \"author\": { \"id\": 1, \"email\": \"alice@prisma.io\", \"name\": \"Alice\" }    },    ...]\n```\n\n### 2\\. Initialize the project for ZenStack[‚Äã](https://zenstack.dev/docs/1.x/quick-start/backend#2-initialize-the-project-for-zenstack \"Direct link to 2. Initialize the project for ZenStack\")\n\nLet's run the `zenstack` CLI to prepare your project for using ZenStack.\n\ninfo\n\nThe command installs a few NPM dependencies. If the project already has a Prisma schema at `prisma/schema.prisma`, it's copied over to `schema.zmodel`. Otherwise, a sample `schema.zmodel` file is created.\n\nMoving forward, you will keep updating `schema.zmodel` file, and `prisma/schema.prisma` will be automatically generated from it.\n\n### 3\\. Add access policies[‚Äã](https://zenstack.dev/docs/1.x/quick-start/backend#3-add-access-policies \"Direct link to 3. Add access policies\")\n\nOur bootstrapped `schema.zmodel` file already has a `User` and a `Post` model defined. However, they don't carry any access policies. So if you use a plain Prisma client in the backend code, anyone can do anything to any data unless you write some custom authorization logic.\n\nYou need two things to secure it up:\n\n1.  Implement an authentication mechanism to identify the current user.\n2.  Implement authorization to control who can take which actions to what data.\n\n#1 can usually be achieved by requiring a session cookie or a JWT token. For simplicity, we'll skip this part in the tutorial and just pass user id in a plain `X-USER-ID` header. We'll focus on #2 and utilize ZenStack to implement authorization without manually coding it.\n\nLet's add the following access policies to the `User` and `Post` model to implement the requirements we laid out previously:\n\n/schema.zmodel\n\n```\nmodel User {    id Int @id() @default(autoincrement())    email String @unique()    name String?    posts Post[]    // make user profile public    @@allow('read', true)}model Post {    id Int @id() @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    title String    content String?    published Boolean @default(false)    viewCount Int @default(0)    author User? @relation(fields: [authorId], references: [id])    authorId Int?    // author has full access    @@allow('all', auth() == author)    // logged-in users can view published posts    @@allow('read', auth() != null && published)}\n```\n\ntip\n\nBy default, all operations are denied for a model. You can use the `@@allow` attribute to open up some permissions.\n\n`@@allow` takes two parameters, the first is operation: create/read/update/delete. You can use a comma separated string to pass multiple operations, or use 'all' to abbreviate all operations. The second parameter is a boolean expression that verdicts if the rule should be activated.\n\nSimilarly, `@@deny` can be used to explicitly turn off some operations. It has the same syntax as `@@allow` but the opposite effect.\n\nWhether an operation is permitted is determined as follows:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied.\n\nCheck out [Understanding Access Policies](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy) for more details.\n\nNow flush the changes to the Prisma schema and database schema:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 4\\. Secure the APIs[‚Äã](https://zenstack.dev/docs/1.x/quick-start/backend#4-secure-the-apis \"Direct link to 4. Secure the APIs\")\n\nNow let's secure up our APIs, leveraging the access policies.\n\nFirst, add a simple middleware to require `X-USER-ID` header (to simulate authentication). Make sure the following code is inserted above all express routes so it can be applied to all endpoints.\n\n/src/index.ts\n\n```\napp.use((req, res, next) => {    const userId = req.header('X-USER-ID');    if (!userId || Number.isNaN(parseInt(userId))) {        res.status(403).json({ error: 'unauthorized' });    } else {        next();    }});\n```\n\nNext, add two helper methods to get a Prisma client that's bound to the current user identity:\n\n/src/index.ts\n\n```\nimport { Request } from 'express';import { enhance } from '@zenstackhq/runtime';function getUserId(req: Request) {    return parseInt(req.header('X-USER-ID')!);}// Gets a Prisma client bound to the current user identityfunction getPrisma(req: Request) {    const userId = getUserId(req);    const user = Number.isNaN(userId) ? undefined : { id: userId };    return enhance(prisma, { user });}\n```\n\ntip\n\n`enhance` is a ZenStack runtime API that wraps a Prisma client and enhances it with access policy checks.\n\nThen, change our `POST /post` API to use extracted user id instead of passing in user email in the body when creating a new post:\n\n/src/index.ts\n\n```\napp.post(`/post`, async (req, res) => {    const { title, content } = req.body;    const result = await prisma.post.create({        data: {            title,            content,            author: { connect: { id: getUserId(req) } },        },    });    res.json(result);});\n```\n\nFinally, change all code that uses `prisma` to `getPrisma(req)`. Here I'm showing only one occurrence:\n\n/src/index.ts\n\n```\napp.get(`/post`, async (req, res) => {    const post = await getPrisma(req).post.findMany({        include: { author: true },    });    res.json(post);});\n```\n\nNote that you don't need to change your Prisma query because the wrapped Prisma client has exactly the same API as the original Prisma client.\n\n### 5\\. Test the secured backend[‚Äã](https://zenstack.dev/docs/1.x/quick-start/backend#5-test-the-secured-backend \"Direct link to 5. Test the secured backend\")\n\nNow, restart the server and hit the `/post` endpoint again directly. You should get a 403 error because the middleware rejected it:\n\n```\ncurl -I localhost:3000/post\n```\n\n```\n  HTTP/1.1 403 Forbidden  X-Powered-By: Express  Content-Type: application/json; charset=utf-8  Content-Length: 24  ETag: W/\"18-gH7/fIZxPCVRh6TuPVNAgHt/40I\"  Date: Sat, 14 Jan 2023 08:08:10 GMT  Connection: keep-alive  Keep-Alive: timeout=5\n```\n\nWe can make it work by specifying `X-USER-ID` header:\n\n```\ncurl -H \"X-USER-ID: 1\" localhost:3000/post\n```\n\nLet's create a new unpublished post for user#1:\n\n```\ncurl --request POST \\    -H \"X-USER-ID: 1\" -H \"Content-Type: application/json\" \\    -d '{\"title\": \"My new post\", \"content\": \"Some awesome content\"}' \\    localhost:3000/post\n```\n\n, and hit `/post` API again with user#1:\n\n```\ncurl -H \"X-USER-ID: 1\" localhost:3000/post\n```\n\nYou should see in the result the newly created post:\n\n```\n[    ...    {        \"id\": 4,        \"createdAt\": \"2023-01-14T08:42:56.833Z\",        \"updatedAt\": \"2023-01-14T08:42:56.833Z\",        \"title\": \"My new post\",        \"content\": \"Some awesome content\",        \"published\": false,        \"viewCount\": 0,        \"authorId\": 1,        \"author\": { \"id\": 1, \"email\": \"alice@prisma.io\", \"name\": \"Alice\" }    }]\n```\n\nHowever, if you hit `/post` API with user#2:\n\n```\ncurl -H \"X-USER-ID: 2\" localhost:3000/post\n```\n\n, you won't see the new post because it's not published yet. Our access policies are at work.\n\nFeel free to play more with updating and deleting posts with different user ids and see if the policies work as expected.\n\n## Wrap up[‚Äã](https://zenstack.dev/docs/1.x/quick-start/backend#wrap-up \"Direct link to Wrap up\")\n\nüéâ Congratulations! You've made a simple but secure blogging service without writing any authorization code. Pretty cool, isn't it?\n\nIf you have trouble following the building process, you can find the final result [here](https://github.com/zenstackhq/docs-tutorial-express/tree/v1). For more details about ZenStack, please refer to the [Reference](https://zenstack.dev/docs/1.x/category/reference) and [Guides](https://zenstack.dev/docs/1.x/category/recipes) parts of the documentation.\n\nHave fun building cool stuff üöÄ!",
  "title": "Backend-only Usage | ZenStack",
  "description": "Steps for using ZenStack only in backend development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/sample-catalog",
  "markdown": "# A Catalog of Sample Projects\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "A Catalog of Sample Projects | ZenStack",
  "description": "The ZenStack team maintains the following three series of sample projects.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/category/recipes",
  "markdown": "# Recipes | ZenStack\n\n[\n\n## üìÑÔ∏è Debugging and Troubleshooting\n\nZenStack's access policies are powerful, but when the rules get complex, it can be challenging to reason why an operation is being allowed or denied. This guide lists some techniques for debugging and troubleshooting.\n\n](https://zenstack.dev/docs/1.x/guides/debugging)",
  "title": "Recipes | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/faq",
  "markdown": "# üôãüèª FAQ | ZenStack\n\n### Is ZenStack implemented with Postgres RLS (row-level-security)?[‚Äã](https://zenstack.dev/docs/1.x/faq#is-zenstack-implemented-with-postgres-rls-row-level-security \"Direct link to Is ZenStack implemented with Postgres RLS (row-level-security)?\")\n\nNo, it is not implemented with Postgres RLS. Instead, ZenStack applies access control rules by injecting into Prisma's query arguments and (in certain scenarios) conducting post-query filtering. The choice brings several benefits:\n\n1.  Database agnostic: ZenStack works with any database that Prisma supports.\n2.  No need to create migrations when changing access control rules.\n3.  A significantly simpler syntax for access control rules compared to SQL RLS.\n4.  Collocating access control rules with the data model.\n\n### Does using ZenStack introduce more connections to my databases?[‚Äã](https://zenstack.dev/docs/1.x/faq#does-using-zenstack-introduce-more-connections-to-my-databases \"Direct link to Does using ZenStack introduce more connections to my databases?\")\n\nNo. It's common to create enhanced PrismaClient wrappers per request (for binding to different user identity). Under the hood all such wrappers share the same PrismaClient instance and thus the same database connection.\n\n### Is ZenStack framework-agnostic?[‚Äã](https://zenstack.dev/docs/1.x/faq#is-zenstack-framework-agnostic \"Direct link to Is ZenStack framework-agnostic?\")\n\nYes, ZenStack is framework-agnostic. The core of ZenStack's runtime is a transparent proxy wrapping a PrismaClient, so it can be used in any framework that can run Prisma. ZenStack already provides adapters for popular frameworks like [Next.js](https://zenstack.dev/docs/1.x/reference/server-adapters/next) and [Fastify](https://zenstack.dev/docs/1.x/reference/server-adapters/fastify), and more are being made. It's also easy to write your own adapters.\n\n### How to use ZenStack in a monorepo setup?[‚Äã](https://zenstack.dev/docs/1.x/faq#how-to-use-zenstack-in-a-monorepo-setup \"Direct link to How to use ZenStack in a monorepo setup?\")\n\nTo use ZenStack in a monorepo setup (e.g., pnpm workspace), run `zenstack init` in the package where `schema.prisma` resides (usually also where the global `prisma` instance is exported). There's no need to install ZenStack-related packages at the workspace level.\n\n### Is ZModel fully compatible with Prisma Schema?[‚Äã](https://zenstack.dev/docs/1.x/faq#is-zmodel-fully-compatible-with-prisma-schema \"Direct link to Is ZModel fully compatible with Prisma Schema?\")\n\nThe ZModel language is designed to be a superset of Prisma Schema. The major extension that ZModel made to Prisma schema today are:\n\n*   [Custom attributes](https://zenstack.dev/docs/1.x/reference/zmodel-language#custom-attributes-and-functions)\n*   [Plugins](https://zenstack.dev/docs/1.x/category/plugins)\n\nUsing a separate DSL gives us the flexibility to add more extensions in the future; however, the goal is to maintain the \"superset\" positioning, i.e., every valid `schema.prisma` is a valid `schema.zmodel`.\n\nIn practice, you may run into problems that the `schema.prisma` generated by ZenStack triggers validation errors in `prisma` CLI. This is because Prisma CLI has many validation rules, some quite subtle. We try to replicate those rules in `zenstack` CLI, but it's more of a best-effort approach. Fortunately, the errors reported by `prisma` CLI usually give pretty good hints on what to change in `schema.zmodel`.\n\nWe will continue improving the parity between ZModel and Prisma Schema regarding validation rules.\n\n### Does ZenStack require a specific Prisma version?[‚Äã](https://zenstack.dev/docs/1.x/faq#does-zenstack-require-a-specific-prisma-version \"Direct link to Does ZenStack require a specific Prisma version?\")\n\nNo. ZenStack references Prisma as a peer dependency and should work with Prisma 4.8.0 and above.\n\n### Does ZenStack work with Prisma migration?[‚Äã](https://zenstack.dev/docs/1.x/faq#does-zenstack-work-with-prisma-migration \"Direct link to Does ZenStack work with Prisma migration?\")\n\nYes. When you run `zenstack generate` it generates a standard Prisma schema file that can be used with Prisma migration.\n\n### Are there any other IDE integrations besides VSCode?[‚Äã](https://zenstack.dev/docs/1.x/faq#are-there-any-other-ide-integrations-besides-vscode \"Direct link to Are there any other IDE integrations besides VSCode?\")\n\nYes, ZenStack has integrations with VSCode and JetBrains IDEs. Please see [here](https://zenstack.dev/docs/1.x/guides/ide) for ore details.\n\n### Why am I getting \"Critical dependency: the request of a dependency is an expression\" error with Next.js 13 and above?[‚Äã](https://zenstack.dev/docs/1.x/faq#why-am-i-getting-critical-dependency-the-request-of-a-dependency-is-an-expression-error-with-nextjs-13-and-above \"Direct link to Why am I getting \"Critical dependency: the request of a dependency is an expression\" error with Next.js 13 and above?\")\n\nNext.js 13's new bundler has compatibility issues with `@zenstackhq/runtime` package. We've submitted a [PR](https://github.com/vercel/next.js/pull/54829) to Next.js but it hasn't been accepted yet. For the time being, please add the following settings to your `next.config.js`:\n\n```\n{  ...  experimental: {    serverComponentsExternalPackages: [      \"@zenstackhq/runtime\"    ],  }}\n```\n\n### Does ZenStack work with Prisma Client Extensions?[‚Äã](https://zenstack.dev/docs/1.x/faq#does-zenstack-work-with-prisma-client-extensions \"Direct link to Does ZenStack work with Prisma Client Extensions?\")\n\nThe short answer is it works in most cases. Please refer to [this guide](https://zenstack.dev/docs/1.x/guides/client-extensions) for more details.",
  "title": "üôãüèª FAQ | ZenStack",
  "description": "ZenStack FAQ.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/access-policy",
  "markdown": "# Access Policy | ZenStack\n\nWhen using an enhanced Prisma Client, the first thing that may surprise you is that you can't read or write any data. For example, given the following model:\n\n```\nmodel User {    id Int @id    email String @unique}\n```\n\nThe following code will result in a runtime error:\n\n```\nconst prisma = new PrismaClient();const db = enhance(prisma);await db.user.create({ data: { email: 'zen@stack.dev'} });\n```\n\nThe reason is that, with an enhanced client, all CRUD operations are denied by default. You'll need to allow them with policy rules explicitly. This \"secure by default\" design may cause some inconvenience, but it prevents you from accidentally exposing data to unauthorized users.",
  "title": "Access Policy | ZenStack",
  "description": "Introduction",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user",
  "markdown": "# Accessing Current User | ZenStack\n\nIn most cases, whether a CRUD operation is allowed depends on the current user. ZenStack provides a special function `auth()` to access the current user in policy rules.\n\n### Auth Model[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#auth-model \"Direct link to Auth Model\")\n\nWhen ZModel is compiled, the `auth()` function needs to be resolved to a data model so that the compiler knows which fields are accessible from the function. By default, the model named \"User\" is used as the auth model. Here's an example:\n\n```\nmodel User {    id Int @id    role String    posts Post[]}model Post {    id Int @id    title String    author User @relation(fields: [authorId], references: [id])    authorId Int    // ‚úÖ valid rule    @@allow('all', auth().role == 'ADMIN')    // ‚ùå invalid rule, `subscribed` field doesn't exist in `User` model    @@allow('all', auth().subscribed == true) }\n```\n\nYou can use a model not named `User` as the auth model by adding the `@@auth` attribute to it.\n\n```\nmodel MyUser {    id Int @id    role String    posts Post[]    @@auth}\n```\n\nWhat if I don't store users in the database?\n\nIf you use an external authentication service like Clerk or Supabase Auth, you can choose not to store users in the database, since the auth services are already doing this for you. However, in ZModel, the `auth()` function call always needs to be resolved to an auth model.\n\nThe trick here is to still define an auth model, but mark it with the `@@ignore` attribute so that it's excluded from the generated PrismaClient.\n\n```\nmodel User {    id String @id    ...    @@ignore}\n```\n\nAlso, when you generate Prisma migrations, make sure to remove the code generated for the `User` model.\n\nSince the `User` model is not mapped to a database table, you shouldn't have other models to have relations to it. Instead, you can store the user id provided by the authentication service in your models, which is like a \"foreign key\" but pointing to an external system.\n\n### Providing Current User[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#providing-current-user \"Direct link to Providing Current User\")\n\nSince ZenStack is not an authentication solution, it doesn't know who the current user is. It's up to the developer to get it from the authentication side and pass it to ZenStack (when calling the `enhance` function).\n\nHere's the pseudo-code:\n\n```\n// `getCurrentUser` is an authentication API that extracts // the current user from the requestconst user = await getCurrentUser(request);// create an enhanced Prisma Client for the user, the `user` object// provides value for the `auth()` function in policy rulesconst db = enhance(prisma, { user })\n```\n\nThe minimum requirement for the `user` object is to have a value for the \"id\" field of the auth model (if the model uses compound id fields, all fields need to be assigned). However, if your access policies involve other fields of the auth model, you need to provide them as well.\n\nProvide all fields needed by policy rules\n\nZenStack doesn't query the database automatically to fetch the missing fields, but you can do that as needed. Let's say if you have a policy rule like:\n\n```\n@@allow('update', auth().role == 'ADMIN')\n```\n\nBefore calling `enhance()`, you can hit the database (using the original Prisma Client) to fetch the user's role:\n\n```\nconst userId = getCurrentUserId(request);const user = await prisma.user.findUniqueOrThrow({ where: { id: userId }, select: { id: true, role: true } });const db = enhance(prisma, { user });\n```\n\nIn the future, we may introduce a new option to control if the missing fields should be automatically fetched from the database.\n\n### Writing Conditions With `auth()`[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#writing-conditions-with-auth \"Direct link to writing-conditions-with-auth\")\n\n#### Checking Anonymous User[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#checking-anonymous-user \"Direct link to Checking Anonymous User\")\n\nYou can indicate that the current user is anonymous by not passing the `user` object (or passing `undefined`) when calling `enhance`:\n\n```\nconst db = enhance(prisma);\n```\n\nIn policy rules, check `auth() == null` for anonymous user:\n\n```\nmodel Post {    ...    // allow all login users to read    @@allow('read', auth() != null)}\n```\n\n#### Comparing `auth()` With Other Fields[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#comparing-auth-with-other-fields \"Direct link to comparing-auth-with-other-fields\")\n\nYou can compare `auth()` against a field of the same type (i.e., the auth model). Such comparison is equivalent to an id field comparison. For example, the following policy rule:\n\n```\nmodel Post {    ...    author User @relation(fields: [authorId], references: [id])    authorId Int    @@allow('update', auth() == author)}\n```\n\nis equivalent to:\n\n```\nmodel Post {    ...    author User @relation(fields: [authorId], references: [id])    authorId Int    @@allow('update', auth().id == author.id)}\n```\n\n, and is also equivalent to:\n\n```\nmodel Post {    ...    author User @relation(fields: [authorId], references: [id])    authorId Int    @@allow('update', auth().id == authorId)}\n```\n\n#### Traversing Relation Fields[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#traversing-relation-fields \"Direct link to Traversing Relation Fields\")\n\nYou can access auth model's relation fields from `auth()` function and chain them with other fields. Remember ZenStack doesn't fetch the fields accessed from `auth()` automatically, so you need to provide them (recursively if there's multi-level traversing) when calling `enhance()`.\n\n```\nmodel User {    ...    role Role}model Role {    ...    permissions Permission[]}model Permission {    ...    name String  // READ, WRITE, etc.}model Post {    ...    @@allow('read', auth().role.permissions?[name == 'READ'])}\n```\n\ninfo\n\nThe `expression?[condition]` syntax used above is called \"Collection Predicate Expression\". It's used for computing a boolean value from a \"\\*-to-many\" relation field. You'll learn more about it in the next chapter.\n\n### Using `auth()` in `@default()`[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#using-auth-in-default \"Direct link to using-auth-in-default\")\n\nAnother very useful place to use `auth()` is in the `@default()` attribute. It's common to require a resource's owner to be the current user when creating an entity. You can use a \"create\" rule to enforce that:\n\n```\nmodel Resource {    ...    owner User @relation(fields: [ownerId], references: [id])    ownerId Int    @@allow('create', owner == auth())}\n```\n\nThe policy ensures that the caller can't set a resource's owner to someone else. However, when making a create call, you'll still need to connect the owner:\n\n```\nawait db.resource.create({ data: { ..., owner: { connect: { id: currentUser.id } } } });\n```\n\nThis can be simplified by using `auth()` in the `@default()` attribute:\n\n```\nmodel Resource {    ...    owner User @relation(fields: [ownerId], references: [id])    ownerId Int @default(auth().id)    @@allow('create', owner == auth())}\n```\n\nNow, when creating a resource, you don't need to explicitly make the owner connection.\n\n### üõ†Ô∏è Adding User-Based Access Control[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#add-user-based-access-control \"Direct link to üõ†Ô∏è Adding User-Based Access Control\")\n\nAdd the following policies and default values to the schema:\n\nschema.zmodel\n\n```\nmodel User {  ...  // everyone can sign up  @@allow('create', true)  // full access by oneself  @@allow('all', auth() == this)}model Space {  ...  ownerId Int @default(auth().id)}model List {  ...  ownerId Int @default(auth().id)  // owner has full access  @@allow('all', auth() == owner)}model Todo {  ...  ownerId Int @default(auth().id)  // owner and list owner has full access  @@allow('all', auth() == owner || auth() == list.owner)}\n```\n\nRerun generation and start REPL:\n\n```\nnpx zenstack generatenpx zenstack repl\n```\n\nSetting Current User\n\nThe REPL provides a \".auth\" command for setting the current user. The user object passed to the command will serve value for the `auth()` function in policy rules at runtime. Run \".auth\" without arguments to switch back to the anonymous user.\n\nSwitch to user#1 and make a query:\n\n```\n.auth { id: 1 }db.user.findMany();\n```\n\n```\n[  {    id: 1,    createdAt: 2023-11-07T21:37:22.506Z,    updatedAt: 2023-11-07T21:37:22.506Z,    email: 'joey@zenstack.dev',    name: 'Joey'  }]\n```\n\nSwitch to user#2 and observe the difference:\n\n```\n.auth { id: 2 }db.user.findMany();\n```\n\n```\n[  {    id: 2,    createdAt: 2023-11-07T21:37:22.509Z,    updatedAt: 2023-11-07T21:37:22.509Z,    email: 'rachel@zenstack.dev',    name: 'Rachel'  }]\n```\n\nWe can also create Todo List now:\n\n```\ndb.list.create({ data: { title: 'Grocery', space: { connect: { slug: 'central-perk' } } } })\n```\n\n```\n{  id: 1,  createdAt: 2023-11-08T04:38:53.385Z,  updatedAt: 2023-11-08T04:38:53.385Z,  spaceId: 1,  ownerId: 2,  title: 'Grocery',  private: false}\n```\n\ntip\n\nNotice that we don't need to connect the `owner` relation when creating? The `@default(auth().id)` attribute takes care of it.\n\nHowever, as user Rachel, we can't create a Todo List on behalf of Joey because it violates the `@@allow('all', auth() == owner)` rule:\n\n```\ndb.list.create({ data: { title: 'Grocery', owner: { connect: { email: 'joey@zenstack.dev' } }, space: { connect: { slug: 'central-perk' } } } })\n```\n\n```\ndenied by policy: list entities failed 'create' check, entity { id: 2 } failed policy checkCode: P2004Meta: { reason: 'ACCESS_POLICY_VIOLATION' }\n```\n\n* * *\n\nAllowing only the owners to read and write their own data is a good start, but we would like to let users in the same `Space` to collaborate on the Todo lists and items in the space. Achieving this requires traversing relations in policy rules, which we'll cover in the next chapter.",
  "title": "Accessing Current User | ZenStack",
  "description": "In most cases, whether a CRUD operation is allowed depends on the current user. ZenStack provides a special function auth() to access the current user in policy rules.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/",
  "markdown": "# Part I: Supercharged ORM | ZenStack\n\nVersion: 2.x\n\nWelcome to the first part of _ZenStack: The Complete Guide_!\n\nAs the creators of ZenStack, we love Prisma and enjoy its excellent developer experience. And we want to achieve more with it! The most fundamental thing that ZenStack does is turning Prisma into a more powerful database tool and a lot more than an ORM:\n\n*   Access policies\n*   Data validation\n*   Custom attributes and functions\n*   Multi-file schema\n*   Model inheritance\n*   Polymorphic relations\n*   ...\n\nEssentially, your schema becomes the single source of truth of data and rules, and at runtime, your database client not only handles CRUD operations but also does it in a secure way.\n\nIn this part of the guide, you'll learn all the concepts of using ZenStack as a drop-in replacement for Prisma in backend development. Let's get started.\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Part I: Supercharged ORM | ZenStack",
  "description": "Welcome to the first part of ZenStack: The Complete Guide!",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/plugins/tanstack-query",
  "markdown": "# @zenstackhq/tanstack-query | ZenStack\n\ninfo\n\nIf you're looking for generating hooks for [SWR](https://swr.vercel.app/), please checkout the [`@zenstackhq/swr`](https://zenstack.dev/docs/reference/plugins/swr) plugin.\n\nThe `@zenstackhq/tanstack-query` plugin generates [Tanstack Query](https://tanstack.com/query/latest) hooks that call into the CRUD services provided by the [server adapters](https://zenstack.dev/docs/category/server-adapters). The plugin currently supports React and Svelte. Vue support is coming soon.\n\nThe hooks syntactically mirror the APIs of a standard Prisma client, including the function names and shapes of parameters (hooks directly use types generated by Prisma).\n\nTo use the generated hooks, you need to install \"tanstack-query\" for the target framework with version 4.0.0 or above.\n\n### Installation[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#installation \"Direct link to Installation\")\n\n```\nnpm install --save-dev @zenstackhq/tanstack-query\n```\n\n### Options[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#options \"Direct link to Options\")\n\n| Name | Type | Description | Required | Default |\n| --- | --- | --- | --- | --- |\n| output | String | Output directory (relative to the path of ZModel) | Yes |     |\n| target | String | Target framework to generate for. Choose from \"react\", \"vue\", and \"svelte\". | Yes |     |\n| version | String | Version of TanStack Query to generate for. Choose from \"v4\" and \"v5\". | No  | v5  |\n\n### Hooks Signature[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#hooks-signature \"Direct link to Hooks Signature\")\n\nThe generated hooks have the following signature convention.\n\n*   **Query Hooks**\n    \n    ```\n    function use[Operation][Model](args?, options?);\n    ```\n    \n    *   `[Operation]`: query operation. E.g., \"FindMany\", \"FindUnique\", \"Count\".\n    *   `[Model]`: the name of the model. E.g., \"Post\".\n    *   `args`: Prisma query args. E.g., `{ where: { published: true } }`.\n    *   `options`: tanstack-query options.\n    \n    The `data` field returned by the hooks call contains the Prisma query result.\n    \n*   **Mutation Hooks**\n    \n    ```\n    function use[Operation][Model](options?);\n    ```\n    \n    *   `[Operation]`: mutation operation. E.g., \"Create\", \"UpdateMany\".\n    *   `[Model]`: the name of the model. E.g., \"Post\".\n    *   `options`: TanStack-Query options.\n    \n    The `mutate` and `mutateAsync` functions returned with the hooks call take the corresponding Prisma mutation args as input. E.q., `{ data: { title: 'Post1' } }`.\n    \n\n### Context Provider[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#context-provider \"Direct link to Context Provider\")\n\nThe generated hooks allow you to control their behavior by setting up context. The following options are available on the context:\n\n*   endpoint\n    \n    The endpoint to use for the queries. Defaults to \"/api/model\".\n    \n*   fetch\n    \n    A custom `fetch` function to use for the queries. Defaults to using [cross-fetch](https://github.com/lquixada/cross-fetch).\n    \n\nExample for using the context provider:\n\n*   React\n*   Vue\n*   Svelte\n\n\\_app.tsx\n\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';import { Provider as ZenStackHooksProvider } from '../lib/hooks';import type { FetchFn } from '@zenstackhq/tanstack-query/runtime';// custom fetch function that adds a custom headerconst myFetch: FetchFn = (url, options) => {    options = options ?? {};    options.headers = {        ...options.headers,        'x-my-custom-header': 'hello world',    };    return fetch(url, options);};const queryClient = new QueryClient();function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {    return (        <QueryClientProvider client={queryClient}>            <ZenStackHooksProvider value={{ endpoint: '/api/model', fetch: myFetch }}>                <AppContent />            </ZenStackHooksProvider>        </QueryClientProvider>    );}export default MyApp;\n```\n\n### Example[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#example \"Direct link to Example\")\n\nHere's a quick example with a ReactJs blogging app. You can find a fully functional Todo app example [here](https://github.com/zenstackhq/sample-todo-nextjs-tanstack).\n\n#### Schema[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#schema \"Direct link to Schema\")\n\n/schema.zmodel\n\n```\nplugin hooks {  provider = '@zenstackhq/tanstack-query'  output = \"./src/lib/hooks\"  target = \"react\"}model User {  id            String    @id @default(cuid())  email         String  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)}model Post {  id        String @id @default(cuid())  title     String  published Boolean @default(false)  author    User @relation(fields: [authorId], references: [id])  authorId  String  // author has full access  @@allow('all', auth() == author)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\n#### App Setup[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#app-setup \"Direct link to App Setup\")\n\n*   React\n*   Vue\n*   Svelte\n\n\\_app.tsx\n\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';import { Provider as ZenStackHooksProvider } from '../lib/hooks';const queryClient = new QueryClient();function App({ Component, pageProps: { session, ...pageProps } }: AppProps) {    return (        <QueryClientProvider client={queryClient}>            <ZenStackHooksProvider value={{ endpoint: '/api/model' }}>                <AppContent />            </ZenStackHooksProvider>        </QueryClientProvider>    );}\n```\n\n#### Using Query and Mutation Hooks[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#using-query-and-mutation-hooks \"Direct link to Using Query and Mutation Hooks\")\n\n*   React\n*   Vue\n*   Svelte\n\n/src/components/Posts.tsx\n\n```\nimport { useFindManyPost, useCreatePost } from '../lib/hooks';// post list componentconst Posts = ({ userId }: { userId: string }) => {    const create = useCreatePost();    // list all posts that're visible to the current user, together with their authors    const { data: posts } = useFindManyPost({        include: { author: true },        orderBy: { createdAt: 'desc' },    });    async function onCreatePost() {        create.mutate({            data: {                title: 'My awesome post',                authorId: userId,            },        });    }    return (        <>            <button onClick={onCreatePost}>Create</button>            <ul>                {posts?.map((post) => (                    <li key={post.id}>                        {post.title} by {post.author.email}                    </li>                ))}            </ul>        </>    );};\n```\n\n### Automatic Optimistic Update[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#automatic-optimistic-update \"Direct link to Automatic Optimistic Update\")\n\nOptimistic update is a technique that allows you to update the data cache immediately when a mutation executes while waiting for the server response. It helps achieve a more responsive UI. TanStack Query provides the [infrastructure for implementing it](https://tanstack.com/query/v5/docs/react/guides/optimistic-updates).\n\nThe ZenStack-generated mutation hooks allow you to opt-in to \"automatic optimistic update\" by passing the `optimisticUpdate` option when calling the hook. When the mutation executes, it analyzes the current queries in the cache and tries to find the ones that need to be updated. When the mutation settles (either succeeded or failed), the queries are invalidated to trigger a re-fetch.\n\nHere's an example:\n\n```\nconst { mutate: create } = useCreatePost({ optimisticUpdate: true });function onCreatePost() {    create({ ... })}\n```\n\nWhen `mutate` executes, if there are active queries like `useFindManyPost()`, the data of the mutation call will be optimistically inserted into the head of the query result.\n\n#### Details of the optimistic behavior[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#details-of-the-optimistic-behavior \"Direct link to Details of the optimistic behavior\")\n\n*   `create` mutation inserts item to the head of the query results of the corresponding `useFindMany` queries.\n*   `update` mutation updates the item in the query results of `useFindXXX` queries and their nested reads by matching the item's ID.\n*   `delete` mutation removes the item from the query results of the corresponding `useFindMany` queries and sets `null` to `useFindUnique` and `useFindFirst` query results, by matching the item's ID.\n\n#### Limitations[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#limitations \"Direct link to Limitations\")\n\n*   The automatic optimistic update relies on ID matching. It only works for queries that select the ID field(s).\n*   Non-entity-fetching queries like `count`, `aggregate`, and `groupBy` are not affected.\n*   Infinite queries are not affected.\n*   It doesn't respect filter conditions or access policies that potentially affect the queries under update. For example, for query `useFindManyPost({ where: { published: true }})`, when a non-published `Post` is created, it'll still be inserted into the query result.\n\n#### Opt-out[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#opt-out \"Direct link to Opt-out\")\n\nBy default, all queries opt into automatic optimistic update. You can opt-out on a per-query basis by passing `false` to the `optimisticUpdate` option.\n\n```\nconst { data } = useFindManyPost({ where: { published: true } }, { optimisticUpdate: false });\n```\n\nWhen a query opts out, it won't be updated by a mutation, even if the mutation is set to update optimistically.\n\n### Fine-Grained Optimistic Update[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#fine-grained-optimistic-update \"Direct link to Fine-Grained Optimistic Update\")\n\nAutomatic optimistic update is convenient, but there might be cases where you want to explicitly control how the update happens. You can use the `optimisticUpdateProvider` callback to fully customize how each query cache entry should be optimistically updated. When the callback is set, it takes precedence over the automatic optimistic logic.\n\n```\nuseCreatePost({  optimisticUpdateProvider: ({ queryModel, queryOperation, queryArgs, currentData, mutationArgs }) => {    return { kind: 'Update', data: ... /* computed result */ };  }});\n```\n\nThe callback is invoked for each query cache entry and receives the following arguments in a property bag:\n\n*   `queryModel`: The model of the query, e.g., `Post`.\n*   `queryOperation`: The operation of the query, e.g., `findMany`, `count`.\n*   `queryArgs`: The arguments of the query, e.g., `{ where: { published: true } }`.\n*   `currentData`: The current cache data.\n*   `mutationArgs`: The arguments of the mutation, e.g., `{ data: { title: 'My awesome post' } }`.\n\nIt should return a result object with the following fields:\n\n*   `kind`: The kind of the optimistic update.\n    *   `Update`: update the cache using the computed data\n    *   `Skip`: skip the update\n    *   `ProceedDefault`: use the default automatic optimistic behavior.\n*   `data`: The computed data to update the cache with. Only used when `kind` is `Update`.\n\n### Using Infinite Query[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#using-infinite-query \"Direct link to Using Infinite Query\")\n\n*   React\n*   Vue\n*   Svelte\n\nHere's a quick example of using infinite query to load a list of posts with infinite pagination. See [Tanstack Query documentation](https://tanstack.com/query/v4/docs/react/guides/infinite-queries) for more details.\n\n/src/components/Posts.tsx\n\n```\nimport { useInfiniteFindManyPost } from '../lib/hooks';// post list component with infinite loadingconst Posts = () => {    const PAGE_SIZE = 10;    const fetchArgs = {        include: { author: true },        orderBy: { createdAt: 'desc' as const },        take: PAGE_SIZE,    };    const { data, fetchNextPage, hasNextPage } = useInfiniteFindManyPost(fetchArgs, {        getNextPageParam: (lastPage, pages) => {            if (lastPage.length < PAGE_SIZE) {                return undefined;            }            const fetched = pages.flatMap((item) => item).length;            return {                ...fetchArgs,                skip: fetched,            };        },    });        return (        <>            <ul>                {data?.pages.map((posts, i) => (                    <React.Fragment key={i}>                        {posts?.map((post) => (                            <li key={post.id}>                                {post.title} by {post.author.email}                            </li>                        ))}                    </React.Fragment>                ))}            </ul>            {hasNextPage && (                <button onClick={() => fetchNextPage()}>                    Load more                </button>            )}        </>    );};\n```\n\n## Advanced[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#advanced \"Direct link to Advanced\")\n\n### Query Invalidation[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#query-invalidation \"Direct link to Query Invalidation\")\n\nThe mutation hooks generated by ZenStack automatically invalidates the queries that are potentially affected by the changes. For example, if you create a `Post`, the `useFindManyPost` query will be automatically invalidated when the mutation succeeds. Invalidation causes cache to be purged and fresh data to be refetched.\n\nThe automatic invalidation takes care of nested read, write, and delete cascading.\n\n**1\\. Nested Read**\n\nNested reads are also subject to automatic invalidation. For example, if you create a `Post`, the query made by\n\n```\nuseFindUniqueUser({ where: { id: userId }, include: { posts: true } });\n```\n\nwill be invalidated.\n\n**2\\. Nested Write**\n\nSimilarly, nested writes also trigger automatic invalidation. For example, if you create a `Post` in a nested update to `User` like:\n\n```\nupdateUser({ where: { id: userId }, posts: { create: { title: 'post1' } } });\n```\n\nThe mutation will cause queries like `useFindManyPost()` to be invalidated.\n\n**3\\. Delete Cascade**\n\nIn ZModel, relations can be configured to cascade delete, e.g.:\n\n```\nmodel User {    ...    posts Post[]}model Post {    ...    user User @relation(fields: [userId], references: [id], onDelete: Cascade)    userId Int}\n```\n\nWhen a `User` is deleted, the `Post` entities it owns will be deleted automatically. The generated hooks takes cascade delete into account. For example, if you delete a `User`, `Post` model will be considered as affected and queries like `useFindManyPost()` will be invalidated.\n\ninfo\n\nThe automatic invalidation is enabled by default, and you can use the `invalidateQueries` option to opt-out and handle revalidation by yourself.\n\n```\nuseCreatePost({ invalidateQueries: false });\n```\n\n### Query Key[‚Äã](https://zenstack.dev/docs/reference/plugins/tanstack-query#query-key \"Direct link to Query Key\")\n\nQuery keys serve as unique identifiers for organizing the query cache. The generated hooks use the following query key scheme:\n\n```\n['zenstack', model, operation, args, flags]\n```\n\nFor example, the query key for\n\n```\nuseFindUniqueUser({ where: { id: '1' } })\n```\n\nwill be:\n\n```\n['zenstack', 'User', 'findUnique', { where: { id: '1' } }, { infinite: false }]\n```\n\nYou can use the generated `getQueryKey` function to compute it.",
  "title": "@zenstackhq/tanstack-query | ZenStack",
  "description": "Plugin for generating Tanstack Query query and mutation hooks",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part2/",
  "markdown": "# Part II: Plugin System | ZenStack\n\nIf you're experienced with Prisma, you've probably used some generators, like [prisma-erd-generator](https://github.com/keonik/prisma-erd-generator) and [typegraphql-prisma](https://github.com/MichalLytek/typegraphql-prisma). ZenStack's plugins share similarities with Prisma generators but also differ in several ways:\n\n*   Ease of programming\n    \n    Prisma's generator API uses the internal [DMMF format](https://github.com/prisma/prisma/blob/main/ARCHITECTURE.md#the-dmmf-or-data-model-meta-format) that's undocumented and not very friendly to work with. ZenStack's plugin API uses the ZModel AST, which is much more intuitive. The ZenStack plugin still receives a DMMF object as input in case you need it.\n    \n*   Extending the schema language\n    \n    Prisma's schema language is not open to extension, and the community has been using the [triple slash hack](https://zenstack.dev/docs/guides/existing-prisma#prisma-generators-triple-slash-hack) to inject custom attributes. ZenStack allows plugins to introduce custom attributes and functions directly and type-check their usage at generation time.\n    \n\nPlugins and generators are not mutually exclusive. ZenStack fully supports Prisma generators, and you can use them alongside plugins.",
  "title": "Part II: Plugin System | ZenStack",
  "description": "Welcome to the second part of ZenStack: The Complete Guide!",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/server-adapters/sveltekit",
  "markdown": "# SvelteKit | ZenStack\n\n```\n// create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n```\n\n```\n{    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n```",
  "title": "SvelteKit | ZenStack",
  "description": "Adapter for integrating with SvelteKit",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part4/",
  "markdown": "# Part IV: Frontend Data Query\n\nVersion: 2.x\n\nIn previous parts of this guide, we have learned how ZenStack turns Prisma into a data access layer with access control and how, based on that, we can automatically serve secure CRUD APIs.\n\nConsuming a CRUD API is straightforward, but it's a tedious and error-prone job if you do it manually. In this part, we'll see how ZenStack can help us generate frontend data query libraries (aka hooks) that make it effortless to consume the APIs from the frontend. We'll also continue evolving our Todo project into a full-fledged application.\n\nLet's roll on!\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Part IV: Frontend Data Query | ZenStack",
  "description": "In previous parts of this guide, we have learned how ZenStack turns Prisma into a data access layer with access control and how, based on that, we can automatically serve secure CRUD APIs.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/epilogue",
  "markdown": "# Epilogue | ZenStack\n\nüéâ Congratulations on completing the guide! We hope you've enjoyed the journey and got ready to build your own ZenStack-powered application.\n\n### Let The Schema Drive Your App[‚Äã](https://zenstack.dev/docs/the-complete-guide/epilogue#let-the-schema-drive-your-app \"Direct link to Let The Schema Drive Your App\")\n\nOur final version of the Todo app consists of roughly 500 lines of manually written code. That's quite a small codebase for a fully functional application!\n\nZenStack takes a schema-first approach to model your application. It originated from the Prisma ORM, evolved its schema for extensibility, added access control, introduced a plugin system, and served automatic CRUD APIs. Although it has been a long way, the schema has always been the core. The key is to boil down the application's essential business logic into a concise representation and then automate as many things as possible with it, so you can write less boilerplate code and focus on creating real values.\n\nAs its name suggests, we want the project to help bring simplicity, tranquility, and mindfulness back to software development.\n\n![](https://zenstack.dev/img/the-complete-guide/zen-coder.png)\n\n### What's Next[‚Äã](https://zenstack.dev/docs/the-complete-guide/epilogue#whats-next \"Direct link to What's Next\")\n\n*   The [Quick Start](https://zenstack.dev/docs/category/quick-start) documents guide you through creating a simple app using ZenStack with various frameworks. They are fast-paced and can get you up running in minutes.\n*   The [Recipes](https://zenstack.dev/docs/category/recipes) include guides for achieving specific tasks. For example, you may want to learn how to [deploy to production](https://zenstack.dev/docs/guides/deploy).\n*   The best way to get support or send feedback is to join our [Discord server](https://discord.gg/Ykhr738dUe). The community is responsive and helpful.\n*   But you're also welcome to create issues and feature requests directly on [GitHub](https://github.com/zenstackhq/zenstack).\n*   Finally, don't forget to [‚≠êÔ∏èStar Us‚≠êÔ∏è](https://github.com/zenstackhq/zenstack). We appreciate it!",
  "title": "Epilogue | ZenStack",
  "description": "Epilogue",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/dev-workflow",
  "markdown": "# Development Workflow | ZenStack\n\nVersion: 2.x\n\nThe development workflow using ZenStack is very close to Prisma. The main difference is, instead of modifying `schema.prisma` file, you edit `schema.zmodel` to make changes to data models and policies and then use `zenstack generate` command to generate Prisma schema. After that, everything is just standard Prisma workflow, including generating and deploying migrations.\n\nThe following diagram illustrates a typical workflow for prototyping data model changes during feature development:\n\n![Feature Prototyping Workflow](https://zenstack.dev/img/dev-workflow-light.png)![Feature Prototyping Workflow](https://zenstack.dev/img/dev-workflow-dark.png)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Development Workflow | ZenStack",
  "description": "Development Workflow",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/supabase-security",
  "markdown": "# Ensuring Security When Integrating Supabase with ZenStack\n\nIntegrating Supabase with ZenStack can be a great choice as Supabase provides authentication as well as database hosting and file uploads.\n\nHowever, it is essential to take some precautions when using ZenStack with Supabase to ensure that the ZenStack authorization layer cannot be bypassed via requests to the Supabase API url.\n\nThis article will help you to understand the risk, how to test if your database is exposed, and how to prevent it.\n\n## 1\\. Understanding the Risk[‚Äã](https://zenstack.dev/docs/guides/supabase-security#1--understanding-the-risk \"Direct link to 1.  Understanding the Risk\")\n\nSupabase allows anonymous requests to the Supabase rest API access the database by default, assuming Row Level Security (RLS) is in place.\n\nZenStack's authorization can effectively serve as an in-application security layer, but **direct HTTP requests to your Supabase API could still leave your database exposed.**\n\nThis poses a potential risk because Supabase API URL and anon key are both public and can easily be found eg by inspecting the url/headers of a Supabase authentication network request.\n\n## 2\\. How to test if your database is exposed to direct Supabase API requests[‚Äã](https://zenstack.dev/docs/guides/supabase-security#2-how-to-test-if-your-database-is-exposed-to-direct-supabase-api-requests \"Direct link to 2. How to test if your database is exposed to direct Supabase API requests\")\n\nUse Bash or an API client (such as postman or VS Code thunder client) to send a HTTP request with these details:\n\n```\ncurl '{SUPABASE_PROJECT_URL}/rest/v1/{DATABASE_TABLE}?select=*' \\-H \"apikey: SUPABASE_ANON_KEY\" \\-H \"Authorization: Bearer SUPABASE_ANON_KEY\"\n```\n\nFor example:\n\n```\ncurl 'https://jypbzsozorjnogibmfhu.supabase.co/rest/v1/User?select=*' \\-H \"apikey: eyOiJIUzJhbGciI1...\" \\-H \"Authorization: Bearer eyOiJIUzJhbGciI1...\"\n```\n\nNote:\n\n*   Your Supabase project URL should look like this: `https://projectid.supabase.co`\n*   You can find both of these values inside Supabase dashboard > settings > api\n\nAs previously mentioned, all the detailed needed to make this request are public and could be accessed eg by inspecting the url/headers of a Supabase authentication network request.\n\nIf your database is secure, you should receive a permission denied error, such as:\n\n```\n{   \"code\": \"42501\",   \"details\": null,   \"hint\": null,   \"message\": \"permission denied for table User\"}\n```\n\nIf you have RLS enabled on the table, you may get a response with an empty array instead of a permission denied error. This means RLS filtering is effective, and it's preventing you from reading rows that are not granted access. However, it's still recommended to fully revoke anonymous access permissions for better security\n\n## 3\\. How to prevent direct Supabase API requests[‚Äã](https://zenstack.dev/docs/guides/supabase-security#3-how-to-prevent-direct-supabase-api-requests \"Direct link to 3. How to prevent direct Supabase API requests\")\n\n### Revoke default & current privileges[‚Äã](https://zenstack.dev/docs/guides/supabase-security#revoke-default--current-privileges \"Direct link to Revoke default & current privileges\")\n\nStart by revoking all privileges from the `anon` role to prevent unauthenticated access, and changing the defauts to ensure future objects are also protected.\n\nIn the Supabase dashboard inside the SQL Editor tab, execute the following:\n\n```\n-- Revoke current privilegesREVOKE SELECT ON ALL TABLES IN SCHEMA public FROM anon;REVOKE USAGE ON ALL SEQUENCES IN SCHEMA public FROM anon;REVOKE EXECUTE ON ALL FUNCTIONS IN SCHEMA public FROM anon;-- Revoke default privileges for future objectsALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON TABLES FROM anon;ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON FUNCTIONS FROM anon;ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON SEQUENCES FROM anon;\n```\n\nNote: If you are using Supabase cli for local development, then create a migration file with `pnpm supabase db migration new disable-anon-access` to prevent accidental rollbacks. (this creates a new local sql migration file, 'disable-anon-access' can be replaced)\n\n### Verify Role Configurations[‚Äã](https://zenstack.dev/docs/guides/supabase-security#verify-role-configurations \"Direct link to Verify Role Configurations\")\n\nIn the Supabase dashboard under the Database > Roles section, confirm the following:\n\n**Anon Role:** All permissions should be disabled. **Authenticated Role:** All permissions should be also disabled here. **Postgres Role:** Ensure it retains the ability to bypass RLS for necessary backend tasks.\n\n## Conclusion[‚Äã](https://zenstack.dev/docs/guides/supabase-security#conclusion \"Direct link to Conclusion\")\n\nBy disabling permissions for `anon` and `authenticated` roles, you prevent direct public access to your database, relying instead on your application logic and ZenStack's authorization to control access.\n\nRemember to regularly test your application security to ensure effective and appropriate access control for your application.",
  "title": "Ensuring Security When Integrating Supabase with ZenStack | ZenStack",
  "description": "Guide to securely integrating Supabase with ZenStack - how to prevent unauthorized access.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/category/integrating-with-authentication",
  "markdown": "# Integrating With Authentication | ZenStack\n\n[\n\n## üìÑÔ∏è Auth.js (NextAuth)\n\nIntegrating with Auth.js.\n\n](https://zenstack.dev/docs/guides/authentication/next-auth)",
  "title": "Integrating With Authentication | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/existing-prisma",
  "markdown": "# Migrating Existing Prisma Projects | ZenStack\n\nZenStack CLI provides an `init` command for easily converting an existing Prisma project.\n\nThe command does the following things:\n\n1.  It copies over `prisma/schema.prisma` to `/schema.zmodel`.\n    \n    If your Prisma schema is in a non-standard location, you can pass it in with the `--prisma` option.\n    \n    ```\n    npx zenstack@latest init --prisma prisma/my.schema\n    ```\n    \n2.  It installs NPM packages.\n    \n    `zenstack` package as a dev dependency and `@zenstackhq/runtime` as a regular dependency. The CLI tries to guess the package manager you use, but you can also explicitly specify one with the `--package-manager` option (supported values are `npm | pnpm | yarn`).\n    \n    ```\n    npx zenstack@latest init --package-manager pnpm\n    ```\n    \n\nIf the `init` command doesn't suit your needs, manually doing these steps is just fine. See [ZenStack CLI](https://zenstack.dev/docs/reference/cli) for more details about using the CLI.\n\n## Prisma generators' triple slash hack[‚Äã](https://zenstack.dev/docs/guides/existing-prisma#prisma-generators-triple-slash-hack \"Direct link to Prisma generators' triple slash hack\")\n\nOne major limitation of Prisma schema is the lack of support for custom attributes and functions. Generators can't directly attach specific metadata to models. The community has been using the triple-slash comment hack as a workaround.\n\nHere's an example from [TypeGraphQL Prisma](https://prisma.typegraphql.com/). The comment on the \"password\" field marks it to be omitted from both the GraphQL input and output types. The generator parses its text and acts accordingly.\n\nschema.prisma\n\n```\nmodel User {  id Int @default(autoincrement()) @id  email String  @unique  /// @TypeGraphQL.omit(output: true, input: true)  password String  posts Post[]}\n```\n\nTo make this scenario continue working, ZenStack preserves all triple-slash comments when generating the Prisma schema.\n\nThe hack works but is error-prone because comments have no protection from the compiler. Fortunately, with ZModel, you can implement it in a much nicer way, thanks to its custom attributes support:\n\nschema.zmodel\n\n```\nattribute @TypeGraphQL.omit(output: Boolean?, input: Boolean?)model User {  id Int @default(autoincrement()) @id  email String  @unique  password String @TypeGraphQL.omit(output: true, input: true)  posts Post[]}\n```\n\nNow, if you make a typo or pass in wrongly-typed expressions to the attribute, the compiler catches it for you. When ZenStack generates the Prisma schema, it translates all custom attributes back to triple-slash comments, so the original Prisma generators can continue working as before.",
  "title": "Migrating Existing Prisma Projects | ZenStack",
  "description": "Steps for migrating from existing Prisma projects.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/ide",
  "markdown": "# Installing IDE Extensions | ZenStack\n\nVersion: 2.x\n\n## VSCode[‚Äã](https://zenstack.dev/docs/guides/ide#vscode \"Direct link to VSCode\")\n\nZenStack VSCode extension provides syntax highlighting and error checking to improve the efficiency of your modeling work. It offers functionalities similar to the Prisma VSCode extension, plus support for added features like access policies.\n\n### Features[‚Äã](https://zenstack.dev/docs/guides/ide#features \"Direct link to Features\")\n\n*   Syntax highlighting\n*   Error highlighting\n*   Go to definition\n*   Auto-completion\n*   Hover documentation\n*   Formatting\n\n### Installation[‚Äã](https://zenstack.dev/docs/guides/ide#installation \"Direct link to Installation\")\n\nYou can install it by searching \"ZenStack Language Tools\" inside VSCode or directly from [here](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack).\n\n[![VSCode Screenshot](https://zenstack.dev/assets/images/vscode-screenshot-3b3552b40686a215efe0d37d13e42da9.png)](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack)\n\n## JetBrains IDEs[‚Äã](https://zenstack.dev/docs/guides/ide#jetbrains-ides \"Direct link to JetBrains IDEs\")\n\nZenStack provides a plugin for JetBrains IDEs. The extension is based on JetBrain platform's new [Language Server Protocol (LSP) support](https://blog.jetbrains.com/platform/2023/07/lsp-for-plugin-developers/). The extension only offers preliminary features today, but please expect improvements in the future as the LSP support matures.\n\ninfo\n\nJetBrain's LSP support is not available to the community edition of the IDEs, so is the ZenStack plugin.\n\n### Features[‚Äã](https://zenstack.dev/docs/guides/ide#features-1 \"Direct link to Features\")\n\n*   Syntax highlighting\n*   Error highlighting\n*   Go to definition\n*   Auto-completion (partial)\n*   Formatting\n\n### Installation[‚Äã](https://zenstack.dev/docs/guides/ide#installation-1 \"Direct link to Installation\")\n\nYou can install it by searching \"ZenStack Language Tools\" inside JetBrain IDE's plugins marketplace or directly from [here](https://plugins.jetbrains.com/plugin/23397-zenstack-language-tools).\n\n[![JetBrains Screenshot](https://zenstack.dev/assets/images/jetbrains-screenshot-dbb8270a9e0cab19d15c40f6326bd107.png)](https://plugins.jetbrains.com/plugin/17210-zenstack-language-tools)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Installing IDE Extensions | ZenStack",
  "description": "IDE extensions",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/multiple-schema",
  "markdown": "# Multiple Schema Files and Model Inheritance\n\nAs your business expands, your schema file grows with it. ZenStack offers increased flexibility in managing your schema file through multiple schema files and model inheritance. An example project is provided below for your reference:\n\n[https://github.com/zenstackhq/sample-multiple-schema](https://github.com/zenstackhq/sample-multiple-schema)\n\n## Abstract Model Inheritance[‚Äã](https://zenstack.dev/docs/guides/multiple-schema#abstract-model-inheritance \"Direct link to Abstract Model Inheritance\")\n\nYou can use abstract model to include common fields that would be shared by multiple models. By extending abstract model, you can keep your schema DRY(Don‚Äôt repeat yourself). The abstract model can contain both fields and attributes like a normal model, but it is erased after generation and does not appear in the generated Prisma schema file.\n\nYou can have your model defined as:\n\n```\nabstract model Base {    id Int @id @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    //Logged-in users can view    @@allow('read', auth() != null)}model Post extends Base{    title String    content String?    viewCount Int @default(0)}model ToDo extends Base{    title String    completed Boolean @default(false)}\n```\n\nThe generated `schema.prisma` file would be:\n\n```\n/// @@allow('all', auth() != null && published)model User {    name String    id Int @id() @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)}/// @@allow('all', auth() != null && published)model Post {    title String    content String?    viewCount Int @default(0)    comment Comment[]    id Int @id() @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)}/// @@allow('all', auth() != null && published)model Comment {    content String    post Post @relation(fields: [postId], references: [id])    postId Int    id Int @id() @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)}\n```\n\n## Multiple Schema Files[‚Äã](https://zenstack.dev/docs/guides/multiple-schema#multiple-schema-files \"Direct link to Multiple Schema Files\")\n\nYou can split your schema file into multiple files and use `import` statements to include the file you needed. When running `zenstack generate`, it recursively traverses all the imported models and combine them into a single model. For instance, you can split the above schema file into two files below:\n\n*   base.zmodel\n    \n    ```\n    abstract model Base {    id Int @id @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)    // author has full access    @@allow('all', auth() != null && published)}\n    ```\n    \n*   schema.zmodel\n    \n    ```\n    import \"base\"model User extends Base {    name String}model Post extends Base {    title String    content String?    viewCount Int @default(0)    comment Comment[]}model Comment extends Base {    content String    post Post @relation(fields: [postId], references: [id])    postId Int}\n    ```\n    \n\nYou can also import schema files from NPM packages by prefixing the import path with a package name (with or without organization scope). See [the docs](https://zenstack.dev/docs/reference/zmodel-language#import) for more details. ZenStack user [TGTGamer](https://github.com/TGTGamer) made [this cool project](https://github.com/Eventiva/Eventiva) demonstrating a component-based organization of a complex schema.",
  "title": "Multiple Schema Files and Model Inheritance | ZenStack",
  "description": "ZenStack offers increased flexibility in managing your schema file through multiple schema files and model inheritance.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/",
  "markdown": "# Part III: Automatic CRUD API\n\nIn Part I, we learned how ZenStack extended Prisma ORM on the schema and runtime levels. By making these extensions, ZenStack unleashed many new potentials of the ORM and turned it into a data access layer that enforces access control and additional data integrity.\n\nOne interesting side effect of this extension is that we can automatically derive CRUD APIs from the schema. The data models tell us how the input/output of the APIs should look like, and the enhanced Prisma Client ensures that the APIs are secure.\n\nIn this part of the guide, we'll learn how such automatic APIs work - the general architecture, the different flavors of APIs, and how they integrate into the framework of your choice.\n\nWe'll also continue evolving our Todo project into a fully functional backend service. If you're unfamiliar with the project, please first revisit the [Sample Project](https://zenstack.dev/docs/the-complete-guide/#sample-project) part. You can use the \"part2\" branch of [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/part2) repo as a starting point, and clone it and check out to that branch with the following command:\n\n```\ngit clone --branch part2 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```\n\nLet's get started.",
  "title": "Part III: Automatic CRUD API | ZenStack",
  "description": "In Part I, we learned how ZenStack extended Prisma ORM on the schema and runtime levels. By making these extensions, ZenStack unleashed many new potentials of the ORM and turned it into a data access layer that enforces access control and additional data integrity.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/trpc",
  "markdown": "# Using With tRPC | ZenStack\n\n[tRPC](https://trpc.io/) is a fantastic library that magically turns server-side procedures into client-callable functions without requiring you to provide any formal contract. The popular [T3 stack](https://create.t3.gg/) promotes the combo of Prisma + tRPC for achieving type safety from your frontend all the way down to the database.\n\nZenStack makes things even easier by automatically generating tRPC routers from the ZModel schema. You can use the generated routers together with an enhanced Prisma client; since the Prisma client has the ability to enforce access policies, there is no need to implement authorization code anymore.\n\n## Details[‚Äã](https://zenstack.dev/docs/guides/trpc#details \"Direct link to Details\")\n\n### 1\\. Initializing the project[‚Äã](https://zenstack.dev/docs/guides/trpc#1-initializing-the-project \"Direct link to 1. Initializing the project\")\n\nIf you haven't initialized your tRPC project with ZenStack, run the following command to do it:\n\ninfo\n\nThe \"init\" command does the following things for you:\n\n1.  Install Prisma if it's not already installed.\n2.  Install the `zenstack` CLI package as a dev dependency.\n3.  Install the `@zenstackhq/runtime` package - used for enhancing `PrismaClient` at the runtime.\n4.  Copy the `prisma/schema.prisma` file to `schema.zmodel` if it exists; otherwise, create a new template `schema.zmodel` file.\n\nYou can always manually complete the steps above if you have a special project setup that the \"init\" command doesn't work with.\n\nAfter the initialization, please remember that you should edit the `schema.zmodel` moving forward. The `prisma/schema.prisma` file will be automatically regenerated when you run `zenstack generate`.\n\n### 2\\. Installing the tRPC plugin[‚Äã](https://zenstack.dev/docs/guides/trpc#2-installing-the-trpc-plugin \"Direct link to 2. Installing the tRPC plugin\")\n\nYou can enable tRPC router generation with the `@zenstackhq/trpc` plugin.\n\nFirst install the trpc package:\n\n```\nnpm install -D @zenstackhq/trpc@latest\n```\n\n/schema.zmodel\n\n```\nplugin trpc {    provider = '@zenstackhq/trpc'    output = 'src/server/routers/generated'}\n```\n\n### 3\\. Setting up the tRPC context[‚Äã](https://zenstack.dev/docs/guides/trpc#3-setting-up-the-trpc-context \"Direct link to 3. Setting up the tRPC context\")\n\nUsually in your tRPC project, you have a function to create a tRPC context. You need to make sure the context contains a `prisma` field that is an instance of Prisma client. The generated tRPC routers use that to talk to the database.\n\nFor most of the cases you should use a Prisma client that's \"enhanced\" by ZenStack so that the CRUD operations are guarded by the access policies defined in the ZModel schema. Here's a quick example with Next.js:\n\n/src/server/context.ts\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { prisma } from './db';import { getSessionUser } from './auth';export const createContext = async ({ req, res }: CreateNextContextOptions) => {    return {        ...,        // use access-control-enabled Prisma client        prisma: await enhance(prisma, { user: getSessionUser(req, res) }),    };};\n```\n\n### 4\\. Using the generated routers[‚Äã](https://zenstack.dev/docs/guides/trpc#4-using-the-generated-routers \"Direct link to 4. Using the generated routers\")\n\nNow run the `zenstack` CLI to generate artifacts:\n\nYou should find a bunch of tRPC routers generated in the output folder, one per each data model. A `createRouter` helper function is also generated, which returns a router instance for all models. You can use it as your top-level tRPC router, or merge it with other routers to form a more complex setup.\n\n/src/server/routers/\\_app.ts\n\n```\nimport { createRouter } from './generated/routers';const t = initTRPC.context<Context>().create();export const appRouter = createRouter(t.router, t.procedure);export type AppRouter = typeof appRouter;\n```\n\n_NOTE_: The ZenStack trpc plugin is based on the awesome work by [Omar Dulaimi](https://github.com/omar-dulaimi/prisma-trpc-generator).\n\n* * *\n\nPlease refer to the [@zenstackhq/trpc](https://zenstack.dev/docs/reference/plugins/trpc) plugin documentation for more details.",
  "title": "Using With tRPC | ZenStack",
  "description": "Guide for using ZenStack with tRPC.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/deploy",
  "markdown": "# Deploying to Production | ZenStack\n\nVersion: 2.x\n\nAfter the hard work of building your application, nothing is more exciting than deploying it to production. This guide explains how ZenStack participates in the deployment process.\n\n### Running ZenStack CLI During Deployment[‚Äã](https://zenstack.dev/docs/guides/deploy#running-zenstack-cli-during-deployment \"Direct link to Running ZenStack CLI During Deployment\")\n\nIf you use a framework that requires a build step, for example, \"next build\" for Next.js, you can run `zenstack generate` as the very first step in the build process. It ensures the `schema.prisma` file is up-to-date, and the supporting modules are generated into the `node_modules/.zenstack` directory.\n\nHere's what the build script of our sample Todo app looks like for deploying to Vercel:\n\npackage.json\n\n```\n{  \"scripts\": {    \"vercel-build\": \"zenstack generate && next build && prisma migrate deploy\"  }}\n```\n\n### Not Using ZenStack CLI During Deployment[‚Äã](https://zenstack.dev/docs/guides/deploy#not-using-zenstack-cli-during-deployment \"Direct link to Not Using ZenStack CLI During Deployment\")\n\nThere might be cases where you don't want to run the `zenstack` CLI during the deployment process. For example, you may want to avoid installing dev dependencies during the build to keep a clean \"node\\_modules\" folder. In such cases, you can run `zenstack generate` with a `--output` option to generate the supporting modules into your source tree and then commit them to your repository.\n\n```\nnpx zenstack generate --output ./zenstack\n```\n\nThen, instead of importing the `enhance` API from `@zenstackhq/runtime`, import it directly from the output location:\n\n```\nimport { enhance } from './zenstack/enhance';\n```\n\nIn this way, all information ZenStack needs at runtime is already in the source tree, and you don't need to run `zenstack generate` during deployment.\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Deploying to Production | ZenStack",
  "description": "After the hard work of building your application, nothing is more exciting than deploying it to production. This guide explains how ZenStack participates in the deployment process.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/debugging",
  "markdown": "# Debugging and Troubleshooting | ZenStack\n\nVersion: 2.x\n\nZenStack's access policies are powerful, but when the rules get complex, it can be challenging to reason why an operation is being allowed or denied. This guide lists some techniques for debugging and troubleshooting.\n\n### Enable Debug Logging[‚Äã](https://zenstack.dev/docs/guides/debugging#enable-debug-logging \"Direct link to Enable Debug Logging\")\n\nZenStack enforces access policies by injecting into Prisma queries, so a straightforward way to see what's going on is to enable logging of such queries. You can achieve it with two steps:\n\n1.  When calling `enhance()` to create an enhanced PrismaClient, pass in a `logPrismaQueries` option set to `true`:\n    \n    ```\n    const db = enhance(prisma, { user }, { logPrismaQuery: true })\n    ```\n    \n2.  Enable \"info\" level logging on PrismaClient\n    \n    The queries will be logged into PrismaClient's logger with the \"info\" level, so you need to ensure that level is turned on when creating the PrismaClient instance.\n    \n    ```\n    const prisma = new PrismaClient({ log: ['info'] });\n    ```\n    \n\nWhen these are set up, you should be able to see all Prisma queries ZenStack makes in the console like the following:\n\n```\nprisma:info [policy] `findMany` list:{  where: {    AND: [      { NOT: { OR: [] } },      {        OR: [          { owner: { is: { id: 1 } } },          {            AND: [              {                space: {                  members: {                    some: { user: { is: { id: 1 } } }                  }                }              },              { NOT: { private: true } }            ]          }        ]      }    ]  }}\n```\n\n### Try Things Out In REPL[‚Äã](https://zenstack.dev/docs/guides/debugging#try-things-out-in-repl \"Direct link to Try Things Out In REPL\")\n\nThe `zenstack` CLI provides a REPL environment for you to execute queries with the regular or enhanced PrismaClient interactively. You can quickly switch between different user contexts and see how the access policies affect the result.\n\nPlease find more details about the REPL in the [CLI reference](https://zenstack.dev/docs/reference/cli#repl).\n\n* * *\n\nIn the future, we may devise more advanced debugging tools that help you break down complex rules and pinpoint the one that causes an operation to be allowed or denied. Please stay tuned!\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Debugging and Troubleshooting | ZenStack",
  "description": "ZenStack's access policies are powerful, but when the rules get complex, it can be challenging to reason why an operation is being allowed or denied. This guide lists some techniques for debugging and troubleshooting.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/polymorphism",
  "markdown": "# Polymorphic Relations | ZenStack\n\n## Introduction[‚Äã](https://zenstack.dev/docs/guides/polymorphism#introduction \"Direct link to Introduction\")\n\nModeling relations in Prisma is straightforward: you define fields referencing the model of the other side of the relation, and associate them with the `@relation` attribute, e.g.:\n\n```\nmodel User {  id Int @id @default(autoincrement())  posts Post[]}model Post {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title String  owner User @relation(fields: [ownerId], references: [id])  ownerId Int}\n```\n\nHowever, if the `User` model has relations with many models, it'll need to declare relation field (like the `posts` field above) for each of them. It's a very common pattern in applications where a model type is polymorphically related to many other types of models. For example, a user can own posts, videos, comments, etc. In such cases, the schema will look like this:\n\n```\nmodel User {  ...  posts Post[]  videos Video[]  ...}model Post {  ...  title String}model Video {  ...  duration Int}\n```\n\nThe way how it's modeled in Prisma is awkward for several reasons:\n\n1.  The `User` model needs to be updated every time a new polymorphic model is added.\n2.  There's no way to query the polymorphic models uniformly with sorting and pagination.\n3.  You can't easily model access policies consistently across the polymorphic models.\n\nThere are several Prisma issues related to this missing feature:\n\n*   [Support for a Union type](https://github.com/prisma/prisma/issues/2505)\n*   [Support for Polymorphic Associations](https://github.com/prisma/prisma/issues/1644)\n\n## ZenStack Implementation[‚Äã](https://zenstack.dev/docs/guides/polymorphism#zenstack-implementation \"Direct link to ZenStack Implementation\")\n\nOne of the main things ZenStack does is to \"enhance\" `PrismaClient`. So it's natural to support polymorphism as an enhancement. There are several strategies to implement polymorphism in the database as summarized in [this blog post](https://zenstack.dev/blog/polymorphism). ZenStack chooses to take the \"delegated types\" design, which has a good balance between flexibility and efficiency.\n\n### Usage[‚Äã](https://zenstack.dev/docs/guides/polymorphism#usage \"Direct link to Usage\")\n\n#### Modeling[‚Äã](https://zenstack.dev/docs/guides/polymorphism#modeling \"Direct link to Modeling\")\n\nTo define a polymorphic hierarchy, you first define a base model, and them inherit from it. The base model should be marked with the `@@delegate` attribute. The attribute requires a parameter referencing a discriminator field - used for storing the concrete model type it delegates. Here's an example:\n\n```\nmodel User {  id Int @id @default(autoincrement())  contents Content[]}model Content {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  published Boolean @default(false)  owner User @relation(fields: [ownerId], references: [id])  ownerId Int  contentType String  @@delegate(contentType)}model Post extends Content {  title String}model Video extends Content {  name String  duration Int}\n```\n\nDifference from abstract inheritance\n\nZenStack v1 already supports [inheriting from abstract models](https://zenstack.dev/docs/guides/multiple-schema#abstract-model-inheritance). Abstract inheritance merely copies over the fields and attributes from the base model to the child. It doesn't really provide a polymorphic hierarchy.\n\nDiscriminator field\n\nWhen a concrete model entity is created, the discriminator field will be automatically set to the model name. You can also use en enum for the discriminator field, and in that case, the enum fields must match the concrete model names.\n\n```\nenum ContentType {  Post  Video}model Content {  ...  @@delegate(contentType)}\n```\n\n#### Querying[‚Äã](https://zenstack.dev/docs/guides/polymorphism#querying \"Direct link to Querying\")\n\nTo use polymorphic relations, you should create an enhanced `PrismaClient` with the \"delegate\" enhancement kind enabled - either by a simple `enhance` call with all kinds enabled:\n\n```\nconst db = enhance(prisma, { user });\n```\n\n, or by explicitly specifying the \"delegate\" kind:\n\n```\nconst db = enhance(prisma, { user }, { kinds: ['delegate'] });\n```\n\nYou can then work with the inheritance hierarchy pretty much like how you deal with polymorphism in OOP:\n\n```\n// create a userconst user = await db.user.create({ data: { id: 1 } });// create a concrete `Post` modelconst post = await db.post.create({  data: {    owner: { connect: { id: user.id } },     title: 'Post1'   },});// create a concrete `Video` modelconst video = await db.video.create({  data: {    owner: { connect: { id: user.id } },    name: 'Video1',    duration: 100,  }});// query with concrete model, will return fields from both base and concrete models// [ //   { id: 1, ownerId: 1, contentType: 'Post', title: 'Post1', published: false, createdAt: ..., updatedAt: ... },//   { id: 2, ownerId: 1, contentType: 'Video', name: 'Video1', duration: 100, published: false, createdAt: ..., updatedAt: ... }// ]console.log('All posts:', inspect(await db.post.findMany()));// query with base model, will also return fields from both base and concrete models, but with base's typing// [ //   { id: 1, ownerId: 1, contentType: 'Post', title: 'Post1', published: false, createdAt: ..., updatedAt: ... },//   { id: 2, ownerId: 1, contentType: 'Video', name: 'Video1', duration: 100, published: false, createdAt: ..., updatedAt: ... }// ]console.log('All contents:', inspect(await db.content.findMany()));// you can use the discriminator field to help TypeScript narrow down the typingconst firstContent = await db.content.findFirstOrThrow();if (firstContent.contentType === 'Post') {  console.log('Post title:', firstContent.title);} else {  console.log('Video name:', firstContent.name);}// set all contents as published from the userawait db.user.update({  where: { id: user.id },  data: {    contents: {       updateMany: { where: {}, data: { published: true } }     },  },});// delete with base modelawait db.content.deleteMany();// querying with concrete model again will get an empty array // because of the cascaded deletionconsole.log('All posts after delete:', inspect(await db.post.findMany()));\n```\n\ndanger\n\nYou should never manipulate the concrete models with a raw `PrismaClient` or one without the \"delegate\" enhancement kind enabled. This may cause corruption to the relation between the base and concrete entities.\n\n### Access Policies[‚Äã](https://zenstack.dev/docs/guides/polymorphism#access-policies \"Direct link to Access Policies\")\n\nIn an delegated inheritance hierarchy, all access policies from the base models are inherited to the sub models. This ensures that when you directly manipulate base model's fields with a sub model, the access policies on the base are effective.\n\nHere's how you can add policies to the sample schema:\n\n```\nmodel User {  id Int @id @default(autoincrement())  contents Content[]  @@allow('create,read', true)  @@allow('all', auth() == this)}model Content {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)  ownerId Int  published Boolean @default(false)  contentType String  @@delegate(contentType)  @@allow('read', published)  @@allow('all', auth() == owner)}model Post extends Content {  title String}model Video extends Content {  name String  duration Int}\n```\n\n### Polymorphic TypeScript Types[‚Äã](https://zenstack.dev/docs/guides/polymorphism#polymorphic-typescript-types \"Direct link to Polymorphic TypeScript Types\")\n\nThe TS types generated by Prisma into the `@prisma/client` module have the database representation's typing and do not provide the \"polymorphic view\". For example, the following code doesn't compile:\n\n```\nimport type { Prisma } from '@prisma/client';const where: Prisma.PostWhereInput = {};console.log(where.published); // error: Property 'published' does not exist on type 'PostWhereInput'\n```\n\nTo use the TS types with polymorphic view, import the `Prisma` type from the `@zenstackhq/runtime/models` module instead. This module contains types generated by ZenStack that comply with the ZModel schema.\n\n```\nimport type { Prisma } from '@zenstackhq/runtime/models';const where: Prisma.PostWhereInput = {}console.log(where.published); // `PostWhereInput` has the `published` field\n```\n\n### Sample Project[‚Äã](https://zenstack.dev/docs/guides/polymorphism#sample-project \"Direct link to Sample Project\")\n\n*   Simple TypeScript script sample: [https://github.com/zenstackhq/v2-polymorphism](https://github.com/zenstackhq/v2-polymorphism)\n*   Full-stack blog app sample (use `polymorphic` branch): [https://github.com/zenstackhq/docs-tutorial-nextjs/tree/polymorphic](https://github.com/zenstackhq/docs-tutorial-nextjs/tree/polymorphic)\n\n### Inner Workings[‚Äã](https://zenstack.dev/docs/guides/polymorphism#inner-workings \"Direct link to Inner Workings\")\n\nZenStack works with two versions of `PrismaClient` to achieve polymorphism:\n\n*   **Logical view**\n    \n    It's the `PrismaClient` an end-developer sees when using the enhanced client. The logical client copies all fields of the base models to the sub models to give you the experience of inheritance. The logical client is only for providing polymorphic typing, and it's not mapped to the database schema or used for real database operations.\n    \n    The logical `PrismaClient` is derived from a Prisma schema generated into \"node\\_modules/.zenstack/delegate.schema\".\n    \n*   **Physical view**\n    \n    It's the `PrismaClient` ZenStack internally uses when working with the database. It's derived from the Prisma schema that's normally generated as the output of `zenstack generate`. The physical client also aligns with your database schema: fields of base and sub models only reside in their respective tables without duplication, and they are linked with foreign keys.\n    \n\nThe main thing that ZenStack does internally is to translate between these two \"views\". The end-developer works on the logical view, and ZenStack intercepts the Prisma calls and translate them into appropriate queries and mutations to the physical view.\n\n### Limitations[‚Äã](https://zenstack.dev/docs/guides/polymorphism#limitations \"Direct link to Limitations\")\n\n*   Inheriting from multiple `@delegate` models is not supported yet.\n    \n*   You cannot access base fields when calling `count`, `aggregate`, and `groupBy` with a concrete model. The following query is not supported:\n    \n    ```\n    // you can't access base fields (`published` here) when aggregatingdb.post.count({ select: { published: true } });\n    ```",
  "title": "Polymorphic Relations | ZenStack",
  "description": "Polymorphic Relations",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/client-extensions",
  "markdown": "# Using With Prisma Client Extensions\n\n[Prisma Client Extension](https://www.prisma.io/docs/orm/prisma-client/client-extensions) is a mechanism for extending the interface and functionality of Prisma Client. This guide introduces two ways of using ZenStack with client extensions and their implications.\n\nWe'll use the following ZModel as a reference throughout this guide:\n\n```\nmodel Post {  id Int @id @default(autoincrement())  title String  content String?  published Boolean @default(false)  @@allow('read', published)}\n```\n\n## Enhancing a Prisma Client with extensions installed[‚Äã](https://zenstack.dev/docs/guides/client-extensions#enhancing-a-prisma-client-with-extensions-installed \"Direct link to Enhancing a Prisma Client with extensions installed\")\n\nThis should be the most common way of using ZenStack with client extensions. You install client extensions to the global `PrismaClient` instance when the application starts and then call `enhance` with the extended client on a per-request basis. It will generally work as you would intuitively expect.\n\nLet's look at a few examples.\n\n### 1\\. Model-level methods[‚Äã](https://zenstack.dev/docs/guides/client-extensions#1-model-level-methods \"Direct link to 1. Model-level methods\")\n\n```\nconst extendedPrisma = prisma.$extends({  model: {    post: {      async getFeeds() {          const context = Prisma.getExtensionContext(this);          return context.findMany();      },    },  },});const db = enhance(extendedPrisma);const feeds = await db.post.getFeeds();\n```\n\nThe `getFeeds()` call will return only published posts. The `context` variable fetched with `Prisma.getExtensionContext(this)` is enhanced by ZenStack.\n\n### 2\\. Query-level overrides[‚Äã](https://zenstack.dev/docs/guides/client-extensions#2-query-level-overrides \"Direct link to 2. Query-level overrides\")\n\n```\nconst extendedPrisma = prisma.$extends({  query: {    post: {      findMany({ query, args }) {        console.log('Query args:', inspect(args, { depth: null }));        return query(args);      },    },  },});const enhanced = enhance(extendedPrisma);const posts = await enhanced.post.findMany();\n```\n\nThe `findMany` call returns only published posts. The printed log will demonstrate that the `args` is injected by ZenStack to include access policy filters.\n\nYou can also override mutation methods and it generally works. However, it must be noted that ZenStack enforces mutation policies before or after the mutation is executed (in the case of \"after\", a transaction is used to roll back if the policy fails), depending on the access policies and the mutation input. This means that if you alter the mutation args in a client extension to make it conform to the access policy, it may not work because ZenStack intercepts the mutation call first, and may decide to reject it based on the original args.\n\n### 3\\. Computed fields[‚Äã](https://zenstack.dev/docs/guides/client-extensions#3-computed-fields \"Direct link to 3. Computed fields\")\n\n```\nconst extendedPrisma = prisma.$extends({  result: {    post: {      myTitle: {        needs: { title: true },        compute(post) {          return 'MyTitle: ' + post.title;        },      },    },  },});const enhanced = enhance(extendedPrisma);const post = await enhanced.post.findFirst();\n```\n\nComputed fields will work as expected. ZenStack enhancement works transparently with it.\n\ndanger\n\nCurrently there's a limitation that computed fields are not governed by field-level access policies. This means that if you have a computed field that depends on a field that the current user cannot read, the computed field will still be calculated and returned.\n\n## Installing extensions to an enhanced Prisma Client[‚Äã](https://zenstack.dev/docs/guides/client-extensions#installing-extensions-to-an-enhanced-prisma-client \"Direct link to Installing extensions to an enhanced Prisma Client\")\n\nSuch a setup DOES NOT WORK as you would expect in most cases, so it should generally be avoided. For example,\n\n```\nconst enhanced = enhance(prisma);const db = enhanced.$extends({  model: {    post: {      async getFeeds() {          const context = Prisma.getExtensionContext(this);          return context.findMany();      },    },  },});const feeds = await db.post.getFeeds();\n```\n\nThe `getFeeds()` call will return all posts (both published and unpublished ones). This is due to how Prisma internally implements the client extensions. Although you're calling `$extends` on an enhanced client, inside the extension, the context (returned by `Prisma.getExtensionContext(this)`) bypasses ZenStack and directly calls into the original Prisma client.\n\nYou can refactor the code to make it work by explicitly referencing the enhanced client in the extension:\n\n```\nconst enhanced = enhance(prisma);const db = enhanced.$extends({  model: {    post: {      async getFeeds() {          return enhanced.post.findMany();      },    },  },});const feeds = await db.post.getFeeds();\n```\n\nIt may or may not be practical, depending on the structure of your code base.",
  "title": "Using With Prisma Client Extensions | ZenStack",
  "description": "Using ZenStack with Prisma Client Extensions.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/redwood",
  "markdown": "# Using With RedwoodJS | ZenStack\n\n[RedwoodJS](https://redwoodjs.com/) is an opinionated full-stack framework that combines a set of tools and libraries and helps you build GraphQL-based applications quickly without struggling with tooling.\n\nZenStack provides a plugin package to help you easily integrate with RedwoodJS projects. After setting it up, you can define access policies in ZModel and use the enhanced `PrismaClient` to enforce the policies in your services automatically.\n\n## Details[‚Äã](https://zenstack.dev/docs/guides/redwood#details \"Direct link to Details\")\n\n### Setting up[‚Äã](https://zenstack.dev/docs/guides/redwood#setting-up \"Direct link to Setting up\")\n\nYou can prepare your RedwoodJS project for ZenStack by running the following command at the root of your project:\n\n```\nyarn rw setup package @zenstackhq/redwood\n```\n\nThe setup command will:\n\n1.  Update \"redwood.toml\" to allow the ZenStack CLI plugin\n    \n    ```\n    [[experimental.cli.plugins]]package = \"@zenstackhq/redwood\"enabled = true\n    ```\n    \n2.  Install ZenStack dependencies to the \"api\" package\n    \n    *   `zenstack`: the main CLI\n    *   `@zenstackhq/runtime`: the runtime library for creating enhanced `PrismaClient`\n    *   `@zenstackhq/redwood`: custom CLI and runtime for RedwoodJS\n3.  Prepare ZModel schema\n    \n    Your Prisma schema file \"api/db/schema.prisma\" will be copied to \"api/db/schema.zmodel\". Moving forward, you should edit \"schema.zmodel\" to update the database schema and access policies. The \"schema.prisma\" file will be regenerated when you run `yarn rw @zenstackhq generate`.\n    \n4.  Register the location of \"schema.zmodel\" and \"schema.prisma\" in \"api/package.json\"\n    \n    api/package.json\n    \n    ```\n    {  ...  \"zenstack\": {    \"schema\": \"db/schema.zmodel\",    \"prisma\": \"db/schema.prisma\"  }}\n    ```\n    \n5.  Install a GraphQLYoga plugin to the GraphQL handler\n    \n    api/src/functions/graphql.\\[ts|js\\]\n    \n    ```\n    import { useZenStack } from '@zenstackhq/redwood'import { db } from 'src/lib/db'import { createGraphQLHandler } from '@redwoodjs/graphql-server'...export const handler = createGraphQLHandler({  ...  extraPlugins: [useZenStack(db)],})\n    ```\n    \n    The `useZenStack` plugin creates an enhanced `PrismaClient` for the current requesting user and stores it as `db` field in the global GraphQL context. You can use it in your service code via `context.db`. For example, the service for listing blog posts can be implemented as follows: only posts readable to the current user will be returned.\n    \n    api/src/services/posts/posts.js\n    \n    ```\n    export const posts = (...args) => {  return context.db.post.findMany()}\n    ```\n    \n    The plugin, by default, uses `context.currentUser` to get the current requesting user. You can customize it by passing in a function as the second argument to calculate a custom user object based on `context.currentUser`. E.g.:\n    \n    ```\n    useZenStack(db, async (currentUser) => {  const typedUser = currentUser as { id: string };  const dbUser = await db.user.findUnique({     where: { id: typedUser.id },    // select more fields    select: { id: true, role: true }  });  return dbUser;});\n    ```\n    \n    See [here](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user) for more details about accessing the current user.\n    \n6.  Eject service templates\n    \n    The setup runs `yarn rw setup generator service` to eject template files used by `yarn rw g service` command. It also modifies the templates to use `context.db` instead of `db` to access the database with automatic access policy enforcement.\n    \n\n### Modeling data and access policies[‚Äã](https://zenstack.dev/docs/guides/redwood#modeling-data-and-access-policies \"Direct link to Modeling data and access policies\")\n\nZenStack's ZModel language is a superset of Prisma schema language. You should use it to define both the data schema and access policies. [The Complete Guide](https://zenstack.dev/docs/the-complete-guide/part1/) of ZenStack is the best way to learn how to author ZModel schemas. Here's a quick example to show how you can define access policies for the blog post sample used throughout the official RedwoodJS tutorial:\n\napi/db/schema.zmodel\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String  body      String  comments  Comment[]  user      User     @relation(fields: [userId], references: [id])  userId    Int  createdAt DateTime @default(now())  published Boolean @default(true)  // üîê Admin user can do everything to his own posts  @@allow('all', auth().roles == 'admin' && auth() == user)  // üîê Posts are visible to everyone if published  @@allow('read', published)}\n```\n\nYou should run the following command after updating \"schema.zmodel\":\n\n```\nyarn rw @zenstackhq generate\n```\n\nThe command does the following things:\n\n1.  Regenerate \"schema.prisma\"\n2.  Run `prisma generate` to regenerate `PrismaClient`\n3.  Generate supporting JS modules for enforcing access policies at runtime\n\n### Development workflow[‚Äã](https://zenstack.dev/docs/guides/redwood#development-workflow \"Direct link to Development workflow\")\n\nThe workflow of using ZenStack is very similar to using Prisma in RedwoodJS projects. The two main differences are:\n\n1.  Code generation\n    \n    You should run `yarn rw @zenstackhq generate` instead of `yarn rw prisma generate`. The ZenStack's \"generate\" command internally regenerates the Prisma schema from the ZModel schema, runs `prisma generate` automatically, and outputs supporting modules for access policy enforcement.\n    \n2.  Database access in services\n    \n    In your service code, you should use `context.db` instead of `db` for accessing the database. The setup procedure prepared a customized service code template. When you run `yarn rw g service`, the generated code will already use `context.db`.\n    \n\nOther Prisma-related workflows like generation migration or pushing schema to the database stay unchanged.\n\n### Deployment[‚Äã](https://zenstack.dev/docs/guides/redwood#deployment \"Direct link to Deployment\")\n\nYou should run the \"generate\" command in your deployment script before `yarn rw deploy`. For example, to deploy to Vercel, the command can be:\n\n```\nyarn rw @zenstackhq generate && yarn rw deploy vercel\n```\n\nNotes about Netlify\n\nZenStack generates supporting JS modules into the `node_modules/.zenstack` folder, and the folder needs to be accessible at the runtime. Netlify detects the dependencies it needs to bundle by inspecting an application's root package.json file. This will result in the `.zenstack` folder being ignored.\n\nTo fix this problem, add the following section to your `netlify.toml` file:\n\n```\n[functions]  included_files = [\"node_modules/.zenstack/*\"]\n```\n\n### Using the `@zenstackhq` CLI plugin[‚Äã](https://zenstack.dev/docs/guides/redwood#using-the-zenstackhq-cli-plugin \"Direct link to using-the-zenstackhq-cli-plugin\")\n\nThe `@zenstackhq/redwood` package registers a set of custom commands to the RedwoodJS CLI under the `@zenstackhq` namespace. You can run it with:\n\n```\nyarn rw @zenstackhq <cmd> [options] \n```\n\nThe plugin is a simple wrapper of the standard `zenstack` CLI, similar to how RedwoodJS wraps the standard `prisma` CLI. It's equivalent to running `npx zenstack ...` inside the \"api\" directory.\n\nSee the [CLI references](https://zenstack.dev/docs/reference/cli) for the complete list of commands.\n\n## Sample application[‚Äã](https://zenstack.dev/docs/guides/redwood#sample-application \"Direct link to Sample application\")\n\nYou can find a completed multi-tenant Todo application built with RedwoodJS and ZenStack at: [https://github.com/zenstackhq/sample-todo-redwood](https://github.com/zenstackhq/sample-todo-redwood).",
  "title": "Using With RedwoodJS | ZenStack",
  "description": "Guide for using ZenStack with RedwoodJS.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/check-permission",
  "markdown": "# Checking Permissions Without Hitting the Database (Preview)\n\n## Introduction[‚Äã](https://zenstack.dev/docs/guides/check-permission#introduction \"Direct link to Introduction\")\n\nZenStack's access policies provide a protection layer around Prisma's CRUD operations and filter/deny access to the data automatically. However, there are cases where you simply want to check if an operation is permitted without actually executing it. For example, you might want to show or hide a button based on the user's permission.\n\nOf course, you can determine the permission by executing the operation to see if it's allowed (try reading data, or mutating inside a transaction then aborting). But this comes with the cost of increased database load, slower UI rendering, and data pollution risks.\n\nAnother choice is to implement permission checking logic directly inside your frontend code. However, it'll be much nicer if the access policies in ZModel can be reused, so it stays as the single source of truth for access control.\n\nThis guide introduces how to use ZenStack's `check` API to check permissions without accessing the database. The feature is in preview, and feedback is highly appreciated.\n\ndanger\n\nPermission checking is an approximation and can be over-permissive. You MUST NOT trust it and circumvent the real access control mechanism (e.g., calling raw Prisma CRUD operations without further authorization checks).\n\n## Understanding the Problem[‚Äã](https://zenstack.dev/docs/guides/check-permission#understanding-the-problem \"Direct link to Understanding the Problem\")\n\nZenStack's access policies are by design coupled with the data model, which implies that to check permission precisely, you'll have to evaluate it against the actual data. In reality, what you often need is an approximation, or in other words, a \"weak\" check. For example, you may want to check if the current user, given his role, can read entities of a particular model, and if so, render the corresponding part of UI. You don't really want to guarantee that the user is allowed to read every row of that model. What you care about is if he's potentially allowed.\n\nWith this in mind, \"checking permission\" is equivalent to answering the following question:\n\n> Assuming we can have arbitrary rows of data in the database, can the access policies for the given operation possibly evaluate to `TRUE` for the current user?\n\nThe problem then becomes a [Boolean Satisfiability Problem](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem). We can treat model fields as \"variables\" and use a [SAT Solver](https://en.wikipedia.org/wiki/SAT_solver) to find a solution for those variables that satisfy the access policies. If a solution exists, then the permission is possible.\n\nLet's make the discussion more concrete by looking at an example:\n\n```\nmodel Post {  id Int @id @default(autoincrement())  title String  author User @relation(fields: [authorId], references: [id])  authorId Int  published Boolean @default(false)  @@allow('read', published || authorId == auth().id)}\n```\n\nThe \"read\" policy rule can be converted to a boolean formula like:\n\ninfo\n\n*   The `context` object is the second argument you pass to the `enhance` API call.\n*   A name wrapped with square brackets represents a named variable in a boolean formula.\n\nTo check if a user can read posts, we simply need to find a solution for the `published` and `authorId` variables that make the boolean formula evaluate to `TRUE`.\n\n## Using the `check` API[‚Äã](https://zenstack.dev/docs/guides/check-permission#using-the-check-api \"Direct link to using-the-check-api\")\n\nZenStack adds a `check` API to every model in the enhanced PrismaClient. The feature is still in preview, so you need to explicitly opt in by turning on the \"generatePermissionChecker\" flag on the \"@core/enhancer\" plugin in ZModel:\n\n```\nplugin enhancer {  provider = '@core/enhancer'  generatePermissionChecker = true}\n```\n\nThen, rerun `zenstack generate`, and the `check` API will be available on each model with the following signature (using the `Post` model as an example):\n\n```\ntype CheckArgs = {  /**   * The operation to check for   */  operation: 'create' | 'read' | 'update' | 'delete';  /**   * The optional additional constraints to impose on the model fields   */  where?: { id?: number; title?: string; published?: boolean; authorId?: number };}check(args: CheckArgs): Promise<boolean>;\n```\n\nLet's see how to use it to check `Post` readability for different use cases. Just to recap, the boolean formula for the \"read\" policy is:\n\n### 1\\. Can an anonymous user read posts?[‚Äã](https://zenstack.dev/docs/guides/check-permission#1-can-an-anonymous-user-read-posts \"Direct link to 1. Can an anonymous user read posts?\")\n\nThe scenario is to determine if the `Posts` UI tab should be visible when the current user is not logged in. We can do the checking as follows:\n\n```\nconst db = enhance(prisma); // enhance without a user contextawait canRead = await db.post.check({ operation: 'read' });\n```\n\nThe result will be `true` with the following variable assignments:\n\n*   `published -> true`\n*   `authorId -> 0`\n\nNote that the `authorId` variable can actually be any integer.\n\n### 2\\. Can an anonymous user read unpublished posts?[‚Äã](https://zenstack.dev/docs/guides/check-permission#2-can-an-anonymous-user-read-unpublished-posts \"Direct link to 2. Can an anonymous user read unpublished posts?\")\n\nThe scenario is to determine if the `Drafts` UI tab should be visible when the current user is not logged in.\n\n```\nconst db = enhance(prisma); // enhance without a user contextawait canRead = await db.post.check({ operation: 'read', where: { published: false } });\n```\n\nWe're now adding an additional constraint `published == false` that the solver needs to consider besides the original formula:\n\nThe result will be `false` because there are no assignments of the `published` and `authorId` variables that satisfy the formula. Note that the `context.user.id` value is undefined thus cannot be equal to `authorId`.\n\n### 3\\. Can `user#1` read unpublished posts[‚Äã](https://zenstack.dev/docs/guides/check-permission#3-can-user1-read-unpublished-posts \"Direct link to 3-can-user1-read-unpublished-posts\")\n\nThe scenario is to determine if the `Drafts` UI tab should be visible for a currently logged-in user.\n\n```\nconst db = enhance(prisma, { user: { id: 1 } }); // enhance with user contextawait canRead = await db.post.check({ operation: 'read', where: { published: false } });\n```\n\nWe're now providing a value `1` to `context.user.id`, and the formula becomes:\n\nThe result will be `true` with the following variable assignments:\n\n*   `published -> false`\n*   `authorId -> 1`\n\n## Server Adapters and Hooks[‚Äã](https://zenstack.dev/docs/guides/check-permission#server-adapters-and-hooks \"Direct link to Server Adapters and Hooks\")\n\nThe `check` API is also available in the [RPC API Handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc) and can be used with all [server adapters](https://zenstack.dev/docs/category/server-adapters).\n\nThe [@zenstackhq/tanstack-query](https://zenstack.dev/docs/reference/plugins/tanstack-query) and [@zenstackhq/swr](https://zenstack.dev/docs/reference/plugins/swr) plugins have been updated to generate `useCheck[Model]` hooks for checking permissions in the frontend.\n\n```\nimport { useCheckPost } from '~/lib/hooks';const { data: canReadDrafts } = useCheckPost({  operation: 'read',  where: { published: false } });\n```\n\n## Limitations[‚Äã](https://zenstack.dev/docs/guides/check-permission#limitations \"Direct link to Limitations\")\n\nZenStack uses the [logic-solver](https://www.npmjs.com/package/logic-solver) package for SAT solving. The solver is lightweighted, but only supports boolean and bits (non-negative integer) types. This resulted in the following limitations:\n\n*   Only `Boolean`, `Int`, `String`, and enum types are supported.\n*   Functions (e.g., `startsWith`, `contains`, etc.) are not supported.\n*   Array fields are not supported.\n*   Relation fields are not supported.\n*   Collection predicates are not supported.\n\nYou can still use the `check` API even if your access policies use these unsupported features. Boolean components containing unsupported features are ignored during SAT solving by being converted to free variables, which can be assigned either `true` or `false` in a solution.\n\n## Notes About Anonymous Context[‚Äã](https://zenstack.dev/docs/guides/check-permission#notes-about-anonymous-context \"Direct link to Notes About Anonymous Context\")\n\nAccess policy rules often use `auth()` and members of `auth()` (e.g., `auth().role`) in them. When a PrismaClient is enhanced in an anonymous context (calling `enhance` without context user object), neither `auth()` nor its members are unavailable. In such cases, the following evaluation rules apply:\n\n*   `auth() == null` evaluates to `true`.\n*   `auth() != null` evaluates to `false`.\n*   Any other form of boolean component involving `auth()` or its members evaluates to `false`.",
  "title": "Checking Permissions Without Hitting the Database (Preview) | ZenStack",
  "description": "Checking permissions without hitting the database.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/edge",
  "markdown": "# Deploying to Edge Runtime (Preview)\n\n## Introduction[‚Äã](https://zenstack.dev/docs/guides/edge#introduction \"Direct link to Introduction\")\n\nEdge Runtime is a kind of JavaScript runtime environment that allows code to run closer to the user's location, typically at the \"edge\" of the network. It can help improve the performance of web applications by reducing latency and increasing the speed of content delivery.\n\nZenStack is tested to work with Vercel Edge Runtime and Cloudflare Workers. Please [let us know](https://discord.gg/Ykhr738dUe) if you would like to see support for other environments.\n\n## Edge-Compatible Database Drivers[‚Äã](https://zenstack.dev/docs/guides/edge#edge-compatible-database-drivers \"Direct link to Edge-Compatible Database Drivers\")\n\nZenStack is built above Prisma, and Prisma's edge support was added recently and still evolving. The first thing you need to check is to make sure you use a edge-compatible database driver and Prisma adapter, or a traditional database with [Prisma Accelerate](https://www.prisma.io/docs/accelerate). Please check [this documentation](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview) for more details.\n\n## Vercel Edge Runtime[‚Äã](https://zenstack.dev/docs/guides/edge#vercel-edge-runtime \"Direct link to Vercel Edge Runtime\")\n\nYou can enable edge runtime for a route by exporting a const named `runtime`. For example, for a RSC page:\n\n```\nimport { createPrisma } from '~/lib/db';import { getSessionUser } from '~/lib/auth';export default async function Page() {  ...  // IMPORTANT: in edge environment you must create a new `PrismaClient` for each request  // https://github.com/prisma/prisma/issues/20566#issuecomment-2021594203  const prisma = createPrisma();  const db = enhance(prisma, { user: getSessionUser() });  const posts = await db.post.findMany();  ...}export const runtime = 'edge';\n```\n\nThe page component (which is an RSC) will run on the server side in edge environment. You can use a compatible `PrismaClient` enhanced by ZenStack in its implementation.\n\nYou can also run ZenStack's [Next.js server adapter](https://zenstack.dev/docs/reference/server-adapters/next) on the edge:\n\n/src/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { NextRequestHandler } from '@zenstackhq/server/next';import { createPrisma } from '~/lib/db';import { getSessionUser } from '~/lib/auth';function getEnhancedPrisma(req: Request) {  // IMPORTANT: in edge environment you must create a new `PrismaClient` for each request  // https://github.com/prisma/prisma/issues/20566#issuecomment-2021594203  const prisma = createPrisma();  return enhance(prisma, { user: getSessionUser(req) });}const handler = NextRequestHandler({ getPrisma: (req) => getEnhancedPrisma(req), useAppDir: true });export {  handler as DELETE,  handler as GET,  handler as PATCH,  handler as POST,  handler as PUT,};export const runtime = 'edge';export const dynamic = 'force-dynamic';\n```\n\nDO NOT REUSE Prisma Client\n\nWhen targeting the edge runtime, it's important that you create a new `PrismaClient` instance for each request. Otherwise you can get unexpected behavior or errors. See [this comment](https://github.com/prisma/prisma/issues/20566#issuecomment-2021594203) for more details.\n\nYou can use the \"v2-edge\" branch of [https://github.com/zenstackhq/sample-todo-nextjs-tanstack](https://github.com/zenstackhq/sample-todo-nextjs-tanstack/tree/v2-edge) as a reference.\n\n### Caveats[‚Äã](https://zenstack.dev/docs/guides/edge#caveats \"Direct link to Caveats\")\n\n`@zenstackhq/runtime` depends on `bcryptjs` which is not fully compatible with Vercel Edge Runtime. You may get the following error during compilation:\n\n```\n./node_modules/bcryptjs/dist/bcrypt.jsModule not found: Can't resolve 'crypto' in '.../node_modules/bcryptjs/dist'\n```\n\nTo workaround this problem, add the following to the \"package.json\" file to avoid explicitly resolving the \"crypto\" module:\n\n```\n{  ...  \"browser\": {    \"crypto\": false  }}\n```\n\n## Cloudflare Workers[‚Äã](https://zenstack.dev/docs/guides/edge#cloudflare-workers \"Direct link to Cloudflare Workers\")\n\nYou can use ZenStack-enhanced `PrismaClient` in Cloudflare Workers. Here's an example for using with a Neon database. It's recommended to import `enhance` from `@zenstackhq/runtime/edge` instead of `@zenstackhq/runtime`. Although these two modules are identical today, they may diverge in the future due to limitations of the edge runtime.\n\n```\nimport { PrismaClient } from '@prisma/client';import { PrismaNeon } from '@prisma/adapter-neon';import { Pool } from '@neondatabase/serverless';import { enhance } from '@zenstackhq/runtime/edge';import { getSessionUser } from './auth';export default {  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {    const neon = new Pool({ connectionString: env.DATABASE_URL });    const adapter = new PrismaNeon(neon);    const prisma = new PrismaClient({ adapter });    const db = enhance(prisma, { user: getSessionUser(request) });    const posts = await db.post.findMany();      return Response.json(posts);  }};\n```\n\ninfo\n\nCloudflare's [D1 database](https://developers.cloudflare.com/d1/) is not yet supported by ZenStack due to its lack of support for interactive transactions.\n\nZenStack currently doesn't have adapters for edge-first server frameworks like [hono](https://hono.dev/). Please create a [feature request](https://github.com/zenstackhq/zenstack/issues/new?template=feature_request.md&title=%5BFeature+Request%5D) if you have a need for it.",
  "title": "Deploying to Edge Runtime (Preview) | ZenStack",
  "description": "Guide for deploying ZenStack to edge runtime.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/server-adapters/next",
  "markdown": "# Next.js | ZenStack\n\n## Next.js Server Adapter\n\nThe `@zenstackhq/server/next` module provides a quick way to install API endpoints onto a [Next.js](https://nextjs.org/) project for database CRUD operations. Combined with ZenStack's power of enhancing Prisma with access policies, it's surprisingly simple to achieve a secure data backend without manually coding it.\n\nThe server adapter supports both the \"pages\" routes for older versions of Next.js and the new \"app\" routes for Next.js 13.\n\n### Installation[‚Äã](https://zenstack.dev/docs/reference/server-adapters/next#installation \"Direct link to Installation\")\n\n```\nnpm install @zenstackhq/server\n```\n\n### Mounting the API[‚Äã](https://zenstack.dev/docs/reference/server-adapters/next#mounting-the-api \"Direct link to Mounting the API\")\n\nYou can use it to create a request handler in an API endpoint like:\n\n*   App Router\n*   Pages Router\n\n/src/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { NextRequestHandler } from '@zenstackhq/server/next';import type { NextRequest } from \"next/server\";import { enhance } from '@zenstackhq/runtime';import { prisma } from '~/lib/db.ts';import { getSessionUser } from '~/lib/auth.ts';// create an enhanced Prisma client with user contextfunction getPrisma(req: NextRequest) {    // getSessionUser extracts the current session user from the request, its    // implementation depends on your auth solution    return enhance(prisma, { user: getSessionUser(req) });}const handler = NextRequestHandler({ getPrisma, useAppDir: true });export {  handler as GET,  handler as POST,  handler as PUT,  handler as PATCH,  handler as DELETE,};\n```\n\nThe Next.js API route handler takes the following options to initialize:\n\n*   getPrisma (required)\n    \n    > (req: NextRequest) => unknown | Promise<unknown>\n    \n    A callback for getting a PrismaClient instance for talking to the database. Usually you'll use an enhanced instance created with ZenStack's [`enhance`](https://zenstack.dev/docs/reference/runtime-api#enhance) API to ensure access policies are enforced.\n    \n*   logger (optional)\n    \n    > LoggerConfig\n    \n    Configuration for customizing logging behavior.\n    \n*   modelMeta (optional)\n    \n    > ModelMeta\n    \n    Model metadata. By default loaded from the `node_module/.zenstack/model-meta` module. You can pass it in explicitly if you configured ZenStack to output to a different location. E.g.: `require('output/model-meta').default`.\n    \n*   zodSchemas (optional)\n    \n    > ModelZodSchema | boolean | undefined\n    \n    Provides the Zod schemas used for validating CRUD request input. The Zod schemas can be generated with the `@core/zod` plugin. Pass `true` for this option to load the schemas from the default location. If you configured `@core/zod` plugin to output to a custom location, you can load the schemas explicitly and pass the loaded module to this option. E.g.:\n    \n    ```\n    factory({    ...    zodSchemas: require('./zod'),});\n    ```\n    \n    Not passing this option or passing in `undefined` disables input validation.\n    \n*   handler (optional)\n    \n    > (req: RequestContext) => Promise<Response>\n    \n    The request handler function. This option determines the API endpoints and its input and output formats. Currently ZenStack supports two styles of APIs: RPC (the default) and RESTful.\n    \n    *   RPC\n        \n        The goal of the RPC-style API handler is to fully mirror [PrismaClient's API](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#model-queries) across the network, so that developers can continue enjoying the convenience and flexibility of Prisma's query syntax. This is the default choice for the `handler` option.\n        \n        The RPC-style handler can be created like:\n        \n        ```\n        import { RPCApiHandler } from '@zenstackhq/server/api';const handler = RPCApiHandler();\n        ```\n        \n        For more details, please check out [RPC API Handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc).\n        \n    *   RESTful\n        \n        The goal of RESTful-style API handler is to provide a resource-centric RESTful API using [JSON:API](https://jsonapi.org/) as transportation format.\n        \n        The RESTful-style handler can be created like:\n        \n        ```\n        import { RestApiHandler } from '@zenstackhq/server/api';const handler = RestApiHandler({ endpoint: 'http://myhost/api' });\n        ```\n        \n        For more details, please check out [RESTful API Handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest).\n        \n\n### Controlling what endpoints to expose[‚Äã](https://zenstack.dev/docs/reference/server-adapters/next#controlling-what-endpoints-to-expose \"Direct link to Controlling what endpoints to expose\")\n\nYou can use a [Next.js middleware](https://nextjs.org/docs/pages/building-your-application/routing/middleware) to further control what endpoints to expose. For example, if you're using a RESTful API handler installed at \"/api/model\", you can disallow listing all `User` entities by adding a middleware like:\n\n/src/middleware.ts\n\n```\nimport { type NextRequest, NextResponse } from 'next/server';export function middleware(request: NextRequest) {    const url = new URL(request.url);    if (        request.method === 'GET' &&        url.pathname.match(/^\\/api\\/model\\/user\\/?$/)    ) {        return NextResponse.json({ error: 'Not allowed' }, { status: 405 });    }}export const config = {    matcher: '/api/model/:path*',};\n```\n\n### Using the API[‚Äã](https://zenstack.dev/docs/reference/server-adapters/next#using-the-api \"Direct link to Using the API\")\n\nThe APIs can be used in the following three ways:\n\n1.  With generated client hooks\n    \n    ZenStack provides plugins to generate client hooks from the ZModel targeting the most popular frontend data fetching libraries: [TanStack Query](https://tanstack.com/query/latest) and [SWR](https://swr.vercel.app/). The generated hooks can be used to make API calls to the server adapters. Refer to the follow docs for detailed usage:\n    \n    *   [`@zenstackhq/tanstack-query`](https://zenstack.dev/docs/reference/plugins/tanstack-query)\n    *   [`@zenstackhq/swr`](https://zenstack.dev/docs/reference/plugins/swr)\n    \n    info\n    \n    The generated client hooks assumes the server adapter uses [RPC-style API handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc) (which is the default setting).\n    \n2.  With direct HTTP calls\n    \n    You can make direct HTTP calls to the server adapter using your favorite client libraries like `fetch` or `axios`. Refer to the documentation of the [API Handlers](https://zenstack.dev/docs/reference/server-adapters/api-handlers/) for the API endpoints and data formats.\n    \n    Here's an example using `fetch`:\n    \n    *   RPC Handler\n    *   RESTful Handler\n    \n    ```\n    // create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n    ```\n    \n    Output:\n    \n    ```\n    {    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n    ```\n    \n3.  With third-party client generators\n    \n    ZenStack provides an [OpenAPI](https://zenstack.dev/docs/reference/plugins/openapi) plugin for generating Open API 3.x specification from the ZModel. The generated OpenAPI spec can be used to generate client libraries for various languages and frameworks. For example, you can use [openapi-typescript](https://github.com/drwpow/openapi-typescript) to generate a typescript client.\n    \n\n### Error Handling[‚Äã](https://zenstack.dev/docs/reference/server-adapters/next#error-handling \"Direct link to Error Handling\")\n\nRefer to the specific sections for [RPC Handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#http-status-code-and-error-responses) and [RESTful Handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#error-handling).\n\n### Fully working example[‚Äã](https://zenstack.dev/docs/reference/server-adapters/next#fully-working-example \"Direct link to Fully working example\")\n\nYou can find the fully working examples below:\n\n*   [Pages router](https://github.com/zenstackhq/docs-tutorial-nextjs)\n*   [Apps router](https://github.com/zenstackhq/docs-tutorial-nextjs-app-dir)",
  "title": "Next.js | ZenStack",
  "description": "Adapter for integrating with Next.js",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/server-adapters/fastify",
  "markdown": "# Fastify | ZenStack\n\n```\n// create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n```\n\n```\n{    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n```",
  "title": "Fastify | ZenStack",
  "description": "Adapter for integrating with Fastify",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/cli",
  "markdown": "# ZenStack CLI Reference | ZenStack\n\n## Usage[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#usage \"Direct link to Usage\")\n\n```\nzenstack [options] [command]Œ∂ ZenStack is a Prisma power pack for building full-stack apps.Documentation: https://zenstack.dev.Options:  -v --version           display CLI version  -h, --help             display help for commandCommands:  info [path]            Get information of installed ZenStack and related packages.  init [options] [path]  Initialize an existing project for ZenStack.  generate [options]     Generates RESTful API and Typescript client for your data model.  repl [options]         Start a REPL session.  format [options]       Format a ZenStack schema file.  help [command]         Display help for a command.\n```\n\n## Sub Commands[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#sub-commands \"Direct link to Sub Commands\")\n\n### init[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#init \"Direct link to init\")\n\nInitializes an existing project to use ZenStack.\n\n```\nzenstack init [options] [path]\n```\n\n#### Arguments[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#arguments \"Direct link to Arguments\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| path | Project path | current folder |\n\n#### Options[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#options \"Direct link to Options\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| \\--prisma | location of Prisma schema file to bootstrap from | <project path>/prisma/schema.prisma |\n| \\-p, --package-manager | package manager to use: \"npm\", \"yarn\", or \"pnpm\" | auto detect |\n| \\--no-version-check | do not check for new versions of ZenStack | false |\n\n#### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#examples \"Direct link to Examples\")\n\nInitialize current folder with default settings.\n\nInitialize \"myapp\" folder with custom package manager and schema location.\n\n```\nnpx zenstack init -p pnpm --prisma prisma/my.schema myapp\n```\n\n### generate[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#generate \"Direct link to generate\")\n\nGenerates Prisma schema and other artifacts as specified by \"plugin\"s in ZModel.\n\n```\nzenstack generate [options]\n```\n\n#### Arguments[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#arguments-1 \"Direct link to Arguments\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| path | Project path | current folder |\n\n#### Options[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#options-1 \"Direct link to Options\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| \\--schema | schema file (with extension .zmodel) | ./schema.zmodel |\n| \\-o, --output <path> | default output directory for TS/JS files generated by built-in plugins | node\\_modules/.zenstack |\n| \\--no-default-plugins | do not automatically run built-in plugins | false |\n| \\--no-compile | do not compile the output of built-in plugins | false |\n| \\--no-version-check | do not check for new versions of ZenStack | false |\n\nYou can also specify the ZModel schema location in the \"package.json\" file of your project like the following:\n\npackage.json\n\n```\n{  \"zenstack\": {    \"schema\": \"./db/schema.zmodel\"  }}\n```\n\n#### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#examples-1 \"Direct link to Examples\")\n\nGenerate with default settings.\n\nGenerate with custom schema location.\n\n```\nnpx zenstack generate --schema src/my.zmodel\n```\n\n### repl[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#repl \"Direct link to repl\")\n\nStarts a REPL session. You should run the command inside the package where you ran `zenstack generate`.\n\nYou can call PrismaClient methods interactively in the REPL session. The following variables are available in the REPL session.\n\n*   `prisma`\n    \n    The original PrismaClient instance (without ZenStack enhancement).\n    \n*   `db`\n    \n    The ZenStack enhanced PrismaClient instance.\n    \n\nYou don't need to `await` the Prisma method call result. The REPL session will automatically await and print the result.\n\n#### Options[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#options-2 \"Direct link to Options\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| \\--debug | Enable debug output. Can be toggled on the fly in the repl session with the \".debug\" command. | false |\n| \\--table | Enable table format. Can be toggled on the fly in the repl session with the \".table\" command. | false |\n| \\--prisma-client | Path to load PrismaClient module. | \"./node\\_modules/.prisma/client\" |\n\n#### Repl Commands[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#repl-commands \"Direct link to Repl Commands\")\n\nYou can use the following commands in the REPL session.\n\n*   `.debug [on|off]`\n    \n    Toggle debug output.\n    \n*   `.table [on|off]`\n    \n    Toggle table format.\n    \n*   `.auth [user object]`\n    \n    Set current user. E.g.: `.auth { id: 1 }`. Run the command without argument to reset to anonymous user.\n    \n\n#### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#examples-2 \"Direct link to Examples\")\n\nStart the session:\n\nInside the session:\n\n```\n> prisma.user.findMany()[  {    id: '7aa301d2-7a29-4e1e-a041-822913a3ea78',    createdAt: 2023-09-05T04:04:43.793Z,    updatedAt: 2023-09-05T04:04:43.793Z,    email: 'yiming@whimslab.io',    ...  }]> .auth { id: '7aa301d2-7a29-4e1e-a041-822913a3ea78' }Auth user: { id: '7aa301d2-7a29-4e1e-a041-822913a3ea78' }. Use \".auth\" to switch to anonymous.> .tableTable output: true> db.list.findMany({select: { title: true, private: true}})‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ (index) ‚îÇ                       title                        ‚îÇ private ‚îÇ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§‚îÇ    0    ‚îÇ                        'L1'                        ‚îÇ  false  ‚îÇ‚îÇ    1    ‚îÇ               'Wonderful new world'                ‚îÇ  false  ‚îÇ‚îÇ    2    ‚îÇ 'Model for a space in which users can collaborate' ‚îÇ  false  ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### format[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#format \"Direct link to format\")\n\nFormat a ZenStack schema file.\n\n```\nzenstack format [options]\n```\n\n#### Options[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#options-3 \"Direct link to Options\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| \\--schema | schema file (with extension .zmodel) | ./schema.zmodel |\n\nYou can also specify the ZModel schema location in the \"package.json\" file of your project like the following:\n\npackage.json\n\n```\n{  \"zenstack\": {    \"schema\": \"./db/schema.zmodel\"  }}\n```\n\n### info[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#info \"Direct link to info\")\n\nGet information of installed ZenStack and related packages.\n\n```\nzenstack info [options] [path]\n```\n\n#### Arguments[‚Äã](https://zenstack.dev/docs/1.x/reference/cli#arguments-2 \"Direct link to Arguments\")\n\n| Name | Description | Default |\n| --- | --- | --- |\n| path | Project path | current folder |",
  "title": "ZenStack CLI Reference | ZenStack",
  "description": "CLI references",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/runtime-api",
  "markdown": "# Runtime API Reference | ZenStack\n\nThis document provides references for runtime APIs exported from the `@zenstackhq/runtime` package.\n\n## Prisma Enhancement API[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#prisma-enhancement-api \"Direct link to Prisma Enhancement API\")\n\nEnhancement APIs create wrappers around a Prisma client to add additional behavior. These wrappers can be freely combined to fine-tune what behavior to include.\n\n### enhance[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#enhance \"Direct link to enhance\")\n\n#### Description[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#description \"Direct link to Description\")\n\nCalling `enhance` is the simplest way to include all essential enhancements offered by ZenStack, including access policies, field validation, field omission, and password hashing. It's equivalent to calling:\n\n```\nwithOmit(withPassword(withPolicy(prisma, options)));\n```\n\n#### Signature[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#signature \"Direct link to Signature\")\n\n```\nfunction enhance<DbClient extends object>(    prisma: DbClient,    context?: WithPolicyContext,    options?: EnhancementOptions): DbClient;\n```\n\n##### Parameter `prisma`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-prisma \"Direct link to parameter-prisma\")\n\nThe PrismaClient instance to enhance.\n\n##### Parameter `context`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-context \"Direct link to parameter-context\")\n\nThe context to for evaluating access policies with the following typing.\n\n```\ntype WithPolicyContext = {    user?: Record<string, unknown>};\n```\n\n| Field | Description |\n| --- | --- |\n| user | The user object that provides value for the `auth()` function call in access policies. If provided. Its shape should be consistent with the `User` model in your ZModel, with all fields optional except for id field(s). Pass `undefined` to represent an anonymous user, and the `auth()` function call will evaluate to `null` in that case. |\n\n##### Parameter `options`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-options \"Direct link to parameter-options\")\n\nOptions with the following typing.\n\n```\ntype TransactionIsolationLevel =    | 'ReadUncommitted'    | 'ReadCommitted'    | 'RepeatableRead'    | 'Snapshot'    | 'Serializable';type EnhancementOptions = {    loadPath?: string;    policy?: PolicyDef;    modelMeta?: ModelMeta;    logPrismaQuery?: boolean;    prismaModule?: any;    transactionMaxWait?: number;    transactionTimeout?: number;    transactionIsolationLevel?: TransactionIsolationLevel;};\n```\n\n| Field | Description | Default |\n| --- | --- | --- |\n| loadPath | Path for loading CLI-generated code, including model metadata, access policies, and zod schemas. | node\\_modules/.zenstack |\n| policy | The access policy data, generated by `@core/access-policy` plugin. | Loaded from the default location or the path specified by the \"loadPath\" option |\n| modelMeta | The model metadata, generated by `@core/model-meta` plugin. | Loaded from the default location or the path specified by the \"loadPath\" option |\n| zodSchemas | The zod schemas, generated by `@core/zod` plugin. | Loaded from the default location or the path specified by the \"loadPath\" option |\n| logPrismaQuery | Whether to log queries sent to Prisma client. Log will be emitted with \"info\" level, so please make sure you [turn that level on](https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/logging#log-to-stdout) when creating Prisma client | false |\n| prismaModule | The `Prisma` module generated together with `PrismaClient`. You only need to pass it when you specified a custom `PrismaClient` output path. The module can be loaded like: `import { Prisma } from '<your PrismaClient output path>';`. |     |\n| transactionMaxWait | The `maxWait` option (in ms) passed to `prisma.$transaction()` call for transactions initiated by ZenStack. | 100000 |\n| transactionTimeout | The `timeout` option (in ms) passed to `prisma.$transaction()` call for transactions initiated by ZenStack. | 100000 |\n| transactionIsolationLevel | The `isolationLevel` option passed to `prisma.$transaction()` call for transactions initiated by ZenStack. | Database default |\n\n#### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#example \"Direct link to Example\")\n\n```\nconst session = getSession();const enhancedClient = enhance(prisma, { user: session.user });\n```\n\n### withPresets[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#withpresets \"Direct link to withPresets\")\n\n#### Description[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#description-1 \"Direct link to Description\")\n\nwarning\n\nThis API is equivalent to [`enhance`](https://zenstack.dev/docs/1.x/reference/runtime-api#enhance) and will be deprecated soon.\n\n### withPolicy[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#withpolicy \"Direct link to withPolicy\")\n\nUse `withPolicy` to include enhancements of access policy (`@@allow` and `@@deny`) and field validation (`@length`, `@email`, etc.).\n\nAccess policies and validation rules are processed by the `@core/access-policy` plugin, which transforms the attributes into objects that can be loaded at runtime by default into `node_modules/.zenstack` folder. `withPolicy` function also loads from there by default.\n\nIf your access policy rules use the `auth()` function, evaluating it requires access to the current user's identity. You need to pass in a context user object that at least contains the user id.\n\n#### Signature[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#signature-1 \"Direct link to Signature\")\n\n```\nfunction withPolicy<DbClient extends object>(    prisma: DbClient,    context?: WithPolicyContext,    options?: WithPolicyOptions): DbClient;\n```\n\n##### Parameter `prisma`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-prisma-1 \"Direct link to parameter-prisma-1\")\n\nThe PrismaClient instance to enhance.\n\n##### Parameter `context`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-context-1 \"Direct link to parameter-context-1\")\n\nThe context to for evaluating access policies with the following typing.\n\n```\ntype WithPolicyContext = {    user?: Record<string, unknown>};\n```\n\n| Field | Description | Default |\n| --- | --- | --- |\n| user | The user object that provides value for the `auth()` function call in access policies. If provided. Its shape should be consistent with the `User` model in your ZModel, with all fields optional except for id field(s). Pass `undefined` to represent an anonymous user, and the `auth()` function call will evaluate to `null` in that case. | undefined |\n\n##### Parameter `options`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-options-1 \"Direct link to parameter-options-1\")\n\nOptions with the following typing.\n\n```\ntype TransactionIsolationLevel =    | 'ReadUncommitted'    | 'ReadCommitted'    | 'RepeatableRead'    | 'Snapshot'    | 'Serializable';type WithPolicyOptions = {    loadPath?: string;    policy?: PolicyDef;    modelMeta?: ModelMeta;    logPrismaQuery?: boolean;    transactionMaxWait?: number;    transactionTimeout?: number;    transactionIsolationLevel?: TransactionIsolationLevel;};\n```\n\n| Field | Description | Default |\n| --- | --- | --- |\n| loadPath | Path for loading CLI-generated code, including model metadata, access policies, and zod schemas. | node\\_modules/.zenstack |\n| policy | The access policy data, generated by `@core/access-policy` plugin. | Loaded from the default location or the path specified by the \"loadPath\" option |\n| modelMeta | The model metadata, generated by `@core/model-meta` plugin. | Loaded from the default location or the path specified by the \"loadPath\" option |\n| zodSchemas | The zod schemas, generated by `@core/zod` plugin. | Loaded from the default location or the path specified by the \"loadPath\" option |\n| logPrismaQuery | Whether to log queries sent to Prisma client. Log will be emitted with \"info\" level, so please make sure you [turn that level on](https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/logging#log-to-stdout) when creating Prisma client | false |\n| transactionMaxWait | The `maxWait` option (in ms) passed to `prisma.$transaction()` call for transactions initiated by ZenStack. | 100000 |\n| transactionTimeout | The `timeout` option (in ms) passed to `prisma.$transaction()` call for transactions initiated by ZenStack. | 100000 |\n| transactionIsolationLevel | The `isolationLevel` option passed to `prisma.$transaction()` call for transactions initiated by ZenStack. | Database default |\n\n#### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#example-1 \"Direct link to Example\")\n\n```\n// ZModelmodel Post {    id String @id    title String    author User @relation(fields: [authorId], references: [id])    authorId String    @@allow('read', auth() == author)}\n```\n\n```\nconst session = getSession();const enhanced = withPolicy(prisma, { user: session.user });// only posts belonging to the current user are returnedconst posts = enhanced.post.findMany();\n```\n\n### withOmit[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#withomit \"Direct link to withOmit\")\n\nUse `withOmit` function to include support for the `@omit` attribute. Fields marked with the attribute will be removed from the entities when they're returned.\n\n#### Signature[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#signature-2 \"Direct link to Signature\")\n\n```\nfunction withOmit<DbClient extends object>(    prisma: DbClient,    options?: WithOmitOptions): DbClient;\n```\n\n##### Parameter `prisma`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-prisma-2 \"Direct link to parameter-prisma-2\")\n\nThe PrismaClient instance to enhance.\n\n##### Parameter `options`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-options-2 \"Direct link to parameter-options-2\")\n\nOptions with the following typing.\n\n```\ntype WithOmitOptions = {    loadPath?: string;    modelMeta?: ModelMeta;};\n```\n\n| Field | Description | Default |\n| --- | --- | --- |\n| loadPath | Path for loading CLI-generated code, including model metadata, access policies, and zod schemas. | node\\_modules/.zenstack |\n| modelMeta | The model metadata, generated by `@core/model-meta` plugin. Only need to pass it if you configured the plugin to generate into custom location. | Loaded from default location |\n\n#### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#example-2 \"Direct link to Example\")\n\n```\n// ZModelmodel User {    id String @id    email String    password String @omit}\n```\n\n```\nconst enhanced = withOmit(prisma);// password field is removed from user entitiesconst user = enhanced.user.findMany();\n```\n\n### withPassword[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#withpassword \"Direct link to withPassword\")\n\nUse `withPassword` function to include support for the `@password` attribute. Fields marked with the attribute will be automatically hashed (using [bcryptjs](https://www.npmjs.com/package/bcryptjs)) before being stored.\n\n#### Signature[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#signature-3 \"Direct link to Signature\")\n\n```\nfunction withPassword<DbClient extends object = any>(    prisma: DbClient,    options?: WithPasswordOptions): DbClient;\n```\n\n##### Parameter `prisma`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-prisma-3 \"Direct link to parameter-prisma-3\")\n\nThe PrismaClient instance to enhance.\n\n##### Parameter `options`[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#parameter-options-3 \"Direct link to parameter-options-3\")\n\nOptions with the following typing.\n\n```\ntype WithPasswordOptions = {    loadPath?: string;    modelMeta?: ModelMeta;};\n```\n\n| Field | Description | Default |\n| --- | --- | --- |\n| loadPath | Path for loading CLI-generated code, including model metadata, access policies, and zod schemas. | node\\_modules/.zenstack |\n| modelMeta | The model metadata, generated by `@core/model-meta` plugin. | Loaded from the default location or the path specified by the \"loadPath\" option |\n\n#### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/runtime-api#example-3 \"Direct link to Example\")\n\n```\n// ZModelmodel User {    id String @id    email String    password String @password}\n```\n\n```\nconst enhanced = withPassword(prisma);// password field is hashed before stored into the databaseconst user = enhanced.user.create({    data: { email: 'foo@bar.com', password: 'mysecurepassword' },});\n```",
  "title": "Runtime API Reference | ZenStack",
  "description": "Runtime API references",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/zmodel-language",
  "markdown": "# ZModel Language Reference | ZenStack\n\n## Overview[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#overview \"Direct link to Overview\")\n\n**ZModel**, the modeling DSL of ZenStack, is the main concept you'll deal with when using this toolkit. The ZModel syntax is a superset of [Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema). Therefore, every valid Prisma schema is a valid ZModel.\n\ninfo\n\nWe made that choice to extend the Prisma schema for several reasons:\n\n*   Creating a new ORM adds little value to the community. Instead, extending Prisma - the overall best ORM toolkit for Typescript - sounds more sensible.\n    \n*   Prisma's schema language is simple and intuitive.\n    \n*   Extending an existing popular language lowers the learning curve compared to inventing a new one.\n    \n\nHowever, the standard capability of Prisma schema doesn't allow us to build the functionalities we want in a natural way, so we made a few extensions to the language by adding the following:\n\n1.  Custom attributes\n2.  Custom attribute functions\n3.  Built-in attributes and functions for defining access policies\n4.  Built-in attributes for defining field validation rules\n5.  Utility attributes like `@password` and `@omit`\n6.  Multi-schema files support\n\nSome of these extensions have been asked for by the Prisma community for some time, so we hope that ZenStack can be helpful even just as an extensible version of Prisma.\n\nThis section provides detailed descriptions of all aspects of the ZModel language, so you don't have to jump over to Prisma's documentation for extra learning.\n\n## Import[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#import \"Direct link to Import\")\n\nZModel allows to import other ZModel files. This is useful when you want to split your schema into multiple files for better organization. Under the hood, it will recursively merge all the imported schemas, and generate a single Prisma schema file for the Prisma CLI to consume.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#syntax \"Direct link to Syntax\")\n\n```\nimport [IMPORT_SPECIFICATION]\n```\n\n*   **\\[IMPORT\\_SPECIFICATION\\]**: Path to the ZModel file to be imported. It can be:\n    \n    *   An absolute path, e.g., \"/path/to/user\".\n    *   A relative path, e.g., \"./user\".\n    *   A module resolved to an installed NPM package, e.g., \"my-package/base\".\n    \n    If the import specification doesn't end with \".zmodel\", the resolver will automatically append it. Once a file is imported, all the declarations in that file will be included in the building process.\n    \n\n### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#examples \"Direct link to Examples\")\n\n```\n// there is a file called \"user.zmodel\" in the same directoryimport \"user\"\n```\n\n## Data source[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#data-source \"Direct link to Data source\")\n\nEvery model needs to include exactly one `datasource` declaration, providing information on how to connect to the underlying database.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#syntax-1 \"Direct link to Syntax\")\n\n```\ndatasource [NAME] {    provider = [PROVIDER]    url = [DB_URL]}\n```\n\n*   **\\[NAME\\]**:\n    \n    Name of the data source. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`. Name is only informational and serves no other purposes.\n    \n*   **\\[PROVIDER\\]**:\n    \n    Name of database connector. Valid values:\n    \n    *   sqlite\n    *   postgresql\n    *   mysql\n    *   sqlserver\n    *   cockroachdb\n*   **\\[DB\\_URL\\]**:\n    \n    Database connection string. Either a plain string or an invocation of `env` function to fetch from an environment variable.\n    \n\n### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#examples-1 \"Direct link to Examples\")\n\n```\ndatasource db {    provider = \"postgresql\"    url = \"postgresql://postgres:abc123@localhost:5432/todo?schema=public\"}\n```\n\nIt's highly recommended that you not commit sensitive database connection strings into source control. Alternatively, you can load it from an environment variable:\n\n```\ndatasource db {    provider = \"postgresql\"    url = env(\"DATABASE_URL\")}\n```\n\n### Supported databases[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#supported-databases \"Direct link to Supported databases\")\n\nZenStack uses [Prisma](https://prisma.io/ \":target=_blank\") to talk to databases, so all relational databases supported by Prisma are also supported by ZenStack.\n\nHere's a list for your reference:\n\nDatabase\n\nVersion\n\nPostgreSQL\n\n9.6\n\nPostgreSQL\n\n10\n\nPostgreSQL\n\n11\n\nPostgreSQL\n\n12\n\nPostgreSQL\n\n13\n\nPostgreSQL\n\n14\n\nPostgreSQL\n\n15\n\nMySQL\n\n5.6\n\nMySQL\n\n5.7\n\nMySQL\n\n8\n\nMariaDB\n\n10\n\nSQLite\n\n\\*\n\nAWS Aurora\n\n\\*\n\nAWS Aurora Serverless\n\n\\*\n\nMicrosoft SQL Server\n\n2022\n\nMicrosoft SQL Server\n\n2019\n\nMicrosoft SQL Server\n\n2017\n\nAzure SQL\n\n\\*\n\nCockroachDB\n\n21.2.4+\n\nYou can find the orignal list [here](https://www.prisma.io/docs/reference/database-reference/supported-databases \":target=_blank\").\n\n## Generator[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#generator \"Direct link to Generator\")\n\nGenerators are used for creating assets (usually code) from a Prisma schema. Check [here](https://www.prisma.io/docs/concepts/components/prisma-schema/generators) for a list of official and community generators.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#syntax-2 \"Direct link to Syntax\")\n\n```\ngenerator [GENERATOR_NAME] {    [OPTION]*}\n```\n\n*   **\\[GENERATOR\\_NAME\\]**\n    \n    Name of the generator. Needs to be unique in the entire model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[OPTION\\]**\n    \n    A generator configuration option, in form of \"\\[NAME\\] = \\[VALUE\\]\". A generator needs to have at least a \"provider\" option that specify its provider.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#example \"Direct link to Example\")\n\n```\ngenerator client {  provider = \"prisma-client-js\"  output   = \"./generated/prisma-client-js\"\n```\n\n## Plugin[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#plugin \"Direct link to Plugin\")\n\nPlugins are ZenStack's extensibility mechanism. It's usage is similar to [Generator](https://zenstack.dev/docs/1.x/reference/zmodel-language#generator). Users can define their own plugins to generate artifacts from the ZModel schema. Plugins differ from generators mainly in the following ways:\n\n*   They have a cleaner interface without the complexity of JSON-RPC.\n*   They use an easier-to-program AST representation than generators.\n*   They have access to language features that ZenStack adds to Prisma, like custom attributes and functions.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#syntax-3 \"Direct link to Syntax\")\n\n```\nplugin [PLUGIN_NAME] {    [OPTION]*}\n```\n\n*   **\\[PLUGIN\\_NAME\\]**\n    \n    Name of the plugin. Needs to be unique in the entire model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[OPTION\\]**\n    \n    A plugin configuration option, in form of \"\\[NAME\\] = \\[VALUE\\]\". A plugin needs to have at least a \"provider\" option that specify its provider.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#example-1 \"Direct link to Example\")\n\n```\nplugin swr {    provider = '@zenstackhq/swr'    output = 'lib/hooks'}\n```\n\n## Enum[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#enum \"Direct link to Enum\")\n\nEnums are container declarations for grouping constant identifiers. You can use them to express concepts like user roles, product categories, etc.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#syntax-4 \"Direct link to Syntax\")\n\n```\nenum [ENUM_NAME] {    [FIELD]*}\n```\n\n*   **\\[ENUM\\_NAME\\]**\n    \n    Name of the enum. Needs to be unique in the entire model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[FIELD\\]**\n    \n    Field identifier. Needs to be unique in the model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#example-2 \"Direct link to Example\")\n\n```\nenum UserRole {    USER    ADMIN}\n```\n\n## Model[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#model \"Direct link to Model\")\n\nModels represent the business entities of your application. A model inherits all fields and attributes from extended abstract models. Abstract models are eliminated in the generated prisma schema file.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#syntax-5 \"Direct link to Syntax\")\n\n```\n(abstract)? model [NAME] (extends [ABSTRACT_MODEL_NAME](,[ABSTRACT_MODEL_NAME])*)? {    [FIELD]*}\n```\n\n*   **\\[abstract\\]**:\n    \n    Optional. If present, the model is marked as abstract would not be mapped to a database table. Abstract models are only used as base classes for other models.\n    \n*   **\\[NAME\\]**:\n    \n    Name of the model. Needs to be unique in the entire model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[FIELD\\]**:\n    \n    Arbitrary number of fields. See [next section](https://zenstack.dev/docs/1.x/reference/zmodel-language#field) for details.\n    \n*   **\\[ABSTRACT\\_MODEL\\_NAME\\]**:\n    \n    Name of an abstract model.\n    \n\n### Note[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#note \"Direct link to Note\")\n\nA model must include a field marked with `@id` attribute. The `id` field serves as a unique identifier for a model entity and is mapped to the database table's primary key.\n\nSee [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#attribute) for more details about attributes.\n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#example-3 \"Direct link to Example\")\n\n```\nabstract model Basic {    id String @id    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt}model User extends Basic {    name String }\n```\n\nThe generated prisma file only contains one `User` model:\n\n```\nmodel User {    id String @id    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    name String @id}\n```\n\n## Attribute[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#attribute \"Direct link to Attribute\")\n\nAttributes decorate fields and models and attach extra behaviors or constraints to them.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#syntax-6 \"Direct link to Syntax\")\n\n#### Field attribute[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#field-attribute \"Direct link to Field attribute\")\n\nField attribute name is prefixed by a single `@`.\n\n```\nid String @[ATTR_NAME](ARGS)?\n```\n\n*   **\\[ATTR\\_NAME\\]**\n\nAttribute name. See [below](https://zenstack.dev/docs/1.x/reference/zmodel-language#predefined-attributes) for a full list of attributes.\n\n*   **\\[ARGS\\]**\n\nSee [attribute arguments](https://zenstack.dev/docs/1.x/reference/zmodel-language#arguments).\n\n#### Model attribute[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#model-attribute \"Direct link to Model attribute\")\n\nField attribute name is prefixed double `@@`.\n\n```\nmodel Model {    @@[ATTR_NAME](ARGS)?}\n```\n\n*   **\\[ATTR\\_NAME\\]**\n\nAttribute name. See [below](https://zenstack.dev/docs/1.x/reference/zmodel-language#predefined-attributes) for a full list of attributes.\n\n*   **\\[ARGS\\]**\n\nSee [attribute arguments](https://zenstack.dev/docs/1.x/reference/zmodel-language#arguments).\n\n### Arguments[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#arguments \"Direct link to Arguments\")\n\nAttribute can be declared with a list of parameters and applied with a comma-separated list of arguments.\n\nArguments are mapped to parameters by position or by name. For example, for the `@default` attribute declared as:\n\n```\nattribute @default(_ value: ContextType)\n```\n\n, the following two ways of applying it are equivalent:\n\n```\npublished Boolean @default(value: false)\n```\n\n```\npublished Boolean @default(false)\n```\n\n### Parameter types[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#parameter-types \"Direct link to Parameter types\")\n\nAttribute parameters are typed. The following types are supported:\n\n*   Int\n    \n    Integer literal can be passed as argument.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @password(saltLength: Int?, salt: String?)\n    ```\n    \n    application:\n    \n    ```\n    password String @password(saltLength: 10)\n    ```\n    \n*   String\n    \n    String literal can be passed as argument.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @id(map: String?)\n    ```\n    \n    application:\n    \n    ```\n    id String @id(map: \"_id\")\n    ```\n    \n*   Boolean\n    \n    Boolean literal or expression can be passed as argument.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @@allow(_ operation: String, _ condition: Boolean)\n    ```\n    \n    application:\n    \n    ```\n    @@allow(\"read\", true)@@allow(\"update\", auth() != null)\n    ```\n    \n*   ContextType\n    \n    A special type that represents the type of the field onto which the attribute is attached.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @default(_ value: ContextType)\n    ```\n    \n    application:\n    \n    ```\n    f1 String @default(\"hello\")f2 Int @default(1)\n    ```\n    \n*   FieldReference\n    \n    References to fields defined in the current model.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @relation(    _ name: String?,    fields: FieldReference[]?,    references: FieldReference[]?,    onDelete: ReferentialAction?,    onUpdate: ReferentialAction?,    map: String?)\n    ```\n    \n    application:\n    \n    ```\n    model Model {    ...    // [ownerId] is a list of FieldReference    owner Owner @relation(fields: [ownerId], references: [id])    ownerId}\n    ```\n    \n*   Enum\n    \n    Attribute parameter can also be typed as predefined enum.\n    \n    E.g., declaration:\n    \n    ```\n    attribute @relation(    _ name: String?,    fields: FieldReference[]?,    references: FieldReference[]?,    // ReferentialAction is a predefined enum    onDelete: ReferentialAction?,    onUpdate: ReferentialAction?,    map: String?)\n    ```\n    \n    application:\n    \n    ```\n    model Model {    // 'Cascade' is a predefined enum value    owner Owner @relation(..., onDelete: Cascade)}\n    ```\n    \n\nAn attribute parameter can be typed as any of the types above, a list of the above type, or an optional of the types above.\n\n```\n    model Model {        ...        f1 String        f2 String        // a list of FieldReference        @@unique([f1, f2])    }\n```\n\n### Attribute functions[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#attribute-functions \"Direct link to Attribute functions\")\n\nAttribute functions are used for providing values for attribute arguments, e.g., current `DateTime`, an autoincrement `Int`, etc. They can be used in place of attribute arguments, like:\n\n```\nmodel Model {    ...    serial Int @default(autoincrement())    createdAt DateTime @default(now())}\n```\n\nYou can find a list of predefined attribute functions [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#predefined-attribute-functions).\n\n### Predefined attributes[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#predefined-attributes \"Direct link to Predefined attributes\")\n\n#### Field attributes[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#field-attributes \"Direct link to Field attributes\")\n\n##### @id[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#id \"Direct link to @id\")\n\n```\nattribute @id(map: String?)\n```\n\nDefines an ID on the model.\n\n_Params_:\n\nName\n\nDescription\n\nmap\n\nThe name of the underlying primary key constraint in the database\n\n##### @default[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#default \"Direct link to @default\")\n\n```\nattribute @default(_ value: ContextType)\n```\n\nDefines a default value for a field.\n\n_Params_:\n\nName\n\nDescription\n\nvalue\n\nThe default value expression\n\n##### @unique[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#unique \"Direct link to @unique\")\n\n```\nattribute @unique(map: String?)\n```\n\nDefines a unique constraint for this field.\n\n_Params_:\n\nName\n\nDescription\n\nmap\n\nThe name of the underlying primary key constraint in the database\n\n##### @relation[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#relation \"Direct link to @relation\")\n\n```\nattribute @relation(    _ name: String?,    fields: FieldReference[]?,     references: FieldReference[]?,     onDelete: ReferentialAction?,    onUpdate: ReferentialAction?,    map: String?)\n```\n\nDefines meta information about a relation.\n\n_Params_:\n\nName\n\nDescription\n\nname\n\nThe name of the relationship\n\nfields\n\nA list of fields defined in the current model\n\nreferences\n\nA list of fields of the model on the other side of the relation\n\nonDelete\n\nReferential action to take on delete. See details [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#referential-action).\n\nonUpdate\n\nReferential action to take on update. See details [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#referential-action).\n\n##### @map[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#map \"Direct link to @map\")\n\n```\nattribute @map(_ name: String)\n```\n\nMaps a field name or enum value from the schema to a column with a different name in the database.\n\n_Params_:\n\nName\n\nDescription\n\nmap\n\nThe name of the underlying column in the database\n\n##### @updatedAt[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#updatedat \"Direct link to @updatedAt\")\n\nAutomatically stores the time when a record was last updated.\n\n##### @ignore[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#ignore \"Direct link to @ignore\")\n\nExclude a field from the Prisma Client (for example, a field that you do not want Prisma users to update).\n\n##### @allow[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#allow \"Direct link to @allow\")\n\n```\nattribute @allow(_ operation: String, _ condition: Boolean)\n```\n\nDefines an access policy that allows the annotated field to be read or updated. Read more about access policies [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#access-policy).\n\n_Params_:\n\nName\n\nDescription\n\noperation\n\nComma separated list of operations to control, including `\"read\"` and `\"update\"`. Pass `\"all\"` as an abbreviation for including all operations.\n\ncondition\n\nBoolean expression indicating if the operations should be allowed\n\n##### @deny[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#deny \"Direct link to @deny\")\n\n```\nattribute @deny(_ operation: String, _ condition: Boolean)\n```\n\nDefines an access policy that denies the annotated field to be read or updated. Read more about access policies [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#access-policy).\n\n_Params_:\n\nName\n\nDescription\n\noperation\n\nComma separated list of operations to control, including `\"read\"` and `\"update\"`. Pass `\"all\"` as an abbreviation for including all operations.\n\ncondition\n\nBoolean expression indicating if the operations should be denied\n\n##### @password[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#password \"Direct link to @password\")\n\n```\nattribute @password(saltLength: Int?, salt: String?)\n```\n\nIndicates that the field is a password field and needs to be hashed before persistence.\n\n_NOTE_: ZenStack uses the \"bcryptjs\" library to hash passwords. You can use the `saltLength` parameter to configure the cost of hashing or use `salt` parameter to provide an explicit salt. By default, a salt length of 12 is used. See [here](https://www.npmjs.com/package/bcryptjs \":target=blank\") for more details.\n\n_Params_:\n\nName\n\nDescription\n\nsaltLength\n\nThe length of salt to use (cost factor for the hash function)\n\nsalt\n\nThe salt to use (a pregenerated valid salt)\n\n##### @omit[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#omit \"Direct link to @omit\")\n\nIndicates that the field should be omitted when read from the generated services. Commonly used together with `@password` attribute.\n\n##### @prisma.passthrough[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#prismapassthrough \"Direct link to @prisma.passthrough\")\n\n```\nattribute @prisma.passthrough(_ text: String)\n```\n\nA utility attribute for passing arbitrary text to the generated Prisma schema. This is useful as a workaround for dealing with discrepancies between Prisma schema and ZModel.\n\n_Params_:\n\nName\n\nDescription\n\ntext\n\nText to passthrough to Prisma schema\n\nE.g., the following ZModel content:\n\n```\nmodel User {    id Int @id @default(autoincrement())    name String @prisma.passthrough(\"@unique\")}\n```\n\nwil be translated to the following Prisma schema:\n\n```\nmodel User {    id Int @id @default(autoincrement())    name String @unique}\n```\n\n#### Model attributes[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#model-attributes \"Direct link to Model attributes\")\n\n##### @@id[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#id-1 \"Direct link to @@id\")\n\n```\nattribute @@id(_ fields: FieldReference[], name: String?, map: String?)\n```\n\nDefines a multi-field ID (composite ID) on the model.\n\n_Params_:\n\nName\n\nDescription\n\nfields\n\nA list of fields defined in the current model\n\nname\n\nThe name that the Client API will expose for the argument covering all fields\n\nmap\n\nThe name of the underlying primary key constraint in the database\n\n##### @@unique[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#unique-1 \"Direct link to @@unique\")\n\n```\nattribute @@unique(_ fields: FieldReference[], name: String?, map: String?)\n```\n\nDefines a compound unique constraint for the specified fields.\n\n_Params_:\n\nName\n\nDescription\n\nfields\n\nA list of fields defined in the current model\n\nname\n\nThe name of the unique combination of fields\n\nmap\n\nThe name of the underlying unique constraint in the database\n\n##### @@schema[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#schema \"Direct link to @@schema\")\n\n```\nattribute @@schema(_ name: String)\n```\n\nSpecifies the database schema to use in a [multi-schema setup](https://www.prisma.io/docs/guides/database/multi-schema).\n\n_Params_:\n\nName\n\nDescription\n\nname\n\nThe name of the database schema\n\n##### @@index[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#index \"Direct link to @@index\")\n\n```\nattribute @@index(_ fields: FieldReference[], map: String?)\n```\n\nDefines an index in the database.\n\n_Params_:\n\nName\n\nDescription\n\nfields\n\nA list of fields defined in the current model\n\nmap\n\nThe name of the underlying index in the database\n\n##### @@map[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#map-1 \"Direct link to @@map\")\n\n```\nattribute @@map(_ name: String)\n```\n\nMaps the schema model name to a table with a different name, or an enum name to a different underlying enum in the database.\n\n_Params_:\n\nName\n\nDescription\n\nname\n\nThe name of the underlying table or enum in the database\n\n##### @@ignore[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#ignore-1 \"Direct link to @@ignore\")\n\nExclude a model from the Prisma Client (for example, a model that you do not want Prisma users to update).\n\n##### @@allow[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#allow-1 \"Direct link to @@allow\")\n\n```\nattribute @@allow(_ operation: String, _ condition: Boolean)\n```\n\nDefines an access policy that allows a set of operations when the given condition is true. Read more about access policies [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#access-policy).\n\n_Params_:\n\nName\n\nDescription\n\noperation\n\nComma separated list of operations to control, including `\"create\"`, `\"read\"`, `\"update\"`, and `\"delete\"`. Pass `\"all\"` as an abbriviation for including all operations.\n\ncondition\n\nBoolean expression indicating if the operations should be allowed\n\n##### @@deny[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#deny-1 \"Direct link to @@deny\")\n\n```\nattribute @@deny(_ operation: String, _ condition: Boolean)\n```\n\nDefines an access policy that denies a set of operations when the given condition is true. Read more about access policies [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#access-policy).\n\n_Params_:\n\nName\n\nDescription\n\noperation\n\nComma separated list of operations to control, including `\"create\"`, `\"read\"`, `\"update\"`, and `\"delete\"`. Pass `\"all\"` as an abbriviation for including all operations.\n\ncondition\n\nBoolean expression indicating if the operations should be denied\n\n##### @@auth[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#auth \"Direct link to @@auth\")\n\nSpecify the model for resolving `auth()` function call in access policies. By default, the model named \"User\" is used. You can use this attribute to override the default behavior. A Zmodel can have at most one model with this attribute.\n\n##### @@prisma.passthrough[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#prismapassthrough-1 \"Direct link to @@prisma.passthrough\")\n\n```\nattribute @@prisma.passthrough(_ text: String)\n```\n\nA utility attribute for passing arbitrary text to the generated Prisma schema. This is useful as a workaround for dealing with discrepancies between Prisma schema and ZModel.\n\n_Params_:\n\nName\n\nDescription\n\ntext\n\nText to passthrough to Prisma schema\n\nE.g., the following ZModel content:\n\n```\nmodel User {    id Int @id @default(autoincrement())    name String    @@prisma.passthrough(\"@@unique([name])\")}\n```\n\nwil be translated to the following Prisma schema:\n\n```\nmodel User {    id Int @id @default(autoincrement())    name String    @@unique([name])}\n```\n\n### Predefined attribute functions[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#predefined-attribute-functions \"Direct link to Predefined attribute functions\")\n\n##### uuid()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#uuid \"Direct link to uuid()\")\n\n```\nfunction uuid(): String {}\n```\n\nGenerates a globally unique identifier based on the UUID spec.\n\n##### cuid()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#cuid \"Direct link to cuid()\")\n\n```\nfunction cuid(): String {}\n```\n\nGenerates a globally unique identifier based on the [CUID](https://github.com/ericelliott/cuid) spec.\n\n##### now()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#now \"Direct link to now()\")\n\n```\nfunction now(): DateTime {}\n```\n\nGets current date-time.\n\n##### autoincrement()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#autoincrement \"Direct link to autoincrement()\")\n\n```\nfunction autoincrement(): Int {}\n```\n\nCreates a sequence of integers in the underlying database and assign the incremented values to the ID values of the created records based on the sequence.\n\n##### dbgenerated()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#dbgenerated \"Direct link to dbgenerated()\")\n\n```\nfunction dbgenerated(expr: String): Any {}\n```\n\nRepresents default values that cannot be expressed in the Prisma schema (such as random()).\n\n##### auth()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#auth-1 \"Direct link to auth()\")\n\nGets the current login user. The return type of the function is the `User` model defined in the current ZModel.\n\n##### future()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#future \"Direct link to future()\")\n\n```\nfunction future(): Any {}\n```\n\nGets the \"post-update\" state of an entity. Only valid when used in a \"update\" access policy. Read more about access policies [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#access-policy).\n\n##### contains()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#contains \"Direct link to contains()\")\n\n```\n    function contains(field: String, search: String, caseInSensitive: Boolean?): Boolean {}\n```\n\nChecks if the given field contains the search string. The search string is case-sensitive by default. Use `caseInSensitive` to toggle the case sensitivity.\n\nEquivalent to Prisma's [contains](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#contains) operator.\n\n##### search()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#search \"Direct link to search()\")\n\n```\nfunction search(field: String, search: String): Boolean {}\n```\n\nChecks if the given field contains the search string using [full-text-search](https://www.prisma.io/docs/concepts/components/prisma-client/full-text-search).\n\nEquivalent to Prisma's [search](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#search) operator.\n\n##### startsWith()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#startswith \"Direct link to startsWith()\")\n\n```\nfunction startsWith(field: String, search: String): Boolean {}\n```\n\nChecks if the given field starts with the search string.\n\nEquivalent to Prisma's [startsWith](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#startswith) operator.\n\n##### endsWith()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#endswith \"Direct link to endsWith()\")\n\n```\nfunction endsWith(field: String, search: String): Boolean {}\n```\n\nChecks if the given field ends with the search string.\n\nEquivalent to Prisma's [endsWith](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#endswith) operator.\n\n##### has()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#has \"Direct link to has()\")\n\n```\nfunction has(field: Any[], search: Any): Boolean {}\n```\n\nCheck if the given field (list) contains the search value.\n\nEquivalent to Prisma's [has](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#has) operator.\n\n##### hasEvery()[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#hasevery \"Direct link to hasEvery()\")\n\n```\nfunction hasEvery(field: Any[], search: Any[]): Boolean {}\n```\n\nCheck if the given field (list) contains every element of the search list.\n\nEquivalent to Prisma's [hasEvery](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#hasevery) operator.\n\n##### hasSome[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#hassome \"Direct link to hasSome\")\n\n```\nfunction hasSome(field: Any[], search: Any[]): Boolean {}\n```\n\nCheck if the given field (list) contains at least one element of the search list.\n\nEquivalent to Prisma's [hasSome](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#hassome) operator.\n\n##### isEmpty[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#isempty \"Direct link to isEmpty\")\n\n```\nfunction isEmpty(field: Any[]): Boolean {}\n```\n\nCheck if the given field (list) is empty.\n\nEquivalent to Prisma's [isEmpty](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#isempty) operator.\n\n### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#examples-2 \"Direct link to Examples\")\n\nHere're some examples on using field and model attributes:\n\n```\nmodel User {    // unique id field with a default UUID value    id String @id @default(uuid())    // require email field to be unique    email String @unique    // password is hashed with bcrypt with length of 16, omitted when returned from the CRUD services    password String @password(saltLength: 16) @omit    // default to current date-time    createdAt DateTime @default(now())    // auto-updated when the entity is modified    updatedAt DateTime @updatedAt    // mapping to a different column name in database    description String @map(\"desc\")    // mapping to a different table name in database    @@map(\"users\")    // use @@index to specify fields to create database index for    @@index([email])    // use @@allow to specify access policies    @@allow(\"create,read\", true)    // use auth() to reference the current user    // use future() to access the \"post-update\" state    @@allow(\"update\", auth() == this && future().email == email)}\n```\n\n### Custom attributes and functions[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#custom-attributes-and-functions \"Direct link to Custom attributes and functions\")\n\nYou can find examples of custom attributes and functions in [ZModel Standard Library](https://github.com/zenstackhq/zenstack/blob/main/packages/schema/src/res/stdlib.zmodel).\n\n## Field[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#field \"Direct link to Field\")\n\nFields are typed members of models.\n\n### Syntax[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#syntax-7 \"Direct link to Syntax\")\n\n```\nmodel Model {    [FIELD_NAME] [FIELD_TYPE] (FIELD_ATTRIBUTES)?}\n```\n\n*   **\\[FIELD\\_NAME\\]**\n    \n    Name of the field. Needs to be unique in the containing model. Needs to be a valid identifier matching regular expression `[A-Za-z][a-za-z0-9_]\\*`.\n    \n*   **\\[FIELD\\_TYPE\\]**\n    \n    Type of the field. Can be a scalar type or a reference to another model.\n    \n    The following scalar types are supported:\n    \n    *   String\n    *   Boolean\n    *   Int\n    *   BigInt\n    *   Float\n    *   Decimal\n    *   Json\n    *   Bytes\n    *   [Unsupported types](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#unsupported-types)\n    \n    A field's type can be any of the scalar or reference type, a list of the aforementioned type (suffixed with `[]`), or an optional of the aforementioned type (suffixed with `?`).\n    \n*   **\\[FIELD\\_ATTRIBUTES\\]**\n    \n    Field attributes attach extra behaviors or constraints to the field. See [Attribute](https://zenstack.dev/docs/1.x/reference/zmodel-language#attribute) for more information.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#example-4 \"Direct link to Example\")\n\n```\nmodel Post {    // \"id\" field is a mandatory unique identifier of this model    id String @id @default(uuid())    // fields can be DateTime    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    // or string    title String    // or integer    viewCount Int @default(0)    // and optional    content String?    // and a list too    tags String[]    // and can reference another model too    comments Comment[]}\n```\n\n## Relation[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#relation-1 \"Direct link to Relation\")\n\nRelations are connections among models. There're three types of relations:\n\n*   One-to-one\n*   One-to-many\n*   Many-to-many\n\nRelations are expressed with a pair of fields and together with the special `@relation` field attribute. One side of the relation field carries the `@relation` attribute to indicate how the connection is established.\n\n### One-to-one relation[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#one-to-one-relation \"Direct link to One-to-one relation\")\n\nThe _owner_ side of the relation declares an optional field typed as the model of the _owned_ side of the relation.\n\nOn the _owned_ side, a reference field is declared with `@relation` attribute, together with a **foreign key** field storing the id of the owner entity.\n\n```\nmodel User {    id String @id    profile Profile?}model Profile {    id String @id    user User @relation(fields: [userId], references: [id])    userId String @unique}\n```\n\n### One-to-many relation[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#one-to-many-relation \"Direct link to One-to-many relation\")\n\nThe _owner_ side of the relation declares a list field typed as the model of the _owned_ side of the relation.\n\nOn the _owned_ side, a reference field is declared with `@relation` attribute, together with a **foreign key** field storing the id of the owner entity.\n\n```\nmodel User {    id String @id    posts Post[]}model Post {    id String @id    author User? @relation(fields: [authorId], references: [id])    authorId String?}\n```\n\n### Many-to-many relation[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#many-to-many-relation \"Direct link to Many-to-many relation\")\n\nA _join model_ is declared to connect the two sides of the relation using two one-to-one relations.\n\nEach side of the relation then establishes a one-to-many relation with the _join model_.\n\n```\nmodel Space {    id String @id    // one-to-many with the \"join-model\"    members Membership[]}// Membership is the \"join-model\" between User and Spacemodel Membership {    id String @id()    // one-to-many from Space    space Space @relation(fields: [spaceId], references: [id])    spaceId String    // one-to-many from User    user User @relation(fields: [userId], references: [id])    userId String    // a user can be member of a space for only once    @@unique([userId, spaceId])}model User {    id String @id    // one-to-many with the \"join-model\"    membership Membership[]}\n```\n\n### Self-relations[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#self-relations \"Direct link to Self-relations\")\n\nA relation field referencing its own model is called \"self-relation\". ZModel's represents self-relation in the same way as Prisma does. Please refer to the [Prisma documentation](https://www.prisma.io/docs/concepts/components/prisma-schema/relations/self-relations) for more details.\n\n### Referential action[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#referential-action \"Direct link to Referential action\")\n\nWhen defining a relation, you can specify what happens when one side of a relation is updated or deleted. See [Referential action](https://zenstack.dev/docs/1.x/reference/zmodel-language#referential-action) for details.\n\n## Access policy[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#access-policy \"Direct link to Access policy\")\n\n### Model-level policy[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#model-level-policy \"Direct link to Model-level policy\")\n\nModel-level access policies are defined with `@@allow` and `@@deny` attributes. They specify the eligibility of an operation over a model entity. The signatures of the attributes are:\n\n*   `@@allow`\n    \n    ```\n        attribute @@allow(_ operation: String, _ condition: Boolean)\n    ```\n    \n    _Params_:\n    \n    Name\n    \n    Description\n    \n    operation\n    \n    Comma separated list of operations to control, including `\"create\"`, `\"read\"`, `\"update\"`, and `\"delete\"`. Pass `\"all\"` as an abbreviation for including all operations.\n    \n    condition\n    \n    Boolean expression indicating if the operations should be allowed\n    \n*   `@@deny`\n    \n    ```\n        attribute @@deny(_ operation: String, _ condition: Boolean)\n    ```\n    \n    _Params_:\n    \n    Name\n    \n    Description\n    \n    operation\n    \n    Comma separated list of operations to control, including `\"create\"`, `\"read\"`, `\"update\"`, and `\"delete\"`. Pass `\"all\"` as an abbreviation for including all operations.\n    \n    condition\n    \n    Boolean expression indicating if the operations should be denied\n    \n\n### Field-level policy[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#field-level-policy \"Direct link to Field-level policy\")\n\nField-level access policies are defined with `@allow` and `@deny` attributes. They control whether the annotated field can be read or updated. If a field fails \"read\" check, it'll be deleted when returned. If a field is set to be updated but fails \"update\" check, the update operation will be rejected.\n\nNote that it's not allowed to put \"update\" rule on relation fields, because whether an entity can be updated shouldn't be determined indirectly by a relation, but directly by the entity itself. However, you can put \"update\" rule on a foreign key field to control how a a relation can be updated.\n\nThe signatures of the attributes are:\n\n*   `@allow`\n    \n    ```\n        attribute @allow(_ operation: String, _ condition: Boolean, _ override: Boolean?)\n    ```\n    \n    _Params_:\n    \n    Name\n    \n    Description\n    \n    Default\n    \n    operation\n    \n    Comma separated list of operations to control, including `\"read\"` and `\"update\"`. Pass `\"all\"` as an abbreviation for including all operations.\n    \n    condition\n    \n    Boolean expression indicating if the operations should be allowed\n    \n    override\n    \n    Boolean indicating if the field-level policy should override model-level ones. See [here](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/field-level#overriding-model-level-policies) for more details.\n    \n    false\n    \n*   `@deny`\n    \n    ```\n        attribute @deny(_ operation: String, _ condition: Boolean)\n    ```\n    \n    _Params_:\n    \n    Name\n    \n    Description\n    \n    operation\n    \n    Comma separated list of operations to control, including \\`\\`\"read\"`and`\"update\"`. Pass` \"all\"\\` as an abbreviation for including all operations.\n    \n    condition\n    \n    Boolean expression indicating if the operations should be denied\n    \n\n### Policy expressions[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#policy-expressions \"Direct link to Policy expressions\")\n\nPolicy rules use boolean expressions to make verdicts. ZModel provides a set of literals and operators for constructing expressions of arbitrary complexity.\n\n```\nExpression ::= Literal | Array | This | Null | Reference | MemberAccess | Invocation | Binary | Unary | CollectionPredicateLiteral ::= String | Number | BooleanArray ::= \"[\" Expression [, Expression]* \"]\"This ::= \"this\"Null ::= \"null\"Reference ::= IdentifierMemberAccess ::= Expression \".\" IdentifierOperator_Precedence#tableBinary ::= Expression (\"==\" | \"!=\" | \">\" | \"<\" | \">=\" | \"<=\" | \"&&\" | \"||\" || \"in\")Unary ::= \"!\" ExpressionCollectionPredicate ::= Expression (\"?\" | \"!\" | \"^\") \"[\" Expression \"]\"\n```\n\nBinary operator precedence follows [Javascript's rules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/).\n\nCollection predicate expressions are used for reaching into relation fields. You can find more details [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#collection-predicate-expressions).\n\n### Using authentication in policy rules[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#using-authentication-in-policy-rules \"Direct link to Using authentication in policy rules\")\n\nIt's very common to use the current login user to verdict if an operation should be permitted. Therefore, ZenStack provides a built-in `auth()` attribute function that evaluates to the `User` entity corresponding to the current user. To use the function, your ZModel file must define a `User` model or a model marked with the `@@auth` attribute.\n\nYou can use `auth()` to:\n\n*   Check if a user is logged in\n    \n    ```\n    @@deny('all', auth() == null)\n    ```\n    \n*   Access user's fields\n    \n    ```\n    @@allow('update', auth().role == 'ADMIN')\n    ```\n    \n*   Compare user identity\n    \n    ```\n    // owner is a relation field to User model@@allow('update', auth() == owner)\n    ```\n    \n\n### Accessing relation fields in policy[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#accessing-relation-fields-in-policy \"Direct link to Accessing relation fields in policy\")\n\nAs you've seen in the examples above, you can access fields from relations in policy expressions. For example, to express \"a user can be read by any user sharing a space\" in the `User` model, you can directly read into its `membership` field.\n\n```\n    @@allow('read', membership?[space.members?[user == auth()]])\n```\n\nIn most cases, when you use a \"to-many\" relation in a policy rule, you'll use \"Collection Predicate\" to express a condition. See [next section](https://zenstack.dev/docs/1.x/reference/zmodel-language#collection-predicate-expressions) for details.\n\n### Collection predicate expressions[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#collection-predicate-expressions \"Direct link to Collection predicate expressions\")\n\nCollection predicate expressions are boolean expressions used to express conditions over a list. It's mainly designed for building policy rules for \"to-many\" relations. It has three forms of syntaxes:\n\n*   Any\n    \n    Any element in `collection` matches `condition`\n    \n*   All\n    \n    All elements in `collection` match `condition`\n    \n*   None\n    \n    None element in `collection` matches `condition`\n    \n\nThe `condition` expression has direct access to fields defined in the model of `collection`. E.g.:\n\n```\n    @@allow('read', members?[user == auth()])\n```\n\n, in condition `user == auth()`, `user` refers to the `user` field in model `Membership`, because the collection `members` is resolved to `Membership` model.\n\nAlso, collection predicates can be nested to express complex conditions involving multi-level relation lookup. E.g.:\n\n```\n    @@allow('read', membership?[space.members?[user == auth()]])\n```\n\nIn this example, `user` refers to `user` field of `Membership` model because `space.members` is resolved to `Membership` model.\n\n### Combining multiple rules[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#combining-multiple-rules \"Direct link to Combining multiple rules\")\n\nA model can contain an arbitrary number of policy rules. The logic of combining model-level rules is as follows:\n\n*   The operation is rejected if any of the conditions in `@@deny` rules evaluate to `true`.\n*   Otherwise, the operation is permitted if any of the conditions in `@@allow` rules evaluate to `true`.\n*   Otherwise, the operation is rejected.\n\nA field can also contain an arbitrary number of policy rules. The logic of combining field-level rules is as follows:\n\n*   The operation is rejected if any of the conditions in `@deny` rules evaluate to `true`.\n*   Otherwise, if there exists any `@allow` rule and at least one of them evaluates to `true`, the operation is permitted.\n*   Otherwise, if there exists any `@allow` rule but none one of them evaluates to `true`, the operation is rejected.\n*   Otherwise, the operation is permitted.\n\nPlease note the difference between model-level and field-level rules. Model-level access are by-default denied, while field-level access are by-default allowed.\n\n### Pre-update vs. post-update[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#pre-update-vs-post-update \"Direct link to Pre-update vs. post-update\")\n\nWhen an access policy rule is applied to a mutate operation, the entities under operation have a \"pre\" and \"post\" state. For a \"create\" rule, its \"pre\" state is empty, so the rule implicitly refers to the \"post\" state. For a \"delete\" rule, its \"post\" state is empty, so the rule implicitly refers to the \"pre\" state.\n\nHowever, for \"update\" rules it is ambiguous; both the \"pre\" and the \"post\" states exist. By default, for \"update\" rules, fields referenced in the expressions refer to the \"pre\" state, and you can use the `future()` function to refer to the \"post\" state explicitly.\n\nIn the following example, the \"update\" rule uses `future()` to ensure an update cannot alter the post's owner.\n\n```\nmodel Post {    id String @id @default(uuid())    title String @length(1, 100)    author User @relation(fields: [authorId], references: [id], onDelete: Cascade)    authorId String    // update can only be done by the author, and is not allowed to change author    @@allow('update', author == auth() && future().author == author)}\n```\n\ninfo\n\nThe `future()` function is not supported in field-level access policies. To express post-update rules, put them into model-level policies.\n\n### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#examples-3 \"Direct link to Examples\")\n\n#### A simple example with Post model[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#a-simple-example-with-post-model \"Direct link to A simple example with Post model\")\n\n```\nmodel Post {    // reject all operations if user's not logged in    @@deny('all', auth() == null)    // allow all operations if the entity's owner matches the current user    @@allow('all', auth() == owner)    // posts are readable to anyone    @allow('read', true)}\n```\n\n#### A more complex example with multi-user spaces[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#a-more-complex-example-with-multi-user-spaces \"Direct link to A more complex example with multi-user spaces\")\n\n```\nmodel Space {    id String @id    members Membership[]    owner User @relation(fields: [ownerId], references: [id])    ownerId String    // require login    @@deny('all', auth() == null)    // everyone can create a space    @@allow('create', true)    // owner can do everything    @@allow('all', auth() == owner)    // any user in the space can read the space    //    // Here the <collection>?[condition] syntax is called    // \"Collection Predicate\", used to check if any element    // in the \"collection\" matches the \"condition\"    @@allow('read', members?[user == auth()])}// Membership is the \"join-model\" between User and Spacemodel Membership {    id String @id()    // one-to-many from Space    space Space @relation(fields: [spaceId], references: [id])    spaceId String    // one-to-many from User    user User @relation(fields: [userId], references: [id])    userId String    // a user can be member of a space for only once    @@unique([userId, spaceId])    // require login    @@deny('all', auth() == null)    // space owner can create/update/delete    @@allow('create,update,delete', space.owner == auth())    // user can read entries for spaces which he's a member of    @@allow('read', space.members?[user == auth()])}model User {    id String @id    email String @unique    membership Membership[]    ownedSpaces Space[]    // allow signup    @@allow('create', true)    // user can do everything to herself; note that \"this\" represents    // the current entity    @@allow('all', auth() == this)    // can be read by users sharing a space    @@allow('read', membership?[space.members?[user == auth()]])}\n```\n\n## Data validation[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#data-validation \"Direct link to Data validation\")\n\n### Overview[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#overview-1 \"Direct link to Overview\")\n\nData validation is used for attaching constraints to field values. Unlike access policies, field validation rules cannot access the current user with the `auth()` function and are only checked for 'create' and 'update' operations. The main purpose of field validation is to ensure data integrity and consistency, not for access control.\n\nThe [`@core/zod`](https://zenstack.dev/docs/1.x/reference/plugins/zod) plugin recognizes the validation attributes and includes them into the generated Zod schemas.\n\n### Field-level validation attributes[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#field-level-validation-attributes \"Direct link to Field-level validation attributes\")\n\nThe following attributes can be used to attach validation rules to individual fields:\n\n#### String[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#string \"Direct link to String\")\n\n*   `@length(_ min: Int?, _ max: Int?, _ message: String?)`\n    \n    Validates length of a string field.\n    \n*   `@startsWith(_ text: String, _ message: String?)`\n    \n    Validates a string field value starts with the given text.\n    \n*   `@endsWith(_ text: String, _ message: String?)`\n    \n    Validates a string field value ends with the given text.\n    \n*   `@contains(_text: String, _ message: String?)`\n    \n    Validates a string field value contains the given text.\n    \n*   `@email(_ message: String?)`\n    \n    Validates a string field value is a valid email address.\n    \n*   `@url(_ message: String?)`\n    \n    Validates a string field value is a valid url.\n    \n*   `@datetime(_ message: String?)`\n    \n    Validates a string field value is a valid ISO datetime.\n    \n*   `@regex(_ regex: String, _ message: String?)`\n    \n    Validates a string field value matches a regex.\n    \n*   `@trim(_ value: String)`\n    \n    Trims whitespace.\n    \n*   `@lower(_ value: String)`\n    \n    Converts to lowercase.\n    \n*   `@upper(_ value: String)`\n    \n    Converts to uppercase.\n    \n\ninfo\n\nAttributes `@trim`, `@lower`, and `@upper` are actually \"transformation\" instead of \"validation\". They make sure the values are transformed before storing into the database.\n\n#### Number[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#number \"Direct link to Number\")\n\n*   `@gt(_ value: Int, _ message: String?)`\n    \n    Validates a number field is greater than the given value.\n    \n*   `@gte(_ value: Int, _ message: String?)`\n    \n    Validates a number field is greater than or equal to the given value.\n    \n*   `@lt(_ value: Int, _ message: String?)`\n    \n    Validates a number field is less than the given value.\n    \n*   `@lte(_ value: Int, _ message: String?)`\n    \n    Validates a number field is less than or equal to the given value.\n    \n\n### Model-level validation attributes[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#model-level-validation-attributes \"Direct link to Model-level validation attributes\")\n\nYou can use the `@@validate` attribute to attach validation rules to a model.\n\n```\n@@validate(_ value: Boolean, _ message: String?)\n```\n\nModel-level rules can reference multiple fields, use relation operators (`==`, `!=`, `>`, `>=`, `<`, `<=`) to compare fields, use boolean operators (`&&`, `||`, and `!`) to compose conditions, and can use the following functions to evaluate conditions for fields:\n\n*   `function length(field: String, min: Int, max: Int?): Boolean`\n    \n    Validates length of a string field.\n    \n*   `function regex(field: String, regex: String): Boolean`\n    \n    Validates a string field value matches a regex.\n    \n*   `function email(field: String): Boolean`\n    \n    Validates a string field value is a valid email address.\n    \n*   `function datetime(field: String): Boolean`\n    \n    Validates a string field value is a valid ISO datetime.\n    \n*   `function url(field: String)`\n    \n    Validates a string field value is a valid url.\n    \n*   `function contains(field: String, search: String, caseInSensitive: Boolean?): Boolean`\n    \n    Validates a string field contains the search string.\n    \n*   `function startsWith(field: String, search: String): Boolean`\n    \n    Validates a string field starts with the search string.\n    \n*   `function endsWith(field: String, search: String): Boolean`\n    \n    Validates a string field ends with the search string.\n    \n*   `function has(field: Any[], search: Any): Boolean`\n    \n    Validates a list field contains the search value.\n    \n*   `function hasEvery(field: Any[], search: Any[]): Boolean`\n    \n    Validates a list field contains every element in the search list.\n    \n*   `function hasSome(field: Any[], search: Any[]): Boolean`\n    \n    Validates a list field contains some elements in the search list.\n    \n*   `function isEmpty(field: Any[]): Boolean`\n    \n    Validates a list field is null or empty.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#example-5 \"Direct link to Example\")\n\n```\nmodel User {    id String @id    handle String @regex(\"^[0-9a-zA-Z]{4,16}$\")    email String? @email @endsWith(\"@myorg.com\", \"must be an email from myorg.com\")    profileImage String? @url    age Int @gte(18)    activated Boolean @default(false)    @@validate(!activated || email != null, \"activated user must have an email\")}\n```\n\n## Referential action[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#referential-action-1 \"Direct link to Referential action\")\n\n### Overview[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#overview-2 \"Direct link to Overview\")\n\nWhen defining a relation, you can use referential action to control what happens when one side of a relation is updated or deleted by setting the `onDelete` and `onUpdate` parameters in the `@relation` attribute.\n\n```\nattribute @relation(    _ name: String?,    fields: FieldReference[]?,    references: FieldReference[]?,    onDelete: ReferentialAction?,    onUpdate: ReferentialAction?,    map: String?)\n```\n\nThe `ReferentialAction` enum is defined as:\n\n```\nenum ReferentialAction {    Cascade    Restrict    NoAction    SetNull    SetDefault}\n```\n\n*   `Cascade`\n    \n    *   **onDelete**: deleting a referenced record will trigger the deletion of referencing record.\n        \n    *   **onUpdate**: updates the relation scalar fields if the referenced scalar fields of the dependent record are updated.\n        \n*   `Restrict`\n    \n    *   **onDelete**: prevents the deletion if any referencing records exist.\n    *   **onUpdate**: prevents the identifier of a referenced record from being changed.\n*   `NoAction`\n    \n    Similar to 'Restrict', the difference between the two is dependent on the database being used.\n    \n    See details [here](https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions#noaction \":target=blank\")\n    \n*   `SetNull`\n    \n    *   **onDelete**: the scalar field of the referencing object will be set to NULL.\n    *   **onUpdate**: when updating the identifier of a referenced object, the scalar fields of the referencing objects will be set to NULL.\n*   `SetDefault`\n    \n    *   **onDelete**: the scalar field of the referencing object will be set to the fields default value.\n    *   **onUpdate**: the scalar field of the referencing object will be set to the fields default value.\n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/zmodel-language#example-6 \"Direct link to Example\")\n\n```\nmodel User {    id String @id    profile Profile?}model Profile {    id String @id    user @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)    userId String @unique}\n```",
  "title": "ZModel Language Reference | ZenStack",
  "description": "ZModel language references",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/category/plugins",
  "markdown": "# Plugins | ZenStack\n\n[\n\n## üìÑÔ∏è @zenstackhq/tanstack-query\n\nPlugin for generating Tanstack Query query and mutation hooks\n\n](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query)",
  "title": "Plugins | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/category/server-adapters",
  "markdown": "# Server Adapters | ZenStack\n\nVersion: 1.x\n\n[\n\n## üìÑÔ∏è Next.js\n\nAdapter for integrating with Next.js\n\n](https://zenstack.dev/docs/1.x/reference/server-adapters/next)\n\n[\n\n## üìÑÔ∏è Nuxt\n\nAdapter for integrating with Nuxt\n\n](https://zenstack.dev/docs/1.x/reference/server-adapters/nuxt)\n\n[\n\n## üìÑÔ∏è SvelteKit\n\nAdapter for integrating with SvelteKit\n\n](https://zenstack.dev/docs/1.x/reference/server-adapters/sveltekit)\n\n[\n\n## üìÑÔ∏è Express.js\n\nAdapter for integrating with Express.js\n\n](https://zenstack.dev/docs/1.x/reference/server-adapters/express)\n\n[\n\n## üìÑÔ∏è Fastify\n\nAdapter for integrating with Fastify\n\n](https://zenstack.dev/docs/1.x/reference/server-adapters/fastify)\n\n[\n\n## üóÉÔ∏è API Handlers\n\n2 items\n\n](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/)",
  "title": "Server Adapters | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/error-handling",
  "markdown": "# Error Handling | ZenStack\n\nZenStack's enhancements to Prisma clients are transparent proxies, so normal errors thrown from a Prisma client simply pass through, and you can handle them the same way as you do in a regular Prisma project. It's good to read these references from Prisma:\n\nThe enhanced Prisma client can throw extra errors when an operation is rejected by [access policies](https://zenstack.dev/docs/1.x/reference/zmodel-language#access-policy) or its data fails [validation rules](https://zenstack.dev/docs/1.x/reference/zmodel-language#data-validation). To keep a consistent programming experience, a `PrismaClientKnownRequestError` is thrown with code [`P2004`](https://www.prisma.io/docs/reference/api-reference/error-reference#p2004) is used in such cases:\n\n```\nthrow new PrismaClientKnownRequestError(message, {    clientVersion: getVersion(),    code: 'P2004',    meta: ...});\n```\n\nThe error contains a `meta` field providing more information about the error. It contains the following fields:",
  "title": "Error Handling | ZenStack",
  "description": "Error handling",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/limitations",
  "markdown": "# Limitations | ZenStack\n\nThis section lists the current limitations of ZenStack.\n\n### Sequential operations transaction[‚Äã](https://zenstack.dev/docs/1.x/reference/limitations#sequential-operations-transaction \"Direct link to Sequential operations transaction\")\n\n[Sequential operations transaction](https://www.prisma.io/docs/concepts/components/prisma-client/transactions#sequential-prisma-client-operations) is not supported by enhanced Prisma clients yet.\n\nAs a workaround, use [interactive transactions](https://www.prisma.io/docs/concepts/components/prisma-client/transactions#interactive-transactions) instead.\n\n### MongoDB is not supported[‚Äã](https://zenstack.dev/docs/1.x/reference/limitations#mongodb-is-not-supported \"Direct link to MongoDB is not supported\")\n\nRight now, the focus of this project is SQL databases, and there's no plan to support MongoDB in the near future.\n\n### Edge runtime is not supported[‚Äã](https://zenstack.dev/docs/1.x/reference/limitations#edge-runtime-is-not-supported \"Direct link to Edge runtime is not supported\")\n\nPrisma by default doesn't support running in edge runtime environments (e.g. [Vercel Edge Runtime](https://edge-runtime.vercel.app/)). Its [Accelerate](https://www.prisma.io/data-platform/accelerate) commercial service does support edge, but ZenStack is not compatible with it yet. We plan to support it in the near future.\n\n### Cloudflare D1 database is not supported[‚Äã](https://zenstack.dev/docs/1.x/reference/limitations#cloudflare-d1-database-is-not-supported \"Direct link to Cloudflare D1 database is not supported\")\n\nPrisma doesn't support interactive transactions with D1 databases. ZenStack relies on the feature to enforce access policies in certain cases.",
  "title": "Limitations | ZenStack",
  "description": "Current limitations",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/plugins/zod",
  "markdown": "# @core/zod | ZenStack\n\nThe schemas for validating the models and input data for creating and updating the models. They contain field's typing and [validation rules](https://zenstack.dev/docs/reference/zmodel-language#data-validation). The module exports several Zod schemas for each model for different use cases. To facilitate the discussion, let's use the following model as an example:\n\n*   _\\[Model\\]Schema_\n    \n    The schema for validating the model itself, including all scalar fields, foreign key fields, and relation fields. All relation fields are optional.\n    \n    ```\n    const PostSchema = z.object({  id: z.number(),  title: z.string().min(10).max(255),  published: z.boolean(),  createdAt: z.date(),  updatedAt: z.date(),  author: z.record(z.unknown()).optional(),  authorId: z.number(),});\n    ```\n    \n*   _\\[Model\\]CreateScalarSchema_\n    \n    The schema for validating the input for creating the model. It only includes scalar fields. All fields are required unless it's optional in the model or has a default value.\n    \n    ```\n    const PostCreateScalarSchema = z.object({  id: z.number().optional(),  title: z.string().min(10).max(255),  published: z.boolean().optional(),  createdAt: z.date().optional(),  updatedAt: z.date().optional(),});\n    ```\n    \n*   _\\[Model\\]CreateSchema_\n    \n    The schema for validating the input for creating the model. It's similar to `[Model]CreateScalarSchema` but includes foreign key fields. You can use it to validate create input that involves setting foreign keys.\n    \n    ```\n    const PostCreateSchema = z.object({  id: z.number().optional(),  title: z.string().min(10).max(255),  published: z.boolean().optional(),  createdAt: z.date().optional(),  updatedAt: z.date().optional(),  authorId: z.number(),});\n    ```\n    \n*   _\\[Model\\]UpdateScalarSchema_\n    \n    The schema for validating the input for updating the model. It only includes scalar fields. All fields are optional (since in Prisma's semantic, all updates are patching).\n    \n    ```\n    const PostUpdateScalarSchema = z.object({  id: z.number(),  title: z.string().min(10).max(255),  published: z.boolean(),  createdAt: z.date(),  updatedAt: z.date(),}).partial();\n    ```\n    \n*   _\\[Model\\]UpdateSchema_\n    \n    Similar to `[Model]UpdateScalarSchema` but includes foreign key fields (all optional). You can use it to validate update input that involves setting foreign keys.\n    \n    ```\n    const PostUpdateSchema = z.object({  id: z.number(),  title: z.string().min(10).max(255),  published: z.boolean(),  createdAt: z.date(),  updatedAt: z.date(),  authorId: z.number(),}).partial();\n    ```\n    \n*   _\\[Model\\]???WithoutRefinementSchema_\n    \n    This includes `[Model]WithoutRefinementSchema`, `[Model]CreateWithoutRefinementSchema`, and `[Model]UpdateWithoutRefinementSchema`. These are only generated when a model contains `@@validate` model-level data validation rules.\n    \n    The `@@validate` rules are translated into `z.refine()` calls. For example, for the `Post` model, the following refinement function is generated:\n    \n    ```\n    function refinePost<T, D extends z.ZodTypeDef>(schema: z.ZodType<T, D, T>) {  return schema.refine((value: any) => new RegExp('^[A-Za-z0-9 ]+$').test(value?.title));}\n    ```\n    \n    However, zod has a limitation that, when you call `.refine()` on a `ZodObject` schema, the result won't be an object schema anymore, which means that you can't use `.omit()`, `.partial()`, etc. `ZodObject` methods to further tune it for your needs anymore. That's why a series of `WithoutRefinementSchema` schemas are exported. They are the Zod schemas prior to calling the `refine()` method. If you need to make changes to the schema while still preserving the `@@validate` rules, you can manipulate the `WithoutRefinementSchema` schemas and then call the `refine` function manually on the result. E.g.:\n    \n    ```\n    const myPostCreateSchema = refinePost(PostCreateWithoutRefinementSchema.omit({id: true}));\n    ```\n    \n*   _\\[Model\\]PrismaCreateSchema_\n    \n    Used internally by ZenStack.\n    \n*   _\\[Model\\]PrismaUpdateSchema_\n    \n    Used internally by ZenStack.",
  "title": "@core/zod | ZenStack",
  "description": "Built-in plugin for generating Zod schemas for validating CRUD input arguments",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/access-policy/field-level",
  "markdown": "# Field-Level Policies | ZenStack\n\nIn the previous parts, we've introduced how to write model-level policies to control CRUD permissions. In database terms, this is called row-level security. With the power of relation traversal, current user access, and flexible expressions and functions, you are fully equipped to handle most real-world authorization scenarios. Sometimes, however, you'll find yourself needing more fine-grained access control.\n\nZenStack's field-level policies allow you to define access rules for individual fields. For example, you can allow a blog post's owner to update its title and content, but only users with the \"EDITOR\" role can change the \"published\" field.\n\nThe combination of model-level and field-level policies gives you the ultimate granularity and flexibility and lets ZenStack surpass Postgres's native [row-level-security](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) capabilities.\n\n### Defining Field-Level Policies[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/field-level#defining-field-level-policies \"Direct link to Defining Field-Level Policies\")\n\nTo define field-level policies, you use the `@allow` and `@deny` field-level attributes to attach rules to fields. Beware that field-level attributes always start with a single `@`. Here's an example:\n\n```\nmodel Post {    ...    published Boolean @allow('update', auth().role == EDITOR)}\n```\n\ninfo\n\nYou can't use `future()` function in field-level access policies. To express post-update rules, put them into model-level policies. We have an active [feature request](https://github.com/zenstackhq/zenstack/issues/671) for it.\n\n### Difference Between Field-Level and Model-Level Policies[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/field-level#difference-between-field-level-and-model-level-policies \"Direct link to Difference Between Field-Level and Model-Level Policies\")\n\nA few key differences between field-level policies and model-level policies:\n\n*   Field-level policies only support \"read\", \"update\", and \"all\" operations. It's not meaningful to control \"create\" and \"delete\" permissions at the field level.\n*   Field-level access is allowed by default. If you don't attach any rule to a field, it's accessible as long as the model is accessible. On the contrary, model-level access is denied by default. You'll have to explicitly open up access using `@@allow` attributes.\n\n### Behavior of Field-Level Access Control[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/field-level#behavior-of-field-level-access-control \"Direct link to Behavior of Field-Level Access Control\")\n\nA field's accessibility is determined in the following order:\n\n*   If no access policies are defined for the field, the operation is allowed\n*   If any `@deny` rule is satisfied, the operation is denied\n*   If some `@allow` rules are defined, and none of them are satisfied, the operation is denied\n*   Otherwise, the operation is allowed\n\nWhen a \"read\" operation is denied, the field is dropped from the result. When an \"update\" operation is denied, the operation is rejected with an error.\n\n### Overriding Model-Level Policies[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/field-level#overriding-model-level-policies \"Direct link to Overriding Model-Level Policies\")\n\nTo successfully \"read\" or \"update\" a field, the current user must first satisfy the corresponding model-level policies unless the field-level `@allow` attribute is passed with a third argument `true` to override.\n\n```\nmodel Post {    ...    published Boolean @allow('update', auth().role == EDITOR, true)    @@allow('update', !published)}\n```\n\nIn the example above, if a `Post` is published, although the model-level policy denies updates, an EDITOR user can still update the `published` field (and only this field) because of the overriding setting on the field-level policy. Without the override flag, the update operation will be denied.\n\nYou can use this feature with \"read\" policies, too. If a field has an override \"read\" policy, the field can be read if it's explicitly selected in the query, even if the model-level policy denies access.\n\n### üõ†Ô∏è Adding Field-Level Policies[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/field-level#%EF%B8%8F-adding-field-level-policies \"Direct link to üõ†Ô∏è Adding Field-Level Policies\")\n\nBack to where we left off in the previous chapter, let's tighten up our schema and prevent the `ownerId` field from being updated for `List` and `Todo`:\n\nschema.zmodel\n\n```\nmodel List {    ...    ownerId Int @default(auth().id) @deny('update', true)}model Todo {    ...    ownerId Int @default(auth().id) @deny('update', true)}\n```\n\nRerun generation and start REPL:\n\n```\nnpx zenstack generatenpx zenstack repl\n```\n\nFirst, create a new `List` using Joey (id #1):\n\n```\n.auth { id: 1 }db.list.create({ data: { title: \"Joey' List\", private: true, owner: { connect: { id: 1 } }, space: { connect: { id: 1 } } } })\n```\n\nResult:\n\n```\n{  id: 4,  createdAt: 2023-11-09T05:36:20.264Z,  updatedAt: 2023-11-09T05:36:20.264Z,  spaceId: 1,  ownerId: 1,  title: \"Joey' List\",  private: true}\n```\n\nTry to update the `owner` field to Rachel (id #2):\n\n```\ndb.list.update({ where: { id: 1 }, data: { owner: { connect: 2 } } })\n```\n\nThe operation is denied:\n\n```\ndenied by policy: list entities failed 'update' check, entity { id: 1 } failed update policy check for field \"owner\"Code: P2004Meta: { reason: 'ACCESS_POLICY_VIOLATION' }\n```",
  "title": "Field-Level Policies | ZenStack",
  "description": "In the previous parts, we've introduced how to write model-level policies to control CRUD permissions. In database terms, this is called row-level security. With the power of relation traversal, current user access, and flexible expressions and functions, you are fully equipped to handle most real-world authorization scenarios. Sometimes, however, you'll find yourself needing more fine-grained access control.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/plugins/prisma",
  "markdown": "# @core/prisma | ZenStack\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "@core/prisma | ZenStack",
  "description": "Built-in plugin for generating Prisma schema",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/telemetry",
  "markdown": "# Telemetry | ZenStack\n\nZenStack CLI and VSCode extension sends anonymous telemetry for analyzing usage stats and finding bugs.\n\nWe don't collect any telemetry at the runtime of apps built with ZenStack.\n\nWe appreciate that you keep the telemetry ON so we can keep improving the toolkit. We follow the [Console Do Not Track](https://consoledonottrack.com/ \":target=blank\") convention, and you can turn off the telemetry by setting the environment variable `DO_NOT_TRACK` to `1`:\n\n```\nDO_NOT_TRACK=1 npx zenstack ...\n```",
  "title": "Telemetry | ZenStack",
  "description": "Telemetry",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/plugins/trpc",
  "markdown": "# @zenstackhq/trpc | ZenStack\n\nThe `@zenstackhq/trpc` plugin generates a [tRPC router](https://trpc.io/docs/router) to make database CRUD calls. You can use it directly as your main router or merge it with other routers to create a more complex setup. The router syntactically mirrors the APIs of a standard Prisma client, including the function names and shapes of parameters (hooks directly use types generated by Prisma).\n\ninfo\n\nThe `@zenstackhq/trpc` plugin depends on the [`@core/zod`](https://zenstack.dev/docs/reference/plugins/zod) plugin to generate Zod schemas for the routers' input, and will enable that plugin automatically if it's not already enabled.\n\nThis plugin is based on [prisma-trpc-generator](https://github.com/omar-dulaimi/prisma-trpc-generator). Thanks to [Omar Dulaimi](https://github.com/omar-dulaimi) for making this happen!\n\n### Installation[‚Äã](https://zenstack.dev/docs/reference/plugins/trpc#installation \"Direct link to Installation\")\n\n```\nnpm install --save-dev @zenstackhq/trpc\n```\n\n### Options[‚Äã](https://zenstack.dev/docs/reference/plugins/trpc#options \"Direct link to Options\")\n\n| Name | Type | Description | Required | Default |\n| --- | --- | --- | --- | --- |\n| output | String | Output directory (relative to the path of ZModel) | Yes |     |\n| generateModels | String, String\\[\\] | Array or comma separated string for the models to generate routers for. | No  | All models |\n| generateModelActions | String, String\\[\\] | Array or comma separated string for actions to generate for each model: `create`, `findUnique`, `update`, etc. | No  | All supported Prisma actions |\n| generateClientHelpers | String, String\\[\\] | Array or comma separated string for the types of client helpers to generate. Supported values: \"react\" or \"next\". See [here](https://zenstack.dev/docs/reference/plugins/trpc#client-helpers) for more details. | No  |     |\n| zodSchemasImport | String | Import path for the generated zod schemas. The trpc plugin relies on the `@core/zod` plugin to generate zod schemas for input validation. If you set a custom output location for the zod schemas, you can use this option to override the import path. | No  | @zenstackhq/runtime/zod |\n\ninfo\n\nWhen `@core/zod` plugin is automatically enabled by the `@zenstackhq/trpc` plugin, if the `@zenstackhq/trpc` plugin has a `generateModels` option specified, it'll be carried over to the `@core/zod` plugin as well.\n\n## Dependencies[‚Äã](https://zenstack.dev/docs/reference/plugins/trpc#dependencies \"Direct link to Dependencies\")\n\n*   [`@core/zod`](https://zenstack.dev/docs/reference/plugins/zod)\n\n### Details[‚Äã](https://zenstack.dev/docs/reference/plugins/trpc#details \"Direct link to Details\")\n\n#### Preparing tRPC Context[‚Äã](https://zenstack.dev/docs/reference/plugins/trpc#preparing-trpc-context \"Direct link to Preparing tRPC Context\")\n\nThe generated tRPC routers require a `prisma` field in the context and you need to make sure to include it when creating the context. You can use any PrismaClient instance for it, but most likely you want to use one created with [`enhance`](https://zenstack.dev/docs/reference/runtime-api#enhance) so that the client enforces access control policies.\n\n```\nexport const createContext = async ({ req, res }: CreateNextContextOptions) => {    const session = await getServerAuthSession({ req, res });    return {        session,        // use access-control-enabled db client        prisma: enhance(prisma, { user: session?.user }),    };};\n```\n\n#### Client Helpers[‚Äã](https://zenstack.dev/docs/reference/plugins/trpc#client-helpers \"Direct link to Client Helpers\")\n\nTRPC relies on TypeScript's type inference to provide the client-side API call signatures. This is very neat and powerful, but it has some limitations regarding generic APIs. For example, one of the best features of Prisma's API is its output type automatically adapts to the input's shape. e.g.:\n\n```\nconst post = await prisma.post.findFirst({ include: { author: true } });\n```\n\nFor the code above, the `post` variable is smartly inferred to be of type `Post & { author: User }`. However, if you wrap it with tRPC, such typing adaptivity is lost:\n\n```\n// trpc routerconst router = t.router({  findFirst: t.procedure    .input(PostInputSchema)    .query(({ ctx, input }) => ctx.prisma.findFirst(input))})// client sideconst { data } = trpc.post.findFirst({ include: { author: true } });\n```\n\nNow the `data` field has a fixed `Post` type, even though at runtime it carries the extra `author` field.\n\nTo mitigate this limitation, ZenStack's tRPC plugin can generate a \"type-fixing\" helper that re-enables the inference power from the client side. To use it, you need to specify the `generateClientHelpers` option:\n\n```\nplugin trpc {  provider = '@zenstackhq/trpc'  output = 'server/routers/generated'  generateClientHelpers = 'next'}\n```\n\nUse value \"next\" if you're using tRPC with Next.js, or \"react\" if using it with react-query. With that option on, the plugin generates an extra \"client\" folder containing helpers that do the type fixing. The only code change you need to make is instead of calling the `createTRPCNext` or `createTRPCReact` API, you call the one generated instead.\n\nHere's an example of how to use it with Next.js:\n\n```\nimport { createTRPCNext } from 'server/routers/generated/client/next';export const trpc = createTRPCNext<AppRouter>({    ...});\n```\n\n### Example[‚Äã](https://zenstack.dev/docs/reference/plugins/trpc#example \"Direct link to Example\")\n\nHere's an example with a blogging app:\n\n/schema.zmodel\n\n```\nplugin trpc {  provider = '@zenstackhq/trpc'  output = 'server/routers/generated'  generateModelActions = 'create,update,findUnique,findMany'}model User {  id            String    @id @default(cuid())  email         String  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)}model Post {  id        String @id @default(cuid())  title     String  published Boolean @default(false)  author    User @relation(fields: [authorId], references: [id])  authorId  String  // author has full access  @@allow('all', auth() == author)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\n/server/routers/\\_app.ts\n\n```\nimport { createRouter as createCRUDRouter } from './generated/routers';import { initTRPC } from '@trpc/server';import { type Context } from '../context';const t = initTRPC.context<Context>().create();export const appRouter = createCRUDRouter(t.router, t.procedure);export type AppRouter = typeof appRouter;\n```\n\nCheck out the [Using With tRPC](https://zenstack.dev/docs/guides/trpc) guide for more details about using ZenStack in a tRPC project.",
  "title": "@zenstackhq/trpc | ZenStack",
  "description": "Plugin for generating tRPC data query routes",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/plugins/openapi",
  "markdown": "# @zenstackhq/openapi | ZenStack\n\n```\nmodel User {    id String @id    email String @unique    @@openapi.meta({        security: [ { basic: [] } ],        tagDescription: 'Operations for managing users',        findMany: {            description: 'Find users matching the given conditions'        },        delete: {            method: 'put',            path: 'dodelete',            description: 'Delete a unique user',            summary: 'Delete a user yeah yeah',            tags: ['delete', 'user'],        },        createMany: {            security: [],            deprecated: true        }    })}\n```",
  "title": "@zenstackhq/openapi | ZenStack",
  "description": "Plugin for generating OpenAPI 3.0 specifications",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/server-adapters/nuxt",
  "markdown": "# Nuxt | ZenStack\n\n```\n// create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n```\n\n```\n{    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n```",
  "title": "Nuxt | ZenStack",
  "description": "Adapter for integrating with Nuxt",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/plugins/enhancer",
  "markdown": "# @core/enhancer | ZenStack\n\nVersion: 2.x\n\nThe `@core/enhancer` plugin generates JavaScript modules that support runtime enhancement of Prisma Client. The generated modules include the following:\n\n*   enhance\n    \n    The `enhance` API that creates a proxy around a `PrismaClient` instance to extend its behavior. When using the default output location, you can import this API from `@zenstackhq/runtime`.\n    \n*   model-meta\n    \n    Lightweight runtime representation of ZModel's AST.\n    \n*   policy\n    \n    Partial Prisma query input objects and input checker functions compiled from access policy expressions.\n    \n\ninfo\n\nThis plugin is always automatically included when `zenstack generate` is run. You only need to add it to your ZModel if you want to customize its options.\n\n### Installation[‚Äã](https://zenstack.dev/docs/reference/plugins/enhancer#installation \"Direct link to Installation\")\n\nThis plugin is built-in to ZenStack and does not need to be installed separately.\n\n### Options[‚Äã](https://zenstack.dev/docs/reference/plugins/enhancer#options \"Direct link to Options\")\n\n| Name | Type | Description | Required | Default |\n| --- | --- | --- | --- | --- |\n| output | String | Output directory (relative to the path of ZModel) | No  | node\\_modules/.zenstack |\n| compile | Boolean | If the generated TS code should be compiled to JS | No  | true |\n| preserveTsFiles | Boolean | If the generated TS files should be preserved (after compiled to JS) | No  | true if `compile` is set to false, otherwise false |\n\n### Example[‚Äã](https://zenstack.dev/docs/reference/plugins/enhancer#example \"Direct link to Example\")\n\n/schema.zmodel\n\n```\nplugin enhancer {  provider = '@core/enhancer'  output = 'src/lib/zenstack'  compile = false}\n```\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "@core/enhancer | ZenStack",
  "description": "Built-in plugin for generating JavaScript modules that support runtime enhancement of Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/server-adapters/express",
  "markdown": "# Express.js | ZenStack\n\n```\n// create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n```\n\n```\n{    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n```",
  "title": "Express.js | ZenStack",
  "description": "Adapter for integrating with Express.js",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/server-adapters/api-handlers/",
  "markdown": "# API Handlers | ZenStack\n\nVersion: 2.x\n\nZenStack supports two API styles: _**rpc**_ and _**rest**_:\n\n*   _**rpc**_ style API directly mirrors Prisma client's API, thus provides endpoints like `[model]/findMany`, `[model]/create`, etc. Its input and output data format also aligns with that of Prisma client.\n    \n*   _**rest**_ style API is designed to be more RESTful, thus provides endpoints like `[model]`, `[model]/[id]`, `[model]/[id]/relationships/[relationship]`, etc. It uses [JSON:API](https://jsonapi.org/) as its data format.\n    \n\nAPI handlers are framework-agnostic and deals with canonicalized request and response objects. It's the responsibility of the server adapters to translate the framework-specific request and response types. You can use either of these two API handlers with any server adapter.\n\nThe following diagram illustrates their relationships with server adapters.\n\n![ZModel Generation](https://zenstack.dev/img/intro/api-handler-light.png)![ZModel Generation](https://zenstack.dev/img/intro/api-handler-dark.png)\n\nCheckout the reference pages for detailed information about these API handlers:\n\n*   [RPC API Handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc)\n*   [RESTful API Handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "API Handlers | ZenStack",
  "description": "ZenStack supports two API styles",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/plugins/swr",
  "markdown": "# @zenstackhq/swr | ZenStack\n\nThe `@zenstackhq/swr` plugin generates [SWR](https://swr.vercel.app/) hooks that call into the CRUD services provided by the [server adapters](https://zenstack.dev/docs/category/server-adapters).\n\nThe hooks syntactically mirror the APIs of a standard Prisma client, including the function names and shapes of parameters (hooks directly use types generated by Prisma).\n\nTo use the generated hooks, you need to install \"swr\" version 2.0.0 or above.\n\n### Installation[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#installation \"Direct link to Installation\")\n\n```\nnpm install --save-dev @zenstackhq/swr\n```\n\n### Context Provider[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#context-provider \"Direct link to Context Provider\")\n\nThe plugin generates a React context provider which you can use to configure the behavior of the hooks. The following options are available on the provider:\n\n*   endpoint\n    \n    The endpoint to use for the queries. Defaults to \"/api/model\".\n    \n*   fetch\n    \n    A custom `fetch` function to use for the queries. Defaults to the browser's built-in `fetch`.\n    \n\nExample for using the context provider:\n\n```\nimport { FetchFn, Provider as ZenStackHooksProvider } from '../lib/hooks';// custom fetch function that adds a custom headerconst myFetch: FetchFn = (url, options) => {    options = options ?? {};    options.headers = {        ...options.headers,        'x-my-custom-header': 'hello world',    };    return fetch(url, options);};function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {    return (        <ZenStackHooksProvider value={{ endpoint: '/api/model', fetch: myFetch }}>            <AppContent />        </ZenStackHooksProvider>    );}export default MyApp;\n```\n\n### Options[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#options \"Direct link to Options\")\n\n| Name | Type | Description | Required | Default |\n| --- | --- | --- | --- | --- |\n| output | String | Output directory (relative to the path of ZModel) | Yes |     |\n\n### Hooks Signature[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#hooks-signature \"Direct link to Hooks Signature\")\n\nThe generated hooks have the following signature convention.\n\n*   **Query Hooks**\n    \n    ```\n    function use[Operation][Model](args?, options?);\n    ```\n    \n    *   `[Operation]`: query operation. E.g., \"FindMany\", \"FindUnique\", \"Count\".\n    *   `[Model]`: the name of the model. E.g., \"Post\".\n    *   `args`: Prisma query args. E.g., `{ where: { published: true } }`.\n    *   `options`: swr options.\n    \n    The `data` field returned by the hooks call contains the Prisma query result.\n    \n*   **Mutation Hooks**\n    \n    ```\n    function use[Operation][Model](options?);\n    ```\n    \n    *   `[Operation]`: mutation operation. E.g., \"Create\", \"UpdateMany\".\n    *   `[Model]`: the name of the model. E.g., \"Post\".\n    *   `options`: swr options.\n    \n    The `trigger` function returned with the hooks call takes the corresponding Prisma mutation args as input. E.q., `{ data: { title: 'Post1' } }`.\n    \n\n### Example[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#example \"Direct link to Example\")\n\nHere's a quick example with a blogging app. You can find a fully functional Todo app example [here](https://github.com/zenstackhq/sample-todo-nextjs).\n\n#### Schema[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#schema \"Direct link to Schema\")\n\n/schema.zmodel\n\n```\nplugin hooks {  provider = '@zenstackhq/swr'  output = \"./src/lib/hooks\"}model User {  id            String    @id @default(cuid())  email         String  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)}model Post {  id        String @id @default(cuid())  title     String  published Boolean @default(false)  author    User @relation(fields: [authorId], references: [id])  authorId  String  // author has full access  @@allow('all', auth() == author)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\n#### Using Query and Mutation Hooks[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#using-query-and-mutation-hooks \"Direct link to Using Query and Mutation Hooks\")\n\n/src/components/posts.tsx\n\n```\nimport type { Post } from '@prisma/client';import { useFindManyPost, useCreatePost } from '../lib/hooks';// post list componentconst Posts = ({ userId }: { userId: string }) => {    const { trigger: createPost } = useCreatePost();    // list all posts that're visible to the current user, together with their authors    const { data: posts } = useFindManyPost({        include: { author: true },        orderBy: { createdAt: 'desc' },    });    function onCreatePost() {        createPost({            data: {                title: 'My awesome post',                authorId: userId,            },        });    }    return (        <>            <button onClick={onCreatePost}>Create</button>            <ul>                {posts?.map((post) => (                    <li key={post.id}>                        {post.title} by {post.author.email}                    </li>                ))}            </ul>        </>    );};\n```\n\n### Automatic Optimistic Update[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#automatic-optimistic-update \"Direct link to Automatic Optimistic Update\")\n\nOptimistic update is a technique that allows you to update the data cache immediately when a mutation executes while waiting for the server response. It helps achieve a more responsive UI. SWR provides the [infrastructure for implementing it](https://swr.vercel.app/docs/mutation#optimistic-updates).\n\nThe ZenStack-generated mutation hooks allow you to opt-in to \"automatic optimistic update\" by passing the `optimisticUpdate` option when calling the hook. When the mutation executes, it analyzes the current queries in the cache and tries to find the ones that need to be updated. When the mutation settles (either succeeded or failed), the queries are invalidated to trigger a re-fetch.\n\nHere's an example:\n\n```\nconst { trigger: create } = useCreatePost({ optimisticUpdate: true });function onCreatePost() {    create({ ... })}\n```\n\nWhen `create` executes, if there are active queries like `useFindManyPost()`, the data of the mutation call will be optimistically inserted into the head of the query result.\n\n#### Details of the optimistic behavior[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#details-of-the-optimistic-behavior \"Direct link to Details of the optimistic behavior\")\n\n*   `create` mutation inserts item to the head of the query results of the corresponding `useFindMany` queries.\n*   `update` mutation updates the item in the query results of `useFindXXX` queries and their nested reads by matching the item's ID.\n*   `delete` mutation removes the item from the query results of the corresponding `useFindMany` queries and sets `null` to `useFindUnique` and `useFindFirst` query results, by matching the item's ID.\n\n#### Limitations[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#limitations \"Direct link to Limitations\")\n\n*   The automatic optimistic update relies on ID matching. It only works for queries that select the ID field(s).\n*   Non-entity-fetching queries like `count`, `aggregate`, and `groupBy` are not affected.\n*   Infinite queries are not affected.\n*   It doesn't respect filter conditions or access policies that potentially affect the queries under update. For example, for query `useFindManyPost({ where: { published: true }})`, when a non-published `Post` is created, it'll still be inserted into the query result.\n\n#### Opt-out[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#opt-out \"Direct link to Opt-out\")\n\nBy default, all queries opt into automatic optimistic update. You can opt-out on a per-query basis by passing `false` to the `optimisticUpdate` option.\n\n```\n// arguments are query args, query options, and optimisticUpdateconst { data } = useFindManyPost(    { where: { published: true } },    { optimisticUpdate: false });\n```\n\nWhen a query opts out, it won't be updated by a mutation, even if the mutation is set to update optimistically.\n\n### Fine-Grained Optimistic Update[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#fine-grained-optimistic-update \"Direct link to Fine-Grained Optimistic Update\")\n\nAutomatic optimistic update is convenient, but there might be cases where you want to explicitly control how the update happens. You can use the `optimisticUpdateProvider` callback to fully customize how each query cache entry should be optimistically updated. When the callback is set, it takes precedence over the automatic optimistic logic.\n\n```\nuseCreatePost({  optimisticUpdateProvider: ({ queryModel, queryOperation, queryArgs, currentData, mutationArgs }) => {    return { kind: 'Update', data: ... /* computed result */ };  }});\n```\n\nThe callback is invoked for each query cache entry and receives the following arguments in a property bag:\n\n*   `queryModel`: The model of the query, e.g., `Post`.\n*   `queryOperation`: The operation of the query, e.g., `findMany`, `count`.\n*   `queryArgs`: The arguments of the query, e.g., `{ where: { published: true } }`.\n*   `currentData`: The current cache data.\n*   `mutationArgs`: The arguments of the mutation, e.g., `{ data: { title: 'My awesome post' } }`.\n\nIt should return a result object with the following fields:\n\n*   `kind`: The kind of the optimistic update.\n    *   `Update`: update the cache using the computed data\n    *   `Skip`: skip the update\n    *   `ProceedDefault`: use the default automatic optimistic behavior.\n*   `data`: The computed data to update the cache with. Only used when `kind` is `Update`.\n\n### Using Infinite Query[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#using-infinite-query \"Direct link to Using Infinite Query\")\n\nSee [SWR's documentation](https://swr.vercel.app/docs/pagination) for more details.\n\n/src/components/posts.tsx\n\n```\nimport type { Post } from '@prisma/client';import { useInfiniteFindManyPost } from '../lib/hooks';// post list component with infinite loadingconst Posts = ({ userId }: { userId: string }) => {    const PAGE_SIZE = 10;    const { data: pages, size, setSize } = useInfiniteFindManyPost(        (pageIndex, previousPageData) => {            if (previousPageData && !previousPageData.length) {                return null;            }            return {                include: { author: true },                orderBy: { createdAt: 'desc' },                take: PAGE_SIZE,                skip: pageIndex * PAGE_SIZE,            };        }    );    const isEmpty = pages?.[0]?.length === 0;    const isReachingEnd = isEmpty || (pages && pages[pages.length - 1].length < PAGE_SIZE);    return (        <>            <ul>                {pages?.map((posts, index) => (                    <React.Fragment key={index}>                        {posts?.map((post) => (                            <li key={post.id}>                                {post.title} by {post.author.email}                            </li>                        ))}                    </React.Fragment>                ))}            </ul>            {!isReachingEnd && (                <button onClick={() => setSize(size + 1)}>                    Load more                </button>            )}        </>    );};\n```\n\n## Advanced[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#advanced \"Direct link to Advanced\")\n\n### Query Invalidation[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#query-invalidation \"Direct link to Query Invalidation\")\n\nThe mutation hooks generated by ZenStack automatically invalidates the queries that are potentially affected by the changes. For example, if you create a `Post`, the `useFindManyPost` query will be automatically invalidated when the mutation succeeds. Invalidation causes cache to be purged and fresh data to be refetched.\n\nThe automatic invalidation takes care of nested read, write, and delete cascading.\n\n**1\\. Nested Read**\n\nNested reads are also subject to automatic invalidation. For example, if you create a `Post`, the query made by\n\n```\nuseFindUniqueUser({ where: { id: userId }, include: { posts: true } });\n```\n\nwill be invalidated.\n\n**2\\. Nested Write**\n\nSimilarly, nested writes also trigger automatic invalidation. For example, if you create a `Post` in a nested update to `User` like:\n\n```\nupdateUser({ where: { id: userId }, posts: { create: { title: 'post1' } } });\n```\n\nThe mutation will cause queries like `useFindManyPost()` to be invalidated.\n\n**3\\. Delete Cascade**\n\nIn ZModel, relations can be configured to cascade delete, e.g.:\n\n```\nmodel User {    ...    posts Post[]}model Post {    ...    user User @relation(fields: [userId], references: [id], onDelete: Cascade)    userId Int}\n```\n\nWhen a `User` is deleted, the `Post` entities it owns will be deleted automatically. The generated hooks takes cascade delete into account. For example, if you delete a `User`, `Post` model will be considered as affected and queries like `useFindManyPost()` will be invalidated.\n\ninfo\n\nThe automatic invalidation is enabled by default, and you can use the `revalidate` option to opt-out and handle revalidation by yourself.\n\n```\nuseCreatePost({ revalidate: false });\n```\n\n### Query Key[‚Äã](https://zenstack.dev/docs/reference/plugins/swr#query-key \"Direct link to Query Key\")\n\nQuery keys serve as unique identifiers for organizing the query cache. The generated hooks use the following query key scheme:\n\n```\nJSON.stringify({ prefix: 'zenstack', model, operation, args, flags })\n```\n\nFor example, the query key for\n\n```\nuseFindUniqueUser({ where: { id: '1' } })\n```\n\nwill be:\n\n```\nJSON.stringify({     prefix: 'zenstack',    model: 'User',     operation: 'findUnique',     args: { where: { id: '1' } },     flags: { infinite: false } })\n```\n\nYou can use the generated `getQueryKey` function to compute it.",
  "title": "@zenstackhq/swr | ZenStack",
  "description": "Plugin for generating SWR query and mutation hooks",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/server-adapters/nestjs",
  "markdown": "# NestJS | ZenStack\n\n## NestJS Adapter\n\nThe `@zenstackhq/server/nestjs` module provides a quick way to install a ZenStack-enhanced Prisma service as a dependency injection provider onto a [NestJS](https://nestjs.com/) application.\n\n### Installation[‚Äã](https://zenstack.dev/docs/reference/server-adapters/nestjs#installation \"Direct link to Installation\")\n\n```\nnpm install @zenstackhq/server\n```\n\n### Registering the provider[‚Äã](https://zenstack.dev/docs/reference/server-adapters/nestjs#registering-the-provider \"Direct link to Registering the provider\")\n\nYou can register the enhanced Prisma service by importing the `ZenStackModule` NestJS module.\n\n```\nimport { ZenStackModule } from '@zenstackhq/server/nestjs';import { enhance } from '@zenstackhq/runtime';import { PrismaService } from './prisma.service';@Module({  imports: [    ZenStackModule.registerAsync({      useFactory: (prisma: PrismaService) => {        return {          getEnhancedPrisma: () => enhance(prisma, { user: ... }),        };      },      inject: [PrismaService],      extraProviders: [PrismaService],    }),  ],})export class AppModule {}\n```\n\nThe `registerAsync` API takes as input a factory function that returns a config used for creating an enhanced prisma service. The config contains a callback function where you should create and return an enhanced `PrismaClient`. It'll be called each time a Prisma method is invoked.\n\nYou'll usually pass in a user context when calling `enhance` inside the callback. The way how the user context is fetched depends on your authentication mechanism. You can check the [NestJS quick start guide](https://zenstack.dev/docs/quick-start/nestjs) for a reference solution.\n\n### Using the enhanced Prisma service[‚Äã](https://zenstack.dev/docs/reference/server-adapters/nestjs#using-the-enhanced-prisma-service \"Direct link to Using the enhanced Prisma service\")\n\nInside your NestJS controllers or services, you can inject the enhanced Prisma service and use it as you would with the regular Prisma service. Just use the special token name `ENHANCED_PRISMA` when injecting the service.\n\n```\nimport { ENHANCED_PRISMA } from '@zenstackhq/server/nestjs';@Controller()export class MyController {  constructor(    @Inject(ENHANCED_PRISMA) private readonly prismaService: PrismaService,  ) {}  ...}\n```\n\nYou can still use the regular Prisma service by injecting as usual.\n\n### API reference[‚Äã](https://zenstack.dev/docs/reference/server-adapters/nestjs#api-reference \"Direct link to API reference\")\n\n#### `ZenStackModule.registerAsync`[‚Äã](https://zenstack.dev/docs/reference/server-adapters/nestjs#zenstackmoduleregisterasync \"Direct link to zenstackmoduleregisterasync\")\n\n##### Signature[‚Äã](https://zenstack.dev/docs/reference/server-adapters/nestjs#signature \"Direct link to Signature\")\n\n```\nregisterAsync(options: ZenStackModuleAsyncOptions): DynamicModule;\n```\n\n##### Parameter `options`[‚Äã](https://zenstack.dev/docs/reference/server-adapters/nestjs#parameter-options \"Direct link to parameter-options\")\n\n```\ninterface ZenStackModuleAsyncOptions {  /**   * Optional list of imported modules that export the providers which are   * required in this module.   */  imports?: Array<Type<any> | DynamicModule | Promise<DynamicModule> | ForwardReference>;  /**   * Whether the module is global-scoped.   */  global?: boolean;  /**   * The token to export the enhanced Prisma service. Default is `'ENHANCED_PRISMA'`.   */  exportToken?: string;  /**   * The factory function to create the enhancement options.   */  useFactory: (...args: unknown[]) => Promise<ZenStackModuleOptions> | ZenStackModuleOptions;  /**   * The dependencies to inject into the factory function.   */  inject?: FactoryProvider['inject'];  /**   * Extra providers to facilitate dependency injection.   */  extraProviders?: Provider[];}\n```\n\n```\ninterface ZenStackModuleOptions {  /**   * A callback for getting an enhanced `PrismaClient`.   */  getEnhancedPrisma: () => unknown;}\n```",
  "title": "NestJS | ZenStack",
  "description": "Adapter for integrating with NestJS",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/server-adapters/sveltekit",
  "markdown": "# SvelteKit | ZenStack\n\n```\n// create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n```\n\n```\n{    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n```",
  "title": "SvelteKit | ZenStack",
  "description": "Adapter for integrating with SvelteKit",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy",
  "markdown": "# Access Policy | ZenStack\n\nWhen using an enhanced Prisma Client, the first thing that may surprise you is that you can't read or write any data. For example, given the following model:\n\n```\nmodel User {    id Int @id    email String @unique}\n```\n\nThe following code will result in a runtime error:\n\n```\nconst prisma = new PrismaClient();const db = enhance(prisma);await db.user.create({ data: { email: 'zen@stack.dev'} });\n```\n\nThe reason is that, with an enhanced client, all CRUD operations are denied by default. You'll need to allow them with policy rules explicitly. This \"secure by default\" design may cause some inconvenience, but it prevents you from accidentally exposing data to unauthorized users.",
  "title": "Access Policy | ZenStack",
  "description": "Introduction",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/",
  "markdown": "# Part I: Supercharged ORM | ZenStack\n\nVersion: 1.x\n\nWelcome to the first part of _ZenStack: The Complete Guide_!\n\nAs the creators of ZenStack, we love Prisma and enjoy its excellent developer experience. And we want to achieve more with it! The most fundamental thing that ZenStack does is turning Prisma into a more powerful database tool and a lot more than an ORM:\n\n*   Access policies\n*   Data validation\n*   Custom attributes and functions\n*   Multi-file schema\n*   Model inheritance\n*   ...\n\nEssentially, your schema becomes the single source of truth of data and rules, and at runtime, your database client not only handles CRUD operations but also does it in a secure way.\n\nIn this part of the guide, you'll learn all the concepts of using ZenStack as a drop-in replacement for Prisma in backend development. Let's get started.\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Part I: Supercharged ORM | ZenStack",
  "description": "Welcome to the first part of ZenStack: The Complete Guide!",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest",
  "markdown": "# RESTful API Handler | ZenStack\n\n## Introduction[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#introduction \"Direct link to Introduction\")\n\nThe RESTful-style API handler exposes CRUD APIs as RESTful endpoints using [JSON:API](https://jsonapi.org/) as transportation format. The API handler is not meant to be used directly; instead, you should use it together with a [server adapter](https://zenstack.dev/docs/category/server-adapters) which handles the request and response API for a specific framework.\n\nIt can be created as the following:\n\n*   Next.js\n*   SvelteKit\n*   Nuxt\n\n/src/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { NextRequestHandler } from '@zenstackhq/server/next';import { RestApiHandler } from '@zenstackhq/server/api';import { getPrisma } from '~/lib/db';const handler = NextRequestHandler({    getPrisma,    useAppDir: true,    handler: RestApiHandler({ endpoint: 'http://myhost/api' })    });export {  handler as GET,  handler as POST,  handler as PUT,  handler as PATCH,  handler as DELETE,};\n```\n\nThe factory function accepts an options object with the following fields:\n\n*   endpoint\n    \n    Required. A `string` field representing the base URL of the RESTful API, used for generating resource links.\n    \n*   pageSize\n    \n    Optional. A `number` field representing the default page size for listing resources and relationships. Defaults to 100. Set to Infinity to disable pagination.\n    \n\n## Endpoints and Features[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#endpoints-and-features \"Direct link to Endpoints and Features\")\n\nThe RESTful API handler conforms to the the [JSON:API](https://jsonapi.org/format/) v1.1 specification for its URL design and input/output format. The following sections list the endpoints and features are implemented. The examples refer to the following schema modeling a blogging app:\n\n```\nmodel User {    id Int @id @default(autoincrement())    email String    posts Post[]}model Profile {    id Int @id @default(autoincrement())    gender String    user User @relation(fields: [userId], references: [id])    userId Int @unique}model Post {    id Int @id @default(autoincrement())    title String    published Boolean @default(false)    viewCount Int @default(0)    author User @relation(fields: [authorId], references: [id])    authorId Int    comments Comment[]}model Comment {    id Int @id @default(autoincrement())    content String    post Post @relation(fields: [postId], references: [id])    postId Int}\n```\n\n### Listing resources[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#listing-resources \"Direct link to Listing resources\")\n\nA specific type of resource can be listed using the following endpoint:\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#status-codes \"Direct link to Status codes\")\n\n*   200: The request was successful and the response body contains the requested resources.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type does not exist.\n*   422: The request violated data validation rules.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples \"Direct link to Examples\")\n\n```\n{    \"meta\": {        \"total\": 1    },    \"data\": [        {            \"attributes\": {                \"authorId\": 1,                \"published\": true,                \"title\": \"My Awesome Post\",                \"viewCount\": 0            },            \"id\": 1,            \"links\": {                \"self\": \"http://myhost/api/post/1\"            },            \"relationships\": {                \"author\": {                    \"data\": { \"id\": 1, \"type\": \"user\" },                    \"links\": {                        \"related\": \"http://myhost/api/post/1/author/1\",                        \"self\": \"http://myhost/api/post/1/relationships/author/1\"                    }                }            },            \"type\": \"post\"        }    ],    \"jsonapi\": {        \"version\": \"1.1\"    },    \"links\": {        \"first\": \"http://myhost/api/post?page%5Blimit%5D=100\",        \"last\": \"http://myhost/api/post?page%5Boffset%5D=0\",        \"next\": null,        \"prev\": null,        \"self\": \"http://myhost/api/post\"    }}\n```\n\n### Fetching a resource[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#fetching-a-resource \"Direct link to Fetching a resource\")\n\nA unique resource can be fetched using the following endpoint:\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#status-codes-1 \"Direct link to Status codes\")\n\n*   200: The request was successful and the response body contains the requested resource.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type or ID does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-1 \"Direct link to Examples\")\n\n```\n{    \"data\": {        \"attributes\": {            \"authorId\": 1,            \"published\": true,            \"title\": \"My Awesome Post\",            \"viewCount\": 0        },        \"id\": 1,        \"links\": {            \"self\": \"http://myhost/api/post/1\"        },        \"relationships\": {            \"author\": {                \"data\": { \"id\": 1, \"type\": \"user\" },                \"links\": {                    \"related\": \"http://myhost/api/post/1/author/1\",                    \"self\": \"http://myhost/api/post/1/relationships/author/1\"                }            }        },        \"type\": \"post\"    },    \"jsonapi\": {        \"version\": \"1.1\"    },    \"links\": {        \"self\": \"http://myhost/api/post/1\"    }}\n```\n\n### Fetching relationships[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#fetching-relationships \"Direct link to Fetching relationships\")\n\nA resource's relationships can be fetched using the following endpoint:\n\n```\nGET /:type/:id/relationships/:relationship\n```\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#status-codes-2 \"Direct link to Status codes\")\n\n*   200: The request was successful and the response body contains the requested relationships.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type, ID, or relationship does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-2 \"Direct link to Examples\")\n\n1.  Fetching a to-one relationship\n    \n    ```\n    GET /post/1/relationships/author\n    ```\n    \n    ```\n    {    \"data\" : { \"id\" : 1, \"type\" : \"user\" },    \"jsonapi\" : {        \"version\" : \"1.1\"    },    \"links\" : {        \"self\" : \"http://myhost/api/post/1/relationships/author\"    }}\n    ```\n    \n2.  Fetching a to-many relationship\n    \n    ```\n    GET /user/1/relationships/posts\n    ```\n    \n    ```\n    {    \"data\" : [        { \"id\" : 1, \"type\" : \"post\" },        { \"id\" : 2, \"type\" : \"post\" }    ],    \"jsonapi\" : {        \"version\" : \"1.1\"    },    \"links\" : {        \"first\" : \"http://myhost/api/user/1/relationships/posts?page%5Blimit%5D=100\",        \"last\" : \"http://myhost/api/user/1/relationships/posts?page%5Boffset%5D=0\",        \"next\" : null,        \"prev\" : null,        \"self\" : \"http://myhost/api/user/1/relationships/posts\"    }}\n    ```\n    \n\n```\nGET /:type/:id/:relationship\n```\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#status-codes-3 \"Direct link to Status codes\")\n\n*   200: The request was successful and the response body contains the requested relationship.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type, ID, or relationship does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-3 \"Direct link to Examples\")\n\n```\n{   \"data\" : {      \"attributes\" : {         \"email\" : \"emily@zenstack.dev\",         \"name\" : \"Emily\"      },      \"id\" : 1,      \"links\" : {         \"self\" : \"http://myhost/api/user/1\"      },      \"relationships\" : {         \"posts\" : {            \"links\" : {               \"related\" : \"http://myhost/api/user/1/posts\",               \"self\" : \"http://myhost/api/user/1/relationships/posts\"            }         }      },      \"type\" : \"user\"   },   \"jsonapi\" : {      \"version\" : \"1.1\"   },   \"links\" : {      \"self\" : \"http://myhost/api/post/1/author\"   }}\n```\n\n### Fine-grained data fetching[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#fine-grained-data-fetching \"Direct link to Fine-grained data fetching\")\n\n#### Filtering[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#filtering \"Direct link to Filtering\")\n\nYou can use the `filter[:selector1][:selector2][...]=value` [query parameter family](https://jsonapi.org/format/#query-parameters-families) to filter resource collections or relationship collections.\n\n##### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-4 \"Direct link to Examples\")\n\n1.  Equality filter against plain field\n    \n    ```\n    GET /api/post?filter[published]=false\n    ```\n    \n2.  Equality filter against relationship\n    \n    Relationship field can be filtered directly by its id.\n    \n    ```\n    GET /api/post?filter[author]=1\n    ```\n    \n    If the relationship is to-many, the filter has \"some\" semantic and evaluates to `true` if any of the items in the relationship matches.\n    \n    ```\n    GET /api/user?filter[posts]=1\n    ```\n    \n3.  Filtering with multiple values\n    \n    Multiple filter values can be separated by comma. Items statisfying any of the values will be returned.\n    \n    ```\n    GET /api/post?filter[author]=1,2\n    ```\n    \n4.  Multiple filters\n    \n    A request can carry multiple filters. Only items statisfying all filters will be returned.\n    \n    ```\n    GET /api/post?filter[author]=1&filter[published]=true\n    ```\n    \n5.  Deep filtering\n    \n    A filter can carry multiple field selectors to reach into relationships.\n    \n    ```\n    GET /api/post?filter[author][name]=Emily\n    ```\n    \n    When reaching into a to-many relationship, the filter has \"some\" semantic and evaluates to `true` if any of the items in the relationship matches.\n    \n    ```\n    GET /api/user?filter[posts][published]=true\n    ```\n    \n6.  Filtering with comparison operators\n    \n    Filters can go beyond equality by appending an \"operator suffix\".\n    \n    ```\n    GET /api/post?filter[viewCount$gt]=100\n    ```\n    \n    The following operators are supported:\n    \n    *   **$lt**\n        \n        Less than\n        \n    *   **$lte**\n        \n        Less than or equal to\n        \n    *   **$gt**\n        \n        Greater than\n        \n    *   **$gte**\n        \n        Greater than or equal to\n        \n    *   **$contains**\n        \n        String contains\n        \n    *   **$icontains**\n        \n        Case-insensitive string contains\n        \n    *   **$search**\n        \n        String full-text search\n        \n    *   **$startsWith**\n        \n        String starts with\n        \n    *   **$endsWith**\n        \n        String ends with\n        \n    *   **$has**\n        \n        Collection has value\n        \n    *   **$hasEvery**\n        \n        Collection has every element in value\n        \n    *   **$hasSome**\n        \n        Collection has some elements in value\n        \n    *   **$isEmpty**\n        \n        Collection is empty\n        \n\n#### Sorting[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#sorting \"Direct link to Sorting\")\n\nYou can use the `sort` query parameter to sort resource collections or relationship collections. The value of the parameter is a comma-separated list of fields names. The order of the fields in the list determines the order of sorting. By default, sorting is done in ascending order. To sort in descending order, prefix the field name with a minus sign.\n\n##### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-5 \"Direct link to Examples\")\n\n```\nGET /api/post?sort=createdAt,-viewCount\n```\n\nWhen creating a RESTful API handler, you can pass in a `pageSize` option to control pagination behavior of fetching a collection of resources, related resources, and relationships. By default the page size is 100, and you can disable pagination by setting `pageSize` option to `Infinity`.\n\nWhen fetching a collection resource or relationship, you can use the `page[offset]=value` and `page[limit]=value` [query parameter family](https://jsonapi.org/format/#query-parameters-families) to fetch a specific page. They're mapped to `skip` and `take` parameters in the query arguments sent to PrismaClient.\n\nThe response data of collection fetching contains pagination links that facilitate navigating through the collection. The \"meta\" section also contains the total count available. E.g.:\n\n```\n{    \"meta\": {        \"total\": 10    },    \"data\" : [        ...    ],    \"links\" : {        \"first\" : \"http://myhost/api/post?page%5Blimit%5D=2\",        \"last\" : \"http://myhost/api/post?page%5Boffset%5D=4\",        \"next\" : \"http://myhost/api/post?page%5Boffset%5D=4&page%5Blimit%5D=2\",        \"prev\" : \"http://myhost/api/post?page%5Boffset%5D=0&page%5Blimit%5D=2\",        \"self\" : \"http://myhost/api/post\"    }}\n```\n\n##### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-6 \"Direct link to Examples\")\n\n1.  Fetching a specific page of resources\n    \n    ```\n    GET /api/post?page[offset]=10&page[limit]=5\n    ```\n    \n2.  Fetching a specific page of relationships\n    \n    ```\n    GET /api/user/1/relationships/posts?page[offset]=10&page[limit]=5\n    ```\n    \n3.  Fetching a specific page of related resources\n    \n    ```\n    GET /api/user/1/posts?page[offset]=10&page[limit]=5\n    ```\n    \n\nYou can use the `include` query parameter to include related resources in the response. The value of the parameter is a comma-separated list of fields names. Field names can contain dots to reach into nested relationships.\n\nWhen including related resources, the response data takes the form of [Compound Documents](https://jsonapi.org/format/#document-compound-documents) and contains a `included` field carrying normalized related resources. E.g.:\n\n```\n{   \"data\" : [      {         \"attributes\" : {            ...         },         \"id\" : 1,         \"relationships\" : {            \"author\" : {               \"data\" : { \"id\" : 1, \"type\" : \"user\" }            }         },         \"type\" : \"post\"      }   ],   \"included\" : [      {         \"attributes\" : {            \"email\" : \"emily@zenstack.dev\",            \"name\" : \"Emily\"         },         \"id\" : 1,         \"links\" : {            \"self\" : \"http://myhost/api/user/1\"         },         \"relationships\" : {            \"posts\" : {               \"links\" : {                  \"related\" : \"http://myhost/api/user/1/posts\",                  \"self\" : \"http://myhost/api/user/1/relationships/posts\"               }            }         },         \"type\" : \"user\"      }   ]}\n```\n\n##### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-7 \"Direct link to Examples\")\n\n1.  Including a direct relationship\n    \n    ```\n    GET /api/post?include=author\n    ```\n    \n2.  Including a deep relationship\n    \n    ```\n    GET /api/post?include=author.profile\n    ```\n    \n3.  Including multiple relationships\n    \n    ```\n    GET /api/post?include=author,comments\n    ```\n    \n\n### Creating a resource[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#creating-a-resource \"Direct link to Creating a resource\")\n\nA new resource can be created using the following endpoint:\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#status-codes-4 \"Direct link to Status codes\")\n\n*   201: The request was successful and the resource was created.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-8 \"Direct link to Examples\")\n\n1.  Creating a resource\n    \n    ```\n    POST /user{    \"data\": {        \"type\": \"user\",        \"attributes\": {            \"name\": \"Emily\",            \"email\": \"emily@zenstack.dev\"        }    }}\n    ```\n    \n2.  Creating a resource with relationships attached\n    \n    ```\n    POST /user{    \"data\": {        \"type\": \"user\",        \"attributes\": {            \"name\": \"Emily\",            \"email\": \"emily@zenstack.dev\"        },        \"relationships\": {            \"posts\": {                \"data\": [{ \"type\": \"post\", \"id\": 1 }]            }        }    }}\n    ```\n    \n\n### Updating a resource[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#updating-a-resource \"Direct link to Updating a resource\")\n\nA resource can be updated using the following endpoints:\n\n```\nPUT /:type/:idPATCH /:type/:id\n```\n\nBoth `PUT` and `PATCH` do partial update and has exactly the same behavior.\n\ninfo\n\nBesides plain fields, you can also include relationships in the request body. Please note that this won't update the related resource; instead if only replaces the relationships. If you update a to-many relationship, the new collection will entirely replace the old one.\n\nRelationships can also be manipulated directly. See [Manipulating Relationships](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#manipulating-relationships) for more details.\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#status-codes-5 \"Direct link to Status codes\")\n\n*   200: The request was successful and the resource was updated.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type or ID does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-9 \"Direct link to Examples\")\n\n1.  Updating a resource\n    \n    ```\n    PUT /post/1{    \"data\": {        \"type\": \"post\",        \"attributes\": {            \"title\": \"My Awesome Post\"        }    }}\n    ```\n    \n2.  Updating a resource's relationships\n    \n    ```\n    PUT /user/1{    \"data\": {        \"type\": \"user\",        \"relationships\": {            \"posts\": {                \"data\": [{ \"type\": \"post\", \"id\": 2 }]            }        }    }}\n    ```\n    \n\n### Deleting a resource[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#deleting-a-resource \"Direct link to Deleting a resource\")\n\nA resource can be deleted using the following endpoint:\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#status-codes-6 \"Direct link to Status codes\")\n\n*   204: The request was successful and the resource was deleted.\n*   403: The request was forbidden.\n*   404: The requested resource type or ID does not exist.\n\n### Manipulating relationships[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#manipulating-relationships \"Direct link to Manipulating relationships\")\n\nRelationships can be manipulated using the following endpoints:\n\n#### Adding to a to-many relationship[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#adding-to-a-to-many-relationship \"Direct link to Adding to a to-many relationship\")\n\n```\nPOST /:type/:id/relationships/:relationship\n```\n\n##### Status codes[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#status-codes-7 \"Direct link to Status codes\")\n\n*   200: The request was successful and the relationship was updated.\n*   403: The request was forbidden.\n*   404: The requested resource type, ID, or relationship does not exist.\n\n##### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-10 \"Direct link to Examples\")\n\n```\nPOST /user/1/relationships/posts{    \"data\": [        { \"type\": \"post\", \"id\": \"1\" },        { \"type\": \"post\", \"id\": \"2\" }    ]}\n```\n\n#### Updating a relationship (to-one or to-many)[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#updating-a-relationship-to-one-or-to-many \"Direct link to Updating a relationship (to-one or to-many)\")\n\n```\nPUT /:type/:id/relationships/:relationshipPATCH /:type/:id/relationships/:relationship\n```\n\ninfo\n\n`PUT` and `PATCH` has exactly the same behavior and both relace the existing relationships with the new ones entirely.\n\n##### Status codes[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#status-codes-8 \"Direct link to Status codes\")\n\n*   200: The request was successful and the relationship was updated.\n*   403: The request was forbidden.\n*   404: The requested resource type, ID, or relationship does not exist.\n\n##### Examples[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#examples-11 \"Direct link to Examples\")\n\n1.  Replacing a to-many relationship\n    \n    ```\n    PUT /user/1/relationships/posts{    \"data\": [        { \"type\": \"post\", \"id\": \"1\" },        { \"type\": \"post\", \"id\": \"2\" }    ]}\n    ```\n    \n2.  Replacing a to-one relationship\n    \n    ```\n    PUT /post/1/author{    \"data\": { \"type\": \"user\", \"id\": \"2\" }}\n    ```\n    \n3.  Clearing a to-many relationship\n    \n    ```\n    PUT /user/1/relationships/posts{    \"data\": []}\n    ```\n    \n4.  Clearing a to-one relationship\n    \n    ```\n    PUT /post/1/author{    \"data\": null}\n    ```\n    \n\n## Serialization[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#serialization \"Direct link to Serialization\")\n\nZenStack uses [superjson](https://github.com/blitz-js/superjson) to serialize and deserialize data. Superjson generates two parts during serialization:\n\n*   json:\n    \n    The JSON-compatible serialization result.\n    \n*   meta:\n    \n    The serialization metadata including information like field types that facilitates deserialization.\n    \n\nIf the data only involves simple data types, the serialization result is the same as regular `JSON.stringify`, and no `meta` part is generated. However, for complex data types (like `Bytes`, `Decimal`, etc.), a `meta` object will be generated, which needs to be carried along when sending the request, and will also be included in the response.\n\nWhen sending requests, if superjson-serializing the request body results in a `meta` object, it should be put into a `{ \"serialization\": meta }` object and included in the `meta` field of the request body. For example, if you have a `bytes` field of type `Bytes`, the request body should look like:\n\n```\nPOST /post{    \"data\": {        \"type\": \"post\",        \"attributes\": {            ...            \"bytes\": \"AQID\" // base64-encoded bytes        }    },    \"meta\": {         \"serialization\": {\"values\": { \"data.attributes.bytes\": [[ \"custom\", \"Bytes\"]] } }     } }\n```\n\nCorrespondingly, the response body of a query may look like:\n\n```\nGET /post/1{    \"data\": {        \"id\": \"1\",        \"type\": \"post\",        \"attributes\": {            ...            \"bytes\": \"AQID\" // base64-encoded bytes        }    },    \"meta\": {         \"serialization\": {\"values\": { \"data.attributes.bytes\": [[ \"custom\", \"Bytes\"]] } }     } }\n```\n\nYou should use the `meta.serialization` field value to superjson-deserialize the response body.\n\n### Data Type Serialization Format[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#data-type-serialization-format \"Direct link to Data Type Serialization Format\")\n\n*   `DateTime`\n    \n    ISO 8601 string\n    \n*   `Bytes`\n    \n    Base64-encoded string\n    \n*   `BigInt`\n    \n    String representation\n    \n*   `Decimal`\n    \n    String representation\n    \n\n## Error Handling[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#error-handling \"Direct link to Error Handling\")\n\nAn error response is an object containing the following fields:\n\n*   errors\n    \n    An array of error objects, each containing the following fields:\n    \n    *   code: `string`, error code\n    *   status: `number`, HTTP status code\n    *   title: `string`, error title\n    *   detail: `string`, error detail\n    *   prismaCode: `string`, Prisma error code, if the error is thrown by Prisma\n\n### Example[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#example \"Direct link to Example\")\n\n```\n{   \"errors\" : [      {         \"code\" : \"unsupported-model\",         \"detail\" : \"Model foo doesn't exist\",         \"status\" : 404,         \"title\" : \"Unsupported model type\"      }   ]}\n```",
  "title": "RESTful API Handler | ZenStack",
  "description": "RESTful-style API handler that provides resource-centric endpoints",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query",
  "markdown": "# @zenstackhq/tanstack-query | ZenStack\n\ninfo\n\nIf you're looking for generating hooks for [SWR](https://swr.vercel.app/), please checkout the [`@zenstackhq/swr`](https://zenstack.dev/docs/1.x/reference/plugins/swr) plugin.\n\nThe `@zenstackhq/tanstack-query` plugin generates [Tanstack Query](https://tanstack.com/query/latest) hooks that call into the CRUD services provided by the [server adapters](https://zenstack.dev/docs/1.x/category/server-adapters). The plugin currently supports React and Svelte. Vue support is coming soon.\n\nThe hooks syntactically mirror the APIs of a standard Prisma client, including the function names and shapes of parameters (hooks directly use types generated by Prisma).\n\nTo use the generated hooks, you need to install \"tanstack-query\" for the target framework with version 4.0.0 or above.\n\n### Installation[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#installation \"Direct link to Installation\")\n\n```\nnpm install --save-dev @zenstackhq/tanstack-query\n```\n\n### Options[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#options \"Direct link to Options\")\n\n| Name | Type | Description | Required | Default |\n| --- | --- | --- | --- | --- |\n| output | String | Output directory (relative to the path of ZModel) | Yes |     |\n| target | String | Target framework to generate for. Choose from \"react\", \"vue\", and \"svelte\". | Yes |     |\n| version | String | Version of TanStack Query to generate for. Choose from \"v4\" and \"v5\". | No  | v4  |\n\n### Context Provider[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#context-provider \"Direct link to Context Provider\")\n\nThe generated hooks allow you to control their behavior by setting up context. The following options are available on the context:\n\n*   endpoint\n    \n    The endpoint to use for the queries. Defaults to \"/api/model\".\n    \n*   fetch\n    \n    A custom `fetch` function to use for the queries. Defaults to using [cross-fetch](https://github.com/lquixada/cross-fetch).\n    \n\nExample for using the context provider:\n\n*   React\n*   Vue\n*   Svelte\n\n\\_app.tsx\n\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';import { Provider as ZenStackHooksProvider } from '../lib/hooks';import type { FetchFn } from '@zenstackhq/tanstack-query/runtime';// custom fetch function that adds a custom headerconst myFetch: FetchFn = (url, options) => {    options = options ?? {};    options.headers = {        ...options.headers,        'x-my-custom-header': 'hello world',    };    return fetch(url, options);};const queryClient = new QueryClient();function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {    return (        <QueryClientProvider client={queryClient}>            <ZenStackHooksProvider value={{ endpoint: '/api/model', fetch: myFetch }}>                <AppContent />            </ZenStackHooksProvider>        </QueryClientProvider>    );}export default MyApp;\n```\n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#example \"Direct link to Example\")\n\nHere's a quick example with a ReactJs blogging app. You can find a fully functional Todo app example [here](https://github.com/zenstackhq/sample-todo-nextjs-tanstack).\n\n#### Schema[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#schema \"Direct link to Schema\")\n\n/schema.zmodel\n\n```\nplugin hooks {  provider = '@zenstackhq/tanstack-query'  output = \"./src/lib/hooks\"  target = \"react\"}model User {  id            String    @id @default(cuid())  email         String  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)}model Post {  id        String @id @default(cuid())  title     String  published Boolean @default(false)  author    User @relation(fields: [authorId], references: [id])  authorId  String  // author has full access  @@allow('all', auth() == author)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\n#### App Setup[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#app-setup \"Direct link to App Setup\")\n\n*   React\n*   Vue\n*   Svelte\n\n\\_app.tsx\n\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';import { Provider as ZenStackHooksProvider } from '../lib/hooks';const queryClient = new QueryClient();function App({ Component, pageProps: { session, ...pageProps } }: AppProps) {    return (        <QueryClientProvider client={queryClient}>            <ZenStackHooksProvider value={{ endpoint: '/api/model' }}>                <AppContent />            </ZenStackHooksProvider>        </QueryClientProvider>    );}\n```\n\n#### Using Query and Mutation Hooks[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#using-query-and-mutation-hooks \"Direct link to Using Query and Mutation Hooks\")\n\n*   React\n*   Vue\n*   Svelte\n\n/src/components/Posts.tsx\n\n```\nimport { useFindManyPost, useCreatePost } from '../lib/hooks';// post list componentconst Posts = ({ userId }: { userId: string }) => {    const create = useCreatePost();    // list all posts that're visible to the current user, together with their authors    const { data: posts } = useFindManyPost({        include: { author: true },        orderBy: { createdAt: 'desc' },    });    async function onCreatePost() {        create.mutate({            data: {                title: 'My awesome post',                authorId: userId,            },        });    }    return (        <>            <button onClick={onCreatePost}>Create</button>            <ul>                {posts?.map((post) => (                    <li key={post.id}>                        {post.title} by {post.author.email}                    </li>                ))}            </ul>        </>    );};\n```\n\n### Automatic Optimistic Update (Preview)[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#automatic-optimistic-update-preview \"Direct link to Automatic Optimistic Update (Preview)\")\n\nOptimistic update is a technique that allows you to update the data cache immediately when a mutation executes while waiting for the server response. It helps achieve a more responsive UI. TanStack Query provides the [infrastructure for implementing it](https://tanstack.com/query/v5/docs/react/guides/optimistic-updates).\n\nThe ZenStack-generated mutation hooks allow you to opt-in to \"automatic optimistic update\" by passing an extra `optimisticUpdate` argument when calling the hook. When the mutation executes, it analyzes the current queries in the cache and tries to find the ones that need to be updated. When the mutation settles (either succeeded or failed), the queries are invalidated to trigger a re-fetch.\n\nHere's an example:\n\n```\n// arguments are mutation options, invalidate, and optimisticUpdateconst create = useCreatePost(undefined, true, true);function onCreatePost() {    create.mutate({ ... })}\n```\n\nWhen `mutate` executes, if there are active queries like `useFindManyPost()`, the data of the mutation call will be optimistically inserted into the head of the query result.\n\n#### Details of the optimistic behavior[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#details-of-the-optimistic-behavior \"Direct link to Details of the optimistic behavior\")\n\n*   `create` mutation inserts item to the head of the query results of the corresponding `useFindMany` queries.\n*   `update` mutation updates the item in the query results of `useFindXXX` queries and their nested reads by matching the item's ID.\n*   `delete` mutation removes the item from the query results of the corresponding `useFindMany` queries and sets `null` to `useFindUnique` and `useFindFirst` query results, by matching the item's ID.\n\n#### Limitations[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#limitations \"Direct link to Limitations\")\n\n*   The automatic optimistic update relies on ID matching. It only works for queries that select the ID field(s).\n*   Non-entity-fetching queries like `count`, `aggregate`, and `groupBy` are not affected.\n*   Infinite queries are not affected.\n*   It doesn't respect filter conditions or access policies that potentially affect the queries under update. For example, for query `useFindManyPost({ where: { published: true }})`, when a non-published `Post` is created, it'll still be inserted into the query result.\n\n#### Opt-out[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#opt-out \"Direct link to Opt-out\")\n\nBy default, all queries opt into automatic optimistic update. You can opt-out on a per-query basis by passing `false` to the `optimisticUpdate` argument.\n\n```\n// arguments are query args, query options, and optimisticUpdateconst { data } = useFindManyPost({ where: { published: true } }, undefined, false);\n```\n\nWhen a query opts out, it won't be updated by a mutation, even if the mutation is set to update optimistically.\n\n### Using Infinite Query[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#using-infinite-query \"Direct link to Using Infinite Query\")\n\n*   React\n*   Vue\n*   Svelte\n\nHere's a quick example of using infinite query to load a list of posts with infinite pagination. See [Tanstack Query documentation](https://tanstack.com/query/v4/docs/react/guides/infinite-queries) for more details.\n\n/src/components/Posts.tsx\n\n```\nimport { useInfiniteFindManyPost } from '../lib/hooks';// post list component with infinite loadingconst Posts = () => {    const PAGE_SIZE = 10;    const fetchArgs = {        include: { author: true },        orderBy: { createdAt: 'desc' as const },        take: PAGE_SIZE,    };    const { data, fetchNextPage, hasNextPage } = useInfiniteFindManyPost(fetchArgs, {        getNextPageParam: (lastPage, pages) => {            if (lastPage.length < PAGE_SIZE) {                return undefined;            }            const fetched = pages.flatMap((item) => item).length;            return {                ...fetchArgs,                skip: fetched,            };        },    });        return (        <>            <ul>                {data?.pages.map((posts, i) => (                    <React.Fragment key={i}>                        {posts?.map((post) => (                            <li key={post.id}>                                {post.title} by {post.author.email}                            </li>                        ))}                    </React.Fragment>                ))}            </ul>            {hasNextPage && (                <button onClick={() => fetchNextPage()}>                    Load more                </button>            )}        </>    );};\n```\n\n## Advanced[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#advanced \"Direct link to Advanced\")\n\n### Query Invalidation[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#query-invalidation \"Direct link to Query Invalidation\")\n\nThe mutation hooks generated by ZenStack automatically invalidates the queries that are potentially affected by the changes. For example, if you create a `Post`, the `useFindManyPost` query will be automatically invalidated when the mutation succeeds. Invalidation causes cache to be purged and fresh data to be refetched.\n\nThe automatic invalidation takes care of nested read, write, and delete cascading.\n\n**1\\. Nested Read**\n\nNested reads are also subject to automatic invalidation. For example, if you create a `Post`, the query made by\n\n```\nuseFindUniqueUser({ where: { id: userId }, include: { posts: true } });\n```\n\nwill be invalidated.\n\n**2\\. Nested Write**\n\nSimilarly, nested writes also trigger automatic invalidation. For example, if you create a `Post` in a nested update to `User` like:\n\n```\nupdateUser({ where: { id: userId }, posts: { create: { title: 'post1' } } });\n```\n\nThe mutation will cause queries like `useFindManyPost()` to be invalidated.\n\n**3\\. Delete Cascade**\n\nIn ZModel, relations can be configured to cascade delete, e.g.:\n\n```\nmodel User {    ...    posts Post[]}model Post {    ...    user User @relation(fields: [userId], references: [id], onDelete: Cascade)    userId Int}\n```\n\nWhen a `User` is deleted, the `Post` entities it owns will be deleted automatically. The generated hooks takes cascade delete into account. For example, if you delete a `User`, `Post` model will be considered as affected and queries like `useFindManyPost()` will be invalidated.\n\ninfo\n\nThe automatic invalidation is enabled by default, and you can use the `invalidateQueries` argument to opt-out and handle revalidation by yourself.\n\n```\n// arguments are mutation options and invalidateQueriesuseCreatePost(undefined, false);\n```\n\n### Query Key[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#query-key \"Direct link to Query Key\")\n\nQuery keys serve as unique identifiers for organizing the query cache. The generated hooks use the following query key scheme:\n\n```\n['zenstack', model, operation, args, flags]\n```\n\nFor example, the query key for\n\n```\nuseFindUniqueUser({ where: { id: '1' } })\n```\n\nwill be:\n\n```\n['zenstack', 'User', 'findUnique', { where: { id: '1' } }, { infinite: false }]\n```\n\nYou can use the generated `getQueryKey` function to compute it.",
  "title": "@zenstackhq/tanstack-query | ZenStack",
  "description": "Plugin for generating Tanstack Query query and mutation hooks",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part2/",
  "markdown": "# Part II: Plugin System | ZenStack\n\nIf you're experienced with Prisma, you've probably used some generators, like [prisma-erd-generator](https://github.com/keonik/prisma-erd-generator) and [typegraphql-prisma](https://github.com/MichalLytek/typegraphql-prisma). ZenStack's plugins share similarities with Prisma generators but also differ in several ways:\n\n*   Ease of programming\n    \n    Prisma's generator API uses the internal [DMMF format](https://github.com/prisma/prisma/blob/main/ARCHITECTURE.md#the-dmmf-or-data-model-meta-format) that's undocumented and not very friendly to work with. ZenStack's plugin API uses the ZModel AST, which is much more intuitive. The ZenStack plugin still receives a DMMF object as input in case you need it.\n    \n*   Extending the schema language\n    \n    Prisma's schema language is not open to extension, and the community has been using the [triple slash hack](https://zenstack.dev/docs/1.x/guides/existing-prisma#prisma-generators-triple-slash-hack) to inject custom attributes. ZenStack allows plugins to introduce custom attributes and functions directly and type-check their usage at generation time.\n    \n\nPlugins and generators are not mutually exclusive. ZenStack fully supports Prisma generators, and you can use them alongside plugins.",
  "title": "Part II: Plugin System | ZenStack",
  "description": "Welcome to the second part of ZenStack: The Complete Guide!",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/",
  "markdown": "# Part III: Automatic CRUD API\n\nIn Part I, we learned how ZenStack extended Prisma ORM on the schema and runtime levels. By making these extensions, ZenStack unleashed many new potentials of the ORM and turned it into a data access layer that enforces access control and additional data integrity.\n\nOne interesting side effect of this extension is that we can automatically derive CRUD APIs from the schema. The data models tell us how the input/output of the APIs should look like, and the enhanced Prisma Client ensures that the APIs are secure.\n\nIn this part of the guide, we'll learn how such automatic APIs work - the general architecture, the different flavors of APIs, and how they integrate into the framework of your choice.\n\nWe'll also continue evolving our Todo project into a fully functional backend service. If you're unfamiliar with the project, please first revisit the [Sample Project](https://zenstack.dev/docs/1.x/the-complete-guide/#sample-project) part. You can use the \"part2\" branch of [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/v1-part2) repo as a starting point, and clone it and check out to that branch with the following command:\n\n```\ngit clone --branch v1-part2 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```\n\nLet's get started.",
  "title": "Part III: Automatic CRUD API | ZenStack",
  "description": "In Part I, we learned how ZenStack extended Prisma ORM on the schema and runtime levels. By making these extensions, ZenStack unleashed many new potentials of the ORM and turned it into a data access layer that enforces access control and additional data integrity.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/",
  "markdown": "# Part IV: Frontend Data Query\n\nVersion: 1.x\n\nIn previous parts of this guide, we have learned how ZenStack turns Prisma into a data access layer with access control and how, based on that, we can automatically serve secure CRUD APIs.\n\nConsuming a CRUD API is straightforward, but it's a tedious and error-prone job if you do it manually. In this part, we'll see how ZenStack can help us generate frontend data query libraries (aka hooks) that make it effortless to consume the APIs from the frontend. We'll also continue evolving our Todo project into a full-fledged application.\n\nLet's roll on!\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Part IV: Frontend Data Query | ZenStack",
  "description": "In previous parts of this guide, we have learned how ZenStack turns Prisma into a data access layer with access control and how, based on that, we can automatically serve secure CRUD APIs.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/dev-workflow",
  "markdown": "# Development Workflow | ZenStack\n\nVersion: 1.x\n\nThe development workflow using ZenStack is very close to Prisma. The main difference is, instead of modifying `schema.prisma` file, you edit `schema.zmodel` to make changes to data models and policies and then use `zenstack generate` command to generate Prisma schema. After that, everything is just standard Prisma workflow, including generating and deploying migrations.\n\nThe following diagram illustrates a typical workflow for prototyping data model changes during feature development:\n\n![Feature Prototyping Workflow](https://zenstack.dev/img/dev-workflow-light.png)![Feature Prototyping Workflow](https://zenstack.dev/img/dev-workflow-dark.png)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Development Workflow | ZenStack",
  "description": "Development Workflow",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/epilogue",
  "markdown": "# Epilogue | ZenStack\n\nüéâ Congratulations on completing the guide! We hope you've enjoyed the journey and got ready to build your own ZenStack-powered application.\n\n### Let The Schema Drive Your App[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/epilogue#let-the-schema-drive-your-app \"Direct link to Let The Schema Drive Your App\")\n\nOur final version of the Todo app consists of roughly 500 lines of manually written code. That's quite a small codebase for a fully functional application!\n\nZenStack takes a schema-first approach to model your application. It originated from the Prisma ORM, evolved its schema for extensibility, added access control, introduced a plugin system, and served automatic CRUD APIs. Although it has been a long way, the schema has always been the core. The key is to boil down the application's essential business logic into a concise representation and then automate as many things as possible with it, so you can write less boilerplate code and focus on creating real values.\n\nAs its name suggests, we want the project to help bring simplicity, tranquility, and mindfulness back to software development.\n\n![](https://zenstack.dev/img/the-complete-guide/zen-coder.png)\n\n### What's Next[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/epilogue#whats-next \"Direct link to What's Next\")\n\n*   The [Quick Start](https://zenstack.dev/docs/1.x/category/quick-start) documents guide you through creating a simple app using ZenStack with various frameworks. They are fast-paced and can get you up running in minutes.\n*   The [Recipes](https://zenstack.dev/docs/1.x/category/recipes) include guides for achieving specific tasks. For example, you may want to learn how to [deploy to production](https://zenstack.dev/docs/1.x/guides/deploy).\n*   The best way to get support or send feedback is to join our [Discord server](https://discord.gg/Ykhr738dUe). The community is responsive and helpful.\n*   But you're also welcome to create issues and feature requests directly on [GitHub](https://github.com/zenstackhq/zenstack).\n*   Finally, don't forget to [‚≠êÔ∏èStar Us‚≠êÔ∏è](https://github.com/zenstackhq/zenstack). We appreciate it!",
  "title": "Epilogue | ZenStack",
  "description": "Epilogue",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/ide",
  "markdown": "# Installing IDE Extensions | ZenStack\n\nVersion: 1.x\n\n## VSCode[‚Äã](https://zenstack.dev/docs/1.x/guides/ide#vscode \"Direct link to VSCode\")\n\nZenStack VSCode extension provides syntax highlighting and error checking to improve the efficiency of your modeling work. It offers functionalities similar to the Prisma VSCode extension, plus support for added features like access policies.\n\n### Features[‚Äã](https://zenstack.dev/docs/1.x/guides/ide#features \"Direct link to Features\")\n\n*   Syntax highlighting\n*   Error highlighting\n*   Go to definition\n*   Auto-completion\n*   Hover documentation\n*   Formatting\n\n### Installation[‚Äã](https://zenstack.dev/docs/1.x/guides/ide#installation \"Direct link to Installation\")\n\nYou can install it by searching \"ZenStack Language Tools\" inside VSCode or directly from [here](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack).\n\n[![VSCode Screenshot](https://zenstack.dev/assets/images/vscode-screenshot-3b3552b40686a215efe0d37d13e42da9.png)](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack)\n\n## JetBrains IDEs[‚Äã](https://zenstack.dev/docs/1.x/guides/ide#jetbrains-ides \"Direct link to JetBrains IDEs\")\n\nZenStack provides a plugin for JetBrains IDEs. The extension is based on JetBrain platform's new [Language Server Protocol (LSP) support](https://blog.jetbrains.com/platform/2023/07/lsp-for-plugin-developers/). The extension only offers preliminary features today, but please expect improvements in the future as the LSP support matures.\n\ninfo\n\nJetBrain's LSP support is not available to the community edition of the IDEs, so is the ZenStack plugin.\n\n### Features[‚Äã](https://zenstack.dev/docs/1.x/guides/ide#features-1 \"Direct link to Features\")\n\n*   Syntax highlighting\n*   Error highlighting\n*   Go to definition\n*   Auto-completion (partial)\n*   Formatting\n\n### Installation[‚Äã](https://zenstack.dev/docs/1.x/guides/ide#installation-1 \"Direct link to Installation\")\n\nYou can install it by searching \"ZenStack Language Tools\" inside JetBrain IDE's plugins marketplace or directly from [here](https://plugins.jetbrains.com/plugin/23397-zenstack-language-tools).\n\n[![JetBrains Screenshot](https://zenstack.dev/assets/images/jetbrains-screenshot-dbb8270a9e0cab19d15c40f6326bd107.png)](https://plugins.jetbrains.com/plugin/17210-zenstack-language-tools)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Installing IDE Extensions | ZenStack",
  "description": "IDE extensions",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/supabase-security",
  "markdown": "# Ensuring Security When Integrating Supabase with ZenStack\n\nIntegrating Supabase with ZenStack can be a great choice as Supabase provides authentication as well as database hosting and file uploads.\n\nHowever, it is essential to take some precautions when using ZenStack with Supabase to ensure that the ZenStack authorization layer cannot be bypassed via requests to the Supabase API url.\n\nThis article will help you to understand the risk, how to test if your database is exposed, and how to prevent it.\n\n## 1\\. Understanding the Risk[‚Äã](https://zenstack.dev/docs/1.x/guides/supabase-security#1--understanding-the-risk \"Direct link to 1.  Understanding the Risk\")\n\nSupabase allows anonymous requests to the Supabase rest API access the database by default, assuming Row Level Security (RLS) is in place.\n\nZenStack's authorization can effectively serve as an in-application security layer, but **direct HTTP requests to your Supabase API could still leave your database exposed.**\n\nThis poses a potential risk because Supabase API URL and anon key are both public and can easily be found eg by inspecting the url/headers of a Supabase authentication network request.\n\n## 2\\. How to test if your database is exposed to direct Supabase API requests[‚Äã](https://zenstack.dev/docs/1.x/guides/supabase-security#2-how-to-test-if-your-database-is-exposed-to-direct-supabase-api-requests \"Direct link to 2. How to test if your database is exposed to direct Supabase API requests\")\n\nUse Bash or an API client (such as postman or VS Code thunder client) to send a HTTP request with these details:\n\n```\ncurl '{SUPABASE_PROJECT_URL}/rest/v1/{DATABASE_TABLE}?select=*' \\-H \"apikey: SUPABASE_ANON_KEY\" \\-H \"Authorization: Bearer SUPABASE_ANON_KEY\"\n```\n\nFor example:\n\n```\ncurl 'https://jypbzsozorjnogibmfhu.supabase.co/rest/v1/User?select=*' \\-H \"apikey: eyOiJIUzJhbGciI1...\" \\-H \"Authorization: Bearer eyOiJIUzJhbGciI1...\"\n```\n\nNote:\n\n*   Your Supabase project URL should look like this: `https://projectid.supabase.co`\n*   You can find both of these values inside Supabase dashboard > settings > api\n\nAs previously mentioned, all the detailed needed to make this request are public and could be accessed eg by inspecting the url/headers of a Supabase authentication network request.\n\nIf your database is secure, you should receive a permission denied error, such as:\n\n```\n{   \"code\": \"42501\",   \"details\": null,   \"hint\": null,   \"message\": \"permission denied for table User\"}\n```\n\nIf you have RLS enabled on the table, you may get a response with an empty array instead of a permission denied error. This means RLS filtering is effective, and it's preventing you from reading rows that are not granted access. However, it's still recommended to fully revoke anonymous access permissions for better security\n\n## 3\\. How to prevent direct Supabase API requests[‚Äã](https://zenstack.dev/docs/1.x/guides/supabase-security#3-how-to-prevent-direct-supabase-api-requests \"Direct link to 3. How to prevent direct Supabase API requests\")\n\n### Revoke default & current privileges[‚Äã](https://zenstack.dev/docs/1.x/guides/supabase-security#revoke-default--current-privileges \"Direct link to Revoke default & current privileges\")\n\nStart by revoking all privileges from the `anon` role to prevent unauthenticated access, and changing the defauts to ensure future objects are also protected.\n\nIn the Supabase dashboard inside the SQL Editor tab, execute the following:\n\n```\n-- Revoke current privilegesREVOKE SELECT ON ALL TABLES IN SCHEMA public FROM anon;REVOKE USAGE ON ALL SEQUENCES IN SCHEMA public FROM anon;REVOKE EXECUTE ON ALL FUNCTIONS IN SCHEMA public FROM anon;-- Revoke default privileges for future objectsALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON TABLES FROM anon;ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON FUNCTIONS FROM anon;ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON SEQUENCES FROM anon;\n```\n\nNote: If you are using Supabase cli for local development, then create a migration file with `pnpm supabase db migration new disable-anon-access` to prevent accidental rollbacks. (this creates a new local sql migration file, 'disable-anon-access' can be replaced)\n\n### Verify Role Configurations[‚Äã](https://zenstack.dev/docs/1.x/guides/supabase-security#verify-role-configurations \"Direct link to Verify Role Configurations\")\n\nIn the Supabase dashboard under the Database > Roles section, confirm the following:\n\n**Anon Role:** All permissions should be disabled. **Authenticated Role:** All permissions should be also disabled here. **Postgres Role:** Ensure it retains the ability to bypass RLS for necessary backend tasks.\n\n## Conclusion[‚Äã](https://zenstack.dev/docs/1.x/guides/supabase-security#conclusion \"Direct link to Conclusion\")\n\nBy disabling permissions for `anon` and `authenticated` roles, you prevent direct public access to your database, relying instead on your application logic and ZenStack's authorization to control access.\n\nRemember to regularly test your application security to ensure effective and appropriate access control for your application.",
  "title": "Ensuring Security When Integrating Supabase with ZenStack | ZenStack",
  "description": "Guide to securely integrating Supabase with ZenStack - how to prevent unauthorized access.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/category/integrating-with-authentication",
  "markdown": "# Integrating With Authentication | ZenStack\n\n[\n\n## üìÑÔ∏è Auth.js (NextAuth)\n\nIntegrating with Auth.js.\n\n](https://zenstack.dev/docs/1.x/guides/authentication/next-auth)",
  "title": "Integrating With Authentication | ZenStack",
  "description": "ZenStack supercharges Prisma ORM with a fine-grained Authorization layer, auto-generated type-safe APIs/hooks to unlock its full potential for full-stack development.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/trpc",
  "markdown": "# Using With tRPC | ZenStack\n\n[tRPC](https://trpc.io/) is a fantastic library that magically turns server-side procedures into client-callable functions without requiring you to provide any formal contract. The popular [T3 stack](https://create.t3.gg/) promotes the combo of Prisma + tRPC for achieving type safety from your frontend all the way down to the database.\n\nZenStack makes things even easier by automatically generating tRPC routers from the ZModel schema. You can use the generated routers together with an enhanced Prisma client; since the Prisma client has the ability to enforce access policies, there is no need to implement authorization code anymore.\n\n## Details[‚Äã](https://zenstack.dev/docs/1.x/guides/trpc#details \"Direct link to Details\")\n\n### 1\\. Initializing the project[‚Äã](https://zenstack.dev/docs/1.x/guides/trpc#1-initializing-the-project \"Direct link to 1. Initializing the project\")\n\nIf you haven't initialized your tRPC project with ZenStack, run the following command to do it:\n\ntip\n\nThe \"init\" command does the following things for you:\n\n1.  Install Prisma if it's not already installed.\n2.  Install the `zenstack` CLI package as a dev dependency.\n3.  Install the `@zenstackhq/runtime` package - used for enhancing `PrismaClient` at the runtime.\n4.  Copy the `prisma/schema.prisma` file to `schema.zmodel` if it exists; otherwise, create a new template `schema.zmodel` file.\n\nYou can always manually complete the steps above if you have a special project setup that the \"init\" command doesn't work with.\n\nAfter the initialization, please remember that you should edit the `schema.zmodel` moving forward. The `prisma/schema.prisma` file will be automatically regenerated when you run `zenstack generate`.\n\n### 2\\. Installing the tRPC plugin[‚Äã](https://zenstack.dev/docs/1.x/guides/trpc#2-installing-the-trpc-plugin \"Direct link to 2. Installing the tRPC plugin\")\n\nYou can enable tRPC router generation with the `@zenstackhq/trpc` plugin.\n\nFirst install the trpc package:\n\n```\nnpm install -D @zenstackhq/trpc@1\n```\n\n/schema.zmodel\n\n```\nplugin trpc {    provider = '@zenstackhq/trpc'    output = 'src/server/routers/generated'}\n```\n\n### 3\\. Setting up the tRPC context[‚Äã](https://zenstack.dev/docs/1.x/guides/trpc#3-setting-up-the-trpc-context \"Direct link to 3. Setting up the tRPC context\")\n\nUsually in your tRPC project, you have a function to create a tRPC context. You need to make sure the context contains a `prisma` field that is an instance of Prisma client. The generated tRPC routers use that to talk to the database.\n\nFor most of the cases you should use a Prisma client that's \"enhanced\" by ZenStack so that the CRUD operations are guarded by the access policies defined in the ZModel schema. Here's a quick example with Next.js:\n\n/src/server/context.ts\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { prisma } from './db';import { getSessionUser } from './auth';export const createContext = async ({ req, res }: CreateNextContextOptions) => {    return {        ...,        // use access-control-enabled Prisma client        prisma: await enhance(prisma, { user: getSessionUser(req, res) }),    };};\n```\n\n### 4\\. Using the generated routers[‚Äã](https://zenstack.dev/docs/1.x/guides/trpc#4-using-the-generated-routers \"Direct link to 4. Using the generated routers\")\n\nNow run the `zenstack` CLI to generate artifacts:\n\nYou should find a bunch of tRPC routers generated in the output folder, one per each data model. A `createRouter` helper function is also generated, which returns a router instance for all models. You can use it as your top-level tRPC router, or merge it with other routers to form a more complex setup.\n\n/src/server/routers/\\_app.ts\n\n```\nimport { createRouter } from './generated/routers';const t = initTRPC.context<Context>().create();export const appRouter = createRouter(t.router, t.procedure);export type AppRouter = typeof appRouter;\n```\n\n_NOTE_: The ZenStack trpc plugin is based on the awesome work by [Omar Dulaimi](https://github.com/omar-dulaimi/prisma-trpc-generator).\n\n* * *\n\nPlease refer to the [@zenstackhq/trpc](https://zenstack.dev/docs/1.x/reference/plugins/trpc) plugin documentation for more details.",
  "title": "Using With tRPC | ZenStack",
  "description": "Guide for using ZenStack with tRPC.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/existing-prisma",
  "markdown": "# Migrating Existing Prisma Projects | ZenStack\n\nZenStack CLI provides an `init` command for easily converting an existing Prisma project.\n\nThe command does the following things:\n\n1.  It copies over `prisma/schema.prisma` to `/schema.zmodel`.\n    \n    If your Prisma schema is in a non-standard location, you can pass it in with the `--prisma` option.\n    \n    ```\n    npx zenstack@1 init --prisma prisma/my.schema\n    ```\n    \n2.  It installs NPM packages.\n    \n    `zenstack` package as a dev dependency and `@zenstackhq/runtime` as a regular dependency. The CLI tries to guess the package manager you use, but you can also explicitly specify one with the `--package-manager` option (supported values are `npm | pnpm | yarn`).\n    \n    ```\n    npx zenstack@1 init --package-manager pnpm\n    ```\n    \n\nIf the `init` command doesn't suit your needs, manually doing these steps is just fine. See [ZenStack CLI](https://zenstack.dev/docs/1.x/reference/cli) for more details about using the CLI.\n\n## Prisma generators' triple slash hack[‚Äã](https://zenstack.dev/docs/1.x/guides/existing-prisma#prisma-generators-triple-slash-hack \"Direct link to Prisma generators' triple slash hack\")\n\nOne major limitation of Prisma schema is the lack of support for custom attributes and functions. Generators can't directly attach specific metadata to models. The community has been using the triple-slash comment hack as a workaround.\n\nHere's an example from [TypeGraphQL Prisma](https://prisma.typegraphql.com/). The comment on the \"password\" field marks it to be omitted from both the GraphQL input and output types. The generator parses its text and acts accordingly.\n\nschema.prisma\n\n```\nmodel User {  id Int @default(autoincrement()) @id  email String  @unique  /// @TypeGraphQL.omit(output: true, input: true)  password String  posts Post[]}\n```\n\nTo make this scenario continue working, ZenStack preserves all triple-slash comments when generating the Prisma schema.\n\nThe hack works but is error-prone because comments have no protection from the compiler. Fortunately, with ZModel, you can implement it in a much nicer way, thanks to its custom attributes support:\n\nschema.zmodel\n\n```\nattribute @TypeGraphQL.omit(output: Boolean?, input: Boolean?)model User {  id Int @default(autoincrement()) @id  email String  @unique  password String @TypeGraphQL.omit(output: true, input: true)  posts Post[]}\n```\n\nNow, if you make a typo or pass in wrongly-typed expressions to the attribute, the compiler catches it for you. When ZenStack generates the Prisma schema, it translates all custom attributes back to triple-slash comments, so the original Prisma generators can continue working as before.",
  "title": "Migrating Existing Prisma Projects | ZenStack",
  "description": "Steps for migrating from existing Prisma projects.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/multiple-schema",
  "markdown": "# Multiple Schema Files and Model Inheritance\n\nAs your business expands, your schema file grows with it. ZenStack offers increased flexibility in managing your schema file through multiple schema files and model inheritance. An example project is provided below for your reference:\n\n[https://github.com/zenstackhq/sample-multiple-schema](https://github.com/zenstackhq/sample-multiple-schema)\n\n## Model Inheritance[‚Äã](https://zenstack.dev/docs/1.x/guides/multiple-schema#model-inheritance \"Direct link to Model Inheritance\")\n\nYou can use abstract model to include common fields that would be shared by multiple models. By extending abstract model, you can keep your schema DRY(Don‚Äôt repeat yourself). The abstract model can contain both fields and attributes like a normal model, but it is erased after generation and does not appear in the generated Prisma schema file.\n\nYou can have your model defined as:\n\n```\nabstract model Base {    id Int @id @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    //Logged-in users can view    @@allow('read', auth() != null)}model Post extends Base{    title String    content String?    viewCount Int @default(0)}model ToDo extends Base{    title String    completed Boolean @default(false)}\n```\n\nThe generated `schema.prisma` file would be:\n\n```\n/// @@allow('all', auth() != null && published)model User {    name String    id Int @id() @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)}/// @@allow('all', auth() != null && published)model Post {    title String    content String?    viewCount Int @default(0)    comment Comment[]    id Int @id() @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)}/// @@allow('all', auth() != null && published)model Comment {    content String    post Post @relation(fields: [postId], references: [id])    postId Int    id Int @id() @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)}\n```\n\n## Multiple Schema Files[‚Äã](https://zenstack.dev/docs/1.x/guides/multiple-schema#multiple-schema-files \"Direct link to Multiple Schema Files\")\n\nYou can split your schema file into multiple files and use `import` statements to include the file you needed. When running `zenstack generate`, it recursively traverses all the imported models and combine them into a single model. For instance, you can split the above schema file into two files below:\n\n*   base.zmodel\n    \n    ```\n    abstract model Base {    id Int @id @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)    // author has full access    @@allow('all', auth() != null && published)}\n    ```\n    \n*   schema.zmodel\n    \n    ```\n    import \"base\"model User extends Base {    name String}model Post extends Base {    title String    content String?    viewCount Int @default(0)    comment Comment[]}model Comment extends Base {    content String    post Post @relation(fields: [postId], references: [id])    postId Int}\n    ```",
  "title": "Multiple Schema Files and Model Inheritance | ZenStack",
  "description": "ZenStack offers increased flexibility in managing your schema file through multiple schema files and model inheritance.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/server-adapters/next",
  "markdown": "# Next.js | ZenStack\n\n## Next.js Server Adapter\n\nThe `@zenstackhq/server/next` module provides a quick way to install API endpoints onto a [Next.js](https://nextjs.org/) project for database CRUD operations. Combined with ZenStack's power of enhancing Prisma with access policies, it's surprisingly simple to achieve a secure data backend without manually coding it.\n\nThe server adapter supports both the \"pages\" routes for older versions of Next.js and the new \"app\" routes for Next.js 13.\n\n### Installation[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/next#installation \"Direct link to Installation\")\n\n```\nnpm install @zenstackhq/server\n```\n\n### Mounting the API[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/next#mounting-the-api \"Direct link to Mounting the API\")\n\nYou can use it to create a request handler in an API endpoint like:\n\n*   App Router\n*   Pages Router\n\n/src/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { NextRequestHandler } from '@zenstackhq/server/next';import type { NextRequest } from \"next/server\";import { enhance } from '@zenstackhq/runtime';import { prisma } from '~/lib/db.ts';import { getSessionUser } from '~/lib/auth.ts';// create an enhanced Prisma client with user contextfunction getPrisma(req: NextRequest) {    // getSessionUser extracts the current session user from the request, its    // implementation depends on your auth solution    return enhance(prisma, { user: getSessionUser(req) });}const handler = NextRequestHandler({ getPrisma, useAppDir: true });export {  handler as GET,  handler as POST,  handler as PUT,  handler as PATCH,  handler as DELETE,};\n```\n\ninfo\n\nNext.js 13 has issues handling `@zenstackhq/runtime` and `@zenstackhq/server` packages when compiling server components. Please add the following config section to your `next.config.mjs` to exclude them:\n\nnext.config.mjs\n\n```\nconst config = {    experimental: {        serverComponentsExternalPackages: [            \"@zenstackhq/runtime\",            \"@zenstackhq/server\",        ],    },}\n```\n\nThe Next.js API route handler takes the following options to initialize:\n\n*   getPrisma (required)\n    \n    > (req: NextRequest) => unknown | Promise<unknown>\n    \n    A callback for getting a PrismaClient instance for talking to the database. Usually you'll use an enhanced instance created with ZenStack's [`enhance`](https://zenstack.dev/docs/1.x/reference/runtime-api#enhance) API to ensure access policies are enforced.\n    \n*   logger (optional)\n    \n    > LoggerConfig\n    \n    Configuration for customizing logging behavior.\n    \n*   modelMeta (optional)\n    \n    > ModelMeta\n    \n    Model metadata. By default loaded from the `node_module/.zenstack/model-meta` module. You can pass it in explicitly if you configured ZenStack to output to a different location. E.g.: `require('output/model-meta').default`.\n    \n*   zodSchemas (optional)\n    \n    > ModelZodSchema | boolean | undefined\n    \n    Provides the Zod schemas used for validating CRUD request input. The Zod schemas can be generated with the `@core/zod` plugin. Pass `true` for this option to load the schemas from the default location. If you configured `@core/zod` plugin to output to a custom location, you can load the schemas explicitly and pass the loaded module to this option. E.g.:\n    \n    ```\n    factory({    ...    zodSchemas: require('./zod'),});\n    ```\n    \n    Not passing this option or passing in `undefined` disables input validation.\n    \n*   useSuperJson (optional)\n    \n    > boolean\n    \n    Whether to use [superjson](https://github.com/blitz-js/superjson) for data serialization. Defaults to `false`.\n    \n    _NOTE_: This options is decprecated. The server adapters now always use superjson for data serialization.\n    \n*   handler (optional)\n    \n    > (req: RequestContext) => Promise<Response>\n    \n    The request handler function. This option determines the API endpoints and its input and output formats. Currently ZenStack supports two styles of APIs: RPC (the default) and RESTful.\n    \n    *   RPC\n        \n        The goal of the RPC-style API handler is to fully mirror [PrismaClient's API](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#model-queries) across the network, so that developers can continue enjoying the convenience and flexibility of Prisma's query syntax. This is the default choice for the `handler` option.\n        \n        The RPC-style handler can be created like:\n        \n        ```\n        import RPCApiHandler from '@zenstackhq/server/api/rpc';const handler = RPCApiHandler();\n        ```\n        \n        For more details, please check out [RPC API Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc).\n        \n    *   RESTful\n        \n        The goal of RESTful-style API handler is to provide a resource-centric RESTful API using [JSON:API](https://jsonapi.org/) as transportation format.\n        \n        The RESTful-style handler can be created like:\n        \n        ```\n        import RestApiHandler from '@zenstackhq/server/api/rest';const handler = RestApiHandler({ endpoint: 'http://myhost/api' });\n        ```\n        \n        For more details, please check out [RESTful API Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest).\n        \n\n### Controlling what endpoints to expose[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/next#controlling-what-endpoints-to-expose \"Direct link to Controlling what endpoints to expose\")\n\nYou can use a [Next.js middleware](https://nextjs.org/docs/pages/building-your-application/routing/middleware) to further control what endpoints to expose. For example, if you're using a RESTful API handler installed at \"/api/model\", you can disallow listing all `User` entities by adding a middleware like:\n\n/src/middleware.ts\n\n```\nimport { type NextRequest, NextResponse } from 'next/server';export function middleware(request: NextRequest) {    const url = new URL(request.url);    if (        request.method === 'GET' &&        url.pathname.match(/^\\/api\\/model\\/user\\/?$/)    ) {        return NextResponse.json({ error: 'Not allowed' }, { status: 405 });    }}export const config = {    matcher: '/api/model/:path*',};\n```\n\n### Using the API[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/next#using-the-api \"Direct link to Using the API\")\n\nThe APIs can be used in the following three ways:\n\n1.  With generated client hooks\n    \n    ZenStack provides plugins to generate client hooks from the ZModel targeting the most popular frontend data fetching libraries: [TanStack Query](https://tanstack.com/query/latest) and [SWR](https://swr.vercel.app/). The generated hooks can be used to make API calls to the server adapters. Refer to the follow docs for detailed usage:\n    \n    *   [`@zenstackhq/tanstack-query`](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query)\n    *   [`@zenstackhq/swr`](https://zenstack.dev/docs/1.x/reference/plugins/swr)\n    \n    info\n    \n    The generated client hooks assumes the server adapter uses [RPC-style API handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc) (which is the default setting).\n    \n2.  With direct HTTP calls\n    \n    You can make direct HTTP calls to the server adapter using your favorite client libraries like `fetch` or `axios`. Refer to the documentation of the [API Handlers](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/) for the API endpoints and data formats.\n    \n    Here's an example using `fetch`:\n    \n    *   RPC Handler\n    *   RESTful Handler\n    \n    ```\n    // create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n    ```\n    \n    Output:\n    \n    ```\n    {    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n    ```\n    \n3.  With third-party client generators\n    \n    ZenStack provides an [OpenAPI](https://zenstack.dev/docs/1.x/reference/plugins/openapi) plugin for generating Open API 3.x specification from the ZModel. The generated OpenAPI spec can be used to generate client libraries for various languages and frameworks. For example, you can use [openapi-typescript](https://github.com/drwpow/openapi-typescript) to generate a typescript client.\n    \n\n### Error Handling[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/next#error-handling \"Direct link to Error Handling\")\n\nRefer to the specific sections for [RPC Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#http-status-code-and-error-responses) and [RESTful Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#error-handling).\n\n### Fully working example[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/next#fully-working-example \"Direct link to Fully working example\")\n\nYou can find the fully working examples below:\n\n*   [Pages router](https://github.com/zenstackhq/docs-tutorial-nextjs)\n*   [Apps router](https://github.com/zenstackhq/docs-tutorial-nextjs-app-dir)",
  "title": "Next.js | ZenStack",
  "description": "Adapter for integrating with Next.js",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/client-extensions",
  "markdown": "# Using With Prisma Client Extensions\n\n[Prisma Client Extension](https://www.prisma.io/docs/orm/prisma-client/client-extensions) is a mechanism for extending the interface and functionality of Prisma Client. This guide introduces two ways of using ZenStack with client extensions and their implications.\n\nWe'll use the following ZModel as a reference throughout this guide:\n\n```\nmodel Post {  id Int @id @default(autoincrement())  title String  content String?  published Boolean @default(false)  @@allow('read', published)}\n```\n\n## Enhancing a Prisma Client with extensions installed[‚Äã](https://zenstack.dev/docs/1.x/guides/client-extensions#enhancing-a-prisma-client-with-extensions-installed \"Direct link to Enhancing a Prisma Client with extensions installed\")\n\nThis should be the most common way of using ZenStack with client extensions. You install client extensions to the global `PrismaClient` instance when the application starts and then call `enhance` with the extended client on a per-request basis. It will generally work as you would intuitively expect.\n\nLet's look at a few examples.\n\n### 1\\. Model-level methods[‚Äã](https://zenstack.dev/docs/1.x/guides/client-extensions#1-model-level-methods \"Direct link to 1. Model-level methods\")\n\n```\nconst extendedPrisma = prisma.$extends({  model: {    post: {      async getFeeds() {          const context = Prisma.getExtensionContext(this);          return context.findMany();      },    },  },});const db = enhance(extendedPrisma);const feeds = await db.post.getFeeds();\n```\n\nThe `getFeeds()` call will return only published posts. The `context` variable fetched with `Prisma.getExtensionContext(this)` is enhanced by ZenStack.\n\n### 2\\. Query-level overrides[‚Äã](https://zenstack.dev/docs/1.x/guides/client-extensions#2-query-level-overrides \"Direct link to 2. Query-level overrides\")\n\n```\nconst extendedPrisma = prisma.$extends({  query: {    post: {      findMany({ query, args }) {        console.log('Query args:', inspect(args, { depth: null }));        return query(args);      },    },  },});const enhanced = enhance(extendedPrisma);const posts = await enhanced.post.findMany();\n```\n\nThe `findMany` call returns only published posts. The printed log will demonstrate that the `args` is injected by ZenStack to include access policy filters.\n\nYou can also override mutation methods and it generally works. However, it must be noted that ZenStack enforces mutation policies before or after the mutation is executed (in the case of \"after\", a transaction is used to roll back if the policy fails), depending on the access policies and the mutation input. This means that if you alter the mutation args in a client extension to make it conform to the access policy, it may not work because ZenStack intercepts the mutation call first, and may decide to reject it based on the original args.\n\n### 3\\. Computed fields[‚Äã](https://zenstack.dev/docs/1.x/guides/client-extensions#3-computed-fields \"Direct link to 3. Computed fields\")\n\n```\nconst extendedPrisma = prisma.$extends({  result: {    post: {      myTitle: {        needs: { title: true },        compute(post) {          return 'MyTitle: ' + post.title;        },      },    },  },});const enhanced = enhance(extendedPrisma);const post = await enhanced.post.findFirst();\n```\n\nComputed fields will work as expected. ZenStack enhancement works transparently with it.\n\ndanger\n\nCurrently there's a limitation that computed fields are not governed by field-level access policies. This means that if you have a computed field that depends on a field that the current user cannot read, the computed field will still be calculated and returned.\n\n## Installing extensions to an enhanced Prisma Client[‚Äã](https://zenstack.dev/docs/1.x/guides/client-extensions#installing-extensions-to-an-enhanced-prisma-client \"Direct link to Installing extensions to an enhanced Prisma Client\")\n\nSuch a setup DOES NOT WORK as you would expect in most cases, so it should generally be avoided. For example,\n\n```\nconst enhanced = enhance(prisma);const db = enhanced.$extends({  model: {    post: {      async getFeeds() {          const context = Prisma.getExtensionContext(this);          return context.findMany();      },    },  },});const feeds = await db.post.getFeeds();\n```\n\nThe `getFeeds()` call will return all posts (both published and unpublished ones). This is due to how Prisma internally implements the client extensions. Although you're calling `$extends` on an enhanced client, inside the extension, the context (returned by `Prisma.getExtensionContext(this)`) bypasses ZenStack and directly calls into the original Prisma client.\n\nYou can refactor the code to make it work by explicitly referencing the enhanced client in the extension:\n\n```\nconst enhanced = enhance(prisma);const db = enhanced.$extends({  model: {    post: {      async getFeeds() {          return enhanced.post.findMany();      },    },  },});const feeds = await db.post.getFeeds();\n```\n\nIt may or may not be practical, depending on the structure of your code base.",
  "title": "Using With Prisma Client Extensions | ZenStack",
  "description": "Using ZenStack with Prisma Client Extensions.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/redwood",
  "markdown": "# Using With RedwoodJS | ZenStack\n\n[RedwoodJS](https://redwoodjs.com/) is an opinionated full-stack framework that combines a set of tools and libraries and helps you build GraphQL-based applications quickly without struggling with tooling.\n\nZenStack provides a plugin package to help you easily integrate with RedwoodJS projects. After setting it up, you can define access policies in ZModel and use the enhanced `PrismaClient` to enforce the policies in your services automatically.\n\n## Details[‚Äã](https://zenstack.dev/docs/1.x/guides/redwood#details \"Direct link to Details\")\n\n### Setting up[‚Äã](https://zenstack.dev/docs/1.x/guides/redwood#setting-up \"Direct link to Setting up\")\n\nYou can prepare your RedwoodJS project for ZenStack by running the following command at the root of your project:\n\n```\nyarn rw setup package @zenstackhq/redwood\n```\n\nThe setup command will:\n\n1.  Update \"redwood.toml\" to allow the ZenStack CLI plugin\n    \n    ```\n    [[experimental.cli.plugins]]package = \"@zenstackhq/redwood\"enabled = true\n    ```\n    \n2.  Install ZenStack dependencies to the \"api\" package\n    \n    *   `zenstack`: the main CLI\n    *   `@zenstackhq/runtime`: the runtime library for creating enhanced `PrismaClient`\n    *   `@zenstackhq/redwood`: custom CLI and runtime for RedwoodJS\n3.  Prepare ZModel schema\n    \n    Your Prisma schema file \"api/db/schema.prisma\" will be copied to \"api/db/schema.zmodel\". Moving forward, you should edit \"schema.zmodel\" to update the database schema and access policies. The \"schema.prisma\" file will be regenerated when you run `yarn rw @zenstackhq generate`.\n    \n4.  Register the location of \"schema.zmodel\" and \"schema.prisma\" in \"api/package.json\"\n    \n    api/package.json\n    \n    ```\n    {  ...  \"zenstack\": {    \"schema\": \"db/schema.zmodel\",    \"prisma\": \"db/schema.prisma\"  }}\n    ```\n    \n5.  Install a GraphQLYoga plugin to the GraphQL handler\n    \n    api/src/functions/graphql.\\[ts|js\\]\n    \n    ```\n    import { useZenStack } from '@zenstackhq/redwood'import { db } from 'src/lib/db'import { createGraphQLHandler } from '@redwoodjs/graphql-server'...export const handler = createGraphQLHandler({  ...  extraPlugins: [useZenStack(db)],})\n    ```\n    \n    The `useZenStack` plugin creates an enhanced `PrismaClient` for the current requesting user and stores it as `db` field in the global GraphQL context. You can use it in your service code via `context.db`. For example, the service for listing blog posts can be implemented as follows: only posts readable to the current user will be returned.\n    \n    api/src/services/posts/posts.js\n    \n    ```\n    export const posts = (...args) => {  return context.db.post.findMany()}\n    ```\n    \n    The plugin, by default, uses `context.currentUser` to get the current requesting user. You can customize it by passing in a function as the second argument to calculate a custom user object based on `context.currentUser`. E.g.:\n    \n    ```\n    useZenStack(db, async (currentUser) => {  const typedUser = currentUser as { id: string };  const dbUser = await db.user.findUnique({     where: { id: typedUser.id },    // select more fields    select: { id: true, role: true }  });  return dbUser;});\n    ```\n    \n    See [here](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user) for more details about accessing the current user.\n    \n6.  Eject service templates\n    \n    The setup runs `yarn rw setup generator service` to eject template files used by `yarn rw g service` command. It also modifies the templates to use `context.db` instead of `db` to access the database with automatic access policy enforcement.\n    \n\n### Modeling data and access policies[‚Äã](https://zenstack.dev/docs/1.x/guides/redwood#modeling-data-and-access-policies \"Direct link to Modeling data and access policies\")\n\nZenStack's ZModel language is a superset of Prisma schema language. You should use it to define both the data schema and access policies. [The Complete Guide](https://zenstack.dev/docs/1.x/the-complete-guide/part1/) of ZenStack is the best way to learn how to author ZModel schemas. Here's a quick example to show how you can define access policies for the blog post sample used throughout the official RedwoodJS tutorial:\n\napi/db/schema.zmodel\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String  body      String  comments  Comment[]  user      User     @relation(fields: [userId], references: [id])  userId    Int  createdAt DateTime @default(now())  published Boolean @default(true)  // üîê Admin user can do everything to his own posts  @@allow('all', auth().roles == 'admin' && auth() == user)  // üîê Posts are visible to everyone if published  @@allow('read', published)}\n```\n\nYou should run the following command after updating \"schema.zmodel\":\n\n```\nyarn rw @zenstackhq generate\n```\n\nThe command does the following things:\n\n1.  Regenerate \"schema.prisma\"\n2.  Run `prisma generate` to regenerate `PrismaClient`\n3.  Generate supporting JS modules for enforcing access policies at runtime\n\n### Development workflow[‚Äã](https://zenstack.dev/docs/1.x/guides/redwood#development-workflow \"Direct link to Development workflow\")\n\nThe workflow of using ZenStack is very similar to using Prisma in RedwoodJS projects. The two main differences are:\n\n1.  Code generation\n    \n    You should run `yarn rw @zenstackhq generate` instead of `yarn rw prisma generate`. The ZenStack's \"generate\" command internally regenerates the Prisma schema from the ZModel schema, runs `prisma generate` automatically, and outputs supporting modules for access policy enforcement.\n    \n2.  Database access in services\n    \n    In your service code, you should use `context.db` instead of `db` for accessing the database. The setup procedure prepared a customized service code template. When you run `yarn rw g service`, the generated code will already use `context.db`.\n    \n\nOther Prisma-related workflows like generation migration or pushing schema to the database stay unchanged.\n\n### Deployment[‚Äã](https://zenstack.dev/docs/1.x/guides/redwood#deployment \"Direct link to Deployment\")\n\nYou should run the \"generate\" command in your deployment script before `yarn rw deploy`. For example, to deploy to Vercel, the command can be:\n\n```\nyarn rw @zenstackhq generate && yarn rw deploy vercel\n```\n\nNotes about Netlify\n\nZenStack generates supporting JS modules into the `node_modules/.zenstack` folder, and the folder needs to be accessible at the runtime. Netlify detects the dependencies it needs to bundle by inspecting an application's root package.json file. This will result in the `.zenstack` folder being ignored.\n\nTo fix this problem, add the following section to your `netlify.toml` file:\n\n```\n[functions]  included_files = [\"node_modules/.zenstack/*\"]\n```\n\n### Using the `@zenstackhq` CLI plugin[‚Äã](https://zenstack.dev/docs/1.x/guides/redwood#using-the-zenstackhq-cli-plugin \"Direct link to using-the-zenstackhq-cli-plugin\")\n\nThe `@zenstackhq/redwood` package registers a set of custom commands to the RedwoodJS CLI under the `@zenstackhq` namespace. You can run it with:\n\n```\nyarn rw @zenstackhq <cmd> [options] \n```\n\nThe plugin is a simple wrapper of the standard `zenstack` CLI, similar to how RedwoodJS wraps the standard `prisma` CLI. It's equivalent to running `npx zenstack ...` inside the \"api\" directory.\n\nSee the [CLI references](https://zenstack.dev/docs/1.x/reference/cli) for the complete list of commands.\n\n## Sample application[‚Äã](https://zenstack.dev/docs/1.x/guides/redwood#sample-application \"Direct link to Sample application\")\n\nYou can find a completed multi-tenant Todo application built with RedwoodJS and ZenStack at: [https://github.com/zenstackhq/sample-todo-redwood](https://github.com/zenstackhq/sample-todo-redwood).",
  "title": "Using With RedwoodJS | ZenStack",
  "description": "Guide for using ZenStack with RedwoodJS.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/debugging",
  "markdown": "# Debugging and Troubleshooting | ZenStack\n\nVersion: 1.x\n\nZenStack's access policies are powerful, but when the rules get complex, it can be challenging to reason why an operation is being allowed or denied. This guide lists some techniques for debugging and troubleshooting.\n\n### Enable Debug Logging[‚Äã](https://zenstack.dev/docs/1.x/guides/debugging#enable-debug-logging \"Direct link to Enable Debug Logging\")\n\nZenStack enforces access policies by injecting into Prisma queries, so a straightforward way to see what's going on is to enable logging of such queries. You can achieve it with two steps:\n\n1.  When calling `enhance()` to create an enhanced PrismaClient, pass in a `logPrismaQueries` option set to `true`:\n    \n    ```\n    const db = enhance(prisma, { user }, { logPrismaQuery: true })\n    ```\n    \n2.  Enable \"info\" level logging on PrismaClient\n    \n    The queries will be logged into PrismaClient's logger with the \"info\" level, so you need to ensure that level is turned on when creating the PrismaClient instance.\n    \n    ```\n    const prisma = new PrismaClient({ log: ['info'] });\n    ```\n    \n\nWhen these are set up, you should be able to see all Prisma queries ZenStack makes in the console like the following:\n\n```\nprisma:info [policy] `findMany` list:{  where: {    AND: [      { NOT: { OR: [] } },      {        OR: [          { owner: { is: { id: 1 } } },          {            AND: [              {                space: {                  members: {                    some: { user: { is: { id: 1 } } }                  }                }              },              { NOT: { private: true } }            ]          }        ]      }    ]  }}\n```\n\n### Try Things Out In REPL[‚Äã](https://zenstack.dev/docs/1.x/guides/debugging#try-things-out-in-repl \"Direct link to Try Things Out In REPL\")\n\nThe `zenstack` CLI provides a REPL environment for you to execute queries with the regular or enhanced PrismaClient interactively. You can quickly switch between different user contexts and see how the access policies affect the result.\n\nPlease find more details about the REPL in the [CLI reference](https://zenstack.dev/docs/1.x/reference/cli#repl).\n\n* * *\n\nIn the future, we may devise more advanced debugging tools that help you break down complex rules and pinpoint the one that causes an operation to be allowed or denied. Please stay tuned!\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Debugging and Troubleshooting | ZenStack",
  "description": "ZenStack's access policies are powerful, but when the rules get complex, it can be challenging to reason why an operation is being allowed or denied. This guide lists some techniques for debugging and troubleshooting.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/deploy",
  "markdown": "# Deploying to Production | ZenStack\n\nVersion: 1.x\n\nAfter the hard work of building your application, nothing is more exciting than deploying it to production. This guide explains how ZenStack participates in the deployment process.\n\n### Running ZenStack CLI During Deployment[‚Äã](https://zenstack.dev/docs/1.x/guides/deploy#running-zenstack-cli-during-deployment \"Direct link to Running ZenStack CLI During Deployment\")\n\nIf you use a framework that requires a build step, for example, \"next build\" for Next.js, you can run `zenstack generate` as the very first step in the build process. It ensures the `schema.prisma` file is up-to-date, and the supporting modules are generated into the `node_modules/.zenstack` directory.\n\nHere's what the build script of our sample Todo app looks like for deploying to Vercel:\n\npackage.json\n\n```\n{  \"scripts\": {    \"vercel-build\": \"zenstack generate && next build && prisma migrate deploy\"  }}\n```\n\n### Not Using ZenStack CLI During Deployment[‚Äã](https://zenstack.dev/docs/1.x/guides/deploy#not-using-zenstack-cli-during-deployment \"Direct link to Not Using ZenStack CLI During Deployment\")\n\nThere might be cases where you don't want to run the `zenstack` CLI during the deployment process. For example, you may want to avoid installing dev dependencies during the build to keep a clean \"node\\_modules\" folder. In such cases, you can run `zenstack generate` with a `--output` option to generate the supporting modules into your source tree and then commit them to your repository.\n\n```\nnpx zenstack generate --output ./zenstack\n```\n\nAt the runtime, when calling `enhance()`, you need to pass in an extra `loadPath` option to point to the directory where the supporting modules are located:\n\n```\nconst db = enhance(prisma, { user }, { loadPath: './zenstack' })\n```\n\nIn this way, all information ZenStack needs at runtime is already in the source tree, and you don't need to run `zenstack generate` during deployment.\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Deploying to Production | ZenStack",
  "description": "After the hard work of building your application, nothing is more exciting than deploying it to production. This guide explains how ZenStack participates in the deployment process.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/server-adapters/fastify",
  "markdown": "# Fastify | ZenStack\n\n```\n// create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n```\n\n```\n{    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n```",
  "title": "Fastify | ZenStack",
  "description": "Adapter for integrating with Fastify",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/zmodel",
  "markdown": "# ZModel Language | ZenStack\n\nThe first thing that ZenStack may surprise you is that, unlike other Prisma tools, we created a new schema language called _ZModel_. It's a superset of the Prisma Schema Language (PSL) with syntax elements to support additional features. The `zenstack` CLI takes a ZModel file as input and generates a Prisma Schema file out of it - which in turn can be fed to the standard `prisma` CLI for generating a Prisma Client or migrating the database.\n\nWhy did we invent a new schema language?\n\n### Why ZModel?[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#why-zmodel \"Direct link to Why ZModel?\")\n\n#### Custom Attributes[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#custom-attributes \"Direct link to Custom Attributes\")\n\nWhile Prisma Schema Language provides a terse and intuitive way to define data models, it has a major extensibility limitation: you can't add custom attributes. Prisma provides a set of pre-defined attributes to control detailed aspects of your tables and fields, but you're stuck when you need custom ones for your special modeling purposes. Traditionally, Prisma community tools have been hacking around this limitation by smuggling custom information in code comments, like the following example with [TypeGraphQL Prisma](https://prisma.typegraphql.com/):\n\n```\nmodel User {    id Int @default(autoincrement()) @id    email String @unique    /// @TypeGraphQL.omit(output: true, input: true)    password String}\n```\n\nIt works, but it's ugly and gets no protection from the compiler. The model can become messy if it's littered with such hacks everywhere. One of the biggest reasons for introducing the ZModel language is to systematically remove this obstacle so that we have a solid foundation for adding custom semantics into the schema down the road.\n\nHere's a quick example of the custom `@password` and `@omit` attributes ZModel added for automatically hashing passwords upon saving and omitting them from query results:\n\n```\nmodel User {    id Int @default(autoincrement()) @id    email String @unique    password String @omit @password}\n```\n\nThe access policies and data validation rules are also implemented with custom attributes. Don't worry. We'll cover them in detail in the following chapters.\n\n#### Other Language Features[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#other-language-features \"Direct link to Other Language Features\")\n\nA custom schema language also allows us to add new language features besides custom attributes. For example:\n\n1.  The `import` syntax for breaking down a large schema into multiple files\n2.  The `extends` syntax for inheriting fields from a base model\n\nHere's an example of how to use them to manage large schemas more effectively:\n\nbase.zmodel\n\n```\nabstract model Base {    id Int @id @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)    // author has full access    @@allow('all', auth() != null && published)}\n```\n\nschema.zmodel\n\n```\nimport \"base\"model User extends Base {    name String}model Post extends Base {    title String    content String?    viewCount Int @default(0)    comment Comment[]}model Comment extends Base {    content String    post Post @relation(fields: [postId], references: [id])    postId Int}\n```\n\n#### A Better Plugin System[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#a-better-plugin-system \"Direct link to A Better Plugin System\")\n\nPrisma allows you to write custom generators. However, the generator development API is undocumented and difficult to understand. ZenStack provides a plugin system that enables you to generate custom artifacts with a simple API and object model. In fact, almost all the features of ZenStack itself are implemented as plugins. [Part II](https://zenstack.dev/docs/the-complete-guide/part2) of this guide is dedicated to covering the plugin system.\n\n### ZModel Structure[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#zmodel-structure \"Direct link to ZModel Structure\")\n\nThe ZModel language is a superset of Prisma Schema Language (PSL). All Prisma schema syntaxes are valid in ZModel. A ZModel can contain the following declarations.\n\n#### Imports[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#imports \"Direct link to Imports\")\n\nThe `import` syntax is an extension to PSL. You can use it to break down a large schema into multiple files.\n\nschema.zmodel\n\n```\nimport \"user\"import \"post\"\n```\n\nuser.zmodel\n\n```\nmodel User {    id Int @id @default(autoincrement())    email String @unique    posts Post[]}\n```\n\npost.zmodel\n\n```\nmodel Post {    id Int @id @default(autoincrement())    title String    author User @relation(fields: [authorId], references: [id])    authorId Int}\n```\n\nWhen the `zenstack` CLI compiles an input schema, it merges the content of all imported files into a single schema before further processing.\n\n#### Data Source[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#data-source \"Direct link to Data Source\")\n\nThe `datasource` declaration of ZModel is exactly the same as PSL. ZenStack passes it to the generated Prisma schema without modification.\n\n```\ndatasource db {    provider = \"postgresql\"    url      = env(\"DATABASE_URL\")}\n```\n\n#### Prisma Generators[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#prisma-generators \"Direct link to Prisma Generators\")\n\nThe `generator` declarations of ZModel are exactly the same as PSL. ZenStack passes it to the generated Prisma schema without modification.\n\n```\ngenerator client {    provider = \"prisma-client-js\"}\n```\n\n#### Plugins[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#plugins \"Direct link to Plugins\")\n\nPlugins are the new extensibility mechanism provided by ZModel. Its syntax is similar to generators but with the `plugin` declaration keyword. Here's an example for generating tRPC CRUD routers:\n\n```\nplugin trpc {    provider = \"@zenstackhq/trpc\"    output   = \"src/generated\"}\n```\n\n[Part II](https://zenstack.dev/docs/the-complete-guide/part2) of this guide will cover the plugin system in detail.\n\n#### Models[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#models \"Direct link to Models\")\n\nThe `model` declaration of ZModel is exactly the same as PSL, except for the new set of attributes ZenStack added.\n\n```\nmodel User {    id Int @id @default(autoincrement())    // during create and update, ZenStack validates the field is a valid email address    email String @unique @email    // the field is automatically hashed upon saving, and omitted from query results    password String @omit @password    // access policy: open to sign up    @@allow('create', true)    // access policy: the user has full access to self    @@allow('all', auth() == this)}\n```\n\n### IDE Support[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#ide-support \"Direct link to IDE Support\")\n\nZenStack comes with a [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) and a [JetBrains IDE plugin](https://plugins.jetbrains.com/plugin/23397-zenstack-language-tools). You can find more information about IDE support [here](https://zenstack.dev/docs/guides/ide).\n\n### Full Documentation[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/zmodel#full-documentation \"Direct link to Full Documentation\")\n\nCheck out the [ZModel Language](https://zenstack.dev/docs/reference/zmodel-language) reference documentation for a complete language description.",
  "title": "ZModel Language | ZenStack",
  "description": "The first thing that ZenStack may surprise you is that, unlike other Prisma tools, we created a new schema language called ZModel. It's a superset of the Prisma Schema Language (PSL) with syntax elements to support additional features. The zenstack CLI takes a ZModel file as input and generates a Prisma Schema file out of it - which in turn can be fed to the standard prisma CLI for generating a Prisma Client or migrating the database.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/prisma",
  "markdown": "# Prisma Crash Course | ZenStack\n\ninfo\n\nFeel free to skip to the [next chapter](https://zenstack.dev/docs/the-complete-guide/part1/zmodel) if you are already familiar with Prisma.\n\nZenStack is built above Prisma ORM, so it'll be important to have a basic understanding of it.\n\nPrisma is a so-called \"schema-first\" ORM that simplifies database access for Node.js and TypeScript applications. It provides an intuitive and concise DSL (Domain-Specific Language) for defining data models and generates a type-safe client for accessing the database.\n\nThis guide is by no means a comprehensive introduction to Prisma, but it covers the most essential parts of understanding and using it.\n\n### Prisma Schema[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/prisma#prisma-schema \"Direct link to Prisma Schema\")\n\nYou can define your data models in a file called `schema.prisma`. Here's an example:\n\n```\nmodel User {    id Int @id @default(autoincrement())    email String @unique    name String?}\n```\n\nThe `User` model contains a primary key `id` (indicated by the `@id` attribute), a unique `email` field, and an optional `name` field. The `@default` attribute specifies the field's default value, and the `autoincrement` function instructs the database to generate incrementing values automatically.\n\nModeling relationships is also easy. The following example shows a `Post` model with a one-to-many relationship with the `User` model. The `@relation` attribute is the key for connecting the two models by associating them with a foreign key.\n\n```\nmodel User {    id Int @id @default(@autoincrement())    ...    posts Post[]}model Post {    id Int @id @default(@autoincrement())    title String    author User @relation(fields: [authorId], references: [id])    authorId Int}\n```\n\n### Prisma Client[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/prisma#prisma-client \"Direct link to Prisma Client\")\n\nYou can run the Prisma CLI to generate a type-safe client for accessing the database.\n\nThe client is generated into the `@prisma/client` package and can be used as the following:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient();// create a userawait prisma.user.create({    data: { email: 'user1@abc.com' }});// create a user together with two related postsawait prisma.user.create({     data: {        email: 'user2@abc.com',        posts: {            create: [                { title: 'Post 1' },                { title: 'Post 2' }            ]        }    }});// find posts with title containing some text, and return the author of each post togetherconst posts = prisma.post.findMany({    where: { title: { contains: 'ZenStack' } },    include: { author: true }});// here the `posts` is smartly inferred to be typed `Array<Post & { author: User }>`console.log(posts[0].author.email);\n```\n\n### Prisma Migrate[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/prisma#prisma-migrate \"Direct link to Prisma Migrate\")\n\nTo synchronize your schema to the database tables and fields, run the \"migrate\" command:\n\nIt synchronizes the local database with the schema and generates a migration record (used for reconstructing database's schema when your app deploys).\n\nWhen deploying your app to an integration environment (e.g, staging or production), you should run\n\n```\nnpx prisma migrate deploy\n```\n\nto apply the migration records to the database.\n\n* * *\n\nPrisma has a rich set of other features not covered here, like schema migration, data browsing, etc., but we've got enough knowledge to understand and use ZenStack. Check out [Prisma Documentation](https://www.prisma.io/docs/getting-started) for a more comprehensive introduction.",
  "title": "Prisma Crash Course | ZenStack",
  "description": "Feel free to skip to the next chapter if you are already familiar with Prisma.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/cli",
  "markdown": "# ZenStack CLI | ZenStack\n\nThe `zenstack` CLI is the primary tool for using ZenStack in a project. The CLI is intentionally designed to have similar commands to the `prisma` CLI.\n\nIn this chapter, we'll use the CLI to scaffold our Todo sample project. You can find the complete documentation in the [CLI reference guide](https://zenstack.dev/docs/reference/cli).\n\n### üõ†Ô∏è Creating Our Sample Project[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/cli#%EF%B8%8F-creating-our-sample-project \"Direct link to üõ†Ô∏è Creating Our Sample Project\")\n\n#### 1\\. Initializing a Project[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/cli#1-initializing-a-project \"Direct link to 1. Initializing a Project\")\n\nYou can initialize an existing TypeScript project using the `zenstack init` command. To save some typing, we'll first use the \"try-prisma\" utility to create a simple TypeScript CLI project.\n\n```\nnpx try-prisma@latest -p . -n my-todo-app -t typescript/script --install npmcd my-todo-app\n```\n\nThen initialize the project for ZenStack:\n\nThe \"init\" command does the following things for you:\n\n1.  Install Prisma if it's not already installed.\n2.  Install the `zenstack` CLI package as a dev dependency.\n3.  Install the `@zenstackhq/runtime` package - used for enhancing `PrismaClient` at the runtime.\n4.  Copy the `prisma/schema.prisma` file to `schema.zmodel` if it exists; otherwise, create a new template `schema.zmodel` file.\n\nYou can always manually complete the steps above if you have a special project setup that the \"init\" command doesn't work with.\n\nAfter the initialization, please remember that you should edit the `schema.zmodel` moving forward. The `prisma/schema.prisma` file will be automatically regenerated when you run `zenstack generate`.\n\n#### 2\\. Preparing The Schema[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/cli#2-preparing-the-schema \"Direct link to 2. Preparing The Schema\")\n\nReplace the content of `schema.zmodel` with the following:\n\nschema.zmodel\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}generator js {  provider = \"prisma-client-js\"}// where users can collaborate on todo lists and itemsmodel Space {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  name String  slug String @unique  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)  ownerId Int  members SpaceUser[]  lists List[]}// a join table for many-to-many relation between `Space` and `User`model SpaceUser {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  space Space @relation(fields: [spaceId], references: [id], onDelete: Cascade)  spaceId Int  user User @relation(fields: [userId], references: [id], onDelete: Cascade)  userId Int  role String @default(\"USER\")  @@unique([userId, spaceId])}// usermodel User {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  email String @unique  name String?  spaces SpaceUser[] // user's space membership  lists List[]  todos Todo[]  ownedSpaces Space[] // spaces owned by the user}// todo listmodel List {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  space Space @relation(fields: [spaceId], references: [id], onDelete: Cascade)  spaceId Int  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)  ownerId Int  title String  private Boolean @default(false)  todos Todo[]}// todo itemmodel Todo {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)  ownerId Int  list List @relation(fields: [listId], references: [id], onDelete: Cascade)  listId Int  title String  completedAt DateTime?}\n```\n\ninfo\n\nOur sample project uses a SQLite database. You can use any other database supported by Prisma. Please refer to the [Prisma docs](https://www.prisma.io/docs/concepts/database-connectors) for more details.\n\nTake some time to familiarize yourself with the entities and their relations.\n\n![Todo App ERD](https://zenstack.dev/assets/images/todo-app-erd-ae0258b6364af45e83a87e5ba6895579.svg)\n\n#### 3\\. Generating Artifacts[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/cli#3-generating-artifacts \"Direct link to 3. Generating Artifacts\")\n\nThe CLI command you'll most often use is `zenstack generate`. It runs plugins (including the built-in ones that are automatically enabled and the ones you explicitly put into ZModel) to generate various artifacts.\n\nThe most important artifact is the Prisma schema. It's generated into the `prisma/schema.prisma` file by default. The command also automatically runs `prisma generate` to regenerate the Prisma Client.\n\nYou should see output like the following in your terminal:\n\n```\n‚åõÔ∏è ZenStack CLI vx.y.z, running plugins‚úî Generating Prisma schema‚úî Generating PrismaClient enhancer‚úî Generating Zod schemasüëª All plugins completed successfully!Don't forget to restart your dev server to let the changes take effect.\n```\n\nA bunch of plugins are run. When it is complete, the `prisma/schema.prisma` file should be updated to contain the new models we added. You can also use the models in your TS code now since the Prisma Client code has also been regenerated.\n\nFinally, push the schema to the database:\n\n#### 4\\. Seeding The Database[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/cli#4-seeding-the-database \"Direct link to 4. Seeding The Database\")\n\nLet's create a seed script to populate some test data into our database. Create a new file `prisma/seed.ts` with the following content:\n\nprisma/seed.ts\n\n```\nimport { PrismaClient } from '@prisma/client';const prisma = new PrismaClient();async function main() {    // clean up    await prisma.user.deleteMany();    await prisma.space.deleteMany();    const joey = await prisma.user.create({        data: {            email: 'joey@zenstack.dev',            name: 'Joey'        }    });    console.log('User created:', joey);    const rachel = await prisma.user.create({        data: {            email: 'rachel@zenstack.dev',            name: 'Rachel'        }    });    console.log('User created:', rachel);    const centralPerk = await prisma.space.create({        data: {            name: 'Central Perk',            slug: 'central-perk',            owner: { connect: { id: rachel.id } },            members: {                create: [                    {                        user: { connect: { id: joey.id } },                        role: 'USER'                    },                    {                        user: { connect: { id: rachel.id } },                        role: 'ADMIN'                    }                ]            }        }    });    console.log('Space created:', centralPerk);    const rachelPersonal = await prisma.space.create({        data: {            name: \"Rachel's Personal Space\",            slug: 'rachel',            owner: { connect: { id: rachel.id } },            members: {                create: [                    {                        user: { connect: { id: rachel.id } },                        role: 'ADMIN'                    }                ]            }        }    });    console.log('Space created:', rachelPersonal);}main()    .then(async () => {        await prisma.$disconnect();    })    .catch(async (e) => {        console.error(e);        await prisma.$disconnect();        process.exit(1);    });\n```\n\nThen add the seed script into \"package.json\":\n\npackage.json\n\n```\n{    ...    \"prisma\": {        \"seed\": \"ts-node prisma/seed.ts\"    }}\n```\n\nFinally, run the seed command to load the data into the database:\n\n```\nRunning seed command `ts-node prisma/seed.ts` ...User created: {  id: 1,  createdAt: 2023-11-07T21:37:22.506Z,  updatedAt: 2023-11-07T21:37:22.506Z,  email: 'joey@zenstack.dev',  name: 'Joey'}User created: {  id: 2,  createdAt: 2023-11-07T21:37:22.509Z,  updatedAt: 2023-11-07T21:37:22.509Z,  email: 'rachel@zenstack.dev',  name: null}Space created: {  id: 1,  createdAt: 2023-11-07T21:37:22.510Z,  updatedAt: 2023-11-07T21:37:22.510Z,  name: 'Central Perk',  slug: 'central-perk'}Space created: {  id: 2,  createdAt: 2023-11-07T21:37:22.512Z,  updatedAt: 2023-11-07T21:37:22.512Z,  name: \"Rachel's Personal Space\",  slug: 'rachel'}üå±  The seed command has been executed.\n```\n\n#### 5\\. Querying Data With REPL[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/cli#5-querying-data-with-repl \"Direct link to 5. Querying Data With REPL\")\n\nZenStack CLI comes with a convenient REPL mode that you can use to query data interactively. We'll use it to demonstrate ZenStack's features throughout the guide. Let's try a few commands here:\n\nEnter the REPL mode:\n\nThe REPL provides a global `prisma` instance that you can use directly. Execute a few queries (the REPL automatically awaits the result Promises):\n\n```\n{  id: 1,  createdAt: 2023-11-07T21:37:22.506Z,  updatedAt: 2023-11-07T21:37:22.506Z,  email: 'joey@zenstack.dev',  name: 'Joey'}\n```\n\n```\nprisma.space.findFirst({ include: { members: true } })\n```\n\n```\n{  id: 1,  createdAt: 2023-11-07T21:37:22.510Z,  updatedAt: 2023-11-07T21:37:22.510Z,  name: 'Central Perk',  slug: 'central-perk',  members: [    {      id: 1,      createdAt: 2023-11-07T21:37:22.510Z,      updatedAt: 2023-11-07T21:37:22.510Z,      spaceId: 1,      userId: 2,      role: 'ADMIN'    },    {      id: 2,      createdAt: 2023-11-07T21:37:22.510Z,      updatedAt: 2023-11-07T21:37:22.510Z,      spaceId: 1,      userId: 1,      role: 'USER'    }  ]}\n```\n\nThe REPL also provides a `db` variable for querying data with access control. We'll get back to it in [chapter 4](https://zenstack.dev/docs/the-complete-guide/part1/access-policy).\n\nYou can exit the REPL with the `.exit` command.\n\n#### 6\\. Listing Installed ZenStack Packages[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/cli#6-listing-installed-zenstack-packages \"Direct link to 6. Listing Installed ZenStack Packages\")\n\nZenStack provides multiple npm packages that implement either plugins or runtime functionalities. The `zenstack` and `@zenstackhq/runtime` packages are almost always needed. The other packages are optional and can be installed based on your needs.\n\nWhen you upgrade ZenStack, it's important to keep all package versions in sync to avoid unexpected results. The `zenstack info` command can help you list all installed ZenStack packages and their versions. It also checks and prompts if there are newer versions available.\n\nTry running it in our project:\n\n```\nInstalled ZenStack Packages:    zenstack                    x.y.z    @zenstackhq/runtime         x.y.z‚úî Checking npm registryYou are using the latest version of Zenstack.\n```\n\n### ZenStack CLI & Prisma CLI[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/cli#zenstack-cli--prisma-cli \"Direct link to ZenStack CLI & Prisma CLI\")\n\nThe ZenStack CLI is not meant for replacing the Prisma CLI. After `zenstack generate` generates the Prisma schema, you can use the Prisma CLI as you normally do to complete tasks like:\n\n*   Creating migration records with `prisma migrate dev`\n*   Pushing schema changes to the db with `prima db push`\n*   Launching Prisma Studio with `prisma studio`\n*   ...\n\nThe Prisma development workflow that you're already familiar with should work seamlessly with ZenStack. See [here](https://zenstack.dev/docs/guides/dev-workflow) for a detailed explanation of the development workflow.\n\n![ZModel Generation](https://zenstack.dev/img/intro/zmodel-generation-light.png)![ZModel Generation](https://zenstack.dev/img/intro/zmodel-generation-dark.png)",
  "title": "ZenStack CLI | ZenStack",
  "description": "The zenstack CLI is the primary tool for using ZenStack in a project. The CLI is intentionally designed to have similar commands to the prisma CLI.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/access-policy/model-level",
  "markdown": "# Model-Level Policies | ZenStack\n\nThe most frequently used access policies are those declared at the model level - written using the `@@allow` and `@@deny` model-level attributes.\n\nModel-level vs field-level attributes\n\nZenStack follows Prisma's convention: model-level attributes are prefixed with `@@`, and field-level attributes with `@`.\n\nHere's a basic example:\n\n```\nmodel Post {    id Int @id    title String    published Boolean @default(false)    // published posts are readable    @@allow('read', published)}\n```\n\nYou can also achieve the same goal with `@@deny`:\n\n```\nmodel Post {    id Int @id    title String    published Boolean @default(false)    @@allow('read', true)    @@deny('read', !published)}\n```\n\nBoth `@@allow` and `@@deny` take two arguments:\n\n1.  Operation\n    \n    `create`, `read`, `update`, `delete`, or a comma-separated list of them. You can also use `all` to abbreviate all operations.\n    \n2.  Condition: a boolean expression\n    \n    You can use boolean literals: `true` and `false`. Operators `==`, `!=`, `>`, `>=`, `<`, and `<=` can be used to compare values. You can also use `&&`, `||`, and `!` to compose boolean expressions.\n    \n    There are functions and special expressions that help you write more advanced conditions. We'll cover them in later chapters.\n    \n\n### Evaluation of Model-Level Policies[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/model-level#evaluation-of-model-level-policies \"Direct link to Evaluation of Model-Level Policies\")\n\nYou can write as many policy rules as you want for a model. The order of the rules doesn't matter.\n\nZenStack determines whether a CRUD operation is allowed using the following logic:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied (secure by default).\n\nEach of the CRUD operation types governs a set of Prisma Client methods, as follows:\n\n*   **create**\n    \n    `create`, `createMany`, `upsert`, and `create`/`createMany`/`connectOrCreate` nested in create/update calls.\n    \n*   **read**\n    \n    `findUnique`, `findUniqueOrThrow`, `findFirst`, `findFirstOrThrow`, `count`, `aggregate`, and `groupBy`.\n    \n    The \"read\" operation also determines whether the value returned from `create`, `update` and `delete` method can be read.\n    \n*   **update**\n    \n    `update`, `updateMany`, `upsert`, and `update`/`updateMany`/`set`/`connect`/`connectOrCreate`/`disconnect` nested in create/update calls.\n    \n*   **delete**\n    \n    `delete`, `deleteMany`, and `delete` nested in update calls.\n    \n\nRelation manipulation and policies\n\nWhen a Prisma call involves relation manipulation, it can be unobvious which side the relation needs to satisfy the \"update\" policies. For example, given the following model:\n\n```\nmodel User {    ...    posts Post[]}model Post {    ...    author User @relation(fields: [authorId], references: [id])    authorId Int}\n```\n\nIf we add a post to a user like:\n\n```\ndb.user.update({    where: { id: 1 },    data: {        posts: { connect: { id: 1 } }    }})\n```\n\nDoes `Post#1` need to satisfy its \"update\" policies?\n\nThe trick is to consider which side of the relation will have a foreign key update. In this example, the foreign key `authorId` of `Post#1` will be updated, so `Post#1` needs to satisfy its \"update\" policies, and `User`'s \"update\" policies are not relevant.\n\nA special case is Prisma's [implicit many-to-many relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). Since there are no explicit foreign keys in this case, manipulating such a relation requires both sides to satisfy the \"update\" policies.\n\n### How Do Policies Affect Prisma Client's Behavior?[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/model-level#how-do-policies-affect-prisma-clients-behavior \"Direct link to How Do Policies Affect Prisma Client's Behavior?\")\n\nEnforcing access policies causes an enhanced Prisma Client to behave differently from the original. You can predict what happens with the following principles:\n\n*   Read methods behave as if the rows not satisfying the policies don't exist\n    \n    For example, `findMany` only returns rows that satisfy the policies. `count` only counts rows that satisfy the policies. This applies to nested reads as well. ZenStack enforces \"read\" policies by injecting `where` clauses into the Prisma query.\n    \n\nNested read can filter out parent records\n\nThere's one thing that may catch you off guard. When you do a find and include a to-one relation field, if the field is not nullable and cannot be ready by the current user, it'll result in the parent record being filtered out. For example:\n\n```\n// if `author` is not readable, the parent `Post` is excludedconst posts = await db.post.findMany({ include: { author: true }});\n```\n\nThe reason for this design choice is two-fold:\n\n1.  Type safety\n    \n    If we silently drop the `author` field, we'll break type-safety because the `author` field is not optional in its TS definition.\n    \n2.  Performance\n    \n    Prisma doesn't provide a direct way to include a non-nullable to-one relation conditionally. If we choose to drop the field, we'll have to do post-read processing, which may require additional database queries.\n    \n\n*   Bulk update and bulk delete methods behave as if the rows that don't satisfy the policies don't exist\n    \n    For example, `updateMany` only updates rows that satisfy the policies. Same for `deleteMany`. ZenStack enforces \"update\" and \"delete\" policies by injecting `where` clauses into the Prisma query.\n    \n*   Other write methods throw errors if the corresponding policies are not satisfied\n    \n    For example, `create` throws an error if the policies are not satisfied. When possible, ZenStack determines policy satisfaction by inspecting the input object of the Prisma query. Otherwise, it wraps the write into a transaction and checks the policies after the write is complete but before the transaction commits.\n    \n    If a nested write causes a policy violation, the top-level write will be rejected as a whole.\n    \n\nA write can imply a read\n\nHere's another fun fact about access policies. A `create`, `update` or `delete` call may succeed but still throw an error. Why?\n\nThe reason is that a write can imply a read. When you call `db.user.create`, the created result will be returned and subject to the \"read\" policy check. If it fails, an error will be thrown even though the write is persisted.\n\n### üõ†Ô∏è Giving It a Try[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/model-level#%EF%B8%8F-giving-it-a-try \"Direct link to üõ†Ô∏è Giving It a Try\")\n\nLet's continue working on our Todo app and add some access policies. Add the following rule to the `User` model:\n\nschema.zmodel\n\n```\nmodel User {    ...    @@allow('read', startsWith(email, 'joey'))}\n```\n\ninfo\n\n`startsWith` is an attribute function that checks whether a field starts with a given string. We'll cover functions in detail in [Expressions and Functions](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func).\n\nThen rerun generation and start the REPL:\n\n```\nnpx zenstack generatenpx zenstack repl\n```\n\nNow query users with the enhanced Prisma Client:\n\nThis time, we should get back a user. Our policy rule is working!\n\n```\n[  {    id: 1,    createdAt: 2023-11-07T21:37:22.506Z,    updatedAt: 2023-11-07T21:37:22.506Z,    email: 'joey@zenstack.dev',    name: 'Joey'  }]\n```\n\nYou'll still encounter an error if you try to create a user since we haven't added any \"create\" rule yet:\n\n```\ndb.user.create({ data: { email: 'ross@zenstack.dev', name: 'Ross' } });\n```\n\n```\ndenied by policy: user entities failed 'create' checkCode: P2004Meta: { reason: 'ACCESS_POLICY_VIOLATION' }\n```\n\n### Next[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/model-level#next \"Direct link to Next\")\n\nUsing only the direct fields of a model for access control isn't super useful. In the following chapters, you'll learn how to the requesting user's information and relation fields to write more advanced rules.",
  "title": "Model-Level Policies | ZenStack",
  "description": "The most frequently used access policies are those declared at the model level - written using the @@allow and @@deny model-level attributes.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/access-policy/authn-authz",
  "markdown": "# Authentication and Authorization | ZenStack\n\nAuthentication and authorization are the two most important concepts for designing a secure application. To set up a solid knowledge foundation, let's first clarify what they mean respectively in the context of ZenStack.\n\n### Authentication[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/authn-authz#authentication \"Direct link to Authentication\")\n\nAuthentication is the process of verifying the identity of a user. It can be a simple email and password verification or an OAuth workflow that interacts with a third-party identity provider.\n\nZenStack is not an authentication solution, but it usually depends on one to work. In a real-world application, access control rules usually need to leverage the information of the requesting user. An authentication solution provides the user information.\n\nZenStack is agnostic to the authentication solution you use. The authentication system only needs to be able to provide an object that represents the current user. ZenStack uses it to create a user-scoped enhanced Prisma Client that enforces access policies.\n\nWe'll cover this topic in more detail in the next chapter.\n\n#### Popular Authentication Solutions[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/authn-authz#popular-authentication-solutions \"Direct link to Popular Authentication Solutions\")\n\nHere are some popular authentication solutions in the Javascript/Typescript ecosystem:\n\n*   [Auth.js (formerly NextAuth)](https://authjs.dev/)\n*   [Clerk](https://clerk.com/)\n*   [Supabase Auth](https://supabase.com/docs/guides/auth)\n*   [Auth0](https://auth0.com/)\n*   [Firebase Authentication](https://firebase.google.com/docs/auth)\n*   [Lucia](https://lucia-auth.com/)\n\nYou can find how to integrate some of these solutions in the [Integration With Authentication](https://zenstack.dev/docs/category/integrating-with-authentication) guides.\n\nAuthorization is the process of determining whether a user has permission to perform a specific action. ZenStack's core part is an authorization solution that directly couples with the database. It controls what CRUD actions a user can perform on a table or a field.\n\nSome commonly used patterns for modeling authorization are listed below (with increasing flexibility and complexity):\n\n1.  Access Control List (ACL)\n    \n    Users are directly assigned with permissions. For example, a user can be given `read` permission on the `Post` table.\n    \n2.  Role-Based Access Control (RBAC)\n    \n    Users are assigned roles, and roles are configured with permissions. For example, a user can be assigned an `admin` role, which is granted with full permission on the `Post` table.\n    \n3.  Attribute-Based Access Control (ABAC)\n    \n    Permissions are defined over attributes of the user and the resource. For example, a user can be assigned with 'read' permission to a `Post` row if the `Post` is published and the user is a subscribed member.\n    \n4.  Relation-Based Access Control (ReBAC)\n    \n    Permissions are defined by the presence of relationships between the subjects and resources. For example, a user can edit a `Post` if the user has an \"edit\" relationship with the `Post`.\n    \n\nA complex application often needs to use a combination of these patterns. ZenStack's access policy system is designed to be easy to use yet have excellent flexibility to tackle these challenges.",
  "title": "Authentication and Authorization | ZenStack",
  "description": "Authentication and authorization are the two most important concepts for designing a secure application. To set up a solid knowledge foundation, let's first clarify what they mean respectively in the context of ZenStack.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/enhancement",
  "markdown": "# Enhanced Prisma Client | ZenStack\n\nHere we are, the most exciting part of ZenStack.\n\nIn the previous chapters, we've been focusing on the design-time concepts: the ZModel language and the `zenstack` CLI. Now, let's get to ZenStack's power at runtime. You'll understand why we say ZenStack ‚ö°Ô∏èsupercharges‚ö°Ô∏è Prisma.\n\n### What Is Enhanced Prisma Client?[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/enhancement#what-is-enhanced-prisma-client \"Direct link to What Is Enhanced Prisma Client?\")\n\nAn enhanced Prisma Client is a transparent proxy that wraps a regular Prisma Client instance. It has the same API as the original Prisma Client but adds additional behaviors by intercepting API calls. The added behaviors include:\n\n*   Enforcing access policies\n*   Data validation\n*   Hashing passwords\n*   Omitting fields from query results\n\nMore will come in the future.\n\nCreating an enhanced Prisma Client is easy, just call the `enhance` API with a regular Prisma Client:\n\n```\nimport { PrismaClient } from '@prisma/client';import { enhance } from '@zenstackhq/runtime';const prisma = new PrismaClient();const db = enhance(prisma);// db has the same typing as prismaawait db.user.findMany();await db.user.create({ data: { email: 'zen@stack.dev'} });\n```\n\nIn a real-world application, you'll usually call `enhance` with an extra context argument to provide the current user identity, so that the access policy engine knows which user is making the call.\n\n```\nimport { getSessionUser } from './auth';// the `getSessionUser` implementation depends on your authentication solutionconst db = enhance(prisma, { user: getSessionUser() });\n```\n\nWe'll get to that in detail in the next chapter.\n\nA few extra notes about enhanced Prisma Client:\n\n*   **Creating an enhanced client is cheap**\n    \n    It doesn't cause new database connections to be made. It's common to create a new enhanced Prisma Client per request.\n    \n*   **Using Prisma Client Extensions with enhanced client**\n    \n    Enhanced Prisma Client can work with [Prisma Client Extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) with some caveats. Please refer to [Using With Prisma Client Extensions](https://zenstack.dev/docs/guides/client-extensions) for more details.\n    \n*   **Using the original client and an enhanced one together**\n    \n    You can use both in your application. For example, you may want to use an enhanced client in part of the logic where you want access policy enforcement, while using the original client where you need unrestricted access to the database.\n    \n\nLimitations\n\nWe try to make the enhanced Prisma Client as compatible as possible with the original Prisma Client, but there are still some limitations:\n\n1.  No Sequential Operations Transaction\n\nEnhanced Prisma CLient doesn't support [sequential operations transaction](https://www.prisma.io/docs/concepts/components/prisma-client/transactions#sequential-prisma-client-operations). Use [interactive transaction](https://www.prisma.io/docs/concepts/components/prisma-client/transactions#interactive-transactions) instead, or simply use the original Prisma Client.\n\n1.  Raw SQL APIs Are Not Enhanced\n\nAlthough you can call raw sql APIs like `$queryRaw` or `$executeRaw`, these APIs are not enhanced, so their behavior is the same as the original Prisma Client. It means that, for example, if you use `@omit` to mark a field to be dropped on return:\n\n```\nmodel User {    ...    password String @omit}\n```\n\nIf you query via `$queryRaw`, the `password` field will still be returned.\n\nYou should fall back to using the original Prisma Client in such cases.\n\n### Enhancement Kinds[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/enhancement#enhancement-kinds \"Direct link to Enhancement Kinds\")\n\nZenStack can enhance Prisma Client in several ways. When you call the `enhance` API to create an enhanced client, all enhancement kinds are enabled by default. You can use the `kinds` option to fine tune which ones to enable:\n\n```\nconst db = enhance(prisma, { user: getSessionUser() }, { kinds: ['policy'] });\n```\n\nSee [here](https://zenstack.dev/docs/reference/runtime-api#enhancement-kinds) for more details.\n\n### üõ†Ô∏è Using Enhanced Prisma Client In REPL[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/enhancement#%EF%B8%8F-using-enhanced-prisma-client-in-repl \"Direct link to üõ†Ô∏è Using Enhanced Prisma Client In REPL\")\n\nWe saw in the previous chapter that in the REPL environment, you can use the built-in `prisma` variable to access Prisma Client directly. Another variable named `db` gives you access to an enhanced Prisma Client.\n\nLet's try it out:\n\nIt works but gives an empty array. Why? With an enhanced Prisma Client, all operations are denied by default unless you explicitly open them up with access policies. Let's see how to do that in the next chapter.\n\n### Inner Workings[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/enhancement#inner-workings \"Direct link to Inner Workings\")\n\ninfo\n\nThis part is for those interested in the inner workings of ZenStack. It's not necessary to understand it to use ZenStack.\n\nIf you know the inner workings of Prisma Client, you'll find ZenStack shares some similarities.. When `zenstack generate` is run, besides generating the `prisma/schema.prisma` file, it also runs several other plugins that transform different pieces of information in the ZModel into Javascript code that can be efficiently loaded and executed at runtime. The `enhance` API from`@zenstackhq/runtime` relies on the generated Javascript modules to get its job done.\n\n*   `enhance`\n    \n    Contains the function that enhances a `PrismaClient`. The `enhance` API from `@zenstackhq/runtime` simply reexports this function.\n    \n*   `model-meta`\n    \n    Lightweight representation of ZModel's AST.\n    \n*   `policy`\n    \n    Partial Prisma query input objects compiled from access policy expressions.\n    \n*   `zod/**`\n    \n    Zod schemas for validating input data according to ZModel.\n    \n\nThe generation by default outputs to the `node_modules/.zenstack` folder. You can pass a `--output, -o` CLI switch when running `zenstack generate` to use a custom output location.\n\n```\nnpx zenstack generate -o lib/zenstack\n```\n\nWhen using a custom output location, you can't use the `enhance` API from `@zenstackhq/runtime` directly. Instead, import directly from the output location:\n\n```\nimport { enhance } from 'lib/zenstack/enhance';\n```\n\n### Next[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/enhancement#next \"Direct link to Next\")\n\nThis chapter gave an abstract overview of the enhanced Prisma Client. In the following chapters, you'll see how each kind of enhancement helps simplify your development work.\n\nLet's roll on.",
  "title": "Enhanced Prisma Client | ZenStack",
  "description": "Here we are, the most exciting part of ZenStack.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/data-validation",
  "markdown": "# Data Validation | ZenStack\n\nVersion: 2.x\n\n### Overview[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/data-validation#overview \"Direct link to Overview\")\n\nBesides permission control, an application often also has a notion of data validity: what form of data is allowed to be stored in the database? Database schema provides a preliminary mechanism for defining that, but many rules still need to be enforced outside of it. Here are a few quick examples:\n\n*   `email` field must be a valid email address.\n*   `password` field must be at least 8 characters long.\n*   A post's `slug` must only contain letters, numbers, and dashes.\n*   `price` field must be a positive number.\n*   `password` field is only allowed to have value if `identityProvider` field is set to `credentials`.\n\nTraditionally, developers either write imperative code to validate data or use a declarative validation library like [Zod](https://zod.dev/). ZenStack allows you to define such rules right inside the ZModel schema and automatically enforces them with the enhanced Prisma Client. When validation rules are violated during a \"create\" or \"update\" operation, the operation is rejected with an error.\n\ninfo\n\nData validation and access policy may have some similarities, but there are some fundamental differences:\n\n1.  Access policies are usually defined regarding the current user, while validation rules are defined against the data itself.\n2.  Access policies are mostly evaluated on the database side (through injection into Prisma queries), while data validation is evaluated entirely on the application side.\n3.  Access policies govern CRUD operations, while data validation only covers \"create\" and \"update\" actions.\n4.  Data validation only works with simple fields, not with relations.\n\n### Field-Level Validation[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/data-validation#field-level-validation \"Direct link to Field-Level Validation\")\n\nZenStack provides a set of field-level attributes for defining validation rules. You can find the full list of such attributes [here](https://zenstack.dev/docs/reference/zmodel-language#field-level-validation-attributes). Here are a few usage examples:\n\n```\nmodel User {    id Int @id    email String @unique @email @endsWith('@zenstack.dev')    imgUrl String? @url    password String @length(min: 8, max: 32)    age Int @gt(0) @lt(120)}\n```\n\nAll validation attributes also accept an extra parameter `message` for specifying a custom error message. For example:\n\n```\nmodel User {    ...    email String @unique @email('must be a valid email')    password String @length(min: 8, max: 32, message: 'must be between 8 and 32 characters long')}\n```\n\n### Model-Level Validation[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/data-validation#model-level-validation \"Direct link to Model-Level Validation\")\n\nYou can use the model-level `@@validate` attribute to define validation rules that involve multiple fields. A set of helper functions are provided for building complex validation expressions. You can find the full list of such functions [here](https://zenstack.dev/docs/reference/zmodel-language#model-level-validation-attributes). Here's an example:\n\n```\nmodel User {    id String @id    email String? @unique    activated Boolean @default(false)    @@validate(!activated || email != null, \"activated user must have an email\")}\n```\n\n### üõ†Ô∏è Adding Data Validation[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/data-validation#%EF%B8%8F-adding-data-validation \"Direct link to üõ†Ô∏è Adding Data Validation\")\n\nWe can use data validation to improve our app's robustness in many places. Two such examples are shown here:\n\n1.  Make sure `User`'s email is a valid email address.\n    \n    ```\n    model User {    ...    email String @unique @email}\n    ```\n    \n2.  Limit the format of `Space`'s slug.\n    \n    ```\n     model Space {      ...      slug String @unique @regex('^[0-9a-zA-Z_\\-]{4,16}$') }\n    ```\n    \n\nRerun generation and start REPL:\n\n```\nnpx zenstack generatenpx zenstack repl\n```\n\nTry to create a user with an invalid email address:\n\n```\ndb.user.create({ data: { email: 'xyz.abc' } })\n```\n\nObserve the validation error:\n\n```\ndenied by policy: user entities failed 'create' check, input failed validation: Validation error:Invalid email at \"email\"Code: P2004Meta: {  reason: 'DATA_VALIDATION_VIOLATION',  zodErrors: ZodError: [...]}\n```\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Data Validation | ZenStack",
  "description": "Overview",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/other-enhancements",
  "markdown": "# Other Enhancements | ZenStack\n\nBesides core enhancements like access policies, ZenStack also provides a few other lightweight enhancements targeting specific use cases.\n\n### Hashing Passwords[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/other-enhancements#hashing-passwords \"Direct link to Hashing Passwords\")\n\nWhen using a credential-based authentication system, it's important never to store the password in plain text. ZenStack provides a simple way to automatically hash passwords before storing them in the database. To enable it, simply mark the password field with the `@password` attribute.\n\n```\nmodel User {    id Int @id @default(autoincrement())    email String @unique    password String? @password}\n```\n\nUnder the hood, ZenStack uses [bcryptjs](https://github.com/dcodeIO/bcrypt.js/tree/master) to generate a hash.\n\nSee [here](https://zenstack.dev/docs/reference/zmodel-language#password) for more details about the `@password` attribute.\n\n#### üõ†Ô∏è Adding User Password[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/other-enhancements#%EF%B8%8F-adding-user-password \"Direct link to üõ†Ô∏è Adding User Password\")\n\nLet's add a `password` field to our `User` model, so we can implement credential-based authentication in the future.\n\n```\nmodel User {    ...    password String? @password}\n```\n\nRerun generation, push database schema, and start REPL:\n\n```\nnpx zenstack generatenpx prisma db pushnpx zenstack repl\n```\n\nTry to create a new user with a password:\n\n```\ndb.user.create({ data: { email: 'ross@zenstack.dev', password: 'abc123' }})\n```\n\nYou may see a surprising error:\n\n```\ndenied by policy: user entities failed 'create' check, result is not allowed to be read backCode: P2004Meta: { reason: 'RESULT_NOT_READABLE' }\n```\n\nRecall that in previous chapters, we mentioned that \"write can imply read\". In this case, the `create` operation returns the created user object, which is subject to the \"read\" policy check. Since we're using an anonymous context, the read operation is denied.\n\nHowever, if you use the raw Prisma Client to query, you can see the user is created, and his password is hashed:\n\n```\nprisma.user.findFirst({ orderBy: { id: 'desc' } });\n```\n\n```\n{  id: 3,  createdAt: 2023-11-09T05:53:28.793Z,  updatedAt: 2023-11-09T05:53:28.793Z,  email: 'ross@zenstack.dev',  password: '$2a$12$jYdALEg7gtIi.tc9JmFKuOG3X//0Cdo801xYotdtUw5pXV6Ahb.2m',  name: null}\n```\n\ninfo\n\nThis \"result not readable\" issue is often not a problem in practice, since a user with write privilege can also usually read. Sign-up flow is a special case where a user transitions from anonymous to authenticated. You can catch and ignore the error in the sign-up part. After the user logs in, you can use his identity for the subsequent operations.\n\nOr alternatively, you can use the raw Prisma Client in the authentication part of your system.\n\n### Omitting Fields[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/other-enhancements#omitting-fields \"Direct link to Omitting Fields\")\n\nSome database fields can be sensitive and should not be exposed to the client. Password is a good example (even when it's hashed). You can use the `@omit` attribute to mark a field, and it'll be automatically omitted when queried from an enhanced Prisma Client.\n\n```\nmodel User {    ...    password String? @password @omit}\n```\n\ninfo\n\nYou can use a field-level access policy to achieve the same goal:\n\n```\nmodel User {    ...    password String? @password @allow('read', false)}\n```\n\nHowever, using `@omit` is more appropriate since conceptually omitting sensitive field is not a permission issue.\n\n#### üõ†Ô∏è Omitting Password Field[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/other-enhancements#%EF%B8%8F-omitting-password-field \"Direct link to üõ†Ô∏è Omitting Password Field\")\n\nLet's mark the `password` field with `@omit`:\n\n```\nmodel User {    ...    password String? @password @omit}\n```\n\nRerun generation, push database schema, and start REPL:\n\n```\nnpx zenstack generatenpx prisma db pushnpx zenstack repl\n```\n\nQuery users, and you'll find the `password` field is omitted:\n\n```\n.auth { id: 1 }db.user.findFirst();\n```\n\n```\n{  id: 1,  createdAt: 2023-11-07T21:37:22.506Z,  updatedAt: 2023-11-07T21:37:22.506Z,  email: 'joey@zenstack.dev',  name: 'Joey'}\n```",
  "title": "Other Enhancements | ZenStack",
  "description": "Besides core enhancements like access policies, ZenStack also provides a few other lightweight enhancements targeting specific use cases.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func",
  "markdown": "# Expressions and Functions | ZenStack\n\nIn the previous chapters, we've informally introduced how policy expressions are written. This chapter will list all expression types supported and functions that help you construct complex rules.\n\n### Expressions[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#expressions \"Direct link to Expressions\")\n\n#### Literal Expression[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#literal-expression \"Direct link to Literal Expression\")\n\n*   String: both single or double quoted, `\"foo\"`, `'bar'`.\n*   Number: `123`, `3.14`.\n*   Boolean: `true`, `false`.\n*   Null: `null`.\n\n#### Array Expression[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#array-expression \"Direct link to Array Expression\")\n\nArray of expressions. E.g, `[1, 2, 3]`, `['foo', 'bar']`, `[ADMIN, MEMBER]`.\n\n#### Reference Expression[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#reference-expression \"Direct link to Reference Expression\")\n\nUsed to reference a model field or an enum field.\n\n```\nmodel Post {    ...    published Boolean    @@allow('read', published) // `published` is a Reference Expression}\n```\n\n#### This Expression[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#this-expression \"Direct link to This Expression\")\n\nRepresented by `this` keyword. Used to address the value of the containing model.\n\n```\nmodel User {    id Int @id    @@allow('all', auth() == this) // `this` is a This Expression}\n```\n\n#### Member Access Expression[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#member-access-expression \"Direct link to Member Access Expression\")\n\nUsed to access a field from an expression.\n\n```\nmodel Post {    id Int @id    published Boolean    @@allow('read', auth().role == 'READ') // `auth().role` is a Member Access Expression}\n```\n\n#### Invocation Expression[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#invocation-expression \"Direct link to Invocation Expression\")\n\nUsed to invoke a function. E.g, `auth()` is an Invocation Expression.\n\n#### Unary Expression[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#unary-expression \"Direct link to Unary Expression\")\n\n*   `!` Logical NOT, operand must be boolean\n\n#### Binary Expression[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#binary-expression \"Direct link to Binary Expression\")\n\n*   `==` Equality, translated to id comparison when model types are compared\n*   `!=` Inequality, translated to id comparison when model types are compared\n*   `>` Greater than, both operands must be number\n*   `>=` Greater than or equal to, both operands must be number\n*   `<` Less than, both operands must be number\n*   `<=` Less than or equal to, both operands must be number\n*   `&&` Logical AND, both operands must be boolean\n*   `||` Logical OR, both operands must be boolean\n*   `in` Membership, with the left operand being an array and the right operand being a literal or a reference to an enum field\n\n### Functions[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#functions \"Direct link to Functions\")\n\nYou can find the detailed signature of each function in the [Predefined attribute functions](https://zenstack.dev/docs/reference/zmodel-language#predefined-attribute-functions) document.\n\n#### auth()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#auth \"Direct link to auth()\")\n\nReturns the current user. The function call has the type of the [auth model](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#auth-model).\n\n#### now()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#now \"Direct link to now()\")\n\nReturns the current timestamp. The function call is typed `DateTime`.\n\n```\n@@allow('read', future().updatedAt < now())\n```\n\n#### future()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#future \"Direct link to future()\")\n\nRepresents the post-update model value. You'll learn more about it in the [next chapter](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/post-update).\n\n#### contains()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#contains \"Direct link to contains()\")\n\nReturns if a string field contains a value.\n\n```\nmodel Post {    id Int @id    title String    @@allow('read', contains(title, 'zenstack'))}\n```\n\nThe comparison is case-sensitive by default. You can also pass a third argument to make the comparison case insensitive:\n\n```\n@@allow('read', contains(title, 'zenstack', true))\n```\n\n#### search()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#search \"Direct link to search()\")\n\nReturns if a string field matches the search condition with [full-text-search](https://www.prisma.io/docs/concepts/components/prisma-client/full-text-search). Need to enable Prisma's \"fullTextSearch\" preview feature to use.\n\n```\n@@allow('read', contains(title, 'zenstack is awesome'))\n```\n\n#### startsWith()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#startswith \"Direct link to startsWith()\")\n\nReturns if a string field starts with a value.\n\n```\n@@allow('read', startsWith(title, 'zenstack'))\n```\n\n#### endsWith()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#endswith \"Direct link to endsWith()\")\n\nReturns if a string field ends with a value.\n\n```\n@@allow('read', endsWith(title, 'zenstack'))\n```\n\n#### has()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#has \"Direct link to has()\")\n\nReturns if an array field contains a value.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', has(tags, 'zenstack'))}\n```\n\n#### hasEvery()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#hasevery \"Direct link to hasEvery()\")\n\nReturns if an array field contains every value in the provided array.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', has(tags, ['zenstack', 'prisma']))}\n```\n\n#### hasSome()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#hassome \"Direct link to hasSome()\")\n\nReturns if an array field contains some value in the provided array.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', hasSome(tags, ['zenstack', 'prisma']))}\n```\n\n#### isEmpty()[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/expr-func#isempty \"Direct link to isEmpty()\")\n\nReturns if an array field is empty.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', isEmpty(tags))}\n```",
  "title": "Expressions and Functions | ZenStack",
  "description": "In the previous chapters, we've informally introduced how policy expressions are written. This chapter will list all expression types supported and functions that help you construct complex rules.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/conclusion",
  "markdown": "# Conclusion | ZenStack\n\nIn this part of the guide, we've focused on the core layer of ZenStack - an enhanced Prisma Client. The enhanced Prisma Client essentially turns the ORM into a fully secured data access layer, enabling the upper layer features like the automatic CRUD APIs and the generation of frontend data query libraries.\n\nThe design choice of enhancing Prisma Client makes ZenStack framework-agnostic. It can be used wherever Prisma is used - a CLI application, a Node.js backend, or a full-stack application - as a non-intrusive drop-in replacement.\n\nAs you have seen, the ZModel language provides great flexibility in modeling the authorization aspects of your application. If you want to learn how commonly used patterns like RBAC, ABAC, etc., can be modeled in ZModel, this blog post can be a good reference: [Modeling Authorization in Prisma - No Theory, Just Code](https://zenstack.dev/blog/model-authz).\n\nThe completed sample project up to the end of this part can be found in the \"part1\" branch of the [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/part1) repo. You can clone it and check out to that branch with the following command:\n\n```\ngit clone --branch part1 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```",
  "title": "Conclusion | ZenStack",
  "description": "In this part of the guide, we've focused on the core layer of ZenStack - an enhanced Prisma Client. The enhanced Prisma Client essentially turns the ORM into a fully secured data access layer, enabling the upper layer features like the automatic CRUD APIs and the generation of frontend data query libraries.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/access-policy/relations",
  "markdown": "# Working With Relations | ZenStack\n\n```\nmodel Space {  ...  // require login  @@deny('all', auth() == null)  // everyone can create a space  @@allow('create', true)  // users in the space can read the space  @@allow('read', members?[user == auth()])  // space admin can update and delete  @@allow('update,delete', members?[user == auth() && role == 'ADMIN'])}model SpaceUser {    ...    // require login    @@deny('all', auth() == null)    // space owner and admins have full access    @@allow('all', space.owner == auth() || space.members?[user == auth() && role == 'ADMIN'])    // user can read members of spaces that he's a member of    @@allow('read', space.members?[user == auth()])}model User {    ...    // everyone can sign up    @@allow('create', true)    // full access by oneself    @@allow('all', auth() == this)    // can be read by users sharing any space    @@allow('read', spaces?[space.members?[user == auth()]])}model List {    ...    // require login    @@deny('all', auth() == null)    // can be read by space members if not private    @@allow('read', owner == auth() || (space.members?[user == auth()] && !private))    // when create, owner must be set to current user, and user must be in the space    @@allow('create,update', owner == auth() && space.members?[user == auth()])    // can be deleted by owner    @@allow('delete', owner == auth())}model Todo {    ...    // require login    @@deny('all', auth() == null)    // owner has full access    @@allow('all', list.owner == auth())    // space members have full access if the parent List is not private    @@allow('all', list.space.members?[user == auth()] && !list.private)}\n```",
  "title": "Working With Relations | ZenStack",
  "description": "In the previous chapters, we've learned how to write basic policy rules involving model fields and the current user. However, real-world applications usually have authorization requirements that need to access relations. Here're some examples:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part2/using-plugins",
  "markdown": "# Using Plugins | ZenStack\n\n```\nplugin openapi {    provider = \"@zenstackhq/openapi\"    output = \"openapi.yaml\"    title = \"My Todo API\"    version = \"1.0.0\"}\n```",
  "title": "Using Plugins | ZenStack",
  "description": "To use a plugin, install the plugin npm package:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/access-policy/post-update",
  "markdown": "# Post-Update Checks | ZenStack\n\nAmong the \"create\", \"read\", \"update\", and \"delete\" operations, \"update\" is a special one, because its data has two states: pre-update and post-update. When you write a policy rule for \"update\", by default, you're checking against the pre-update state. But sometimes, you may want to inspect the post-update state. For example, you may wish to prevent a user from setting a \"revision\" to a smaller value than the current one.\n\nTo define a post-update rule, you use the `future()` function to access the post-update state. Here's an example:\n\n```\nmodel Post {    ...    revision Int    @@allow('update', future().revision > revision)}\n```\n\nAlthough there are two kinds of update rules, ZenStack uses a single \"update\" operation to represent both pre-update and post-update checks. The only difference is that you use the `future()` function to access the post-update state. What happens when pre-update and post-update rules are mixed? For example:\n\n```\nmodel Post {    ...    published Boolean    revision Int    @@allow('update', !published && future().revision > revision)}\n```\n\nWhen ZenStack detects that a model has \"update\" rules involving `future()` calls, it'll postpone the evaluation of all \"update\" rules of that model to the \"post-update\" stage. It analyzes what fields' pre-update state is needed and collects them before the update happens.\n\nOne of the use cases of post-update rules is to prevent modification of specific fields. For example, in our Todo app, we allow `List`'s owner to update its fields, but we shouldn't allow its owner to be changed. We can use a post-update rule to enforce this:\n\n```\nmodel List {    ...    @@deny('update', future().owner != owner)}\n```\n\nIt works, but it feels a bit awkward for such a common use case. In the next chapter, we'll learn a better way to handle this.",
  "title": "Post-Update Checks | ZenStack",
  "description": "Among the \"create\", \"read\", \"update\", and \"delete\" operations, \"update\" is a special one, because its data has two states: pre-update and post-update. When you write a policy rule for \"update\", by default, you're checking against the pre-update state. But sometimes, you may want to inspect the post-update state. For example, you may wish to prevent a user from setting a \"revision\" to a smaller value than the current one.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part2/builtin-plugins",
  "markdown": "# Built-in Plugins | ZenStack\n\nZenStack ships with a set of built-in plugins. They fall into the following two categories.\n\nMost of the core functionalities of ZenStack are implemented as or supported by a few core plugins. They're vital to the operation of ZenStack and are enabled automatically as needed. Core plugins are implemented inside the `zenstack` npm package and have names starting with `@core/`.\n\nThe ZenStack CLI automatically decides whether a core plugin should be enabled based on the ZModel. You can also explicitly declare a core plugin to override its options. For example, declare a `@core/prisma` plugin to output the generated Prisma schema file to a custom location:\n\n```\nplugin prisma {    provider = \"@core/prisma\"    output = \"src/db/prisma/schema.prisma\"}\n```\n\nBesides core plugins, the ZenStack team maintains a set of useful but non-essential plugins. They are implemented in separate npm packages under the `@zenstackhq` organization.",
  "title": "Built-in Plugins | ZenStack",
  "description": "ZenStack ships with a set of built-in plugins. They fall into the following two categories.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/debugging",
  "markdown": "# Debugging | ZenStack\n\nVersion: 2.x\n\nZenStack provides you with a set of powerful tools to model the authorization aspects of your application. However, it can be challenging to understand why an operation is rejected or why a query gives seemingly incorrect results.\n\nYou can let ZenStack log all queries sent to the wrapped Prisma Client and use it to inspect the effect of your policy rules. To enable the logging, pass an extra `logPrismaQuery` option when calling the `enhance` function:\n\n```\nconst db = enhance(prisma, { user }, { logPrismaQuery: true });\n```\n\nThe logs are output to the logger of Prisma Client with \"info\" level, so to be able to see it on the console, you'll also need to make sure it's turned on in the Prisma Client options:\n\n```\nconst prisma = new PrismaClient({ log: ['info'] });\n```\n\nAfter setting these up, you should be able to see all Prisma queries ZenStack makes in the console.\n\n### üõ†Ô∏è Debugging In REPL[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/debugging#%EF%B8%8F-debugging-in-repl \"Direct link to üõ†Ô∏è Debugging In REPL\")\n\nThe REPL environment provides a \".debug\" command to turn on/off debugging output on the fly.\n\n```\n.auth { id: 1 }.debugdb.list.findMany()\n```\n\nYou should see the Prisma queries injected by ZenStack printed in the console.\n\n```\nprisma:info [policy] `findMany` list:{  where: {    AND: [      { NOT: { OR: [] } },      {        OR: [          { owner: { is: { id: 1 } } },          {            AND: [              {                space: {                  members: {                    some: { user: { is: { id: 1 } } }                  }                }              },              { NOT: { private: true } }            ]          }        ]      }    ]  }}\n```\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Debugging | ZenStack",
  "description": "ZenStack provides you with a set of powerful tools to model the authorization aspects of your application. However, it can be challenging to understand why an operation is rejected or why a query gives seemingly incorrect results.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part2/conclusion",
  "markdown": "# Conclusion | ZenStack\n\nIn this part of the guide, we've focused on the plugin system of ZenStack. We've learned how to use plugins and how to write one.\n\nZModel contains a formal representation of how data is organized and its constraints. Besides serving as database schema and access control, it's an excellent source for powering other aspects of your app. Don't hesitate to write your own plugins when you feel the need.\n\nIn [Part III](https://zenstack.dev/docs/the-complete-guide/part3/) and [Part IV](https://zenstack.dev/docs/the-complete-guide/part4/) of the guide, you'll see in action how we use plugins to turn our Todo project from a schema to a full-stack application without writing much code.\n\nThe completed sample project up to the end of this part can be found in the \"part2\" branch of the [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/part2) repo. You can clone it and check out to that branch with the following command:\n\n```\ngit clone --branch part2 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```",
  "title": "Conclusion | ZenStack",
  "description": "In this part of the guide, we've focused on the plugin system of ZenStack. We've learned how to use plugins and how to write one.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user",
  "markdown": "# Accessing Current User | ZenStack\n\nIn most cases, whether a CRUD operation is allowed depends on the current user. ZenStack provides a special function `auth()` to access the current user in policy rules.\n\n### Auth Model[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#auth-model \"Direct link to Auth Model\")\n\nWhen ZModel is compiled, the `auth()` function needs to be resolved to a data model so that the compiler knows which fields are accessible from the function. By default, the model named \"User\" is used as the auth model. Here's an example:\n\n```\nmodel User {    id Int @id    role String    posts Post[]}model Post {    id Int @id    title String    author User @relation(fields: [authorId], references: [id])    authorId Int    // ‚úÖ valid rule    @@allow('all', auth().role == 'ADMIN')    // ‚ùå invalid rule, `subscribed` field doesn't exist in `User` model    @@allow('all', auth().subscribed == true) }\n```\n\nYou can use a model not named `User` as the auth model by adding the `@@auth` attribute to it.\n\n```\nmodel MyUser {    id Int @id    role String    posts Post[]    @@auth}\n```\n\nWhat if I don't store users in the database?\n\nIf you use an external authentication service like Clerk or Supabase, you can choose not to store users in the database, since the auth services are already doing this for you. However, in ZModel, the `auth()` function call always needs to be resolved to an auth model.\n\nThe trick here is to still define an auth model, but mark it with the `@@ignore` attribute so that it's excluded from the generated PrismaClient.\n\n```\nmodel User {    id String @id    ...    @@ignore}\n```\n\nAlso, when you generate Prisma migrations, make sure to remove the code generated for the `User` model.\n\nSince the `User` model is not mapped to a database table, you shouldn't have other models to have relations to it. Instead, you can store the user id provided by the authentication service in your models, which is like a \"foreign key\" but pointing to an external system.\n\n### Providing Current User[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#providing-current-user \"Direct link to Providing Current User\")\n\nSince ZenStack is not an authentication solution, it doesn't know who the current user is. It's up to the developer to get it from the authentication side and pass it to ZenStack (when calling the `enhance` function).\n\nHere's the pseudo-code:\n\n```\n// `getCurrentUser` is an authentication API that extracts // the current user from the requestconst user = await getCurrentUser(request);// create an enhanced Prisma Client for the user, the `user` object// provides value for the `auth()` function in policy rulesconst db = enhance(prisma, { user })\n```\n\nThe minimum requirement for the `user` object is to have a value for the \"id\" field of the auth model (if the model uses compound id fields, all fields need to be assigned). However, if your access policies involve other fields of the auth model, you need to provide them as well.\n\nProvide all fields needed by policy rules\n\nZenStack doesn't query the database automatically to fetch the missing fields, but you can do that as needed. Let's say if you have a policy rule like:\n\n```\n@@allow('update', auth().role == 'ADMIN')\n```\n\nBefore calling `enhance()`, you can hit the database (using the original Prisma Client) to fetch the user's role:\n\n```\nconst userId = getCurrentUserId(request);const user = await prisma.user.findUniqueOrThrow({ where: { id: userId }, select: { id: true, role: true } });const db = enhance(prisma, { user });\n```\n\n### Writing Conditions With `auth()`[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#writing-conditions-with-auth \"Direct link to writing-conditions-with-auth\")\n\n#### Checking Anonymous User[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#checking-anonymous-user \"Direct link to Checking Anonymous User\")\n\nYou can indicate that the current user is anonymous by not passing the `user` object (or passing `undefined`) when calling `enhance`:\n\n```\nconst db = enhance(prisma);\n```\n\nIn policy rules, check `auth() == null` for anonymous user:\n\n```\nmodel Post {    ...    // allow all login users to read    @@allow('read', auth() != null)}\n```\n\n#### Comparing `auth()` With Other Fields[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#comparing-auth-with-other-fields \"Direct link to comparing-auth-with-other-fields\")\n\nYou can compare `auth()` against a field of the same type (i.e., the auth model). Such comparison is equivalent to an id field comparison. For example, the following policy rule:\n\n```\nmodel Post {    ...    author User @relation(fields: [authorId], references: [id])    authorId Int    @@allow('update', auth() == author)}\n```\n\nis equivalent to:\n\n```\nmodel Post {    ...    author User @relation(fields: [authorId], references: [id])    authorId Int    @@allow('update', auth().id == author.id)}\n```\n\n, and is also equivalent to:\n\n```\nmodel Post {    ...    author User @relation(fields: [authorId], references: [id])    authorId Int    @@allow('update', auth().id == authorId)}\n```\n\n#### Traversing Relation Fields[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#traversing-relation-fields \"Direct link to Traversing Relation Fields\")\n\nYou can access auth model's relation fields from `auth()` function and chain them with other fields. Remember ZenStack doesn't fetch the fields accessed from `auth()` automatically, so you need to provide them (recursively if there's multi-level traversing) when calling `enhance()`.\n\n```\nmodel User {    ...    role Role}model Role {    ...    permissions Permission[]}model Permission {    ...    name String  // READ, WRITE, etc.}model Post {    ...    @@allow('read', auth().role.permissions?[name == 'READ'])}\n```\n\ninfo\n\nThe `expression?[condition]` syntax used above is called \"Collection Predicate Expression\". It's used for computing a boolean value from a \"\\*-to-many\" relation field. You'll learn more about it in the next chapter.\n\n### üõ†Ô∏è Adding User-Based Access Control[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#add-user-based-access-control \"Direct link to üõ†Ô∏è Adding User-Based Access Control\")\n\nAdd the following policies to the schema:\n\nschema.zmodel\n\n```\nmodel User {  ...  // everyone can sign up  @@allow('create', true)  // full access by oneself  @@allow('all', auth() == this)}model List {  ...  // owner has full access  @@allow('all', auth() == owner)}model Todo {  ...  // owner and list owner has full access  @@allow('all', auth() == owner || auth() == list.owner)}\n```\n\nRerun generation and start REPL:\n\n```\nnpx zenstack generatenpx zenstack repl\n```\n\nSetting Current User\n\nThe REPL provides a \".auth\" command for setting the current user. The user object passed to the command will serve value for the `auth()` function in policy rules at runtime. Run \".auth\" without arguments to switch back to the anonymous user.\n\nSwitch to user#1 and make a query:\n\n```\n.auth { id: 1 }db.user.findMany();\n```\n\n```\n[  {    id: 1,    createdAt: 2023-11-07T21:37:22.506Z,    updatedAt: 2023-11-07T21:37:22.506Z,    email: 'joey@zenstack.dev',    name: 'Joey'  }]\n```\n\nSwitch to user#2 and observe the difference:\n\n```\n.auth { id: 2 }db.user.findMany();\n```\n\n```\n[  {    id: 2,    createdAt: 2023-11-07T21:37:22.509Z,    updatedAt: 2023-11-07T21:37:22.509Z,    email: 'rachel@zenstack.dev',    name: 'Rachel'  }]\n```\n\nWe can also create Todo List now:\n\n```\ndb.list.create({ data: { title: 'Grocery', owner: { connect: { email: 'rachel@zenstack.dev' } }, space: { connect: { slug: 'central-perk' } } } })\n```\n\n```\n{  id: 1,  createdAt: 2023-11-08T04:38:53.385Z,  updatedAt: 2023-11-08T04:38:53.385Z,  spaceId: 1,  ownerId: 2,  title: 'Grocery',  private: false}\n```\n\nHowever, as user Rachel, we can't create a Todo List on behalf of Joey because it violates the `@@allow('all', auth() == owner)` rule:\n\n```\ndb.list.create({ data: { title: 'Grocery', owner: { connect: { email: 'joey@zenstack.dev' } }, space: { connect: { slug: 'central-perk' } } } })\n```\n\n```\ndenied by policy: list entities failed 'create' check, entity { id: 2 } failed policy checkCode: P2004Meta: { reason: 'ACCESS_POLICY_VIOLATION' }\n```\n\n* * *\n\nAllowing only the owners to read and write their own data is a good start, but we would like to let users in the same `Space` to collaborate on the Todo lists and items in the space. Achieving this requires traversing relations in policy rules, which we'll cover in the next chapter.",
  "title": "Accessing Current User | ZenStack",
  "description": "In most cases, whether a CRUD operation is allowed depends on the current user. ZenStack provides a special function auth() to access the current user in policy rules.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part1/under-the-hood",
  "markdown": "# How Does ZenStack Work Under the Hood?\n\nAdvanced Topic\n\nThis document is for advanced users who want to understand how ZenStack works under the hood. It's not required for using ZenStack.\n\nZenStack extends Prisma ORM mainly at two levels. First, it provides a modeling DSL (ZModel) - a superset of Prisma schema. Second, it allows the creation of enhanced wrappers for Prisma clients at runtime for injecting extra behaviors.\n\nThis document explains how these extensions work so that you can make a more informed judgment on whether ZenStack is the right choice for you.\n\n## ZModel Language[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/under-the-hood#zmodel-language \"Direct link to ZModel Language\")\n\nZenStack implemented the ZModel DSL from scratch, including the CLI and the VSCode extension, using the fantastic language toolkit [Langium](https://langium.org/). The DLS includes a plugin system, allowing a modular and extensible way to generate different artifacts from the schema. The core functionality of the toolkit is supported by the following core plugins:\n\n*   Prisma: `@core/prisma`\n    \n    The `@core/prisma` plugin generates the Prisma schema and Prisma client from the ZModel schema. The Prisma schema can then be used for common Prisma tasks like `db push`, `migrate dev`, etc.\n    \n*   Enhancer: `@core/enhancer`\n    \n    The `@core/enhancer` plugin generates several Javascript modules to support ZenStack's runtime enhancements to Prisma clients. The modules include:\n    \n    *   Model metadata\n        \n        Provides basic information about models and fields at runtime. The metadata is much more lightweight than the whole ZModel AST and is much cheaper to load.\n        \n        The default output location is `node_modules/.zenstack/model-meta.js`.\n        \n    *   Access policies\n        \n        Javascript function representation of access policy rules (expressed with `@@allow` and `@@deny` attributes). The functions take a context object as input and return partial Prisma query objects, which will be injected into Prisma query arguments at runtime. The context object contains the following properties:\n        \n        *   `user`: the current user, which serves as the return value of [`auth()`](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user) in the policy rules.\n        *   `preValue`: the previous value of an entity before update (for supporting the [`future()`](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/post-update) function in the policy rules).\n        \n        The default output location is `node_modules/.zenstack/policy.js`.\n        \n        For example, for the following `Post` model:\n        \n        ```\n        model Post {    id        String @id @default(cuid())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    title     String    published Boolean @default(false)    author    User @relation(fields: [authorId], references: [id])    authorId  String    // author has full access    @@allow('all', auth() == author)    // logged-in users can view published posts    @@allow('read', auth() != null && published)}\n        ```\n        \n        , the following checker functions are generated for \"read\" and \"update\" respectively:\n        \n        ```\n        function Post_read(context: QueryContext) {    const user = hasAllFields(context.user, ['id']) ? context.user : null;    return {        OR: [            user == null                ? { OR: [] } // false condition                : {                      author: {                          is: {                              id: user.id,                          },                      },                  },            {                AND: [                    user == null ? { OR: [] } : { AND: [] },                    {                        published: true,                    },                ],            },        ],    };}function Post_update(context: QueryContext) {    const user = hasAllFields(context.user, ['id']) ? context.user : null;    return user == null        ? { OR: [] } // false condition        : {              author: {                  is: {                      id: user.id,                  },              },          };}\n        ```\n        \n\n## Runtime Enhancements[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/under-the-hood#runtime-enhancements \"Direct link to Runtime Enhancements\")\n\nThe primary responsibility of ZenStack's runtime is to create _enhanced_ Prisma client instances. Runtime enhancements are achieved by creating transparent proxies around raw Prisma clients. The proxies intercept all Prisma client methods, inject into query arguments, and manipulate the query results returned by the client.\n\n### Access Policy[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/under-the-hood#access-policy \"Direct link to Access Policy\")\n\nAccess policy is the most complex part of the system. Part of the complexity comes from the great flexibility Prisma offers in querying and mutating data. For example, to enforce \"read\" rules on a `Post` model, we need to consider several possibilities:\n\n```\n// a direct where conditionprisma.post.findMany({    where: {...}});// nested fetch for relationsprisma.user.findUnique({    where: {id: ...},    include: { posts: true }});// nested fetch during mutationprisma.user.update({    where: {id: ...},    data: { ... },    select: { id: true, email: true, posts: true }});// ...\n```\n\nWe need the following measures to enforce access policies systematically:\n\n1.  **Inject filter conditions into the \"where\" clause in the context of \"find many\"**\n    \n    This covers cases like direct `findMany`/`findUnique`/`findFirst`/... calls:\n    \n    ```\n    prisma.user.findMany({ where: { ... } });// toprisma.user.findMany({    where: {        AND: [            { /* original conditions */ },            { /* read conditions */ },        ],    },});\n    ```\n    \n    Or nested \"find\" for a to-many relation:\n    \n    ```\n    prisma.user.findMany({ include: { posts: true } });// toprisma.user.findMany({    include: {        posts: {            where: {                /* read conditions */            },        },    },});\n    ```\n    \n    Or an implicit \"find\" carried with a mutation:\n    \n    ```\n    prisma.user.update({ data: { ... }, include: { posts: true } });// toprisma.user.update({ data: { ... }, include: { posts: { where: { /* read conditions */ } } } });\n    ```\n    \n2.  **Inject filter conditions into the \"where\" clause of \"mutate many\"**\n    \n    This covers cases like `updateMany` and `deleteMany`:\n    \n    ```\n    prisma.user.updateMany({ where: { ... }, data: { ... } });// toprisma.user.updateMany({    where: {        AND: [ { /* original conditions */ }, { /* update conditions */ } ]    },    data: { ... }});\n    ```\n    \n    Or nested usage of them:\n    \n    ```\n    prisma.user.update({ where: { ... }, data: { posts: { deleteMany: { where: { ... } } } } });// toprisma.user.update({ where: { ... },    data: {        posts: {            deleteMany: {                AND: [ { /* original conditions */ }, { /* delete conditions */ } ]            }        }    }});\n    ```\n    \n3.  **Post-read check for entities fetched as a to-one relation**\n    \n    To-one relation is a special case for reading because there's no way to do filtering at the read time: you either include it or not. So, we need to do a post-read check to ensure the fetched entity can be read.\n    \n    ```\n    const user = prisma.user.findUnique({ where: { id: ... }, include: { profile: true } });// toconst user = prisma.user.findUnique({ where: { id: ... }, include: { profile: true } });if (profile && !readable(user.profile)) {   // throw rejected error}\n    ```\n    \n4.  **Transaction-protected mutations**\n    \n    Policies that do \"post-mutation\" checks, including \"create\" and \"post-update\" (\"update\" rule calling [`future()`](https://zenstack.dev/docs/the-complete-guide/part1/under-the-hood#the-future-function) function) rules, are protected by a transaction. The mutation is conducted first, and then post-mutation checks are performed. If any of the checks fail, the transaction rolls back.\n    \n    Although, for simple cases, we can enforce policies by checking the mutation input, there are many cases where we can't safely rely on that. Instead, employing a transaction is the most reliable way to achieve a consistent result. In the future, we may add input checking as an optimization where possible.\n    \n    ```\n    prisma.user.create({ data: { ... } });// toprisma.$transaction((tx) => {    const user = prisma.user.create({ data: { ... } });    if (!createable(user)) {        // throw rejected error    }})\n    ```\n    \n\n### The `auth()` function[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/under-the-hood#the-auth-function \"Direct link to the-auth-function\")\n\nThe `auth()` function connects authentication with access control. It's typed as the auth model (the model named \"User\" by default) in ZModel and represents the current authenticated user. The most common way of setup is to read the auth model entity from the database after authentication is completed and pass the result to the `enhance` function as context.\n\nAlthough `auth()` resolves to the auth model, since it's provided by the user, there's no way to guarantee its value fully conforms to the model' typing: e.g., non-nullable fields can be passed as `null` or `undefined`. We employ some simple rules to deal with such cases:\n\n*   If `auth()` is `undefined`, it's normalized to `null` when evaluating access policies.\n*   If `auth()` itself is `null`, any member access (or chained member access) is `null`.\n*   `expression == null` evaluates to `true` if `expression` is `null`.\n*   Otherwise, a boolean expression evaluates to `false` if a `null` value is involved.\n\nHere are a few examples (assuming `auth()` is `null`):\n\n1.  `auth() == null` -> `true`\n2.  `auth() != null` -> `false`\n3.  `auth().name == null` -> `true`\n4.  `auth().age > 0` -> `false`\n5.  `auth().age < 0` -> `false`\n\n### The `future()` function[‚Äã](https://zenstack.dev/docs/the-complete-guide/part1/under-the-hood#the-future-function \"Direct link to the-future-function\")\n\nAn \"update\" policy rule is treated as a \"post-update\" rule if it involves a `future()` function call. `future()` represents the value of the model entity after the update is completed. In a \"post-update\" policy rule, any member accesses that are not prefixed with `future().` is treated as referencing the entity's value before the update. To support the evaluation of such rules, the entity value before the update is captured and passed as the `preValue` field in the context object passed to the checker function.",
  "title": "How Does ZenStack Work Under the Hood? | ZenStack",
  "description": "This document is for advanced users who want to understand how ZenStack works under the hood. It's not required for using ZenStack.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part4/prepare-project",
  "markdown": "# üõ†Ô∏è Creating a Full-Stack Project\n\nTo simplify the process of building our full-stack Todo app, we'll recreate the project from scratch using the [create-t3-app](https://create.t3.gg/) scaffolding tool - saving us a lot of time manually integrating different tools and libraries. We'll reuse the ZModel schema we built in Part I.\n\nZenStack is framework-agnostic\n\nFor ease of demonstration, we'll use the [Next.js](https://nextjs.org/) framework for full-stack development. However, ZenStack is framework-agnostic. Most of the content apply to other choices, including full-stack ones like like [Nuxt](https://nuxt.com/) and [SvelteKit](https://kit.svelte.dev/), or SPA + backend frameworks like [Express](https://expressjs.com/), [Fastify](https://fastify.dev/), [NestJS](https://nestjs.com/).\n\n### 1\\. Creating the Project[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/prepare-project#1-creating-the-project \"Direct link to 1. Creating the Project\")\n\nCreate a new Next.js project using `create-t3-app`:\n\n```\nnpx create-t3-app@latest --tailwind --nextAuth --prisma --appRouter --CI my-todo-app\n```\n\nIt sets up a project with the following features:\n\n*   [Next.js](https://nextjs.org/) with app router\n*   TypeScript\n*   Prisma for ORM\n*   [NextAuth.js](https://next-auth.js.org/) for authentication\n*   [Tailwind CSS](https://tailwindcss.com/) for styling\n*   SQLite for database\n\nWe'll also use \"daisyUI\" for UI components. Run the following command to install it:\n\nThen add the \"daisyui\" plugin to `tailwind.config.ts`:\n\n```\nmodule.exports = {  //...  plugins: [require(\"daisyui\")],}\n```\n\nFinally, add some utility packages we'll use later:\n\n### 2\\. Setting Up ZenStack[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/prepare-project#2-setting-up-zenstack \"Direct link to 2. Setting Up ZenStack\")\n\nInitialize the project for ZenStack:\n\nBesides installing dependencies, the command also copies the `prisma/schema.prisma` file to `schema.zmodel`. We're going to continue using the ZModel we've developed in the previous part, but with a few tweaks:\n\n1.  All \"id\" fields are changed to String type (as required by NextAuth).\n2.  The \"markdown\" and \"openapi\" plugins are removed (not needed for this part).\n\nYou can also find the updated version here: [https://github.com/zenstackhq/the-complete-guide-sample/blob/part4-start/schema.zmodel](https://github.com/zenstackhq/the-complete-guide-sample/blob/part4-start/schema.zmodel). Replace the `schema.zmodel` file in your project with it.\n\nRun generation and push the schema to the database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 3\\. Implementing Authentication[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/prepare-project#3-implementing-authentication \"Direct link to 3. Implementing Authentication\")\n\n#### 3.1 NextAuth Session Provider[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/prepare-project#31-nextauth-session-provider \"Direct link to 3.1 NextAuth Session Provider\")\n\nTo use NextAuth, we'll need to install a session provider at the root of our app. First, create a file `src/components/SessionProvider.tsx` with the following content:\n\nsrc/components/SessionProvider.tsx\n\n```\n'use client';import { SessionProvider } from 'next-auth/react';import React from 'react';type Props = {  children: React.ReactNode;};function NextAuthSessionProvider({ children }: Props) {  return <SessionProvider>{children}</SessionProvider>;}export default NextAuthSessionProvider;\n```\n\nThen, update the `src/app/layout.tsx` file to use it\n\nsrc/app/layout.tsx\n\n```\nimport NextAuthSessionProvider from '~/components/SessionProvider';export default function RootLayout({ children }: { children: React.ReactNode }) {  return (    <html lang=\"en\">      <body className={`font-sans ${inter.variable}`}>        <NextAuthSessionProvider>{children}</NextAuthSessionProvider>      </body>    </html>  );}\n```\n\n#### 3.2 Credential-Based Auth[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/prepare-project#32-credential-based-auth \"Direct link to 3.2 Credential-Based Auth\")\n\nThe default project created by `create-t3-app` uses Discord OAuth for authentication. We'll replace it with credential-based authentication for simplicity.\n\nReplace the content of `/src/server/auth.ts` with the following:\n\n/src/server/auth.ts\n\n```\nimport { PrismaAdapter } from '@next-auth/prisma-adapter';import type { PrismaClient } from '@prisma/client';import { compare } from 'bcryptjs';import NextAuth, { type DefaultSession, type NextAuthOptions } from 'next-auth';import CredentialsProvider from 'next-auth/providers/credentials';import { db } from './db';declare module 'next-auth' {  interface Session extends DefaultSession {    user: {      id: string;    } & DefaultSession['user'];  }}export const authOptions: NextAuthOptions = {  session: {    strategy: 'jwt',  },  // Include user.id on session  callbacks: {    session({ session, token }) {      if (session.user) {        session.user.id = token.sub!;      }      return session;    },  },  // Configure one or more authentication providers  adapter: PrismaAdapter(db),  providers: [    CredentialsProvider({      credentials: {        email: { type: 'email' },        password: { type: 'password' },      },      authorize: authorize(db),    }),  ],};function authorize(prisma: PrismaClient) {  return async (credentials: Record<'email' | 'password', string> | undefined) => {    if (!credentials?.email) throw new Error('\"email\" is required in credentials');    if (!credentials?.password) throw new Error('\"password\" is required in credentials');    const maybeUser = await prisma.user.findFirst({      where: { email: credentials.email },      select: { id: true, email: true, password: true },    });    if (!maybeUser?.password) return null;    // verify the input password with stored hash    const isValid = await compare(credentials.password, maybeUser.password);    if (!isValid) return null;    return { id: maybeUser.id, email: maybeUser.email };  };}export default NextAuth(authOptions);\n```\n\nRemove code related to `DISCORD_CLIENT_ID` and `DISCORD_CLIENT_SECRET` from `/src/env.js`, and update the `.env` file under project root to the following:\n\n.env\n\n```\nDATABASE_URL=\"file:./db.sqlite\"NEXTAUTH_SECRET=\"abc123\"NEXTAUTH_URL=\"http://localhost:3000\"\n```\n\ninfo\n\nYou should use a strong `NEXTAUTH_SECRET` in a real application.\n\n### 4\\. Mounting the CRUD API[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/prepare-project#4-mounting-the-crud-api \"Direct link to 4. Mounting the CRUD API\")\n\nZenStack uses server adapters to mount CRUD APIs to frameworks, and it has several pre-built adapters for popular frameworks - one of which is Next.js. First, install the server adapter package:\n\n```\nnpm install @zenstackhq/server\n```\n\nThen, create a file `src/app/api/model/[...path]/route.ts` with the following content:\n\nsrc/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { NextRequestHandler } from '@zenstackhq/server/next';import { getServerSession } from 'next-auth';import { authOptions } from '~/server/auth';import { db } from '~/server/db';async function getPrisma() {  const session = await getServerSession(authOptions);  const user = session ? { id: session.user.id } : undefined;  return enhance(db, { user });}const handler = NextRequestHandler({ getPrisma, useAppDir: true });export { handler as DELETE, handler as GET, handler as PATCH, handler as POST, handler as PUT };\n```\n\ninfo\n\nThe crucial part is that we use an enhanced PrismaClient with the server adapter, so all API calls are automatically subject to the access policies defined in the ZModel schema.\n\nIn the next chapter, we'll learn how to use a plugin to generate frontend data query hooks that help us consume it.\n\n### 5\\. Compile the Project[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/prepare-project#5-compile-the-project \"Direct link to 5. Compile the Project\")\n\nCompile the project and see if everything is working correctly:",
  "title": "üõ†Ô∏è Creating a Full-Stack Project | ZenStack",
  "description": "To simplify the process of building our full-stack Todo app, we'll recreate the project from scratch using the create-t3-app scaffolding tool - saving us a lot of time manually integrating different tools and libraries. We'll reuse the ZModel schema we built in Part I.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc",
  "markdown": "# RPC API Handler | ZenStack\n\n## Introduction[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#introduction \"Direct link to Introduction\")\n\nThe RPC-style API handler exposes CRUD endpoints that fully mirror [PrismaClient's query API](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#model-queries). Consuming the APIs feels like making RPC calls to a PrismaClient then. The API handler is not meant to be used directly; instead, you should use it together with a [server adapter](https://zenstack.dev/docs/category/server-adapters) which handles the request and response API for a specific framework.\n\nIt can be created and used as the following:\n\n*   Next.js\n*   SvelteKit\n*   Nuxt\n\n/src/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { NextRequestHandler } from '@zenstackhq/server/next';import { RestApiHandler } from '@zenstackhq/server/api';import { getPrisma } from '~/lib/db';const handler = NextRequestHandler({    getPrisma,    useAppDir: true,    handler: RPCApiHandler() // you can also omit it since `RPCApiHandler` is the default});export {  handler as GET,  handler as POST,  handler as PUT,  handler as PATCH,  handler as DELETE,};\n```\n\n## Wire Format[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#wire-format \"Direct link to Wire Format\")\n\n### Input[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#input \"Direct link to Input\")\n\nFor endpoints using `GET` and `DELETE` Http verbs, the query body is serialized and passed as the `q` query parameter. E.g.:\n\n```\nGET /api/post/findMany?q=%7B%22where%22%3A%7B%22public%22%3Atrue%7D%7D\n```\n\n*   Endpoint: /api/post/findMany\n*   Query parameters: `q` -> `{ \"where\" : { \"public\": true } }`\n\nFor endpoints using other HTTP verbs, the query body is passed as `application/json` in the request body. E.g.:\n\n```\nPOST /api/post/create{ \"data\": { \"title\": \"Hello World\" } }\n```\n\n### Output[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#output \"Direct link to Output\")\n\nThe output shape conforms to the data structure returned by the corresponding PrismaClient API, wrapped into a `data` field. E.g.:\n\n```\nGET /api/post/findMany{    \"data\": [ { \"id\": 1, \"title\": \"Hello World\" } ]}\n```\n\n### Serialization[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#serialization \"Direct link to Serialization\")\n\nThis section explains the details about data serialization. If you're using generated hooks to consume the API, the generated code already automatically deals with serialization for you, and you don't need to do any further processing.\n\nZenStack uses [superjson](https://github.com/blitz-js/superjson) to serialize and deserialize data - including the `q` query parameter, the request body, and the response body. Superjson generates two parts during serialization:\n\n*   json:\n    \n    The JSON-compatible serialization result.\n    \n*   meta:\n    \n    The serialization metadata including information like field types that facilitates deserialization.\n    \n\nIf the data only involves simple data types, the serialization result is the same as regular `JSON.stringify`, and no `meta` part is generated. However, for complex data types (like `Bytes`, `Decimal`, etc.), a `meta` object will be generated, which needs to be carried along when sending the request, and will also be included in the response.\n\nThe following part explains how the `meta` information is included for different situations:\n\n*   The `q` query parameter\n    \n    If during superjson-serialization of the `q` parameter, a `meta` object is generated, it should be put into an object `{ serialization: meta }`, JSON-stringified, and included as an additional query parameter `meta`. For example, if you have a field named `bytes` of `Bytes` type, and you may want to query with a filter like `{ where: { bytes: Buffer.from([1,2,3]) } }`. Superjson-serializing the query object results in:\n    \n    ```\n    {    \"json\": { \"where\": { \"bytes\": \"AQID\" } }, // base-64 encoded bytes    \"meta\": { \"values\": { \"where.bytes\": [[\"custom\",\"Bytes\"]] } }}\n    ```\n    \n    Your query URL should look like:\n    \n    ```\n    GET /api/post/findMany?q={\"where\":{\"bytes\":\"AQID\"}}&meta={\"serialization\":{\"values\":{\"where.bytes\":[[\"custom\",\"Bytes\"]]}}}\n    ```\n    \n*   The request body\n    \n    If during superjson-serialization of the request body, a `meta` object is generated, it should be put into an object `{ serialization: meta }`, and included as an additional field `meta` field in the request body. For example, if you have a field named `bytes` of `Bytes` type, and you may want to create a record with a value like `{ data: { bytes: Buffer.from([1,2,3]) } }`. Superjson-serializing the request body results in:\n    \n    ```\n    {    \"json\": { \"bytes\": \"AQID\" }, // base-64 encoded bytes    \"meta\": { \"values\": { \"bytes\": [[ \"custom\", \"Bytes\" ]] } }}\n    ```\n    \n    Your request body should look like:\n    \n    ```\n    POST /api/post/create{     \"data\": { \"bytes\": \"AQID\" },    \"meta\": { \"serialization\": {\"values\": { \"bytes\": [[ \"custom\",\"Bytes\" ]] } } } }\n    ```\n    \n*   The response body\n    \n    If during superjson-serialization of the response body, a `meta` object is generated, it will be put into an object `{ serialization: meta }`, and included as an additional field `meta` field in the response body. For example, if you have a field named `bytes` of `Bytes` type, and a `findFirst` query returns `{ id: 1, bytes: Buffer.from([1,2,3]) }`. Superjson-serializing the request body results in:\n    \n    ```\n    {    \"json\": { \"id\": 1, \"bytes\":\"AQID\" }, // base-64 encoded bytes    \"meta\": { \"values\": { \"bytes\": [[ \"custom\", \"Bytes\" ]] } }}\n    ```\n    \n    Your response body will look like:\n    \n    ```\n    GET /api/post/findFirst{     \"data\": { \"id\": 1, \"bytes\": \"AQID\" },    \"meta\": { \"serialization\": {\"values\": { \"bytes\": [[ \"custom\",\"Bytes\"]] } } } }\n    ```\n    \n    You should use the meta.serialization field value to superjson-deserialize the response body.\n    \n\n#### Data Type Serialization Format[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#data-type-serialization-format \"Direct link to Data Type Serialization Format\")\n\n*   `DateTime`\n    \n    ISO 8601 string\n    \n*   `Bytes`\n    \n    Base64-encoded string\n    \n*   `BigInt`\n    \n    String representation\n    \n*   `Decimal`\n    \n    String representation\n    \n\n## Endpoints[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#endpoints \"Direct link to Endpoints\")\n\n*   **\\[model\\]/findMany**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/findUnique**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/findFirst**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/count**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/aggregate**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/groupBy**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/create**\n    \n    _Http method:_ `POST`\n    \n*   **\\[model\\]/createMany**\n    \n    _Http method:_ `POST`\n    \n*   **\\[model\\]/update**\n    \n    _Http method:_ `PATCH` or `PUT`\n    \n*   **\\[model\\]/updateMany**\n    \n    _Http method:_ `PATCH` or `PUT`\n    \n*   **\\[model\\]/upsert**\n    \n    _Http method:_ `POST`\n    \n*   **\\[model\\]/delete**\n    \n    _Http method:_ `DELETE`\n    \n*   **\\[model\\]/deleteMany**\n    \n    _Http method:_ `DELETE`\n    \n*   **\\[model\\]/check**\n    \n    _Http method:_ `GET`\n    \n\n## HTTP Status Code and Error Responses[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#http-status-code-and-error-responses \"Direct link to HTTP Status Code and Error Responses\")\n\n### Status code[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#status-code \"Direct link to Status code\")\n\nThe HTTP status code used by the endpoints follows the following rules:\n\n*   `create` and `createMany` use `201` for success. Other endpoints use `200`.\n*   `403` is used for to indicate the request is denied due to lack of permissions, usually caused by access policy violation.\n*   `400` is used for invalid requests, e.g., malformed request body.\n*   `422` is used for data validation errors.\n*   `500` is used for other unexpected errors.\n\n### Error response format[‚Äã](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#error-response-format \"Direct link to Error response format\")\n\n```\n{    // true to indicate the failure is due to a Prisma error    prisma?: boolean;    // true to indicate the failure is due to access policy violation    rejectedByPolicy?: boolean;    // original Prisma error code, available when `prisma` is true    code?: string;    // error message    message: string;    // extra reason about why a failure happened (e.g., 'RESULT_NOT_READABLE' indicates    // a mutation succeeded but the result cannot be read back due to access policy)    reason?: string;}\n```",
  "title": "RPC API Handler | ZenStack",
  "description": "RPC-style API handler that fully mirrors PrismaClient's query API",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part4/generate-hooks",
  "markdown": "# üõ†Ô∏è Generating Hooks | ZenStack\n\nIf you use a frontend framework like React or Vue, you've probably used or heard of libraries like [TanStack Query](https://tanstack.com/query/latest) and [SWR](https://swr.vercel.app/). These libraries make it a breeze to build data-driven UI by providing excellent encapsulation for reactive data query, cache management, and data invalidation (aka refetching).\n\nZenStack provides plugins for generating frontend hooks targeting these two libraries. In this guide, we'll focus on using TanStack Query, but the concepts and usage are similar for SWR.\n\n### Installing Dependencies[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/generate-hooks#installing-dependencies \"Direct link to Installing Dependencies\")\n\n```\nnpm install @tanstack/react-query @zenstackhq/tanstack-query\n```\n\nThe `@zenstackhq/tanstack-query` package contains both the plugin and a runtime part, so it needs to be installed as a regular dependency.\n\n### Setting Up TanStack Query[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/generate-hooks#setting-up-tanstack-query \"Direct link to Setting Up TanStack Query\")\n\nTo use TanStack Query, we need to set up a `QueryClientProvider` context provider in the root component of our app. First, create a file `src/components/QueryClientProvider.tsx` with the following content:\n\nsrc/components/QueryClientProvider.tsx\n\n```\n'use client';import { QueryClient, QueryClientProvider } from '@tanstack/react-query';type Props = {  children: React.ReactNode;};const queryClient = new QueryClient();function Provider({ children }: Props) {  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;}export default Provider;\n```\n\nThen, update the `src/app/layout.tsx` file to use it:\n\nsrc/app/layout.tsx\n\n```\nimport QueryClientProvider from '~/components/QueryClientProvider';export default function RootLayout({ children }: { children: React.ReactNode }) {  return (    <html lang=\"en\">      <body className={`font-sans ${inter.variable}`}>        <QueryClientProvider>          <NextAuthSessionProvider>{children}</NextAuthSessionProvider>        </QueryClientProvider>      </body>    </html>  );}\n```\n\n### Adding TanStack Query Plugin[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/generate-hooks#adding-tanstack-query-plugin \"Direct link to Adding TanStack Query Plugin\")\n\nNow add the plugin to the ZModel schema:\n\nschema.zmodel\n\n```\nplugin hooks {  provider = '@zenstackhq/tanstack-query'  target = 'react'  output = 'src/lib/hooks'}\n```\n\nTanStack Query is a multi-framework library and supports React, Vue, and Svelte. The \"target\" field specifies the frontend framework to generate hooks for.\n\nThen, rerun generation and observe that the hooks code is generated in the `src/lib/hooks` directory.\n\n### A Peek Into the Hooks[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/generate-hooks#a-peek-into-the-hooks \"Direct link to A Peek Into the Hooks\")\n\nThe generated hooks allow you to query and mutate data without worrying about the API details. They're designed to fully preserve the Prisma query syntax you already know. Here are some quick examples of their usage:\n\n*   Nested read with filtering and sorting\n    \n    ```\n    // `data` is typed as `(Todo & { list: List })[]`const { data } = useFindManyTodo({  where: { owner: { id: 1 } },  include: { list: true },  orderBy: { createdAt: 'desc' }});\n    ```\n    \n*   Nested create\n    \n    ```\n    const { mutate } = useCreateList();function onCreateList() {  mutate({    data: {       title: 'My List',      todos: {        create: [          { name: 'Todo 1' },          { name: 'Todo 2' }        ]      }    }  })}\n    ```\n    \n*   Count\n    \n    ```\n    const { data } = useCountTodo({ where: { owner: { id: 1 } } });\n    ```\n    \n\nWe'll cover the usage of the hooks in detail in the upcoming chapters.",
  "title": "üõ†Ô∏è Generating Hooks | ZenStack",
  "description": "If you use a frontend framework like React or Vue, you've probably used or heard of libraries like TanStack Query and SWR. These libraries make it a breeze to build data-driven UI by providing excellent encapsulation for reactive data query, cache management, and data invalidation (aka refetching).",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part4/auth-ui",
  "markdown": "# üõ†Ô∏è Building Authentication UI | ZenStack\n\n```\n'use client';import { signIn } from 'next-auth/react';import Link from 'next/link';import { useState, type FormEvent } from 'react';import { useCreateUser } from '~/lib/hooks';export default function Signup() {  const [email, setEmail] = useState('');  const [password, setPassword] = useState('');  const { mutate: signup, error: signupError } = useCreateUser({    onSuccess: async () => {      // sign-up succeeded, sign in with the credentials      const signInResult = await signIn('credentials', {        redirect: false,        email,        password,      });      if (signInResult?.ok) {        window.location.href = '/';      } else {        console.error('Signin failed:', signInResult?.error);      }    },  });  const _err = signupError as { info?: { code?: string } };  const errMsg = _err    ? _err.info?.code === 'P2002' // P2002 is the Prisma error code for unique constraint failure      ? 'Email already exists'      : `Unexpected error occurred: ${JSON.stringify(_err)}`    : '';  function onSignup(e: FormEvent<HTMLFormElement>) {    e.preventDefault();    signup({ data: { email, password } });  }  return (    <div className=\"mx-auto flex h-screen flex-col items-center justify-center\">      <div className=\"mb-10 flex items-center space-x-4\">        <h1 className=\"text-4xl\">Welcome to Todo</h1>      </div>      <div className=\"flex w-full max-w-screen-sm items-center justify-center rounded-lg\">        <div className=\"w-full space-y-8 p-16\">          <h2 className=\"text-3xl font-bold\">Create a Free Account</h2>          <form className=\"mt-8 space-y-6\" action=\"#\" onSubmit={onSignup}>            <div>              <label htmlFor=\"email\" className=\"label\">                Your email              </label>              <input                type=\"email\"                value={email}                onChange={(e) => setEmail(e.target.value)}                className=\"input input-bordered w-full\"                placeholder=\"Email address\"                required              />            </div>            <div>              <label htmlFor=\"password\" className=\"label\">                Your password              </label>              <input                type=\"password\"                value={password}                onChange={(e) => setPassword(e.target.value)}                placeholder=\"‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\"                className=\"input input-bordered w-full\"                required              />            </div>            {errMsg && <p className=\"text-sm text-red-600\">{errMsg}</p>}            <button className=\"btn btn-primary mt-4\" type=\"submit\">              Create account            </button>            <div>              Already have an account?{' '}              <Link href=\"/signin\" className=\"text-primary\">                Login here              </Link>            </div>          </form>        </div>      </div>    </div>  );}\n```",
  "title": "üõ†Ô∏è Building Authentication UI | ZenStack",
  "description": "The TanStack Query hooks generated in the previous chapter provide all the data-access building blocks for implementing the UI. Let's first use it to implement the authentication UI.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins",
  "markdown": "# Writing Plugins | ZenStack\n\nThe ZModel schema is the single source of truth for your data and access control. It can be used to generate many other valuable things based on your specific needs. In this part of the guide, we'll learn the fundamentals of how to write plugins and create a simple one that generates a markdown documentation from the ZModel schema.\n\n### Structure of a Plugin[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#structure-of-a-plugin \"Direct link to Structure of a Plugin\")\n\nA plugin is a Node.js module that has the following exports:\n\n1.  \\[Required\\] A named export `name` that specifies the name of the plugin used for logging and error reporting.\n2.  \\[Optional\\] A named export `description` that contains a short human-readable description of the plugin.\n3.  \\[Required\\] A default function export containing the plugin logic.\n\nHere's what a bare minimum plugin looks like:\n\n```\nimport type { DMMF, PluginOptions } from '@zenstackhq/sdk';import type { Model } from '@zenstackhq/sdk/ast';export const name = 'My Plugin';export default async function run(model: Model, options: PluginOptions, dmmf: DMMF.Document) {    ...}\n```\n\nWhen `zenstack generate` runs, it identifies all the plugins declared in the ZModel, loads their Javascript modules, and calls the default export functions. The following sections explain the arguments passed to the plugin function.\n\n#### ZModel AST[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#zmodel-ast \"Direct link to ZModel AST\")\n\nThe first input of the plugin function is the ZModel AST. It is the result object model of parsing and linking the ZModel schema - a tree structure containing all the information in the schema. Most plugins traverse the AST, extract information of interest, and transform it into another form.\n\nThe following diagram shows the (abbreviated) AST of a simple ZModel schema:\n\n```\ndatasource db {    provider = 'sqlite'    url = 'file:.dev.db'}model User {    id Int @id @default(autoincrement())    posts Post[]}model Post {    id Int @id @default(autoincrement())    title String    author User @relation(fields: [authorId], references: [id])    authorId Int    @@allow('all', auth() == author)}\n```\n\nThe best way to understand the AST structure is to inspect the [ZModel language definition](https://github.com/zenstackhq/zenstack/blob/main/packages/language/src/zmodel.langium).\n\n#### Plugin Options[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#plugin-options \"Direct link to Plugin Options\")\n\nThe second input of the plugin function is the options - an object containing the config fields that the plugin user specified in the ZModel. As a plugin developer, you should define and document what config options your plugin supports.\n\n#### Prisma DMMF[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#prisma-dmmf \"Direct link to Prisma DMMF\")\n\nThe third input of the plugin function is the Prisma DMMF (Data Model Meta Format). DMMF is essentially Prisma Schema's AST enriched with other information needed to generate Prisma Client. It is the main API that developers use to write custom Prisma generators. However, the API is undocumented and considered internal.\n\nFor ZenStack plugins, the DMMF is provided as an auxiliary input. If you only need information from the ZModel schema, the ZModel AST is all you need. However, if you need to access types generated for the Prisma Client (e.g., the parameter shapes of `prisma.user.findMany()`), DMMF is the only way to get them. The best way to learn how to use DMMF is to study the source code of [Prisma's community generators](https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators).\n\n### Adding Custom Attributes[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#adding-custom-attributes \"Direct link to Adding Custom Attributes\")\n\nA plugin can contribute custom attributes and functions to the ZModel language. To do that, simply include a `plugin.zmodel` file in the same directory as the plugin's entry point, and declare the attributes and functions there. Check [here](https://github.com/zenstackhq/zenstack/blob/main/packages/plugins/openapi/src/plugin.zmodel) for an example. As a convention for conflict avoidance, please qualify the declaration names with your plugin name. E.g.:\n\n```\nattribute @@myplugin.include()\n```\n\nAnd you can use it in the ZModel when the plugin is enabled:\n\n```\nmodel Foo {    ...    @@myplugin.include()}\n```\n\n### Publishing a Plugin[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#publishing-a-plugin \"Direct link to Publishing a Plugin\")\n\nIf your plugin is specific to your project, you can implement it inside the project and load it with a relative path in the ZModel. No publishing is needed. We'll see how to do that in the next section.\n\nIf you're building something reusable, please publish it as an NPM package and [tweet us](https://twitter.com/intent/tweet?text=I%27ve%20published%20a%20%40zenstackhq%20plugin%3A&url=) or reach us on [Discord](https://discord.gg/Ykhr738dUe). We'll be happy to share your work with the community.\n\n### üõ†Ô∏è Building a Markdown Generator Plugin[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#%EF%B8%8F-building-a-markdown-generator-plugin \"Direct link to üõ†Ô∏è Building a Markdown Generator Plugin\")\n\nLet's build a simple plugin that generates a markdown documentation from the ZModel schema. The generated documentation will look like this:\n\n```\n# My Awesome Todo AppA multi-tenant Todo app built with ZenStack.- [Space](#space)- [User](#user)- ...## Space- CREATE  - ‚ùå auth() == null  - ‚úÖ true- READ  - ‚ùå auth() == null  - ‚úÖ members?[user == auth()]- UPDATE  - ‚ùå auth() == null  - ‚úÖ members?[user == auth() && role == ADMIN]- DELETE  - ‚ùå auth() == null  - ‚úÖ members?[user == auth() && role == ADMIN]## User...\n```\n\n#### 1\\. Creating the plugin[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#1-creating-the-plugin \"Direct link to 1. Creating the plugin\")\n\nIn our sample project, create a `markdown-plugin.ts` file at the root:\n\nmarkdown-plugin.ts\n\n```\nimport { type PluginOptions } from '@zenstackhq/sdk';import {    isDataModel,    type DataModel,    type Model,} from '@zenstackhq/sdk/ast';import fs from 'fs';export const name = 'Markdown';export default async function run(model: Model, options: PluginOptions) {    // process options    const title = options.title ?? 'My Application Model';    const description = options.description ?? 'Description of my application';    // get all data models    const dataModels = model.declarations.filter((x): x is DataModel =>        isDataModel(x)    );    // TOC    const toc = dataModels.map((x) => `- [${x.name}](#${x.name})`).join('\\n');    // data model docs    const dataModelDocs = generateDataModelDocs(dataModels);    fs.writeFileSync(        'schema.md',        `# ${title}    ${description}    ${toc}    ${dataModelDocs}    `    );}\n```\n\nThe code sets up the high-level structure of the markdown document. Let's now add the `generateDataModelDocs` function implementation in the same file.\n\nmarkdown-plugin.ts\n\n```\nimport { ZModelCodeGenerator, getLiteral } from '@zenstackhq/sdk';import { type DataModelAttribute } from '@zenstackhq/sdk/ast';function generateDataModelDocs(dataModels: DataModel[]) {    // AST -> ZModel source generator    const zmodelCodeGen = new ZModelCodeGenerator();    // all CRUD operations    const CRUD = ['create', 'read', 'update', 'delete'];    const docs = dataModels.map((dataModel) => {        // first, group model attributes by CRUD operations        const groupByCrud = dataModel.attributes            .filter((attr) =>                ['@@allow', '@@deny'].includes(attr.decl.ref?.name || '')            )            .reduce<Record<string, DataModelAttribute[]>>((group, attr) => {                const ops = getLiteral<string>(attr.args[0].value);                if (ops) {                    const splitOps =                        ops == 'all'                            ? CRUD                            : ops.split(',').map((op) => op.trim());                    splitOps.forEach((op) => {                        group[op] = group[op] || [];                        group[op].push(attr);                    });                }                return group;            }, {});        // then generate rules for each operation        const policies = CRUD.map((op) => {            const rules = groupByCrud[op]                ? groupByCrud[op]                      // output `@@deny` before `@@allow`                      .sort((a) => {                          return a.decl.ref?.name == '@@deny' ? -1 : 1;                      })                      .map(                          (attr) =>                              `  - ${                                  attr.decl.ref?.name == '@@deny'                                      ? '‚ùå '                                      : '‚úÖ '                              }${zmodelCodeGen.generate(attr.args[1].value)}`                      )                      .join('\\n')                : [];            return [`- ${op.toUpperCase()}`, rules].join('\\n');        }).join('\\n');        return `## ${dataModel.name}\\n\\n${policies}`;    });    return docs.join('\\n\\n');}\n```\n\nFinally, compile the plugin code:\n\nThe JavaScript output should have been generated into the `dist` folder.\n\n#### 2\\. Testing the plugin[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#2-testing-the-plugin \"Direct link to 2. Testing the plugin\")\n\nWe can now add the plugin to our ZModel:\n\n```\nplugin markdown {    provider = './dist/markdown-plugin'    title = 'My Awesome Todo App'    description = 'A multi-tenant Todo application built with ZenStack.'}\n```\n\nPlugin module resolution\n\nWhen you use a relative path (starting with \".\") in the \"provider\" field, ZenStack resolves the path relative to the ZModel file and loads the plugin module from it with `require()`. If the plugin is a published NPM package, use the package name directly in the \"provider\" field.\n\nNow run the CLI to regenerate:\n\nYou should see the following output and the `schema.md` file generated in the current directory:\n\n```\n‚åõÔ∏è ZenStack CLI vx.y.z, running plugins‚úî Generating Prisma schema‚úî Generating PrismaClient enhancer‚úî Generating Zod schemas‚úî Running plugin markdownüëª All plugins completed successfully!Don't forget to restart your dev server to let the changes take effect.\n```\n\n#### 3\\. Full source code[‚Äã](https://zenstack.dev/docs/the-complete-guide/part2/writing-plugins#3-full-source-code \"Direct link to 3. Full source code\")\n\nThe sample plugin we implemented here is a simplified version of the [zenstack-markdown](https://github.com/jiashengguo/zenstack-markdown) plugin created by [@jiashengguo](https://github.com/jiashengguo). Besides outputting access policies, it also generates mini entity-relation diagrams in [mermaid](https://mermaid-js.github.io/) format.",
  "title": "Writing Plugins | ZenStack",
  "description": "The ZModel schema is the single source of truth for your data and access control. It can be used to generate many other valuable things based on your specific needs. In this part of the guide, we'll learn the fundamentals of how to write plugins and create a simple one that generates a markdown documentation from the ZModel schema.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part4/invalidation",
  "markdown": "# Automatic Invalidation | ZenStack\n\nData query libraries like TanStack Query and SWR are essentially cache managers. They cache the data fetched from the server, let you bind it to the UI, and allow you to invalidate the query cache when the data is updated.\n\nIn application development, query invalidation is the developers' job. After making a mutation, a developer should know what queries are impacted, compute their keys, and trigger invalidation. For example, after creating a `Todo`, you'll need to remember to invalidate the queries that directly or indirectly fetch a list of Todos. This can be hard to manage when your app gets more complex.\n\nFortunately, ZenStack can fully automate it for you by exploiting an important fact:\n\n> It knows what mutations impact what kind of queries for the hooks it generates.\n\nFor example, when you use `useCreateTodo()` to create a `Todo`, ZenStack can go through the query cache, identify all queries potentially impacted by the mutation, and invalidate them. For example, a query made with:\n\n```\nuseFindManyList({ include: { todos: true } });\n```\n\nwill be invalidated because it fetches a list of Todos with nested reading.\n\nHow ZenStack uses query keys\n\nZenStack uses a quintuple to form a query key:\n\n```\n['zenstack', model, operation, args, flags]\n```\n\n*   `'zenstack'`: a string literal prefix\n*   `model`: the model name, e.g., \"Todo\"\n*   `operation`: the Prisma operation name, e.g., \"findMany\"\n*   `args`: the arguments passed to the operation, e.g., `{ include: { todos: true } }`\n*   `flags`: a set of flags that further defines the query, e.g., if it's an infinite query, etc\n\nYou usually don't need to use query keys directly, but the generated hooks provide a `getQueryKey` helper function to help you compute them.\n\nIn this chapter, we'll add a `Space` and a `List` management UI to our Todo app and see how the automatic invalidation works in action.\n\n### üõ†Ô∏è Adding Space Management[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/invalidation#%EF%B8%8F-adding-space-management \"Direct link to üõ†Ô∏è Adding Space Management\")\n\nWe'll use the homepage to manage spaces. Replace the content of `src/app/page.tsx` with the following:\n\nsrc/app/page.tsx\n\n```\n'use client';import { nanoid } from 'nanoid';import type { NextPage } from 'next';import { signOut, useSession } from 'next-auth/react';import Link from 'next/link';import { useCreateSpace, useFindManySpace } from '~/lib/hooks';const Home: NextPage = () => {  const { data: session } = useSession();  const { mutate: createSpace } = useCreateSpace();  const { data: spaces } = useFindManySpace({ orderBy: { createdAt: 'desc' } });  function onCreateSpace() {    const name = prompt('Enter a name for your space');    if (name) {      createSpace({        data: {          name,          slug: nanoid(6),          owner: { connect: { id: session?.user.id } },          // add the creating user as an admin member          members: {            create: {              user: { connect: { id: session?.user.id } },              role: 'ADMIN',            },          },        },      });    }  }  return (    <div className=\"container mx-auto flex justify-center\">      {session?.user ? (        <div className=\"mt-8 flex w-full flex-col items-center\">          <h1 className=\"text-center text-2xl\">            Welcome {session.user.email}{' '}            <button                className=\"btn btn-ghost btn-xs mt-4\"                onClick={() => signOut({ callbackUrl: '/signin' })}            >              Logout            </button>          </h1>          <div className=\"w-full p-8\">            <h2 className=\"mb-8 text-xl\">              Choose a space to start, or{' '}              <button className=\"btn btn-link p-0 text-xl\" onClick={onCreateSpace}>                create a new one.              </button>            </h2>            <ul className=\"flex gap-4\">              {spaces?.map((space) => (                <Link href={`/spaces/${space.slug}`} key={space.id}>                  <li className=\"flex h-32 w-72 items-center justify-center rounded-lg border text-2xl\">                    {space.name}                  </li>                </Link>              ))}            </ul>          </div>        </div>      ) : (        <div>          Please{' '}          <Link href=\"/signin\">            <button className=\"btn btn-link p-0\">login</button>          </Link>{' '}          to get started        </div>      )}    </div>  );};export default Home;\n```\n\nThe key part is the usage of the `useFindManySpace` query hook and the `useCreateSpace` mutation hook. Some quick notes about the logic:\n\n*   Calling `useFindManySpace` is conceptually equivalent to calling `db.space.findMany()` in the backend. The access policies ensure only the spaces readable to the user are returned.\n    \n*   The `onCreateSpace` function shows the flexibility of the hooks. When creating a space, we make a nested write to create a `SpaceUser` record that adds the user as the admin member of the space. The call is also executed in the backend as a nested write, so the two create operations are atomic.\n    \n\nNow, you can head to the homepage and create a few spaces. The UI should look like this:\n\n![Space management](https://zenstack.dev/assets/images/space-mgmt-8392e76dfb277cae09e35132c0760dd9.png)\n\nYou've probably already noticed this: after creating a space, you don't need to refresh the UI to see the result. ZenStack figures out that the `useCreateSpace` mutation can potentially impact the `useFindManySpace` query and automatically invalidates it.\n\nOpt-out of automatic invalidation\n\nWhen calling a mutation hook, you can pass an `invalidateQueries` option as `false` to opt out of automatic invalidation. For example:\n\n```\nconst { mutate: createSpace } = useCreateSpace({ invalidateQueries: false });\n```\n\nWith this change, the created space won't appear in the list until you refresh the page.\n\n### üõ†Ô∏è Adding List Management[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/invalidation#%EF%B8%8F-adding-list-management \"Direct link to üõ†Ô∏è Adding List Management\")\n\nList management is essentially the same as space, so we'll skip the code walkthrough. Here's the content of `src/app/spaces/[slug]/page.tsx`:\n\nsrc/app/spaces/\\[slug\\]/page.tsx\n\n```\n'use client';import { useSession } from 'next-auth/react';import Link from 'next/link';import { useParams } from 'next/navigation';import { useCreateList, useFindManyList, useFindUniqueSpace } from '~/lib/hooks';export default function SpaceHome() {  const { slug } = useParams<{ slug: string }>();  const { data: session } = useSession();  const { data: space } = useFindUniqueSpace({ where: { slug } }, { enabled:!!session?.user });  const { data: lists } = useFindManyList(    {      where: { space: { slug } },      include: { owner: true },      orderBy: { updatedAt: 'desc' },    },    { enabled: !!session?.user },  );  const { mutate: createList } = useCreateList();  function onCreateList() {    const title = prompt('Enter a title for your list');    if (title) {      createList({        data: {          title,          space: { connect: { id: space?.id } },        },      });    }  }  if (!session?.user || !space || !lists) return null;  return (    <div className=\"container mx-auto mt-16\">      <h1 className=\"text-center text-3xl\">        Welcome to Space <span className=\"italic\">{space.name}</span>      </h1>      <div className=\"p-8\">        <button className=\"btn btn-primary btn-wide\" onClick={onCreateList}>          Create a list        </button>        <ul className=\"mt-8 flex flex-wrap gap-6\">          {lists?.map((list) => (            <Link href={`/spaces/${slug}/${list.id}`} key={list.id}>              <li className=\"flex h-32 w-72 items-center justify-center rounded-lg border text-2xl\">                {list.title}              </li>            </Link>          ))}        </ul>      </div>    </div>  );}\n```\n\nThe result should look like this:\n\n![List management](https://zenstack.dev/assets/images/list-mgmt-85e7f4b0f3f41b3751d283e2cbf83f6e.png)",
  "title": "Automatic Invalidation | ZenStack",
  "description": "Data query libraries like TanStack Query and SWR are essentially cache managers. They cache the data fetched from the server, let you bind it to the UI, and allow you to invalidate the query cache when the data is updated.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part4/optimistic-update",
  "markdown": "# Optimistic Update | ZenStack\n\nOptimistic update is a technique that allows us to update the UI immediately after a user action without waiting for the server response. It's a great way to improve the perceived performance of an application and is especially useful for the parts where users interact with the UI frequently.\n\nLibraries like TanStack Query and SWR provides the framework for developers to implement optimistic update. The approach is essentially to update the query cache immediately after the user action and revert or invalidate the cache after the server response comes back (either success or error). However, similar to the query invalidation problem we discussed in the previous chapter, the challenge is identifying which queries need to be updated and how.\n\nZenStack supports automatic optimistic update for the hooks it generates. It uses a set of rules to update queries and aims to cover the most common use cases. You can find more on how it works [here](https://zenstack.dev/docs/reference/plugins/tanstack-query#details-of-the-optimistic-behavior).\n\nAutomatic optimistic update is an approximation\n\nIt's often impossible to accurately determine the correct way to update a query cache from the frontend. For example, you may have a query that fetches a filtered list of Todos using the `useFindManyTodo()` hook. When creating a new Todo, we can't precisely determine if the new item should be inserted into the query result (i.e., matching the filter conditions) without querying the database. But paradoxically, the update is no longer optimistic if we query the database.\n\nZenStack takes an \"optimistic\" action here and inserts the new Todo into the query result. It's not always correct, but the worst-case scenario is that the item shows up on the list for a short while until the query is invalidated upon getting the server response.\n\n### üõ†Ô∏è Adding Todo Management[‚Äã](https://zenstack.dev/docs/the-complete-guide/part4/optimistic-update#%EF%B8%8F-adding-todo-management \"Direct link to üõ†Ô∏è Adding Todo Management\")\n\nThe main missing part of our sample app is managing Todos in a List. This is a great place to implement optimistic update because users may add, update, or delete Todos in quick paces, and waiting for the server response to update the UI will result in a very sluggish experience.\n\nLet's first implement the Todo management UI without optimistic update. First, create a component `src/components/TodoComponent.tsx` to manage one single Todo:\n\nsrc/components/TodoComponent.tsx\n\n```\nimport type { Todo } from \"@prisma/client\";import { useDeleteTodo, useUpdateTodo } from \"~/lib/hooks\";type Props = {  value: Todo;  optimistic?: boolean;};export default function TodoComponent({ value, optimistic }: Props) {  const update = useUpdateTodo();  const del = useDeleteTodo();  function onDelete() {    del.mutate({ where: { id: value.id } });  }  function onToggleCompleted(completed: boolean) {    if (completed === !!value.completedAt) {      return;    }    update.mutate({      where: { id: value.id },      data: { completedAt: completed ? new Date() : null },    });  }  return (    <div className=\"flex w-96 flex-col items-center rounded-lg border px-8 py-4\">      <div className=\"flex w-full justify-between\">        <h3          className={`flex items-center text-xl                        ${                          value.completedAt                            ? \"italic text-gray-400 line-through\"                            : \"text-gray-700\"                        }                    }`}        >          {value.title}          {optimistic && (            <span className=\"loading loading-spinner loading-sm ml-1\"></span>          )}        </h3>        <div className=\"flex\">          <input            type=\"checkbox\"            className=\"checkbox mr-2\"            checked={!!value.completedAt}            onChange={(e) => onToggleCompleted(e.currentTarget.checked)}          />          <button className=\"btn btn-ghost btn-xs\" onClick={onDelete}>            Delete          </button>        </div>      </div>    </div>  );}\n```\n\nThen, create a page at `src/app/spaces/[slug]/[listId]/page.tsx` to manage Todos in a List:\n\nsrc/app/spaces/\\[slug\\]/\\[listId\\]/page.tsx\n\n```\n\"use client\";import { useSession } from \"next-auth/react\";import { useParams } from \"next/navigation\";import { useState } from \"react\";import TodoComponent from \"~/components/TodoComponent\";import { useCreateTodo, useFindManyTodo, useFindUniqueList } from \"~/lib/hooks\";export default function TodoList() {  const { listId } = useParams<{ listId: string }>();  const { data: session } = useSession();  const { data: list } = useFindUniqueList(    {      where: { id: listId },    },    { enabled: !!session?.user },  );  const { mutate: create } = useCreateTodo();  const { data: todos } = useFindManyTodo(    {      where: { listId },      orderBy: { createdAt: \"desc\" as const },    },    { enabled: !!session?.user },  );  const [title, setTitle] = useState(\"\");  function onCreate() {    create({      data: {        title,        owner: { connect: { id: session?.user.id } },        list: { connect: { id: listId } },      },    });    setTitle(\"\");  }  if (!session?.user || !list) {    return <></>;  }  return (    <div>      <div className=\"container mx-auto flex w-full flex-col items-center py-12\">        <h1 className=\"mb-4 text-2xl font-semibold\">{list.title}</h1>        <div className=\"flex space-x-2\">          <input            type=\"text\"            placeholder=\"Type a title and press enter\"            className=\"input input-bordered mt-2 w-72 max-w-xs\"            value={title}            autoFocus            onKeyUp={(e) => {              if (e.key === \"Enter\") {                onCreate();              }            }}            onChange={(e) => {              setTitle(e.currentTarget.value);            }}          />        </div>        <ul className=\"flex w-auto flex-col space-y-4 py-8\">          {todos?.map((todo) => (            <TodoComponent              key={todo.id}              value={todo}              optimistic={todo.$optimistic}            />          ))}        </ul>      </div>    </div>  );}\n```\n\nTo simulate usage in the real world, I've enabled Chrome's network throttling to \"Fast 3G\" mode. Here's what it looks like:\n\n![Todo management without optimistic update](https://zenstack.dev/assets/images/todo-mgmt-non-optimistic-e9bea05d48adde85d7afa4da60f01bf0.gif)\n\nIt's obviously very sluggish. It's not something a user wants to pay for.\n\nLet's make some small changes to enable automatic optimistic update. In `src/pages/spaces/[slug]/[listId]/index.tsx`, change the `useCreateTodo` call to the following:\n\n```\nconst { mutate: create } = useCreateTodo({ optimisticUpdate: true });\n```\n\nAnd likewise, change the `useUpdateTodo` and `useDeleteTodo` calls in `Todo.tsx` to the following:\n\n```\nconst update = useUpdateTodo({ optimisticUpdate: true });const del = useDeleteTodo({ optimisticUpdate: true });\n```\n\nNow, if we repeat the same test with network throttling, we'll see a much better experience:\n\n![Todo management with optimistic update](https://zenstack.dev/assets/images/todo-mgmt-optimistic-7ab48fdba468dbd916e0b9da99cefe22.gif)\n\nOpt-out of automatic optimistic update\n\nWhen you enable automatic optimistic update for a mutation, it applies to all queries that may be impacted. If this is not desirable, you can pass the `optimisticUpdate` option as `false` to opt out of automatic optimistic update per query. For example:\n\n```\nconst { data: todos } = useFindManyTodo(    { where: { listId } },    { enabled: !!session?.user, optimisticUpdate: false },);\n```\n\nWith this change, the `useCreateTodo` mutation will not optimistically update this query even if the mutation is set to do so.",
  "title": "Optimistic Update | ZenStack",
  "description": "Optimistic update is a technique that allows us to update the UI immediately after a user action without waiting for the server response. It's a great way to improve the perceived performance of an application and is especially useful for the parts where users interact with the UI frequently.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part4/conclusion",
  "markdown": "# Conclusion | ZenStack\n\nVersion: 2.x\n\nIn this part of the guide, we've focused on using plugins to generate frontend data query hooks and use them to build highly responsive data-driven UIs with ease. We've also evolved our sample project into a fully functional application. There are still a few parts unimplemented (like space member management), but since we've covered all essential ZenStack concepts and features with what we've built, we'll skip them in this guide. You can find the completed source code for this part in the \"main\" branch of [https://github.com/zenstackhq/the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample).\n\nThere are also variants of the Todo app built with different stacks in the following repositories. They are feature complete and have better UI styling.\n\n*   [Next.js (pages route) + SWR](https://github.com/zenstackhq/sample-todo-nextjs)\n*   [Next.js (pages route) + TanStack Query](https://github.com/zenstackhq/sample-todo-nextjs-tanstack)\n*   [Nuxt + TanStack Query](https://github.com/zenstackhq/sample-todo-nuxt)\n*   [SvelteKit + TanStack Query](https://github.com/zenstackhq/sample-todo-sveltekit)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Conclusion | ZenStack",
  "description": "In this part of the guide, we've focused on using plugins to generate frontend data query hooks and use them to build highly responsive data-driven UIs with ease. We've also evolved our sample project into a fully functional application. There are still a few parts unimplemented (like space member management), but since we've covered all essential ZenStack concepts and features with what we've built, we'll skip them in this guide. You can find the completed source code for this part in the \"main\" branch of https://github.com/zenstackhq/the-complete-guide-sample.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/authentication/auth0",
  "markdown": "# üöß Integrating With Auth0 | ZenStack\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "üöß Integrating With Auth0 | ZenStack",
  "description": "Integrating with Auth0.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/authentication/lucia",
  "markdown": "# üöß Integrating With Lucia | ZenStack\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "üöß Integrating With Lucia | ZenStack",
  "description": "Integrating with Lucia.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/authentication/next-auth",
  "markdown": "# Integrating With Auth.js (NextAuth) | ZenStack\n\n[NextAuth](https://next-auth.js.org/) is a comprehensive framework for implementing authentication in Next.js projects. It offers a pluggable mechanism for configuring how user data is persisted.\n\nTo get access policies to work, ZenStack needs to be connected to the authentication system to get the user's identity. This guide introduces tasks required for integrating ZenStack with NextAuth. You can find a complete example [here](https://github.com/zenstackhq/sample-todo-nextjs \":target=blank\").\n\n### Data model requirement[‚Äã](https://zenstack.dev/docs/guides/authentication/next-auth#data-model-requirement \"Direct link to Data model requirement\")\n\nNextAuth is agnostic about the underlying database type, but it requires specific table structures, depending on how you configure it. Therefore, your ZModel definitions should reflect these requirements. A sample `User` model is shown here (to be used with `CredentialsProvider`):\n\n/schema.zmodel\n\n```\nmodel User {    id String @id @default(cuid())    email String @unique @email    emailVerified DateTime?    password String @password @omit    name String?    image String? @url    // open to signup    @@allow('create', true)    // full access by oneself    @@allow('all', auth() == this)}\n```\n\nYou can find the detailed database model requirements [here](https://next-auth.js.org/adapters/models \":target=blank\").\n\n### Adapter[‚Äã](https://zenstack.dev/docs/guides/authentication/next-auth#adapter \"Direct link to Adapter\")\n\nAdapter is a NextAuth mechanism for hooking in custom persistence of auth-related entities, like User, Account, etc. Since ZenStack is based on Prisma, you can use PrismaAdapter for the job:\n\n/src/pages/api/auth/\\[...nextauth\\].ts\n\n```\nimport { PrismaAdapter } from \"@next-auth/prisma-adapter\";import NextAuth, { type NextAuthOptions } from 'next-auth';import { prisma } from \"../../../server/db/client\";export const authOptions: NextAuthOptions = {    // install Prisma adapter    adapter: PrismaAdapter(prisma),    ...};export default NextAuth(authOptions);\n```\n\nIf you use [`CredentialsProvider`](https://next-auth.js.org/providers/credentials \":target=blank\"), i.e. email/password based auth, you need to implement an `authorize` function for verifying credentials against the database.\n\nThis is standard Prisma stuff, and the following is just a quick example of how to do it:\n\n/src/pages/api/auth/\\[...nextauth\\].ts\n\n```\nimport { prisma } from \"../../../server/db/client\";export const authOptions: NextAuthOptions = {    ...    providers: [        CredentialsProvider({            credentials: {                email: {                    label: 'Email Address',                    type: 'email',                },                password: {                    label: 'Password',                    type: 'password',                },            },            authorize: authorize(prisma),        }),    ]};function authorize(prisma: PrismaClient) {  return async (credentials: Record<\"email\" | \"password\", string> | undefined) => {    if (!credentials) throw new Error(\"Missing credentials\");    if (!credentials.email) throw new Error('\"email\" is required in credentials');    if (!credentials.password) throw new Error('\"password\" is required in credentials');    const maybeUser = await prisma.user.findFirst({      where: { email: credentials.email },      select: { id: true, email: true, password: true },    });    if (!maybeUser || !maybeUser.password) return null;    const isValid = await compare(credentials.password, maybeUser.password);    if (!isValid) {      return null;    }    return { id: maybeUser.id, email: maybeUser.email };  };}\n```\n\n### Create an enhanced Prisma client[‚Äã](https://zenstack.dev/docs/guides/authentication/next-auth#create-an-enhanced-prisma-client \"Direct link to Create an enhanced Prisma client\")\n\nYou can create an enhanced Prisma client which automatically validates access policies, field validation rules etc., during CRUD operations. For more details, please refer to [ZModel Language](https://zenstack.dev/docs/reference/zmodel-language) reference.\n\nTo create such a client with a standard setup, call the `enhance` API with a regular Prisma client and the current user (fetched with NextAuth API). Here's an example:\n\n```\nimport type { NextApiRequest, NextApiResponse } from 'next';import { getServerSession } from 'next-auth';import { enhance } from '@zenstackhq/runtime';import { authOptions } from '../../pages/api/auth/[...nextauth]';import { prisma } from '../../../server/db/client';async function getPrisma(req: NextApiRequest, res: NextApiResponse) {    const session = await getServerSession(req, res, authOptions);    // create a wrapper of Prisma client that enforces access policy,    // data validation, and @password, @omit behaviors    return enhance(prisma, { user: session?.user });}\n```\n\nYou can then use this enhanced Prisma client for CRUD operations that you desire to be governed by the access policies you defined in your data models.",
  "title": "Integrating With Auth.js (NextAuth) | ZenStack",
  "description": "Integrating with Auth.js.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/serialization",
  "markdown": "# Data Serialization | ZenStack\n\nOne problem with passing Prisma requests and responses across the network is that the data is not always serializable. The following Prisma types are problematic:\n\n*   `Date`: Javascript's `Date` object is serializable, but its type is lost\n*   `Bytes`: not serializable\n*   `BigInt`: not serializable\n*   `Decimal`: not serializable\n\nZenStack solves this problem by using [superjson](https://github.com/blitz-js/superjson) to deserialize input and serialize output. Since data is still JSON-serializable most of the time, ZenStack adopts superjson in a non-intrusive way. The serialized data is directly put inside the request or response data. When there is extra serialization information (superjson generates it when it encounters data that's not JSON-serializable), it's put inside the `meta` field in the request or response.\n\nThe benefit of this design is that if the data is fully JSON-serializable (not involving the types mentioned above), the wire format is just plain JSON serialization without any pollution.\n\nYou can find more details about serialization in the [RPC API Handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rpc#serialization) and [RESTful API Handler](https://zenstack.dev/docs/reference/server-adapters/api-handlers/rest#serialization) documentation.\n\n### üõ†Ô∏è Observing Serialization Behavior[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/serialization#%EF%B8%8F-observing-serialization-behavior \"Direct link to üõ†Ô∏è Observing Serialization Behavior\")\n\nTo illustrate this, let's try a few requests to observe the serialization behavior.\n\nMake the following request to find the first `List` with `{\"select\":{\"id\":true,\"title\":true}}`:\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst?q=%7B%22select%22%3A%7B%22id%22%3Atrue%2C%22title%22%3Atrue%7D%7D\" -H \"x-user-id: 1\"\n```\n\nYou should get a simple response. Since the result data is fully JSON-serializable, the response has no extra serialization metadata.\n\n```\n{    \"data\": {        \"id\":1,        \"title\":\"Grocery\"    }}\n```\n\nNow, if we send a different request and ask for the full `List` object\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst\" -H \"x-user-id: 1\"\n```\n\nWe get back a richer response. The `createdAt` and `updatedAt` fields are not directly JSON-serializable, and the information contained in the `meta.serialization` field is generated by superjson to facilitate deserialization.\n\n```\n{   \"data\" : {      \"createdAt\" : \"2023-11-08T04:38:53.385Z\",      \"id\" : 1,      \"ownerId\" : 1,      \"private\" : false,      \"spaceId\" : 1,      \"title\" : \"Grocery\",      \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"   },   \"meta\" : {      \"serialization\" : {         \"values\" : {            \"createdAt\" : [ \"Date\" ],            \"updatedAt\" : [ \"Date\" ]         }      }   }}\n```\n\nThe API consumer should pass the data and the serialization metadata to the superjson API to get back data with full fidelity. The following code shows how to deserialize and restore the proper `Date` type for the `createdAt` and `updatedAt` fields.\n\n```\nimport SuperJSON from 'superjson';SuperJSON.deserialize({    json: {        \"createdAt\" : \"2023-11-08T04:38:53.385Z\",        \"id\" : 1,        \"ownerId\" : 1,        \"private\" : false,        \"spaceId\" : 1,        \"title\" : \"Grocery\",        \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"   },   meta: {        \"values\" : {            \"createdAt\" : [ \"Date\" ],            \"updatedAt\" : [ \"Date\" ]        }    }});\n```\n\n```\n{    createdAt: 2023-11-08T04:38:53.385Z,    id: 1,    ownerId: 1,    private: false,    spaceId: 1,    title: 'Grocery',    updatedAt: 2023-11-09T04:52:57.987Z}\n```",
  "title": "Data Serialization | ZenStack",
  "description": "One problem with passing Prisma requests and responses across the network is that the data is not always serializable. The following Prisma types are problematic:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/authentication/supabase",
  "markdown": "# Integrating With Supabase Auth | ZenStack\n\n[Supabase](https://supabase.com/) is a comprehensive Backend-as-a-Service that offers database, authentication, and blob services.\n\nTo get access policies to work, ZenStack needs to be connected to the authentication system to get the user's identity. If you use Supabase as your authentication provider, this document will guide you through integrating ZenStack with it.\n\n### Using Prisma with Supabase[‚Äã](https://zenstack.dev/docs/guides/authentication/supabase#using-prisma-with-supabase \"Direct link to Using Prisma with Supabase\")\n\ninfo\n\nThis section is only relevant if you're also using Supabase's Database service as the underlying Postgres database of Prisma/ZenStack.\n\nThis section is not directly to integrating authentication, but since ZenStack is based on Prisma, understanding how Prisma and Supabase should be set up appropriately when Supabase Auth is involved is important.\n\nSupabase Auth stores user data in a separate Postgres schema called \"auth\". Since that schema is managed by Supabase, it's good idea not to directly import it into ZModel and use it in your application, since Supabase team may decide to change table schemas at any time. Instead, a better approach is to define your own `User` model in ZModel, and use database triggers to synchronize user data from Supabase Auth to your `User` table.\n\n**Schema:**\n\nschema.zmodel\n\n```\nmodel User {    id String @id @db.Uuid    posts Post[]    ... // other fields    @@allow('read', true)}model Post {    id String @id @db.Uuid    title String    author User @relation(fields: [authorId], references: [id])    authorId String @db.Uuid    @@allow('all', author == auth())}\n```\n\n**Database trigger (for synchronizing new users):**\n\nYou can check [here](https://supabase.com/docs/guides/database/postgres/triggers) for a general introduction about triggers in Supabase. The following code shows how to use it to synchronize new users:\n\n```\n-- inserts a row into public.\"User\"create function public.handle_new_user()returns triggerlanguage plpgsqlsecurity definer set search_path = publicas $$begin  insert into public.\"User\" (id)  values (new.id);  return new;end;$$;-- trigger the function every time a user is createdcreate trigger on_auth_user_created  after insert on auth.users  for each row execute procedure public.handle_new_user();\n```\n\nSimilarly you can implement more triggers to synchronize user update and delete. Find more information about this approach [here](https://supabase.com/docs/guides/auth/managing-user-data#using-triggers).\n\nWith these in place, your own `User` table will be always in sync with Supabase Auth, and in your application, your other entities will have relations to the `User` table instead of pointing to Supabase Auth's internal tables.\n\n### Creating an enhanced Prisma client[‚Äã](https://zenstack.dev/docs/guides/authentication/supabase#creating-an-enhanced-prisma-client \"Direct link to Creating an enhanced Prisma client\")\n\nTo get ZenStack's access policies to work, you need to create an enhanced `PrismaClient` with a current user context. The way to fetch \"current user\" on the server side depends on the type of server you're using. Supabase provides a set of [auth helpers](https://supabase.com/docs/guides/auth/auth-helpers) for different frameworks. For example, if you're following [this guide](https://supabase.com/docs/guides/auth/auth-helpers/nextjs) to use Supabase Auth with Next.js (app router), you can create an enhanced `PrismaClient` using `@supabase/auth-helpers-nextjs` like the following:\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';import { prisma } from '@lib/db';// create a wrapper of Prisma client that enforces access policy,// data validation, and @password, @omit behaviorsasync function getPrisma() {    const supabase = createRouteHandlerClient({ cookies });    const { data: user } = await supabase.auth.getUser();    const uid = user.user?.id;    // TODO: if you need to access fields other than just \"id\" in access policies,     // you can do a database query here to fetch the full user record    const contextUser = uid ? { id: uid } : undefined;    return enhance(prisma, { user: contextUser });}\n```\n\nwarning\n\nIt may be tempting to call Supabase's `getSession` API to get the current user. However, the data returned is not validated on the server side, so it should not be trusted. You can find more details in [this GitHub discussion](https://github.com/orgs/supabase/discussions/23224). Calling `getUser` instead guarantees that the return user identity is validated remotely, although it incurs an extra network request to Supabase. Supabase may resolve the performance issue in the future.\n\nSpecial thanks to [@bbozzay](https://github.com/bbozzay) for bringing this issue to our attention!\n\nYou can then use this enhanced Prisma client for CRUD operations that you desire to be governed by the access policies you defined in your data models.\n\nNext, make sure to read [this guide](https://zenstack.dev/docs/guides/supabase-security) to ensure your database is securely protected from HTTP requests to the supabase API.",
  "title": "Integrating With Supabase Auth | ZenStack",
  "description": "Integrating with Supabase Auth.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/conclusion",
  "markdown": "# Conclusion | ZenStack\n\nIn this part of the guide, we've focused on ZenStack's powers for deriving CRUD APIs automatically from the ZModel schema. We had an overview of the different API flavors and learned how to mount the APIs onto a backend framework.\n\nIn the next part, we'll see how effortless it is to consume the APIs from a frontend application and eventually turn our Todo project into a full-stack application.\n\nThe completed sample project up to the end of this part can be found in the \"part3\" branch of the [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/part3) repo. You can clone it and check out to that branch with the following command:\n\n```\ngit clone --branch part3 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```",
  "title": "Conclusion | ZenStack",
  "description": "In this part of the guide, we've focused on ZenStack's powers for deriving CRUD APIs automatically from the ZModel schema. We had an overview of the different API flavors and learned how to mount the APIs onto a backend framework.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/customization",
  "markdown": "# Customizing The Generated API | ZenStack\n\nHaving APIs derived from the schema is great, but sometimes, you want to customize them to fit your needs. Some of the common use cases are:\n\nIn this chapter, let's explore a few options to do that.\n\nMost server frameworks provide some kind of \"middleware\" mechanism for developers to intercept requests and responses. For example, you can use a separate Express middleware to add custom a custom header to the response before it's sent to the client:\n\n```\napp.use('/api/rpc',     ZenStackMiddleware({        getPrisma: (req) => enhance(prisma, { user: getUser(req) }),        // instructs the middleware to not send the response,        // instead, store it in `res.locals`        sendResponse: false,    }),    (req: Request, res: Response) => {        // another middleware to intercept the CRUD response,        // add a header and send the response        const { status, body } = res.locals;        res.header('x-requested-by', req.headers['x-user-id']);        res.status(status).json(body);    });\n```\n\nSince server adapters are just lightweight wrappers around API handlers, you can also implement a custom adapter to interact with the API handler directly. This way, you have complete control over how the API handler's result data is processed and sent back to the client as a framework response.\n\nThe following code demonstrates how to add the 'x-requested-by' header with this approach:\n\n```\nimport { RPCApiHandler } from '@zenstackhq/server/api';app.use('/api/rpc-custom', async (req: Request, res: Response) => {    const url = req.protocol + '://' + req.get('host') + req.originalUrl;    const searchParams = new URL(url).searchParams;    const query = Object.fromEntries(searchParams);    const handler = RPCHandler();    const { status, body } = await handler({        method: req.method,        path: req.path,        query,        requestBody: req.body,        prisma: enhance(prisma, { user: getUser(req) }) as any,    });    res.status(status)        .header('x-requested-by', req.header('x-user-id'))        .json(body);});\n```\n\nUsing the automatic CRUD API doesn't mean you can't implement your own APIs. You can always build fully customized APIs from scratch and leverage the enhanced Prisma Client.",
  "title": "Customizing The Generated API | ZenStack",
  "description": "Having APIs derived from the schema is great, but sometimes, you want to customize them to fit your needs. Some of the common use cases are:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/documentation",
  "markdown": "# Generating API Documentation | ZenStack\n\nVersion: 2.x\n\nAn API is only complete when documented. Similar to the API itself, the documentation can also be derived from the ZModel.\n\nIn [Part II](https://zenstack.dev/docs/the-complete-guide/part2/) of the guide, we've learned how to use plugins. ZenStack ships the [@zenstackhq/openapi](https://zenstack.dev/docs/reference/plugins/openapi) plugin to generate [OpenAPI](https://www.openapis.org/) specs from the ZModel schema. Like the API handlers, the openapi plugin also supports two flavors: \"rpc\" and \"rest\".\n\nOnce the documentation is generated, it's easy to render it using tools like [Swagger UI](https://swagger.io/tools/swagger-ui/) and [Redocly](https://redocly.com/).\n\n### üõ†Ô∏è Serving API Documentation[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/documentation#%EF%B8%8F-serving-api-documentation \"Direct link to üõ†Ô∏è Serving API Documentation\")\n\nLet's generate an OpenAPI spec for our Todo API and serve it using Swagger UI.\n\n#### 1\\. Installing Dependencies[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/documentation#1-installing-dependencies \"Direct link to 1. Installing Dependencies\")\n\n```\nnpm install --save-dev @zenstackhq/openapinpm install swagger-ui-expressnpm install -D @types/swagger-ui-express\n```\n\n#### 2\\. Adding OpenAPI Plugin to ZModel[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/documentation#2-adding-openapi-plugin-to-zmodel \"Direct link to 2. Adding OpenAPI Plugin to ZModel\")\n\nschema.zmodel\n\n```\nplugin openapi {    provider = \"@zenstackhq/openapi\"    output = \"todo-api.json\"    title = \"My Todo API\"    version = \"1.0.0\"    flavor = \"rpc\"}\n```\n\nRerun generation:\n\nThe `todo-api.json` file should be generated in the project root.\n\n#### 3\\. Serving the OpenAPI Spec[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/documentation#3-serving-the-openapi-spec \"Direct link to 3. Serving the OpenAPI Spec\")\n\nAdd the following code to `main.ts` before the line of `app.listen(...)`:\n\nmain.ts\n\n```\nimport swaggerUI from 'swagger-ui-express';app.use(    '/api/docs',    swaggerUI.serve,    swaggerUI.setup(require('./todo-api.json')));\n```\n\nNow, you can visit the documentation at [http://localhost:3000/api/docs](http://localhost:3000/api/docs) in a browser.\n\n![Swagger UI](https://zenstack.dev/assets/images/todo-app-openapi-5c63d09d659d098462f00c376787718c.png)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Generating API Documentation | ZenStack",
  "description": "An API is only complete when documented. Similar to the API itself, the documentation can also be derived from the ZModel.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/server-adapters",
  "markdown": "# Server Adapters | ZenStack\n\n### Overview[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/server-adapters#overview \"Direct link to Overview\")\n\nZenStack is a toolkit but not a framework. It doesn't come with its own web server. Instead, it provides a set of server adapters that \"mount\" APIs to the server of your choice.\n\nServer adapters are framework-specific. ZenStack ships a `@zenstackhq/server` package that contains adapters for the most popular backend and full-stack frameworks:\n\n*   [Express](https://zenstack.dev/docs/reference/server-adapters/express)\n*   [Fastify](https://zenstack.dev/docs/reference/server-adapters/fastify)\n*   [NestJS](https://zenstack.dev/docs/reference/server-adapters/nestjs)\n*   [Next.js](https://zenstack.dev/docs/reference/server-adapters/next)\n*   [Nuxt](https://zenstack.dev/docs/reference/server-adapters/nuxt)\n*   [SvelteKit](https://zenstack.dev/docs/reference/server-adapters/sveltekit)\n\nCheck out their respective documentation to learn more details.\n\nAs mentioned in the previous chapter, server adapters handle framework-specific request/response formats and transform them to the canonical form that the underlying API handlers understand. All server adapters share the following two initialization options:\n\n*   `handler`\n    \n    The API handler to use. As mentioned in the previous chapter, ZenStack provides two built-in API handler implementations. If you don't specify this option, the default API handler is RPC.\n    \n    *   RPC handler: `@zenstackhq/server/api/rpc`\n    *   RESTful handler: `@zenstackhq/server/api/rest`\n*   `getPrisma`\n    \n    A callback function for getting a PrismaClient instance used for handling a CRUD request. The function is passed with a framework-specific request object. Although you can return a vanilla Prisma Client, you most likely should use an enhanced one to enforce access policies.\n    \n\n### üõ†Ô∏è Serving CRUD API[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/server-adapters#%EF%B8%8F-serving-crud-api \"Direct link to üõ†Ô∏è Serving CRUD API\")\n\nLet's see how we can automagically turn our ZModel schema into a web API without really coding it üöÄ! We'll use Express for simplicity for now, but working with another framework is essentially the same.\n\n#### 1\\. Installing dependencies[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/server-adapters#1-installing-dependencies \"Direct link to 1. Installing dependencies\")\n\nFirst, install Express and the ZenStack server package:\n\n```\nnpm install express @zenstackhq/servernpm install --save-dev @types/express tsx\n```\n\n#### 2\\. Creating an Express app[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/server-adapters#2-creating-an-express-app \"Direct link to 2. Creating an Express app\")\n\nCreate a file `main.ts` with the following content:\n\nmain.ts\n\n```\nimport express from 'express';const app = express();app.use(express.json());app.get('/', (req, res) => {    res.json({ greet: 'Hello World!' });});app.listen(3000, () => console.log('üöÄ Server ready at: http://localhost:3000'));\n```\n\nStart the server:\n\nMake a request in another terminal to verify everything is working:\n\n```\ncurl http://localhost:3000\n```\n\n> { \"greet\": \"Hello World!\" }\n\n#### 3\\. Adding ZenStack server adapter (RPC flavor)[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/server-adapters#3-adding-zenstack-server-adapter-rpc-flavor \"Direct link to 3. Adding ZenStack server adapter (RPC flavor)\")\n\nLet's create an express middleware and mount the CRUD API to the `/api/rpc` path. Replace `main.ts` with the following content:\n\nmain.ts\n\n```\nimport { PrismaClient } from '@prisma/client';import { ZenStackMiddleware } from '@zenstackhq/server/express';import express from 'express';const app = express();app.use(express.json());const prisma = new PrismaClient();app.use('/api/rpc', ZenStackMiddleware({ getPrisma: () => prisma }));app.listen(3000, () => console.log('üöÄ Server ready at: http://localhost:3000'));\n```\n\ninfo\n\nThe `ZenStackMiddleware` server adapter uses RPC-flavor API by default.\n\nWe've configured the server adapter to use a vanilla Prisma Client for now for quick testing. By default, the server adapter uses RPC-style API. We can hit the endpoint to do a few tests now:\n\n*   Find a `List`\n    \n    ```\n    curl \"http://localhost:3000/api/rpc/list/findFirst\"\n    ```\n    \n    ```\n    {    \"data\" : {        \"createdAt\" : \"2023-11-08T04:38:53.385Z\",        \"id\" : 1,        \"ownerId\" : 1,        \"private\" : false,        \"spaceId\" : 1,        \"title\" : \"Grocery\",        \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"    },    \"meta\" : { ... }}\n    ```\n    \n*   Find a private `List`\n    \n    Note the parameter `q` is url-encoded `{\"where\":{\"private\":true}}`.\n    \n    ```\n    curl \"http://localhost:3000/api/rpc/list/findFirst?q=%7B%22where%22%3A%7B%22private%22%3Atrue%7D%7D\"\n    ```\n    \n    ```\n    {    \"data\" : {        \"createdAt\" : \"2023-11-11T02:34:29.880Z\",        \"id\" : 5,        \"ownerId\" : 1,        \"private\" : true,        \"spaceId\" : 1,        \"title\" : \"Joey' List\",        \"updatedAt\" : \"2023-11-11T02:34:29.880Z\"    },    \"meta\" : { ...}}\n    ```\n    \n*   Create a `List`\n    \n    ```\n    curl -XPOST \"http://localhost:3000/api/rpc/list/create\" \\    -d '{\"data\":{\"title\":\"Jobs to be done\",\"owner\":{\"connect\":{\"id\":2}},\"space\":{\"connect\":{\"id\":1}}}}' \\    -H 'Content-Type: application/json'\n    ```\n    \n    ```\n    {    \"data\": {        \"id\": 6,        \"createdAt\": \"2023-11-11T02:40:58.765Z\",        \"updatedAt\": \"2023-11-11T02:40:58.765Z\",        \"spaceId\": 1,        \"ownerId\": 2,        \"title\": \"Jobs to be done\",        \"private\": false    },    \"meta\": { ... }}\n    ```\n    \n\n#### 4\\. Making access policies work[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/server-adapters#4-making-access-policies-work \"Direct link to 4. Making access policies work\")\n\nTo make access policies work, we need to create an enhanced Prisma Client, and to do that, we need to be able to get the current user from the request. Since we haven't implemented authentication yet, we'll use a special `x-user-id` header to simulate and pass the requesting user's ID. It's definitely not a secure implementation, but it's sufficient for demonstration. We'll hook up a real authentication system in [Part IV](https://zenstack.dev/docs/the-complete-guide/part4/).\n\nReplace the content of `main.ts` with the following code:\n\nmain.ts\n\n```\nimport { PrismaClient } from '@prisma/client';import { enhance } from '@zenstackhq/runtime';import { ZenStackMiddleware } from '@zenstackhq/server/express';import express, { Request } from 'express';const app = express();app.use(express.json());const prisma = new PrismaClient();function getUser(req: Request) {    if (req.headers['x-user-id']) {        return { id: parseInt(req.headers['x-user-id'] as string) };    } else {        return undefined;    }}app.use('/api/rpc',     ZenStackMiddleware({         getPrisma: (req) => enhance(prisma, { user: getUser(req) })    }));app.listen(3000, () => console.log('üöÄ Server ready at: http://localhost:3000'));\n```\n\nNow, if we hit the endpoint again without the `x-user-id` header, we'll get a null response:\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst\"\n```\n\nAdd the header and request again. We should get back a result then:\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst\" -H \"x-user-id: 1\"\n```\n\n```\n{  \"data\": {    \"id\": 1,    \"createdAt\": \"2023-11-08T04:38:53.385Z\",    \"updatedAt\": \"2023-11-09T04:52:57.987Z\",    \"spaceId\": 1,    \"ownerId\": 1,    \"title\": \"Grocery\",    \"private\": false  },  \"meta\": { ... }}\n```\n\nYou can try other operations with different user identities. The service's behavior should be consistent with what we've seen in the REPL with the enhanced Prisma in [Part I](https://zenstack.dev/docs/the-complete-guide/part1/access-policy/current-user#add-user-based-access-control).\n\n#### 5\\. Trying Out The RESTful API Flavor[‚Äã](https://zenstack.dev/docs/the-complete-guide/part3/server-adapters#5-trying-out-the-restful-api-flavor \"Direct link to 5. Trying Out The RESTful API Flavor\")\n\nLet's mount a RESTful-flavor API under another path `/api/rest`. Add the following code to `main.ts` before the line of `app.listen(...)`:\n\n```\nimport RESTHandler from '@zenstackhq/server/api/rest';app.use('/api/rest',     ZenStackMiddleware({         handler: RESTHandler({ endpoint: 'http://localhost:3000/api/rest' }),        getPrisma: (req) => enhance(prisma, { user: getUser(req) })    }));\n```\n\nAs you've seen above, we're using the same server adapter implementation and swapped the API handler. Now we can fetch the first `List` item by making a RESTful-style request.\n\ninfo\n\nThe \"-g\" parameter passed to curl is for allowing square brackets in the URL.\n\n```\ncurl -g 'http://localhost:3000/api/rest/list?page[limit]=1' -H \"x-user-id: 1\"\n```\n\n```\n{   \"data\" : [      {         \"attributes\" : {            \"createdAt\" : \"2023-11-08T04:38:53.385Z\",            \"ownerId\" : 1,            \"private\" : false,            \"spaceId\" : 1,            \"title\" : \"Grocery\",            \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"         },         \"id\" : 1,         \"links\" : { ... },         \"relationships\" : { ... },         \"type\" : \"list\"      }   ],   \"jsonapi\" : {      \"version\" : \"1.1\"   },   \"links\" : { ... },   \"meta\" : { ... }}\n```",
  "title": "Server Adapters | ZenStack",
  "description": "Overview",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/plugins/zod",
  "markdown": "# @core/zod | ZenStack\n\nThe schemas for validating the models and input data for creating and updating the models. They contain field's typing and [validation rules](https://zenstack.dev/docs/1.x/reference/zmodel-language#data-validation). The module exports several Zod schemas for each model for different use cases. To facilitate the discussion, let's use the following model as an example:\n\n*   _\\[Model\\]Schema_\n    \n    The schema for validating the model itself, including all scalar fields, foreign key fields, and relation fields. All fields are optional (**we may revisit this design in a future release**).\n    \n    ```\n    const PostSchema = z.object({  id: z.number(),  title: z.string().min(10).max(255),  published: z.boolean(),  createdAt: z.date(),  updatedAt: z.date(),  author: z.record(z.unknown()),  authorId: z.number(),}).partial();\n    ```\n    \n*   _\\[Model\\]CreateScalarSchema_\n    \n    The schema for validating the input for creating the model. It only includes scalar fields. All fields are required unless it's optional in the model or has a default value.\n    \n    ```\n    const PostCreateScalarSchema = z.object({  id: z.number().optional(),  title: z.string().min(10).max(255),  published: z.boolean().optional(),  createdAt: z.date().optional(),  updatedAt: z.date().optional(),});\n    ```\n    \n*   _\\[Model\\]CreateSchema_\n    \n    The schema for validating the input for creating the model. It's similar to `[Model]CreateScalarSchema` but includes foreign key fields. You can use it to validate create input that involves setting foreign keys.\n    \n    ```\n    const PostCreateSchema = z.object({  id: z.number().optional(),  title: z.string().min(10).max(255),  published: z.boolean().optional(),  createdAt: z.date().optional(),  updatedAt: z.date().optional(),  authorId: z.number(),});\n    ```\n    \n*   _\\[Model\\]UpdateScalarSchema_\n    \n    The schema for validating the input for updating the model. It only includes scalar fields. All fields are optional (since in Prisma's semantic, all updates are patching).\n    \n    ```\n    const PostUpdateScalarSchema = z.object({  id: z.number(),  title: z.string().min(10).max(255),  published: z.boolean(),  createdAt: z.date(),  updatedAt: z.date(),}).partial();\n    ```\n    \n*   _\\[Model\\]UpdateSchema_\n    \n    Similar to `[Model]UpdateScalarSchema` but includes foreign key fields (all optional). You can use it to validate update input that involves setting foreign keys.\n    \n    ```\n    const PostUpdateSchema = z.object({  id: z.number(),  title: z.string().min(10).max(255),  published: z.boolean(),  createdAt: z.date(),  updatedAt: z.date(),  authorId: z.number(),}).partial();\n    ```\n    \n*   _\\[Model\\]???WithoutRefinementSchema_\n    \n    This includes `[Model]WithoutRefinementSchema`, `[Model]CreateWithoutRefinementSchema`, and `[Model]UpdateWithoutRefinementSchema`. These are only generated when a model contains `@@validate` model-level data validation rules.\n    \n    The `@@validate` rules are translated into `z.refine()` calls. For example, for the `Post` model, the following refinement function is generated:\n    \n    ```\n    function refinePost<T, D extends z.ZodTypeDef>(schema: z.ZodType<T, D, T>) {  return schema.refine((value: any) => new RegExp('^[A-Za-z0-9 ]+$').test(value?.title));}\n    ```\n    \n    However, zod has a limitation that, when you call `.refine()` on a `ZodObject` schema, the result won't be an object schema anymore, which means that you can't use `.omit()`, `.partial()`, etc. `ZodObject` methods to further tune it for your needs anymore. That's why a series of `WithoutRefinementSchema` schemas are exported. They are the Zod schemas prior to calling the `refine()` method. If you need to make changes to the schema while still preserving the `@@validate` rules, you can manipulate the `WithoutRefinementSchema` schemas and then call the `refine` function manually on the result. E.g.:\n    \n    ```\n    const myPostCreateSchema = refinePost(PostCreateWithoutRefinementSchema.omit({id: true}));\n    ```\n    \n*   _\\[Model\\]PrismaCreateSchema_\n    \n    Used internally by ZenStack.\n    \n*   _\\[Model\\]PrismaUpdateSchema_\n    \n    Used internally by ZenStack.",
  "title": "@core/zod | ZenStack",
  "description": "Built-in plugin for generating Zod schemas for validating CRUD input arguments",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/field-level",
  "markdown": "# Field-Level Policies | ZenStack\n\nIn the previous parts, we've introduced how to write model-level policies to control CRUD permissions. In database terms, this is called row-level security. With the power of relation traversal, current user access, and flexible expressions and functions, you are fully equipped to handle most real-world authorization scenarios. Sometimes, however, you'll find yourself needing more fine-grained access control.\n\nZenStack's field-level policies allow you to define access rules for individual fields. For example, you can allow a blog post's owner to update its title and content, but only users with the \"EDITOR\" role can change the \"published\" field.\n\nThe combination of model-level and field-level policies gives you the ultimate granularity and flexibility and lets ZenStack surpass Postgres's native [row-level-security](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) capabilities.\n\n### Defining Field-Level Policies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/field-level#defining-field-level-policies \"Direct link to Defining Field-Level Policies\")\n\nTo define field-level policies, you use the `@allow` and `@deny` field-level attributes to attach rules to fields. Beware that field-level attributes always start with a single `@`. Here's an example:\n\n```\nmodel Post {    ...    published Boolean @allow('update', auth().role == EDITOR)}\n```\n\ninfo\n\nYou can't use `future()` function in field-level access policies. To express post-update rules, put them into model-level policies. We have an active [feature request](https://github.com/zenstackhq/zenstack/issues/671) for it.\n\n### Difference Between Field-Level and Model-Level Policies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/field-level#difference-between-field-level-and-model-level-policies \"Direct link to Difference Between Field-Level and Model-Level Policies\")\n\nA few key differences between field-level policies and model-level policies:\n\n*   Field-level policies only support \"read\", \"update\", and \"all\" operations. It's not meaningful to control \"create\" and \"delete\" permissions at the field level.\n*   Field-level access is allowed by default. If you don't attach any rule to a field, it's accessible as long as the model is accessible. On the contrary, model-level access is denied by default. You'll have to explicitly open up access using `@@allow` attributes.\n\n### Behavior of Field-Level Access Control[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/field-level#behavior-of-field-level-access-control \"Direct link to Behavior of Field-Level Access Control\")\n\nA field's accessibility is determined in the following order:\n\n*   If no access policies are defined for the field, the operation is allowed\n*   If any `@deny` rule is satisfied, the operation is denied\n*   If some `@allow` rules are defined, and none of them are satisfied, the operation is denied\n*   Otherwise, the operation is allowed\n\nWhen a \"read\" operation is denied, the field is dropped from the result. When an \"update\" operation is denied, the operation is rejected with an error.\n\n### Overriding Model-Level Policies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/field-level#overriding-model-level-policies \"Direct link to Overriding Model-Level Policies\")\n\nTo successfully \"read\" or \"update\" a field, the current user must first satisfy the corresponding model-level policies unless the field-level `@allow` attribute is passed with a third argument `true` to override.\n\n```\nmodel Post {    ...    published Boolean @allow('update', auth().role == EDITOR, true)    @@allow('update', !published)}\n```\n\nIn the example above, if a `Post` is published, although the model-level policy denies updates, an EDITOR user can still update the `published` field (and only this field) because of the overriding setting on the field-level policy. Without the override flag, the update operation will be denied.\n\nYou can use this feature with \"read\" policies, too. If a field has an override \"read\" policy, the field can be read if it's explicitly selected in the query, even if the model-level policy denies access.\n\n### üõ†Ô∏è Adding Field-Level Policies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/field-level#%EF%B8%8F-adding-field-level-policies \"Direct link to üõ†Ô∏è Adding Field-Level Policies\")\n\nBack to where we left off in the previous chapter, let's tighten up our schema and prevent the `ownerId` field from being updated for `List` and `Todo`:\n\nschema.zmodel\n\n```\nmodel List {    ...    ownerId Int @deny('update', true)}model Todo {    ...    ownerId Int @deny('update', true)}\n```\n\nRerun generation and start REPL:\n\n```\nnpx zenstack generatenpx zenstack repl\n```\n\nFirst, create a new `List` using Joey (id #1):\n\n```\n.auth { id: 1 }db.list.create({ data: { title: \"Joey' List\", private: true, owner: { connect: { id: 1 } }, space: { connect: { id: 1 } } } })\n```\n\nResult:\n\n```\n{  id: 4,  createdAt: 2023-11-09T05:36:20.264Z,  updatedAt: 2023-11-09T05:36:20.264Z,  spaceId: 1,  ownerId: 1,  title: \"Joey' List\",  private: true}\n```\n\nTry to update the `owner` field to Rachel (id #2):\n\n```\ndb.list.update({ where: { id: 1 }, data: { owner: { connect: 2 } } })\n```\n\nThe operation is denied:\n\n```\ndenied by policy: list entities failed 'update' check, entity { id: 1 } failed update policy check for field \"owner\"Code: P2004Meta: { reason: 'ACCESS_POLICY_VIOLATION' }\n```",
  "title": "Field-Level Policies | ZenStack",
  "description": "In the previous parts, we've introduced how to write model-level policies to control CRUD permissions. In database terms, this is called row-level security. With the power of relation traversal, current user access, and flexible expressions and functions, you are fully equipped to handle most real-world authorization scenarios. Sometimes, however, you'll find yourself needing more fine-grained access control.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/plugins/prisma",
  "markdown": "# @core/prisma | ZenStack\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "@core/prisma | ZenStack",
  "description": "Built-in plugin for generating Prisma schema",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/plugins/model-meta",
  "markdown": "# @core/model-meta | ZenStack\n\nThe `@core/model-meta` plugin generates lightweight metadata for introspecting schema at runtime.\n\nThis plugin is built-in to ZenStack and does not need to be installed separately.\n\nRuntime APIs like [`enhance`](https://zenstack.dev/docs/1.x/reference/runtime-api#enhance) and [`withPolicy`](https://zenstack.dev/docs/1.x/reference/runtime-api#withpolicy) depend on the output of this plugin and by default load it from the default output location. If you customize the output location, you need to load and pass it manually:\n\n```\nconst meta = require('./lib/zenstack/model-meta').default;const db = enhance(prisma, { user }, undefined, meta);\n```",
  "title": "@core/model-meta | ZenStack",
  "description": "Built-in plugin for generating lightweight metadata for introspecting schema at runtime",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/api-flavor/",
  "markdown": "# API Flavors | ZenStack\n\nVersion: 2.x\n\nAPI design is a complex topic. While thinking about wrapping CRUD APIs around ORM, we feel there are two main competing goals:\n\n*   Query flexibility\n    \n    Prisma's API is very flexible, especially regarding nested reads and writes. It'd be nice to preserve this flexibility fully in the derived APIs. This way, you can also carry your knowledge of using Prisma over to using the APIs.\n    \n*   RESTfulness\n    \n    When designing CRUD APIs, making it RESTful is a natural choice. Resource-oriented URLs and semantic HTTP verbs match the problem well. While RESTful APIs traditionally suffer from the [N + 1 Problem](https://restfulapi.net/rest-api-n-1-problem/) (as traditionally ORM did, too), there are some conventions we can use to mitigate it.\n    \n\nIt is tough to choose one over the other. So, we decided to provide both API flavors. You can choose the one that fits your use case better.\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "API Flavors | ZenStack",
  "description": "API design is a complex topic. While thinking about wrapping CRUD APIs around ORM, we feel there are two main competing goals:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/plugins/trpc",
  "markdown": "# @zenstackhq/trpc | ZenStack\n\nThe `@zenstackhq/trpc` plugin generates a [tRPC router](https://trpc.io/docs/router) to make database CRUD calls. You can use it directly as your main router or merge it with other routers to create a more complex setup. The router syntactically mirrors the APIs of a standard Prisma client, including the function names and shapes of parameters (hooks directly use types generated by Prisma).\n\ninfo\n\nThe `@zenstackhq/trpc` plugin depends on the [`@core/zod`](https://zenstack.dev/docs/1.x/reference/plugins/zod) plugin to generate Zod schemas for the routers' input, and will enable that plugin automatically if it's not already enabled.\n\nThis plugin is based on [prisma-trpc-generator](https://github.com/omar-dulaimi/prisma-trpc-generator). Thanks to [Omar Dulaimi](https://github.com/omar-dulaimi) for making this happen!\n\n### Installation[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/trpc#installation \"Direct link to Installation\")\n\n```\nnpm install --save-dev @zenstackhq/trpc\n```\n\n### Options[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/trpc#options \"Direct link to Options\")\n\n| Name | Type | Description | Required | Default |\n| --- | --- | --- | --- | --- |\n| output | String | Output directory (relative to the path of ZModel) | Yes |     |\n| generateModels | String, String\\[\\] | Array or comma separated string for the models to generate routers for. | No  | All models |\n| generateModelActions | String, String\\[\\] | Array or comma separated string for actions to generate for each model: `create`, `findUnique`, `update`, etc. | No  | All supported Prisma actions |\n| generateClientHelpers | String, String\\[\\] | Array or comma separated string for the types of client helpers to generate. Supported values: \"react\" or \"next\". See [here](https://zenstack.dev/docs/1.x/reference/plugins/trpc#client-helpers) for more details. | No  |     |\n| zodSchemasImport | String | Import path for the generated zod schemas. The trpc plugin relies on the `@core/zod` plugin to generate zod schemas for input validation. If you set a custom output location for the zod schemas, you can use this option to override the import path. | No  | @zenstackhq/runtime/zod |\n\ninfo\n\nWhen `@core/zod` plugin is automatically enabled by the `@zenstackhq/trpc` plugin, if the `@zenstackhq/trpc` plugin has a `generateModels` option specified, it'll be carried over to the `@core/zod` plugin as well.\n\n## Dependencies[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/trpc#dependencies \"Direct link to Dependencies\")\n\n*   [`@core/zod`](https://zenstack.dev/docs/1.x/reference/plugins/zod)\n\n### Details[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/trpc#details \"Direct link to Details\")\n\n#### Preparing tRPC Context[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/trpc#preparing-trpc-context \"Direct link to Preparing tRPC Context\")\n\nThe generated tRPC routers require a `prisma` field in the context and you need to make sure to include it when creating the context. You can use any PrismaClient instance for it, but most likely you want to use one created with [`enhance`](https://zenstack.dev/docs/1.x/reference/runtime-api#enhance) so that the client enforces access control policies.\n\n```\nexport const createContext = async ({ req, res }: CreateNextContextOptions) => {    const session = await getServerAuthSession({ req, res });    return {        session,        // use access-control-enabled db client        prisma: enhance(prisma, { user: session?.user }),    };};\n```\n\n#### Client Helpers[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/trpc#client-helpers \"Direct link to Client Helpers\")\n\nTRPC relies on TypeScript's type inference to provide the client-side API call signatures. This is very neat and powerful, but it has some limitations regarding generic APIs. For example, one of the best features of Prisma's API is its output type automatically adapts to the input's shape. e.g.:\n\n```\nconst post = await prisma.post.findFirst({ include: { author: true } });\n```\n\nFor the code above, the `post` variable is smartly inferred to be of type `Post & { author: User }`. However, if you wrap it with tRPC, such typing adaptivity is lost:\n\n```\n// trpc routerconst router = t.router({  findFirst: t.procedure    .input(PostInputSchema)    .query(({ ctx, input }) => ctx.prisma.findFirst(input))})// client sideconst { data } = trpc.post.findFirst({ include: { author: true } });\n```\n\nNow the `data` field has a fixed `Post` type, even though at runtime it carries the extra `author` field.\n\nTo mitigate this limitation, ZenStack's tRPC plugin can generate a \"type-fixing\" helper that re-enables the inference power from the client side. To use it, you need to specify the `generateClientHelpers` option:\n\n```\nplugin trpc {  provider = '@zenstackhq/trpc'  output = 'server/routers/generated'  generateClientHelpers = 'next'}\n```\n\nUse value \"next\" if you're using tRPC with Next.js, or \"react\" if using it with react-query. With that option on, the plugin generates an extra \"client\" folder containing helpers that do the type fixing. The only code change you need to make is instead of calling the `createTRPCNext` or `createTRPCReact` API, you call the one generated instead.\n\nHere's an example of how to use it with Next.js:\n\n```\nimport { createTRPCNext } from 'server/routers/generated/client/next';export const trpc = createTRPCNext<AppRouter>({    ...});\n```\n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/trpc#example \"Direct link to Example\")\n\nHere's an example with a blogging app:\n\n/schema.zmodel\n\n```\nplugin trpc {  provider = '@zenstackhq/trpc'  output = 'server/routers/generated'  generateModelActions = 'create,update,findUnique,findMany'}model User {  id            String    @id @default(cuid())  email         String  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)}model Post {  id        String @id @default(cuid())  title     String  published Boolean @default(false)  author    User @relation(fields: [authorId], references: [id])  authorId  String  // author has full access  @@allow('all', auth() == author)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\n/server/routers/\\_app.ts\n\n```\nimport { createRouter as createCRUDRouter } from './generated/routers';import { initTRPC } from '@trpc/server';import { type Context } from '../context';const t = initTRPC.context<Context>().create();export const appRouter = createCRUDRouter(t.router, t.procedure);export type AppRouter = typeof appRouter;\n```\n\nCheck out the [Using With tRPC](https://zenstack.dev/docs/1.x/guides/trpc) guide for more details about using ZenStack in a tRPC project.",
  "title": "@zenstackhq/trpc | ZenStack",
  "description": "Plugin for generating tRPC data query routes",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/plugins/openapi",
  "markdown": "# @zenstackhq/openapi | ZenStack\n\n```\nmodel User {    id String @id    email String @unique    @@openapi.meta({        security: [ { basic: [] } ],        tagDescription: 'Operations for managing users',        findMany: {            description: 'Find users matching the given conditions'        },        delete: {            method: 'put',            path: 'dodelete',            description: 'Delete a unique user',            summary: 'Delete a user yeah yeah',            tags: ['delete', 'user'],        },        createMany: {            security: [],            deprecated: true        }    })}\n```",
  "title": "@zenstackhq/openapi | ZenStack",
  "description": "Plugin for generating OpenAPI 3.0 specifications",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/plugins/swr",
  "markdown": "# @zenstackhq/swr | ZenStack\n\nThe `@zenstackhq/swr` plugin generates [SWR](https://swr.vercel.app/) hooks that call into the CRUD services provided by the [server adapters](https://zenstack.dev/docs/1.x/category/server-adapters).\n\nThe hooks syntactically mirror the APIs of a standard Prisma client, including the function names and shapes of parameters (hooks directly use types generated by Prisma).\n\nTo use the generated hooks, you need to install \"swr\" version 2.0.0 or above.\n\n### Installation[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#installation \"Direct link to Installation\")\n\n```\nnpm install --save-dev @zenstackhq/swr\n```\n\n### Context Provider[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#context-provider \"Direct link to Context Provider\")\n\nThe plugin generates a React context provider which you can use to configure the behavior of the hooks. The following options are available on the provider:\n\n*   endpoint\n    \n    The endpoint to use for the queries. Defaults to \"/api/model\".\n    \n*   fetch\n    \n    A custom `fetch` function to use for the queries. Defaults to the browser's built-in `fetch`.\n    \n\nExample for using the context provider:\n\n```\nimport { FetchFn, Provider as ZenStackHooksProvider } from '../lib/hooks';// custom fetch function that adds a custom headerconst myFetch: FetchFn = (url, options) => {    options = options ?? {};    options.headers = {        ...options.headers,        'x-my-custom-header': 'hello world',    };    return fetch(url, options);};function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {    return (        <ZenStackHooksProvider value={{ endpoint: '/api/model', fetch: myFetch }}>            <AppContent />        </ZenStackHooksProvider>    );}export default MyApp;\n```\n\n### Options[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#options \"Direct link to Options\")\n\n| Name | Type | Description | Required | Default |\n| --- | --- | --- | --- | --- |\n| output | String | Output directory (relative to the path of ZModel) | Yes |     |\n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#example \"Direct link to Example\")\n\nHere's a quick example with a blogging app. You can find a fully functional Todo app example [here](https://github.com/zenstackhq/sample-todo-nextjs).\n\n#### Schema[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#schema \"Direct link to Schema\")\n\n/schema.zmodel\n\n```\nplugin hooks {  provider = '@zenstackhq/swr'  output = \"./src/lib/hooks\"}model User {  id            String    @id @default(cuid())  email         String  posts         Post[]  // everyone can signup, and user profile is also publicly readable  @@allow('create,read', true)}model Post {  id        String @id @default(cuid())  title     String  published Boolean @default(false)  author    User @relation(fields: [authorId], references: [id])  authorId  String  // author has full access  @@allow('all', auth() == author)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\n#### Using Query and Mutation Hooks[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#using-query-and-mutation-hooks \"Direct link to Using Query and Mutation Hooks\")\n\n/src/components/posts.tsx\n\n```\nimport type { Post } from '@prisma/client';import { useFindManyPost, useCreatePost } from '../lib/hooks';// post list componentconst Posts = ({ userId }: { userId: string }) => {    const { trigger: createPost } = useCreatePost();    // list all posts that're visible to the current user, together with their authors    const { data: posts } = useFindManyPost({        include: { author: true },        orderBy: { createdAt: 'desc' },    });    function onCreatePost() {        createPost({            data: {                title: 'My awesome post',                authorId: userId,            },        });    }    return (        <>            <button onClick={onCreatePost}>Create</button>            <ul>                {posts?.map((post) => (                    <li key={post.id}>                        {post.title} by {post.author.email}                    </li>                ))}            </ul>        </>    );};\n```\n\n### Automatic Optimistic Update (Preview)[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#automatic-optimistic-update-preview \"Direct link to Automatic Optimistic Update (Preview)\")\n\nOptimistic update is a technique that allows you to update the data cache immediately when a mutation executes while waiting for the server response. It helps achieve a more responsive UI. SWR provides the [infrastructure for implementing it](https://swr.vercel.app/docs/mutation#optimistic-updates).\n\nThe ZenStack-generated mutation hooks allow you to opt-in to \"automatic optimistic update\" by passing the `optimisticUpdate` option when calling the hook. When the mutation executes, it analyzes the current queries in the cache and tries to find the ones that need to be updated. When the mutation settles (either succeeded or failed), the queries are invalidated to trigger a re-fetch.\n\nHere's an example:\n\n```\nconst { trigger: create } = useCreatePost({ optimisticUpdate: true });function onCreatePost() {    create({ ... })}\n```\n\nWhen `create` executes, if there are active queries like `useFindManyPost()`, the data of the mutation call will be optimistically inserted into the head of the query result.\n\n#### Details of the optimistic behavior[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#details-of-the-optimistic-behavior \"Direct link to Details of the optimistic behavior\")\n\n*   `create` mutation inserts item to the head of the query results of the corresponding `useFindMany` queries.\n*   `update` mutation updates the item in the query results of `useFindXXX` queries and their nested reads by matching the item's ID.\n*   `delete` mutation removes the item from the query results of the corresponding `useFindMany` queries and sets `null` to `useFindUnique` and `useFindFirst` query results, by matching the item's ID.\n\n#### Limitations[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#limitations \"Direct link to Limitations\")\n\n*   The automatic optimistic update relies on ID matching. It only works for queries that select the ID field(s).\n*   Non-entity-fetching queries like `count`, `aggregate`, and `groupBy` are not affected.\n*   Infinite queries are not affected.\n*   It doesn't respect filter conditions or access policies that potentially affect the queries under update. For example, for query `useFindManyPost({ where: { published: true }})`, when a non-published `Post` is created, it'll still be inserted into the query result.\n\n#### Opt-out[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#opt-out \"Direct link to Opt-out\")\n\nBy default, all queries opt into automatic optimistic update. You can opt-out on a per-query basis by passing `false` to the `optimisticUpdate` option.\n\n```\n// arguments are query args, query options, and optimisticUpdateconst { data } = useFindManyPost(    { where: { published: true } },    { optimisticUpdate: false });\n```\n\nWhen a query opts out, it won't be updated by a mutation, even if the mutation is set to update optimistically.\n\n#### Using Infinite Query[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#using-infinite-query \"Direct link to Using Infinite Query\")\n\nSee [SWR's documentation](https://swr.vercel.app/docs/pagination) for more details.\n\n/src/components/posts.tsx\n\n```\nimport type { Post } from '@prisma/client';import { useInfiniteFindManyPost } from '../lib/hooks';// post list component with infinite loadingconst Posts = ({ userId }: { userId: string }) => {    const PAGE_SIZE = 10;    const { data: pages, size, setSize } = useInfiniteFindManyPost(        (pageIndex, previousPageData) => {            if (previousPageData && !previousPageData.length) {                return null;            }            return {                include: { author: true },                orderBy: { createdAt: 'desc' },                take: PAGE_SIZE,                skip: pageIndex * PAGE_SIZE,            };        }    );    const isEmpty = pages?.[0]?.length === 0;    const isReachingEnd = isEmpty || (pages && pages[pages.length - 1].length < PAGE_SIZE);    return (        <>            <ul>                {pages?.map((posts, index) => (                    <React.Fragment key={index}>                        {posts?.map((post) => (                            <li key={post.id}>                                {post.title} by {post.author.email}                            </li>                        ))}                    </React.Fragment>                ))}            </ul>            {!isReachingEnd && (                <button onClick={() => setSize(size + 1)}>                    Load more                </button>            )}        </>    );};\n```\n\n## Advanced[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#advanced \"Direct link to Advanced\")\n\n### Query Invalidation[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#query-invalidation \"Direct link to Query Invalidation\")\n\nThe mutation hooks generated by ZenStack automatically invalidates the queries that are potentially affected by the changes. For example, if you create a `Post`, the `useFindManyPost` query will be automatically invalidated when the mutation succeeds. Invalidation causes cache to be purged and fresh data to be refetched.\n\nThe automatic invalidation takes care of nested read, write, and delete cascading.\n\n**1\\. Nested Read**\n\nNested reads are also subject to automatic invalidation. For example, if you create a `Post`, the query made by\n\n```\nuseFindUniqueUser({ where: { id: userId }, include: { posts: true } });\n```\n\nwill be invalidated.\n\n**2\\. Nested Write**\n\nSimilarly, nested writes also trigger automatic invalidation. For example, if you create a `Post` in a nested update to `User` like:\n\n```\nupdateUser({ where: { id: userId }, posts: { create: { title: 'post1' } } });\n```\n\nThe mutation will cause queries like `useFindManyPost()` to be invalidated.\n\n**3\\. Delete Cascade**\n\nIn ZModel, relations can be configured to cascade delete, e.g.:\n\n```\nmodel User {    ...    posts Post[]}model Post {    ...    user User @relation(fields: [userId], references: [id], onDelete: Cascade)    userId Int}\n```\n\nWhen a `User` is deleted, the `Post` entities it owns will be deleted automatically. The generated hooks takes cascade delete into account. For example, if you delete a `User`, `Post` model will be considered as affected and queries like `useFindManyPost()` will be invalidated.\n\ninfo\n\nThe automatic invalidation is enabled by default, and you can use the `revalidate` option to opt-out and handle revalidation by yourself.\n\n```\nuseCreatePost({ revalidate: false });\n```\n\n### Query Key[‚Äã](https://zenstack.dev/docs/1.x/reference/plugins/swr#query-key \"Direct link to Query Key\")\n\nQuery keys serve as unique identifiers for organizing the query cache. The generated hooks use the following query key scheme:\n\n```\nJSON.stringify({ prefix: 'zenstack', model, operation, args, flags })\n```\n\nFor example, the query key for\n\n```\nuseFindUniqueUser({ where: { id: '1' } })\n```\n\nwill be:\n\n```\nJSON.stringify({     prefix: 'zenstack',    model: 'User',     operation: 'findUnique',     args: { where: { id: '1' } },     flags: { infinite: false } })\n```\n\nYou can use the generated `getQueryKey` function to compute it.",
  "title": "@zenstackhq/swr | ZenStack",
  "description": "Plugin for generating SWR query and mutation hooks",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/",
  "markdown": "# API Handlers | ZenStack\n\nVersion: 1.x\n\nZenStack supports two API styles: _**rpc**_ and _**rest**_:\n\n*   _**rpc**_ style API directly mirrors Prisma client's API, thus provides endpoints like `[model]/findMany`, `[model]/create`, etc. Its input and output data format also aligns with that of Prisma client.\n    \n*   _**rest**_ style API is designed to be more RESTful, thus provides endpoints like `[model]`, `[model]/[id]`, `[model]/[id]/relationships/[relationship]`, etc. It uses [JSON:API](https://jsonapi.org/) as its data format.\n    \n\nAPI handlers are framework-agnostic and deals with canonicalized request and response objects. It's the responsibility of the server adapters to translate the framework-specific request and response types. You can use either of these two API handlers with any server adapter.\n\nThe following diagram illustrates their relationships with server adapters.\n\n![ZModel Generation](https://zenstack.dev/img/intro/api-handler-light.png)![ZModel Generation](https://zenstack.dev/img/intro/api-handler-dark.png)\n\nCheckout the reference pages for detailed information about these API handlers:\n\n*   [RPC API Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc)\n*   [RESTful API Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "API Handlers | ZenStack",
  "description": "ZenStack supports two API styles",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/server-adapters/express",
  "markdown": "# Express.js | ZenStack\n\n```\n// create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n```\n\n```\n{    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n```",
  "title": "Express.js | ZenStack",
  "description": "Adapter for integrating with Express.js",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/server-adapters/nuxt",
  "markdown": "# Nuxt | ZenStack\n\n```\n// create a user with two postsconst r = await fetch(`/api/user/create`, {    method: 'POST',    headers: { 'Content-Type': 'application/json' },    body: JSON.stringify({        include: { posts: true },        data: {            email: 'user1@abc.com',            posts: {                create: [{ title: 'Post 1' }, { title: 'Post 2' }],            },        },    }),});console.log(await r.json());\n```\n\n```\n{    \"id\": 1,    \"email\": \"user1@abc.com\",    \"posts\": [        {            \"id\": 1,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 1\",            \"authorId\": 1        },        {            \"id\": 2,            \"createdAt\": \"2023-03-14T07:45:04.036Z\",            \"updatedAt\": \"2023-03-14T07:45:04.036Z\",            \"title\": \"Post 2\",            \"authorId\": 1        }    ]}\n```",
  "title": "Nuxt | ZenStack",
  "description": "Adapter for integrating with Nuxt",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest",
  "markdown": "# RESTful API Handler | ZenStack\n\n## Introduction[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#introduction \"Direct link to Introduction\")\n\nThe RESTful-style API handler exposes CRUD APIs as RESTful endpoints using [JSON:API](https://jsonapi.org/) as transportation format. The API handler is not meant to be used directly; instead, you should use it together with a [server adapter](https://zenstack.dev/docs/1.x/category/server-adapters) which handles the request and response API for a specific framework.\n\nIt can be created as the following:\n\n*   Next.js\n*   SvelteKit\n*   Nuxt\n\n/src/pages/api/model/\\[...path\\].ts\n\n```\nimport { NextRequestHandler } from '@zenstackhq/server/next';import RestApiHandler from '@zenstackhq/server/api/rest';import { getPrisma } from '../../lib/db';export default NextRequestHandler({     getPrisma,    handler: RestApiHandler({ endpoint: 'http://myhost/api' }) });\n```\n\nThe factory function accepts an options object with the following fields:\n\n*   endpoint\n    \n    Required. A `string` field representing the base URL of the RESTful API, used for generating resource links.\n    \n*   pageSize\n    \n    Optional. A `number` field representing the default page size for listing resources and relationships. Defaults to 100. Set to Infinity to disable pagination.\n    \n\n## Endpoints and Features[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#endpoints-and-features \"Direct link to Endpoints and Features\")\n\nThe RESTful API handler conforms to the the [JSON:API](https://jsonapi.org/format/) v1.1 specification for its URL design and input/output format. The following sections list the endpoints and features are implemented. The examples refer to the following schema modeling a blogging app:\n\n```\nmodel User {    id Int @id @default(autoincrement())    email String    posts Post[]}model Profile {    id Int @id @default(autoincrement())    gender String    user User @relation(fields: [userId], references: [id])    userId Int @unique}model Post {    id Int @id @default(autoincrement())    title String    published Boolean @default(false)    viewCount Int @default(0)    author User @relation(fields: [authorId], references: [id])    authorId Int    comments Comment[]}model Comment {    id Int @id @default(autoincrement())    content String    post Post @relation(fields: [postId], references: [id])    postId Int}\n```\n\n### Listing resources[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#listing-resources \"Direct link to Listing resources\")\n\nA specific type of resource can be listed using the following endpoint:\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#status-codes \"Direct link to Status codes\")\n\n*   200: The request was successful and the response body contains the requested resources.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples \"Direct link to Examples\")\n\n```\n{    \"meta\": {        \"total\": 1    },    \"data\": [        {            \"attributes\": {                \"authorId\": 1,                \"published\": true,                \"title\": \"My Awesome Post\",                \"viewCount\": 0            },            \"id\": 1,            \"links\": {                \"self\": \"http://myhost/api/post/1\"            },            \"relationships\": {                \"author\": {                    \"data\": { \"id\": 1, \"type\": \"user\" },                    \"links\": {                        \"related\": \"http://myhost/api/post/1/author/1\",                        \"self\": \"http://myhost/api/post/1/relationships/author/1\"                    }                }            },            \"type\": \"post\"        }    ],    \"jsonapi\": {        \"version\": \"1.1\"    },    \"links\": {        \"first\": \"http://myhost/api/post?page%5Blimit%5D=100\",        \"last\": \"http://myhost/api/post?page%5Boffset%5D=0\",        \"next\": null,        \"prev\": null,        \"self\": \"http://myhost/api/post\"    }}\n```\n\n### Fetching a resource[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#fetching-a-resource \"Direct link to Fetching a resource\")\n\nA unique resource can be fetched using the following endpoint:\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#status-codes-1 \"Direct link to Status codes\")\n\n*   200: The request was successful and the response body contains the requested resource.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type or ID does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-1 \"Direct link to Examples\")\n\n```\n{    \"data\": {        \"attributes\": {            \"authorId\": 1,            \"published\": true,            \"title\": \"My Awesome Post\",            \"viewCount\": 0        },        \"id\": 1,        \"links\": {            \"self\": \"http://myhost/api/post/1\"        },        \"relationships\": {            \"author\": {                \"data\": { \"id\": 1, \"type\": \"user\" },                \"links\": {                    \"related\": \"http://myhost/api/post/1/author/1\",                    \"self\": \"http://myhost/api/post/1/relationships/author/1\"                }            }        },        \"type\": \"post\"    },    \"jsonapi\": {        \"version\": \"1.1\"    },    \"links\": {        \"self\": \"http://myhost/api/post/1\"    }}\n```\n\n### Fetching relationships[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#fetching-relationships \"Direct link to Fetching relationships\")\n\nA resource's relationships can be fetched using the following endpoint:\n\n```\nGET /:type/:id/relationships/:relationship\n```\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#status-codes-2 \"Direct link to Status codes\")\n\n*   200: The request was successful and the response body contains the requested relationships.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type, ID, or relationship does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-2 \"Direct link to Examples\")\n\n1.  Fetching a to-one relationship\n    \n    ```\n    GET /post/1/relationships/author\n    ```\n    \n    ```\n    {    \"data\" : { \"id\" : 1, \"type\" : \"user\" },    \"jsonapi\" : {        \"version\" : \"1.1\"    },    \"links\" : {        \"self\" : \"http://myhost/api/post/1/relationships/author\"    }}\n    ```\n    \n2.  Fetching a to-many relationship\n    \n    ```\n    GET /user/1/relationships/posts\n    ```\n    \n    ```\n    {    \"data\" : [        { \"id\" : 1, \"type\" : \"post\" },        { \"id\" : 2, \"type\" : \"post\" }    ],    \"jsonapi\" : {        \"version\" : \"1.1\"    },    \"links\" : {        \"first\" : \"http://myhost/api/user/1/relationships/posts?page%5Blimit%5D=100\",        \"last\" : \"http://myhost/api/user/1/relationships/posts?page%5Boffset%5D=0\",        \"next\" : null,        \"prev\" : null,        \"self\" : \"http://myhost/api/user/1/relationships/posts\"    }}\n    ```\n    \n\n```\nGET /:type/:id/:relationship\n```\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#status-codes-3 \"Direct link to Status codes\")\n\n*   200: The request was successful and the response body contains the requested relationship.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type, ID, or relationship does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-3 \"Direct link to Examples\")\n\n```\n{   \"data\" : {      \"attributes\" : {         \"email\" : \"emily@zenstack.dev\",         \"name\" : \"Emily\"      },      \"id\" : 1,      \"links\" : {         \"self\" : \"http://myhost/api/user/1\"      },      \"relationships\" : {         \"posts\" : {            \"links\" : {               \"related\" : \"http://myhost/api/user/1/posts\",               \"self\" : \"http://myhost/api/user/1/relationships/posts\"            }         }      },      \"type\" : \"user\"   },   \"jsonapi\" : {      \"version\" : \"1.1\"   },   \"links\" : {      \"self\" : \"http://myhost/api/post/1/author\"   }}\n```\n\n### Fine-grained data fetching[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#fine-grained-data-fetching \"Direct link to Fine-grained data fetching\")\n\n#### Filtering[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#filtering \"Direct link to Filtering\")\n\nYou can use the `filter[:selector1][:selector2][...]=value` [query parameter family](https://jsonapi.org/format/#query-parameters-families) to filter resource collections or relationship collections.\n\n##### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-4 \"Direct link to Examples\")\n\n1.  Equality filter against plain field\n    \n    ```\n    GET /api/post?filter[published]=false\n    ```\n    \n2.  Equality filter against relationship\n    \n    Relationship field can be filtered directly by its id.\n    \n    ```\n    GET /api/post?filter[author]=1\n    ```\n    \n    If the relationship is to-many, the filter has \"some\" semantic and evaluates to `true` if any of the items in the relationship matches.\n    \n    ```\n    GET /api/user?filter[posts]=1\n    ```\n    \n3.  Filtering with multiple values\n    \n    Multiple filter values can be separated by comma. Items statisfying any of the values will be returned.\n    \n    ```\n    GET /api/post?filter[author]=1,2\n    ```\n    \n4.  Multiple filters\n    \n    A request can carry multiple filters. Only items statisfying all filters will be returned.\n    \n    ```\n    GET /api/post?filter[author]=1&filter[published]=true\n    ```\n    \n5.  Deep filtering\n    \n    A filter can carry multiple field selectors to reach into relationships.\n    \n    ```\n    GET /api/post?filter[author][name]=Emily\n    ```\n    \n    When reaching into a to-many relationship, the filter has \"some\" semantic and evaluates to `true` if any of the items in the relationship matches.\n    \n    ```\n    GET /api/user?filter[posts][published]=true\n    ```\n    \n6.  Filtering with comparison operators\n    \n    Filters can go beyond equality by appending an \"operator suffix\".\n    \n    ```\n    GET /api/post?filter[viewCount$gt]=100\n    ```\n    \n    The following operators are supported:\n    \n    *   **$lt**\n        \n        Less than\n        \n    *   **$lte**\n        \n        Less than or equal to\n        \n    *   **$gt**\n        \n        Greater than\n        \n    *   **$gte**\n        \n        Greater than or equal to\n        \n    *   **$contains**\n        \n        String contains\n        \n    *   **$icontains**\n        \n        Case-insensitive string contains\n        \n    *   **$search**\n        \n        String full-text search\n        \n    *   **$startsWith**\n        \n        String starts with\n        \n    *   **$endsWith**\n        \n        String ends with\n        \n    *   **$has**\n        \n        Collection has value\n        \n    *   **$hasEvery**\n        \n        Collection has every element in value\n        \n    *   **$hasSome**\n        \n        Collection has some elements in value\n        \n    *   **$isEmpty**\n        \n        Collection is empty\n        \n\n#### Sorting[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#sorting \"Direct link to Sorting\")\n\nYou can use the `sort` query parameter to sort resource collections or relationship collections. The value of the parameter is a comma-separated list of fields names. The order of the fields in the list determines the order of sorting. By default, sorting is done in ascending order. To sort in descending order, prefix the field name with a minus sign.\n\n##### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-5 \"Direct link to Examples\")\n\n```\nGET /api/post?sort=createdAt,-viewCount\n```\n\nWhen creating a RESTful API handler, you can pass in a `pageSize` option to control pagination behavior of fetching a collection of resources, related resources, and relationships. By default the page size is 100, and you can disable pagination by setting `pageSize` option to `Infinity`.\n\nWhen fetching a collection resource or relationship, you can use the `page[offset]=value` and `page[limit]=value` [query parameter family](https://jsonapi.org/format/#query-parameters-families) to fetch a specific page. They're mapped to `skip` and `take` parameters in the query arguments sent to PrismaClient.\n\nThe response data of collection fetching contains pagination links that facilitate navigating through the collection. The \"meta\" section also contains the total count available. E.g.:\n\n```\n{    \"meta\": {        \"total\": 10    },    \"data\" : [        ...    ],    \"links\" : {        \"first\" : \"http://myhost/api/post?page%5Blimit%5D=2\",        \"last\" : \"http://myhost/api/post?page%5Boffset%5D=4\",        \"next\" : \"http://myhost/api/post?page%5Boffset%5D=4&page%5Blimit%5D=2\",        \"prev\" : \"http://myhost/api/post?page%5Boffset%5D=0&page%5Blimit%5D=2\",        \"self\" : \"http://myhost/api/post\"    }}\n```\n\n##### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-6 \"Direct link to Examples\")\n\n1.  Fetching a specific page of resources\n    \n    ```\n    GET /api/post?page[offset]=10&page[limit]=5\n    ```\n    \n2.  Fetching a specific page of relationships\n    \n    ```\n    GET /api/user/1/relationships/posts?page[offset]=10&page[limit]=5\n    ```\n    \n3.  Fetching a specific page of related resources\n    \n    ```\n    GET /api/user/1/posts?page[offset]=10&page[limit]=5\n    ```\n    \n\nYou can use the `include` query parameter to include related resources in the response. The value of the parameter is a comma-separated list of fields names. Field names can contain dots to reach into nested relationships.\n\nWhen including related resources, the response data takes the form of [Compound Documents](https://jsonapi.org/format/#document-compound-documents) and contains a `included` field carrying normalized related resources. E.g.:\n\n```\n{   \"data\" : [      {         \"attributes\" : {            ...         },         \"id\" : 1,         \"relationships\" : {            \"author\" : {               \"data\" : { \"id\" : 1, \"type\" : \"user\" }            }         },         \"type\" : \"post\"      }   ],   \"included\" : [      {         \"attributes\" : {            \"email\" : \"emily@zenstack.dev\",            \"name\" : \"Emily\"         },         \"id\" : 1,         \"links\" : {            \"self\" : \"http://myhost/api/user/1\"         },         \"relationships\" : {            \"posts\" : {               \"links\" : {                  \"related\" : \"http://myhost/api/user/1/posts\",                  \"self\" : \"http://myhost/api/user/1/relationships/posts\"               }            }         },         \"type\" : \"user\"      }   ]}\n```\n\n##### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-7 \"Direct link to Examples\")\n\n1.  Including a direct relationship\n    \n    ```\n    GET /api/post?include=author\n    ```\n    \n2.  Including a deep relationship\n    \n    ```\n    GET /api/post?include=author.profile\n    ```\n    \n3.  Including multiple relationships\n    \n    ```\n    GET /api/post?include=author,comments\n    ```\n    \n\n### Creating a resource[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#creating-a-resource \"Direct link to Creating a resource\")\n\nA new resource can be created using the following endpoint:\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#status-codes-4 \"Direct link to Status codes\")\n\n*   201: The request was successful and the resource was created.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-8 \"Direct link to Examples\")\n\n1.  Creating a resource\n    \n    ```\n    POST /user{    \"data\": {        \"type\": \"user\",        \"attributes\": {            \"name\": \"Emily\",            \"email\": \"emily@zenstack.dev\"        }    }}\n    ```\n    \n2.  Creating a resource with relationships attached\n    \n    ```\n    POST /user{    \"data\": {        \"type\": \"user\",        \"attributes\": {            \"name\": \"Emily\",            \"email\": \"emily@zenstack.dev\"        },        \"relationships\": {            \"posts\": {                \"data\": [{ \"type\": \"post\", \"id\": 1 }]            }        }    }}\n    ```\n    \n\n### Updating a resource[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#updating-a-resource \"Direct link to Updating a resource\")\n\nA resource can be updated using the following endpoints:\n\n```\nPUT /:type/:idPATCH /:type/:id\n```\n\nBoth `PUT` and `PATCH` do partial update and has exactly the same behavior.\n\ninfo\n\nBesides plain fields, you can also include relationships in the request body. Please note that this won't update the related resource; instead if only replaces the relationships. If you update a to-many relationship, the new collection will entirely replace the old one.\n\nRelationships can also be manipulated directly. See [Manipulating Relationships](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#manipulating-relationships) for more details.\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#status-codes-5 \"Direct link to Status codes\")\n\n*   200: The request was successful and the resource was updated.\n*   400: The request was malformed.\n*   403: The request was forbidden.\n*   404: The requested resource type or ID does not exist.\n\n#### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-9 \"Direct link to Examples\")\n\n1.  Updating a resource\n    \n    ```\n    PUT /post/1{    \"data\": {        \"type\": \"post\",        \"attributes\": {            \"title\": \"My Awesome Post\"        }    }}\n    ```\n    \n2.  Updating a resource's relationships\n    \n    ```\n    PUT /user/1{    \"data\": {        \"type\": \"user\",        \"relationships\": {            \"posts\": {                \"data\": [{ \"type\": \"post\", \"id\": 2 }]            }        }    }}\n    ```\n    \n\n### Deleting a resource[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#deleting-a-resource \"Direct link to Deleting a resource\")\n\nA resource can be deleted using the following endpoint:\n\n#### Status codes[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#status-codes-6 \"Direct link to Status codes\")\n\n*   204: The request was successful and the resource was deleted.\n*   403: The request was forbidden.\n*   404: The requested resource type or ID does not exist.\n\n### Manipulating relationships[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#manipulating-relationships \"Direct link to Manipulating relationships\")\n\nRelationships can be manipulated using the following endpoints:\n\n#### Adding to a to-many relationship[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#adding-to-a-to-many-relationship \"Direct link to Adding to a to-many relationship\")\n\n```\nPOST /:type/:id/relationships/:relationship\n```\n\n##### Status codes[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#status-codes-7 \"Direct link to Status codes\")\n\n*   200: The request was successful and the relationship was updated.\n*   403: The request was forbidden.\n*   404: The requested resource type, ID, or relationship does not exist.\n\n##### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-10 \"Direct link to Examples\")\n\n```\nPOST /user/1/relationships/posts{    \"data\": [        { \"type\": \"post\", \"id\": \"1\" },        { \"type\": \"post\", \"id\": \"2\" }    ]}\n```\n\n#### Updating a relationship (to-one or to-many)[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#updating-a-relationship-to-one-or-to-many \"Direct link to Updating a relationship (to-one or to-many)\")\n\n```\nPUT /:type/:id/relationships/:relationshipPATCH /:type/:id/relationships/:relationship\n```\n\ninfo\n\n`PUT` and `PATCH` has exactly the same behavior and both relace the existing relationships with the new ones entirely.\n\n##### Status codes[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#status-codes-8 \"Direct link to Status codes\")\n\n*   200: The request was successful and the relationship was updated.\n*   403: The request was forbidden.\n*   404: The requested resource type, ID, or relationship does not exist.\n\n##### Examples[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#examples-11 \"Direct link to Examples\")\n\n1.  Replacing a to-many relationship\n    \n    ```\n    PUT /user/1/relationships/posts{    \"data\": [        { \"type\": \"post\", \"id\": \"1\" },        { \"type\": \"post\", \"id\": \"2\" }    ]}\n    ```\n    \n2.  Replacing a to-one relationship\n    \n    ```\n    PUT /post/1/author{    \"data\": { \"type\": \"user\", \"id\": \"2\" }}\n    ```\n    \n3.  Clearing a to-many relationship\n    \n    ```\n    PUT /user/1/relationships/posts{    \"data\": []}\n    ```\n    \n4.  Clearing a to-one relationship\n    \n    ```\n    PUT /post/1/author{    \"data\": null}\n    ```\n    \n\n## Serialization[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#serialization \"Direct link to Serialization\")\n\nZenStack uses [superjson](https://github.com/blitz-js/superjson) to serialize and deserialize data. Superjson generates two parts during serialization:\n\n*   json:\n    \n    The JSON-compatible serialization result.\n    \n*   meta:\n    \n    The serialization metadata including information like field types that facilitates deserialization.\n    \n\nIf the data only involves simple data types, the serialization result is the same as regular `JSON.stringify`, and no `meta` part is generated. However, for complex data types (like `Bytes`, `Decimal`, etc.), a `meta` object will be generated, which needs to be carried along when sending the request, and will also be included in the response.\n\nWhen sending requests, if superjson-serializing the request body results in a `meta` object, it should be put into a `{ \"serialization\": meta }` object and included in the `meta` field of the request body. For example, if you have a `bytes` field of type `Bytes`, the request body should look like:\n\n```\nPOST /post{    \"data\": {        \"type\": \"post\",        \"attributes\": {            ...            \"bytes\": \"AQID\" // base64-encoded bytes        }    },    \"meta\": {         \"serialization\": {\"values\": { \"data.attributes.bytes\": [[ \"custom\", \"Bytes\"]] } }     } }\n```\n\nCorrespondingly, the response body of a query may look like:\n\n```\nGET /post/1{    \"data\": {        \"id\": \"1\",        \"type\": \"post\",        \"attributes\": {            ...            \"bytes\": \"AQID\" // base64-encoded bytes        }    },    \"meta\": {         \"serialization\": {\"values\": { \"data.attributes.bytes\": [[ \"custom\", \"Bytes\"]] } }     } }\n```\n\nYou should use the `meta.serialization` field value to superjson-deserialize the response body.\n\n### Data Type Serialization Format[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#data-type-serialization-format \"Direct link to Data Type Serialization Format\")\n\n*   `DateTime`\n    \n    ISO 8601 string\n    \n*   `Bytes`\n    \n    Base64-encoded string\n    \n*   `BigInt`\n    \n    String representation\n    \n*   `Decimal`\n    \n    String representation\n    \n\n## Error Handling[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#error-handling \"Direct link to Error Handling\")\n\nAn error response is an object containing the following fields:\n\n*   errors\n    \n    An array of error objects, each containing the following fields:\n    \n    *   code: `string`, error code\n    *   status: `number`, HTTP status code\n    *   title: `string`, error title\n    *   detail: `string`, error detail\n    *   prismaCode: `string`, Prisma error code, if the error is thrown by Prisma\n\n### Example[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#example \"Direct link to Example\")\n\n```\n{   \"errors\" : [      {         \"code\" : \"unsupported-model\",         \"detail\" : \"Model foo doesn't exist\",         \"status\" : 404,         \"title\" : \"Unsupported model type\"      }   ]}\n```",
  "title": "RESTful API Handler | ZenStack",
  "description": "RESTful-style API handler that provides resource-centric endpoints",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/guides/authentication/clerk",
  "markdown": "# Integrating With Clerk | ZenStack\n\n[Clerk](https://clerk.com/) is a comprehensive authentication and user management platform, providing both APIs and pre-made UI components.\n\n### Set up Clerk[‚Äã](https://zenstack.dev/docs/guides/authentication/clerk#set-up-clerk \"Direct link to Set up Clerk\")\n\nFirst, follow Clerk's [quick start guides](https://clerk.com/docs/quickstarts/overview) to set up your project.\n\n### Adjust your ZModel[‚Äã](https://zenstack.dev/docs/guides/authentication/clerk#adjust-your-zmodel \"Direct link to Adjust your ZModel\")\n\nSince Clerk manages both user authentication and storage, you don't need to store users in your database anymore. However, since the `auth()` function is resolved to the `User` model in ZModel, you still need to define it in your schema. The trick here is to mark the `User` model as ignored so Prisma doesn't map it to a database table.\n\nYou can include any field you want in the `User` model, as long as you provide the same set of fields in the context object used for creating the enhanced Prisma client.\n\nThe following code shows an example blog post schema:\n\n```\nmodel User {    id String @id    @@ignore}model Post {  id String @id @default(cuid())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title String  published Boolean @default(false)  authorId String // stores Clerk's user ID  // author has full access  @@allow('all', auth() != null && auth().id == authorId)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\nIf you choose to [synchronize user data to your database](https://clerk.com/docs/users/sync-data-to-your-backend), you can model the `User` model as a regular Prisma model without putting the `@@ignore` attribute there.\n\n### Create an enhanced Prisma client[‚Äã](https://zenstack.dev/docs/guides/authentication/clerk#create-an-enhanced-prisma-client \"Direct link to Create an enhanced Prisma client\")\n\nYou can create an enhanced Prisma client that automatically validates access policies, field validation rules, etc., during CRUD operations. For more details, please refer to [ZModel Language](https://zenstack.dev/docs/reference/zmodel-language) reference.\n\nTo create such a client with a standard setup, call the `enhance` API with a regular Prisma client and the current user (fetched from Clerk). Here's an example:\n\n*   Next.js App Router\n*   Next.js Pages Router\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { auth } from \"@clerk/nextjs/server\";import { prisma } from '../lib/db';async function getPrisma() {  const authObject = auth();  // create a wrapper of Prisma client that enforces access policy  return enhance(prisma, {    user: authObject ? { id: authObject.userId } : undefined,  });}\n```\n\n* * *\n\nYou can find a working sample project for Next.js [here](https://github.com/zenstackhq/docs-tutorial-clerk). Use the \"main\" branch for app router, and the \"pages-router\" branch for pages router.",
  "title": "Integrating With Clerk | ZenStack",
  "description": "Integrating with Clerk.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/enhancement",
  "markdown": "# Enhanced Prisma Client | ZenStack\n\nHere we are, the most exciting part of ZenStack.\n\nIn the previous chapters, we've been focusing on the design-time concepts: the ZModel language and the `zenstack` CLI. Now, let's get to ZenStack's power at runtime. You'll understand why we say ZenStack ‚ö°Ô∏èsupercharges‚ö°Ô∏è Prisma.\n\n### What Is Enhanced Prisma Client?[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/enhancement#what-is-enhanced-prisma-client \"Direct link to What Is Enhanced Prisma Client?\")\n\nAn enhanced Prisma Client is a transparent proxy that wraps a regular Prisma Client instance. It has the same API as the original Prisma Client but adds additional behaviors by intercepting API calls. The added behaviors include:\n\n*   Enforcing access policies\n*   Data validation\n*   Hashing passwords\n*   Omitting fields from query results\n\nMore will come in the future.\n\nCreating an enhanced Prisma Client is easy, just call the `enhance` API with a regular Prisma Client:\n\n```\nimport { PrismaClient } from '@prisma/client';import { enhance } from '@zenstackhq/runtime';const prisma = new PrismaClient();const db = enhance(prisma);// db has the same typing as prismaawait db.user.findMany();await db.user.create({ data: { email: 'zen@stack.dev'} });\n```\n\nIn a real-world application, you'll usually call `enhance` with an extra context argument to provide the current user identity, so that the access policy engine knows which user is making the call.\n\n```\nimport { getSessionUser } from './auth';// the `getSessionUser` implementation depends on your authentication solutionconst db = enhance(prisma, { user: getSessionUser() });\n```\n\nWe'll get to that in detail in the next chapter.\n\nA few extra notes about enhanced Prisma Client:\n\n*   **Creating an enhanced client is cheap**\n    \n    It doesn't cause new database connections to be made. It's common to create a new enhanced Prisma Client per request.\n    \n*   **Using Prisma Client Extensions with enhanced client**\n    \n    Enhanced Prisma Client can work with [Prisma Client Extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) with some caveats. Please refer to [Using With Prisma Client Extensions](https://zenstack.dev/docs/1.x/guides/client-extensions) for more details.\n    \n*   **Using the original client and an enhanced one together**\n    \n    You can use both in your application. For example, you may want to use an enhanced client in part of the logic where you want access policy enforcement, while using the original client where you need unrestricted access to the database.\n    \n\nLimitations\n\nWe try to make the enhanced Prisma Client as compatible as possible with the original Prisma Client, but there are still some limitations:\n\n1.  No Sequential Operations Transaction\n\nEnhanced Prisma CLient doesn't support [sequential operations transaction](https://www.prisma.io/docs/concepts/components/prisma-client/transactions#sequential-prisma-client-operations). Use [interactive transaction](https://www.prisma.io/docs/concepts/components/prisma-client/transactions#interactive-transactions) instead, or simply use the original Prisma Client.\n\n1.  Raw SQL APIs Are Not Enhanced\n\nAlthough you can call raw sql APIs like `$queryRaw` or `$executeRaw`, these APIs are not enhanced, so their behavior is the same as the original Prisma Client. It means that, for example, if you use `@omit` to mark a field to be dropped on return:\n\n```\nmodel User {    ...    password String @omit}\n```\n\nIf you query via `$queryRaw`, the `password` field will still be returned.\n\nYou should fall back to using the original Prisma Client in such cases.\n\n### üõ†Ô∏è Using Enhanced Prisma Client In REPL[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/enhancement#%EF%B8%8F-using-enhanced-prisma-client-in-repl \"Direct link to üõ†Ô∏è Using Enhanced Prisma Client In REPL\")\n\nWe saw in the previous chapter that in the REPL environment, you can use the built-in `prisma` variable to access Prisma Client directly. Another variable named `db` gives you access to an enhanced Prisma Client.\n\nLet's try it out:\n\nIt works but gives an empty array. Why? With an enhanced Prisma Client, all operations are denied by default unless you explicitly open them up with access policies. Let's see how to do that in the next chapter.\n\n### Inner Workings[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/enhancement#inner-workings \"Direct link to Inner Workings\")\n\ninfo\n\nThis part is for those interested in the inner workings of ZenStack. It's not necessary to understand it to use ZenStack.\n\nIf you know the inner workings of Prisma Client, you'll find ZenStack shares some similarities.. When `zenstack generate` is run, besides generating the `prisma/schema.prisma` file, it also runs several other plugins that transform different pieces of information in the ZModel into Javascript code that can be efficiently loaded and executed at runtime. The `enhance` API relies on the generated code to get its job done.\n\n*   `model-meta.js`\n    \n    Lightweight representation of ZModel's AST.\n    \n*   `policy.js`\n    \n    Partial Prisma query input objects compiled from access policy expressions.\n    \n*   `zod/**/*.js|ts`\n    \n    Zod schemas for validating input data according to ZModel.\n    \n\nThe generation by default outputs to the `node_modules/.zenstack` folder. You can pass a `--output, -o` CLI switch when running `zenstack generate` to use a custom output location.\n\n```\nnpx zenstack generate -o lib/zenstack\n```\n\nThe `enhance` API, by default, loads the generated code from the `node_modules/.zenstack` folder. If you use a custom output location, make sure to use the `loadPath` option to specify it.\n\n```\nconst db = enhance(prisma, { user: getSessionUser() }, { loadPath: 'lib/zenstack' });\n```\n\n### Next[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/enhancement#next \"Direct link to Next\")\n\nThis chapter gave an abstract overview of the enhanced Prisma Client. In the following chapters, you'll see how each kind of enhancement helps simplify your development work.\n\nLet's roll on.",
  "title": "Enhanced Prisma Client | ZenStack",
  "description": "Here we are, the most exciting part of ZenStack.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/prisma",
  "markdown": "# Prisma Crash Course | ZenStack\n\ninfo\n\nFeel free to skip to the [next chapter](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel) if you are already familiar with Prisma.\n\nZenStack is built above Prisma ORM, so it'll be important to have a basic understanding of it.\n\nPrisma is a so-called \"schema-first\" ORM that simplifies database access for Node.js and TypeScript applications. It provides an intuitive and concise DSL (Domain-Specific Language) for defining data models and generates a type-safe client for accessing the database.\n\nThis guide is by no means a comprehensive introduction to Prisma, but it covers the most essential parts of understanding and using it.\n\n### Prisma Schema[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/prisma#prisma-schema \"Direct link to Prisma Schema\")\n\nYou can define your data models in a file called `schema.prisma`. Here's an example:\n\n```\nmodel User {    id Int @id @default(autoincrement())    email String @unique    name String?}\n```\n\nThe `User` model contains a primary key `id` (indicated by the `@id` attribute), a unique `email` field, and an optional `name` field. The `@default` attribute specifies the field's default value, and the `autoincrement` function instructs the database to generate incrementing values automatically.\n\nModeling relationships is also easy. The following example shows a `Post` model with a one-to-many relationship with the `User` model. The `@relation` attribute is the key for connecting the two models by associating them with a foreign key.\n\n```\nmodel User {    id Int @id @default(@autoincrement())    ...    posts Post[]}model Post {    id Int @id @default(@autoincrement())    title String    author User @relation(fields: [authorId], references: [id])    authorId Int}\n```\n\n### Prisma Client[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/prisma#prisma-client \"Direct link to Prisma Client\")\n\nYou can run the Prisma CLI to generate a type-safe client for accessing the database.\n\nThe client is generated into the `@prisma/client` package and can be used as the following:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient();// create a userawait prisma.user.create({    data: { email: 'user1@abc.com' }});// create a user together with two related postsawait prisma.user.create({     data: {        email: 'user2@abc.com',        posts: {            create: [                { title: 'Post 1' },                { title: 'Post 2' }            ]        }    }});// find posts with title containing some text, and return the author of each post togetherconst posts = prisma.post.findMany({    where: { title: { contains: 'ZenStack' } },    include: { author: true }});// here the `posts` is smartly inferred to be typed `Array<Post & { author: User }>`console.log(posts[0].author.email);\n```\n\n### Prisma Migrate[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/prisma#prisma-migrate \"Direct link to Prisma Migrate\")\n\nTo synchronize your schema to the database tables and fields, run the \"migrate\" command:\n\nIt synchronizes the local database with the schema and generates a migration record (used for reconstructing database's schema when your app deploys).\n\nWhen deploying your app to an integration environment (e.g, staging or production), you should run\n\n```\nnpx prisma migrate deploy\n```\n\nto apply the migration records to the database.\n\n* * *\n\nPrisma has a rich set of other features not covered here, like schema migration, data browsing, etc., but we've got enough knowledge to understand and use ZenStack. Check out [Prisma Documentation](https://www.prisma.io/docs/getting-started) for a more comprehensive introduction.",
  "title": "Prisma Crash Course | ZenStack",
  "description": "Feel free to skip to the next chapter if you are already familiar with Prisma.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/model-level",
  "markdown": "# Model-Level Policies | ZenStack\n\nThe most frequently used access policies are those declared at the model level - written using `@@allow` and `@@deny` model-level attributes.\n\nModel-level vs field-level attributes\n\nZenStack follows Prisma's convention: model-level attributes are prefixed with `@@`, and field-level attributes with `@`.\n\nHere's a basic example:\n\n```\nmodel Post {    id Int @id    title String    published Boolean @default(false)    // published posts are readable    @@allow('read', published)}\n```\n\nYou can also achieve the same goal with `@@deny`:\n\n```\nmodel Post {    id Int @id    title String    published Boolean @default(false)    @@allow('read', true)    @@deny('read', !published)}\n```\n\nBoth `@@allow` and `@@deny` take two arguments:\n\n1.  Operation\n    \n    `create`, `read`, `update`, `delete`, or a comma-separated list of them. You can also use `all` to abbreviate all operations.\n    \n2.  Condition: a boolean expression\n    \n    You can use boolean literals: `true` and `false`. Operators `==`, `!=`, `>`, `>=`, `<`, and `<=` can be used to compare values. You can also use `&&`, `||`, and `!` to compose boolean expressions.\n    \n    There are functions and special expressions that help you write more advanced conditions. We'll cover them in later chapters.\n    \n\n### Evaluation of Model-Level Policies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/model-level#evaluation-of-model-level-policies \"Direct link to Evaluation of Model-Level Policies\")\n\nYou can write as many policy rules as you want for a model. The order of the rules doesn't matter.\n\nZenStack determines whether a CRUD operation is allowed using the following logic:\n\n1.  If any `@@deny` rule evaluates to true, it's denied.\n2.  If any `@@allow` rule evaluates to true, it's allowed.\n3.  Otherwise, it's denied (secure by default).\n\nEach of the CRUD operation types governs a set of Prisma Client methods, as follows:\n\n*   **create**\n    \n    `create`, `createMany`, `upsert`, and `create`/`createMany`/`connectOrCreate` nested in create/update calls.\n    \n*   **read**\n    \n    `findUnique`, `findUniqueOrThrow`, `findFirst`, `findFirstOrThrow`, `count`, `aggregate`, and `groupBy`.\n    \n    The \"read\" operation also determines whether the value returned from `create`, `update` and `delete` method can be read.\n    \n*   **update**\n    \n    `update`, `updateMany`, `upsert`, and `update`/`updateMany`/`set`/`connect`/`connectOrCreate`/`disconnect` nested in create/update calls.\n    \n*   **delete**\n    \n    `delete`, `deleteMany`, and `delete` nested in update calls.\n    \n\nRelation manipulation and policies\n\nWhen a Prisma call involves relation manipulation, it can be unobvious which side the relation needs to satisfy the \"update\" policies. For example, given the following model:\n\n```\nmodel User {    ...    posts Post[]}model Post {    ...    author User @relation(fields: [authorId], references: [id])    authorId Int}\n```\n\nIf we add a post to a user like:\n\n```\ndb.user.update({    where: { id: 1 },    data: {        posts: { connect: { id: 1 } }    }})\n```\n\nDoes `Post#1` need to satisfy its \"update\" policies?\n\nThe trick is to consider which side of the relation will have a foreign key update. In this example, the foreign key `authorId` of `Post#1` will be updated, so `Post#1` needs to satisfy its \"update\" policies, and `User`'s \"update\" policies are not relevant.\n\nA special case is Prisma's [implicit many-to-many relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). Since there are no explicit foreign keys in this case, manipulating such a relation requires both sides to satisfy the \"update\" policies.\n\n### How Do Policies Affect Prisma Client's Behavior?[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/model-level#how-do-policies-affect-prisma-clients-behavior \"Direct link to How Do Policies Affect Prisma Client's Behavior?\")\n\nEnforcing access policies causes an enhanced Prisma Client to behave differently from the original. You can predict what happens with the following principles:\n\n*   Read methods behave as if the rows not satisfying the policies don't exist\n    \n    For example, `findMany` only returns rows that satisfy the policies. `count` only counts rows that satisfy the policies. This applies to nested reads as well. ZenStack enforces \"read\" policies by injecting `where` clauses into the Prisma query.\n    \n\nNested read can filter out parent records\n\nThere's one thing that may catch you off guard. When you do a find and include a to-one relation field, if the field is not nullable and cannot be ready by the current user, it'll result in the parent record being filtered out. For example:\n\n```\n// if `author` is not readable, the parent `Post` is excludedconst posts = await db.post.findMany({ include: { author: true }});\n```\n\nThe reason for this design choice is two-fold:\n\n1.  Type safety\n    \n    If we silently drop the `author` field, we'll break type-safety because the `author` field is not optional in its TS definition.\n    \n2.  Performance\n    \n    Prisma doesn't provide a direct way to include a non-nullable to-one relation conditionally. If we choose to drop the field, we'll have to do post-read processing, which may require additional database queries.\n    \n\n*   Bulk update and bulk delete methods behave as if the rows that don't satisfy the policies don't exist\n    \n    For example, `updateMany` only updates rows that satisfy the policies. Same for `deleteMany`. ZenStack enforces \"update\" and \"delete\" policies by injecting `where` clauses into the Prisma query.\n    \n*   Other write methods throw errors if the corresponding policies are not satisfied\n    \n    For example, `create` throws an error if the policies are not satisfied. When possible, ZenStack determines policy satisfaction by inspecting the input object of the Prisma query. Otherwise, it wraps the write into a transaction and checks the policies after the write is complete but before the transaction commits.\n    \n    If a nested write causes a policy violation, the top-level write will be rejected as a whole.\n    \n\nA write can imply a read\n\nHere's another fun fact about access policies. A `create`, `update` or `delete` call may succeed but still throw an error. Why?\n\nThe reason is that a write can imply a read. When you call `db.user.create`, the created result will be returned and subject to the \"read\" policy check. If it fails, an error will be thrown even though the write is persisted.\n\n### üõ†Ô∏è Giving It a Try[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/model-level#%EF%B8%8F-giving-it-a-try \"Direct link to üõ†Ô∏è Giving It a Try\")\n\nLet's continue working on our Todo app and add some access policies. Add the following rule to the `User` model:\n\nschema.zmodel\n\n```\nmodel User {    ...    @@allow('read', startsWith(email, 'joey'))}\n```\n\ninfo\n\n`startsWith` is an attribute function that checks whether a field starts with a given string. We'll cover functions in detail in [Expressions and Functions](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func).\n\nThen rerun generation and start the REPL:\n\n```\nnpx zenstack generatenpx zenstack repl\n```\n\nNow query users with the enhanced Prisma Client:\n\nThis time, we should get back a user. Our policy rule is working!\n\n```\n[  {    id: 1,    createdAt: 2023-11-07T21:37:22.506Z,    updatedAt: 2023-11-07T21:37:22.506Z,    email: 'joey@zenstack.dev',    name: 'Joey'  }]\n```\n\nYou'll still encounter an error if you try to create a user since we haven't added any \"create\" rule yet:\n\n```\ndb.user.create({ data: { email: 'ross@zenstack.dev', name: 'Ross' } });\n```\n\n```\ndenied by policy: user entities failed 'create' checkCode: P2004Meta: { reason: 'ACCESS_POLICY_VIOLATION' }\n```\n\n### Next[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/model-level#next \"Direct link to Next\")\n\nUsing only the direct fields of a model for access control isn't super useful. In the following chapters, you'll learn how to the requesting user's information and relation fields to write more advanced rules.",
  "title": "Model-Level Policies | ZenStack",
  "description": "The most frequently used access policies are those declared at the model level - written using @@allow and @@deny model-level attributes.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/plugins/access-policy",
  "markdown": "# @core/access-policy | ZenStack\n\nThe `@core/access-policy` plugin generates access policy guard objects from [policy rules](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/) (defined using `@@allow` and `@@deny` attributes).\n\nThis plugin is built-in to ZenStack and does not need to be installed separately.\n\nRuntime APIs like [`enhance`](https://zenstack.dev/docs/1.x/reference/runtime-api#enhance) and [`withPolicy`](https://zenstack.dev/docs/1.x/reference/runtime-api#withpolicy) depend on the output of this plugin and by default load it from the default output location. If you customize the output location, you need to load and pass it manually:\n\n```\nconst policy = require('./lib/zenstack/policy').default;const db = enhance(prisma, { user }, policy);\n```",
  "title": "@core/access-policy | ZenStack",
  "description": "Built-in plugin for generating access policy guards",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/relations",
  "markdown": "# Working With Relations | ZenStack\n\n```\nmodel Space {  ...  // require login  @@deny('all', auth() == null)  // everyone can create a space  @@allow('create', true)  // users in the space can read the space  @@allow('read', members?[user == auth()])  // space admin can update and delete  @@allow('update,delete', members?[user == auth() && role == 'ADMIN'])}model SpaceUser {    ...    // require login    @@deny('all', auth() == null)    // space owner and admins have full access    @@allow('all', space.owner == auth() || space.members?[user == auth() && role == 'ADMIN'])    // user can read members of spaces that he's a member of    @@allow('read', space.members?[user == auth()])}model User {    ...    // everyone can sign up    @@allow('create', true)    // full access by oneself    @@allow('all', auth() == this)    // can be read by users sharing any space    @@allow('read', spaces?[space.members?[user == auth()]])}model List {    ...    // require login    @@deny('all', auth() == null)    // can be read by space members if not private    @@allow('read', owner == auth() || (space.members?[user == auth()] && !private))    // when create, owner must be set to current user, and user must be in the space    @@allow('create,update', owner == auth() && space.members?[user == auth()])    // can be deleted by owner    @@allow('delete', owner == auth())}model Todo {    ...    // require login    @@deny('all', auth() == null)    // owner has full access    @@allow('all', list.owner == auth())    // space members have full access if the parent List is not private    @@allow('all', list.space.members?[user == auth()] && !list.private)}\n```",
  "title": "Working With Relations | ZenStack",
  "description": "In the previous chapters, we've learned how to write basic policy rules involving model fields and the current user. However, real-world applications usually have authorization requirements that need to access relations. Here're some examples:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc",
  "markdown": "# RPC API Handler | ZenStack\n\n## Introduction[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#introduction \"Direct link to Introduction\")\n\nThe RPC-style API handler exposes CRUD endpoints that fully mirror [PrismaClient's query API](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#model-queries). Consuming the APIs feels like making RPC calls to a PrismaClient then. The API handler is not meant to be used directly; instead, you should use it together with a [server adapter](https://zenstack.dev/docs/1.x/category/server-adapters) which handles the request and response API for a specific framework.\n\nIt can be created and used as the following:\n\n*   Next.js\n*   SvelteKit\n*   Nuxt\n\n/src/pages/api/model/\\[...path\\].ts\n\n```\nimport { NextRequestHandler } from '@zenstackhq/server/next';import RPCApiHandler from '@zenstackhq/server/api/rpc';import { getPrisma } from '../../lib/db';export default NextRequestHandler({     getPrisma,     handler: RPCApiHandler() // you can also omit it since `RPCApiHandler` is the default});\n```\n\n## Wire Format[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#wire-format \"Direct link to Wire Format\")\n\n### Input[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#input \"Direct link to Input\")\n\nFor endpoints using `GET` and `DELETE` Http verbs, the query body is serialized and passed as the `q` query parameter. E.g.:\n\n```\nGET /api/post/findMany?q=%7B%22where%22%3A%7B%22public%22%3Atrue%7D%7D\n```\n\n*   Endpoint: /api/post/findMany\n*   Query parameters: `q` -> `{ \"where\" : { \"public\": true } }`\n\nFor endpoints using other HTTP verbs, the query body is passed as `application/json` in the request body. E.g.:\n\n```\nPOST /api/post/create{ \"data\": { \"title\": \"Hello World\" } }\n```\n\n### Output[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#output \"Direct link to Output\")\n\nThe output shape conforms to the data structure returned by the corresponding PrismaClient API, wrapped into a `data` field. E.g.:\n\n```\nGET /api/post/findMany{    \"data\": [ { \"id\": 1, \"title\": \"Hello World\" } ]}\n```\n\n### Serialization[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#serialization \"Direct link to Serialization\")\n\nThis section explains the details about data serialization. If you're using generated hooks to consume the API, the generated code already automatically deals with serialization for you, and you don't need to do any further processing.\n\nZenStack uses [superjson](https://github.com/blitz-js/superjson) to serialize and deserialize data - including the `q` query parameter, the request body, and the response body. Superjson generates two parts during serialization:\n\n*   json:\n    \n    The JSON-compatible serialization result.\n    \n*   meta:\n    \n    The serialization metadata including information like field types that facilitates deserialization.\n    \n\nIf the data only involves simple data types, the serialization result is the same as regular `JSON.stringify`, and no `meta` part is generated. However, for complex data types (like `Bytes`, `Decimal`, etc.), a `meta` object will be generated, which needs to be carried along when sending the request, and will also be included in the response.\n\nThe following part explains how the `meta` information is included for different situations:\n\n*   The `q` query parameter\n    \n    If during superjson-serialization of the `q` parameter, a `meta` object is generated, it should be put into an object `{ serialization: meta }`, JSON-stringified, and included as an additional query parameter `meta`. For example, if you have a field named `bytes` of `Bytes` type, and you may want to query with a filter like `{ where: { bytes: Buffer.from([1,2,3]) } }`. Superjson-serializing the query object results in:\n    \n    ```\n    {    \"json\": { \"where\": { \"bytes\": \"AQID\" } }, // base-64 encoded bytes    \"meta\": { \"values\": { \"where.bytes\": [[\"custom\",\"Bytes\"]] } }}\n    ```\n    \n    Your query URL should look like:\n    \n    ```\n    GET /api/post/findMany?q={\"where\":{\"bytes\":\"AQID\"}}&meta={\"serialization\":{\"values\":{\"where.bytes\":[[\"custom\",\"Bytes\"]]}}}\n    ```\n    \n*   The request body\n    \n    If during superjson-serialization of the request body, a `meta` object is generated, it should be put into an object `{ serialization: meta }`, and included as an additional field `meta` field in the request body. For example, if you have a field named `bytes` of `Bytes` type, and you may want to create a record with a value like `{ data: { bytes: Buffer.from([1,2,3]) } }`. Superjson-serializing the request body results in:\n    \n    ```\n    {    \"json\": { \"bytes\": \"AQID\" }, // base-64 encoded bytes    \"meta\": { \"values\": { \"bytes\": [[ \"custom\", \"Bytes\" ]] } }}\n    ```\n    \n    Your request body should look like:\n    \n    ```\n    POST /api/post/create{     \"data\": { \"bytes\": \"AQID\" },    \"meta\": { \"serialization\": {\"values\": { \"bytes\": [[ \"custom\",\"Bytes\" ]] } } } }\n    ```\n    \n*   The response body\n    \n    If during superjson-serialization of the response body, a `meta` object is generated, it will be put into an object `{ serialization: meta }`, and included as an additional field `meta` field in the response body. For example, if you have a field named `bytes` of `Bytes` type, and a `findFirst` query returns `{ id: 1, bytes: Buffer.from([1,2,3]) }`. Superjson-serializing the request body results in:\n    \n    ```\n    {    \"json\": { \"id\": 1, \"bytes\":\"AQID\" }, // base-64 encoded bytes    \"meta\": { \"values\": { \"bytes\": [[ \"custom\", \"Bytes\" ]] } }}\n    ```\n    \n    Your response body will look like:\n    \n    ```\n    GET /api/post/findFirst{     \"data\": { \"id\": 1, \"bytes\": \"AQID\" },    \"meta\": { \"serialization\": {\"values\": { \"bytes\": [[ \"custom\",\"Bytes\"]] } } } }\n    ```\n    \n    You should use the meta.serialization field value to superjson-deserialize the response body.\n    \n\n#### Data Type Serialization Format[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#data-type-serialization-format \"Direct link to Data Type Serialization Format\")\n\n*   `DateTime`\n    \n    ISO 8601 string\n    \n*   `Bytes`\n    \n    Base64-encoded string\n    \n*   `BigInt`\n    \n    String representation\n    \n*   `Decimal`\n    \n    String representation\n    \n\n## Endpoints[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#endpoints \"Direct link to Endpoints\")\n\n*   **\\[model\\]/findMany**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/findUnique**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/findFirst**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/count**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/aggregate**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/groupBy**\n    \n    _Http method:_ `GET`\n    \n*   **\\[model\\]/create**\n    \n    _Http method:_ `POST`\n    \n*   **\\[model\\]/createMany**\n    \n    _Http method:_ `POST`\n    \n*   **\\[model\\]/update**\n    \n    _Http method:_ `PATCH` or `PUT`\n    \n*   **\\[model\\]/updateMany**\n    \n    _Http method:_ `PATCH` or `PUT`\n    \n*   **\\[model\\]/upsert**\n    \n    _Http method:_ `POST`\n    \n*   **\\[model\\]/delete**\n    \n    _Http method:_ `DELETE`\n    \n*   **\\[model\\]/deleteMany**\n    \n    _Http method:_ `DELETE`\n    \n\n## HTTP Status Code and Error Responses[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#http-status-code-and-error-responses \"Direct link to HTTP Status Code and Error Responses\")\n\n### Status code[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#status-code \"Direct link to Status code\")\n\nThe HTTP status code used by the endpoints follows the following rules:\n\n*   `create` and `createMany` use `201` for success. Other endpoints use `200`.\n*   `403` is used for to indicate the request is denied due to lack of permissions, usually caused by access policy violation.\n*   `400` is used for invalid requests, e.g., malformed request body.\n*   `500` is used for other unexpected errors.\n\n### Error response format[‚Äã](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#error-response-format \"Direct link to Error response format\")\n\n```\n{    // true to indicate the failure is due to a Prisma error    prisma?: boolean;    // true to indicate the failure is due to access policy violation    rejectedByPolicy?: boolean;    // original Prisma error code, available when `prisma` is true    code?: string;    // error message    message: string;    // extra reason about why a failure happened (e.g., 'RESULT_NOT_READABLE' indicates    // a mutation succeeded but the result cannot be read back due to access policy)    reason?: string;}\n```",
  "title": "RPC API Handler | ZenStack",
  "description": "RPC-style API handler that fully mirrors PrismaClient's query API",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/post-update",
  "markdown": "# Post-Update Checks | ZenStack\n\nAmong the \"create\", \"read\", \"update\", and \"delete\" operations, \"update\" is a special one, because its data has two states: pre-update and post-update. When you write a policy rule for \"update\", by default, you're checking against the pre-update state. But sometimes, you may want to inspect the post-update state. For example, you may wish to prevent a user from setting a \"revision\" to a smaller value than the current one.\n\nTo define a post-update rule, you use the `future()` function to access the post-update state. Here's an example:\n\n```\nmodel Post {    ...    revision Int    @@allow('update', future().revision > revision)}\n```\n\nAlthough there are two kinds of update rules, ZenStack uses a single \"update\" operation to represent both pre-update and post-update checks. The only difference is that you use the `future()` function to access the post-update state. What happens when pre-update and post-update rules are mixed? For example:\n\n```\nmodel Post {    ...    published Boolean    revision Int    @@allow('update', !published && future().revision > revision)}\n```\n\nWhen ZenStack detects that a model has \"update\" rules involving `future()` calls, it'll postpone the evaluation of all \"update\" rules of that model to the \"post-update\" stage. It analyzes what fields' pre-update state is needed and collects them before the update happens.\n\nOne of the use cases of post-update rules is to prevent modification of specific fields. For example, in our Todo app, we allow `List`'s owner to update its fields, but we shouldn't allow its owner to be changed. We can use a post-update rule to enforce this:\n\n```\nmodel List {    ...    @@deny('update', future().owner != owner)}\n```\n\nIt works, but it feels a bit awkward for such a common use case. In the next chapter, we'll learn a better way to handle this.",
  "title": "Post-Update Checks | ZenStack",
  "description": "Among the \"create\", \"read\", \"update\", and \"delete\" operations, \"update\" is a special one, because its data has two states: pre-update and post-update. When you write a policy rule for \"update\", by default, you're checking against the pre-update state. But sometimes, you may want to inspect the post-update state. For example, you may wish to prevent a user from setting a \"revision\" to a smaller value than the current one.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/cli",
  "markdown": "# ZenStack CLI | ZenStack\n\nThe `zenstack` CLI is the primary tool for using ZenStack in a project. The CLI is intentionally designed to have similar commands to the `prisma` CLI.\n\nIn this chapter, we'll use the CLI to scaffold our Todo sample project. You can find the complete documentation in the [CLI reference guide](https://zenstack.dev/docs/1.x/reference/cli).\n\n### üõ†Ô∏è Creating Our Sample Project[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/cli#%EF%B8%8F-creating-our-sample-project \"Direct link to üõ†Ô∏è Creating Our Sample Project\")\n\n#### 1\\. Initializing a Project[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/cli#1-initializing-a-project \"Direct link to 1. Initializing a Project\")\n\nYou can initialize an existing TypeScript project using the `zenstack init` command. To save some typing, we'll first use the \"try-prisma\" utility to create a simple TypeScript CLI project.\n\n```\nnpx try-prisma@latest -p . -n my-todo-app -t typescript/script --install npmcd my-todo-app\n```\n\nThen initialize the project for ZenStack:\n\nThe \"init\" command does the following things for you:\n\n1.  Install Prisma if it's not already installed.\n2.  Install the `zenstack` CLI package as a dev dependency.\n3.  Install the `@zenstackhq/runtime` package - used for enhancing `PrismaClient` at the runtime.\n4.  Copy the `prisma/schema.prisma` file to `schema.zmodel` if it exists; otherwise, create a new template `schema.zmodel` file.\n\nYou can always manually complete the steps above if you have a special project setup that the \"init\" command doesn't work with.\n\nAfter the initialization, please remember that you should edit the `schema.zmodel` moving forward. The `prisma/schema.prisma` file will be automatically regenerated when you run `zenstack generate`.\n\n#### 2\\. Preparing The Schema[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/cli#2-preparing-the-schema \"Direct link to 2. Preparing The Schema\")\n\nReplace the content of `schema.zmodel` with the following:\n\nschema.zmodel\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}generator js {  provider = \"prisma-client-js\"}// where users can collaborate on todo lists and itemsmodel Space {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  name String  slug String @unique  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)  ownerId Int  members SpaceUser[]  lists List[]}// a join table for many-to-many relation between `Space` and `User`model SpaceUser {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  space Space @relation(fields: [spaceId], references: [id], onDelete: Cascade)  spaceId Int  user User @relation(fields: [userId], references: [id], onDelete: Cascade)  userId Int  role String @default(\"USER\")  @@unique([userId, spaceId])}// usermodel User {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  email String @unique  name String?  spaces SpaceUser[] // user's space membership  lists List[]  todos Todo[]  ownedSpaces Space[] // spaces owned by the user}// todo listmodel List {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  space Space @relation(fields: [spaceId], references: [id], onDelete: Cascade)  spaceId Int  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)  ownerId Int  title String  private Boolean @default(false)  todos Todo[]}// todo itemmodel Todo {  id Int @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)  ownerId Int  list List @relation(fields: [listId], references: [id], onDelete: Cascade)  listId Int  title String  completedAt DateTime?}\n```\n\ninfo\n\nOur sample project uses a SQLite database. You can use any other database supported by Prisma. Please refer to the [Prisma docs](https://www.prisma.io/docs/concepts/database-connectors) for more details.\n\nTake some time to familiarize yourself with the entities and their relations.\n\n![Todo App ERD](https://zenstack.dev/assets/images/todo-app-erd-ae0258b6364af45e83a87e5ba6895579.svg)\n\n#### 3\\. Generating Artifacts[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/cli#3-generating-artifacts \"Direct link to 3. Generating Artifacts\")\n\nThe CLI command you'll most often use is `zenstack generate`. It runs plugins (including the built-in ones that are automatically enabled and the ones you explicitly put into ZModel) to generate various artifacts.\n\nThe most important artifact is the Prisma schema. It's generated into the `prisma/schema.prisma` file by default. The command also automatically runs `prisma generate` to regenerate the Prisma Client.\n\nYou should see output like the following in your terminal:\n\n```\n‚åõÔ∏è ZenStack CLI vx.y.z, running plugins‚úî Running plugin Prisma‚úî Running plugin Model Metadata‚úî Running plugin Access Policyüëª All plugins completed successfully!Don't forget to restart your dev server to let the changes take effect.\n```\n\nA bunch of plugins are run. When it is complete, the `prisma/schema.prisma` file should be updated to contain the new models we added. You can also use the models in your TS code now since the Prisma Client code has also been regenerated.\n\nFinally, push the schema to the database:\n\n#### 4\\. Seeding The Database[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/cli#4-seeding-the-database \"Direct link to 4. Seeding The Database\")\n\nLet's create a seed script to populate some test data into our database. Create a new file `prisma/seed.ts` with the following content:\n\nprisma/seed.ts\n\n```\nimport { PrismaClient } from '@prisma/client';const prisma = new PrismaClient();async function main() {    // clean up    await prisma.user.deleteMany();    await prisma.space.deleteMany();    const joey = await prisma.user.create({        data: {            email: 'joey@zenstack.dev',            name: 'Joey'        }    });    console.log('User created:', joey);    const rachel = await prisma.user.create({        data: {            email: 'rachel@zenstack.dev',            name: 'Rachel'        }    });    console.log('User created:', rachel);    const centralPerk = await prisma.space.create({        data: {            name: 'Central Perk',            slug: 'central-perk',            owner: { connect: { id: rachel.id } },            members: {                create: [                    {                        user: { connect: { id: joey.id } },                        role: 'USER'                    },                    {                        user: { connect: { id: rachel.id } },                        role: 'ADMIN'                    }                ]            }        }    });    console.log('Space created:', centralPerk);    const rachelPersonal = await prisma.space.create({        data: {            name: \"Rachel's Personal Space\",            slug: 'rachel',            owner: { connect: { id: rachel.id } },            members: {                create: [                    {                        user: { connect: { id: rachel.id } },                        role: 'ADMIN'                    }                ]            }        }    });    console.log('Space created:', rachelPersonal);}main()    .then(async () => {        await prisma.$disconnect();    })    .catch(async (e) => {        console.error(e);        await prisma.$disconnect();        process.exit(1);    });\n```\n\nThen add the seed script into \"package.json\":\n\npackage.json\n\n```\n{    ...    \"prisma\": {        \"seed\": \"ts-node prisma/seed.ts\"    }}\n```\n\nFinally, run the seed command to load the data into the database:\n\n```\nRunning seed command `ts-node prisma/seed.ts` ...User created: {  id: 1,  createdAt: 2023-11-07T21:37:22.506Z,  updatedAt: 2023-11-07T21:37:22.506Z,  email: 'joey@zenstack.dev',  name: 'Joey'}User created: {  id: 2,  createdAt: 2023-11-07T21:37:22.509Z,  updatedAt: 2023-11-07T21:37:22.509Z,  email: 'rachel@zenstack.dev',  name: null}Space created: {  id: 1,  createdAt: 2023-11-07T21:37:22.510Z,  updatedAt: 2023-11-07T21:37:22.510Z,  name: 'Central Perk',  slug: 'central-perk'}Space created: {  id: 2,  createdAt: 2023-11-07T21:37:22.512Z,  updatedAt: 2023-11-07T21:37:22.512Z,  name: \"Rachel's Personal Space\",  slug: 'rachel'}üå±  The seed command has been executed.\n```\n\n#### 5\\. Querying Data With REPL[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/cli#5-querying-data-with-repl \"Direct link to 5. Querying Data With REPL\")\n\nZenStack CLI comes with a convenient REPL mode that you can use to query data interactively. We'll use it to demonstrate ZenStack's features throughout the guide. Let's try a few commands here:\n\nEnter the REPL mode:\n\nThe REPL provides a global `prisma` instance that you can use directly. Execute a few queries (the REPL automatically awaits the result Promises):\n\n```\n{  id: 1,  createdAt: 2023-11-07T21:37:22.506Z,  updatedAt: 2023-11-07T21:37:22.506Z,  email: 'joey@zenstack.dev',  name: 'Joey'}\n```\n\n```\nprisma.space.findFirst({ include: { members: true } })\n```\n\n```\n{  id: 1,  createdAt: 2023-11-07T21:37:22.510Z,  updatedAt: 2023-11-07T21:37:22.510Z,  name: 'Central Perk',  slug: 'central-perk',  members: [    {      id: 1,      createdAt: 2023-11-07T21:37:22.510Z,      updatedAt: 2023-11-07T21:37:22.510Z,      spaceId: 1,      userId: 2,      role: 'ADMIN'    },    {      id: 2,      createdAt: 2023-11-07T21:37:22.510Z,      updatedAt: 2023-11-07T21:37:22.510Z,      spaceId: 1,      userId: 1,      role: 'USER'    }  ]}\n```\n\nThe REPL also provides a `db` variable for querying data with access control. We'll get back to it in [chapter 4](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy).\n\nYou can exit the REPL with the `.exit` command.\n\n#### 6\\. Listing Installed ZenStack Packages[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/cli#6-listing-installed-zenstack-packages \"Direct link to 6. Listing Installed ZenStack Packages\")\n\nZenStack provides multiple npm packages that implement either plugins or runtime functionalities. The `zenstack` and `@zenstackhq/runtime` packages are almost always needed. The other packages are optional and can be installed based on your needs.\n\nWhen you upgrade ZenStack, it's important to keep all package versions in sync to avoid unexpected results. The `zenstack info` command can help you list all installed ZenStack packages and their versions. It also checks and prompts if there are newer versions available.\n\nTry running it in our project:\n\n```\nInstalled ZenStack Packages:    zenstack                    x.y.z    @zenstackhq/runtime         x.y.z‚úî Checking npm registryYou are using the latest version of Zenstack.\n```\n\n### ZenStack CLI & Prisma CLI[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/cli#zenstack-cli--prisma-cli \"Direct link to ZenStack CLI & Prisma CLI\")\n\nThe ZenStack CLI is not meant for replacing the Prisma CLI. After `zenstack generate` generates the Prisma schema, you can use the Prisma CLI as you normally do to complete tasks like:\n\n*   Creating migration records with `prisma migrate dev`\n*   Pushing schema changes to the db with `prima db push`\n*   Launching Prisma Studio with `prisma studio`\n*   ...\n\nThe Prisma development workflow that you're already familiar with should work seamlessly with ZenStack. See [here](https://zenstack.dev/docs/1.x/guides/dev-workflow) for a detailed explanation of the development workflow.\n\n![ZModel Generation](https://zenstack.dev/img/intro/zmodel-generation-light.png)![ZModel Generation](https://zenstack.dev/img/intro/zmodel-generation-dark.png)",
  "title": "ZenStack CLI | ZenStack",
  "description": "The zenstack CLI is the primary tool for using ZenStack in a project. The CLI is intentionally designed to have similar commands to the prisma CLI.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/other-enhancements",
  "markdown": "# Other Enhancements | ZenStack\n\nBesides core enhancements like access policies, ZenStack also provides a few other lightweight enhancements targeting specific use cases.\n\n### Hashing Passwords[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/other-enhancements#hashing-passwords \"Direct link to Hashing Passwords\")\n\nWhen using a credential-based authentication system, it's important never to store the password in plain text. ZenStack provides a simple way to automatically hash passwords before storing them in the database. To enable it, simply mark the password field with the `@password` attribute.\n\n```\nmodel User {    id Int @id @default(autoincrement())    email String @unique    password String? @password}\n```\n\nUnder the hood, ZenStack uses [bcryptjs](https://github.com/dcodeIO/bcrypt.js/tree/master) to generate a hash.\n\nSee [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#password) for more details about the `@password` attribute.\n\n#### üõ†Ô∏è Adding User Password[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/other-enhancements#%EF%B8%8F-adding-user-password \"Direct link to üõ†Ô∏è Adding User Password\")\n\nLet's add a `password` field to our `User` model, so we can implement credential-based authentication in the future.\n\n```\nmodel User {    ...    password String? @password}\n```\n\nRerun generation, push database schema, and start REPL:\n\n```\nnpx zenstack generatenpx prisma db pushnpx zenstack repl\n```\n\nTry to create a new user with a password:\n\n```\ndb.user.create({ data: { email: 'ross@zenstack.dev', password: 'abc123' }})\n```\n\nYou may see a surprising error:\n\n```\ndenied by policy: user entities failed 'create' check, result is not allowed to be read backCode: P2004Meta: { reason: 'RESULT_NOT_READABLE' }\n```\n\nRecall that in previous chapters, we mentioned that \"write can imply read\". In this case, the `create` operation returns the created user object, which is subject to the \"read\" policy check. Since we're using an anonymous context, the read operation is denied.\n\nHowever, if you use the raw Prisma Client to query, you can see the user is created, and his password is hashed:\n\n```\nprisma.user.findFirst({ orderBy: { id: 'desc' } });\n```\n\n```\n{  id: 3,  createdAt: 2023-11-09T05:53:28.793Z,  updatedAt: 2023-11-09T05:53:28.793Z,  email: 'ross@zenstack.dev',  password: '$2a$12$jYdALEg7gtIi.tc9JmFKuOG3X//0Cdo801xYotdtUw5pXV6Ahb.2m',  name: null}\n```\n\ninfo\n\nThis \"result not readable\" issue is often not a problem in practice, since a user with write privilege can also usually read. Sign-up flow is a special case where a user transitions from anonymous to authenticated. You can catch and ignore the error in the sign-up part. After the user logs in, you can use his identity for the subsequent operations.\n\nOr alternatively, you can use the raw Prisma Client in the authentication part of your system.\n\n### Omitting Fields[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/other-enhancements#omitting-fields \"Direct link to Omitting Fields\")\n\nSome database fields can be sensitive and should not be exposed to the client. Password is a good example (even when it's hashed). You can use the `@omit` attribute to mark a field, and it'll be automatically omitted when queried from an enhanced Prisma Client.\n\n```\nmodel User {    ...    password String? @password @omit}\n```\n\ninfo\n\nYou can use a field-level access policy to achieve the same goal:\n\n```\nmodel User {    ...    password String? @password @allow('read', false)}\n```\n\nHowever, using `@omit` is more appropriate since conceptually omitting sensitive field is not a permission issue.\n\n#### üõ†Ô∏è Omitting Password Field[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/other-enhancements#%EF%B8%8F-omitting-password-field \"Direct link to üõ†Ô∏è Omitting Password Field\")\n\nLet's mark the `password` field with `@omit`:\n\n```\nmodel User {    ...    password String? @password @omit}\n```\n\nRerun generation, push database schema, and start REPL:\n\n```\nnpx zenstack generatenpx prisma db pushnpx zenstack repl\n```\n\nQuery users, and you'll find the `password` field is omitted:\n\n```\n.auth { id: 1 }db.user.findFirst();\n```\n\n```\n{  id: 1,  createdAt: 2023-11-07T21:37:22.506Z,  updatedAt: 2023-11-07T21:37:22.506Z,  email: 'joey@zenstack.dev',  name: 'Joey'}\n```",
  "title": "Other Enhancements | ZenStack",
  "description": "Besides core enhancements like access policies, ZenStack also provides a few other lightweight enhancements targeting specific use cases.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/data-validation",
  "markdown": "# Data Validation | ZenStack\n\nVersion: 1.x\n\n### Overview[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/data-validation#overview \"Direct link to Overview\")\n\nBesides permission control, an application often also has a notion of data validity: what form of data is allowed to be stored in the database? Database schema provides a preliminary mechanism for defining that, but many rules still need to be enforced outside of it. Here are a few quick examples:\n\n*   `email` field must be a valid email address.\n*   `password` field must be at least 8 characters long.\n*   A post's `slug` must only contain letters, numbers, and dashes.\n*   `price` field must be a positive number.\n*   `password` field is only allowed to have value if `identityProvider` field is set to `credentials`.\n\nTraditionally, developers either write imperative code to validate data or use a declarative validation library like [Zod](https://zod.dev/). ZenStack allows you to define such rules right inside the ZModel schema and automatically enforces them with the enhanced Prisma Client. When validation rules are violated during a \"create\" or \"update\" operation, the operation is rejected with an error.\n\ninfo\n\nData validation and access policy may have some similarities, but there are some fundamental differences:\n\n1.  Access policies are usually defined regarding the current user, while validation rules are defined against the data itself.\n2.  Access policies are mostly evaluated on the database side (through injection into Prisma queries), while data validation is evaluated entirely on the application side.\n3.  Access policies govern CRUD operations, while data validation only covers \"create\" and \"update\" actions.\n\n### Field-Level Validation[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/data-validation#field-level-validation \"Direct link to Field-Level Validation\")\n\nZenStack provides a set of field-level attributes for defining validation rules. You can find the full list of such attributes [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#field-level-validation-attributes). Here are a few usage examples:\n\n```\nmodel User {    id Int @id    email String @unique @email @endsWith('@zenstack.dev')    imgUrl String? @url    password String @length(min: 8, max: 32)    age Int @gt(0) @lt(120)}\n```\n\nAll validation attributes also accept an extra parameter `message` for specifying a custom error message. For example:\n\n```\nmodel User {    ...    email String @unique @email('must be a valid email')    password String @length(min: 8, max: 32, message: 'must be between 8 and 32 characters long')}\n```\n\n### Model-Level Validation[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/data-validation#model-level-validation \"Direct link to Model-Level Validation\")\n\nYou can use the model-level `@@validate` attribute to define validation rules that involve multiple fields. A set of helper functions are provided for building complex validation expressions. You can find the full list of such functions [here](https://zenstack.dev/docs/1.x/reference/zmodel-language#model-level-validation-attributes). Here's an example:\n\n```\nmodel User {    id String @id    email String? @unique    activated Boolean @default(false)    @@validate(!activated || email != null, \"activated user must have an email\")}\n```\n\n### üõ†Ô∏è Adding Data Validation[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/data-validation#%EF%B8%8F-adding-data-validation \"Direct link to üõ†Ô∏è Adding Data Validation\")\n\nWe can use data validation to improve our app's robustness in many places. Two such examples are shown here:\n\n1.  Make sure `User`'s email is a valid email address.\n    \n    ```\n    model User {    ...    email String @unique @email}\n    ```\n    \n2.  Limit the format of `Space`'s slug.\n    \n    ```\n     model Space {      ...      slug String @unique @regex('^[0-9a-zA-Z_\\-]{4,16}$') }\n    ```\n    \n\nRerun generation and start REPL:\n\n```\nnpx zenstack generatenpx zenstack repl\n```\n\nTry to create a user with an invalid email address:\n\n```\ndb.user.create({ data: { email: 'xyz.abc' } })\n```\n\nObserve the validation error:\n\n```\ndenied by policy: user entities failed 'create' check, input failed validation: Validation error:Invalid email at \"email\"Code: P2004Meta: {  reason: 'DATA_VALIDATION_VIOLATION',  zodErrors: ZodError: [...]}\n```\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Data Validation | ZenStack",
  "description": "Overview",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/authn-authz",
  "markdown": "# Authentication and Authorization | ZenStack\n\nAuthentication and authorization are the two most important concepts for designing a secure application. To set up a solid knowledge foundation, let's first clarify what they mean respectively in the context of ZenStack.\n\n### Authentication[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/authn-authz#authentication \"Direct link to Authentication\")\n\nAuthentication is the process of verifying the identity of a user. It can be a simple email and password verification or an OAuth workflow that interacts with a third-party identity provider.\n\nZenStack is not an authentication solution, but it usually depends on one to work. In a real-world application, access control rules usually need to leverage the information of the requesting user. An authentication solution provides the user information.\n\nZenStack is agnostic to the authentication solution you use. The authentication system only needs to be able to provide an object that represents the current user. ZenStack uses it to create a user-scoped enhanced Prisma Client that enforces access policies.\n\nWe'll cover this topic in more detail in the next chapter.\n\n#### Popular Authentication Solutions[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/authn-authz#popular-authentication-solutions \"Direct link to Popular Authentication Solutions\")\n\nHere are some popular authentication solutions in the Javascript/Typescript ecosystem:\n\n*   [Auth.js (formerly NextAuth)](https://authjs.dev/)\n*   [Clerk](https://clerk.com/)\n*   [Supabase Auth](https://supabase.com/docs/guides/auth)\n*   [Auth0](https://auth0.com/)\n*   [Firebase Authentication](https://firebase.google.com/docs/auth)\n*   [Lucia](https://lucia-auth.com/)\n\nYou can find how to integrate some of these solutions in the [Integration With Authentication](https://zenstack.dev/docs/1.x/category/integrating-with-authentication) guides.\n\nAuthorization is the process of determining whether a user has permission to perform a specific action. ZenStack's core part is an authorization solution that directly couples with the database. It controls what CRUD actions a user can perform on a table or a field.\n\nSome commonly used patterns for modeling authorization are listed below (with increasing flexibility and complexity):\n\n1.  Access Control List (ACL)\n    \n    Users are directly assigned with permissions. For example, a user can be given `read` permission on the `Post` table.\n    \n2.  Role-Based Access Control (RBAC)\n    \n    Users are assigned roles, and roles are configured with permissions. For example, a user can be assigned an `admin` role, which is granted with full permission on the `Post` table.\n    \n3.  Attribute-Based Access Control (ABAC)\n    \n    Permissions are defined over attributes of the user and the resource. For example, a user can be assigned with 'read' permission to a `Post` row if the `Post` is published and the user is a subscribed member.\n    \n4.  Relation-Based Access Control (ReBAC)\n    \n    Permissions are defined by the presence of relationships between the subjects and resources. For example, a user can edit a `Post` if the user has an \"edit\" relationship with the `Post`.\n    \n\nA complex application often needs to use a combination of these patterns. ZenStack's access policy system is designed to be easy to use yet have excellent flexibility to tackle these challenges.",
  "title": "Authentication and Authorization | ZenStack",
  "description": "Authentication and authorization are the two most important concepts for designing a secure application. To set up a solid knowledge foundation, let's first clarify what they mean respectively in the context of ZenStack.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel",
  "markdown": "# ZModel Language | ZenStack\n\nThe first thing that ZenStack may surprise you is that, unlike other Prisma tools, we created a new schema language called _ZModel_. It's a superset of the Prisma Schema Language (PSL) with syntax elements to support additional features. The `zenstack` CLI takes a ZModel file as input and generates a Prisma Schema file out of it - which in turn can be fed to the standard `prisma` CLI for generating a Prisma Client or migrating the database.\n\nWhy did we invent a new schema language?\n\n### Why ZModel?[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#why-zmodel \"Direct link to Why ZModel?\")\n\n#### Custom Attributes[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#custom-attributes \"Direct link to Custom Attributes\")\n\nWhile Prisma Schema Language provides a terse and intuitive way to define data models, it has a major extensibility limitation: you can't add custom attributes. Prisma provides a set of pre-defined attributes to control detailed aspects of your tables and fields, but you're stuck when you need custom ones for your special modeling purposes. Traditionally, Prisma community tools have been hacking around this limitation by smuggling custom information in code comments, like the following example with [TypeGraphQL Prisma](https://prisma.typegraphql.com/):\n\n```\nmodel User {    id Int @default(autoincrement()) @id    email String @unique    /// @TypeGraphQL.omit(output: true, input: true)    password String}\n```\n\nIt works, but it's ugly and gets no protection from the compiler. The model can become messy if it's littered with such hacks everywhere. One of the biggest reasons for introducing the ZModel language is to systematically remove this obstacle so that we have a solid foundation for adding custom semantics into the schema down the road.\n\nHere's a quick example of the custom `@password` and `@omit` attributes ZModel added for automatically hashing passwords upon saving and omitting them from query results:\n\n```\nmodel User {    id Int @default(autoincrement()) @id    email String @unique    password String @omit @password}\n```\n\nThe access policies and data validation rules are also implemented with custom attributes. Don't worry. We'll cover them in detail in the following chapters.\n\n#### Other Language Features[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#other-language-features \"Direct link to Other Language Features\")\n\nA custom schema language also allows us to add new language features besides custom attributes. For example:\n\n1.  The `import` syntax for breaking down a large schema into multiple files\n2.  The `extends` syntax for inheriting fields from a base model\n\nHere's an example of how to use them to manage large schemas more effectively:\n\nbase.zmodel\n\n```\nabstract model Base {    id Int @id @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)    // author has full access    @@allow('all', auth() != null && published)}\n```\n\nschema.zmodel\n\n```\nimport \"base\"model User extends Base {    name String}model Post extends Base {    title String    content String?    viewCount Int @default(0)    comment Comment[]}model Comment extends Base {    content String    post Post @relation(fields: [postId], references: [id])    postId Int}\n```\n\n#### A Better Plugin System[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#a-better-plugin-system \"Direct link to A Better Plugin System\")\n\nPrisma allows you to write custom generators. However, the generator development API is undocumented and difficult to understand. ZenStack provides a plugin system that enables you to generate custom artifacts with a simple API and object model. In fact, almost all the features of ZenStack itself are implemented as plugins. [Part II](https://zenstack.dev/docs/1.x/the-complete-guide/part2) of this guide is dedicated to covering the plugin system.\n\n### ZModel Structure[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#zmodel-structure \"Direct link to ZModel Structure\")\n\nThe ZModel language is a superset of Prisma Schema Language (PSL). All Prisma schema syntaxes are valid in ZModel. A ZModel can contain the following declarations.\n\n#### Imports[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#imports \"Direct link to Imports\")\n\nThe `import` syntax is an extension to PSL. You can use it to break down a large schema into multiple files.\n\nschema.zmodel\n\n```\nimport \"user\"import \"post\"\n```\n\nuser.zmodel\n\n```\nmodel User {    id Int @id @default(autoincrement())    email String @unique    posts Post[]}\n```\n\npost.zmodel\n\n```\nmodel Post {    id Int @id @default(autoincrement())    title String    author User @relation(fields: [authorId], references: [id])    authorId Int}\n```\n\nWhen the `zenstack` CLI compiles an input schema, it merges the content of all imported files into a single schema before further processing.\n\n#### Data Source[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#data-source \"Direct link to Data Source\")\n\nThe `datasource` declaration of ZModel is exactly the same as PSL. ZenStack passes it to the generated Prisma schema without modification.\n\n```\ndatasource db {    provider = \"postgresql\"    url      = env(\"DATABASE_URL\")}\n```\n\n#### Prisma Generators[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#prisma-generators \"Direct link to Prisma Generators\")\n\nThe `generator` declarations of ZModel are exactly the same as PSL. ZenStack passes it to the generated Prisma schema without modification.\n\n```\ngenerator client {    provider = \"prisma-client-js\"}\n```\n\n#### Plugins[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#plugins \"Direct link to Plugins\")\n\nPlugins are the new extensibility mechanism provided by ZModel. Its syntax is similar to generators but with the `plugin` declaration keyword. Here's an example for generating tRPC CRUD routers:\n\n```\nplugin trpc {    provider = \"@zenstackhq/trpc\"    output   = \"src/generated\"}\n```\n\n[Part II](https://zenstack.dev/docs/1.x/the-complete-guide/part2) of this guide will cover the plugin system in detail.\n\n#### Models[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#models \"Direct link to Models\")\n\nThe `model` declaration of ZModel is exactly the same as PSL, except for the new set of attributes ZenStack added.\n\n```\nmodel User {    id Int @id @default(autoincrement())    // during create and update, ZenStack validates the field is a valid email address    email String @unique @email    // the field is automatically hashed upon saving, and omitted from query results    password String @omit @password    // access policy: open to sign up    @@allow('create', true)    // access policy: the user has full access to self    @@allow('all', auth() == this)}\n```\n\n### IDE Support[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#ide-support \"Direct link to IDE Support\")\n\nZenStack comes with a [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) and a [JetBrains IDE plugin](https://plugins.jetbrains.com/plugin/23397-zenstack-language-tools). You can find more information about IDE support [here](https://zenstack.dev/docs/1.x/guides/ide).\n\n### Full Documentation[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#full-documentation \"Direct link to Full Documentation\")\n\nCheck out the [ZModel Language](https://zenstack.dev/docs/1.x/reference/zmodel-language) reference documentation for a complete language description.",
  "title": "ZModel Language | ZenStack",
  "description": "The first thing that ZenStack may surprise you is that, unlike other Prisma tools, we created a new schema language called ZModel. It's a superset of the Prisma Schema Language (PSL) with syntax elements to support additional features. The zenstack CLI takes a ZModel file as input and generates a Prisma Schema file out of it - which in turn can be fed to the standard prisma CLI for generating a Prisma Client or migrating the database.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/conclusion",
  "markdown": "# Conclusion | ZenStack\n\nIn this part of the guide, we've focused on the core layer of ZenStack - an enhanced Prisma Client. The enhanced Prisma Client essentially turns the ORM into a fully secured data access layer, enabling the upper layer features like the automatic CRUD APIs and the generation of frontend data query libraries.\n\nThe design choice of enhancing Prisma Client makes ZenStack framework-agnostic. It can be used wherever Prisma is used - a CLI application, a Node.js backend, or a full-stack application - as a non-intrusive drop-in replacement.\n\nAs you have seen, the ZModel language provides great flexibility in modeling the authorization aspects of your application. If you want to learn how commonly used patterns like RBAC, ABAC, etc., can be modeled in ZModel, this blog post can be a good reference: [Modeling Authorization in Prisma - No Theory, Just Code](https://zenstack.dev/blog/model-authz).\n\nThe completed sample project up to the end of this part can be found in the \"part1\" branch of the [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/part1) repo. You can clone it and check out to that branch with the following command:\n\n```\ngit clone --branch v1-part1 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```",
  "title": "Conclusion | ZenStack",
  "description": "In this part of the guide, we've focused on the core layer of ZenStack - an enhanced Prisma Client. The enhanced Prisma Client essentially turns the ORM into a fully secured data access layer, enabling the upper layer features like the automatic CRUD APIs and the generation of frontend data query libraries.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func",
  "markdown": "# Expressions and Functions | ZenStack\n\nIn the previous chapters, we've informally introduced how policy expressions are written. This chapter will list all expression types supported and functions that help you construct complex rules.\n\n### Expressions[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#expressions \"Direct link to Expressions\")\n\n#### Literal Expression[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#literal-expression \"Direct link to Literal Expression\")\n\n*   String: both single or double quoted, `\"foo\"`, `'bar'`.\n*   Number: `123`, `3.14`.\n*   Boolean: `true`, `false`.\n*   Null: `null`.\n\n#### Array Expression[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#array-expression \"Direct link to Array Expression\")\n\nArray of expressions. E.g, `[1, 2, 3]`, `['foo', 'bar']`, `[ADMIN, MEMBER]`.\n\n#### Reference Expression[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#reference-expression \"Direct link to Reference Expression\")\n\nUsed to reference a model field or an enum field.\n\n```\nmodel Post {    ...    published Boolean    @@allow('read', published) // `published` is a Reference Expression}\n```\n\n#### This Expression[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#this-expression \"Direct link to This Expression\")\n\nRepresented by `this` keyword. Used to address the value of the containing model.\n\n```\nmodel User {    id Int @id    @@allow('all', auth() == this) // `this` is a This Expression}\n```\n\n#### Member Access Expression[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#member-access-expression \"Direct link to Member Access Expression\")\n\nUsed to access a field from an expression.\n\n```\nmodel Post {    id Int @id    published Boolean    @@allow('read', auth().role == 'READ') // `auth().role` is a Member Access Expression}\n```\n\n#### Invocation Expression[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#invocation-expression \"Direct link to Invocation Expression\")\n\nUsed to invoke a function. E.g, `auth()` is an Invocation Expression.\n\n#### Unary Expression[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#unary-expression \"Direct link to Unary Expression\")\n\n*   `!` Logical NOT, operand must be boolean\n\n#### Binary Expression[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#binary-expression \"Direct link to Binary Expression\")\n\n*   `==` Equality, translated to id comparison when model types are compared\n*   `!=` Inequality, translated to id comparison when model types are compared\n*   `>` Greater than, both operands must be number\n*   `>=` Greater than or equal to, both operands must be number\n*   `<` Less than, both operands must be number\n*   `<=` Less than or equal to, both operands must be number\n*   `&&` Logical AND, both operands must be boolean\n*   `||` Logical OR, both operands must be boolean\n*   `in` Membership, with the left operand being an array and the right operand being a literal or a reference to an enum field\n\n### Functions[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#functions \"Direct link to Functions\")\n\nYou can find the detailed signature of each function in the [Predefined attribute functions](https://zenstack.dev/docs/1.x/reference/zmodel-language#predefined-attribute-functions) document.\n\n#### auth()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#auth \"Direct link to auth()\")\n\nReturns the current user. The function call has the type of the [auth model](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#auth-model).\n\n#### now()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#now \"Direct link to now()\")\n\nReturns the current timestamp. The function call is typed `DateTime`.\n\n```\n@@allow('read', future().updatedAt < now())\n```\n\n#### future()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#future \"Direct link to future()\")\n\nRepresents the post-update model value. You'll learn more about it in the [next chapter](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/post-update).\n\n#### contains()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#contains \"Direct link to contains()\")\n\nReturns if a string field contains a value.\n\n```\nmodel Post {    id Int @id    title String    @@allow('read', contains(title, 'zenstack'))}\n```\n\nThe comparison is case-sensitive by default. You can also pass a third argument to make the comparison case insensitive:\n\n```\n@@allow('read', contains(title, 'zenstack', true))\n```\n\n#### search()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#search \"Direct link to search()\")\n\nReturns if a string field matches the search condition with [full-text-search](https://www.prisma.io/docs/concepts/components/prisma-client/full-text-search). Need to enable Prisma's \"fullTextSearch\" preview feature to use.\n\n```\n@@allow('read', search(title, 'zenstack is awesome'))\n```\n\n#### startsWith()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#startswith \"Direct link to startsWith()\")\n\nReturns if a string field starts with a value.\n\n```\n@@allow('read', startsWith(title, 'zenstack'))\n```\n\n#### endsWith()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#endswith \"Direct link to endsWith()\")\n\nReturns if a string field ends with a value.\n\n```\n@@allow('read', endsWith(title, 'zenstack'))\n```\n\n#### has()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#has \"Direct link to has()\")\n\nReturns if an array field contains a value.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', has(tags, 'zenstack'))}\n```\n\n#### hasEvery()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#hasevery \"Direct link to hasEvery()\")\n\nReturns if an array field contains every value in the provided array.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', has(tags, ['zenstack', 'prisma']))}\n```\n\n#### hasSome()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#hassome \"Direct link to hasSome()\")\n\nReturns if an array field contains some value in the provided array.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', hasSome(tags, ['zenstack', 'prisma']))}\n```\n\n#### isEmpty()[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#isempty \"Direct link to isEmpty()\")\n\nReturns if an array field is empty.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', isEmpty(tags))}\n```",
  "title": "Expressions and Functions | ZenStack",
  "description": "In the previous chapters, we've informally introduced how policy expressions are written. This chapter will list all expression types supported and functions that help you construct complex rules.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood",
  "markdown": "# How Does ZenStack Work Under the Hood?\n\nAdvanced Topic\n\nThis document is for advanced users who want to understand how ZenStack works under the hood. It's not required for using ZenStack.\n\nZenStack extends Prisma ORM mainly at two levels. First, it provides a modeling DSL (ZModel) - a superset of Prisma schema. Second, it allows the creation of enhanced wrappers for Prisma clients at runtime for injecting extra behaviors.\n\nThis document explains how these extensions work so that you can make a more informed judgment on whether ZenStack is the right choice for you.\n\n## ZModel Language[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#zmodel-language \"Direct link to ZModel Language\")\n\nZenStack implemented the ZModel DSL from scratch, including the CLI and the VSCode extension, using the fantastic language toolkit [Langium](https://langium.org/). The DLS includes a plugin system, allowing a modular and extensible way to generate different artifacts from the schema. The core functionality of the toolkit is supported by the following three core plugins:\n\n*   Prisma: `@core/prisma`\n    \n    The Prisma plugin generates the Prisma schema and Prisma client from the ZModel schema. The Prisma schema can then be used for common Prisma tasks like `db push`, `migrate dev`, etc.\n    \n*   Model-meta: `@core/model-meta`\n    \n    The model-meta plugin generates the model metadata, which provides basic information about models and fields at runtime. The metadata is much more lightweight than the whole ZModel AST and is much cheaper to load.\n    \n    The default output location is `node_modules/.zenstack/model-meta.ts`.\n    \n*   Policy: `@core/access-policy`\n    \n    The access policy plugin converts access policy rules (expressed with `@@allow` and `@@deny` attributes) into checker functions. The functions take a context object as input and return partial Prisma query objects, which will be injected into Prisma query arguments at runtime. The context object contains the following properties:\n    \n    *   `user`: the current user, which serves as the return value of [`auth()`](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user) in the policy rules.\n    *   `preValue`: the previous value of an entity before update (for supporting the [`future()`](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/post-update) function in the policy rules).\n    \n    The default output location is `node_modules/.zenstack/policy.ts`.\n    \n    For example, for the following `Post` model:\n    \n    ```\n    model Post {    id        String @id @default(cuid())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    title     String    published Boolean @default(false)    author    User @relation(fields: [authorId], references: [id])    authorId  String    // author has full access    @@allow('all', auth() == author)    // logged-in users can view published posts    @@allow('read', auth() != null && published)}\n    ```\n    \n    , the following checker functions are generated for \"read\" and \"update\" respectively:\n    \n    ```\n    function Post_read(context: QueryContext) {    const user = hasAllFields(context.user, ['id']) ? context.user : null;    return {        OR: [            user == null                ? { OR: [] } // false condition                : {                      author: {                          is: {                              id: user.id,                          },                      },                  },            {                AND: [                    user == null ? { OR: [] } : { AND: [] },                    {                        published: true,                    },                ],            },        ],    };}function Post_update(context: QueryContext) {    const user = hasAllFields(context.user, ['id']) ? context.user : null;    return user == null        ? { OR: [] } // false condition        : {              author: {                  is: {                      id: user.id,                  },              },          };}\n    ```\n    \n\n## Runtime Enhancements[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#runtime-enhancements \"Direct link to Runtime Enhancements\")\n\nThe primary responsibility of ZenStack's runtime is to create _enhanced_ Prisma client instances:\n\n*   `enhance` creates an enhanced client that includes all behaviors below.\n*   `withPolicy` creates an enhanced client that enforces access policies expressed with `@@allow` and `@@deny` attributes.\n*   `withPassword` creates an enhanced client that automatically hashes fields marked with the `@password` attribute before storing them in the database.\n*   `withOmit` creates an enhanced client that automatically strips fields marked with the `@omit` attribute before returning to the caller.\n\n### Proxies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#proxies \"Direct link to Proxies\")\n\nRuntime enhancements are achieved by creating transparent proxies around raw Prisma clients. The proxies intercept all Prisma client methods, inject into query arguments, and manipulate the query results returned by the client. The proxies work independently from each other so that they can be freely combined. In fact, the `enhance` helper is a direct combination of `withPassword`, `withOmit`, and `withPolicy`.\n\n```\nexport function enhance<DbClient extends object>(    prisma: DbClient,    context?: WithPolicyContext,    options?: EnhancementOptions) {    return withPolicy(withOmit(withPassword(prisma, modelMeta), modelMeta), context, policy, modelMeta);}\n```\n\n### Access Policies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#access-policies \"Direct link to Access Policies\")\n\nAccess policies, enabled by the `withPolicy` enhancer, are the most complex parts of the system. Part of the complexity comes from the great flexibility Prisma offers in querying and mutating data. For example, to enforce \"read\" rules on a `Post` model, we need to consider several possibilities:\n\n```\n// a direct where conditionprisma.post.findMany({    where: {...}});// nested fetch for relationsprisma.user.findUnique({    where: {id: ...},    include: { posts: true }});// nested fetch during mutationprisma.user.update({    where: {id: ...},    data: { ... },    select: { id: true, email: true, posts: true }});// ...\n```\n\nWe need the following measures to enforce access policies systematically:\n\n1.  **Inject filter conditions into the \"where\" clause in the context of \"find many\"**\n    \n    This covers cases like direct `findMany`/`findUnique`/`findFirst`/... calls:\n    \n    ```\n    prisma.user.findMany({ where: { ... } });// toprisma.user.findMany({    where: {        AND: [            { /* original conditions */ },            { /* read conditions */ },        ],    },});\n    ```\n    \n    Or nested \"find\" for a to-many relation:\n    \n    ```\n    prisma.user.findMany({ include: { posts: true } });// toprisma.user.findMany({    include: {        posts: {            where: {                /* read conditions */            },        },    },});\n    ```\n    \n    Or an implicit \"find\" carried with a mutation:\n    \n    ```\n    prisma.user.update({ data: { ... }, include: { posts: true } });// toprisma.user.update({ data: { ... }, include: { posts: { where: { /* read conditions */ } } } });\n    ```\n    \n2.  **Inject filter conditions into the \"where\" clause of \"mutate many\"**\n    \n    This covers cases like `updateMany` and `deleteMany`:\n    \n    ```\n    prisma.user.updateMany({ where: { ... }, data: { ... } });// toprisma.user.updateMany({    where: {        AND: [ { /* original conditions */ }, { /* update conditions */ } ]    },    data: { ... }});\n    ```\n    \n    Or nested usage of them:\n    \n    ```\n    prisma.user.update({ where: { ... }, data: { posts: { deleteMany: { where: { ... } } } } });// toprisma.user.update({ where: { ... },    data: {        posts: {            deleteMany: {                AND: [ { /* original conditions */ }, { /* delete conditions */ } ]            }        }    }});\n    ```\n    \n3.  **Post-read check for entities fetched as a to-one relation**\n    \n    To-one relation is a special case for reading because there's no way to do filtering at the read time: you either include it or not. So, we need to do a post-read check to ensure the fetched entity can be read.\n    \n    ```\n    const user = prisma.user.findUnique({ where: { id: ... }, include: { profile: true } });// toconst user = prisma.user.findUnique({ where: { id: ... }, include: { profile: true } });if (profile && !readable(user.profile)) {   // throw rejected error}\n    ```\n    \n4.  **Transaction-protected mutations**\n    \n    Policies that do \"post-mutation\" checks, including \"create\" and \"post-update\" (\"update\" rule calling [`future()`](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#the-future-function) function) rules, are protected by a transaction. The mutation is conducted first, and then post-mutation checks are performed. If any of the checks fail, the transaction rolls back.\n    \n    Although, for simple cases, we can enforce policies by checking the mutation input, there are many cases where we can't safely rely on that. Instead, employing a transaction is the most reliable way to achieve a consistent result. In the future, we may add input checking as an optimization where possible.\n    \n    ```\n    prisma.user.create({ data: { ... } });// toprisma.$transaction((tx) => {    const user = prisma.user.create({ data: { ... } });    if (!createable(user)) {        // throw rejected error    }})\n    ```\n    \n\n### The `auth()` function[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#the-auth-function \"Direct link to the-auth-function\")\n\nThe `auth()` function connects authentication with access control. It's typed as the auth model (the model named \"User\" by default) in ZModel and represents the current authenticated user. The most common way of setup is to read the auth model entity from the database after authentication is completed and pass the result to the `enhance` function as context.\n\nAlthough `auth()` resolves to the auth model, since it's provided by the user, there's no way to guarantee its value fully conforms to the model' typing: e.g., non-nullable fields can be passed as `null` or `undefined`. We employ some simple rules to deal with such cases:\n\n*   If `auth()` is `undefined`, it's normalized to `null` when evaluating access policies.\n*   If `auth()` itself is `null`, any member access (or chained member access) is `null`.\n*   `expression == null` evaluates to `true` if `expression` is `null`.\n*   Otherwise, a boolean expression evaluates to `false` if a `null` value is involved.\n\nHere are a few examples (assuming `auth()` is `null`):\n\n1.  `auth() == null` -> `true`\n2.  `auth() != null` -> `false`\n3.  `auth().name == null` -> `true`\n4.  `auth().age > 0` -> `false`\n5.  `auth().age < 0` -> `false`\n\n### The `future()` function[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#the-future-function \"Direct link to the-future-function\")\n\nAn \"update\" policy rule is treated as a \"post-update\" rule if it involves a `future()` function call. `future()` represents the value of the model entity after the update is completed. In a \"post-update\" policy rule, any member accesses that are not prefixed with `future().` is treated as referencing the entity's value before the update. To support the evaluation of such rules, the entity value before the update is captured and passed as the `preValue` field in the context object passed to the checker function.",
  "title": "How Does ZenStack Work Under the Hood? | ZenStack",
  "description": "This document is for advanced users who want to understand how ZenStack works under the hood. It's not required for using ZenStack.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters",
  "markdown": "# Server Adapters | ZenStack\n\n### Overview[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#overview \"Direct link to Overview\")\n\nZenStack is a toolkit but not a framework. It doesn't come with its own web server. Instead, it provides a set of server adapters that \"mount\" APIs to the server of your choice.\n\nServer adapters are framework-specific. ZenStack ships a `@zenstackhq/server` package that contains adapters for the most popular backend and full-stack frameworks:\n\n*   [Express](https://zenstack.dev/docs/1.x/reference/server-adapters/express)\n*   [Fastify](https://zenstack.dev/docs/1.x/reference/server-adapters/fastify)\n*   [Next.js](https://zenstack.dev/docs/1.x/reference/server-adapters/next)\n*   [Nuxt](https://zenstack.dev/docs/1.x/reference/server-adapters/nuxt)\n*   [SvelteKit](https://zenstack.dev/docs/1.x/reference/server-adapters/sveltekit)\n\nCheck out their respective documentation to learn more details.\n\nAs mentioned in the previous chapter, server adapters handle framework-specific request/response formats and transform them to the canonical form that the underlying API handlers understand. All server adapters share the following two initialization options:\n\n*   `handler`\n    \n    The API handler to use. As mentioned in the previous chapter, ZenStack provides two built-in API handler implementations. If you don't specify this option, the default API handler is RPC.\n    \n    *   RPC handler: `@zenstackhq/server/api/rpc`\n    *   RESTful handler: `@zenstackhq/server/api/rest`\n*   `getPrisma`\n    \n    A callback function for getting a PrismaClient instance used for handling a CRUD request. The function is passed with a framework-specific request object. Although you can return a vanilla Prisma Client, you most likely should use an enhanced one to enforce access policies.\n    \n\n### üõ†Ô∏è Serving CRUD API[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#%EF%B8%8F-serving-crud-api \"Direct link to üõ†Ô∏è Serving CRUD API\")\n\nLet's see how we can automagically turn our ZModel schema into a web API without really coding it üöÄ! We'll use Express for simplicity for now, but working with another framework is essentially the same.\n\n#### 1\\. Installing dependencies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#1-installing-dependencies \"Direct link to 1. Installing dependencies\")\n\nFirst, install Express and the ZenStack server package:\n\n```\nnpm install express @zenstackhq/servernpm install --save-dev @types/express tsx\n```\n\n#### 2\\. Creating an Express app[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#2-creating-an-express-app \"Direct link to 2. Creating an Express app\")\n\nCreate a file `main.ts` with the following content:\n\nmain.ts\n\n```\nimport express from 'express';const app = express();app.use(express.json());app.get('/', (req, res) => {    res.json({ greet: 'Hello World!' });});app.listen(3000, () => console.log('üöÄ Server ready at: http://localhost:3000'));\n```\n\nStart the server:\n\nMake a request in another terminal to verify everything is working:\n\n```\ncurl http://localhost:3000\n```\n\n> { \"greet\": \"Hello World!\" }\n\n#### 3\\. Adding ZenStack server adapter (RPC flavor)[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#3-adding-zenstack-server-adapter-rpc-flavor \"Direct link to 3. Adding ZenStack server adapter (RPC flavor)\")\n\nLet's create an express middleware and mount the CRUD API to the `/api/rpc` path. Replace `main.ts` with the following content:\n\nmain.ts\n\n```\nimport { PrismaClient } from '@prisma/client';import { ZenStackMiddleware } from '@zenstackhq/server/express';import express from 'express';const app = express();app.use(express.json());const prisma = new PrismaClient();app.use('/api/rpc', ZenStackMiddleware({ getPrisma: () => prisma }));app.listen(3000, () => console.log('üöÄ Server ready at: http://localhost:3000'));\n```\n\ninfo\n\nThe `ZenStackMiddleware` server adapter uses RPC-flavor API by default.\n\nWe've configured the server adapter to use a vanilla Prisma Client for now for quick testing. By default, the server adapter uses RPC-style API. We can hit the endpoint to do a few tests now:\n\n*   Find a `List`\n    \n    ```\n    curl \"http://localhost:3000/api/rpc/list/findFirst\"\n    ```\n    \n    ```\n    {    \"data\" : {        \"createdAt\" : \"2023-11-08T04:38:53.385Z\",        \"id\" : 1,        \"ownerId\" : 1,        \"private\" : false,        \"spaceId\" : 1,        \"title\" : \"Grocery\",        \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"    },    \"meta\" : { ... }}\n    ```\n    \n*   Find a private `List`\n    \n    Note the parameter `q` is url-encoded `{\"where\":{\"private\":true}}`.\n    \n    ```\n    curl \"http://localhost:3000/api/rpc/list/findFirst?q=%7B%22where%22%3A%7B%22private%22%3Atrue%7D%7D\"\n    ```\n    \n    ```\n    {    \"data\" : {        \"createdAt\" : \"2023-11-11T02:34:29.880Z\",        \"id\" : 5,        \"ownerId\" : 1,        \"private\" : true,        \"spaceId\" : 1,        \"title\" : \"Joey' List\",        \"updatedAt\" : \"2023-11-11T02:34:29.880Z\"    },    \"meta\" : { ...}}\n    ```\n    \n*   Create a `List`\n    \n    ```\n    curl -XPOST \"http://localhost:3000/api/rpc/list/create\" \\    -d '{\"data\":{\"title\":\"Jobs to be done\",\"owner\":{\"connect\":{\"id\":2}},\"space\":{\"connect\":{\"id\":1}}}}' \\    -H 'Content-Type: application/json'\n    ```\n    \n    ```\n    {    \"data\": {        \"id\": 6,        \"createdAt\": \"2023-11-11T02:40:58.765Z\",        \"updatedAt\": \"2023-11-11T02:40:58.765Z\",        \"spaceId\": 1,        \"ownerId\": 2,        \"title\": \"Jobs to be done\",        \"private\": false    },    \"meta\": { ... }}\n    ```\n    \n\n#### 4\\. Making access policies work[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#4-making-access-policies-work \"Direct link to 4. Making access policies work\")\n\nTo make access policies work, we need to create an enhanced Prisma Client, and to do that, we need to be able to get the current user from the request. Since we haven't implemented authentication yet, we'll use a special `x-user-id` header to simulate and pass the requesting user's ID. It's definitely not a secure implementation, but it's sufficient for demonstration. We'll hook up a real authentication system in [Part IV](https://zenstack.dev/docs/1.x/the-complete-guide/part4/).\n\nReplace the content of `main.ts` with the following code:\n\nmain.ts\n\n```\nimport { PrismaClient } from '@prisma/client';import { enhance } from '@zenstackhq/runtime';import { ZenStackMiddleware } from '@zenstackhq/server/express';import express, { Request } from 'express';const app = express();app.use(express.json());const prisma = new PrismaClient();function getUser(req: Request) {    if (req.headers['x-user-id']) {        return { id: parseInt(req.headers['x-user-id'] as string) };    } else {        return undefined;    }}app.use('/api/rpc',     ZenStackMiddleware({         getPrisma: (req) => enhance(prisma, { user: getUser(req) })    }));app.listen(3000, () => console.log('üöÄ Server ready at: http://localhost:3000'));\n```\n\nNow, if we hit the endpoint again without the `x-user-id` header, we'll get a null response:\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst\"\n```\n\nAdd the header and request again. We should get back a result then:\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst\" -H \"x-user-id: 1\"\n```\n\n```\n{  \"data\": {    \"id\": 1,    \"createdAt\": \"2023-11-08T04:38:53.385Z\",    \"updatedAt\": \"2023-11-09T04:52:57.987Z\",    \"spaceId\": 1,    \"ownerId\": 1,    \"title\": \"Grocery\",    \"private\": false  },  \"meta\": { ... }}\n```\n\nYou can try other operations with different user identities. The service's behavior should be consistent with what we've seen in the REPL with the enhanced Prisma in [Part I](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#add-user-based-access-control).\n\n#### 5\\. Trying Out The RESTful API Flavor[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#5-trying-out-the-restful-api-flavor \"Direct link to 5. Trying Out The RESTful API Flavor\")\n\nLet's mount a RESTful-flavor API under another path `/api/rest`. Add the following code to `main.ts` before the line of `app.listen(...)`:\n\n```\nimport RESTHandler from '@zenstackhq/server/api/rest';app.use('/api/rest',     ZenStackMiddleware({         handler: RESTHandler({ endpoint: 'http://localhost:3000/api/rest' }),        getPrisma: (req) => enhance(prisma, { user: getUser(req) })    }));\n```\n\nAs you've seen above, we're using the same server adapter implementation and swapped the API handler. Now we can fetch the first `List` item by making a RESTful-style request.\n\ninfo\n\nThe \"-g\" parameter passed to curl is for allowing square brackets in the URL.\n\n```\ncurl -g 'http://localhost:3000/api/rest/list?page[limit]=1' -H \"x-user-id: 1\"\n```\n\n```\n{   \"data\" : [      {         \"attributes\" : {            \"createdAt\" : \"2023-11-08T04:38:53.385Z\",            \"ownerId\" : 1,            \"private\" : false,            \"spaceId\" : 1,            \"title\" : \"Grocery\",            \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"         },         \"id\" : 1,         \"links\" : { ... },         \"relationships\" : { ... },         \"type\" : \"list\"      }   ],   \"jsonapi\" : {      \"version\" : \"1.1\"   },   \"links\" : { ... },   \"meta\" : { ... }}\n```",
  "title": "Server Adapters | ZenStack",
  "description": "Overview",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part2/using-plugins",
  "markdown": "# Using Plugins | ZenStack\n\n```\nplugin openapi {    provider = \"@zenstackhq/openapi\"    output = \"openapi.yaml\"    title = \"My Todo API\"    version = \"1.0.0\"}\n```",
  "title": "Using Plugins | ZenStack",
  "description": "To use a plugin, install the plugin npm package:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part2/conclusion",
  "markdown": "# Conclusion | ZenStack\n\nIn this part of the guide, we've focused on the plugin system of ZenStack. We've learned how to use plugins and how to write one.\n\nZModel contains a formal representation of how data is organized and its constraints. Besides serving as database schema and access control, it's an excellent source for powering other aspects of your app. Don't hesitate to write your own plugins when you feel the need.\n\nIn [Part III](https://zenstack.dev/docs/1.x/the-complete-guide/part3/) and [Part IV](https://zenstack.dev/docs/1.x/the-complete-guide/part4/) of the guide, you'll see in action how we use plugins to turn our Todo project from a schema to a full-stack application without writing much code.\n\nThe completed sample project up to the end of this part can be found in the \"part2\" branch of the [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/v1-part2) repo. You can clone it and check out to that branch with the following command:\n\n```\ngit clone --branch v1-part2 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```",
  "title": "Conclusion | ZenStack",
  "description": "In this part of the guide, we've focused on the plugin system of ZenStack. We've learned how to use plugins and how to write one.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part2/builtin-plugins",
  "markdown": "# Built-in Plugins | ZenStack\n\nZenStack ships with a set of built-in plugins. They fall into the following two categories.\n\nMost of the core functionalities of ZenStack are implemented as or supported by a few core plugins. They're vital to the operation of ZenStack and are enabled automatically as needed. Core plugins are implemented inside the `zenstack` npm package and have names starting with `@core/`.\n\nThe ZenStack CLI automatically decides whether a core plugin should be enabled based on the ZModel. You can also explicitly declare a core plugin to override its options. For example, declare a `@core/prisma` plugin to output the generated Prisma schema file to a custom location:\n\n```\nplugin prisma {    provider = \"@core/prisma\"    output = \"src/db/prisma/schema.prisma\"}\n```\n\nBesides core plugins, the ZenStack team maintains a set of useful but non-essential plugins. They are implemented in separate npm packages under the `@zenstackhq` organization.",
  "title": "Built-in Plugins | ZenStack",
  "description": "ZenStack ships with a set of built-in plugins. They fall into the following two categories.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/customization",
  "markdown": "# Customizing The Generated API | ZenStack\n\nHaving APIs derived from the schema is great, but sometimes, you want to customize them to fit your needs. Some of the common use cases are:\n\nIn this chapter, let's explore a few options to do that.\n\nMost server frameworks provide some kind of \"middleware\" mechanism for developers to intercept requests and responses. For example, you can use a separate Express middleware to add custom a custom header to the response before it's sent to the client:\n\n```\napp.use('/api/rpc',     ZenStackMiddleware({        getPrisma: (req) => enhance(prisma, { user: getUser(req) }),        // instructs the middleware to not send the response,        // instead, store it in `res.locals`        sendResponse: false,    }),    (req: Request, res: Response) => {        // another middleware to intercept the CRUD response,        // add a header and send the response        const { status, body } = res.locals;        res.header('x-requested-by', req.headers['x-user-id']);        res.status(status).json(body);    });\n```\n\nSince server adapters are just lightweight wrappers around API handlers, you can also implement a custom adapter to interact with the API handler directly. This way, you have complete control over how the API handler's result data is processed and sent back to the client as a framework response.\n\nThe following code demonstrates how to add the 'x-requested-by' header with this approach:\n\n```\nimport RESTHandler from '@zenstackhq/server/api/rest';app.use('/api/rpc-custom', async (req: Request, res: Response) => {    const url = req.protocol + '://' + req.get('host') + req.originalUrl;    const searchParams = new URL(url).searchParams;    const query = Object.fromEntries(searchParams);    const handler = RPCHandler();    const { status, body } = await handler({        method: req.method,        path: req.path,        query,        requestBody: req.body,        prisma: enhance(prisma, { user: getUser(req) }) as any,    });    res.status(status)        .header('x-requested-by', req.header('x-user-id'))        .json(body);});\n```\n\nUsing the automatic CRUD API doesn't mean you can't implement your own APIs. You can always build fully customized APIs from scratch and leverage the enhanced Prisma Client.",
  "title": "Customizing The Generated API | ZenStack",
  "description": "Having APIs derived from the schema is great, but sometimes, you want to customize them to fit your needs. Some of the common use cases are:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins",
  "markdown": "# Writing Plugins | ZenStack\n\nThe ZModel schema is the single source of truth for your data and access control. It can be used to generate many other valuable things based on your specific needs. In this part of the guide, we'll learn the fundamentals of how to write plugins and create a simple one that generates a markdown documentation from the ZModel schema.\n\n### Structure of a Plugin[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#structure-of-a-plugin \"Direct link to Structure of a Plugin\")\n\nA plugin is a Node.js module that has the following exports:\n\n1.  A named export `name` that specifies the name of the plugin used for logging and error reporting.\n2.  A default function export containing the plugin logic.\n\nHere's what a bare minimum plugin looks like:\n\n```\nimport type { DMMF } from '@prisma/generator-helper';import { type PluginOptions } from '@zenstackhq/sdk';import { type Model } from '@zenstackhq/sdk/ast';export const name = 'My Plugin';export default async function run(model: Model, options: PluginOptions, dmmf: DMMF.Document) {    ...}\n```\n\nWhen `zenstack generate` runs, it identifies all the plugins declared in the ZModel, loads their Javascript modules, and calls the default export functions. The following sections explain the arguments passed to the plugin function.\n\n#### ZModel AST[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#zmodel-ast \"Direct link to ZModel AST\")\n\nThe first input of the plugin function is the ZModel AST. It is the result object model of parsing and linking the ZModel schema - a tree structure containing all the information in the schema. Most plugins traverse the AST, extract information of interest, and transform it into another form.\n\nThe following diagram shows the (abbreviated) AST of a simple ZModel schema:\n\n```\ndatasource db {    provider = 'sqlite'    url = 'file:.dev.db'}model User {    id Int @id @default(autoincrement())    posts Post[]}model Post {    id Int @id @default(autoincrement())    title String    author User @relation(fields: [authorId], references: [id])    authorId Int    @@allow('all', auth() == author)}\n```\n\nThe best way to understand the AST structure is to inspect the [ZModel language definition](https://github.com/zenstackhq/zenstack/blob/main/packages/language/src/zmodel.langium).\n\n#### Plugin Options[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#plugin-options \"Direct link to Plugin Options\")\n\nThe second input of the plugin function is the options - an object containing the config fields that the plugin user specified in the ZModel. As a plugin developer, you should define and document what config options your plugin supports.\n\n#### Prisma DMMF[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#prisma-dmmf \"Direct link to Prisma DMMF\")\n\nThe third input of the plugin function is the Prisma DMMF (Data Model Meta Format). DMMF is essentially Prisma Schema's AST enriched with other information needed to generate Prisma Client. It is the main API that developers use to write custom Prisma generators. However, the API is undocumented and considered internal.\n\nFor ZenStack plugins, the DMMF is provided as an auxiliary input. If you only need information from the ZModel schema, the ZModel AST is all you need. However, if you need to access types generated for the Prisma Client (e.g., the parameter shapes of `prisma.user.findMany()`), DMMF is the only way to get them. The best way to learn how to use DMMF is to study the source code of [Prisma's community generators](https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators).\n\n### Adding Custom Attributes[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#adding-custom-attributes \"Direct link to Adding Custom Attributes\")\n\nA plugin can contribute custom attributes and functions to the ZModel language. To do that, simply include a `plugin.zmodel` file in the same directory as the plugin's entry point, and declare the attributes and functions there. Check [here](https://github.com/zenstackhq/zenstack/blob/main/packages/plugins/openapi/src/plugin.zmodel) for an example. As a convention for conflict avoidance, please qualify the declaration names with your plugin name. E.g.:\n\n```\nattribute @@myplugin.include()\n```\n\nAnd you can use it in the ZModel when the plugin is enabled:\n\n```\nmodel Foo {    ...    @@myplugin.include()}\n```\n\n### Publishing a Plugin[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#publishing-a-plugin \"Direct link to Publishing a Plugin\")\n\nIf your plugin is specific to your project, you can implement it inside the project and load it with a relative path in the ZModel. No publishing is needed. We'll see how to do that in the next section.\n\nIf you're building something reusable, please publish it as an NPM package and [tweet us](https://twitter.com/intent/tweet?text=I%27ve%20published%20a%20%40zenstackhq%20plugin%3A&url=) or reach us on [Discord](https://discord.gg/Ykhr738dUe). We'll be happy to share your work with the community.\n\n### üõ†Ô∏è Building a Markdown Generator Plugin[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#%EF%B8%8F-building-a-markdown-generator-plugin \"Direct link to üõ†Ô∏è Building a Markdown Generator Plugin\")\n\nLet's build a simple plugin that generates a markdown documentation from the ZModel schema. The generated documentation will look like this:\n\n```\n# My Awesome Todo AppA multi-tenant Todo app built with ZenStack.- [Space](#space)- [User](#user)- ...## Space- CREATE  - ‚ùå auth() == null  - ‚úÖ true- READ  - ‚ùå auth() == null  - ‚úÖ members?[user == auth()]- UPDATE  - ‚ùå auth() == null  - ‚úÖ members?[user == auth() && role == ADMIN]- DELETE  - ‚ùå auth() == null  - ‚úÖ members?[user == auth() && role == ADMIN]## User...\n```\n\n#### 1\\. Creating the plugin[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#1-creating-the-plugin \"Direct link to 1. Creating the plugin\")\n\nIn our sample project, create a `markdown-plugin.ts` file at the root:\n\nmarkdown-plugin.ts\n\n```\nimport { type PluginOptions } from '@zenstackhq/sdk';import {    isDataModel,    type DataModel,    type Model,} from '@zenstackhq/sdk/ast';import fs from 'fs';export const name = 'Markdown';export default async function run(model: Model, options: PluginOptions) {    // process options    const title = options.title ?? 'My Application Model';    const description = options.description ?? 'Description of my application';    // get all data models    const dataModels = model.declarations.filter((x): x is DataModel =>        isDataModel(x)    );    // TOC    const toc = dataModels.map((x) => `- [${x.name}](#${x.name})`).join('\\n');    // data model docs    const dataModelDocs = generateDataModelDocs(dataModels);    fs.writeFileSync(        'schema.md',        `# ${title}    ${description}    ${toc}    ${dataModelDocs}    `    );}\n```\n\nThe code sets up the high-level structure of the markdown document. Let's now add the `generateDataModelDocs` function implementation in the same file.\n\nmarkdown-plugin.ts\n\n```\nimport { ZModelCodeGenerator, getLiteral } from '@zenstackhq/sdk';import { type DataModelAttribute } from '@zenstackhq/sdk/ast';function generateDataModelDocs(dataModels: DataModel[]) {    // AST -> ZModel source generator    const zmodelCodeGen = new ZModelCodeGenerator();    // all CRUD operations    const CRUD = ['create', 'read', 'update', 'delete'];    const docs = dataModels.map((dataModel) => {        // first, group model attributes by CRUD operations        const groupByCrud = dataModel.attributes            .filter((attr) =>                ['@@allow', '@@deny'].includes(attr.decl.ref?.name || '')            )            .reduce<Record<string, DataModelAttribute[]>>((group, attr) => {                const ops = getLiteral<string>(attr.args[0].value);                if (ops) {                    const splitOps =                        ops == 'all'                            ? CRUD                            : ops.split(',').map((op) => op.trim());                    splitOps.forEach((op) => {                        group[op] = group[op] || [];                        group[op].push(attr);                    });                }                return group;            }, {});        // then generate rules for each operation        const policies = CRUD.map((op) => {            const rules = groupByCrud[op]                ? groupByCrud[op]                      // output `@@deny` before `@@allow`                      .sort((a) => {                          return a.decl.ref?.name == '@@deny' ? -1 : 1;                      })                      .map(                          (attr) =>                              `  - ${                                  attr.decl.ref?.name == '@@deny'                                      ? '‚ùå '                                      : '‚úÖ '                              }${zmodelCodeGen.generate(attr.args[1].value)}`                      )                      .join('\\n')                : [];            return [`- ${op.toUpperCase()}`, rules].join('\\n');        }).join('\\n');        return `## ${dataModel.name}\\n\\n${policies}`;    });    return docs.join('\\n\\n');}\n```\n\nFinally, compile the plugin code:\n\nThe JavaScript output should have been generated into the `dist` folder.\n\n#### 2\\. Testing the plugin[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#2-testing-the-plugin \"Direct link to 2. Testing the plugin\")\n\nWe can now add the plugin to our ZModel:\n\n```\nplugin markdown {    provider = './dist/markdown-plugin'    title = 'My Awesome Todo App'    description = 'A multi-tenant Todo application built with ZenStack.'}\n```\n\nPlugin module resolution\n\nWhen you use a relative path (starting with \".\") in the \"provider\" field, ZenStack resolves the path relative to the ZModel file and loads the plugin module from it with `require()`. If the plugin is a published NPM package, use the package name directly in the \"provider\" field.\n\nNow run the CLI to regenerate:\n\nYou should see the following output and the `schema.md` file generated in the current directory:\n\n```\n‚åõÔ∏è ZenStack CLI v1.3.1, running plugins‚úî Running plugin Prisma‚úî Running plugin Model Metadata‚úî Running plugin Access Policy‚úî Running plugin Zod‚úî Running plugin Markdownüëª All plugins completed successfully!Don't forget to restart your dev server to let the changes take effect.\n```\n\n#### 3\\. Full source code[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#3-full-source-code \"Direct link to 3. Full source code\")\n\nThe sample plugin we implemented here is a simplified version of the [zenstack-markdown](https://github.com/jiashengguo/zenstack-markdown) plugin created by [@jiashengguo](https://github.com/jiashengguo). Besides outputting access policies, it also generates mini entity-relation diagrams in [mermaid](https://mermaid-js.github.io/) format.",
  "title": "Writing Plugins | ZenStack",
  "description": "The ZModel schema is the single source of truth for your data and access control. It can be used to generate many other valuable things based on your specific needs. In this part of the guide, we'll learn the fundamentals of how to write plugins and create a simple one that generates a markdown documentation from the ZModel schema.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/serialization",
  "markdown": "# Data Serialization | ZenStack\n\nOne problem with passing Prisma requests and responses across the network is that the data is not always serializable. The following Prisma types are problematic:\n\n*   `Date`: Javascript's `Date` object is serializable, but its type is lost\n*   `Bytes`: not serializable\n*   `BigInt`: not serializable\n*   `Decimal`: not serializable\n\nZenStack solves this problem by using [superjson](https://github.com/blitz-js/superjson) to deserialize input and serialize output. Since data is still JSON-serializable most of the time, ZenStack adopts superjson in a non-intrusive way. The serialized data is directly put inside the request or response data. When there is extra serialization information (superjson generates it when it encounters data that's not JSON-serializable), it's put inside the `meta` field in the request or response.\n\nThe benefit of this design is that if the data is fully JSON-serializable (not involving the types mentioned above), the wire format is just plain JSON serialization without any pollution.\n\nYou can find more details about serialization in the [RPC API Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#serialization) and [RESTful API Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#serialization) documentation.\n\n### üõ†Ô∏è Observing Serialization Behavior[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/serialization#%EF%B8%8F-observing-serialization-behavior \"Direct link to üõ†Ô∏è Observing Serialization Behavior\")\n\nTo illustrate this, let's try a few requests to observe the serialization behavior.\n\nMake the following request to find the first `List` with `{\"select\":{\"id\":true,\"title\":true}}`:\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst?q=%7B%22select%22%3A%7B%22id%22%3Atrue%2C%22title%22%3Atrue%7D%7D\" -H \"x-user-id: 1\"\n```\n\nYou should get a simple response. Since the result data is fully JSON-serializable, the response has no extra serialization metadata.\n\n```\n{    \"data\": {        \"id\":1,        \"title\":\"Grocery\"    }}\n```\n\nNow, if we send a different request and ask for the full `List` object\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst\" -H \"x-user-id: 1\"\n```\n\nWe get back a richer response. The `createdAt` and `updatedAt` fields are not directly JSON-serializable, and the information contained in the `meta.serialization` field is generated by superjson to facilitate deserialization.\n\n```\n{   \"data\" : {      \"createdAt\" : \"2023-11-08T04:38:53.385Z\",      \"id\" : 1,      \"ownerId\" : 1,      \"private\" : false,      \"spaceId\" : 1,      \"title\" : \"Grocery\",      \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"   },   \"meta\" : {      \"serialization\" : {         \"values\" : {            \"createdAt\" : [ \"Date\" ],            \"updatedAt\" : [ \"Date\" ]         }      }   }}\n```\n\nThe API consumer should pass the data and the serialization metadata to the superjson API to get back data with full fidelity. The following code shows how to deserialize and restore the proper `Date` type for the `createdAt` and `updatedAt` fields.\n\n```\nimport SuperJSON from 'superjson';SuperJSON.deserialize({    json: {        \"createdAt\" : \"2023-11-08T04:38:53.385Z\",        \"id\" : 1,        \"ownerId\" : 1,        \"private\" : false,        \"spaceId\" : 1,        \"title\" : \"Grocery\",        \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"   },   meta: {        \"values\" : {            \"createdAt\" : [ \"Date\" ],            \"updatedAt\" : [ \"Date\" ]        }    }});\n```\n\n```\n{    createdAt: 2023-11-08T04:38:53.385Z,    id: 1,    ownerId: 1,    private: false,    spaceId: 1,    title: 'Grocery',    updatedAt: 2023-11-09T04:52:57.987Z}\n```",
  "title": "Data Serialization | ZenStack",
  "description": "One problem with passing Prisma requests and responses across the network is that the data is not always serializable. The following Prisma types are problematic:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks",
  "markdown": "# üõ†Ô∏è Generating Hooks | ZenStack\n\nIf you use a frontend framework like React or Vue, you've probably used or heard of libraries like [TanStack Query](https://tanstack.com/query/latest) and [SWR](https://swr.vercel.app/). These libraries make it a breeze to build data-driven UI by providing excellent encapsulation for reactive data query, cache management, and data invalidation (aka refetching).\n\nZenStack provides plugins for generating frontend hooks targeting these two libraries. In this guide, we'll focus on using TanStack Query, but the concepts and usage are similar for SWR.\n\n### Installing Dependencies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks#installing-dependencies \"Direct link to Installing Dependencies\")\n\n```\nnpm install @tanstack/react-query @zenstackhq/tanstack-query\n```\n\nThe `@zenstackhq/tanstack-query` package contains both the plugin and a runtime part, so it needs to be installed as a regular dependency.\n\n### Setting Up TanStack Query[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks#setting-up-tanstack-query \"Direct link to Setting Up TanStack Query\")\n\nTo use TanStack Query, we need to set up a `QueryClientProvider` context provider in the root component of our app. First, create a file `src/components/QueryClientProvider.tsx` with the following content:\n\nsrc/components/QueryClientProvider.tsx\n\n```\n'use client';import { QueryClient, QueryClientProvider } from '@tanstack/react-query';type Props = {  children: React.ReactNode;};const queryClient = new QueryClient();function Provider({ children }: Props) {  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;}export default Provider;\n```\n\nThen, update the `src/app/layout.tsx` file to use it:\n\nsrc/app/layout.tsx\n\n```\nimport QueryClientProvider from '~/components/QueryClientProvider';export default function RootLayout({ children }: { children: React.ReactNode }) {  return (    <html lang=\"en\">      <body className={`font-sans ${inter.variable}`}>        <QueryClientProvider>          <NextAuthSessionProvider>{children}</NextAuthSessionProvider>        </QueryClientProvider>      </body>    </html>  );}\n```\n\n### Adding TanStack Query Plugin[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks#adding-tanstack-query-plugin \"Direct link to Adding TanStack Query Plugin\")\n\nNow add the plugin to the ZModel schema:\n\nschema.zmodel\n\n```\nplugin hooks {  provider = '@zenstackhq/tanstack-query'  target = 'react'  version = 'v5'  output = 'src/lib/hooks'}\n```\n\nTanStack Query is a multi-framework library and supports React, Vue, and Svelte. The \"target\" field specifies the frontend framework to generate hooks for. The \"version\" field specifies the version of TanStack Query to target. Here, we're using the latest \"v5\" version.\n\nThen, rerun generation and observe that the hooks code is generated in the `src/lib/hooks` directory.\n\n### A Peek Into the Hooks[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks#a-peek-into-the-hooks \"Direct link to A Peek Into the Hooks\")\n\nThe generated hooks allow you to query and mutate data without worrying about the API details. They're designed to fully preserve the Prisma query syntax you already know. Here are some quick examples of their usage:\n\n*   Nested read with filtering and sorting\n    \n    ```\n    // `data` is typed as `(Todo & { list: List })[]`const { data } = useFindManyTodo({  where: { owner: { id: 1 } },  include: { list: true },  orderBy: { createdAt: 'desc' }});\n    ```\n    \n*   Nested create\n    \n    ```\n    const { mutate } = useCreateList();function onCreateList() {  mutate({    data: {       title: 'My List',      owner: { connect: { id: userId } },      todos: {        create: [          { name: 'Todo 1' },          { name: 'Todo 2' }        ]      }    }  })}\n    ```\n    \n*   Count\n    \n    ```\n    const { data } = useCountTodo({ where: { owner: { id: 1 } } });\n    ```\n    \n\nWe'll cover the usage of the hooks in detail in the upcoming chapters.",
  "title": "üõ†Ô∏è Generating Hooks | ZenStack",
  "description": "If you use a frontend framework like React or Vue, you've probably used or heard of libraries like TanStack Query and SWR. These libraries make it a breeze to build data-driven UI by providing excellent encapsulation for reactive data query, cache management, and data invalidation (aka refetching).",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation",
  "markdown": "# Generating API Documentation | ZenStack\n\nVersion: 1.x\n\nAn API is only complete when documented. Similar to the API itself, the documentation can also be derived from the ZModel.\n\nIn [Part II](https://zenstack.dev/docs/1.x/the-complete-guide/part2/) of the guide, we've learned how to use plugins. ZenStack ships the [@zenstackhq/openapi](https://zenstack.dev/docs/1.x/reference/plugins/openapi) plugin to generate [OpenAPI](https://www.openapis.org/) specs from the ZModel schema. Like the API handlers, the openapi plugin also supports two flavors: \"rpc\" and \"rest\".\n\nOnce the documentation is generated, it's easy to render it using tools like [Swagger UI](https://swagger.io/tools/swagger-ui/) and [Redocly](https://redocly.com/).\n\n### üõ†Ô∏è Serving API Documentation[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation#%EF%B8%8F-serving-api-documentation \"Direct link to üõ†Ô∏è Serving API Documentation\")\n\nLet's generate an OpenAPI spec for our Todo API and serve it using Swagger UI.\n\n#### 1\\. Installing Dependencies[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation#1-installing-dependencies \"Direct link to 1. Installing Dependencies\")\n\n```\nnpm install --save-dev @zenstackhq/openapinpm install swagger-ui-expressnpm install -D @types/swagger-ui-express\n```\n\n#### 2\\. Adding OpenAPI Plugin to ZModel[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation#2-adding-openapi-plugin-to-zmodel \"Direct link to 2. Adding OpenAPI Plugin to ZModel\")\n\nschema.zmodel\n\n```\nplugin openapi {    provider = \"@zenstackhq/openapi\"    output = \"todo-api.json\"    title = \"My Todo API\"    version = \"1.0.0\"    flavor = \"rpc\"}\n```\n\nRerun generation:\n\nThe `todo-api.json` file should be generated in the project root.\n\n#### 3\\. Serving the OpenAPI Spec[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation#3-serving-the-openapi-spec \"Direct link to 3. Serving the OpenAPI Spec\")\n\nAdd the following code to `main.ts` before the line of `app.listen(...)`:\n\nmain.ts\n\n```\nimport swaggerUI from 'swagger-ui-express';app.use(    '/api/docs',    swaggerUI.serve,    swaggerUI.setup(require('./todo-api.json')));\n```\n\nNow, you can visit the documentation at [http://localhost:3000/api/docs](http://localhost:3000/api/docs) in a browser.\n\n![Swagger UI](https://zenstack.dev/assets/images/todo-app-openapi-5c63d09d659d098462f00c376787718c.png)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Generating API Documentation | ZenStack",
  "description": "An API is only complete when documented. Similar to the API itself, the documentation can also be derived from the ZModel.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/conclusion",
  "markdown": "# Conclusion | ZenStack\n\nIn this part of the guide, we've focused on ZenStack's powers for deriving CRUD APIs automatically from the ZModel schema. We had an overview of the different API flavors and learned how to mount the APIs onto a backend framework.\n\nIn the next part, we'll see how effortless it is to consume the APIs from a frontend application and eventually turn our Todo project into a full-stack application.\n\nThe completed sample project up to the end of this part can be found in the \"part3\" branch of the [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/v1-part3) repo. You can clone it and check out to that branch with the following command:\n\n```\ngit clone --branch v1-part3 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```",
  "title": "Conclusion | ZenStack",
  "description": "In this part of the guide, we've focused on ZenStack's powers for deriving CRUD APIs automatically from the ZModel schema. We had an overview of the different API flavors and learned how to mount the APIs onto a backend framework.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project",
  "markdown": "# üõ†Ô∏è Creating a Full-Stack Project\n\nTo simplify the process of building our full-stack Todo app, we'll recreate the project from scratch using the [create-t3-app](https://create.t3.gg/) scaffolding tool - saving us a lot of time manually integrating different tools and libraries. We'll reuse the ZModel schema we built in Part I.\n\nZenStack is framework-agnostic\n\nFor ease of demonstration, we'll use the [Next.js](https://nextjs.org/) framework for full-stack development. However, ZenStack is framework-agnostic. Most of the content apply to other choices, including full-stack ones like like [Nuxt](https://nuxt.com/) and [SvelteKit](https://kit.svelte.dev/), or SPA + backend frameworks like [Express](https://expressjs.com/), [Fastify](https://fastify.dev/), [NestJS](https://nestjs.com/).\n\n### 1\\. Creating the Project[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#1-creating-the-project \"Direct link to 1. Creating the Project\")\n\nCreate a new Next.js project using `create-t3-app`:\n\n```\nnpx create-t3-app@latest --tailwind --nextAuth --prisma --appRouter --CI my-todo-app\n```\n\nIt sets up a project with the following features:\n\n*   [Next.js](https://nextjs.org/) with app router\n*   TypeScript\n*   Prisma for ORM\n*   [NextAuth.js](https://next-auth.js.org/) for authentication\n*   [Tailwind CSS](https://tailwindcss.com/) for styling\n*   SQLite for database\n\nWe'll also use \"daisyUI\" for UI components. Run the following command to install it:\n\nThen add the \"daisyui\" plugin to `tailwind.config.ts`:\n\n```\nmodule.exports = {  //...  plugins: [require(\"daisyui\")],}\n```\n\nFinally, add some utility packages we'll use later:\n\n### 2\\. Setting Up ZenStack[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#2-setting-up-zenstack \"Direct link to 2. Setting Up ZenStack\")\n\nInitialize the project for ZenStack:\n\nBesides installing dependencies, the command also copies the `prisma/schema.prisma` file to `schema.zmodel`. We're going to continue using the ZModel we've developed in the previous part, but with a few tweaks:\n\n1.  All \"id\" fields are changed to String type (as required by NextAuth).\n2.  The \"markdown\" and \"openapi\" plugins are removed (not needed for this part).\n\nYou can also find the updated version here: [https://github.com/zenstackhq/the-complete-guide-sample/blob/v1-part4-start/schema.zmodel](https://github.com/zenstackhq/the-complete-guide-sample/blob/v1-part4-start/schema.zmodel). Replace the `schema.zmodel` file in your project with it.\n\nRun generation and push the schema to the database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 3\\. Implementing Authentication[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#3-implementing-authentication \"Direct link to 3. Implementing Authentication\")\n\n#### 3.1 NextAuth Session Provider[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#31-nextauth-session-provider \"Direct link to 3.1 NextAuth Session Provider\")\n\nTo use NextAuth, we'll need to install a session provider at the root of our app. First, create a file `src/components/SessionProvider.tsx` with the following content:\n\nsrc/components/SessionProvider.tsx\n\n```\n'use client';import { SessionProvider } from 'next-auth/react';import React from 'react';type Props = {  children: React.ReactNode;};function NextAuthSessionProvider({ children }: Props) {  return <SessionProvider>{children}</SessionProvider>;}export default NextAuthSessionProvider;\n```\n\nThen, update the `src/app/layout.tsx` file to use it\n\nsrc/app/layout.tsx\n\n```\nimport NextAuthSessionProvider from '~/components/SessionProvider';export default function RootLayout({ children }: { children: React.ReactNode }) {  return (    <html lang=\"en\">      <body className={`font-sans ${inter.variable}`}>        <NextAuthSessionProvider>{children}</NextAuthSessionProvider>      </body>    </html>  );}\n```\n\n#### 3.2 Credential-Based Auth[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#32-credential-based-auth \"Direct link to 3.2 Credential-Based Auth\")\n\nThe default project created by `create-t3-app` uses Discord OAuth for authentication. We'll replace it with credential-based authentication for simplicity.\n\nReplace the content of `/src/server/auth.ts` with the following:\n\n/src/server/auth.ts\n\n```\nimport { PrismaAdapter } from '@next-auth/prisma-adapter';import type { PrismaClient } from '@prisma/client';import { compare } from 'bcryptjs';import NextAuth, { type DefaultSession, type NextAuthOptions } from 'next-auth';import CredentialsProvider from 'next-auth/providers/credentials';import { db } from './db';declare module 'next-auth' {  interface Session extends DefaultSession {    user: {      id: string;    } & DefaultSession['user'];  }}export const authOptions: NextAuthOptions = {  session: {    strategy: 'jwt',  },  // Include user.id on session  callbacks: {    session({ session, token }) {      if (session.user) {        session.user.id = token.sub!;      }      return session;    },  },  // Configure one or more authentication providers  adapter: PrismaAdapter(db),  providers: [    CredentialsProvider({      credentials: {        email: { type: 'email' },        password: { type: 'password' },      },      authorize: authorize(db),    }),  ],};function authorize(prisma: PrismaClient) {  return async (credentials: Record<'email' | 'password', string> | undefined) => {    if (!credentials?.email) throw new Error('\"email\" is required in credentials');    if (!credentials?.password) throw new Error('\"password\" is required in credentials');    const maybeUser = await prisma.user.findFirst({      where: { email: credentials.email },      select: { id: true, email: true, password: true },    });    if (!maybeUser?.password) return null;    // verify the input password with stored hash    const isValid = await compare(credentials.password, maybeUser.password);    if (!isValid) return null;    return { id: maybeUser.id, email: maybeUser.email };  };}export default NextAuth(authOptions);\n```\n\nRemove code related to `DISCORD_CLIENT_ID` and `DISCORD_CLIENT_SECRET` from `/src/env.js`, and update the `.env` file under project root to the following:\n\n.env\n\n```\nDATABASE_URL=\"file:./db.sqlite\"NEXTAUTH_SECRET=\"abc123\"NEXTAUTH_URL=\"http://localhost:3000\"\n```\n\ninfo\n\nYou should use a strong `NEXTAUTH_SECRET` in a real application.\n\n### 4\\. Mounting the CRUD API[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#4-mounting-the-crud-api \"Direct link to 4. Mounting the CRUD API\")\n\nZenStack uses server adapters to mount CRUD APIs to frameworks, and it has several pre-built adapters for popular frameworks - one of which is Next.js. First, install the server adapter package:\n\n```\nnpm install @zenstackhq/server\n```\n\nThen, create a file `src/app/api/model/[...path]/route.ts` with the following content:\n\nsrc/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { NextRequestHandler } from '@zenstackhq/server/next';import { getServerSession } from 'next-auth';import { authOptions } from '~/server/auth';import { db } from '~/server/db';async function getPrisma() {  const session = await getServerSession(authOptions);  return enhance(db, { user: session?.user });}const handler = NextRequestHandler({ getPrisma, useAppDir: true });export { handler as DELETE, handler as GET, handler as PATCH, handler as POST, handler as PUT };\n```\n\ninfo\n\nThe crucial part is that we use an enhanced PrismaClient with the server adapter, so all API calls are automatically subject to the access policies defined in the ZModel schema.\n\nIn the next chapter, we'll learn how to use a plugin to generate frontend data query hooks that help us consume it.\n\nFinally, make a change to the `next.config.js` file to exclude the `@zenstackhq/runtime` package from the server component bundler:\n\nnext.config.js\n\n```\nconst config = {  experimental: {    serverComponentsExternalPackages: ['@zenstackhq/runtime']  }};\n```\n\nWhy is this needed?\n\nNext.js's server component bundler automatically bundles dependencies, but it has some restrictions on the set of Node.js features a package can use. The `@zenstackhq/runtime` package makes [unsupported](https://nextjs.org/docs/app/api-reference/next-config-js/serverComponentsExternalPackages) `require()` calls. We'll try to make it compatible in a future release.\n\n### 5\\. Compile the Project[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#5-compile-the-project \"Direct link to 5. Compile the Project\")\n\nCompile the project and see if everything is working correctly:",
  "title": "üõ†Ô∏è Creating a Full-Stack Project | ZenStack",
  "description": "To simplify the process of building our full-stack Todo app, we'll recreate the project from scratch using the create-t3-app scaffolding tool - saving us a lot of time manually integrating different tools and libraries. We'll reuse the ZModel schema we built in Part I.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/conclusion",
  "markdown": "# Conclusion | ZenStack\n\nVersion: 1.x\n\nIn this part of the guide, we've focused on using plugins to generate frontend data query hooks and use them to build highly responsive data-driven UIs with ease. We've also evolved our sample project into a fully functional application. There are still a few parts unimplemented (like space member management), but since we've covered all essential ZenStack concepts and features with what we've built, we'll skip them in this guide. You can find the completed source code for this part in the \"main\" branch of [https://github.com/zenstackhq/the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample).\n\nThere are also variants of the Todo app built with different stacks in the following repositories. They are feature complete and have better UI styling.\n\n*   [Next.js (pages route) + SWR](https://github.com/zenstackhq/sample-todo-nextjs)\n*   [Next.js (pages route) + TanStack Query](https://github.com/zenstackhq/sample-todo-nextjs-tanstack)\n*   [Nuxt + TanStack Query](https://github.com/zenstackhq/sample-todo-nuxt)\n*   [SvelteKit + TanStack Query](https://github.com/zenstackhq/sample-todo-sveltekit)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Conclusion | ZenStack",
  "description": "In this part of the guide, we've focused on using plugins to generate frontend data query hooks and use them to build highly responsive data-driven UIs with ease. We've also evolved our sample project into a fully functional application. There are still a few parts unimplemented (like space member management), but since we've covered all essential ZenStack concepts and features with what we've built, we'll skip them in this guide. You can find the completed source code for this part in the \"main\" branch of https://github.com/zenstackhq/the-complete-guide-sample.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/authentication/next-auth",
  "markdown": "# Integrating With Auth.js (NextAuth) | ZenStack\n\n[NextAuth](https://next-auth.js.org/) is a comprehensive framework for implementing authentication in Next.js projects. It offers a pluggable mechanism for configuring how user data is persisted.\n\nTo get access policies to work, ZenStack needs to be connected to the authentication system to get the user's identity. This guide introduces tasks required for integrating ZenStack with NextAuth. You can find a complete example [here](https://github.com/zenstackhq/sample-todo-nextjs/tree/v1 \":target=blank\").\n\n### Data model requirement[‚Äã](https://zenstack.dev/docs/1.x/guides/authentication/next-auth#data-model-requirement \"Direct link to Data model requirement\")\n\nNextAuth is agnostic about the underlying database type, but it requires specific table structures, depending on how you configure it. Therefore, your ZModel definitions should reflect these requirements. A sample `User` model is shown here (to be used with `CredentialsProvider`):\n\n/schema.zmodel\n\n```\nmodel User {    id String @id @default(cuid())    email String @unique @email    emailVerified DateTime?    password String @password @omit    name String?    image String? @url    // open to signup    @@allow('create', true)    // full access by oneself    @@allow('all', auth() == this)}\n```\n\nYou can find the detailed database model requirements [here](https://next-auth.js.org/adapters/models \":target=blank\").\n\n### Adapter[‚Äã](https://zenstack.dev/docs/1.x/guides/authentication/next-auth#adapter \"Direct link to Adapter\")\n\nAdapter is a NextAuth mechanism for hooking in custom persistence of auth-related entities, like User, Account, etc. Since ZenStack is based on Prisma, you can use PrismaAdapter for the job:\n\n/src/pages/api/auth/\\[...nextauth\\].ts\n\n```\nimport { PrismaAdapter } from \"@next-auth/prisma-adapter\";import NextAuth, { type NextAuthOptions } from 'next-auth';import { prisma } from \"../../../server/db/client\";export const authOptions: NextAuthOptions = {    // install Prisma adapter    adapter: PrismaAdapter(prisma),    ...};export default NextAuth(authOptions);\n```\n\nIf you use [`CredentialsProvider`](https://next-auth.js.org/providers/credentials \":target=blank\"), i.e. email/password based auth, you need to implement an `authorize` function for verifying credentials against the database.\n\nThis is standard Prisma stuff, and the following is just a quick example of how to do it:\n\n/src/pages/api/auth/\\[...nextauth\\].ts\n\n```\nimport { prisma } from \"../../../server/db/client\";export const authOptions: NextAuthOptions = {    ...    providers: [        CredentialsProvider({            credentials: {                email: {                    label: 'Email Address',                    type: 'email',                },                password: {                    label: 'Password',                    type: 'password',                },            },            authorize: authorize(prisma),        }),    ]};function authorize(prisma: PrismaClient) {  return async (credentials: Record<\"email\" | \"password\", string> | undefined) => {    if (!credentials) throw new Error(\"Missing credentials\");    if (!credentials.email) throw new Error('\"email\" is required in credentials');    if (!credentials.password) throw new Error('\"password\" is required in credentials');    const maybeUser = await prisma.user.findFirst({      where: { email: credentials.email },      select: { id: true, email: true, password: true },    });    if (!maybeUser || !maybeUser.password) return null;    const isValid = await compare(credentials.password, maybeUser.password);    if (!isValid) {      return null;    }    return { id: maybeUser.id, email: maybeUser.email };  };}\n```\n\n### Create an enhanced Prisma client[‚Äã](https://zenstack.dev/docs/1.x/guides/authentication/next-auth#create-an-enhanced-prisma-client \"Direct link to Create an enhanced Prisma client\")\n\nYou can create an enhanced Prisma client which automatically validates access policies, field validation rules etc., during CRUD operations. For more details, please refer to [ZModel Language](https://zenstack.dev/docs/1.x/reference/zmodel-language) reference.\n\nTo create such a client with a standard setup, call the `enhance` API with a regular Prisma client and the current user (fetched with NextAuth API). Here's an example:\n\n```\nimport type { NextApiRequest, NextApiResponse } from 'next';import { getServerSession } from 'next-auth';import { enhance } from '@zenstackhq/runtime';import { authOptions } from '../../pages/api/auth/[...nextauth]';import { prisma } from '../../../server/db/client';async function getPrisma(req: NextApiRequest, res: NextApiResponse) {    const session = await getServerSession(req, res, authOptions);    // create a wrapper of Prisma client that enforces access policy,    // data validation, and @password, @omit behaviors    return enhance(prisma, { user: session?.user });}\n```\n\nYou can then use this enhanced Prisma client for CRUD operations that you desire to be governed by the access policies you defined in your data models.",
  "title": "Integrating With Auth.js (NextAuth) | ZenStack",
  "description": "Integrating with Auth.js.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/optimistic-update",
  "markdown": "# Optimistic Update | ZenStack\n\nOptimistic update is a technique that allows us to update the UI immediately after a user action without waiting for the server response. It's a great way to improve the perceived performance of an application and is especially useful for the parts where users interact with the UI frequently.\n\nLibraries like TanStack Query and SWR provides the framework for developers to implement optimistic update. The approach is essentially to update the query cache immediately after the user action and revert or invalidate the cache after the server response comes back (either success or error). However, similar to the query invalidation problem we discussed in the previous chapter, the challenge is identifying which queries need to be updated and how.\n\nZenStack supports automatic optimistic update for the hooks it generates. It uses a set of rules to update queries and aims to cover the most common use cases. You can find more on how it works [here](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#details-of-the-optimistic-behavior).\n\nAutomatic optimistic update is an approximation\n\nIt's often impossible to accurately determine the correct way to update a query cache from the frontend. For example, you may have a query that fetches a filtered list of Todos using the `useFindManyTodo()` hook. When creating a new Todo, we can't precisely determine if the new item should be inserted into the query result (i.e., matching the filter conditions) without querying the database. But paradoxically, the update is no longer optimistic if we query the database.\n\nZenStack takes an \"optimistic\" action here and inserts the new Todo into the query result. It's not always correct, but the worst-case scenario is that the item shows up on the list for a short while until the query is invalidated upon getting the server response.\n\n### üõ†Ô∏è Adding Todo Management[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/optimistic-update#%EF%B8%8F-adding-todo-management \"Direct link to üõ†Ô∏è Adding Todo Management\")\n\nThe main missing part of our sample app is managing Todos in a List. This is a great place to implement optimistic update because users may add, update, or delete Todos in quick paces, and waiting for the server response to update the UI will result in a very sluggish experience.\n\nLet's first implement the Todo management UI without optimistic update. First, create a component `src/components/TodoComponent.tsx` to manage one single Todo:\n\nsrc/components/TodoComponent.tsx\n\n```\nimport type { Todo } from \"@prisma/client\";import { useDeleteTodo, useUpdateTodo } from \"~/lib/hooks\";type Props = {  value: Todo;  optimistic?: boolean;};export default function TodoComponent({ value, optimistic }: Props) {  const update = useUpdateTodo();  const del = useDeleteTodo();  function onDelete() {    del.mutate({ where: { id: value.id } });  }  function onToggleCompleted(completed: boolean) {    if (completed === !!value.completedAt) {      return;    }    update.mutate({      where: { id: value.id },      data: { completedAt: completed ? new Date() : null },    });  }  return (    <div className=\"flex w-96 flex-col items-center rounded-lg border px-8 py-4\">      <div className=\"flex w-full justify-between\">        <h3          className={`flex items-center text-xl                        ${                          value.completedAt                            ? \"italic text-gray-400 line-through\"                            : \"text-gray-700\"                        }                    }`}        >          {value.title}          {optimistic && (            <span className=\"loading loading-spinner loading-sm ml-1\"></span>          )}        </h3>        <div className=\"flex\">          <input            type=\"checkbox\"            className=\"checkbox mr-2\"            checked={!!value.completedAt}            onChange={(e) => onToggleCompleted(e.currentTarget.checked)}          />          <button className=\"btn btn-ghost btn-xs\" onClick={onDelete}>            Delete          </button>        </div>      </div>    </div>  );}\n```\n\nThen, create a page at `src/app/spaces/[slug]/[listId]/page.tsx` to manage Todos in a List:\n\nsrc/app/spaces/\\[slug\\]/\\[listId\\]/page.tsx\n\n```\n\"use client\";import { useSession } from \"next-auth/react\";import { useParams } from \"next/navigation\";import { useState } from \"react\";import TodoComponent from \"~/components/TodoComponent\";import { useCreateTodo, useFindManyTodo, useFindUniqueList } from \"~/lib/hooks\";export default function TodoList() {  const { listId } = useParams<{ listId: string }>();  const { data: session } = useSession();  const { data: list } = useFindUniqueList(    {      where: { id: listId },    },    { enabled: !!session?.user },  );  const { mutate: create } = useCreateTodo();  const { data: todos } = useFindManyTodo(    {      where: { listId },      orderBy: { createdAt: \"desc\" as const },    },    { enabled: !!session?.user },  );  const [title, setTitle] = useState(\"\");  function onCreate() {    create({      data: {        title,        owner: { connect: { id: session?.user.id } },        list: { connect: { id: listId } },      },    });    setTitle(\"\");  }  if (!session?.user || !list) {    return <></>;  }  return (    <div>      <div className=\"container mx-auto flex w-full flex-col items-center py-12\">        <h1 className=\"mb-4 text-2xl font-semibold\">{list.title}</h1>        <div className=\"flex space-x-2\">          <input            type=\"text\"            placeholder=\"Type a title and press enter\"            className=\"input input-bordered mt-2 w-72 max-w-xs\"            value={title}            autoFocus            onKeyUp={(e) => {              if (e.key === \"Enter\") {                onCreate();              }            }}            onChange={(e) => {              setTitle(e.currentTarget.value);            }}          />        </div>        <ul className=\"flex w-auto flex-col space-y-4 py-8\">          {todos?.map((todo) => (            <TodoComponent              key={todo.id}              value={todo}              optimistic={todo.$optimistic}            />          ))}        </ul>      </div>    </div>  );}\n```\n\nTo simulate usage in the real world, I've enabled Chrome's network throttling to \"Fast 3G\" mode. Here's what it looks like:\n\n![Todo management without optimistic update](https://zenstack.dev/assets/images/todo-mgmt-non-optimistic-e9bea05d48adde85d7afa4da60f01bf0.gif)\n\nIt's obviously very sluggish. It's not something a user wants to pay for.\n\nLet's make some small changes to enable automatic optimistic update. In `src/pages/spaces/[slug]/[listId]/index.tsx`, change the `useCreateTodo` call to the following:\n\n```\n// the three arguments are: //     - mutation options//     - auto invalidate (default true)//     - auto optimistic-update (default false)const { mutate: create } = useCreateTodo(undefined, true, true);\n```\n\nAnd likewise, change the `useUpdateTodo` and `useDeleteTodo` calls in `Todo.tsx` to the following:\n\n```\nconst update = useUpdateTodo(undefined, true, true); // optimistic updateconst del = useDeleteTodo(undefined, true, true); // optimistic update\n```\n\nNow, if we repeat the same test with network throttling, we'll see a much better experience:\n\n![Todo management with optimistic update](https://zenstack.dev/assets/images/todo-mgmt-optimistic-7ab48fdba468dbd916e0b9da99cefe22.gif)\n\nOpt-out of automatic optimistic update\n\nWhen you enable automatic optimistic update for a mutation, it applies to all queries that may be impacted. If this is not desirable, you can pass an extra `optimisticUpdate` argument as `false` to opt out of automatic optimistic update. For example:\n\n```\nconst { data: todos } = useFindManyTodo(    { where: { listId } },    { enabled: !!session?.user },    false, // <- opt-out automatic optimistic update);\n```\n\nWith this change, the `useCreateTodo` mutation will not optimistically update this query even if the mutation is set to do so.",
  "title": "Optimistic Update | ZenStack",
  "description": "Optimistic update is a technique that allows us to update the UI immediately after a user action without waiting for the server response. It's a great way to improve the perceived performance of an application and is especially useful for the parts where users interact with the UI frequently.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/invalidation",
  "markdown": "# Automatic Invalidation | ZenStack\n\nData query libraries like TanStack Query and SWR are essentially cache managers. They cache the data fetched from the server, let you bind it to the UI, and allow you to invalidate the query cache when the data is updated.\n\nIn application development, query invalidation is the developers' job. After making a mutation, a developer should know what queries are impacted, compute their keys, and trigger invalidation. For example, after creating a `Todo`, you'll need to remember to invalidate the queries that directly or indirectly fetch a list of Todos. This can be hard to manage when your app gets more complex.\n\nFortunately, ZenStack can fully automate it for you by exploiting an important fact:\n\n> It knows what mutations impact what kind of queries for the hooks it generates.\n\nFor example, when you use `useCreateTodo()` to create a `Todo`, ZenStack can go through the query cache, identify all queries potentially impacted by the mutation, and invalidate them. For example, a query made with:\n\n```\nuseFindManyList({ include: { todos: true } });\n```\n\nwill be invalidated because it fetches a list of Todos with nested reading.\n\nHow ZenStack uses query keys\n\nZenStack uses a quintuple to form a query key:\n\n```\n['zenstack', model, operation, args, flags]\n```\n\n*   `'zenstack'`: a string literal prefix\n*   `model`: the model name, e.g., \"Todo\"\n*   `operation`: the Prisma operation name, e.g., \"findMany\"\n*   `args`: the arguments passed to the operation, e.g., `{ include: { todos: true } }`\n*   `flags`: a set of flags that further defines the query, e.g., if it's an infinite query, etc\n\nYou usually don't need to use query keys directly, but the generated hooks provide a `getQueryKey` helper function to help you compute them.\n\nIn this chapter, we'll add a `Space` and a `List` management UI to our Todo app and see how the automatic invalidation works in action.\n\n### üõ†Ô∏è Adding Space Management[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/invalidation#%EF%B8%8F-adding-space-management \"Direct link to üõ†Ô∏è Adding Space Management\")\n\nWe'll use the homepage to manage spaces. Replace the content of `src/app/page.tsx` with the following:\n\nsrc/app/page.tsx\n\n```\n'use client';import { nanoid } from 'nanoid';import type { NextPage } from 'next';import { signOut, useSession } from 'next-auth/react';import Link from 'next/link';import { useCreateSpace, useFindManySpace } from '~/lib/hooks';const Home: NextPage = () => {  const { data: session } = useSession();  const { mutate: createSpace } = useCreateSpace();  const { data: spaces } = useFindManySpace({ orderBy: { createdAt: 'desc' } });  function onCreateSpace() {    const name = prompt('Enter a name for your space');    if (name) {      createSpace({        data: {          name,          slug: nanoid(6),          owner: { connect: { id: session?.user.id } },          // add the creating user as an admin member          members: {            create: {              user: { connect: { id: session?.user.id } },              role: 'ADMIN',            },          },        },      });    }  }  return (    <div className=\"container mx-auto flex justify-center\">      {session?.user ? (        <div className=\"mt-8 flex w-full flex-col items-center\">          <h1 className=\"text-center text-2xl\">            Welcome {session.user.email}{' '}            <button                className=\"btn btn-ghost btn-xs mt-4\"                onClick={() => signOut({ callbackUrl: '/signin' })}            >              Logout            </button>          </h1>          <div className=\"w-full p-8\">            <h2 className=\"mb-8 text-xl\">              Choose a space to start, or{' '}              <button className=\"btn btn-link p-0 text-xl\" onClick={onCreateSpace}>                create a new one.              </button>            </h2>            <ul className=\"flex gap-4\">              {spaces?.map((space) => (                <Link href={`/spaces/${space.slug}`} key={space.id}>                  <li className=\"flex h-32 w-72 items-center justify-center rounded-lg border text-2xl\">                    {space.name}                  </li>                </Link>              ))}            </ul>          </div>        </div>      ) : (        <div>          Please{' '}          <Link href=\"/signin\">            <button className=\"btn btn-link p-0\">login</button>          </Link>{' '}          to get started        </div>      )}    </div>  );};export default Home;\n```\n\nThe key part is the usage of the `useFindManySpace` query hook and the `useCreateSpace` mutation hook. Some quick notes about the logic:\n\n*   Calling `useFindManySpace` is conceptually equivalent to calling `db.space.findMany()` in the backend. The access policies ensure only the spaces readable to the user are returned.\n    \n*   The `onCreateSpace` function shows the flexibility of the hooks. When creating a space, we make a nested write to create a `SpaceUser` record that adds the user as the admin member of the space. The call is also executed in the backend as a nested write, so the two create operations are atomic.\n    \n\nNow, you can head to the homepage and create a few spaces. The UI should look like this:\n\n![Space management](https://zenstack.dev/assets/images/space-mgmt-8392e76dfb277cae09e35132c0760dd9.png)\n\nYou've probably already noticed this: after creating a space, you don't need to refresh the UI to see the result. ZenStack figures out that the `useCreateSpace` mutation can potentially impact the `useFindManySpace` query and automatically invalidates it.\n\nOpt-out of automatic invalidation\n\nWhen calling a mutation hook, you can pass an extra `invalidateQueries` argument as `false` to opt out of automatic invalidation. For example:\n\n```\nconst { mutate: createSpace } = useCreateSpace(undefined, false);\n```\n\nWith this change, the created space won't appear in the list until you refresh the page.\n\n### üõ†Ô∏è Adding List Management[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part4/invalidation#%EF%B8%8F-adding-list-management \"Direct link to üõ†Ô∏è Adding List Management\")\n\nList management is essentially the same as space, so we'll skip the code walkthrough. Here's the content of `src/app/spaces/[slug]/page.tsx`:\n\nsrc/app/spaces/\\[slug\\]/page.tsx\n\n```\n'use client';import { useSession } from 'next-auth/react';import Link from 'next/link';import { useParams } from 'next/navigation';import { useCreateList, useFindManyList, useFindUniqueSpace } from '~/lib/hooks';export default function SpaceHome() {    const { slug } = useParams<{ slug: string }>();    const { data: session } = useSession();    const { data: space } = useFindUniqueSpace({ where: { slug } }, { enabled: !!session?.user });    const { data: lists } = useFindManyList(        {            where: { space: { slug } },            include: { owner: true },            orderBy: { updatedAt: 'desc' },        },        { enabled: !!session?.user },    );    const { mutate: createList } = useCreateList();    function onCreateList() {        const title = prompt('Enter a title for your list');        if (title) {            createList({                data: {                    title,                    space: { connect: { id: space?.id } },                    owner: { connect: { id: session?.user.id } },                },            });        }    }    if (!session?.user || !space || !lists) return null;    return (        <div className=\"container mx-auto mt-16\">            <h1 className=\"text-center text-3xl\">                Welcome to Space <span className=\"italic\">{space.name}</span>            </h1>            <div className=\"p-8\">                <button className=\"btn btn-primary btn-wide\" onClick={onCreateList}>                    Create a list                </button>                <ul className=\"mt-8 flex flex-wrap gap-6\">                    {lists?.map((list) => (                        <Link href={`/spaces/${slug}/${list.id}`} key={list.id}>                            <li className=\"flex h-32 w-72 items-center justify-center rounded-lg border text-2xl\">                                {list.title}                            </li>                        </Link>                    ))}                </ul>            </div>        </div>    );}\n```\n\nThe result should look like this:\n\n![List management](https://zenstack.dev/assets/images/list-mgmt-85e7f4b0f3f41b3751d283e2cbf83f6e.png)",
  "title": "Automatic Invalidation | ZenStack",
  "description": "Data query libraries like TanStack Query and SWR are essentially cache managers. They cache the data fetched from the server, let you bind it to the UI, and allow you to invalidate the query cache when the data is updated.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/authentication/clerk",
  "markdown": "# Integrating With Clerk | ZenStack\n\n[Clerk](https://clerk.com/) is a comprehensive authentication and user management platform, providing both APIs and pre-made UI components.\n\n### Set up Clerk[‚Äã](https://zenstack.dev/docs/1.x/guides/authentication/clerk#set-up-clerk \"Direct link to Set up Clerk\")\n\nFirst, follow Clerk's [quick start guides](https://clerk.com/docs/quickstarts/overview) to set up your project.\n\n### Adjust your ZModel[‚Äã](https://zenstack.dev/docs/1.x/guides/authentication/clerk#adjust-your-zmodel \"Direct link to Adjust your ZModel\")\n\nSince Clerk manages both user authentication and storage, you don't need to store users in your database anymore. However, since the `auth()` function is resolved to the `User` model in ZModel, you still need to define it in your schema. The trick here is to mark the `User` model as ignored so Prisma doesn't map it to a database table.\n\nYou can include any field you want in the `User` model, as long as you provide the same set of fields in the context object used for creating the enhanced Prisma client.\n\nThe following code shows an example blog post schema:\n\n```\nmodel User {    id String @id    @@ignore}model Post {  id String @id @default(cuid())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title String  published Boolean @default(false)  authorId String // stores Clerk's user ID  // author has full access  @@allow('all', auth() != null && auth().id == authorId)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\nIf you choose to [synchronize user data to your database](https://clerk.com/docs/users/sync-data-to-your-backend), you can model the `User` model as a regular Prisma model without putting the `@@ignore` attribute there.\n\n### Create an enhanced Prisma client[‚Äã](https://zenstack.dev/docs/1.x/guides/authentication/clerk#create-an-enhanced-prisma-client \"Direct link to Create an enhanced Prisma client\")\n\nYou can create an enhanced Prisma client that automatically validates access policies, field validation rules, etc., during CRUD operations. For more details, please refer to [ZModel Language](https://zenstack.dev/docs/1.x/reference/zmodel-language) reference.\n\nTo create such a client with a standard setup, call the `enhance` API with a regular Prisma client and the current user (fetched from Clerk). Here's an example:\n\n```\nimport type { NextApiRequest } from 'next';import { enhance } from '@zenstackhq/runtime';import { getAuth } from '@clerk/nextjs/server';import { prisma } from '../lib/db';async function getPrisma(req: NextApiRequest) {    const auth = getAuth(req);    // create a wrapper of Prisma client that enforces access policy,    // data validation, and @password, @omit behaviors    return enhance(prisma, { user: auth ? { id: auth.userId } : undefined });}\n```\n\n* * *\n\nYou can find a working sample project [here](https://github.com/zenstackhq/docs-tutorial-clerk/tree/v1).",
  "title": "Integrating With Clerk | ZenStack",
  "description": "Integrating with Clerk.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/auth-ui",
  "markdown": "# üõ†Ô∏è Building Authentication UI | ZenStack\n\n```\n'use client';import { signIn } from 'next-auth/react';import Link from 'next/link';import { useState, type FormEvent } from 'react';import { useCreateUser } from '~/lib/hooks';export default function Signup() {  const [email, setEmail] = useState('');  const [password, setPassword] = useState('');  const { mutate: signup, error: signupError } = useCreateUser({    onSuccess: async () => {      // sign-up succeeded, sign in with the credentials      const signInResult = await signIn('credentials', {        redirect: false,        email,        password,      });      if (signInResult?.ok) {        window.location.href = '/';      } else {        console.error('Signin failed:', signInResult?.error);      }    },  });  const _err = signupError as { info?: { code?: string } };  const errMsg = _err    ? _err.info?.code === 'P2002' // P2002 is the Prisma error code for unique constraint failure      ? 'Email already exists'      : `Unexpected error occurred: ${JSON.stringify(_err)}`    : '';  function onSignup(e: FormEvent<HTMLFormElement>) {    e.preventDefault();    signup({ data: { email, password } });  }  return (    <div className=\"mx-auto flex h-screen flex-col items-center justify-center\">      <div className=\"mb-10 flex items-center space-x-4\">        <h1 className=\"text-4xl\">Welcome to Todo</h1>      </div>      <div className=\"flex w-full max-w-screen-sm items-center justify-center rounded-lg\">        <div className=\"w-full space-y-8 p-16\">          <h2 className=\"text-3xl font-bold\">Create a Free Account</h2>          <form className=\"mt-8 space-y-6\" action=\"#\" onSubmit={onSignup}>            <div>              <label htmlFor=\"email\" className=\"label\">                Your email              </label>              <input                type=\"email\"                value={email}                onChange={(e) => setEmail(e.target.value)}                className=\"input input-bordered w-full\"                placeholder=\"Email address\"                required              />            </div>            <div>              <label htmlFor=\"password\" className=\"label\">                Your password              </label>              <input                type=\"password\"                value={password}                onChange={(e) => setPassword(e.target.value)}                placeholder=\"‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢\"                className=\"input input-bordered w-full\"                required              />            </div>            {errMsg && <p className=\"text-sm text-red-600\">{errMsg}</p>}            <button className=\"btn btn-primary mt-4\" type=\"submit\">              Create account            </button>            <div>              Already have an account?{' '}              <Link href=\"/signin\" className=\"text-primary\">                Login here              </Link>            </div>          </form>        </div>      </div>    </div>  );}\n```",
  "title": "üõ†Ô∏è Building Authentication UI | ZenStack",
  "description": "The TanStack Query hooks generated in the previous chapter provide all the data-access building blocks for implementing the UI. Let's first use it to implement the authentication UI.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/authentication/supabase",
  "markdown": "# Integrating With Supabase Auth | ZenStack\n\n[Supabase](https://supabase.com/) is a comprehensive Backend-as-a-Service that offers database, authentication, and blob services.\n\nTo get access policies to work, ZenStack needs to be connected to the authentication system to get the user's identity. If you use Supabase as your authentication provider, this document will guide you through integrating ZenStack with it.\n\n### Using Prisma with Supabase[‚Äã](https://zenstack.dev/docs/1.x/guides/authentication/supabase#using-prisma-with-supabase \"Direct link to Using Prisma with Supabase\")\n\ninfo\n\nThis section is only relevant if you're also using Supabase's Database service as the underlying Postgres database of Prisma/ZenStack.\n\nThis section is not directly to integrating authentication, but since ZenStack is based on Prisma, understanding how Prisma and Supabase should be set up appropriately when Supabase Auth is involved is important.\n\nSupabase Auth stores user data in a separate Postgres schema called \"auth\". Since that schema is managed by Supabase, it's good idea not to directly import it into ZModel and use it in your application, since Supabase team may decide to change table schemas at any time. Instead, a better approach is to define your own `User` model in ZModel, and use database triggers to synchronize user data from Supabase Auth to your `User` table.\n\n**Schema:**\n\nschema.zmodel\n\n```\nmodel User {    id String @id @db.Uuid    posts Post[]    ... // other fields    @@allow('read', true)}model Post {    id String @id @db.Uuid    title String    author User @relation(fields: [authorId], references: [id])    authorId String @db.Uuid    @@allow('all', author == auth())}\n```\n\n**Database trigger (for synchronizing new users):**\n\nYou can check [here](https://supabase.com/docs/guides/database/postgres/triggers) for a general introduction about triggers in Supabase. The following code shows how to use it to synchronize new users:\n\n```\n-- inserts a row into public.\"User\"create function public.handle_new_user()returns triggerlanguage plpgsqlsecurity definer set search_path = publicas $$begin  insert into public.\"User\" (id)  values (new.id);  return new;end;$$;-- trigger the function every time a user is createdcreate trigger on_auth_user_created  after insert on auth.users  for each row execute procedure public.handle_new_user();\n```\n\nSimilarly you can implement more triggers to synchronize user update and delete. Find more information about this approach [here](https://supabase.com/docs/guides/auth/managing-user-data#using-triggers).\n\nWith these in place, your own `User` table will be always in sync with Supabase Auth, and in your application, your other entities will have relations to the `User` table instead of pointing to Supabase Auth's internal tables.\n\n### Creating an enhanced Prisma client[‚Äã](https://zenstack.dev/docs/1.x/guides/authentication/supabase#creating-an-enhanced-prisma-client \"Direct link to Creating an enhanced Prisma client\")\n\nTo get ZenStack's access policies to work, you need to create an enhanced `PrismaClient` with a current user context. The way to fetch \"current user\" on the server side depends on the type of server you're using. Supabase provides a set of [auth helpers](https://supabase.com/docs/guides/auth/auth-helpers) for different frameworks. For example, if you're following [this guide](https://supabase.com/docs/guides/auth/auth-helpers/nextjs) to use Supabase Auth with Next.js (app router), you can create an enhanced `PrismaClient` using `@supabase/auth-helpers-nextjs` like the following:\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';import { prisma } from '@lib/db';// create a wrapper of Prisma client that enforces access policy,// data validation, and @password, @omit behaviorsasync function getPrisma() {    const supabase = createRouteHandlerClient({ cookies });    const { data: user } = await supabase.auth.getUser();    const uid = user.user?.id;    // TODO: if you need to access fields other than just \"id\" in access policies,     // you can do a database query here to fetch the full user record    const contextUser = uid ? { id: uid } : undefined;    return enhance(prisma, { user: contextUser });}\n```\n\nYou can then use this enhanced Prisma client for CRUD operations that you desire to be governed by the access policies you defined in your data models.\n\nNext, make sure to read [this guide](https://zenstack.dev/docs/1.x/guides/supabase-security) to ensure your database is securely protected from HTTP requests to the supabase API.",
  "title": "Integrating With Supabase Auth | ZenStack",
  "description": "Integrating with Supabase Auth.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/api-flavor/",
  "markdown": "# API Flavors | ZenStack\n\nVersion: 1.x\n\nAPI design is a complex topic. While thinking about wrapping CRUD APIs around ORM, we feel there are two main competing goals:\n\n*   Query flexibility\n    \n    Prisma's API is very flexible, especially regarding nested reads and writes. It'd be nice to preserve this flexibility fully in the derived APIs. This way, you can also carry your knowledge of using Prisma over to using the APIs.\n    \n*   RESTfulness\n    \n    When designing CRUD APIs, making it RESTful is a natural choice. Resource-oriented URLs and semantic HTTP verbs match the problem well. While RESTful APIs traditionally suffer from the [N + 1 Problem](https://restfulapi.net/rest-api-n-1-problem/) (as traditionally ORM did, too), there are some conventions we can use to mitigate it.\n    \n\nIt is tough to choose one over the other. So, we decided to provide both API flavors. You can choose the one that fits your use case better.\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "API Flavors | ZenStack",
  "description": "API design is a complex topic. While thinking about wrapping CRUD APIs around ORM, we feel there are two main competing goals:",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/authentication/auth0",
  "markdown": "# üöß Integrating With Auth0 | ZenStack\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "üöß Integrating With Auth0 | ZenStack",
  "description": "Integrating with Auth0.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/api-flavor/1.1-rpc",
  "markdown": "# RPC Flavor API | ZenStack\n\nThe RPC flavor of API is designed to fully preserve Prisma's query API for both its input and output format. The name \"RPC\" indicates it's literally like remote procedure calls into a Prisma Client. This API flavor is a good choice if you want to expose Prisma's full power and familiar query syntax to your frontend and care less about API taxonomy.\n\n```\n// find all postsGET /api/model/post/findMany=> [{ id: 1, title: 'Hello World', ... }, ...}]// find all published posts, the \"q\" parameter is `{\"where\":{\"published\":true}}` url-encodedGET /api/model/post/findMany?q=%7B%22where%22%3A%7B%22published%22%3Atrue%7D%7D=> [{ id: 1, title: 'Hello World', ... }, ...}]// find all posts with their authors, the \"q\" parameter is `{\"include\":{\"author\":true}}` url-encodedGET /api/model/post/findMany?q=%7B%22include%22%3A%7B%22author%22%3Atrue%7D%7D=> [{ id: 1, title: 'Hello World', author: { id: 1, name: 'Joey', ... } }, ...}]// create a post for user#1POST /api/model/post/create{    \"data\": {        \"title\": \"Hello World\",        \"author\": { \"connect\": { \"id\": 1 } }    }}// update a postPOST /api/model/post/update{    \"where\": { \"id\": 1 },    \"data\": { \"title\": \"Hello New World!\" }}// delete a postDELETE /api/model/post/delete{    \"where\": { \"id\": 1 }}\n```\n\nIn [Part IV](https://zenstack.dev/docs/the-complete-guide/part4/) of this guide, you'll see how to use the auto-generated frontend data query hooks to consume the API, so you don't need to construct the HTTP calls manually.",
  "title": "RPC Flavor API | ZenStack",
  "description": "The RPC flavor of API is designed to fully preserve Prisma's query API for both its input and output format. The name \"RPC\" indicates it's literally like remote procedure calls into a Prisma Client. This API flavor is a good choice if you want to expose Prisma's full power and familiar query syntax to your frontend and care less about API taxonomy.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/guides/authentication/lucia",
  "markdown": "# üöß Integrating With Lucia | ZenStack\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "üöß Integrating With Lucia | ZenStack",
  "description": "Integrating with Lucia.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/api-flavor/1.3-api-handler",
  "markdown": "# API Handlers | ZenStack\n\nAlthough many different backend and full-stack frameworks exist in the Javascript world, how APIs are designed is entirely independent. We've implemented the API flavors as framework-agnostic API handlers. They take canonical input (HTTP verb, URL, body, etc.) and generate canonical output (status code and body).\n\nThe server adapters, as we will see in the next chapter, are responsible for dealing with the framework details and handling the transformation between the framework-specific request/response and the canonical format. If, in the future, we want to introduce a new API flavor, we don't need to change the server adapters.\n\nThe following diagram depicts the relationship between the API handlers and the server adapters:\n\n![ZModel Generation](https://zenstack.dev/img/intro/api-handler-light.png)![ZModel Generation](https://zenstack.dev/img/intro/api-handler-dark.png)",
  "title": "API Handlers | ZenStack",
  "description": "Although many different backend and full-stack frameworks exist in the Javascript world, how APIs are designed is entirely independent. We've implemented the API flavors as framework-agnostic API handlers. They take canonical input (HTTP verb, URL, body, etc.) and generate canonical output (status code and body).",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/api-flavor/1.2-rest",
  "markdown": "# RESTful Flavor API | ZenStack\n\nThe RESTful flavor of API is designed to rigorously follow the RESTful conventions - resources, verbs, and links for further navigation based on the result dataset. It's a good choice if you want to expose a formal RESTful API to your client. The API adopts [JSON:API](https://jsonapi.org/format/) as data format.\n\n```\n// find all postsGET /api/model/post=> {    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        { \"type\": \"post\", \"id\": \"1\", \"attributes\": { \"title\": \"Hello World\", ... }, ... },        ...    ],    ...}// find all published postsGET /api/model/post?filter[published]=true=>{    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        { \"type\": \"post\", \"id\": \"1\", \"attributes\": { \"title\": \"Hello World\", ... }, ... },        ...    ],    ...}// find all posts with their authorsGET /api/model/post?include=author=>{    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        {             \"type\": \"post\",             \"id\": \"1\",             \"attributes\": { \"title\": \"Hello World\", ... },            \"relationships\": {                \"author\": { \"data\": { \"type\": \"user\", \"id\": \"1\" } }            }        },        ...    ],    \"included\": [        { \"type\": \"user\", \"id\": \"1\", \"attributes\": { \"name\": \"Joey\", ... } },        ...    ],    ...}// create a post for user#1POST /api/model/post{    \"data\": {        \"type\": \"post\",        \"attributes\": {            \"title\": \"Hello World\"        },        \"relationships\": {            \"author\": { \"data\": { \"type\": \"user\", \"id\": \"1\" } }        }    }}// update a postPATCH /api/model/post/1{    \"data\": {        \"type\": \"post\",        \"id\": \"1\",        \"attributes\": {            \"title\": \"Hello New World!\"        }    }}// delete a postDELETE /api/model/post/1\n```",
  "title": "RESTful Flavor API | ZenStack",
  "description": "The RESTful flavor of API is designed to rigorously follow the RESTful conventions - resources, verbs, and links for further navigation based on the result dataset. It's a good choice if you want to expose a formal RESTful API to your client. The API adopts JSON:API as data format.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/api-flavor/1.1-rpc",
  "markdown": "# RPC Flavor API | ZenStack\n\nThe RPC flavor of API is designed to fully preserve Prisma's query API for both its input and output format. The name \"RPC\" indicates it's literally like remote procedure calls into a Prisma Client. This API flavor is a good choice if you want to expose Prisma's full power and familiar query syntax to your frontend and care less about API taxonomy.\n\n```\n// find all postsGET /api/model/post/findMany=> [{ id: 1, title: 'Hello World', ... }, ...}]// find all published posts, the \"q\" parameter is `{\"where\":{\"published\":true}}` url-encodedGET /api/model/post/findMany?q=%7B%22where%22%3A%7B%22published%22%3Atrue%7D%7D=> [{ id: 1, title: 'Hello World', ... }, ...}]// find all posts with their authors, the \"q\" parameter is `{\"include\":{\"author\":true}}` url-encodedGET /api/model/post/findMany?q=%7B%22include%22%3A%7B%22author%22%3Atrue%7D%7D=> [{ id: 1, title: 'Hello World', author: { id: 1, name: 'Joey', ... } }, ...}]// create a post for user#1POST /api/model/post/create{    \"data\": {        \"title\": \"Hello World\",        \"author\": { \"connect\": { \"id\": 1 } }    }}// update a postPOST /api/model/post/update{    \"where\": { \"id\": 1 },    \"data\": { \"title\": \"Hello New World!\" }}// delete a postDELETE /api/model/post/delete{    \"where\": { \"id\": 1 }}\n```\n\nIn [Part IV](https://zenstack.dev/docs/1.x/the-complete-guide/part4/) of this guide, you'll see how to use the auto-generated frontend data query hooks to consume the API, so you don't need to construct the HTTP calls manually.",
  "title": "RPC Flavor API | ZenStack",
  "description": "The RPC flavor of API is designed to fully preserve Prisma's query API for both its input and output format. The name \"RPC\" indicates it's literally like remote procedure calls into a Prisma Client. This API flavor is a good choice if you want to expose Prisma's full power and familiar query syntax to your frontend and care less about API taxonomy.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/the-complete-guide/part3/api-flavor/1.3-api-handler",
  "markdown": "# API Handlers | ZenStack\n\nAlthough many different backend and full-stack frameworks exist in the Javascript world, how APIs are designed is entirely independent. We've implemented the API flavors as framework-agnostic API handlers. They take canonical input (HTTP verb, URL, body, etc.) and generate canonical output (status code and body).\n\nThe server adapters, as we will see in the next chapter, are responsible for dealing with the framework details and handling the transformation between the framework-specific request/response and the canonical format. If, in the future, we want to introduce a new API flavor, we don't need to change the server adapters.\n\nThe following diagram depicts the relationship between the API handlers and the server adapters:\n\n![ZModel Generation](https://zenstack.dev/img/intro/api-handler-light.png)![ZModel Generation](https://zenstack.dev/img/intro/api-handler-dark.png)",
  "title": "API Handlers | ZenStack",
  "description": "Although many different backend and full-stack frameworks exist in the Javascript world, how APIs are designed is entirely independent. We've implemented the API flavors as framework-agnostic API handlers. They take canonical input (HTTP verb, URL, body, etc.) and generate canonical output (status code and body).",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/debugging",
  "markdown": "# Debugging | ZenStack\n\nVersion: 1.x\n\nZenStack provides you with a set of powerful tools to model the authorization aspects of your application. However, it can be challenging to understand why an operation is rejected or why a query gives seemingly incorrect results.\n\nYou can let ZenStack log all queries sent to the wrapped Prisma Client and use it to inspect the effect of your policy rules. To enable the logging, pass an extra `logPrismaQuery` option when calling the `enhance` function:\n\n```\nconst db = enhance(prisma, { user }, { logPrismaQuery: true });\n```\n\nThe logs are output to the logger of Prisma Client with \"info\" level, so to be able to see it on the console, you'll also need to make sure it's turned on in the Prisma Client options:\n\n```\nconst prisma = new PrismaClient({ log: ['info'] });\n```\n\nAfter setting these up, you should be able to see all Prisma queries ZenStack makes in the console.\n\n### üõ†Ô∏è Debugging In REPL[‚Äã](https://zenstack.dev/docs/1.x/the-complete-guide/part1/debugging#%EF%B8%8F-debugging-in-repl \"Direct link to üõ†Ô∏è Debugging In REPL\")\n\nThe REPL environment provides a \".debug\" command to turn on/off debugging output on the fly.\n\n```\n.auth { id: 1 }.debugdb.list.findMany()\n```\n\nYou should see the Prisma queries injected by ZenStack printed in the console.\n\n```\nprisma:info [policy] `findMany` list:{  where: {    AND: [      { NOT: { OR: [] } },      {        OR: [          { owner: { is: { id: 1 } } },          {            AND: [              {                space: {                  members: {                    some: { user: { is: { id: 1 } } }                  }                }              },              { NOT: { private: true } }            ]          }        ]      }    ]  }}\n```\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
  "title": "Debugging | ZenStack",
  "description": "ZenStack provides you with a set of powerful tools to model the authorization aspects of your application. However, it can be challenging to understand why an operation is rejected or why a query gives seemingly incorrect results.",
  "languageCode": "en"
},
{
  "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/api-flavor/1.2-rest",
  "markdown": "# RESTful Flavor API | ZenStack\n\nThe RESTful flavor of API is designed to rigorously follow the RESTful conventions - resources, verbs, and links for further navigation based on the result dataset. It's a good choice if you want to expose a formal RESTful API to your client. The API adopts [JSON:API](https://jsonapi.org/format/) as data format.\n\n```\n// find all postsGET /api/model/post=> {    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        { \"type\": \"post\", \"id\": \"1\", \"attributes\": { \"title\": \"Hello World\", ... }, ... },        ...    ],    ...}// find all published postsGET /api/model/post?filter[published]=true=>{    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        { \"type\": \"post\", \"id\": \"1\", \"attributes\": { \"title\": \"Hello World\", ... }, ... },        ...    ],    ...}// find all posts with their authorsGET /api/model/post?include=author=>{    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        {             \"type\": \"post\",             \"id\": \"1\",             \"attributes\": { \"title\": \"Hello World\", ... },            \"relationships\": {                \"author\": { \"data\": { \"type\": \"user\", \"id\": \"1\" } }            }        },        ...    ],    \"included\": [        { \"type\": \"user\", \"id\": \"1\", \"attributes\": { \"name\": \"Joey\", ... } },        ...    ],    ...}// create a post for user#1POST /api/model/post{    \"data\": {        \"type\": \"post\",        \"attributes\": {            \"title\": \"Hello World\"        },        \"relationships\": {            \"author\": { \"data\": { \"type\": \"user\", \"id\": \"1\" } }        }    }}// update a postPATCH /api/model/post/1{    \"data\": {        \"type\": \"post\",        \"id\": \"1\",        \"attributes\": {            \"title\": \"Hello New World!\"        }    }}// delete a postDELETE /api/model/post/1\n```",
  "title": "RESTful Flavor API | ZenStack",
  "description": "The RESTful flavor of API is designed to rigorously follow the RESTful conventions - resources, verbs, and links for further navigation based on the result dataset. It's a good choice if you want to expose a formal RESTful API to your client. The API adopts JSON:API as data format.",
  "languageCode": "en"
}]