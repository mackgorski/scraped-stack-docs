er {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"name\\\": \\\"Mobile SMS\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"\n\n\tpayload := strings.NewReader(\"{ \\\"name\\\": \\\"Mobile SMS\\\" }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"name\\\": \\\"Mobile SMS\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {name: 'Mobile SMS'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"name\": @\"Mobile SMS\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"name\\\": \\\"Mobile SMS\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"name\\\": \\\"Mobile SMS\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"PATCH\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"name\\\": \\\"Mobile SMS\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\"name\": \"Mobile SMS\"] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"phone\",\n    \"name\": \"Mobile SMS\",\n    \"created_at\": \"2023-01-12T00:03:52.855Z\",\n    \"last_auth_at\": \"2023-01-12T00:04:05.157Z\",\n    \"phone_number\": \"+00000000000\",\n    \"preferred_authentication_method\": \"sms\",\n    \"id\": \"phone|dev_XXXXXXXXXXXXXXXX\",\n    \"authentication_methods\": [\n        {\n            \"id\": \"phone|dev_XXXXXXXXXXXXXXXX\",\n            \"type\": \"phone\"\n        }\n    ]\n}\n```\n\n## Delete all authentication methods\n\nUse the [Deletes all authentication methods for the given user](https://auth0.com/docs/api/management/v2#!/Users/delete_authentication_methods) endpoint to delete all authentication methods for a user.\n\nThis endpoint requires the scope: `delete:authentication_methods`.\n\n### Examples\n\nThe following request deletes all authentication methods for a user.\n\n*   [cURL](#b409083687be45958d52693e29e96da4_shell)\n*   [C#](#b409083687be45958d52693e29e96da4_csharp)\n*   [Go](#b409083687be45958d52693e29e96da4_go)\n*   [Java](#b409083687be45958d52693e29e96da4_java)\n*   [Node.JS](#b409083687be45958d52693e29e96da4_node)\n*   [Obj-C](#b409083687be45958d52693e29e96da4_objc)\n*   [...](#)\n\n```\ncurl --request DELETE \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"DELETE\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response with a `204` status code and empty body.\n\n## Delete a single authentication method\n\nUse the [Deletes an authentication method by ID](https://auth0.com/docs/api/management/v2#!/Users/delete_authentication_methods_by_authentication_method_id) endpoint to delete a single authentication method for a user.\n\n### Examples\n\nThe following request deletes a single authentication method for a user based on the specified authentication method's ID.\n\n*   [cURL](#91c40f52334743998b02ee2c7a3ea8a5_shell)\n*   [C#](#91c40f52334743998b02ee2c7a3ea8a5_csharp)\n*   [Go](#91c40f52334743998b02ee2c7a3ea8a5_go)\n*   [Java](#91c40f52334743998b02ee2c7a3ea8a5_java)\n*   [Node.JS](#91c40f52334743998b02ee2c7a3ea8a5_node)\n*   [Obj-C](#91c40f52334743998b02ee2c7a3ea8a5_objc)\n*   [...](#)\n\n```\ncurl --request DELETE \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"DELETE\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response with a `204` status code and empty body.\n\n## Learn more\n\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)\n*   [Register Machine-to-Machine Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications)",
  "title": "Manage Authentication Methods with Management API",
  "description": "Learn how to use the Auth0 Management API to manage MFA authentication methods for your users.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/update-ad-ldap-connectors",
  "markdown": "# Update AD/LDAP Connectors\n\nIf there are multiple instances of the AD/LDAP Connector in your deployment, Auth0 recommends that you perform the steps below for each instance one at a time, so that only one instance is down at any point.\n\n## Admin console (Windows)\n\n1.  Open the Admin Console by navigating to [http://localhost:8357/](http://localhost:8357/). If the Admin Console has outbound access to the internet it will verify if a new version is available and show this on top of the page:\n    \n    ![Update AD/LDAP Connectors Admin Console Screen](https://images.ctfassets.net/cdy7uua7fh8z/6Yp2uRnEU3RMeCqgHa6Ztl/b9c04ab83b9fd725910291b01ac9d05d/connector-update-available.png)\n2.  Go to the **Update** tab to update the installation on the current machine to the latest version. The update will take about 2 minutes and the updater logs will be displayed in the Admin Console.\n    \n\n## Updater script (Windows)\n\nThe updater script will update the AD/LDAP Connector from the command line by running the following steps:\n\n1.  Verify if an update is available.\n    \n2.  Backup the existing configuration, certificates and profileMapper.js.\n    \n3.  Uninstall the AD/LDAP Connector.\n    \n4.  Download the update.\n    \n5.  Install the AD/LDAP Connector.\n    \n6.  Restore the existing configuration, certificates and profileMapper.js.\n    \n7.  Start the Windows Service.\n    \n8.  To run the updater script execute the following statement in the command line: `@powershell -NoProfile -ExecutionPolicy Bypass -Command \"iex ((new-object net.webclient).DownloadString('https://cdn.auth0.com/connector/windows/update-connector.ps1'))\"`\n    \n\nThe updater script uses specific PowerShell commands that are only available in Windows PowerShell 3.0 and higher. If you're running on Windows 2008 and Windows 2008 R2 you might need to update your [](https://www.microsoft.com/en-us/download/details.aspx?id=34595)PowerShell version first.\n\nTo learn more, see [Download Window Management Framework](https://www.microsoft.com/en-us/download/details.aspx?id=34595).\n\n## Manual update (Windows/Linux)\n\n1.  Verify the version you have installed. Hover over the Connector status indicator on the console. The tooltip will indicate the current status and the installed version.\n    \n2.  Download the latest version of the [installer](https://cdn.auth0.com/connector/windows/adldap-5.0.10.msi?_ga=2.58973869.1675886805.1589821069-1123834949.1586212750). Use the GitHub repository [version](https://github.com/auth0/ad-ldap-connector/releases/tag/v5.0.10) for other platforms.\n    \n3.  Backup your current configuration from the Admin Console or manually.\n    \n    1.  From the Admin Console, click the **Download** button to generate a .zip file which contains the `config.json` file, the `certs` folder and the `lib\\\\profileMapper.js` file.\n        \n    2.  To do it manually, backup the same files listed above from `%Program Files(x86)%\\Auth0\\AD LDAP Connector\\` folder. The path works for Windows. Files in other platforms may be located somewhere else but will contain the same assets.\n        \n4.  Run the installer and follow the instructions.\n    \n5.  Close the Configuration dialog without changing anything.\n    \n6.  Restore files from the Admin Console or manually.\n    \n    1.  From the Admin Console, upload the .zip file on the **Import / Export** tab.\n        \n    2.  To do it manually, copy the files you backed up previously.\n        \n7.  Restart the **Auth0 AD LDAP** service from the service console.",
  "title": "Update AD/LDAP Connectors",
  "description": "Learn how to update AD/LDAP Connectors.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/disable-credential-caching",
  "markdown": "# Disable AD/LDAP Connection Credential Caching\n\nWas this article helpful?",
  "title": "Disable AD/LDAP Connection Credential Caching",
  "description": "Learn how to disable credential caching at the connection level for an AD/LDAP enterprise connection using the Auth0 Management Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability",
  "markdown": "# Deploy AD/LDAP Connectors for High Availability Environments\n\nYou can deploy multiple instances of the AD/LDAP Connector to provide a high-availability environment for your AD/LDAP connection.\n\n## Overview\n\nTo deploy multiple instances of the AD/LDAP Connector, you'll need to:\n\n1.  Install the AD/LDAP Connector on the primary server.\n    \n2.  Copy or export the configuration files of the initial installation.\n    \n3.  Install the AD/LDAP Connector on additional servers.\n    \n4.  Import the configuration files from the initial installation to the additional connectors.\n    \n\n## Configure primary server\n\n1.  Install and configure the AD/LDAP Connector on the first server.\n    \n2.  Open the troubleshooting screen ([http://localhost:8357/#troubleshoot](http://localhost:8357/#troubleshoot)) and run the troubleshooting test. Make sure all tests pass.\n    \n    | Test | Description | Troubleshoot |\n    | --- | --- | --- |\n    | Test 1 | Attempts to establish a TCP connection to the LDAP server and port specified. | Check basic network connectivity and firewall settings that might prevent such a connection. |\n    | Test 2 | Attempts to perform an LDAP bind on the LDAP server and port specified and with the username and password provided. | Check the LDAP connection string, search path, username and password. |\n    | Test 3 | Attempts to perform an LDAP search against the directory to check the privileges of the specified username. | Check the privileges of the username in the target directory. |\n    | Test 4 | Attempts to establish a connection to the Auth0 server. | Check network connectivity and firewall settings that might prevent such a connection. |\n    \n3.  Copy or export the configuration files.\n    \n\n## Configure additional server(s)\n\n1.  Install the AD/LDAP Connector on the additional server(s), but do not configure it.\n    \n2.  Import the configuration files from the primary server.\n    \n3.  Restart the Auth0 AD/LDAP and Auth0 AD/LDAP Admin Windows Services on the new server(s).\n    \n4.  Open the troubleshooting screen ([http://localhost:8357/#troubleshoot](http://localhost:8357/#troubleshoot)) and run the troubleshooting test. Make sure all tests pass.\n    \n\nTo learn more, read [Install and Configure the AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector) and [Import and Export AD/LDAP Connector Configurations](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/import-export-ad-ldap-connector-configs).\n\n## Verify connections\n\nIn the Auth0 Dashboard, go to the [Authentication > Enterprise > Active Directory / LDAP](https://manage.auth0.com/#/connections/enterprise/ad), and confirm that the connection is active.\n\nIf you are encountering issues getting your connection online, read [Troubleshoot AD/LDAP Connector](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-ad-ldap-connector).\n\n## Using Kerberos or client certificates\n\nIf you enable Kerberos or client certificates for authentication on your AD/LDAP connection, users contact the AD/LDAP Connector directly instead of going through the Auth0 server.\n\nIf you are using a high-availability configuration with multiple connectors, Auth0 recommends that you front them with a network load balancer:\n\n1.  Use the `SERVER_URL` parameter to publish the public location where the AD/LDAP Connector will be listening to incoming requests.\n    \n2.  Map the `SERVER_URL` in the network load balancer to all internal instances of the deployed AD/LDAP Connectors. A special distribution policy is not required (for example, uniform round-robin with no sticky sessions works).\n    \n\nTo learn more, read [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos) or [Configure AD/LDAP Connector Authentication with Client Certificates](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates).\n\n## Learn more\n\n*   [Install and Configure AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector)\n*   [Import and Export AD/LDAP Connector Configurations](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/import-export-ad-ldap-connector-configs)\n*   [Configure AD/LDAP Connector Authentication with Client Certificates](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates)\n*   [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos)\n*   [Point AD/LDAP Connector to Auth0 Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-to-auth0)\n*   [Update AD/LDAP Connectors](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/update-ad-ldap-connectors)",
  "title": "Deploy AD/LDAP Connectors for High Availability Environments",
  "description": "Describes how to install multiple instances of the connector for higher availability.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-scom",
  "markdown": "# Monitor AD/LDAP Connector with System Center Operations Manager\n\nThe Auth0 AD/LDAP connector can run as a service on Windows-based machines.\n\nYou can monitor the service status using System Center as you would do with any other service.\n\n1.  Open the **Add Monitoring Wizard** and select the **Monitoring Type: Windows Service**:\n    \n    ![Monitor AD/LDAP Connector Wizard Screen 1](https://images.ctfassets.net/cdy7uua7fh8z/6234mP3Hx1g3Iwf7y9mKH9/7a2ac217f7d22070c20a769939461f75/ss-2014-12-11T22-48-51.png)\n2.  Enter a name and description:\n    \n    ![Monitor AD/LDAP Connector Wizard Screen 2](https://images.ctfassets.net/cdy7uua7fh8z/2KZkQoBuubAgAEWBPnkJx0/abdcdf5e1e0fad20829b255401db523f/ss-2014-12-11T22-49-57.png)\n3.  Select the Server in which the AD/LDAP Connector is installed and then choose **Auth0 ADLDAP**:\n    \n    ![Monitor AD/LDAP Connector Wizard Screen 3](https://images.ctfassets.net/cdy7uua7fh8z/DOQHiJYYiJKZrWzHYUIiB/21eae1ad8435a0754c6e221d5e33bab5/ss-2014-12-11T22-50-37.png)\n4.  Select the limits of **CPU** and **Memory limits**. For example, 10% of CPU and 200MB of RAM are good limits to trigger alerts.\n    \n\nWe also recommend that you set up a synthetic transaction to monitor end-to-end authentication.\n\nTo learn more, see [Monitor Auth0 Using SCOM](https://auth0.com/docs/deploy-monitor/monitor/monitor-using-scom).\n\n## Learn more\n\n*   [Monitor Auth0 Using System Center Operations Manager](https://auth0.com/docs/deploy-monitor/monitor/monitor-using-scom)",
  "title": "Monitor AD/LDAP Connector with System Center Operations Manager",
  "description": "Describes how to monitor the AD/LDAP Connector with System Center Operations Manager (SCOM).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-test-environment",
  "markdown": "# Set Up AD/LDAP Connector Test Environment\n\nYou can set up a test environment by creating a minimal AD Domain Controller installation on a cloud-deployed virtual machine (VM). You can run your VM on any cloud platform. This example shows how to set one up on Microsoft Azure.\n\n1.  Create a virtual machine on the [Azure Management](https://azure.microsoft.com/en-us/features/azure-portal/) console.\n    \n2.  Click on the **ENDPOINTS** tab of the new VM, and take note of the **PUBLIC PORT** for the **Remote Desktop** endpoint.\n    \n3.  Open up Microsoft Remote Desktop client (Windows or Mac) or the client of your choice (such as [rdesktop](http://www.rdesktop.org/) for Linux systems). Create a new connection to your VM.\n    \n4.  Open the connection, disregarding any certificate warnings presented by the Remote Desktop client. If you're prompted to find PC's, devices, and content on the local network, choose **No**.\n    \n5.  Click the PowerShell icon in the Windows Task Bar to open the **PowerShell Command Prompt**. Install ADDS.\n    \n6.  Promote the server to a domain controller that manages a FQDN of `mycompany.local`.\n    \n7.  When prompted for the **SafeModeAdministratorPassword**, enter the Administrator password you used when creating the VM. Click Enter to continue. The promotion script will run and the VM will automatically reboot.\n    \n8.  Add test groups and users. Log into VM using the Remote Desktop client and open the PowerShell Command Prompt. Run the following script:\n    \n    ```\n    > New-ADGroup -Name \"Accounting\" -GroupScope \"DomainLocal\"\n        > New-ADGroup -Name \"IT\" -GroupScope \"DomainLocal\"\n        \n        > New-ADUser -GivenName Bob -Surname Johnson -Name \"Bob Johnson\" -SamAccountName bob.johnson -Enabled $True -AccountPassword (ConvertTo-SecureString \"Pass@word1!\" -AsPlainText -force) -PasswordNeverExpires $True\n        > New-ADUser -GivenName Mary -Surname Smith -Name \"Mary Smith\" -SamAccountName mary.smith -Enabled $True -AccountPassword (ConvertTo-SecureString \"Pass@word1!\" -AsPlainText -force) -PasswordNeverExpires $True\n        \n        > Add-ADGroupMember -Identity Accounting -Members \"bob.johnson\", \"mary.smith\"\n        > Add-ADGroupMember -Identity IT -Members \"mary.smith\"\n    ```\n    \n\n## Install and configure AD/LDAP Connector\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and create a new **Active Directory/LDAP** connection with the name `auth0-test-ad`. Be sure to copy the **Ticket URL** that is generated at the end of those instructions.\n    \n2.  On the VM, disable **Internet Explorer Enhanced Security Configuration**.\n    \n3.  Open **Internet Explorer** with the **Ticket URL** you saved in step 1.\n    \n4.  Follow the instructions in the browser to download, install, and configure the **Connector**. When you are prompted for the LDAP service account, use the admin account you created for the VM: **Username**: `mycompany\\ad-admin,` **Pas**sword: (same as before).\n    \n5.  When you're done configuring and installing the Connector, reboot the server.\n    \n6.  Log back into the VM using Remote Desktop.\n    \n7.  Open the Connector configuration site by navigating to `http://localhost:8357/`.\n    \n8.  Check that the **Connector** is able to find a user:\n    \n    1.  Click on the **Search** tab.\n        \n    2.  Under \"Find User by Login\", type `mary.smith`.\n        \n    3.  Click **Search**. You should get JSON back that contains that user's AD profile data:\n        \n\n## Test authentication from Auth0\n\nTo ensure that everything is working using your Auth0 account, we're going to configure your **Default App** in Auth0 to use your new **Active Directory / LDAP** Connection, and use the `/authorize` endpoint to initiate an authentication flow.\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Click the **Settings** icon of your **Default App**.\n    \n3.  Add `http://jwt.io` to the list of the Application's **Allowed Callback URLs**.\n    \n4.  Click the **Connections** tab.\n    \n5.  Under **Enterprise**, enable the `auth0-test-ad` **Active Directory / LDAP** connection.\n    \n6.  Test the authentication flow by opening the following link in your browser:\n    \n    ```\n    https://{yourDomain}/authorize?response_type=token&scope=openid%20profile&client_id={yourClientId}&redirect_uri=http://jwt.io&connection=auth0-test-ad\n    ```\n    \n7.  Log in with one of the test users that was created in the directory:\n    \n    *   Username: `mary.smith` or `bob.johnson`\n        \n    *   Password: `Pass@word1!`\n        \n8.  If everything is working, you should be redirected to the JWT.io website to see the contents of the resulting JWT.",
  "title": "Set Up AD/LDAP Connector Test Environment",
  "description": "Describes how to create and test an Active Directory Domain Controller.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory-native",
  "markdown": "# Connect Your Native App to Microsoft Azure Active Directory Using Resource Owner Flow\n\nIn addition to the WS-Federation and OpenID Connect flows, it's also possible to use the [Resource Owner](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) flow with Azure AD. This flow allows you to capture and validate a user's credentials (email and password) instead of showing the Azure AD login page. For security and Single Sign-on (SSO) reasons, this is not the recommended approach; still, the Resource Owner flow can be useful in Native mobile scenarios or to batch-process authentication with Azure AD.\n\nThis configuration requires two applications: a Web Application and/or Web API, and a Native Application. From Azure AD's point of view, users will be authenticated using the Native Application to gain access to the Web Application and/or Web API.\n\n![Overview Diagram of Azure AD Apps using Resource Owner flow](https://images.ctfassets.net/cdy7uua7fh8z/6Uy9Q35rn0d9rankvlJuBT/6a5fa5175db76fd1cab35b79f0a213ea/azure-ad-native-app.png)\n\n## Prerequisites\n\n[Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications):\n\n1.  Select **Native** for the **Application Type**.\n    \n2.  Add an **Allowed Callback URL**. Your callback URL format will vary depending on your platform. For details about the format for your platform, see our [Native Quickstarts](https://auth0.com/docs/quickstart/native).\n    \n3.  Ensure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n    \n\n## Steps\n\nTo connect your application using Resource Owner flow, you must:\n\n1.  [Set up your applications in the Microsoft Azure portal](#set-up-your-applications-in-the-microsoft-azure-portal).\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0).\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application).\n    \n4.  [Test the connection](#test-the-connection).\n    \n\n## Set up your applications in the Microsoft Azure portal\n\n### Register a new web application\n\nTo learn how to register your application with Azure AD, read [Quickstart: Register an application with the Microsoft identity platform on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n\nWhile setting up your application, make sure you use the following settings:\n\n*   If you want to allow users from external organizations (like other Azure AD directories), select **Accounts in any organizational directory (Any Azure AD directory - Multitenant)** when setting **Supported account types**.\n    \n*   When asked to set a **Redirect URI**, select **Web** and enter your callback URL: `https://{yourDomain}/login/callback`.\n    \n\n#### Find your Auth0 domain name for redirects\n\nIf your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n\nFor example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n\nHowever, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n\nIf you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n\nDuring this process, record the **Application (client) ID** that Microsoft generates for your application (you can find this on the application's **Overview** screen) as you will need it later in the tutorial.\n\n### Configure your web application to expose an API\n\nTo learn how to configure your Web application to expose an API with Azure AD, read [Quickstart: Configure an application to expose web APIs on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-expose-web-apis).\n\nWhile configuring your app, make sure you use the following settings:\n\n*   When asked to set a **Scope name**, enter `API.Access`.\n    \n\nDuring this process, record the **Application ID URI** that Microsoft generates for your application as you will need it later in the tutorial.\n\n### Register a new native application\n\nTo learn how to register a native application in Azure, read [Quickstart: Register an application with the Microsoft identity platform on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n\nWhile setting up your app, make sure you use the following settings:\n\n*   If you want to allow users from external organizations (like other Azure AD directories), select **Accounts in any organizational directory (Any Azure AD directory - Multitenant)** when setting **Supported account types**.\n    \n*   When asked to set a **Redirect URI**, select `Public client/native (mobile & desktop)` and enter your callback URL. Your callback URL format will vary depending on your platform. For details about the format for your platform, read [Native Quickstarts](https://auth0.com/docs/quickstart/native).\n    \n\nDuring this process, record the **Application (client) ID** that Microsoft generates for your application (you can find this on the application's **Overview** screen) as you will need it later in the tutorial.\n\n### Create a client secret for your native application\n\nTo learn how to create a client secret, read [Quickstart: Configure a client application to access web APIs - Add Credentials to your web application on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application).\n\nGenerate a **Client secret** and record its value. You will need it later in the tutorial.\n\n### Add permissions for your native application\n\nTo learn how to add permissions for your **Native** application, read [Quickstart: Configure a client application to access web APIs - Add permissions to access web APIs on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-permissions-to-access-web-apis).\n\nAuth0 requires that you enable the least privileged permissions necessary (for the Microsoft Graph API and for the Web application you configured to expose an API) for this configuration to work properly. To learn more about Microsoft Graph API permissions, read [Microsoft Graph permissions reference on Microsoft Docs](https://learn.microsoft.com/en-us/graph/permissions-reference).\n\nWhile setting up your permissions, make sure you use the following settings for Microsoft Graph API:\n\n*   When asked for a permission type, choose **Delegated permissions**.\n    \n    *   Under **User**, select **User.Read** so your app can sign in users and read the signed-in user's profile.\n        \n    *   Under **Directory**, select **Directory.Read.All** so your app can read directory data on the signed-in user's behalf.\n        \n\nFor your Web app that you configured to expose an API, make sure you use the following settings:\n\n*   When asked for a permission type, choose **Delegated permissions**.\n    \n    *   Under **API**, select **API.Access** so your app can access your API on the user's behalf.\n        \n\n## Configure the connection in Auth0\n\nAfter creating both applications in Azure AD, you can configure the Auth0 connection:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Microsoft Azure AD**, and select the add (**+**) button.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create**:\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Microsoft Azure AD Domain** | Your Azure AD domain name. You can find this on your Azure AD directory's overview page in the Microsoft Azure portal. |\n    | **Client ID** | Unique identifier for your registered Azure AD application. Enter the saved value of the **Application (client) ID** for the Native application you registered in Azure AD. |\n    | **Client Secret** | String used to gain access to your registered Azure AD application. Enter the saved value of the **Client secret** for the Native app you registered in Azure AD. |\n    | **Use common endpoint** (optional) | When enabled, your application will dynamically accept users from new directories. Typically enabled if you selected a multitenant option for **Supported account types** for the application you registered in Azure AD. When enabled, Auth0 will redirect users to Azure's common login endpoint, and Azure will perform _Home Realm Discovery_ based on the domain of the user's email address. |\n    | **Identity API** | API used by Auth0 to interact with Azure AD endpoints. Learn about the differences in behavior in Microsoft's [Why update to Microsoft identity platform (v2.0)](https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-endpoint-comparison) doc. Select `Azure Active Directory (v1)`, and for **App ID URI**, enter the saved value of the **Application ID URI** that was created when you configured your Web application to expose an API. |\n    | **Attributes** | Basic attributes for the signed-in user that your app can access. Indicates how much information you want stored in the Auth0 User Profile. |\n    | **Extended Attributes** (optional) | Extended attributes for the signed-in user that your app can access. |\n    | **Auth0 APIs** (optional) | When selected, indicates that you require the ability to make calls to the Azure AD Users API. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    | **Email Verification** | Choose how Auth0 sets the `email_verified` field in the user profile. To learn more, see [Email Verification for Azure AD and ADFS](https://auth0.com/docs/connections/azuread-adfs-email-verification). |\n    \n    ![Create new Azure AD connection](https://images.ctfassets.net/cdy7uua7fh8z/1r6WTgLJUlbiV9jligIwER/4fd549986503d804ffbcc785b4ef70df/Azure_AD_Connection.png)\n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new Azure AD enterprise connection, you must [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n## Group Memberships and Advanced Profile Information\n\nIn this native flow, Auth0 will receive an Access Token from Azure AD which has been issued for your Azure AD Web application. As a result, features like loading group memberships and advanced profile information will no longer work because the Access Token received by Azure AD can no longer be used to query the Azure AD Graph API for this additional information.\n\nHowever, if you depend on group memberships and advanced profile information, you can change your configuration to accommodate your needs:\n\n1.  In Azure, configure your Native application with additional permissions for the Microsoft Graph API:\n    \n    *   When asked for a permission type, choose **Delegated permissions**.\n        \n        *   Under **Directory**, select **Directory.AccessAsUser.All**, so your app can access the directory as the signed-in user.\n            \n2.  In Auth0, modify your Azure AD enterprise connection:\n    \n    *   In **Identity API**, select `Azure Active Directory (v1)`, and for **App ID URI**, enter the URI of the Azure AD Graph API:\n        \n        ```\n        https://graph.windows.net\n        ```\n        \n\n## Next Steps\n\n*   [Integrate with Auth0 using one of our libraries](https://auth0.com/docs/libraries)\n    \n*   [Integrate with Auth0 using our Authentication API](https://auth0.com/docs/api/authentication)\n    \n*   [Read more about the authentication flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow)\n    \n*   [Pass additional parameters to the Identity Provider](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps)\n    \n*   [Re-prompt users for permissions](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions)",
  "title": "Connect Your Native App to Microsoft Azure Active Directory Using Resource Owner Flow",
  "description": "Learn how to connect your app to Microsoft Azure Active Directory using an enterprise connection with the Resource Owner flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/ping-federate",
  "markdown": "# Connect Your PingFederate Server to Auth0\n\nAuth0 lets you create [PingFederate Server](https://documentation.pingidentity.com/pingfederate/pf84/#gettingStartedGuide/concept/gettingStarted.html) connections.\n\n## Prerequisites\n\nBefore beginning:\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of **`{https://yourApp/callback}`**.\n        \n    *   Make sure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n\n## Steps\n\nAs long as your server is configured in the standard way, to connect your PingFederate server to Auth0 you must:\n\n1.  [Get the signing certificate from the IdP](#get-the-signing-certificate-from-the-idp) and [convert it to Base64](#convert-signing-certificate-to-base64).\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0).\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application).\n    \n4.  [Test the connection](#test-the-connection).\n    \n\n## Get the signing certificate from the IdP\n\nWith PingFederate Server, Auth0 acts as the service provider, so you will need to retrieve an X.509 signing certificate from the IdP (in PEM or CER format); later, you will upload this to Auth0. The methods for retrieving this certificate vary, so please see the [PingFederate documentation](https://documentation.pingidentity.com/pingfederate/pf84/index.shtml#concept_digitalSignatureSettings.html) for instructions on managing your server's certificates.\n\n### Convert signing certificate to Base64\n\nBefore you upload the X.509 signing certificate to Auth0, you must convert the file to Base64. To do this, either use a [simple online tool](https://www.base64decode.org/) or run the following command in Bash: `cat signing-cert.crt | base64`.\n\n## Create an enterprise connection in Auth0\n\nNext, if your server is configured in the standard way, you will need to create and configure a PingFederate Enterprise Connection in Auth0 and upload your X.509 signing certificate. This task can be performed using Auth0's Dashboard.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Ping Federate**, and select its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create:**\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **PingFederate Server URL** | URL for your PingFederate Server. |\n    | **X.509 Signing Certificate** | PingFederate Server public key (encoded in PEM or CER) you retrieved from the IdP earlier in this process. |\n    | **Sign Request** | When enabled, the SAML authentication request will be signed. (Be sure to download and provide the PingFederate server with your [tenant's certificate](https://{yourdomain}/pem).) |\n    | **Sign Request Algorithm** | Algorithm Auth0 will use to sign the SAML assertions. Ensure this matches your PingFederate Server's configuration. |\n    | **Sign Request Digest Algorithm** | Algorithm Auth0 will use for the sign request digest. Ensure this matches your PingFederate Server's configuration. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    ![Configure Ping Federate Settings](https://images.ctfassets.net/cdy7uua7fh8z/6gBIIx0DC8363S1NNGBCqA/5e58d3fbde75661eb170d8bd0cbcda61/PingFederate.png)\n3.  In the **Login Experience** view, configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new PingFederate enterprise connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).",
  "title": "Connect Your PingFederate Server to Auth0",
  "description": "Learn how to create an enterprise connection between a PingFederate Server and Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/google-apps",
  "markdown": "# Connect Your App to Google Workspace\n\n#### Using Google Social and Enterprise Connections\n\nIf you have an existing [Google Social Connection](https://marketplace.auth0.com/integrations/google-social-connection) for your application and you create a new Google Workspace connection for the same domain, users affiliated with the social connection with now be logged in with the new enterprise connection. This will occur regardless of whether you enable the Google Workspace enterprise connection.\n\n## Prerequisites\n\nBefore you begin:\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of **`{https://yourApp/callback}`**.\n        \n    *   Make sure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n\n## Steps\n\nTo connect your application to Google Workspace, you must:\n\n1.  [Set up your app in Google](#set-up-your-app-in-google)\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0)\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application)\n    \n4.  [Test the connection](#test-the-connection)\n    \n\n#### Google Workspace account\n\nBefore proceeding, you will need a valid Google Workspace account and must have **your own** Google Workspace Organization for which you are an administrator.\n\n## Set up your app in Google\n\nTo allow users to log in using Google Workspace, you must register your application in the Google developer console.\n\n### Register a new application\n\nTo learn how to register a new application with Google, follow Google's [Setting up OAuth 2.0](https://support.google.com/googleapi/answer/6158849) doc. During this process, Google will generate a **Client ID** and **Client Secret** for your application; make note of these.\n\nWhile setting up your app, be sure to use these settings:\n\n*   On the **OAuth consent screen**, under **Authorized domains**, add `auth0.com`.\n    \n*   When asked to select an application type, choose **Web application** and set the following parameters:\n    \n    | Field | Description |\n    | --- | --- |\n    | Name | The name of your application. |\n    | Authorized JavaScript origins | `https://{yourDomain}` |\n    | Authorized redirect URIs | `https://{yourDomain}/login/callback` |\n    \n    #### Find your Auth0 domain name for redirects\n    \n    If your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n    \n    For example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n    \n    However, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n    \n    If you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n    \n\n### Enable the Admin SDK Service\n\nIf you plan to connect to Google Workspace enterprise domains, you need to enable the **Admin SDK Service**. To learn how, follow Google's [Enable and disable APIs](https://support.google.com/googleapi/answer/6158841) doc.\n\n## Create an enterprise connection in Auth0\n\nNext, you will need to create and configure a Google Workspace Enterprise Connection in Auth0. Make sure you have the **Client ID** and **Client Secret** generated when you set up your app in the Google developer console.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Google Workspace**, and click its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create:**\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Google Workspace Domain** | Google Workspace domain name for your organization. |\n    | **Client ID** | Unique identifier for your registered Google application. Enter the saved value of the **Client ID** for the app you just registered in the Google developer console. |\n    | **Client Secret** | String used to gain access to your registered Google application. Enter the saved value of the **Client Secret** for the app you just registered in the Google developer console. |\n    | **Attributes** | Basic attributes for the signed-in user that your app can access. Indicates how much information you want stored in the Auth0 User Profile. Options include: **Basic Profile** (`email`, `email verified` flag) and **Extended Profile** (name, public profile URL, photo, gender, birthdate, country, language, and timezone). |\n    | **Extended Attributes** (optional) | Extended attributes for the signed-in user that your app can access. Options include: **Groups** (distribution list(s) to which the user belongs), **Is Domain Administrator** (indicates whether the user is a domain administrator), **Is Account Suspended** (indicates whether the user's account is suspended), and **Agreed to Terms** (indicates whether the user has agreed to the terms of service). |\n    | **Auth0 APIs** (optional) | When **Enable Users API** is selected, indicates that you require the ability to make calls to the Google Directory API. |\n    | **Auth0 User ID** (optional) | By default, the Auth0 `user_id` maps to `email`. By enabling **Use ID instead of Email for Auth0 User ID**, `user_id` instead maps to `id`. This can only be set for new connections and cannot be changed once configured. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    ![Create Google Workspace Connection](https://images.ctfassets.net/cdy7uua7fh8z/5s3W98sar77mRxZ3F3s0Ol/ff0c036b26e95a6bbf7bbc3ca5a772fe/Google_Workspace_form_-_1px.png)\n3.  If you have appropriate administrative permissions to configure your Google Workspace settings so you can use Google's Admin APIs, then click **Continue**. Otherwise, provide the given URL to your administrator so that they can adjust the required settings.\n    \n4.  On the **Login Experience** tab, you can configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n\n## Work with the connection\n\n### Enable the enterprise connection for your Auth0 application\n\nTo use your new AD connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n### Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n### Request Refresh Tokens from Google\n\nGoogle always returns an Access Token, which is stored in the user profile. If you add `access_type=offline&approval_prompt=force` to the authorization request, Auth0 will forward these parameters to Google. Google will then return a Refresh Token, which will also be stored in the user profile.\n\n### Use Identity Provider Tokens from Google\n\nTo retrieve additional user and group details beyond what Auth0 retrieves by default, you can use the access tokens returned from Google to call Google's APIs. To securely access these tokens, follow the guidelines provided in [Identity Provider Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/identity-provider-access-tokens).\n\nFor Google Workspace, Auth0 stores access tokens and refresh tokens on the `user` object for individual users and on the `connection` object for workspace admins.\n\nTo retrieve all extended group properties for a user with Google's Directory Admin API, navigate to the Goolgle Workspace connection in your [Auth0 Dashboard](https://manage.auth0.com/#/connections/enterprise) and enable the **Groups** extended attribute. Then, complete administrator consent using the **Setup** tab.\n\nAfter these steps are complete, use the [Get a connection](https://auth0.com/docs/api/management/v2/connections/get-connections-by-id) endpoint of the Auth0 Management API to retrieve the admin access token stored on the `connection` object. You can then use this token to call Google's [Manage Groups](https://developers.google.com/admin-sdk/directory/v1/guides/manage-groups#get_all_member_groups) endpoint.\n\n**Example call**:\n\n```\ncurl -H \"Authorization: OAuth {admin_access_token}\" https://admin.googleapis.com/admin/directory/v1/groups\\?userKey={user_key}\n```\n\n### Validate authentication with Actions\n\nYou can use `post-login` [Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) to validate whether authentication events are coming from legitimate users who are members of a Google organization. This can help mitigate potential vulnerability by preventing unauthorized access to your applications after users are no longer part of your organization.\n\nTo verify legitimate Google authentications, use `post-login` Actions to validate the `idp_tenant_domain` claim associated with the user and ensure the value matches the expected organization for that user.\n\nYou can only verify `idp_tenant_domain` for users who authenticate with the following connection types:\n\n*   Google Social\n    \n*   Google Workspace\n    \n*   Google OIDC\n    \n\n#### Example\n\nThe following example demonstrates how you can validate the `idp_tenant_domain` using `post-login` Actions.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\n // Example to block social accounts\n if (event.connection.strategy === 'google-oauth2' \n && !event.user.idp_tenant_domain) // Non-organization Accounts\n {\n   api.access.deny('Account not allowed for login');\n }\n\n // Example to only permit allowlisted organization accounts\n if (event.connection.strategy === 'google-oauth2' \n && event.user.idp_tenant_domain != \"allowedOrganization.com\") \n {\n   api.access.deny('Your Google Organization is not allowed to login');\n }\n\n};\n```\n\nIf a Google Workspace admin is deleted, any Google Workspace Enterprise connections they have set up and authorized will need to be reauthorized by a new Google Workspace admin to avoid login failures. This can be done by having the new admin use the link in the **Setup** tab for the Google Workspace Enterprise connection.\n\n## Next Steps\n\n*   [Integrate with Auth0 using one of our libraries](https://auth0.com/docs/libraries)\n    \n*   [Integrate with Auth0 using our Authentication API](https://auth0.com/docs/api/authentication)\n    \n*   [Read more about the authentication flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow)\n    \n*   [Pass additional parameters to the Identity Provider](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps)\n    \n*   [Re-prompt users for permissions](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions)",
  "title": "Connect Your App to Google Workspace",
  "description": "Learn how to connect your app to Google Workspace using an enterprise connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/saml",
  "markdown": "# Connect Your App to SAML Identity Providers\n\nAuth0 lets you create SAML Identity Provider (IdP) connections.\n\n## Prerequisites\n\nBefore beginning:\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of **`{https://yourApp/callback}`**.\n        \n    *   Make sure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n*   Decide on the name of this enterprise connection\n    \n    *   The Post-back URL (also called Assertion Consumer Service URL) becomes: `https://{yourDomain}/login/callback?connection={yourConnectionName}`\n        \n    *   The Entity ID becomes: `urn:auth0:{yourTenant}:{yourConnectionName}`\n        \n\n## Steps\n\nTo connect your application to a SAML Identity Provider, you must:\n\n1.  Enter the Post-back URL and Entity ID at the IdP (to learn how, read about [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)).\n    \n2.  [Get the signing certificate from the IdP](#get-the-signing-certificate-from-the-idp) and [convert it to Base64](#convert-signing-certificate-to-base64).\n    \n3.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0).\n    \n4.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application).\n    \n5.  [Set up mappings](#set-up-mappings) (unnecessary for most cases).\n    \n6.  [Test the connection](#test-the-connection).\n    \n\n## Get the signing certificate from the IdP\n\nWith SAML Login, Auth0 acts as the service provider, so you will need to retrieve an X.509 signing certificate from the SAML IdP (in PEM or CER format); later, you will upload this to Auth0. The methods for retrieving this certificate vary, so please see your IdP's documentation if you need additional assistance.\n\n### Convert signing certificate to Base64\n\nYou can use the Management API or the Auth0 Dashboard to upload the X.509 signing certificate. If you use the Management API, you must convert the file to Base64. To do this, either use a [simple online tool](https://www.base64decode.org/) or run the following command in Bash: `cat signing-cert.crt | base64`.\n\n## Create an enterprise connection in Auth0\n\nNext, you will need to create and configure a SAML Enterprise Connection in Auth0 and upload your X.509 signing certificate. This task can be performed using either Auth0's Dashboard or Management API.\n\n### Create an enterprise connection using the Dashboard\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **SAML**, and select its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create:**\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant and the same name used when setting the Post-back URL and Entity ID at the IdP. Once set, this name can't be changed. |\n    | **Sign In URL** | SAML single login URL. |\n    | **X.509 Signing Certificate** | Signing certificate (encoded in PEM or CER) you retrieved from the IdP earlier in this process. |\n    | **Enable Sign Out** | When enabled, a specific Sign Out URL can be set. Otherwise, the Sign In URL is used by default. |\n    | **Sign Out URL** (optional) | SAML single logout URL. |\n    | **User ID Attribute** (optional) | Attribute in the SAML token that will be mapped to the `user_id` property in Auth0. |\n    | **Debug Mode** | When enabled, more verbose logging will be performed during the authentication process. |\n    | **Sign Request** | When enabled, the SAML authentication request will be signed. (Be sure to download and provide the accompanying certificate so the SAML IdP can validate the assertions' signature.) |\n    | **Sign Request Algorithm** | Algorithm Auth0 will use to sign the SAML assertions. |\n    | **Sign Request Digest Algorithm** | Algorithm Auth0 will use for the sign request digest. |\n    | **Protocol Binding** | HTTP binding supported by the IdP. |\n    | **Request Template** (optional) | Template that formats the SAML request. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    ![Configure SAML Settings](https://images.ctfassets.net/cdy7uua7fh8z/7hvlp8kjva9uFzm5nwsBTQ/4c9f4d01438a3dab6cfb19a5d61d3f13/SAML_Connection_2.png)\n3.  In the **Login Experience** view, configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n4.  If you have appropriate administrative permissions to complete the integration, click **Continue** to learn about the custom parameters needed to configure your IdP. Otherwise, provide the given URL to your administrator so that they can adjust the required settings.\n    \n\n### Create an enterprise connection using the Management API\n\nYou can also use the [Management API](https://auth0.com/docs/api/management/v2) to create your SAML Connection. When doing so, you may choose to specify each SAML configuration field manually or else specify a SAML metadata document that contains the configuration values.\n\n#### Create a connection using specified values\n\nMake a `POST` call to the [Create a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). Be sure to replace `MGMT_API_ACCESS_TOKEN`, `CONNECTION_NAME`, `SIGN_IN_ENDPOINT_URL`, `SIGN_OUT_ENDPOINT_URL`, and `BASE64_SIGNING_CERT` placeholder values with your Management API Access Token, connection name, sign in URL, sign out URL, and Base64-encoded signing certificate (in PEM or CER format), respectively.\n\n*   [cURL](#966e23590b344805bf7d12b75151b008_shell)\n*   [C#](#966e23590b344805bf7d12b75151b008_csharp)\n*   [Go](#966e23590b344805bf7d12b75151b008_go)\n*   [Java](#966e23590b344805bf7d12b75151b008_java)\n*   [Node.JS](#966e23590b344805bf7d12b75151b008_node)\n*   [Obj-C](#966e23590b344805bf7d12b75151b008_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\", \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\", \"signatureAlgorithm\": \"rsa-sha256\", \"digestAlgorithm\": \"sha256\", \"fieldsMap\": {}, \"signingCert\": \"BASE64_SIGNING_CERT\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    strategy: 'samlp',\n    name: 'CONNECTION_NAME',\n    options: {\n      signInEndpoint: 'SIGN_IN_ENDPOINT_URL',\n      signOutEndpoint: 'SIGN_OUT_ENDPOINT_URL',\n      signatureAlgorithm: 'rsa-sha256',\n      digestAlgorithm: 'sha256',\n      fieldsMap: {},\n      signingCert: 'BASE64_SIGNING_CERT'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"samlp\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"signInEndpoint\": @\"SIGN_IN_ENDPOINT_URL\", @\"signOutEndpoint\": @\"SIGN_OUT_ENDPOINT_URL\", @\"signatureAlgorithm\": @\"rsa-sha256\", @\"digestAlgorithm\": @\"sha256\", @\"fieldsMap\": @{  }, @\"signingCert\": @\"BASE64_SIGNING_CERT\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"strategy\": \"samlp\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\",\n    \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\",\n    \"signatureAlgorithm\": \"rsa-sha256\",\n    \"digestAlgorithm\": \"sha256\",\n    \"fieldsMap\": [],\n    \"signingCert\": \"BASE64_SIGNING_CERT\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/api/management/v2/tokens) with the scope `create:connections`. |\n| `CONNECTION_NAME` | Τhe name of the connection to be created. |\n| `SIGN_IN_ENDPONT_URL` | SAML single login URL for the connection to be created. |\n| `SIGN_OUT_ENDPOINT_URL` | SAML single logout URL for the connection to be created. |\n| `BASE64_SIGNING_CERT` | X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP. |\n\nOr, in JSON:\n\n```\n{\n\t\"strategy\": \"samlp\",\n  \t\"name\": \"CONNECTION_NAME\",\n  \t\"options\": {\n    \t\"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\",\n    \t\"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\",\n    \t\"signatureAlgorithm\": \"rsa-sha256\",\n    \t\"digestAlgorithm\": \"sha256\",\n    \t\"fieldsMap\": {\n     \t\t...\n    \t},\n    \t\"signingCert\": \"BASE64_SIGNING_CERT\"\n  \t}\n}\n```\n\n#### Create a connection using SAML metadata\n\nRather than specifying each SAML configuration field, you can specify a SAML metadata document that contains the configuration values. When specifying a SAML metadata document, you may provide either the XML content of the document (`metadataXml`) or the URL of the document (`metadataUrl`). When providing the URL, content is downloaded only once; the connection will not automatically reconfigure if the content of the URL changes in the future.\n\n##### Provide metadata document content\n\nUse the `metadataXml` option to provide content of the document:\n\n*   [cURL](#bf808167d002424ea040de52b4cb0fb8_shell)\n*   [C#](#bf808167d002424ea040de52b4cb0fb8_csharp)\n*   [Go](#bf808167d002424ea040de52b4cb0fb8_go)\n*   [Java](#bf808167d002424ea040de52b4cb0fb8_java)\n*   [Node.JS](#bf808167d002424ea040de52b4cb0fb8_node)\n*   [Obj-C](#bf808167d002424ea040de52b4cb0fb8_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataXml\": \"<EntityDescriptor entityID='\\''urn:saml-idp'\\'' xmlns='\\''urn:oasis:names:tc:SAML:2.0:metadata'\\''>...</EntityDescriptor>\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    strategy: 'samlp',\n    name: 'CONNECTION_NAME',\n    options: {\n      metadataXml: '<EntityDescriptor entityID=\\'urn:saml-idp\\' xmlns=\\'urn:oasis:names:tc:SAML:2.0:metadata\\'>...</EntityDescriptor>'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"samlp\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"metadataXml\": @\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"strategy\": \"samlp\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\"metadataXml\": \"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Provide a metadata document URL\n\nUse the `metadataUrl` option to provide the URL of the document:\n\n*   [cURL](#ce208c9625a740f1add1aa50bcb5e8f3_shell)\n*   [C#](#ce208c9625a740f1add1aa50bcb5e8f3_csharp)\n*   [Go](#ce208c9625a740f1add1aa50bcb5e8f3_go)\n*   [Java](#ce208c9625a740f1add1aa50bcb5e8f3_java)\n*   [Node.JS](#ce208c9625a740f1add1aa50bcb5e8f3_node)\n*   [Obj-C](#ce208c9625a740f1add1aa50bcb5e8f3_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    strategy: 'samlp',\n    name: 'CONNECTION_NAME',\n    options: {\n      metadataUrl: 'https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"samlp\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"metadataUrl\": @\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"strategy\": \"samlp\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nWhen providing the URL, content is downloaded only once; the connection will not automatically reconfigure if the content of the URL changes in the future.\n\n##### Refresh existing connection information with metadata URL\n\nIf you have a B2B implementation and federate to Auth0 with your own SAML identity provider, you may need to refresh connection information stored in Auth0, such as signing certificate changes, endpoint URL changes, or new assertion fields. Auth0 does this automatically for ADFS connections, but not for SAML connections.\n\nYou can create a batch process (cron job) to do a periodic refresh. The process can run every few weeks and perform a PATCH call to `/api/v2/connections/CONNECTION_ID` endpoint, passing a body containing `{options: {metadataUrl: '$URL'}}` where `$URL` is the same metadata URL with which you created the connection. You use the metadata URL to create a new temporary connection, then compare the properties of the old and new connections. If anything is different, update the new connection and then delete the temporary connection.\n\n1.  Create SAML connection with `options.metadataUrl`. The connection object will be populated with information from the metadata.\n    \n2.  Update metadata content in the URL.\n    \n3.  Send a PATCH to the `/api/v2/connections/CONNECTION_ID` endpoint with `{options: {metadataUrl: '$URL'}}`. Now the connection object is updated with the new metadata content.\n    \n\n## Specify a custom Entity ID\n\nTo specify a custom Entity ID, use the Management API to override the default `urn:auth0:YOUR_TENANT:YOUR_CONNECTION_NAME`. Set the `connection.options.entityID` property when the connection is first created or by updating an existing connection.\n\nThe JSON example below can be used to create a new SAML connection using the SAML IdP’s metadata URL while also specifying a custom Entity ID. The Entity ID is still unique since it is created using the name of the connection.\n\n```\n{\n  \"strategy\": \"samlp\", \n  \"name\": \"{yourConnectionName}\", \n  \"options\": { \n    \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\",\n    \"entityId\": \"urn:your-custom-sp-name:{yourConnectionName}\"\n  }\n}\n```\n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new SAML enterprise connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Set up mappings\n\nSelect the **Mappings** view, enter mappings between the `{}`, and select **Save**.\n\n![Configure SAML Mappings](https://images.ctfassets.net/cdy7uua7fh8z/3matGqveShEDX89p8Bcmwr/6e8a1924c2d2ebde8fd980ed47f78d13/dashboard-connections-enterprise-edit_view-mappings_saml.png)\n\n**Mappings for non-standard PingFederate Servers:**\n\n```\n{\n    \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n    \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"\n}\n```\n\n**Mappings for SSO Circle**\n\n```\n{\n  \"email\": \"EmailAddress\",\n  \"given_name\": \"FirstName\",\n  \"family_name\": \"LastName\"\n}\n```\n\n**Map either of two claims to one user attribute**\n\n```\n{\n  \"given_name\": [\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n  ]\n}\n```\n\n**How to map name identifier to a user attribute**\n\n```\n{\n  \"user_id\": [\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn\",\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n  ]\n}\n```\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).",
  "title": "Connect Your App to SAML Identity Providers",
  "description": "Learn how to connect to SAML Identity Providers using an enterprise connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on",
  "markdown": "# Configure SAML Identity Provider-Initiated Single Sign-On\n\nMany instructions for setting up a SAML federation begin with Single Sign-on (SSO) initiated by the service provider. The service provider redirects the user to the identity provider (IdP) for the purposes of authentication. This process is commonly used for consumer-facing scenarios.\n\nHowever, in enterprise scenarios, it is sometimes common to begin with the IdP initiating SSO instead of the service provider. For example, an enterprise might set up a portal to ensure that users navigate to the correct application after they sign on to the portal.\n\n## Risks and considerations\n\nIdP-Initiated flows carry a security risk and are therefore not recommended. The recommendation is to use SP-Initiated flows whenever possible.\n\nMake sure you understand the risks before enabling IdP-Initiated SSO. In this scenario, Auth0 receives the unsolicited response from the IdP and the application receives the unsolicited response from Auth0. Neither entity can verify that the user started the flow. Because of this, enabling this flow opens the possibility of an [Login CSRF attack](https://support.detectify.com/support/solutions/articles/48001048951-login-csrf), where an attacker can trick a legitimate user into unknowingly logging into the application with the identity of the attacker.\n\n### OpenID Connect IdP-initiated flow\n\nOpenID Connect (OIDC) does not support the concept of an IdP-Initiated flow. So while Auth0 offers the possibility of translating a SAML IdP-Initiated flow (from a SAML connection) into an OIDC response for an application, any application that properly implements the OIDC/OAuth2 protocol will reject an unrequested response.\n\nWhen using OIDC applications, the best option is to have your application create a login endpoint. This endpoint’s sole purpose is to initiate the redirect back to the IdP (your Auth0 tenant).\n\nIf you use multiple IdPs, be sure that the login endpoint is either specific to the identity provider or can accept a parameter to identify which IdP initiates the workflow.\n\nAn alternative approach is to have users start the login flow at the application.\n\n### Post-back URL\n\nWhen using IdP-Initiated SSO, make sure to include the connection parameter in the post-back URL:\n\n```\nhttps://{yourDomain}/login/callback?connection={yourConnectionName}\n```\n\nIf you are using the [Organizations](https://auth0.com/docs/manage-users/organizations) feature, you can optionally include an organization parameter containing the organization ID of the desired organization:\n\n```\nhttps://{yourDomain}/login/callback?connection={yourConnectionName}&organization={yourCustomersOrganizationId}\n```\n\n### Lock/Auth0.js\n\nIf your application is a single-page application that uses Lock or Auth0.js to process the authentication results, you must explicitly indicate that you want to allow IdP-Initiated flows and thus open the application to possible Login CSRF attacks.\n\nIf you are using Auth0.js, you must update the `webAuth.parseHash` of the library and set the flag `__enableIdPInitiatedLogin` to `true`.\n\n```\nvar data = webAuth.parseHash(\n      {\n        ...\n        __enableIdPInitiatedLogin: true\n        ...\n      }\n```\n\nIf you're using Lock, you can include the flag using the options parameter sent to the constructor.\n\n`const lock = new Auth0Lock(clientID, domain, options)`\n\nHere's the flag itself:\n\n`var options = { _enableIdPInitiatedLogin: true };`\n\nNote that the `enableIdPInitiatedLogin` flag is preceded by one underscore when used with Lock and two underscores when used with the auth0.js library.\n\n## Set up IDP-initiated SSO\n\n1.  Go to the [Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise) and choose **SAMLP Identity Provider**.\n    \n2.  Under **Settings** you can see the configuration for IdP-Initiated SSO.\n    \n    ![Protocols IdP-initiated SSO Configuration Screen](https://images.ctfassets.net/cdy7uua7fh8z/1HORCAp4fZQg0BOoIopvoS/084dcac9f133b98526e8bda222a6e37c/conn-enterprise-saml-idp-initiated-sso.png)\n\n*   **IdP-initiated SSO Behavior**: This option allows you to enable IdP-initiated logins for the SAML connection. Select **Accept Requests** and complete all the required fields.\n    \n*   **Default Application:** When the IdP initiated login succeeds this is the application where users are routed. This setting shows available applications enabled for this connection. Select the application from the dropdown that you want the users to login with IdP initiated. Only one application can be selected for an IdP-initiated login per SAML connection.\n    \n*   **Response Protocol:** This is the protocol used to connect your selected **Default Application**. Most commonly, applications are configured with the OpenID Connect protocol (see above). However, if you have configured a SAML2 Web App addon for your application and want to route the SAML assertion you will need to select SAML. Once a valid SAML Assertion has been passed to the postback URL, Auth0 sends a login response to the configured default application’s first allowed callback URL using the chosen response protocol, which can be modified using the query string field to specify a `redirect_uri` if you use OIDC.\n    \n*   **Query String:** Query string options help to customize the behavior when the OpenID Connect protocol is used. You can set multiple options similar to setting parameters with a [query string](https://en.wikipedia.org/wiki/Query_string). You can set:\n    \n    | Setting | Description |\n    | --- | --- |\n    | `redirect_uri` | When the IdP-initiated login has completed the request is then redirected to the first URL listed in the **Allowed Callback URLs** for the application. However, if you set a `redirect_uri`, the IdP will redirect to this URL. This adds flexibility for cases such as when you have a set subdomain scheme with a wildcard and you only want to redirect to one specific subdomain. |\n    | `scope` | Define scopes for the ID token sent. You can set multiple scopes. |\n    | `response_type` | Set the token for the Implicit Grant Flow for SPAs. You can set code for the Authorization Code Grant Flow for regular web apps. |\n    \n    Example Query String: `redirect_uri=https://jwt.io&scope=openid email&response_type=token`\n\n## Application drop-down list limited to 100\n\nIf you want to select an application as the **Default Application** in IdP-initiated SSO, and the application isn't in the first 100 applications listed in the drop-down list for your tenant, you must use the Management API to select that application. You must run a patch:\n\n```\n{\n\"options\": {\n\"signInEndpoint\": \"yourIdpSignInUrl\",\n\"idpinitiated\": {\n\"client_id\": \"yourClientId\",\n\"client_protocol\": \"saml\",\n\"client_authorizequery\": \"\"\n},\n\"signingCert\": \"[copied-from-GET]\"\n}\n}\n```\n\n## Learn more\n\n*   [Work with Certificates and Keys as Strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings)",
  "title": "Configure SAML Identity Provider-Initiated Single Sign-On",
  "description": "Describes how to configure SAML Identity Provider-initiated Single Sign-on (SSO).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-idp-initiated-saml-sign-on-to-oidc-apps",
  "markdown": "# Configure IdP-Initiated SAML Sign-on to OIDC Apps\n\nAuth0 provides a method to translate an Identity Provider\\-initiated (IdP) SAML response into an OpenID Connect (OIDC) response for an application.\n\nThe OIDC protocol does not support IdP-initiated authentication flows, but this method allows you to simulate an IdP-initiated authentication flow using the [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).\n\nIf you’d like to implement this method, you must:\n\n*   Add a custom login route handler to your application.\n    \n*   Update your SAML connection to:\n    \n    1.  Accept incoming IdP-initiated SAML responses.\n        \n    2.  Redirect to a default application that sends a Service Provider-initiated authentication request.\n        \n\n## How it works\n\n![Identity Provider-initiated SAML sign-in to OIDC applications flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/5vinAB4pSSwaKDgliTkAhh/0c5822149426b986bbcc851d07666187/idp-provider-init-saml-sign-in0.png)\n\n1.  User navigates to the SAML IdP’s login endpoint.\n    \n2.  SAML IdP returns the login page.\n    \n3.  User submits credentials to the SAML IdP.\n    \n4.  SAML IdP creates a session for the user and then returns an HTML page with Form Post and the SAML response.\n    \n5.  Page automatically sends the SAML response to the Auth0 tenant through an HTTP `POST` call.\n    \n6.  Auth0 tenant redirects the user’s browser to the OIDC application’s custom login route handler with the ID token as a URL fragment.\n    \n7.  Browser calls the custom login route handler of the OIDC application with the `connection` parameter and the ID token.\n    \n8.  OIDC application ignores the ID token, parses the `connection` parameter, creates a `state` parameter for the session, and then redirects the user’s browser to the Auth0 tenant’s `/authorize` endpoint.\n    \n9.  Browser calls the Auth0 tenant’s `/authorize` endpoint with the provided `connection` and `state` parameters.\n    \n10.  Auth0 tenant generates a SAML login request and then redirects the user’s browser to SAML IdP’s login endpoint.\n    \n11.  Browser sends the SAML login request to the SAML IdP’s login endpoint.\n    \n12.  SAML IdP finds the user’s session and then returns an HTML page with Form Post and the SAML response.\n    \n13.  Page automatically sends the SAML response to the Auth0 tenant through an HTTP `POST` call.\n    \n14.  Auth0 tenant redirects the user’s browser to the application’s login route handler.\n    \n15.  Browser calls the application’s login route handler with the provided `state` parameter and ID token.\n    \n16.  OIDC application verifies the `state` parameter, parses the ID token and creates an application session for the user.\n    \n\n## Create the custom login route handler\n\nThe custom login route handler calls your application’s login method. The handler must accept the `connection` parameter and include it in the authentication request sent to your Auth0 tenant.\n\nWe recommend that you associate the custom login route handler with a different endpoint than the one associated with your standard login route handler. For example, if your standard login route handler is associated with the `/login` endpoint, you could associate the custom login route handler with the `/startlogin` endpoint.\n\n### Example\n\nIf you are using the [Auth0 Single Page App SDK](https://auth0.com/docs/libraries/auth0-single-page-app-sdk), you can add a custom login route handler and update the login method to support the connection parameter like so:\n\n```\nconst router = {\n  \"/\": () => showContent(\"content-home\"),\n  \"/profile\": () =>\n    requireAuth(() => showContent(\"content-profile\"), \"/profile\"),\n  \"/login\": () => login(),\n  \"/startlogin\": () => startlogin()\n};\n\n//new method to start login from idp-initiated callback\nconst startlogin = async () => {\n  console.log(window.location.href)\n  let myURL = new URL(window.location.href);\n  let conn = myURL.searchParams.get(\"connection\");\n  return  login(null, conn);\n}\n\n/**\n * Starts the authentication flow\n */\nconst login = async (targetUrl, connection) => {\n  try {\n    console.log(\"Logging in\", targetUrl);\n\n    const options = {\n      redirect_uri: window.location.origin,\n    };\n\n    if (connection) {\n      options.connection = connection;\n    }\n\n    if (targetUrl) {\n      options.appState = { targetUrl };\n    }\n\n    await auth0.loginWithRedirect(options);\n  } catch (err) {\n    console.log(\"Log in failed\", err);\n  }\n};\n```\n\n## Create the query string\n\nThe query string contains the `redirect_uri` parameter. The parameter’s value must be URL encoded and is composed of:\n\n1.  The application endpoint associated with the custom login route handler.\n    \n2.  The `connection` parameter with the value of your SAML connection name.\n    \n\n### Example\n\nIf your application endpoint is `https://exampleco.com/startlogin` and your SAML connection name is `my-saml-connection`, the query string would be `redirect_uri=https%3A%2F%2Fexampleco.com%2Fstartlogin%3Fconnection%3Dmy-saml-connection`.\n\n## Configure the application\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Create a new Application to represent the OIDC application in Auth0.\n    \n3.  Update **Allowed Callback URLs** to include the application endpoint associated with your custom login route handler.\n    \n\n## Configure the connection\n\n1.  Go to [Auth0 Dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n2.  Create a new SAML connection.\n    \n3.  Switch to the **IdP-Initiated SSO** view.\n    \n4.  Select **Accept Requests.**\n    \n5.  For **Default Application**, select the application you previously created.\n    \n6.  For **Response Protocol**, select **OpenID Connect**.\n    \n7.  For **Query String**, enter the query string you previously created.\n    \n\n## Learn more\n\n*   [Connect Your App to SAML Identity Providers](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/saml)\n*   [Configure SAML Identity Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)",
  "title": "Configure IdP-Initiated SAML Sign-on to OIDC Apps",
  "description": "Learn how to configure an Auth0 SAML connection to support Identity Provider-initiated sign-on to a SAML Identity Provider for OIDC applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings",
  "markdown": "# Work with Certificates and Keys as Strings\n\nYou can use the following command in a UNIX shell to concatenate a PEM-formatted certificate with `\\n` (escaped new-line):\n\n```\nawk 'NF {sub(/\\r/, \"\"); printf \"%s\\\\n\",$0;}' certificate.pem | pbcopy\n```\n\nThis copies the value into to your clipboard buffer so you can paste it where needed.\n\n### More information\n\nWhen working with certificates or keys in rules or Management API v2 requests, you will most likely require a string representation of the file.\n\nIf you open a certificate file (`cer`, `pem`) with a text editor, you'll see something like this:\n\n```\n-----BEGIN CERTIFICATE-----\nMIICzDCCAbQCCQDH8GvxPIeH+DANBgkqhkiG9w0BAQsFADAoMQswCQYDVQQGEwJh\ncjEZMBcGA1UEAwwQaHR0cHM6Ly9uaWNvLmNvbTAeFw0xOTA0MDgxODA3NTVaFw0y\n//\n// more lines of base64-encoded information\n//\nnSWyabd+LiBGtLTMB+ZLbOIi3EioWPGw/nHOI8jzPrqhiCLuZCSQmiqrLQYNsc1W\n-----END CERTIFICATE-----\n```\n\nThe lines between the `-----BEGIN CERTIFICATE-----` header and `-----END CERTIFICATE-----` footer contain base64-encoded binary information. Public keys and private keys (.key files) will look similar, with just a different header/footer.\n\nFor a string representation of a certificate/key file, you will need to concatenate everything in one line, with a `\\n` (escaped new-line) sequence replacing the actual new lines in the file. So from the above sample you'd obtain something like this:\n\n```\n\"-----BEGIN CERTIFICATE-----\n\\nMIICzDCCAbQCCQDH8GvxPIeH+DANBgkqhkiG9w0BAQsFADAoMQswCQYDVQQGEwJh\\n\n[..all the other lines..]\n-----END CERTIFICATE-----\\n\"\n```\n\n## Learn more\n\n*   [Configure Auth0 as SAML Identity Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider)\n*   [Configure Auth0 as SAML Service Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider)",
  "title": "Work with Certificates and Keys as Strings",
  "description": "Describes how to work with certificates or keys in rules or Management API requests to require a string representation of the file.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws",
  "markdown": "# Configure Amazon Web Services as SAML Service Provider\n\nConfigure the SAML2 Web App addon for Amazon Web Services (AWS) for an application.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://signin.aws.amazon.com/saml`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**. Be sure to replace the `AWS_SSO_ISSUER_URL` and `AWS_SSO_ACS_URL` placeholders with values you copied from AWS.\n    \n    ```\n    {\n      \"audience\": \"AWS_SSO_ISSUER_URL\",\n      \"destination\": \"AWS_SSO_ACS_URL\",\n      \"mappings\": {\n        \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n        \"name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n      },\n      \"createUpnClaim\": false,\n      \"passthroughClaimsWithNoMapping\": false,\n      \"mapUnknownClaimsAsIs\": false,\n      \"mapIdentities\": false,\n      \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n      \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n      ]\n    }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\nTo learn how to configure AWS for SSO, read [Configure Amazon Web Services for Single Sign-On](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso).\n\n## Learn more\n\n*   [Use Amazon Web Services Session Tags for Role-Based Access Control](https://auth0.com/docs/customize/integrations/aws/session-tags)\n*   [Configure Amazon Web Services for Single Sign-On](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso)",
  "title": "Configure Amazon Web Services as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Amazon Web Services (AWS).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/sign-and-encrypt-saml-requests",
  "markdown": "# Sign and Encrypt SAML Requests\n\nTo increase the security of your transactions, you can sign or encrypt both your requests and your responses in the SAML protocol. In this article, you'll find configurations for specific scenarios, separated under two use cases:\n\n*   Auth0 as the SAML service provider (for example, a SAML connection)\n    \n*   Auth0 as the SAML identity provider (for example, an application configured with the SAML Web App addon)\n    \n\n## Auth0 as the SAML service provider\n\nThese scenarios apply when Auth0 is the SAML Service Provider, which means that Auth0 connects to a SAML identity provider by creating a SAML connection.\n\n### Sign the SAML authentication request\n\nIf Auth0 is the SAML **service provider**, you can sign the authentication request Auth0 sends to the IdP as follows:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select **SAML**.\n    \n2.  Select the name of the connection to view.\n    \n3.  Locate **Sign Request**, and enable its switch.\n    \n4.  Download the certificate beneath the **Sign Request** switch, and provide it to the IdP so that it can validate the signature.\n    \n\n#### Enable/disable deflate encoding\n\nBy default, SAML authentication requests are sent via HTTP-Redirect and use deflate encoding, which puts the signature in a query parameter.\n\nTo turn off deflate encoding, you can make a [PATCH call to the Management API's Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) and set the `deflate` option to `false`.\n\nUpdating the `options` object for a connection overrides the whole `options` object. To keep previous connection options, get the existing `options` object and add new key/values to it.\n\nEndpoint: `https://{yourDomain}/api/v2/connections/{yourConnectionId}`\n\nPayload:\n\n```\n{\n\t{ \n\t\t\"options\" : {\n\t\t\t[...], // all the other connection options\n\t\t  \"deflate\": false\n\t}\n}\n```\n\n### Use a custom key to sign requests\n\nBy default, Auth0 uses the tenant private key to sign SAML requests (when the **Sign Request** toggle is enabled). You can also provide your own private/public key pair to sign requests coming from a specific connection.\n\nYou can generate your own certificate and private key using this command:\n\n```\nopenssl req -x509 -nodes -sha256 -days 3650 -newkey rsa:2048 -keyout private_key.key -out certificate.crt\n```\n\nChanging the key used to sign requests in the connection can't be done on the Dashboard UI, so you will have to use the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) from the Management API v2, and add a `signing_key` property to the `options` object, as shown in the payload example below.\n\nUpdating the `options` object for a connection overrides the whole `options` object. To keep previous connection options, get the existing `options` object and add new key/values to it.\n\nEndpoint: `https://{yourDomain}/api/v2/connections/{yourConnectionId}`\n\nPayload:\n\n```\n{\n\t{ \n\t\t\"options\" : {\n\t\t\t[...], // all the other connection options\n\t\t  \"signing_key\": {\n\t\t\t\t\"key\":\"-----BEGIN PRIVATE KEY-----\\n...{your private key here}...\\n-----END PRIVATE KEY-----\",\n\t\t\t\t\"cert\":\"-----BEGIN CERTIFICATE-----\\n...{your public key cert here}...\\n-----END CERTIFICATE-----\"\n\t\t\t}\n    }\n\t}\n}\n```\n\nTo learn how to get the private key and certificate formatted as a JSON string to use in the payload, see [Work with Certificates and Keys and Strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings).\n\n### Receive signed SAML authentication responses\n\nIf Auth0 is the SAML **service provider**, all SAML responses from your identity provider should be signed to indicate it hasn't been tampered with by an unauthorized third-party.\n\nYou will need to configure Auth0 to validate the responses' signatures by obtaining a signing certificate form the identity provider and loading the certificate from the identity provider into your Auth0 Connection:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select **SAML**.\n    \n2.  Select the name of the connection to view.\n    \n3.  Locate **X509 Signing Certificate**, and upload the certificate.\n    \n4.  Select **Save Changes**.\n    \n\nAuth0 can accept a signed response for the assertion, the response, or both.\n\n### Receive encrypted SAML authentication assertions\n\nIf Auth0 is the SAML service provider, it may need to receive encrypted assertions from an identity provider. To do this, you must provide the tenant's public key certificate to the IdP. The IdP encrypts the SAML assertion using the public key and sends it to Auth0, which decrypts it using the tenant's private key.\n\nUse the following links to obtain the public key in different formats:\n\n*   [CER](https://your_auth0_domain/cer?cert=connection)\n    \n*   [PEM](https://your_auth0_domain/pem?cert=connection)\n    \n*   [raw PEM](https://your_auth0_domain/rawpem?cert=connection)\n    \n*   [PKCS#7](https://your_auth0_domain/pb7?cert=connection)\n    \n*   [Fingerprint](https://your_auth0_domain/fingerprint?cert=connection)\n    \n\nDownload the certificate in the format requested by the IdP.\n\n### Use your key pair to decrypt encrypted responses\n\nAs noted above, Auth0 will by default use your tenant's private/public key pair to handle encryption. You can also provide your own public/private key pair if an advanced scenario requires so.\n\nChanging the key pair used to encrypt and decrypt requests in the connection can't be done on the Dashboard UI, so you will have to use the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) from the Management API v2, and add a `decryptionKey` property to the `options` object, as shown in the payload example below.\n\nUpdating the `options` object for a connection overrides the whole `options` object. To keep previous connection options, get the existing `options` object and add new key/values to it.\n\nEndpoint: `https://{yourDomain}/api/v2/connections/{yourConnectionId}`\n\nPayload:\n\n```\n{\n\t{ \n\t\t\"options\" : {\n\t\t\t[...], // all the other connection options\n\t\t  \"decryptionKey\": {\n\t\t\t\t\"key\":\"-----BEGIN PRIVATE KEY-----\\n...{your private key here}...\\n-----END PRIVATE KEY-----\",\n\t\t\t\t\"cert\":\"-----BEGIN CERTIFICATE-----\\n...{your public key cert here}...\\n-----END CERTIFICATE-----\"\n\t\t\t}\n\t}\n}\n```\n\nThe SAML metadata available for the connection will be updated with the provided certificate so that the identity provider can pick it up to sign the SAML response.\n\n## Auth0 as the SAML identity provider\n\nThis scenario applies when Auth0 is the SAML identity provider for an application. This is represented in the Dashboard by an **Application** that has the SAML Web App Addon enabled.\n\n### Sign the SAML responses/assertions\n\nIf Auth0 is the SAML identity provider, it will sign SAML assertions with the tenant's private key and provide the service provider with the public key/certificate necessary to validate the signature.\n\nTo sign the SAML assertions:\n\n1.  Go to [Auth0 Dashboard > Applications](https://manage.auth0.com/#/applications), and select the name of the application to view.\n    \n2.  Scroll to the bottom of the **Settings** page, select **Show Advanced Settings**, and select the **Certificates** view.\n    \n3.  Select **Download Certificate**, and select the format in which you'd like to receive your signing certificate.\n    \n4.  Send your certificate to the service provider.\n    \n\nBy default, Auth0 signs the SAML **assertion** within the response. To sign the SAML **response** instead:\n\n1.  Navigate to [Auth0 Dashboard > Applications](https://manage.auth0.com/#/applications), and select the name of the application to view.\n    \n2.  Select the **Addons** view.\n    \n3.  Select **SAML2 Web App** to view its settings, and locate the **Settings** code block.\n    \n4.  Locate the **\"****`signResponse\"`** key. Uncomment it (or add it, if required), then set its value to `true` (the default value is `false`). The configuration should look like this:\n    \n    ```\n    {\n      [...], // other settings\n      \"signResponse\": true\n    }\n    ```\n    \n\n#### Change the signing key for SAML responses\n\nBy default, Auth0 will use the private/public key pair assigned to your tenant to sign SAML responses or assertions. For very specific scenarios, you might wish to provide your own key pair. You can do so with a rule like this:\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n\n    // replace with the ID of the application that has the SAML Web App Addon enabled\n      // for which you want to change the signing key pair.\n      const samlIdpClientId = 'YOUR_SAML_APP_CLIENT_ID';\n\n    // only do this for the specific client ID.  If you have multiple IdPs that require \n    // custom certificates, you will have an \"if\" statement for each one.  \n    if (event.client.client_id === samlIdpClientId) {\n\n    // provide your own private key and certificate here  \n    // see https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings \n    // for formatting instructions basically you start with a PEM format certificate and\n    // replace the line enedings with \"\\n\"\n    const signingCert = \"-----BEGIN CERTIFICATE-----\\nnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV[..all the other lines..]-----END CERTIFICATE-----\\n\";\n    const signingKey = \"-----BEGIN PRIVATE KEY-----\\nnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV[..all the other lines..]-----END PRIVATE KEY-----\\n\";\n\n    api.samlResponse.setCert(signingCert)    \n    api.samlResponse.setKey(signingKey);\n\n  }\n  };\n```\n\nTo learn how to turn the private key and certificate files into strings that you can use in a rule, see [Work with Certificates and Keys and Strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings).\n\n### Receive signed SAML authentication requests\n\nIf Auth0 is the SAML identity provider, it can receive requests signed with the service provider's private key. Auth0 uses the public key/certificate to validate the signature.\n\nTo configure signature validation:\n\n1.  Download the service provider's certificate with the public key.\n    \n2.  Navigate to [Auth0 Dashboard > Applications](https://manage.auth0.com/#/applications), and select the name of the application to view.\n    \n3.  Select the **Addons** view.\n    \n4.  Select **SAML2 Web App** to view its settings, and locate the **Settings** code block.\n    \n5.  Locate the **\"****`signingCert\"`** key. Uncomment it (or add it, if required), then set its value to the certificate you downloaded from the service provider. The configuration should look like this:\n    \n    ```\n    {\n      [...], // other settings\n      \"signingCert\": \"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"\n    }\n    ```\n    \n\n### Send encrypted SAML authentication assertions\n\nIf Auth0 is the SAML identity provider, you can use rules to encrypt the SAML assertions it sends.\n\nYou must obtain the certificate and the public key from the service provider. If you only got the certificate, you can derive the public key using `openssl`. Assuming that the certificate file is named `certificate.pem`, you can run:\n\n`openssl x509 -in certificate.pem -pubkey -noout > public_key.pem`\n\nOnce you get the certificate and public key files, you must [turn them into strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings) to use them in a rule. The rule will look like this:\n\n```\nfunction (user, context, callback) {\n  // this rule sets a specific public key to encrypt the SAML assertion generated from Auth0 \n  if (context.clientID === 'THE_CLIENT_ID_OF_THE_APP_WITH_THE_SAML_APP_ADDON') {\n\t  context.samlConfiguration = (context.samlConfiguration || {});\n    context.samlConfiguration.encryptionPublicKey = \"-----BEGIN PUBLIC KEY-----\\nnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END PUBLIC KEY-----\\n\";\n    context.samlConfiguration.encryptionCert = \"-----BEGIN CERTIFICATE-----\\nnnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\";\n\t}\n  callback(null, user, context);\n}\n```\n\nThe following algorithms are used:\n\n*   [AES256](http://www.w3.org/2001/04/xmlenc#aes256-cbc) for assertion encryption\n    \n*   [RSA-OAEP](http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p) (including MGF1 and SHA1) for key transport\n    \n\n## Learn more\n\n*   [Work with Certificates and Keys as Strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings)",
  "title": "Sign and Encrypt SAML Requests",
  "description": "Describes the special configuration scenario to sign and encrypt SAML requests",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-cloud",
  "markdown": "# Configure GitHub Enterprise Cloud as SAML Service Provider\n\nYou can configure Auth0 to serve as an identity provider for [GitHub Enterprise Cloud](https://help.github.com/en/articles/about-authentication-with-saml-single-sign-on) (github.com). GitHub requires an enterprise-level subscription to enable using an external SAML IdP.\n\n*   To learn about SSO on GitHub, read [About authentication with SAML single sign-on](https://help.github.com/en/articles/about-authentication-with-saml-single-sign-on) on [https://docs.github.com](https://docs.github.com/).\n    \n*   To learn how to configure Auth0 as the identity provider for GitHub Enterprise Server (private instance), read [Configure Auth0 as Identity Provider for GitHub Enterprise Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server).\n    \n\n## Configure SAML SSO on Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and create a new application. Give it a meaningful name like **GitHub**. You can choose any application type, but the **Regular Web App** type is recommended.\n    \n2.  Go to the [Addons](https://manage.auth0.com/#/applications/{yourClientId}/addons) tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://github.com/orgs/{YOUR_GITHUB_ORG_NAME}/saml/consume`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://github.com/orgs/{yourGitHubOrgName}\",\n          \"mappings\": {\n        \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"email\": \"emails\",\n        \"name\": \"full_name\"\n          },\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapIdentities\": false,\n          \"signatureAlgorithm\": \"rsa-sha256\",\n          \"digestAlgorithm\": \"sha256\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"\n          ]\n        }\n    ```\n    \n    1.  Replace `{YOUR_GITHUB_ORG_NAME}` with the GitHub organization name that corresponds to your subscription. The mapping will send the `user_id` as the **Name Identifier** to GitHub. This is a good option if you enable more than one connection for the GitHub application, as it will ensure uniqueness (every user will have a different ID).\n        \n    2.  If you are using a single connection, you might want to use the `nickname` or another unique identifier as a friendlier **Name Identifier** (but make sure that the property you choose is unique). As an example, if you want `nickname` as the **Name Identifier**, the `mappings` section above will look like this:\n        \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata** and click **Download** to download the metadata file. You will need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Configure SAML SSO on GitHub\n\n1.  Follow the instructions in GitHub for [Enabling and testing SAML Single Sign-on (SSO) for your organization](https://help.github.com/en/articles/enabling-and-testing-saml-single-sign-on-for-your-organization) to complete the configuration on GitHub Enterprise Cloud.\n    \n2.  You will need the following information:\n    \n    | **Field** | **Entry** |\n    | --- | --- |\n    | **Sign On URL** | `https://{yourDomain}/samlp/{CLIENT_ID}`  <br>`{CLIENT_ID}` will be the `client_id` for the GitHub application you just created in Auth0. |\n    | **Issuer** | `urn:auth0:{yourTenant}` |\n    | **Public Certificate** | Download it from `https://{yourDomain}/pem`. Open the downloaded file with a text editor, copy the contents and paste it in the text area on GitHub. |\n    | **Signature method** | `RSA256-SHA256` |\n    | **Digest method** | `SHA256` |\n    \n3.  As recommended in GitHub's documentation, before enabling SAML SSO for your organization, click **Test SAML configuration** to ensure that the information you've entered is correct.\n    \n\nWhen setting up SAML single sign-on (SSO) for your organization, you can test your implementation without affecting your organization members by leaving **Require SAML SSO authentication** **for all members of the organization** unchecked.",
  "title": "Configure GitHub Enterprise Cloud as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for a GitHub Enterprise Cloud (github.com) organization.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server",
  "markdown": "# Configure GitHub Enterprise Server as SAML Service Provider\n\nYou can configure Auth0 as the identity provider using the SAML2 Web App addon for [GitHub Enterprise Server](https://help.github.com/en/enterprise/2.16/admin/user-management/using-saml) (i.e. your private GitHub appliance). If you are looking for instructions to set up Auth0 as the identity provider for GitHub Enterprise Cloud (github.com), read [Configure Auth0 as Identity Provider for GitHub Enterprise Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-cloud) instead.\n\n## Configure SAML SSO on Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and create a new application. Give it a meaningful name like **GitHub**. You can choose any application type, but the **Regular Web App** type is recommended.\n    \n2.  Go to the [Addons](https://manage.auth0.com/#/applications/{yourClientId}/addons) tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to : `https://github.com/orgs/{yourGitHubOrgName}/saml/consume`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"{yourGitHubServerUrl}\",\n          \"mappings\": {\n        \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"email\": \"emails\",\n        \"name\": \"full_name\"\n          },\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapIdentities\": false,\n          \"signatureAlgorithm\": \"rsa-sha256\",\n          \"digestAlgorithm\": \"sha256\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"\n          ]\n        }\n    ```\n    \n    Replace `{yourGitHubOrgName}` with the GitHub organization name that corresponds to your GitHub subscription. For example `https://github.yourname.com`.\n    1.  The above mapping will send the `user_id` as the **Name Identifier** to GitHub. Use this option if you enable more than one connection for the GitHub application, as it will ensure uniqueness (every user will have a different ID).\n        \n    2.  If you are using a single connection, you might prefer to use the `nickname` or another unique identifier as a friendlier **Name Identifier**, but make sure that the property you choose is unique.\n        \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Configure SAML SSO on GitHub\n\nFollow the instructions in [Using SAML on Enterprise Server- GitHub Help](https://help.github.com/en/enterprise/admin/user-management/using-saml#configuring-saml-settings) to complete the configuration on GitHub Enterprise Cloud. You will need the following information:\n\n| **Field** | **Entry** |\n| --- | --- |\n| **Sign On URL** | `https://{yourDomain}/samlp/{CLIENT_ID}`  <br>`{CLIENT_ID}` will be the `client_id` for the GitHub application you just created in Auth0. |\n| **Issuer** | `urn:auth0:{yourTenant}` |\n| **Verification Certificate** | Download it from `https://{yourDomain}/pem`. Open the downloaded file with a text editor, copy the contents and paste it in the text area on GitHub. |\n| **User Attributes** | Leave the defaults here, as the mapping that we configured in the SAML Web App addon uses the default attribute names proposed by GitHub. |\n| **Signature method** | `RSA256-SHA256` |\n| **Digest method** | `SHA256` |",
  "title": "Configure GitHub Enterprise Server as SAML Service Provider",
  "description": "Learn how to configure Auth0 as the identity provider using the SAML2 Web App addon for a GitHub Enterprise Server private instance.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-heroku",
  "markdown": "# Configure Heroku as SAML Service Provider\n\nUse the following SAML configuration for Heroku.\n\n## Configure SAML SSO in Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to the **ACS URL** for your organization from the Settings page in the Single Sign-On section in Heroku.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"audience\":\"THE-HEROKU-ENTITY-ID\",\n         \"mappings\": {\n           \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n         },\n         \"createUpnClaim\": false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\": false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n         ]\n        }\n    ```\n    \n    The `audience` parameter is the **Heroku Entity ID** from the Settings page in Heroku. It will be formatted like this: `https://sso.heroku.com/saml/{yourHerokuOrg}.`\n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider in Heroku.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Configure SAML SSO in Heroku\n\nIn Heroku, on the Settings page in the Single Sign-On section, click **Upload Metadata** and select the file containing the **Identity Provider Metadata** you downloaded in the previous step.",
  "title": "Configure Heroku as SAML Service Provider",
  "description": "Learn how to configure the Auth0 as an identity provider using the SAML2 Web App Addon for Heroku.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-addon-eloqua",
  "markdown": "# Configure Oracle Eloqua Marketing Cloud as SAML Service Provider\n\nUse the following SAML configuration for Oracle Eloqua Marketing Cloud.\n\n## Configure SAML SSO in Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of the application you want to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://login.eloqua.com/auth/saml2/acs`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n        \"audience\": \"<Service Provider Entity Url from within Eloqua>\",\n         \"recipient\": \"https://login.eloqua.com/auth/saml2/acs\",\n           \"mappings\": {\n        \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n        \"name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\",\n           },\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n         \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n        ],\n         \"destination\": \"https://login.eloqua.com/auth/saml2/acs\"\n          }\n    ```\n    \n    Note that the `audience` is set to `http://foo`. This will be changed when the identity provider settings are completed on the Eloqua side.\n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate the **Identity Provider Metadata** and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider in Eloqua.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Configure SAML SSO in Oracle Eloqua\n\n1.  Login as Admin on Eloqua and click on **Settings > Users > Single Sign-On > Identity Provider Settings**.\n    \n2.  Click **Upload Identity Provider from Metadata**. Upload the **Identity Provider metadata** you downloaded from the **Usage** tab in the Auth0 Dashboard.\n    \n3.  Browse to find the downloaded metadata file.\n    \n4.  Edit the newly added identity provider and complete the following steps:\n    \n    1.  Set the **User Identity Mapping** to `Assertion contains the Email Address from the User object` and click **Save**.\n        \n    2.  From the **Identity Provider Details** copy the **Service Provider Entity URL**.\n        \n    3.  Within ELOQUA IdP settings, if this is the default IdP, mark this IdP as default.\n        \n\n## Update Audience Restriction in Auth0\n\nUse the **Service Provider Entity URL** copied from the identity provider settings in Eloqua to set the `audience` restriction in the Auth0 Dashboard.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click the name of the application you want to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, update the `audience` to the value you copied from Eloqua.\n    \n\n## Test configuration\n\n**Login to Eloqua with Auth0** should be enabled now. You can sign in to Eloqua with both IdP-initiated login and SP-initiated login.\n\n*   For SP-initiated login, go to [https://login.eloqua.com/auth/saml2](https://login.eloqua.com/auth/saml2) and enter your company name and start the SAML login process with Auth0.\n    \n*   For IdP-Initiated login use the **Identity Provider Login URL** defined here: **Dashboard > Applications > Applications** on the **Addons** tab, **SAML 2 Web App**, **Usage** tab.",
  "title": "Configure Oracle Eloqua Marketing Cloud as SAML Service Provider",
  "description": "Learn how to configure the Auth0 as the identity provider using the SAML2 Web App addon for Oracle Eloqua.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/update-root-attributes-for-users",
  "markdown": "# Update Root Attributes for Users\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/USER_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: '{ \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/USER_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\n\nlet postData = NSData(data: \"{ \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Update Root Attributes for Users",
  "description": "Learn how to update root attributes in existing user profiles using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2017-16897",
  "markdown": "# CVE-2017-16897: Security Update for passport-wsfed-saml2 Passport Strategy Library\n\n**Published**: December 22, 2017\n\n**CVE number**: CVE-2017-16897\n\n**Credit**: Alan Bishop\n\n## Overview\n\nA vulnerability has been discovered in the [passport-wsfed-saml2 library](https://github.com/auth0/passport-wsfed-saml2) affecting versions < `3.0.5`. **passport-wsfed-saml2** is a WS-Federation protocol and SAML2 tokens authentication provider for [Passport.js](http://passportjs.org/).\n\nThis vulnerability allows an attacker to impersonate another user and potentially elevate their privileges if the SAML identity provider does not sign the full SAML response, but instead only signs the assertion within the response.\n\nAn attacker who successfully exploits this vulnerability could use that response to craft a request with a different **NameIdentifier** in order to log in as a different user. A malicious actor could also perform a privilege escalation attack if authenticating as a specific user with administrative privileges. The attacker must have an existing account, or be able to intercept the encrypted traffic and modify the SAML response on the fly.\n\nThis update addresses the vulnerability by avoiding wrapping attacks for **Assertion** and **Response** elements, as well as providing some defensive changes in XPath expressions. An update has also been implemented to improve the method of logging information about the signing of the SAML response.\n\nPatching this vulnerability requires a library upgrade.\n\n## Am I affected?\n\nThis vulnerability affected cloud tenants utilizing the **SAMLP Identity Provider Connection** wherein the identity provider either:\n\n*   signed SAML response and signed assertion\n    \n*   did not sign SAML response and signed assertion\n    \n\nNo action is required for Auth0 cloud tenants.\n\nThe vulnerability scope also extended to those using the [passport-wsfed-saml2 strategy with passport.js](https://github.com/auth0/passport-wsfed-saml2), which requires a library upgrade (see the next section).\n\n## How to fix that?\n\nDevelopers using the **passport-wsfed-saml2** library need to upgrade to the latest version: `3.0.5`.\n\nUpdated packages are available on npm. To ensure delivery of additional bug fixes moving forward, please make sure your `package.json` file is updated to take patch and minor level updates of our libraries.\n\n```\n{\n  \"dependencies\": {\n    \"passport-wsfed-saml2\": \"^3.0.5\"\n  }\n}\n```\n\n### Will this update impact my users?\n\nNo. This fix patches the library that your application runs, but will not impact your users, their current state, or any existing sessions.",
  "title": "CVE-2017-16897: Security Update for passport-wsfed-saml2 Passport Strategy Library",
  "description": "CVE-2017-16897: Security Update for passport-wsfed-saml2 Passport strategy library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/classic-login/customize-lock-error-messages",
  "markdown": "# Customize Lock Error Messages\n\nYou can customize the error messages that will be displayed in certain situations by providing a `languageDictionary` option. A full listing of available `languageDictionary` fields to customize can be found in the GitHub repository's [English Dictionary file for Lock](https://github.com/auth0/lock/blob/master/src/i18n/en.js). Below is an example of some customized error messages:\n\nto configure this snippet with your account\n\n```\n// Examples of customized error messages in the languageDictionary option\nvar options = {\n  languageDictionary: {\n    error: {\n      login: {\n        \"lock.invalid_email_password\": \"Custom message about invalid credentials\",\n        \"lock.network\": \"Custom message indicating a network error and suggesting the user check connection\",\n        \"lock.unauthorized\": \"Custom message about a failure of permissions\",\n        \"too_many_attempts\": \"Custom message indicating the user has failed to login too many times.\"\n      },\n      signUp: {\n        \"invalid_password\": \"Custom message indicating a password was invalid\",\n        \"user_exists\": \"Custom message indicating that a user already exists\"\n      }\n    }\n  }\n};\n\n// Initiating our Auth0Lock\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}',\n  options\n);\n```\n\n## Custom errors in Rules\n\nIf you are returning custom error codes from a [rule](https://auth0.com/docs/customize/rules) or a custom database script, you can handle custom errors:\n\n*   In your application's redirect URL by reading the `error` and `error_mesage` query string parameters.\n    \n*   By redirecting the user back to your hosted pages with a custom error message and displaying the message with a [flash message](https://auth0.com/docs/libraries/lock/lock-api-reference).\n    \n\n## Learn more\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)",
  "title": "Customize Lock Error Messages",
  "description": "Customizing error messages with Lock",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/choose-a-connection-type-for-azure-ad",
  "markdown": "# Choose a Connection Type for Azure AD\n\nYou can connected your Auth0 instance to Microsoft Azure Active Directory in three ways. Review the options to determine the best approach for your situation.\n\nAuth0 recommends starting with the native Microsoft Azure AD connection. If you need further customization, review the SAML connection configuration. Also, if your organization has additional restrictions on OAuth code flows, review the Enterprise OIDC configuration.\n\nThe table below illustrates the main differences in these connection types. Review these capabilities to determine the best connection type for your organization.\n\n| Connection Type | “Native” Azure AD | Enterprise OIDC | SAML |\n| --- | --- | --- | --- |\n| **Protocol** | OAuth authorization code flow | OAuth implicit flow OR OAuth authorization code flow | SAML |\n| **Can receive optional claims from Azure AD?** | No  | Yes | Yes |\n| **Federated logout support (“Single Logout” or SLO)** | Yes | No  | Yes |\n| **Receive AD Groups** | Yes, friendly names | Yes, object IDs | Yes, object IDs |\n| **Receive Extended Profile** | Yes | No  | No  |\n\n## Microsoft Azure AD\n\nThe first connection type is the **Microsoft Azure AD** connection in [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/dashboard/#/connections/enterprise).\n\nThis connection type uses the OAuth authorization code flow. The Microsoft Azure AD connection accepts claims from an `id_token` and directly queries the Microsoft Graph API. If configured, the query searches for groups and additional profile information. Microsoft Azure AD ignores any custom claims included in the `id_token`.\n\n### Connection Features and Considerations\n\nBecause this connection type is the native workflow, it is explicitly compatible with extended AD features. The Azure AD connection maps profile attributes directly to your Auth0 user profiles from the Microsoft Graph API.\n\nThe extended profile option offers three attributes not available in other connection types. You must [enable permission to query the Microsoft Graph API](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2#add-permissions) to use the receive the extended profile features.The table below compares the Azure AD Graph Attributes across the connection types:\n\n| Graph Attribute | Auth0 Profile Attribute | Data type | Equivalent optional claim for OIDC or SAML |\n| --- | --- | --- | --- |\n| businessPhones | phone | array | \\-  |\n| givenName | given\\_name | string | given\\_name |\n| jobTitle | job\\_title | string | \\-  |\n| mobilePhone | mobile | string | \\-  |\n| preferredLanguage | preferred\\_language | string | xms\\_pl |\n| surname | family\\_name | string | family\\_name |\n| userPrincipalName | upn | string | upn |\n\n### Group Configuration\n\nIf you [enable permission to query the Microsoft Graph API](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2#add-permissions), Auth0 automatically retrieves groups for the user and maps these to the `groups` attribute in the Auth0 profile. Auth0 maps these group \"friendly names\" and does not need to configure a custom claim because these groups map directly from the Microsoft Graph API.\n\n## SAML\n\nThe SAML connection type uses the SAML protocol and supports attribute mapping and all standard SAML features.\n\n### Connection Features and Considerations\n\nThe SAML connection type is the most flexible of the available connection types because it supports optional claims and [federated logouts](https://docs.microsoft.com/en-us/azure/active-directory/develop/single-sign-out-saml-protocol). If you need both of these features, SAML is the only connection type that supports both simultaneously.\n\n### Group Configuration\n\nFor Auth0 to accept group information with the SAML connection type, you must configure your Azure AD with optional attributes in the SAML response. Auth0 then maps the groups to the `group_ids` attribute in the user's Auth0 profile.\n\n## Enterprise OIDC\n\nThe Enterprise Open ID Connect type can use either OAuth Implicit or Authorization Code workflows. This connection maps custom claims in the `id_token` to the Auth0 User Profile. To learn more about authentication flows, visit the [Authentication and Authorization Flows documentation](https://auth0.com/docs/get-started/authentication-and-authorization-flow).\n\n### Connection Features and Considerations\n\nIf you cannot provide client secrets in your login flow due to regulations or privacy protocols, the Implicit Flow the OIDC connection offers could be a preferred method. If you require custom claims but do not want to configure the additional SAML features, the OIDC connection can reduce complexity.\n\n### Group Configuration\n\nFor Auth0 to accept group information with the OIDC connection type, you must configure your Azure AD with an optional claim to add `groups` in the `id_token` of your request. Auth0 then maps these groups to the `group_ids` attribute in the user’s Auth0 profile.\n\n## Learn more\n\n*   [Connect Your App to Microsoft Azure Active Directory](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2)",
  "title": "Choose a Connection Type for Azure AD",
  "description": "Describes Azure connection types and features.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock/lock-authentication-parameters",
  "markdown": "# Lock Authentication Parameters\n\nYou can send parameters when starting a login by adding them to the options object. The example below adds a `state` parameter with a value equal to `'foo'`.\n\n```\nvar options = {\n  auth: {\n    params: {state: 'foo'},\n  }\n};\n```\n\nThe above example would be analogous to triggering the login with `https://{yourDomain}/authorize?state=foo&...`.\n\nThe following parameters are supported: `scope`, `device`, `nonce` and `state`.\n\n## Supported parameters\n\n### scope {string}\n\n```\nvar options = {\n  auth: {\n    params: {scope: 'openid email user_metadata app_metadata picture'},\n  }\n};\n```\n\nThere are different values supported for scope. Keep in mind that JWTs are sent on every API request, so it is desirable to keep them as small as possible.\n\nThe default `scope` value in Lock is `openid profile email`. This minimum scope value is required to make the **Last time you logged in with** feature work correctly.\n\n#### Running Lock locally\n\nIf you don't manually specify at least the default scope of `openid profile email` when initializing Lock, and you are running your website from `http://localhost` or `http://127.0.0.1`, you will get the following error in the browser console:\n\n`Consent required. When using getSSOData, the user has to be authenticated with the following scope: openid profile email`\n\nThat will **not** happen when you run your application in production or if you specify the `openid profile email` scope. You can read more about this in the [User consent and third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications) document.\n\nFor more information about scopes, see the [scopes documentation page](https://auth0.com/docs/get-started/apis/scopes).\n\n#### Example: retrieve a token\n\nIn Lock, if you wish to receive a token with the ability to fetch the user's profile data, you should add the `scope` parameter.\n\n```\nvar options = {\n  auth: {\n    params: {\n        scope: 'openid profile'\n    }\n  }\n};\n```\n\nThere is also a `connectionScopes` configuration option for Lock, which allows you to specify scopes on any specific connection. This will be useful if you want to initially start with a set of scopes (defined on the dashboard), but later on request additional permissions or attributes from a specific connection. Read more about it on the [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration) page.\n\n### state {string}\n\nThe `state` parameter is an arbitrary state value that will be maintained across redirects. It is useful to mitigate [XSRF attacks](http://en.wikipedia.org/wiki/Cross-site_request_forgery) and for any contextual information, [such as a return url](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout) that you might need after the authentication process is finished. If a custom state parameter is not provided, Lock will automatically generate one. For more information, see [State Parameter](https://auth0.com/docs/secure/attack-protection/state-parameters).\n\n### nonce {string}\n\nThe `nonce` parameter is used to help prevent replay attacks, and will be automatically generated by Lock if a custom value is not provided.\n\n### device {string}\n\nThe `device` parameter sets the name of the device or browser requesting authentication.",
  "title": "Lock Authentication Parameters",
  "description": "Lock documentation on setting authentication parameters.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object",
  "markdown": "# Actions Triggers: post-login - Event Object\n\nThe `event` object for the post-login Actions trigger provides contextual information about a single user logging in via Auth0.\n\n| Property | Description |\n| --- | --- |\n| `event.authentication`<br><br>_(Optional)_ | Details about authentication signals obtained during the login flow.<br><br>Includes the following properties:<br><br>*   `methods` _Array of objects_.<br>    <br>    Contains the authentication methods a user has completed during their session.<br>    <br>    Array elements:<br>    <br>    *   One of the following object schemas:<br>        <br>        *   An object with the following properties:<br>            <br>            *   `name` _String_.<br>                <br>                The name of the first factor that was completed. Values include the following:<br>                <br>                *   `\"federated\"` A social or enterprise connection was used to authenticate the user as the first factor.<br>                *   `\"pwd\"` A password was used to authenticate a database connection user as the first factor.<br>                *   `\"passkey\"` A passkey was used to authenticate a database connnection user as the first factor.<br>                *   `\"sms\"` A Passwordless SMS connection was used to authenticate the user as the first factor.<br>                *   `\"email\"` A Passwordless Email connection was used to authenticate the user as the first factor or verify email for password reset.<br>                *   `\"phone_number\"` A phone number was used for password reset.<br>                *   `\"mock\"` Used for internal testing.<br>                *   `string` A custom authentication method denoted by a URL (as second or later factor).<br>            *   `timestamp` _String_.<br>        *   An object with the following properties:<br>            <br>            *   `name` _The value \"mfa\"_. The user completed multi-factor authentication (second or later factors).<br>            *   `timestamp` _String_.<br>*   `riskAssessment` _Optional object_.<br>    <br>    Details about risk assessments obtained during the login or password reset flow.<br>    <br>    Includes the following properties:<br>    <br>    *   `assessments` _Object_.<br>        <br>        Includes the following properties:<br>        <br>        *   `ImpossibleTravel` _Optional object_.<br>            <br>            Determines if the user is logging in from a location signaling impossible travel.<br>            <br>            Includes the following properties:<br>            <br>            *   `code` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `minimal_travel_from_last_login`<br>                *   `travel_from_last_login`<br>                *   `substantial_travel_from_last_login`<br>                *   `impossible_travel_from_last_login`<br>                *   `invalid_travel`<br>                *   `missing_geoip`<br>                *   `anonymous_proxy`<br>                *   `unknown_location`<br>                *   `initial_login`<br>                *   `location_history_not_found`<br>                *   `assessment_not_available`<br>            *   `confidence` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `low`<br>                *   `medium`<br>                *   `high`<br>                *   `neutral`<br>        *   `NewDevice` _Optional object_.<br>            <br>            Determines if the user is logging in from a known device.<br>            <br>            Includes the following properties:<br>            <br>            *   `code` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `match`<br>                *   `partial_match`<br>                *   `no_match`<br>                *   `initial_login`<br>                *   `unknown_device`<br>                *   `no_device_history`<br>                *   `assessment_not_available`<br>            *   `confidence` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `low`<br>                *   `medium`<br>                *   `high`<br>                *   `neutral`<br>            *   `details` _Optional object_.<br>                <br>                Includes the following properties:<br>                <br>                *   `device` _Optional string_.<br>                    <br>                    Possible values include:<br>                    <br>                    *   `known`<br>                    *   `unknown`<br>                *   `useragent` _Optional string_.<br>                    <br>                    Possible values include:<br>                    <br>                    *   `known`<br>                    *   `unknown`<br>        *   `UntrustedIP` _Optional object_.<br>            <br>            Shows if the IP was found in Auth0's repository of low reputation IPs.<br>            <br>            Includes the following properties:<br>            <br>            *   `code` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `not_found_on_deny_list`<br>                *   `found_on_deny_list`<br>                *   `invalid_ip_address`<br>                *   `assessment_not_available`<br>            *   `confidence` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `low`<br>                *   `medium`<br>                *   `high`<br>                *   `neutral`<br>            *   `details` _Optional object_.<br>                <br>                Includes the following properties:<br>                <br>                *   `category` _Optional string_.<br>                *   `ip` _Optional string_. The originating IP address of the request.<br>                *   `matches` _Optional string_.<br>                *   `source` _Optional string_.<br>    *   `confidence` _String_.<br>        <br>        Overall risk score<br>        <br>        Possible values include:<br>        <br>        *   `low`<br>        *   `medium`<br>        *   `high`<br>        *   `neutral`<br>    *   `version` _String_. |\n| `event.authorization`<br><br>_(Optional)_ | An object containing information describing the authorization granted to the user who is logging in.<br><br>Includes the following properties:<br><br>*   `roles` _Array of strings_. An array containing the names of a user's assigned roles. |\n| `event.client` | Information about the Client with which this login transaction was initiated.<br><br>Includes the following properties:<br><br>*   `client_id` _String_. The client id of the application the user is logging in to.<br>*   `metadata` _Dictionary_. An object for holding other application properties.<br>*   `name` _String_. The name of the application (as defined in the Dashboard). |\n| `event.connection` | Details about the Connection that was used to authenticate the user.<br><br>Includes the following properties:<br><br>*   `id` _String_. The connection's unique identifier.<br>*   `metadata` _Optional dictionary_. Metadata associated with the connection.<br>*   `name` _String_. The name of the connection used to authenticate the user (such as `twitter` or `some-g-suite-domain`).<br>*   `strategy` _String_. The type of connection. For social connections, `event.connection.strategy === event.connection.name`. For enterprise connections, the strategy is `waad` (Windows Azure AD), `ad` (Active Directory/LDAP), `auth0` (database connections), and so on. |\n| `event.organization`<br><br>_(Optional)_ | Details about the Organization associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `display_name` _String_. The friendly name of the Organization.<br>*   `id` _String_. The Organization identifier.<br>*   `metadata` _Dictionary_. Metadata associated with the Organization.<br>*   `name` _String_. The name of the Organization. |\n| `event.refresh_token`<br><br>_(Optional)_ | \\[Private Early Access\\] The current refresh token.<br><br>Includes the following properties:<br><br>*   `client_id` _Optional string_. \\[Private Early Access\\] The ID of the client associated with the refresh token.<br>*   `created_at` _String_. \\[Private Early Access\\] Timestamp of when the refresh token was created.<br>*   `device` _Optional object_.<br>    <br>    Includes the following properties:<br>    <br>    *   `initial_asn` _Optional string_. \\[Private Early Access\\] First autonomous system number associated with this refresh token.<br>    *   `initial_ip` _Optional string_. \\[Private Early Access\\] First IP address associated with this refresh token.<br>    *   `initial_user_agent` _Optional string_. \\[Private Early Access\\] First user agent of the device associated with this refresh token.<br>    *   `last_asn` _Optional string_. \\[Private Early Access\\] Last autonomous system number from which this refresh token was last exchanged.<br>    *   `last_ip` _Optional string_. \\[Private Early Access\\] Last IP address from which this refresh token was last exchanged.<br>    *   `last_user_agent` _Optional string_. \\[Private Early Access\\] Last user agent of the device from which this refresh token was last exchanged.<br>*   `expires_at` _Optional string_. \\[Private Early Access\\] Timestamp of when the refresh token will absolutely expire.<br>*   `id` _String_. \\[Private Early Access\\] The ID of the refresh token.<br>*   `idle_expires_at` _Optional string_. \\[Private Early Access\\] Timestamp of when the refresh token will idle expire.<br>*   `resource_servers` _Optional array of objects_.<br>    <br>    Elements include the following properties:<br>    <br>    *   `audience` _String_. \\[Private Early Access\\] The audience of the refresh token.<br>    *   `scopes` _String_. \\[Private Early Access\\] Scopes of the refresh token.<br>*   `rotating` _Optional boolean_. \\[Private Early Access\\] If the refresh token is a rotating refresh token.<br>*   `session_id` _Optional string_. \\[Private Early Access\\] The ID of the session bound to the refresh token.<br>*   `user_id` _Optional string_. \\[Private Early Access\\] The ID of the user bound to the refresh token. |\n| `event.request` | Details about the request that initiated the transaction.<br><br>Includes the following properties:<br><br>*   `asn` _Optional string_. The ASN (autonomous system number) of the user-agent making the request.<br>*   `body` _Dictionary_. The body of the POST request. This data will only be available during refresh token and Client Credential Exchange flows and Post Login Action.<br>*   `geoip` _Object_.<br>    <br>    Includes the following properties:<br>    <br>    *   `cityName` _Optional string_.<br>    *   `continentCode` _Optional string_.<br>    *   `countryCode` _Optional string_.<br>    *   `countryCode3` _Optional string_.<br>    *   `countryName` _Optional string_.<br>    *   `latitude` _Optional number_.<br>    *   `longitude` _Optional number_.<br>    *   `subdivisionCode` _Optional string_.<br>    *   `subdivisionName` _Optional string_.<br>    *   `timeZone` _Optional string_.<br>*   `hostname` _Optional string_. The hostname that is being used for the authentication flow.<br>*   `ip` _String_. The originating IP address of the request.<br>*   `language` _Optional string_. The language requested by the browser.<br>*   `method` _String_. The HTTP method used for the request<br>*   `query` _Dictionary_. The query string parameters sent to the authorization request.<br>*   `user_agent` _Optional string_. The value of the `User-Agent` header received when initiating the transaction. |\n| `event.resource_server`<br><br>_(Optional)_ | Details about the resource server to which the access is being requested.<br><br>Includes the following properties:<br><br>*   `identifier` _String_. The identifier of the resource server. For example: `https://your-api.example.com`. |\n| `event.session`<br><br>_(Optional)_ | The current login session.<br><br>Includes the following properties:<br><br>*   `authenticated_at` _Optional string_. \\[Private Early Access\\] The date and time when the session was last authenticated.<br>*   `authentication` _Optional object_.<br>    <br>    \\[Private Early Access\\] Details about authentication signals obtained during the login flow.<br>    <br>    Includes the following properties:<br>    <br>    *   `methods` _Array of objects_.<br>        <br>        \\[Private Early Access\\] Contains the authentication methods a user has completed during their session.<br>        <br>        Array elements:<br>        <br>        *   \\[Private Early Access\\] Details about authentication signals obtained during the login flow.<br>            <br>            Includes the following properties:<br>            <br>            *   `name` _String_. \\[Private Early Access\\] One of: \"federated\", \"passkey\", \"pwd\", \"sms\", \"email\", \"mfa\", \"mock\" or a custom method denoted by a URL.<br>            *   `timestamp` _String_. \\[Private Early Access\\] Timestamp of when the signal was received.<br>            *   `type` _Optional string_. \\[Private Early Access\\] A specific MFA factor. Only present when \"name\" is set to \"mfa\"<br>*   `clients` _Optional array of objects_.<br>    <br>    \\[Private Early Access\\] List of client details for the session.<br>    <br>    Elements include the following properties:<br>    <br>    *   `client_id` _String_. \\[Private Early Access\\] ID of client for the session.<br>*   `created_at` _Optional string_. \\[Private Early Access\\] The date and time when the session was created.<br>*   `device` _Optional object_.<br>    <br>    \\[Private Early Access\\] Metadata related to the device used in the session.<br>    <br>    Includes the following properties:<br>    <br>    *   `initial_asn` _Optional string_. \\[Private Early Access\\] First autonomous system number associated with this session.<br>    *   `initial_ip` _Optional string_. \\[Private Early Access\\] First IP address associated with this session.<br>    *   `last_asn` _Optional string_. \\[Private Early Access\\] Last autonomous system number from which this user logged in.<br>    *   `last_ip` _Optional string_. \\[Private Early Access\\] Last IP address from which this user logged in.<br>    *   `last_user_agent` _Optional string_. \\[Private Early Access\\] Last user agent of the device from which this user logged in.<br>*   `expires_at` _Optional string_. \\[Private Early Access\\] The date and time when the session will expire.<br>*   `id` _String_. The ID of the current session.<br>*   `idle_expires_at` _Optional string_. \\[Private Early Access\\] The date and time when the session will expire if idle.<br>*   `updated_at` _Optional string_. \\[Private Early Access\\] The date and time when the session was last updated.<br>*   `user_id` _Optional string_. \\[Private Early Access\\] ID of the user which can be used when interacting with other APIs. |\n| `event.stats` | Login statistics for the current user.<br><br>Includes the following properties:<br><br>*   `logins_count` _Number_. The number of times this user has logged in. |\n| `event.tenant` | Details about the Tenant associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `id` _String_. The name of the tenant. |\n| `event.transaction`<br><br>_(Optional)_ | Details about the current transaction.<br><br>Includes the following properties:<br><br>*   `acr_values` _Array of strings_. Any acr\\_values provided in the original authentication request.<br>*   `linking_id` _Optional string_. Dynamic Linking ID that allows developers to reference this transaction.<br>*   `locale` _String_. The locale to be used for this transaction as determined by comparing the browser's requested languages to the tenant's language settings.<br>*   `login_hint` _Optional string_. Hint to the Authorization Server about the login identifier the End-User might use to log in (if necessary).<br>*   `prompt` _Optional array of strings_. List of instructions indicating whether the user may be prompted for re-authentication and consent.<br>*   `protocol` _Optional string_.<br>    <br>    Possible values include:<br>    <br>    *   `oidc-basic-profile` Most used, web-based login.<br>    *   `oidc-implicit-profile` Used on mobile devices and single-page apps.<br>    *   `samlp` SAML protocol used on SaaS apps.<br>    *   `wsfed` WS-Federation used on Microsoft products like Office365.<br>    *   `wstrust-usernamemixed` WS-trust User/password login used on CRM and Office365.<br>    *   `oauth2-device-code` Transaction using the Device Authorization Flow.<br>    *   `oauth2-resource-owner` User/password login typically used on database connections.<br>    *   `oauth2-resource-owner-jwt-bearer` Login using a bearer JWT signed with user's private key.<br>    *   `oauth2-password` Login using the password exchange.<br>    *   `oauth2-access-token` Refreshing a token using the refresh token exchange.<br>    *   `oauth2-refresh-token` Refreshing a token using the refresh token exchange.<br>    *   `oauth2-token-exchange`<br>    *   `oidc-hybrid-profile` Allows your application to have immediate access to an ID token while still providing for secure and safe retrieval of access and refresh tokens.<br>*   `redirect_uri` _Optional string_. The URL to which Auth0 will redirect the browser after the transaction is completed.<br>*   `requested_authorization_details` _Optional array of objects_.<br>    <br>    The details of a rich authorization request per Section 2 of the Rich Authorization Requests spec at https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar#section-2.<br>    <br>    Elements include the following properties:<br>    <br>    *   `type` _String_. The type of authorization details as a string. The value of the type field determines the allowable contents of the object which contains it.<br>*   `requested_scopes` _Array of strings_. The scopes requested (if any) when starting this authentication flow.<br>*   `response_mode` _Optional string_.<br>    <br>    Informs the Authorization Server of the mechanism to be used for returning parameters from the Authorization Endpoint.<br>    <br>    Possible values include:<br>    <br>    *   `query`<br>    *   `fragment`<br>    *   `form_post`<br>    *   `web_message`<br>*   `response_type` _Optional array of strings_.<br>    <br>    Possible values include:<br>    <br>    *   `code`<br>    *   `token`<br>    *   `id_token`<br>*   `state` _Optional string_. An opaque arbitrary alphanumeric string your app adds to the initial request that Auth0 includes when redirecting back to your application.<br>*   `ui_locales` _Array of strings_. The ui\\_locales provided in the original authentication request. |\n| `event.user` | An object describing the user on whose behalf the current transaction was initiated.<br><br>Includes the following properties:<br><br>*   `app_metadata` _Dictionary_. Custom fields that store info about a user that influences the user's access, such as support plan, security roles, or access control groups.<br>*   `created_at` _String_. Timestamp indicating when the user profile was first created.<br>*   `email` _Optional string_. (unique) User's email address.<br>*   `email_verified` _Boolean_. Indicates whether the user has verified their email address.<br>*   `enrolledFactors` _Optional array of objects_.<br>    <br>    An an array of authentication factors that the user has enrolled.<br>    <br>    Array elements:<br>    <br>    *   An object describing an enrolled authentication factor type and any factor-specific options.<br>        <br>        Includes the following properties:<br>        <br>        *   `options` _Optional dictionary_. Additional options describing this instance of the enrolled factor.<br>        *   `type` _String_. The type of authentication factor such as `push-notification`, `phone`, `email`, `otp`, `webauthn-roaming` and `webauthn-platform`.<br>*   `family_name` _Optional string_. User's family name.<br>*   `given_name` _Optional string_. User's given name.<br>*   `identities` _Array of objects_.<br>    <br>    Contains info retrieved from the identity provider with which the user originally authenticates. Users may also link their profile to multiple identity providers; those identities will then also appear in this array. The contents of an individual identity provider object varies by provider.<br>    <br>    Elements include the following properties:<br>    <br>    *   `connection` _Optional string_. Name of the Auth0 connection used to authenticate the user.<br>    *   `isSocial` _Optional boolean_. Indicates whether the connection is a social one.<br>    *   `profileData` _Optional dictionary_. User information associated with the connection. When profiles are linked, it is populated with the associated user info for secondary accounts.<br>    *   `provider` _Optional string_. Name of the entity that is authenticating the user, such as Facebook, Google, SAML, or your own provider.<br>    *   `user_id` _Optional string_. User's unique identifier for this connection/provider.<br>*   `last_password_reset` _Optional string_. Timestamp indicating the last time the user's password was reset/changed. At user creation, this field does not exist. This property is only available for Database connections.<br>*   `multifactor` _Optional array of strings_. List of multi-factor authentication (MFA) providers with which the user is enrolled. This array is updated when the user enrolls in MFA and when an administrator resets a user's MFA enrollments.<br>*   `name` _Optional string_. User's full name.<br>*   `nickname` _Optional string_. User's nickname.<br>*   `phone_number` _Optional string_. User's phone number.<br>*   `phone_verified` _Optional boolean_. Indicates whether the user has verified their phone number.<br>*   `picture` _Optional string_. URL pointing to the [user's profile picture](https://auth0.com/docs/users/change-user-picture).<br>*   `updated_at` _String_. Timestamp indicating when the user's profile was last updated/modified.<br>*   `user_id` _String_. (unique) User's unique identifier.<br>*   `user_metadata` _Dictionary_. Custom fields that store info about a user that does not impact what they can or cannot access, such as work address, home address, or user preferences.<br>*   `username` _Optional string_. (unique) User's username. |",
  "title": "Actions Triggers: post-login - Event Object",
  "description": "Learn about the post-login Action trigger's event object, which provides contextual information about a single user logging in via Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow",
  "markdown": "# Login Flow\n\nThe Login Flow runs when a user logs in to any application in an Auth0 tenant.\n\n![Diagram showing the Actions Login Flow.](https://images.ctfassets.net/cdy7uua7fh8z/2SkfIOm4fFOJ8N0GNJwam8/6615558d16d5827b985434f497b42b8d/Login_Flow__1_.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### Login / Post Login\n\nThe `post-login` trigger is a function executed after a user logs in and when a Refresh Token is requested.\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object): Provides contextual information about a single user logging in via Auth0.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Common use cases\n\n### Access control\n\nA post-login Action can be used to provide custom logic used to deny access to a user who is attempting to access an application:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.user.email && event.user.email.endsWith(\"@example.com\") && event.client.name === \"My SPA\") {\n    api.access.deny(`Access to ${event.client.name} is not allowed.`);\n  }\n};\n```\n\n### Allow access only on weekdays for a specific application\n\nLet's say you have an application that you want to make sure is only accessible during weekdays. To do this, you would create the following Action:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\n exports.onExecutePostLogin = async (event, api) => {\n  if (event.client.name === \"APP_NAME\") {\n    const d = new Date().getDay();\n\n    if (d === 0 || d === 6) {\n      api.access.deny(\"This app is only available during the week.\");\n    }\n  }\n}\n```\n\n### Deny access to anyone calling an API\n\nLet's say you want to deny access to all users who are calling an API. This means that you need to deny access depending on the audience value for your API, which you can find in the **API Audience** field of your API in [Dashboard > Applications > APIs](https://manage.auth0.com/#/apis). To do this, you would create the following Action:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\n exports.onExecutePostLogin = async (event, api) => {\n  // In Actions, an API will be referred to as a Resource Server.\n  if (event.resource_server && event.resource_server.identifier === \"http://todoapi2.api\") {\n    api.access.deny(\"end_users_not_allowed\");\n  }\n}\n```\n\n### Add user roles to ID and Access tokens\n\nTo add user roles to Auth0-issued tokens, use the `event.authorization` object along with the `api.idToken.setCustomClaim` and `api.accessToken.setCustomClaim` methods:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  const namespace = 'https://my-app.example.com';\n  if (event.authorization) {\n    api.idToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);\n    api.accessToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);\n  }\n}\n```\n\n*   A custom claim cannot include certain terms, and we strongly recommend using namespaced claim that takes the form of a URI. See [our documentation on custom claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims) for more information.\n    \n*   The JWT returned to the requesting application is built and signed at the end of the trigger processing. The final, signed JWT is not accessible in an Action.\n    \n\n### Enrich the user profile\n\nAuth0 provides a system for storing metadata on a [User Profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles). In order to set `user_metadata` or `app_metadata` on a user’s profile during their login, use the `api.user.setUserMetadata` or `api.user.setAppMetadata` functions.\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  api.user.setUserMetadata(\"favorite_color\", \"blue\");\n};\n```\n\nOnce all post-login actions have been executed, Actions will update the user profile in a single operation. This operation is subject to the \"Write Users\" [rate limit](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits).\n\n### Enforce custom MFA policy\n\nA post-login Action can be used to dynamically require MFA for a user according to your application’s needs.\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  // Require MFA for anyone logging in from North America.\n  if (event.request.geoip.continentCode === \"NA\") {\n    api.multifactor.enable(\"any\");\n  };\n};\n```\n\nAn MFA Provider must be configured in order to enable MFA during a login. To learn more, read [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication).\n\n### Reduce friction with passkeys\n\nA post-login Action can be used to reduce the friction by dynamically skipping MFA for a user that has authenticated with a passkey.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n // Check if a passkey was used to authenticate\n const skipMFA = event.authentication?.methods.some(\n   (method) => method.name === \"passkey\"\n );\n\n // If a passkey was used skip MFA\n if (skipMFA) {\n   api.multifactor.enable(\"none\");\n }\n};\n```\n\nThe connection must have passkeys and MFA enabled. To learn more, read [Passkeys](https://auth0.com/docs/authenticate/database-connections/passkeys) and [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication).\n\n### Redirect the user to an external site\n\nSimilar to [Redirect Rules](https://auth0.com/docs/customize/rules/redirect-users), a post-login Action can be used to send the user to an external site. When completed, the user can be redirected back to Auth0 to continue their login flow. In the example below, a Redirect Action is used to prompt the user to provide their favorite color.\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  // Skip the redirect if the user has already chosen a favorite color.\n  if (event.user.user_metadata.favorite_color) {\n    return;\n  }\n\n  const token = api.redirect.encodeToken({\n    secret: event.secrets.MY_SHARED_SECRET,\n    payload: {\n      email: event.user.email,\n    },\n  });\n\n  // Send the user to https://my-app.example.com along\n  // with a `session_token` query string param.\n  api.redirect.sendUserTo(\"https://my-app.example.com\", { \n    query: { session_token: token }\n  });\n};\n\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onContinuePostLogin = async (event, api) => {\n  // Once the /continue endpoint has been called, unpack the signed token\n  // and store the favorite color as user metadata.\n\n  const payload = api.redirect.validateToken({\n    secret: event.secrets.MY_SHARED_SECRET,\n  });\n\n  api.user.setUserMetadata(\"favorite_color\", payload.favorite_color);\n};\n```\n\nThe Actions pipeline will be suspended while the user is redirected. Once the user continues their Auth0 login process, the Actions pipeline will resume where it was suspended. Actions that were executed prior to the Redirect will not be executed again.\n\nTo learn more about Redirect Actions, read [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions).\n\n### Modify scopes on an access token\n\nWhen modifying the scopes associated with an access token, ensure you adhere to the best practices surrounding audience specification.\n\n*   Always check for expected audience before adding scopes.\n    \n*   Prevent using untrusted input when adding scopes.\n    \n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.request.query.audience === 'https://example.com/api') {\n    api.accessToken.addScope(\"read:xyz\");\n  }\n};\n```\n\n## Learn more\n\n*   [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata)\n*   [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions)\n*   [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata)",
  "title": "Login Flow",
  "description": "Learn about the Actions Login Flow and the post-login Action trigger, which is executed after a user logs in and when a Refresh Token is requested.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/releases",
  "markdown": "# Releases\n\nFeatures and breaking changes released in versions of Triggers in the Login Flow are listed below.\n\n## v3 (GA)\n\n### Post-login\n\n#### Breaking changes\n\n*   `api.redirect.canRedirect()` marked as deprecated.\n    \n*   `api.redirect.sendUserTo()` will no longer skip redirecting when in a non-interactive flow. This means that calls to `api.redirect.sendUserTo()` should first check if the redirect is needed before issuing the redirect. Information like `event.authentication.methods` can be consulted to see if a redirect was successfully completed and recorded via `api.authentication.recordMethod()`. Attempting to trigger a redirect in a non-interactive flow will correctly trigger an `interaction_required` error.\n    \n\n#### New features\n\n*   `event.authentication.methods` may now also contain custom methods completed by users within that session and recorded using `api.authentication.recordMethod()` from the `onContinuePostLogin` handler.\n    \n*   `api.authentication.recordMethod()` is added as a way to store a record for the completion of a custom method in the user’s session. These APIs allow you to strictly require custom factors for certain scenarios. The user (on a specific device) will be required to complete the custom factor, regardless of whether or not an interactive login is happening. If the conditions are met for requiring the custom factor and the user’s session doesn’t have a record of its completion, the interactivity of the flow shouldn’t influence whether the factor is required or not. For example, if you wanted to implement a required custom factor, you would set up the following:\n    \n    1.  In `onExecutePostLogin`, search for a record in the `event.authentication.methods` array with the custom method’s identifier URL. If the method is there and has a current enough timestamp, allow the login to continue. Otherwise, trigger a redirect to the URL implementing the custom factor using `api.redirect.sendUserTo()`. Custom data can be encoded into a JWT and signed using `api.redirect.encodeToken()`.\n        \n    2.  When the user is redirected to `/continue`, the `onContinuePostLogin` handler will be invoked. Within that handler, validate any data coming back from the custom factor (if needed) and signal its completion by calling `api.authentication.recordMethod()`.\n        \n\n## v2 (GA)\n\n### Post-login\n\n#### Breaking changes\n\n##### Perform side effects\n\nIn the pre-GA version of the post-login trigger, side effects were performed by returning an object from an Action. In Actions GA, an `api` object is provided to encapsulate these changes and provide better in-editor type hints and inline documentation.\n\n**Update user user\\_metadata**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    user: {\n      userMetadata: {\n        myParam: \"foo\"\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.user.setUserMetadata('myParam', 'foo');\n}\n```\n\n**Update user app\\_metadata**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    user: {\n      appMetadata: {\n        myParam: \"foo\"\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.user.setAppMetadata('myParam', 'foo');\n}\n```\n\n**Deny a login**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  throw new Error(\"Access denied.\");\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.access.deny(\"Access denied.\");\n}\n```\n\n**Add Custom Claims to the Access Token**\n\nPre-GA Trigger:\n\n```\nasync function myFunc(event, context) {\n  return {\n    accessToken: {\n      customClaims: {\n        'https://example.com/custom/claim': 'Custom claim value',\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function myFunc(event, api) {\n  api.accessToken.setCustomClaim('https://example.com/custom/claim', 'Custom claim value');\n}\n```\n\n**Add Custom Claims to the ID Token**\n\nPre-GA Trigger:\n\n```\nasync function myFunc(event, context) {\n  return {\n    idToken: {\n      customClaims: {\n        'https://example.com/custom/claim': 'Custom claim value',\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function myFunc(event, api) {\n  api.idToken.setCustomClaim('https://example.com/custom/claim', 'Custom claim value');\n}\n```\n\n**Dynamically enable multi-factor authentication**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    command: {\n      type: \"multifactor\",\n      provider: \"any\"\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.multifactor.enable(\"duo\");\n}\n```\n\n**Redirect the user**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    command: {\n      type: \"redirect\",\n      url: \"https://my-app.example.com\"\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.redirect.sendUserTo(\"https://my-app.example.com\");\n}\n```\n\nTo ensure parameters are being sent securely and to avoid replay attacks, passing data via redirects has changed significantly in Actions GA. For more information, see [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions).\n\n##### Manipulate scopes\n\nAlthough we experimented with providing direct manipulation of ID and Access Token scopes during the Actions Beta, we do not support this functionality in Actions GA.",
  "title": "Releases",
  "description": "Learn about released versions of Triggers in the Actions Login Flow, including breaking changes and new features.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object",
  "markdown": "# Actions Triggers: post-login - API Object\n\nThe API object for the post-login Actions trigger includes:\n\n## `api.access`\n\nModify the user's login access, such as by rejecting the login attempt.\n\n### `api.access.deny(reason)`\n\nMark the current login attempt as denied. This will prevent the end-user from completing the login flow. This will _NOT_ cancel other user-related side effects (such as metadata changes) requested by this Action. The login flow will immediately stop following the completion of this action and no further Actions will be executed.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `reason` | _String_. A human-readable explanation for rejecting the login. This is sent as `error_description` to the application that initiated the request. |\n\n## `api.accessToken`\n\nRequest changes to the access token being issued.\n\n### `api.accessToken.setCustomClaim(name, value)`\n\nSet a custom claim on the Access Token that will be issued upon completion of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. Name of the claim (note that this may need to be a fully-qualified URL). |\n| `value` | _Any value_. The value of the claim. |\n\n### `api.accessToken.addScope(scope)`\n\nAdd a scope on the Access Token that will be issued upon completion of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `scope` | _String_ The scope to be added. |\n\n### `api.accessToken.removeScope(scope)`\n\nRemove a scope on the Access Token that will be issued upon completion of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `scope` | _String_ The scope to be removed. |\n\n## `api.authentication`\n\nRequest changes to the authentication state of the current user's session.\n\n### `api.authentication.recordMethod(provider_url)`\n\nIndicate that a custom authentication method has been completed in the current session. This method will then be available in the \\`event.authentication.methods\\` array in subsequent logins.\n\n**Important**: This API is only available from within the `onContinuePostLogin` function for `PostLogin` Actions. In other words, this may be used to record the completion of a custom authentication method after redirecting the user via `api.redirect.sendUserTo()`.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `provider_url` | _String_. A url representing the identity of the custom authenticated method that was completed. |\n\n### `api.authentication.challengeWith(factor, options)`\n\nChallenge the user with one or more specified multifactor authentication factors. This method presents the default challenge first, then allows the user to select a different option if additional factors have been supplied. If the user has not enrolled in any of the factors supplied (including both the default and any additional factors), the command fails.\n\n**Note**: This method overrides existing policies and rules that enable or disable MFA in a tenant.\n\n| Parameter | Description |\n| --- | --- |\n| `factor` | _Object_. An object containing the `type` field. `type` is a string used to specify the default MFA factor or factors used to challenge the user.<br><br>Supported values include:<br><br>*   `otp`<br>*   `recovery-code`<br>*   `email`<br>*   `push-notification`<br><br>*   `otpFallback`When set to `false`, the user cannot use the OTP fallback option of the push notification factor.<br><br>*   `phone`<br><br>*   `preferredMethod: voice`<br>*   `preferredMethod: sms`<br>*   `preferredMethod: both`<br><br>*   `webauthn-platform`<br>*   `webauthn-roaming`<br><br>Example<br><br>```<br>api.authentication.challengeWith({ <br>    type: 'phone', <br>    options: { preferredMethod: 'both'} <br>  });<br>```<br><br>Was this helpful?<br><br>/ |\n| `options` | _Optional object_. An object containing the optional `additionalFactors` field.<br><br>`additionalFactors` is an array used to specify other factors a user can choose from when completing the MFA challenge. Supports the same values as the `type` field.<br><br>Example<br><br>```<br>api.authentication.challengeWith({<br>    type: 'otp'<br>  }, {<br>    additionalFactors: [{<br>      type: 'push-notification'<br>    }, {<br>      type: 'phone'<br>    }]<br>  })<br>```<br><br>Was this helpful?<br><br>/ |\n\n### `api.authentication.challengeWithAny(factors)`\n\nTrigger an MFA challenge and allow the user to select their preferred factor from the supplied list. This method presents a factor picker to the user rather than a specific challenge, in accordance with the following conditions:\n\n*   If two or more factors are specified, a factor picker displays to the user.\n*   If the user has only enrolled in one of the specified factors (or only one factor is specified), the factor picker is skipped.\n*   If the user has not enrolled in any of the specified factors, the challenge command fails.\n\n**Note**: This method overrides existing policies and rules that enable or disable MFA in a tenant.\n\n| Parameter | Description |\n| --- | --- |\n| `factors` | _Array_. An array of objects that includes the `type` field. `type` is a string used to specify an MFA factor the user can choose from when challenged.<br><br>Supported values include:<br><br>*   `otp`<br>*   `recovery-code`<br>*   `email`<br>*   `push-notification`<br><br>*   `otpFallback`When set to `true`, the user cannot use the OTP fallback option of the push notification factor.<br><br>*   `phone`<br><br>*   `preferredMethod: voice`<br>*   `preferredMethod: sms`<br>*   `preferredMethod: both`<br><br>*   `webauthn-platform`<br>*   `webauthn-roaming` |\n\n### `api.authentication.enrollWith(factor, options)`\n\nPrompt the user to enroll with a specific MFA factor. This method prompts the user to enroll with a default factor, but can optionally allow the user to select a different option if additional factors have been supplied. If the user has already enrolled in all of the supplied factors (including both the default value and any additional factors), the command fails.\n\n**Note**: This method overrides existing policies and rules that enable or disable MFA in a tenant.\n\n| Parameter | Description |\n| --- | --- |\n| `factor` | _Object_. An object containing the `type` field. `type` is a string used to specify the default MFA factor the user is prompted to enroll.<br><br>Supported values include:<br><br>*   `otp`<br>*   `recovery-code`<br>*   `push-notification`<br>*   `phone`<br><br>*   `preferredMethod: voice`<br>*   `preferredMethod: sms`<br>*   `preferredMethod: both`<br><br>*   `webauthn-platform`<br>*   `webauthn-roaming` |\n| `options` | _Optional object_. An object containing the optional `additionalFactors` field.<br><br>`additionalFactors` is an array used to specify other factors a user can choose from during enrollment. Supports the same values as the `type` field.<br><br>Example<br><br>```<br>api.authentication.enrollWith({<br>    type: 'otp'<br>  }, {<br>    additionalFactors: [{<br>      type: 'push-notification'<br>    }, {<br>      type: 'phone'<br>    }]<br>  })<br>```<br><br>Was this helpful?<br><br>/<br><br>Example<br><br>```<br>api.authentication.enrollWith({<br>    type: 'otp'<br>  }, {<br>    additionalFactors: [{<br>      type: 'push-notification'<br>    }, {<br>      type: 'phone'<br>    }]<br>  })<br>```<br><br>Was this helpful?<br><br>/ |\n\n```\n<h3><code>api.authentication.enrollWithAny(factors)</code></h3>\n<p>\n  Prompt the user to select an MFA factor to enroll in from the supplied list. This method presents a factor picker to the user rather than a default factor prompt, in accordance with the following conditions: \n</p>\n<p>\n  <ul>\n    <li>If two or more factors are specified, the factor picker displays to the user.</li>\n    <li>If the user has already enrolled in all supplied factors except one, the factor picker is skipped, and the user is prompted to enroll in the remaining factor.</li>\n    <li> If the user has already enrolled in all of the supplied factors, the command fails.</li>\n</ul>\n</p>\n<p>\n    <strong>Note</strong>: This method overrides existing policies and rules that enable or disable MFA in a tenant.\n</p>\n<table class=\"table\">\n  <thead>\n    <tr>\n      <th>Parameter</th>\n      <th>Description</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><code>factors</code></td>\n      <td>\n        <p>\n          <em>Array</em>. An array of objects that includes the <code> type</code> field. <code> type</code> is a string used to specify the default MFA factor the user is prompted to enroll. \n        </p>\n          <p>Supported values include:</p>\n        <ul>\n          <li><code>otp</code></li>\n          <li><code>recovery-code</code></li>\n          <li><code>push-notification</code></li>\n          <li><code>phone</code></li>\n               <ul>\n                  <li><code>preferredMethod: voice</code></li>\n                  <li><code>preferredMethod: sms</code></li>\n                  <li><code>preferredMethod: both</code></li>\n              </ul>\n          <li><code>webauthn-platform</code></li>\n          <li><code>webauthn-roaming</code></li>\n        </ul>\n      </td>\n  </tbody>\n</table>\n```\n\n### `api.authentication.setPrimaryUser(primary_user_id)`\n\nChange the primary user for the login transaction.\n\nIn scenarios that require linking users, the user identity used to initiate the login may no longer exist as a discrete user. That identity may now be a secondary identity of an existing user. In such situations, the `setPrimaryUser()` function can be used to indicate that the subject of the login should be changed.\n\nImportant:\n\n*   Insecurely linking accounts can allow malicious actors to access legitimate user accounts, your tenant should request authentication for both accounts before linking occurs.\n*   The identity used to authenticate the login must be among the secondary identities of the user referenced by `primary_user_id`. The login will fail and tokens will not be issued otherwise.\n\n| Parameter | Description |\n| --- | --- |\n| `primary_user_id` | _String_. The user ID of the user for whom tokens should be issued (the `sub` claim). |\n\n## `api.cache`\n\nStore and retrieve data that persists across executions.\n\n### `api.cache.delete(key)`\n\nDelete a record describing a cached value at the supplied key if it exists.\n\nReturns a `CacheWriteResult` object with `type: \"success\"` if a value was removed from the cache. A failed operation returns `type: \"error\"`. For errors, the returned object will have a `code` property that indicates the nature of the failure.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.get(key)`\n\nRetrieve a record describing a cached value at the supplied `key`, if it exists. If a record is found, the cached value can be found at the `value` property of the returned object.\n\nReturns a cache record if an item is found in the cache for the supplied `key`. Cache records are objects with a `value` property holding the cached value as well as an `expires_at` property indicating the maximum expiry of the record in milliseconds since the Unix epoch.\n\n**Important:** This cache is designed for short-lived, ephemeral data. Items may not be available in later transactions even if they are within their supplied their lifetime.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.set(key, value, [options])`\n\nStore or update a string value in the cache at the specified key.\n\nValues stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\nValues stored in this way will have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default of lifetime of 24 hours will be used. Lifetimes may not exceed the maximum duration listed at [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n| `value` | _String_. The value of the record to be stored. |\n| `options` | _Optional object_. Options for adjusting cache behavior. |\n| `options.expires_at` | _Optional number_. The absolute expiry time in milliseconds since the unix epoch. While cached records may be evicted earlier, they will never remain beyond the the supplied `expires_at`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `ttl`. If both options are supplied, the earlier expiry of the two will be used. |\n| `options.ttl` | _Optional number_. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the the supplied `ttl`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `expires_at`. If both options are supplied, the earlier expiry of the two will be used. |\n\n## `api.idToken`\n\nRequest changes to the ID token being issued.\n\n### `api.idToken.setCustomClaim(name, value)`\n\nSet a custom claim on the ID token that will be issued upon completion of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. Name of the claim (note that this may need to be a fully-qualified URL). |\n| `value` | _Any value_. The value of the claim. |\n\n## `api.multifactor`\n\nSet the requirement for multifactor authentication on the login attempt.\n\n### `api.multifactor.enable(provider, options)`\n\nEnable multifactor authentication for this login flow. When enabled, users must complete the configured multifactor challenge. The actual multifactor challenge will be deferred to the end of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `provider` | _String_. The name of the multifactor provider to use or the value `any` to use any of the configured providers.<br><br>Supported values include:<br><br>*   `any` Use any of the configured challenges.<br>*   `duo` Use the Duo multifactor provider.<br>*   `google-authenticator` Use the Google Authenticator provider.<br>*   `guardian` Use the Guardian provider.<br>*   `none` Use none of the configured challenges to prevent the MFA flow from triggering. |\n| `options` | _Optional object_. Additional options for enabling multifactor challenges. |\n| `options.allowRememberBrowser` | _Optional boolean_. When provider is set to `google-authenticator` or `duo`, the user is prompted for MFA once every 30 days. When provider is set to `guardian`, the MFA prompt displays the enrollment checkbox for users to choose whether or not to enroll. Defaults to `false`. To learn more, read [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa) |\n| `options.providerOptions` | _Optional object_. Additional options to configure the challenge, only available for the `duo` provider.<br><br>Supported options include:<br><br>*   `host` _String_. This is the API hostname value from your Duo account.<br>*   `ikey` _String_. This is the Client ID (previously Integration key) value from your Duo account.<br>*   `skey` _String_. This is the Client secret (previously Secret key) value from your Duo account.<br>*   `username` _Optional string_. Use some attribute of the profile as the username in DuoSecurity. This is also useful if you already have your users enrolled in Duo. |\n\n## `api.user`\n\nMake application-specific changes to the metadata of the user that is logging in.\n\nNOTE: **Invoking these methods does not update the metadata immediately**. You can call them several times throughout multiple Actions of the same flow, and the engine will aggregate the changes and **update the metadata at once before the flow is completed**.\n\n### `api.user.setAppMetadata(name, value)`\n\nSet application metadata for the user that is logging in. Data stored within app\\_metadata is not editable by the user.\n\nNote: This trigger makes a call to the Management API, consuming the Management API rate limit. If this request hits the rate limit and fails to retry within the timeout window, you will receive a `Deadline Exceeded` error.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. The name of metadata property. |\n| `value` | _Any value_. The value of the metadata property. This may be set to `null` to remove the metadata property. |\n\n### `api.user.setUserMetadata(name, value)`\n\nSet general metadata for the user that is logging in.\n\nNote: This trigger makes a call to the Management API, consuming the Management API rate limit. If this request hits the rate limit and fails to retry within the timeout window, you will receive a `Deadline Exceeded` error.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. The name of metadata property. |\n| `value` | _Any value_. The value of the metadata property. This may be set to `null` to remove the metadata property. |\n\n## `api.redirect`\n\n### `api.redirect.encodeToken(options)`\n\nCreate a session token suitable for using as a query string parameter redirect target (via `sendUserTo`) that contains data whose authenticity must be provable by the target endpoint. The target endpoint can verify the authenticity and integrity of the data by checking the JWT's signature using a shared secret.\n\nReturns a JWT string.\n\n| Parameter | Description |\n| --- | --- |\n| `options` | _Options_. Configure how sensitive data is encoded into the query parameters of the resulting url. |\n| `options.expiresInSeconds` | _Number_. Number of seconds before this token will expire (defaults to 900). |\n| `options.payload` | _Options_. The data intended to be passed to the target of the redirect and whose authenticity and integrity must be provable. |\n| `options.secret` | _String_. A secret that will be used to sign a JWT that is shared with the redirect target. The secret value should be stored as a secret and retrieved using `event.secrets['SECRET_NAME']`. |\n\n```\n<section>\n  <h3><code>api.redirect.sendUserTo(url, options)</code></h3>\n  <p>\n    Trigger a browser redirect to the target `url` immediately after this\n    action completes.\n  </p>\n  <p>Returns a reference to the <code>api</code> object.</p>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th>Parameter</th>\n        <th>Description</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td><code>url</code></td>\n        <td>\n          <p><em>String</em>. The url in which to redirect the user.</p>\n        </td>\n      </tr>\n      <tr>\n        <td><code>options</code></td>\n        <td>\n          <p>\n            <em>Options</em>. An object representing additional query string\n            parameters that should be appended to the redirect URL.\n          </p>\n        </td>\n      </tr>\n      <tr>\n        <td><code>options.query</code></td>\n        <td>\n          <p>\n            <em>Options</em>. Additional query string parameters that should\n            be appended to the redirect URL.\n          </p>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</section>\n\n<section>\n  <h3><code>api.redirect.validateToken(options)</code></h3>\n  <p>\n    Retrieve the data encoded in a JWT token passed to the\n    <code>/continue</code> endpoint while verifying the authenticity and\n    integrity of that data.\n  </p>\n  <p>Returns payload of the JWT token.</p>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th>Parameter</th>\n        <th>Description</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td><code>options</code></td>\n        <td>\n          <p>\n            <em>Options</em>. Options for retrieving the data encoded in a JWT\n            token passed to the <code>/continue</code> endpoint following a\n            redirect.\n          </p>\n        </td>\n      </tr>\n      <tr>\n        <td><code>options.secret</code></td>\n        <td>\n          <p><em>String</em>. Secret used to encode the token.</p>\n        </td>\n      </tr>\n      <tr>\n        <td><code>options.tokenParameterName</code></td>\n        <td>\n          <p>\n            <em>String</em>. The name of the query or body parameter that was\n            sent to the <code>/continue</code> endpoint. (defaults to\n            <code>session_token</code>\n          </p>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</section>\n<section>\n  <h3><code>api.rules</code></h3>\n  <p>\n    Get information about the Rules that have run during the current transaction.\n  </p>\n  <h3><code>api.rules.wasExecuted(ruleId)</code></h3>\n  <p>Check whether a specific Rule has been executed prior to this Action in the current transaction. This can be used to avoid running logic that has been duplicated from that Rule into this Action during migration to Actions.\n```\n\nThis method returns `true` when the Rule with the provided ID has been executed in this transaction and `false` when it has not..\n\n| Parameter | Description |\n| --- | --- |\n| `ruleId` | String. The Rule ID to check. |\n\n## `api.samlResponse`\n\nModify the SAML Response for the user that is logging in.\n\n### `api.samlResponse.setAttribute(attribute, value)`\n\nSet a custom SAML attribute.\n\nA failed operation throws an `Error`. For errors, the returned object has a message that indicates the nature of the failure.\n\nThe value must be of type `SAMLValue`, which can be `string | number | boolean | null | Array < string | number | boolean >`\n\n| Parameter | Description |\n| --- | --- |\n| `attribute` | _String_. The SAML attribute to be set. |\n| `value` | _SAMLValue_. The value of the SAML assertion. This may be set to `null` to remove the attribute property. |\n\n### `api.samlResponse.setAudience(audience)`\n\nAlter the audience of the SAML Response. Default is the issuer on SAMLRequest.\n\n| Parameter | Description |\n| --- | --- |\n| `audience` | _String_. The SAML audience to be set. |\n\n### `api.samlResponse.setEncryptionPublicKey(publicKey)`\n\nOptionally specify a public key used to encrypt the SAML assertion. The public key should be obtained from the service provider. Both the public key and certificate must be specified.\n\n| Parameter | Description |\n| --- | --- |\n| `publicKey` | _String_. The public key to be set. |\n\n### `api.samlResponse.setRecipient(recipient)`\n\nAlter the recipient of the SAML assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on `` SAMLRequest `or callback URL if no SAMLRequest was sent.` ``\n\n````````` ````````   | Parameter | Description | | --- | --- | | `recipient` | _String_. The SAML recipient to be set. |  ### `api.samlResponse.setCreateUpnClaim(createUpnClaim)`  Dictates if a UPN claim should be created. Default is `true`.  | Parameter | Description | | --- | --- | | `createUpnClaim` | _Boolean_ Toggle to create a UPN claim. |  ### `api.samlResponse.setPassthroughClaimsWithNoMapping(passthroughClaimsWithNoMapping)`  If `true` (default), for each claim that is not mapped to the common profile, Auth0 passes through those in the output assertion. If `false`, those claims won't be mapped.  | Parameter | Description | | --- | --- | | `passthroughClaimsWithNoMapping` | _Boolean_ Should claims should be mapped to the output assertion. |  ### `api.samlResponse.setMapUnknownClaimsAsIs(mapUnknownClaimsAsIs)`  If `passthroughClaimsWithNoMapping` is `true` and this is `false` (default), for each claim not mapped to the common profile Auth0 adds a prefix http://schema.auth0.com. If `` true`, it will pass through the claim as-is.` ``  ``````` ``````   | Parameter | Description | | --- | --- | | `mapUnknownClaimsAsIs` | _Boolean_ Should claims should be mapped as-is. |  ### `api.samlResponse.setMapIdentities(mapIdentities)`  If `true` (default), this adds more information in the token such as the provider (Google, ADFS, AD, etc.) and the access token, if available  | Parameter | Description | | --- | --- | | `mapIdentities` | _Boolean_ Should identities be mapped. |  ### `api.samlResponse.setDestination(destination)`  Destination of the SAML response. If not specified, it will be AssertionConsumerUrl of SAMLRequest or callback URL if there was no SAMLRequest.  | Parameter | Description | | --- | --- | | `destination` | _String_ Destination of the SAML response. |  ### `api.samlResponse.setLifetimeInSeconds(lifetimeInSeconds)`  Expiration of the token in seconds. Default is `` 3600 `seconds (1 hour).` ``  ````` ````   | Parameter | Description | | --- | --- | | `lifetimeInSeconds` | _Number_ Expiration of the token in seconds. |  ### `api.samlResponse.setSignResponse(signResponse)`  Whether or not the SAML response should be signed. By default the SAML assertion will be signed, but not the SAML response. If `true`, SAML Response will be signed instead of SAML assertion. Default to `false`.  | Parameter | Description | | --- | --- | | `signResponse` | _Boolean_ Should the SAML response be signed. |  ### `api.samlResponse.setNameIdentifierFormat(nameIdentifierFormat)`  Sets the name ID format. Default is `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.  | Parameter | Description | | --- | --- | | `nameIdentifierFormat` | _String_ The Name ID Format. |  ### `api.samlResponse.setNameIdentifierProbes(nameIdentifierProbes)`  Auth0 tries to name each of the attributes of this array in order. If one of them has a value, it will use that for the Subject/NameID. The order is:  1.  http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier (mapped from `user_id`) 2.  http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress (mapped from `email`), 3.  http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name (mapped from `name`)  | Parameter | Description | | --- | --- | | `nameIdentifierProbes` | _String array_ An array of attributes to try for the name identifier. |  ### `api.samlResponse.setAuthnContextClassRef(authnContextClassRef)`  Default is `urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified`.  | Parameter | Description | | --- | --- | | `authnContextClassRef` | _String_ The AuthnContextClassRef. |  ### `api.samlResponse.setSigningCert(signingCert)`  Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `\"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"`.  | Parameter | Description | | --- | --- | | `signingCert` | _String_ Optional public key certificate used to validate SAML requests. |  ### `api.samlResponse.setIncludeAttributeNameFormat(includeAttributeNameFormat)`  When set to `true`, we infer the NameFormat based on the attribute name. NameFormat values are ``` urn:oasis:names:tc:SAML:2.0:attrname-format:uri``, `urn:oasis:names:tc:SAML:2.0:attrname-format:basic` and `urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified`.`` ```  ``` ``   If set to `false`, the attribute NameFormat is not set in the assertion. Default is `true`.  | Parameter | Description | | --- | --- | | `includeAttributeNameFormat` | _Boolean_Should NameFormat be inferred based on the attribute name. |  ### `api.samlResponse.setTypedAttributes(typedAttributes)`  When set to `true`, we infer the `xs:type` of the element. Types are `xs:string`, `xs:boolean`, `xs:double` and `xs:anyType`. When set to `false` all `xs:type` are `xs:anyType`. Default is `true`.  | Parameter | Description | | --- | --- | | `typedAttributes` | _Boolean_Should `xs:type` be inferred. |  ### `api.samlResponse.setEncryptionCert(encryptionCert)`  Optionally specify a certificate used to encrypt the SAML assertion. The certificate should be obtained from the service provider. Both the certificate and public key must be specified. A sample value would be `\"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"`.  | Parameter | Description | | --- | --- | | `encryptionCert` | _String_Optional certificate to encrypt the SAML assertion. |  ### `api.samlResponse.setCert(cert)`  By default, Auth0 will use the private/public key pair assigned to your tenant to sign SAML responses or assertions. For very specific scenarios, you might wish to provide your own certificate and private key.  Both the certificate and private key must be specified.  A sample value would be `\"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"`.  | Parameter | Description | | --- | --- | | `cert` | _String_Optional certificate to sign the SAML responses or assertions. |  ### `api.samlResponse.setKey(key)`  By default, Auth0 will use the private/public key pair assigned to your tenant to sign SAML responses or assertions. For very specific scenarios, you might wish to provide your own certificate and private key.  Since this private key is sensitive, we recommend using the **Add Secret functionality of Actions**. See here for more details: Write Your First Action  Both the certificate and private key must be specified.  A sample value would be `\"-----BEGIN PRIVATE KEY-----\\nnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END PRIVATE KEY-----\\n\"`.  | Parameter | Description | | --- | --- | | `key` | _String_Optional private key to sign the SAML responses or assertions. |  ### `api.samlResponse.setSignatureAlgorithm(signatureAlgorithm)`  **Deprecated**: Default is `rsa-sha256`  | Parameter | Description | | --- | --- | | `signatureAlgorithm` | `rsa-sha256` \\| `rsa-sha1`. `rsa-sha1` should not be used. This is insecure. |  ### `api.samlResponse.setDigestAlgorithm(digestAlgorithm)`  **Deprecated**: Default is `sha256`  | Parameter | Description | | --- | --- | | `digestAlgorithm` | `sha256` \\| `sha1`. `rsa-sha1` should not be used. This is insecure. |   `` ``` ```` ````` `````` ``````` ```````` `````````",
  "title": "Actions Triggers: post-login - API Object",
  "description": "Learn about the post-login Action trigger's API object.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow",
  "markdown": "# Pre User Registration Flow\n\nThe Pre User Registration Flow runs before a user is added to a Database or Passwordless Connection.\n\n![Diagram showing the Actions Pre User Registration Flow.](https://images.ctfassets.net/cdy7uua7fh8z/2KtUcZhaBcT12GxjhBJZFG/9633b4454ac1c06c0deed6c97e70fe7d/pre-user-registration-flow.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### Pre User Registration\n\nThe `pre-user-registration`  triggers runs when a user attempts to register through a Database or Passwordless connection. This trigger can be used to add metadata to the user profile before it is created or to deny a registration with custom logic.\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow/event-object): Provides contextual information about the request to register a new user.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow/api-object): Provides methods for changing the behavior of the flow\n    \n\n## Common use cases\n\n### Deny registration by location\n\nA pre-user-registration Action can be used to prevent a user from signing up.\n\n```\n/**\n * @param {Event} event - Details about registration event.\n * @param {PreUserRegistrationAPI} api\n */\nexports.onExecutePreUserRegistration = async (event, api) => {\n  if (event.request.geoip.continentCode === \"NA\") {\n\n    // localize the error message \n    const LOCALIZED_MESSAGES = {\n      en: 'You are not allowed to register.',\n      es: 'No tienes permitido registrarte.'\n    };\n\n    const userMessage = LOCALIZED_MESSAGES[event.request.language] || LOCALIZED_MESSAGES['en'];\n    api.access.deny('no_signups_from_north_america', userMessage);\n  }\n};\n```\n\n### Set metadata in the user profile\n\nA pre-user-registration Action can be used to add metadata to the user profile before it is created. Currently, you cannot add metadata to Passwordless users with a pre-user-registration Action.\n\n```\n/**\n * @param {Event} event - Details about registration event.\n * @param {PreUserRegistrationAPI} api\n */\nexports.onExecutePreUserRegistration = async (event, api) => {\n  api.user.setUserMetadata(\"screen_name\", \"username\");  \n};\n```\n\n### Store a user ID from another system in the user profile\n\nA pre-user-registration Action can be used to store a user ID from another system in the user profile.\n\n```\nconst axios = require(\"axios\");\n\n/**\n * @param {Event} event - Details about registration event.\n * @param {PreUserRegistrationAPI} api\n */\nexports.onExecutePreUserRegistration = async (event, api) => {\n  const remoteUser = await axios.get(\"https://my-api.exampleco.com/users\", { params: { email: event.user.email }});\n\n  if (remoteUser) {\n    api.user.setAppMetadata(\"my-api-user-id\", remoteUser.id); \n  }\n};\n```",
  "title": "Pre User Registration Flow",
  "description": "Learn about the Pre User Registration Flow, which runs when a user attempts to register through a Database or Passwordless connection. It can be used to add metadata to the user profile before it is created or to deny a registration.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow",
  "markdown": "# Post User Registration Flow\n\nThe Post User Registration Flow runs after a user is added to a Database or Passwordless Connection.\n\n![Diagram of the Actions Post User Registration Flow.](https://images.ctfassets.net/cdy7uua7fh8z/4bqF9YEPYQshnJGCx39pws/079798c354f4a83355a756a6a02650d5/post-user-registration-flow.png)\n\nActions in this flow are non-blocking (asynchronous), which means the Auth0 pipeline will continue to run without waiting for the Action to finish its execution. Thus, the Action's outcome does not affect the Auth0 transaction.\n\n## Triggers\n\n### Post User Registration\n\nThe `post-user-registration` triggers runs after a user has been created for a Database or Passwordless connection. This trigger can be used to notify another system that a user has registered for your application. Multiple actions can be bound to this trigger, and the actions will run in order. However, these actions will be run asynchronously and will not block the user registration process.\n\n### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow/event-object): Provides contextual information about the newly-created user.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Common use cases\n\n### Notify Slack when a new user registers\n\n```\n/**\n* Handler that will be called during the execution of a PostUserRegistration flow.\n* \n * @param {Event} event - Details about the context and user that has registered.\n * @param {PostUserRegistrationAPI} api - Interface whose methods can be used to change the behavior of post user registration.\n */\n\nexports.onExecutePostUserRegistration = async (event, api) => {\n  const { IncomingWebhook } = require(\"@slack/webhook\");\n  const webhook = new IncomingWebhook(event.secrets.SLACK_WEBHOOK_URL);\n\n  const text = `New User: ${event.user.email}`;\n  const channel = '#some_channel';\n\n  webhook.send({ text, channel });\n};\n```\n\n### Store the Auth0 user id in a remote system\n\nA post-user-registration Action can be used to store the Auth0 user ID in a remote system.\n\n```\n/**\n* Handler that will be called during the execution of a PostUserRegistration flow.\n* \n* @param {Event} event - Details about the context and user that has registered.\n* @param {PostUserRegistrationAPI} api - Interface whose methods can be used to change the behavior of post user registration.\n*/\n\nconst axios = require(\"axios\");\n\nexports.onExecutePostUserRegistration = async (event, api) => {\n  await axios.post(\"https://my-api.exampleco.com/users\", { params: { email: event.user.email }});\n};\n```",
  "title": "Post User Registration Flow",
  "description": "Learn about the Post User Registration Flow and post-user-registration Action trigger, which runs after a user has been created for a Database or Passwordless connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow",
  "markdown": "# Send Phone Message Flow\n\nThe Send Phone Message Flow allows you to execute code when using SMS/Voice as a factor for [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication). When using a [custom provider](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa#custom-phone-messaging-providers) to send the messages, this flow's `send-phone-message` trigger is required to configure your custom provider.\n\n![Diagram of the Actions Send Phone Message Flow.](https://images.ctfassets.net/cdy7uua7fh8z/FSkVXDdknDJq1hsK08EYu/e031ec0067a5460afae8d9ed5d462288/send-phone-message-flow.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### Send Phone Message\n\nThe `send-phone-message` trigger will run for the enrollment process and the challenge process (`event.message_options.action`). It will also run for the `voice` message type when using the New experience for Universal Login (`event.message_options.message_type === 'voice'`).\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow/event-object): Provides contextual information about the message to be sent and the user to be challenged or enrolled.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Common use cases\n\n### Use a custom SMS provider\n\n```\nconst AWS = require(\"aws-sdk\");\n\n/**\n * Handler that will be called during the execution of a SendPhoneMessage flow.\n *\n * @param {Event} event - Details about the user and the context in which they are logging in.\n */\nexports.onExecuteSendPhoneMessage = async (event) => {\n  const text = event.message_options.text;\n  const recipient = event.message_options.recipient;\n\n  const awsSNS = new AWS.SNS({\n    apiVersion: \"2010-03-31\",\n    region: event.secrets.AWS_REGION,\n    credentials: new AWS.Credentials(event.secrets.AWS_ACCESS_KEY_ID, event.secrets.AWS_SECRET_ACCESS_KEY)\n  });\n\n  const params = { Message: text, PhoneNumber: recipient };\n\n  return awsSNS\n    .publish(params)\n    .promise();\n};\n```",
  "title": "Send Phone Message Flow",
  "description": "Learn about Action's Send Phone Message flow and the send-phone-message Action trigger, which runs for the enrollment and challenge process if you have used SMS as a factor for Multi-factor Authentication (MFA).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa",
  "markdown": "# Configure WebAuthn with Security Keys for MFA\n\nFor an introduction to WebAuthn and how Auth0 implements it for both [](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)Security Keys and [Device Biometrics](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa), check out [FIDO Authentication with WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn).\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Use the Dashboard\n\n1.  Enable **WebAuthn with Security Keys** by going to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa).\n    \n2.  Configure how you want to handle User Verification. For security keys, the typical user verification prompts users to enter a PIN to complete the WebAuthn challenge.\n    \n    1.  Never: Users will never be prompted to enter a PIN. This is the default value, and it's usually good enough when using security keys for MFA. Users already entered their password, so already provided some verification.\n        \n    2.  If supported: Users will be prompted to enter a PIN if they already configured one in the key.\n        \n    3.  Required: Users will be asked to set a PIN if it's not already set, and they'll be asked to enter it each time. This is the option that offers the highest security. Some browsers don't implement this properly (for example, [Brave](https://brave.com/) on iOS) so the authentication will fail and Auth0 will ask users to use another browser.\n        \n\nNote that only FIDO-2 compliant security keys support user verification. FIDO-1 keys can be used for WebAuthn, but are not usable if you set User Verification to Required.\n\n## Configure Relying Party\n\nWebAuthn makes phishing impossible by binding the credentials with the browser's origin. Users can't use WebAuthn for a site they did not register too.\n\nBinding credentials to the origin means if you configure a custom domain or change it, users enrolled before the change will not be able to authenticate.\n\nWebAuthn defines a [Relying Party ID attribute](https://www.w3.org/TR/webauthn-2/#relying-party-identifier), which lets you specify the domain used to authenticate users. You can set it to any registrable domain suffix of the browser origin. For example, if the custom domain is accounts.acme.com, you can configure the Relying Party ID to acme.com. This lets users authenticate to any acme.com domain with their WebAuthn credentials.\n\nAuth0 lets you specify the Relying Party ID only if you have a custom domain configured. If the custom domain changes, you must update the Relying Party ID.\n\n## Device support\n\nTo use security keys, a browser needs to have JavaScript enabled and support WebAuthn. If those conditions are not met, Auth0 will not offer the option of enrolling or authenticating with security keys. Auth0 will challenge with another factor or with a recovery code (if they don't have another factor enrolled).\n\nThe latest versions of popular browsers and operating systems provide support for WebAuthn with Security Keys. For more details, read the the [browser support section in webauthn.me](https://webauthn.me/browser-support).\n\n## Limitations\n\n*   When using the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) you can list and remove WebAuthn enrollments, but you cannot enroll them.\n    \n\n## Learn more\n\n*   [Configure WebAuthn with Device Biometrics for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)",
  "title": "Configure WebAuthn with Security Keys for MFA",
  "description": "Describes how to configure WebAuthn with Security Keys for MFA.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa",
  "markdown": "# Configure Push Notifications for MFA\n\nThe [Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian) SDKs for [iOS](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk) and [Android](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk) allow you to use a custom-built app for vendor-specific push notification services. You can configure push notifications for the AWS Simple Notification Service (SNS) platform or use Direct to Vendor services to add Firebase Cloud Messaging (FCM) and Apple Push Notification (APN) credentials directly in Auth0.\n\n## AWS SNS Configuration\n\nBefore you configure push notifications, follow the prerequisites below:\n\n1.  [Create an SNS Platform Application](https://console.aws.amazon.com/sns/v3/home?region=us-east-1#/mobile/push-notifications/platform-applications) using AWS Management console and note it’s ARN.\n    \n2.  Create an AWS Access Key ID authorized to create Platform Application endpoints. Guardian automatically creates a Platform Application endpoint with an appropriate device token as part of a successful enrollment.\n    \n\n### Configure push notifications with AWS SNS\n\nTo receive push notifications from Guardian, you first need to override Guardian's default SNS settings. Then, you can configure push notifications for Android and iOS.\n\n1.  On the Auth0 Dashboard, navigate to [Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and select **Push via Auth0 Guardian**. If the method is inactive, select the toggle at the top right to enable it.\n    \n    ![Auth0 Dashboard > Security > Multi-factor Auth > Guardian](https://images.ctfassets.net/cdy7uua7fh8z/6IH2tJOYtzYLhu7txyOAYv/ab682c51e57f0ef3621884c594616d18/Push_Notifications_with_Guardian.png)\n2.  Select **Custom** to reveal additional settings.\n    \n3.  In the Push Notification Service section, choose **Amazon SNS.**\n    \n\n![Auth0 Dashboard > Security > Multi-factor Auth > Guardian > Custom > Amazon SNS](https://images.ctfassets.net/cdy7uua7fh8z/6PKSyH99GJ2CalJoG38sfZ/fbe7229dcc6f7d303a582520001b3dc1/Amazon_SNS.png)\n\n1.  In the Amazon SNS Configuration section, complete the following fields:\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | AWS Access Key ID | Your AWS Access Key ID. |\n    | AWS Secret Access Key | Your AWS Secret Access Key. |\n    | AWS Region | Your AWS application's region. |\n    \n2.  Select **Save** to complete your changes.\n    \n\n## Configure push notifications for Android using FCM\n\nTo configure Android push notifications on your Auth0 Dashboard, first retrieve your FCM server credentials. For full details, review Google's [Firebase documentation](https://firebase.google.com/docs/admin/setup#initialize-sdk).\n\n1.  Navigate to the Firebase Console and select your applicable project.\n    \n2.  Open the **Settings** menu and choose **Service Accounts**.\n    \n3.  Select **Generate New Private Key** to download your credential file.\n    \n\nAfter you retrieve your credentials, you can configure push notifications on your Auth0 Dashboard.\n\n## Configure push notifications for iOS using APNs\n\nTo configure iOS push notifications on your Auth0 Dashboard, first retrieve your APN certificate.\n\n1.  Generate a [new APN certificate](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/establishing_a_certificate-based_connection_to_apns#2947597) from your Apple developer account.\n    \n2.  Install the certificate locally.\n    \n3.  Find the **Apple Sandbox Push Services: {AppId}** certificate in your Keychain Access.\n    \n4.  Export the certificate and the associated private key to a P12 file without a password (default name: `Certificates.p12`).\n    \n5.  To generate a P12 file using Triple DES instead of RC2, run\n    \n    ```\n    openssl pkcs12 -in Certificates.p12 -legacy -nocerts -nodes -out pk.pem -passin pass:\"\" &&\n    openssl pkcs12 -in Certificates.p12 -legacy -nokeys -out cert.crt -passin pass:\"\" &&\n    openssl pkcs12 -export -inkey pk.pem -in cert.crt -descert -out Certificate_3des.p12 -passout pass:\"\" &&\n    rm pk.pem cert.crt\n    ```\n    \n6.  Delete `Certificates.p12` and use `Certificate_3des.p12` as the APN certificate in the Auth0 Dashboard.\n    \n\nAfter you retrieve your credentials, you can configure push notifications on your Auth0 Dashboard.\n\n## Learn more\n\n*   [Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian)\n*   [Guardian for Android SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)\n*   [Guardian.swift iOS SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk)\n*   [Create Custom Enrollment Tickets](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)",
  "title": "Configure Push Notifications for MFA",
  "description": "Describes how to configure push notifications for MFA.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa",
  "markdown": "# Configure WebAuthn with Device Biometrics for MFA\n\nFor an introduction to WebAuthn and how Auth0 implements it for both [Security Keys](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa) and Device Biometrics, check out [FIDO Authentication with WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn).\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Use the Dashboard\n\nEnable **WebAuthn with Device Biometrics** by going to [Dashboard > Security > Multifactor Auth](https://manage.auth0.com/#/security/mfa). You'll need to enable an additional factor, as it cannot be the only factor enabled.\n\n## Configure Relying Party\n\nWebAuthn makes phishing impossible by binding the credentials with the browser's origin. Users can't use WebAuthn for a site they did not register too.\n\nBinding credentials to the origin means if you configure a custom domain or change it, users enrolled before the change will not be able to authenticate.\n\nWebAuthn defines a [Relying Party ID attribute](https://www.w3.org/TR/webauthn-2/#relying-party-identifier), which lets you specify the domain used to authenticate users. You can set it to any registrable domain suffix of the browser origin. For example, if the custom domain is accounts.acme.com, you can configure the Relying Party ID to acme.com. This lets users authenticate to any acme.com domain with their WebAuthn credentials.\n\nAuth0 lets you specify the Relying Party ID only if you have a custom domain configured. If the custom domain changes, you must update the Relying Party ID.\n\n## Device recognition\n\nWhen you enable WebAuthn with Device Biometrics, Auth0 will try to progressively enroll all of an end-user's WebAuthn-capable devices. Browsers with Javascript disabled or without WebAuthn platform authenticator support, won’t get the option to enroll or authenticate with Device Biometrics.\n\nSince there's no deterministic way to know if a specific device was enrolled or not without challenging the user for WebAuthn, Auth0 relies on the user agent to decide what to do. The behavior depends on the operating system.\n\n### Windows and iOS 14.5+\n\nOn Windows and iOS 14.5+, the WebAuthn platform authenticator is registered at the **operating system level.** Users can enroll with one browser and login with any browser. If Auth0 detects that users have a device enrolled, they will get the option to authenticate with Face ID / Touch ID / Windows Hello. If they enrolled with that same device they'll be able to authenticate. If not, it will fail, and they'll need to use another authentication method.\n\n### macOS \n\nOn Mac, the WebAuthn platform authenticator is registered at the **browser** system level. Users will be asked to enroll with WebAuthn in each browser they use. If Auth0 detects that the user has enrolled from Chrome on a Mac, they will get the option to authenticate with Touch ID when they login from Chrome on a Mac. If they enrolled from the same Mac, they’ll be able to authenticate.  If no, it will fail, and they'll need to use another authentication method. If they try to enroll from Safari in the same Mac, they will be asked to complete MFA with the other authentication method, and then **prompted to enroll** with Touch ID.\n\n### Android\n\nOn Android, **only Chrome** supports WebAuthn platform authenticators. If Auth0 detects that users have an Android device enrolled, they will get the option to authenticate with Android’s Fingerprint/Face Recognition. If they enrolled with that same Android device they'll be able to authenticate. If not, it will fail, and they'll need to use another authentication method.\n\n## Device support\n\nThe user must have another MFA enrollment activated before using device biometrics.\n\nTo use device biometrics keys, a browser needs to have JavaScript enabled and support WebAuthn Platform Authenticators. If those conditions are not met, Auth0 will not offer the option of enrolling or authenticating with the device. Auth0 will challenge the user with another factor.\n\nThe latest versions of popular browsers and operating systems provide support for WebAuthn with Security Keys. For more details, check out the [browser support section in webauthn.me](https://webauthn.me/browser-support).\n\n## Limitations\n\n*   There isn't a a way to enroll with WebAuthn device biometrics beyond the Progressive Enrollment prompt.\n    \n*   When using the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) you can list and remove WebAuthn enrollments, but you cannot enroll them.\n    \n*   Users can only enroll one device per type using WebAuthn with Device Biometrics (one phone, one tablet, one laptop/desktop). If a user wants to enroll another device of the same type, the first device must be unenrolled.\n    \n\n## Webauthn.me\n\nAuth0 maintains [webauthn.me](https://a0.to/webauthme-auth0-docs), which has [detailed information](https://webauthn.me/introduction) about WebAuthn and an up-to-date list of browsers supporting WebAuthn.\n\n## Learn more\n\n*   [Configure WebAuthn with Security Keys for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)",
  "title": "Configure WebAuthn with Device Biometrics for MFA",
  "description": "Describes how to configure WebAuthn with Device Biometrics",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/enable-adaptive-mfa",
  "markdown": "# Enable Adaptive MFA\n\n#### Before you start\n\n*   Subscribe to an Enterprise Plan with the Adaptive MFA addon. Refer to [Auth0 Pricing](https://auth0.com/pricing/) for details.\n    \n*   Configure and enable a Database or Active Directory connection.\n    \n*   Configure and enable at least one MFA factor.\n    \n\nUse Adaptive MFA to trigger MFA when Auth0 determines that an attempted login is risky and to record risk assessments for all login transactions in your tenant logs.\n\n## Enable Adaptive MFA\n\nYou can enable Adaptive MFA in the Auth0 Dashboard or with the Auth0 Management API.\n\n1\\. Go to [**Dashboard > Security > Multi-factor Auth**](https://manage.auth0.com/#/security/mfa).\n\n![Auth0 Dashboard Security Multi-factor Auth Adaptive MFA Policy](https://images.ctfassets.net/cdy7uua7fh8z/4IlQi0LXOPJdYjOuo09xtE/3fb8f8eeb850dde8c9c875074ea2ebfb/Screen_Shot_2021-07-06_at_12.57.04_PM.png)\n\n2\\. In the **Factors** section, enable and configure at least one MFA Factor. To learn more, read [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n\n3\\. In the **Define policies** section, locate **Require Multi-factor Auth**, and then select **Use Adaptive MFA**. Risk assessment will automatically be enabled and recorded in your tenant logs.\n\n4\\. Click **Save**.\n\n## Enable Adaptive MFA Risk Assessment\n\nIf you aren't ready to enable Adaptive MFA, but want to start training it to analyze login behavior, you can enable Adaptive MFA Risk Assessment independently.\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa).\n    \n2.  Locate the **Define policies** section.\n    \n3.  In **MFA Risk Assessors**, select **Enable Adaptive MFA Risk Assessment**.\n    \n4.  Select **Save**.\n    \n\n## Customize Adaptive MFA\n\nYou can customize the behavior of Adaptive MFA to provide the best experience for your users while ensuring security. To learn more, read [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa).\n\n## Limitations\n\nAssessment information in tenant logs is only available for interactive flows. Auth0 does not support recording assessment information for Resource Owner Password Grant (ROPG) flows without adaptive MFA enabled. For more information about authentication flow limitations, read [Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n\n## Learn more\n\n*   [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa)\n*   [Adaptive MFA Log Events](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events)\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)",
  "title": "Enable Adaptive MFA",
  "description": "Learn how to enable Adaptive MFA for low confidence logins based on Auth0's risk assessment and overall confidence scores. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa",
  "markdown": "# Customize Adaptive MFA\n\nYou can customize Adaptive MFA for a variety of scenarios with [Auth0 Actions](https://auth0.com/docs/customize/actions).\n\n## When to customize Adaptive MFA\n\nIf your users are not enrolled in MFA, you should use the default policy for Adaptive MFA. If a user is not enrolled in MFA and your Action assesses a high risk, you have limited options to stop a bad actor.\n\nBefore you begin to customize Adaptive MFA, ask yourself a few questions:\n\n*   At what confidence level do you want to trigger MFA?\n    \n*   How do you want to measure risk?\n    \n*   Do you want Auth0 to measure confidence or do you want a custom measurement?\n    \n*   How will you handle users who are not enrolled in MFA?\n    \n\n## Evaluate confidence\n\nAdaptive MFA calculates an overall confidence score based on the analysis of three assessments. Each assessment has its own confidence score. To learn more, read [Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n\n### Confidence scores\n\nConfidence scores and their associated actions are described below:\n\n| **Confidence score** | **Description** | **Action** |\n| --- | --- | --- |\n| `low` | Login transaction does not match patterns previously displayed by user. | Require MFA. |\n| `medium` | Login transaction somewhat matches patterns previously displayed by user. | Do not require MFA. |\n| `high` | Login transaction closely matches patterns previously displayed by user. | Do not require MFA. |\n| `neutral` | N/A. Reserved for future use. | N/A. Reserved for future use. |\n\n### Custom confidence scoring\n\nIf you want to implement your own method for evaluating the overall confidence score of different scenarios, you can use the data available in the [riskAssessment](#riskassessment-context-object) object.\n\nRead the examples below to learn how Adaptive MFA would score the confidence of different use cases.\n\n#### Examples of high-risk, low-confidence scenarios\n\nThe following table describes high-risk scenarios that result in a `low` confidence score:\n\n| **User State** | **Desired Login Friction** | **Desired Enrollment Policy** | **Implementation** |\n| --- | --- | --- | --- |\n| Enrolled in MFA | Do not require MFA | N/A (user already enrolled) | Use an Action to bypass MFA |\n| Not enrolled in MFA | Require email verification | Skip enrollment (do not collect additional authenticators) | Default behavior (no MFA-related Action) |\n| Not enrolled in MFA | Require email verification | Require MFA enrollment (collect additional authenticator) | Use an Action to force MFA enrollment (template available) |\n\n#### Examples of low-risk, high-confidence scenarios\n\nThe following table describes low-risk scenarios that result in a `high` confidence score:\n\n| **User State** | **Desired Login Friction** | **Desired Enrollment Policy** | **Implementation** |\n| --- | --- | --- | --- |\n| Enrolled in MFA | No friction | N/A (user already enrolled) | Default behavior (no MFA-related Action) |\n| Not enrolled in MFA | No friction | Skip enrollment (do not collect additional authenticators) | Default behavior (no MFA-related Action) |\n| Not enrolled in MFA | No friction | Require MFA enrollment (collect additional authenticator) | Use an Action to force MFA enrollment (template available) |\n\n### riskAssessment object\n\nThe `riskAssessment` object contains the overall confidence score, versioning information, and details of the individual assessments.\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Overall confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `version` | Version identifier of risk assessment API. | string | `1` |\n| `assessments` | Object containing individual assessment details. | object | Read [assessments object](#assessments-object) |\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.authentication && event.authentication.riskAssessment) {\n    event.authentication.riskAssessment = {\n      confidence: 'low' | 'medium' | 'high' | 'neutral',\n      version: '1',\n      assessments: {\n        UntrustedIP: {\n          confidence: 'low' | 'medium' | 'high' | 'neutral',\n          code: 'not_found_on_deny_list' | 'found_on_deny_list',\n          details: { // only if 'found_on_deny_list'\n            ip: '192.168.1.1',\n            matches: '192.168.0/64',\n            source: 'firehol',\n            category: 'abuse'\n          }\n        },\n        NewDevice: {\n          confidence: 'low' | 'medium' | 'high' | 'neutral',\n          code: 'match' | 'partial_match' | 'no_match',\n          details: {\n            device: 'known' | 'unknown',\n            useragent: 'known' | 'unknown',\n          }\n        },\n        ImpossibleTravel: {\n          confidence: 'low' | 'medium' | 'high' | 'neutral',\n          code: 'missing_geoip', | 'anonymous_proxy' | 'unknown_location' | 'initial_login' | 'location_history_not_found' | 'invalid_travel' | 'minimal_travel_from_last_login' | 'impossible_travel_from_last_login' | 'substantial_travel_from_last_login' | 'travel_from_last_login'\n        } \n      },\n       PhoneNumber: {\n          code: \"requires_verification | ok\",\n          confidence: \"low | medium | high | neutral\",\n          details: {\n\t        \tlineType: \"FIXED_LINE | MOBILE | FIXED_LINE_OR_MOBILE | TOLL_FREE | PREMIUM_RATE | SHARED_COST | VOIP | PERSONAL_NUMBER | PAGER | UAN | UNKNOWN\"\n\t            isValid: true | false,\n\t\t        countryCode: 1,\n\t\t        number: \"+12223334444\"\n        }\n      }\n    };\n  }\n}\n```\n\n### assessments object\n\nThe `assessments` object contains details of the three individual risk assessments:\n\n1.  [NewDevice assessment](#newdevice-assessment)\n    \n2.  [ImpossibleTravel assessment](#impossibletravel-assessment)\n    \n3.  [UntrustedIP assessment](#untrustedip-assessment)  \n    \n4.  [PhoneNumber assessment](#phonenumber-assessment)\n    \n\nEach assessment includes a [confidence score](#confidence-scores), a code that describes the evaluation result, and additional contextual information.\n\n#### NewDevice assessment\n\nThe `NewDevice` assessment determines if the user is logging in from a known device and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `code` | Evaluation result of the assessment. | string | `match`, `partial_match`, `no_match`, `initial_login`, `unknown_device`, `no_device_history`, `assessment_not_available` |\n| `details` | Additional contextual information. | object | Refer to table below. |\n\n##### NewDevice assessment code property\n\nThe `NewDevice` assessment `code` property equals one of the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `match` | The property values of the `details` object are equivalent. |\n| `partial_match` | The property values of the `details` object are similar. |\n| `no_match` | The property values of the `details` object are different. |\n| `initial_login` | The user logged in for the first time on the device. |\n| `unknown_device` | Auth0 was unable to attain metadata for the device. |\n| `no_device_history` | There is no login history associated with the device. |\n| `assessment_not_available` | Auth0 could not perform an assessment of the device. |\n\n##### NewDevice assessment details object\n\nIf the `code` property value equals `match`, `partial_match`, or `no_match`, the `NewDevice` assessment contains the `details` object with the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `device` | Device of the user. | string | `known`, `unknown` |\n| `useragent` | User agent of the user. | string | `known`, `unknown` |\n\n#### ImpossibleTravel assessment\n\nThe `ImpossibleTravel` assessment determines if the user is logging in from a location that would indicate impossible travel and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `code` | Evaluation result of the assessment. | string | `minimal_travel_from_last_login`, `travel_from_last_login`, `substantial_travel_from_last_login`, `impossible_travel_from_last_login`, `invalid_travel`, `mission_geoip`, `anonymous_proxy`, `unknown_location`, `initial_login`, `location_history_not_found`, `assessment_not_available` |\n\n#### UntrustedIP assessment\n\nThe `UntrustedIP` assessment determines if the user’s IP address is present in Auth0’s repository of low-reputation IP addresses (“deny list”) and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `code` | Evaluation result of the assessment. | string | `not_found_on_deny_list`, `found_on_deny_list`, `invalid_ip_address`, `assessment_not_available` |\n| `details` | Additional contextual information. | object | Refer to table below. |\n\n##### UntrustedIP assessment details object\n\nIf the `UntrustedIP` assessment `code` property value equals `found_on_deny_list`, the `details` object is present and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `ip` | IP address of the device. | string | Any valid IPv4 or IPv6 address. |\n| `matches` | Subnet mask that IP address belongs to. | string | Any valid IPv4 or IPv6 subnet mask. |\n| `source` | Name of threat intelligence source for the deny list. | string | Any valid text. |\n| `category` | Category indicating why IP address is untrusted. | string | `abuse`, `anonymizer`, `datacenter`, `reputation`, `unroutable` |\n\n##### UntrustedIP assessment details object category property\n\nThe `UntrustedIP` assessment `details` object `category` property describes the general reason why Adaptive MFA considers a given IP address untrusted and equals one of the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `abuse` | IP address exhibited abusive behaviors or was found to be member of bot nets. |\n| `anonymizer` | IP address belongs to anonymizing services such as VPN providers, open proxies, and TOR exit nodes. |\n| `datacenter` | IP address belongs to cloud hosting providers and colocation datacenters. |\n| `reputation` | IP address has a poor reputation score based on activity. |\n| `unroutable` | IP address is not in any range allocated or delegated by any authorized Internet registry or allowed for public use. |\n\n#### PhoneNumber assessment\n\nThe `PhoneNumber` assessment assesses the risk of a phone number for an incoming transaction and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `code` | Describes the evaluation result. | string | `ok`, `requires_verification`, `phone_number_not_provided`, `assessment_not_available` |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `details` | Additional contextual information. | object | Refer to table below. |\n\n##### PhoneNumber assessment details object\n\nThe `PhoneNumber` assessment `details` object contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `lineType` | Type of phone line | string | `FIXED_LINE`, `MOBILE`, `FIXED_LINE_OR_MOBILE`, `TOLL_FREE`, `PREMIUM_RATE`, `SHARED_COST`, `VOIP`, `PERSONAL_NUMBER`, `PAGER`, `UAN`, `UNKNOWN` |\n| `isValid` | Returns the validity of the number | boolean | `true`, `false` |\n| `countryCode` | Country code of the phone origin | integer | `0-999` |\n| `number` | Phone number | string | Valid number including `countryCode` |\n\n## Action result outcomes\n\nIf any of your Actions trigger MFA based on confidence score, the default Adaptive MFA policy triggers MFA when the confidence score is `low`.\n\nThe following table shows the possible outcomes based on the combination of Actions and default Adaptive MFA policy actions.\n\n| **Action result** | **Adaptive MFA action** | **Outcome** |\n| --- | --- | --- |\n| Unauthorized | Trigger MFA | Unauthorized |\n| Unauthorized | No MFA Required | Unauthorized |\n| Trigger MFA | Trigger MFA | Trigger MFA |\n| Trigger MFA | No MFA Required | Trigger MFA |\n| No MFA Required | Trigger MFA | Trigger MFA |\n| No MFA Required | No MFA Required | No MFA Required |\n\n## Action templates\n\nAuth0 provides two Action templates based on Adaptive MFA for you to customize: [Adaptive MFA](#adaptive-mfa) and [Require MFA Enrollment](#require-mfa-enrollment).\n\n### Adaptive MFA template\n\nThis template provides an example and starting point for how to build a custom business flow using individual risk assessments.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.authentication && \n      event.authentication.riskAssessment && \n      event.authentication.riskAssessment.assessments.NewDevice) {\n\n  // Example condition: prompt MFA only based on the NewDevice \n    // confidence level, this will prompt for MFA when a user is logging in \n    // from an unknown device.\n    let shouldPromptMfa;\n\n    switch (event.authentication.riskAssessment.assessments.NewDevice.confidence) {\n      case 'low':\n      case 'medium':\n        shouldPromptMfa = true;\n        break;\n      case 'high':\n        shouldPromptMfa = false;\n        break;\n      case 'neutral':\n        // When this assessor has no useful information about the confidence, \n        // do not prompt MFA.\n        shouldPromptMfa = false;\n        break;\n    }\n\n      // It only makes sense to prompt for MFA when the user has at least one \n      // enrolled MFA factor.\n    const canPromptMfa = event.user.multifactor && event.user.multifactor.length > 0;\n\n    if (shouldPromptMfa && canPromptMfa) {\n      api.multifactor.enable('any', { allowRememberBrowser: true });\n    }\n  }\n};\n```\n\n### Require MFA Enrollment template\n\nThis template demonstrates how you could enforce MFA enrollment when using a standard or Adaptive MFA policy. It uses `event.user.multifactor` to check if the user is enrolled in MFA, and if they’re not, prompts for enrollment.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  if (!event.user.multifactor || event.user.multifactor.length == 0) {\n    api.multifactor.enable('any', { allowRememberBrowser: true });\n  }\n};\n```\n\n## Action use cases\n\nHere are some suggestions for how to build custom Actions based on your use case.\n\n### Perform an action if overall confidence score is X\n\nAssess the `riskAssessment.confidence` property, and then compare it with the constants `high`, `medium`, or `low`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const riskIsMedium = riskAssessment && riskAssessment.confidence === 'medium';\n\n  if (riskIsMedium) {\n    // ....\n  }\n}\n```\n\n### Perform an action if confidence score is above or below X\n\nConfidence scores are discrete values—not in a range—so you cannot use comparison operators (such as `<` or `>`) to evaluate multiple values in a single condition.\n\nUse multiple conditions to logically combine all the confidence scores you want to handle. For example, if you want to know when the confidence score is greater than `low`, check if it’s equal to `medium` or `high`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const riskIsMediumOrHigh = riskAssessment && \n                                  (riskAssessment.confidence === 'high' || \n                                   riskAssessment.confidence === 'medium');\n\n  if (riskIsMediumOrHigh) {\n    // ...\n  }\n}\n```\n\n### Get additional details if overall confidence score is X\n\nThe `riskAssessment` object is saved in your tenant logs. You can view log entries to see the risk assessment score and the determining factors (reasons).\n\nYou can view the `riskAssessment` object and report the results elsewhere. For example, you can send an email or save a record in an external database.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const riskIsLow = riskAssessment && riskAssessment.confidence === 'low';\n\n  if (riskIsLow) {\n    // log(externalDatabase, riskAssessment);\n  }\n}\n```\n\n### Perform an action if a specific assessment has a specific result\n\nUse the [assessments](#assessments-object) object to access the details for individual assessments, including the `code` property:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const { ImpossibleTravel } = riskAssessment && riskAssessment.assessments;\n\n  if (ImpossibleTravel.code === 'impossible_travel_from_last_login') {\n    // ...\n  }\n}\n```\n\n### Aggregate assessments for a custom overall confidence score.\n\nUse the [assessments](#assessments-object) object to access the details for individual assessments, and then use the `confidence` property, the `code` property, or both.\n\nTo learn more about custom confidence scoring, read [Custom confidence scoring](#custom-confidence-scoring).\n\n### Block current transaction and return error and message if a specific assessment has a specific result\n\nUse the [assessments](#assessments-object) object to access the details for individual assessments, including the `code` property.\n\nBlock the login transaction from completing by returning the callback function with an `UnauthorizedError` object as the [error parameter](https://auth0.com/docs/troubleshoot/error-handling-best-practices). The `UnauthorizedError` object always sets `error` to `unauthorized`, but you can customize the `error_message`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const { ImpossibleTravel } = riskAssessment && riskAssessment.assessments;\n\n  if (ImpossibleTravel.code === 'impossible_travel_from_last_login') {\n    return api.access.deny('Login blocked due to impossible travel detected.')\n  }\n}\n```\n\nThis redirects the user back to the application's callback URL with the `error` and `error_message` parameters included.\n\n### Safely handle when Auth0 fails to execute assessments\n\nAuth0 automatically assigns a `low` confidence score if there is any sort of failure performing the risk assessment.\n\nTo mitigate this scenario, use the [assessments](#assessments-object) object to inspect the `code` property for each individual assessment and check if the value is set to `assessment_not_available`.\n\n## Learn more\n\n*   [Enable Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/enable-adaptive-mfa)\n*   [Adaptive MFA Log Events](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events)\n*   [Actions Triggers: post-login - API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object)\n*   [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object)",
  "title": "Customize Adaptive MFA",
  "description": "Learn how to customize Adaptive Multi-Factor Authentication (MFA).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-apis",
  "markdown": "# Configure Step-up Authentication for APIs\n\nWith step-up authentication, applications that allow access to different types of resources can require users to authenticate with a stronger mechanism to access sensitive information or perform certain transactions.\n\nFor example, a user of a banking app may be allowed to transfer money between accounts only after they have confirmed their identity using multi-factor authentication (MFA).\n\nWhen your audience is an API, you can implement step-up authentication with Auth0 using scopes, access tokens, and [Actions](https://auth0.com/docs/customize/actions). When an application wants to access an API's protected resources, it must provide an access token. The resources that it will have access to depend on the permissions that are included in the access token. These permissions are defined as [scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes).\n\n## Validate access tokens for MFA\n\nIn addition to checking the scope, the API must [validate the access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens) to:\n\n*   Verify the token's signature, used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way.\n    \n*   Validate the standard claims:\n    \n    | Claim | Description |\n    | --- | --- |\n    | `exp` | Token expiration |\n    | `iss` | Token issuer |\n    | `aud` | Intended recipient of the token |\n    \n\n## Scenario: Bank transactions with push notifications\n\nIn the following scenario, an application authenticates a user with username and password and then requests an account balance. Before retrieving the account balance information, the user must authenticate with Guardian push factor.\n\nThe banking API can accept two different levels of authorization: view account balance (scope `view:balance`) or transfer funds (scope `transfer:funds`). When the application asks the API to retrieve the user's balance, the access token should contain the `view:balance` scope. To transfer money to another account, the access token should contain the `transfer:funds` scope.\n\n### Workflow\n\n1.  The user logs in to the application using username and password authentication. The standard login gives this user the ability to interact with the API and fetch their balance. This means that the access token that the app receives after the user authenticates contains the `view:balance` scope.\n    \n2.  The application sends a request to the API to retrieve the balance, using the access token as credentials.\n    \n3.  The API validates the token and sends the balance info to the application, so the user can view it.\n    \n4.  The user wants to transfer funds from one account to another, which is deemed a high-value transaction that requires the `transfer:funds` scope. The application sends a request to the API using the same access token.\n    \n5.  The API validates the token and denies access because the token is missing the required `transfer:funds` scope.\n    \n6.  The application redirects to Auth0, where an Action is used to challenge the user to authenticate with MFA since a high-value scope was requested. Once the user successfully authenticates with MFA, a new access token that includes the correct scope is generated and sent to the application as part of the response.\n    \n7.  The application sends another transfer funds request using the new access token, which includes the `transfer:funds` scope this time.\n    \n8.  The API validates the token, discards it, and proceeds with the operation.\n    \n\n### Prerequisites\n\nFor this scenario, you must configure the following items in the Dashboard:\n\n*   [Register a Single-Page Web App](https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps).\n    \n*   [Create a database connection](https://manage.auth0.com/#/connections/database).\n    \n*   [Register the API](https://auth0.com/docs/get-started/auth0-overview/set-up-apis). Create two scopes: `view:balance` and `transfer:funds`.\n    \n*   [Enable MFA](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa) to use push notifications.\n    \n\n### Create an Action\n\nCreate an Action that challenges the user to authenticate with MFA when the `transfer:funds` scope is requested. Go to [Dashboard > Actions > Flows](https://manage.auth0.com/#/actions/flows) and create an Action that contains the following content:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const CLIENTS_WITH_MFA = ['REPLACE_WITH_YOUR_CLIENT_ID'];\n  // run only for the specified clients\n  if (CLIENTS_WITH_MFA.includes(event.client.client_id)) {\n    // ask for MFA only if scope transfer:funds was requested\n    if (event.transaction.requested_scopes.indexOf('transfer:funds') > -1)\n      api.multifactor.enable('any', { allowRememberBrowser: false });\n    }\n  }\n}\n```\n\n*   The `CLIENTS_WITH_MFA` variable contains the client IDs of the applications you want this Action to apply to. You can remove this (and the `if` conditional that follows) if you don't need it.\n    \n*   The `event.transaction.requested_scopes` property contains all the scopes for which the authentication request asked. If it includes the value `transfer:funds`, then we ask for MFA by setting the `context.multifactor` property to the appropriate value. In this case, we are asking for MFA using [push](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa).\n    \n\n### Configure app\n\nConfigure the app to send the appropriate authentication request to the API, depending on whether the user is attempting to perform the high-value transaction of transferring funds. Notice that the only difference between the two authentication requests (with or without MFA) is the scope.\n\n*   With MFA:\n    \n    ```\n    https://{yourDomain}/authorize?\n    audience=https://my-banking-api&\n    scope=openid%20view:balance%20transfer:funds&\n    response_type=id_token%20token&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    nonce=NONCE&\n    state=OPAQUE_VALUE\n    ```\n    \n*   Without MFA:\n    \n    ```\n    https://{yourDomain}/authorize?\n    audience=https://my-banking-api&\n    scope=openid%20view:balance&\n    response_type=id_token%20token&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    nonce=NONCE&\n    state=OPAQUE_VALUE\n    ```\n    \n\n| Parameter | Setting |\n| --- | --- |\n| `audience` | Set to the **Identifier** of your API (find it at [API Settings](https://manage.auth0.com/#/apis/)). We set ours to `https://my-banking-api`. |\n| `response_type` | Set to `id_token token` so we get both an ID Token and an Access Token in the response. |\n| `client_id` | Set to the Client ID of your application (find it at [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings)). |\n| `redirect_uri` | Set to a URL in your application that Auth0 should redirect back to after authentication (find it at [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings)). |\n| `nonce` | Set to a secure string value which will be included in the response from Auth0. This is [used to prevent token replay attacks](https://auth0.com/docs/api-auth/tutorials/nonce) and is required for `response_type=id_token token`. |\n| `state` | Set to an opaque value that Auth0 includes when redirecting back to the application. This value must be used by the application to prevent CSRF attacks. |\n\n### Configure API\n\nConfigure the API to validate the incoming token and check the authorized permissions.\n\n1.  Configure two endpoints for our API: `GET /balance`: to retrieve the current balance `POST /transfer`: to transfer funds\n    \n2.  Use `Node.js` and a number of modules:\n    \n    1.  [express](https://expressjs.com/): adds the Express web application framework.\n        \n    2.  [jwks-rsa](https://github.com/auth0/node-jwks-rsa): retrieves RSA signing keys from a **JWKS** (JSON Web Key Set) endpoint. Using `expressJwtSecret`, we can generate a secret provider that will issue the right signing key to `express-jwt` based on the `kid` in the JWT header.\n        \n    3.  [express-jwt](https://github.com/auth0/express-jwt): lets you authenticate HTTP requests using JWT tokens in your Node.js applications. It provides several functions that make working with JWTs easier.\n        \n    4.  [express-jwt-authz](https://github.com/auth0/express-jwt-authz): checks if the access token contains a specific scope.\n        \n3.  Install the dependencies: `npm install express express-jwt jwks-rsa express-jwt-authz --save`\n    \n4.  Define the API endpoints, create a middleware function to validate the access token, and secure the endpoints using that middleware. The code in your `server.js` file should look like the following sample script:\n    \n    ```\n    // set dependencies\n        const express = require('express');\n        const app = express();\n        const jwt = require('express-jwt');\n        const jwksRsa = require('jwks-rsa');\n        const jwtAuthz = require('express-jwt-authz');\n    \n        // Create middleware for checking the JWT\n        const checkJwt = jwt({\n          // Dynamically provide a signing key based on the kid in the header and the signing keys provided by the JWKS endpoint\n          secret: jwksRsa.expressJwtSecret({\n            cache: true,\n            rateLimit: true,\n            jwksRequestsPerMinute: 5,\n            jwksUri: `https://{yourDomain}/.well-known/jwks.json`\n          }),\n    \n          // Validate the audience and the issuer\n          audience: 'https://my-banking-api', // replace with your API's audience, available at Dashboard > APIs\n          issuer: 'https://{yourDomain}/',\n          algorithms: [ 'RS256' ] // we are using RS256 to sign our tokens\n        });\n    \n        // create retrieve balance endpoint\n        app.get('/balance', checkJwt, jwtAuthz(['view:balance']), function (req, res) {\n          // code that retrieves the user's balance and sends it back to the calling app\n          res.status(201).send({message: \"This is the GET /balance endpoint\"});\n        });\n    \n    \n        // create transfer funds endpoint\n        app.post('/transfer', checkJwt, jwtAuthz(['transfer:funds']), function (req, res) {\n          // code that transfers funds from one account to another\n          res.status(201).send({message: \"This is the POST /transfer endpoint\"});\n        });\n    \n        // launch the API Server at localhost:8080\n        app.listen(8080);\n        console.log('Listening on http://localhost:8080');\n    ```\n    \n    Each time the API receives a request the following happens:\n    1.  The endpoint calls the `checkJwt` middleware.\n        \n    2.  `express-jwt` decodes the token and passes the request, the header, and the payload to `jwksRsa.expressJwtSecret`.\n        \n    3.  `jwks-rsa` downloads all signing keys from the JWKS endpoint and checks if one of the signing keys matches the `kid` in the header of the access token. If none of the signing keys match the incoming `kid`, an error is thrown. If there is a match, we pass the right signing key to `express-jwt`.\n        \n    4.  `express-jwt` continues its own logic to validate the signature of the token, the expiration, audience, and the issuer.\n        \n    5.  `jwtAuthz` checks if the scope that the endpoint requires is part of the access token. If the specified scopes are missing from the access token, the request is rejected with a 403 error message.\n        \n\n## Learn more\n\n*   [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens)\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Action Use Cases](https://auth0.com/docs/customize/actions/use-cases)\n*   [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes)\n*   [Configure Step-up Authentication for Web Apps](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-web-apps)",
  "title": "Configure Step-up Authentication for APIs",
  "description": "Learn how an API can check if a user has logged in with Multi-factor Authentication by examining their access token.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk",
  "markdown": "# Guardian.swift iOS SDK\n\n[Guardian.swift](https://github.com/auth0/Guardian.swift) allows you to integrate Auth0's Guardian multi-factor service in your own iOS app, transforming it into the second factor itself. Your users will get all the benefits of our frictionless multi-factor authentication from your app. To learn more, read [Getting Started with Apple Push Notification Service](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa#configure-push-notifications-for-apple-using-apn-).\n\n## Requirements\n\n*   iOS 10+ and Swift 4.1 is required in order to use Guardian.\n    \n*   To use this SDK you have to configure your tenant's Guardian service with your own push notification credentials, otherwise, you would not receive any push notifications. To learn more, read [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa).\n    \n\n## Install Guardian iOS SDK\n\n### CocoaPods\n\nGuardian.swift is available through [CocoaPods](http://cocoapods.org/). To install it, add the following line to your Podfile:\n\n```\npod 'Guardian', '~> 1.1.0'\n```\n\n### Carthage\n\nAdd this line to your Cartfile:\n\n```\ngithub \"auth0/Guardian.swift\" ~> 1.1.0\n```\n\n## Enable Guardian push notifications\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/guardian).\n    \n    ![Auth0 Dashboard Security Multi-Factor Authentication](https://images.ctfassets.net/cdy7uua7fh8z/4xrjmhY1cLhXhlygZKyN4f/3ec3b4cfc0d4e3ce178b519a0fb7df17/Dashboard_-_Security_-_MFA.png)\n2.  Toggle **Push Notification** on to enable it.\n    \n3.  [Configure push notifications](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa#configure-push-notifications-for-apple-using-apn-).\n    \n\n## Usage\n\n`Guardian` is the core of the SDK. To use the SDK, import the library:\n\nSet the domain for your tenant. Or, use the custom domain if you configured one for your tenant:\n\n```\nlet domain = \"{yourDomain}/appliance-mfa\"\n```\n\n### Enroll\n\nAn enrollment is a link between the second factor and an Auth0 account. When an account is enrolled you'll need it to provide the second factor required to verify the identity. If your app is not yet using push notifications or you're not familiar with it, see [Apple Push Notification Service Overview](https://developer.apple.com/go/?id=push-notifications) for details.\n\nFor an enrollment you need the following information, besides your Guardian domain:\n\n| Variable | Description |\n| --- | --- |\n| **Enrollment URI** | Value encoded in the QR code scanned from Guardian Web Widget or your enrollment ticket sent to you in email or SMS. |\n| **APNS Token** | Apple APNS token for the device. It must be a string containing the 64 bytes (in hexidecimal format). |\n| **Key Pair** | An RSA (private/public) key pair used to assert your identity with Auth0 Guardian. |\n\nAfter you have the information, you can enroll your device:\n\n```\nGuardian\n        .enroll(forDomain: \"{yourGuardianDomain}\",\n                usingUri: \"{enrollmentUri}\",\n                notificationToken: \"{apnsToken}\",\n                signingKey: signingKey,\n                verificationKey: verificationKey\n                )\n        .start { result in\n            switch result {\n            case .success(let enrolledDevice):\n                // success, we have the enrollment device data available\n            case .failure(let cause):\n                // something failed, check cause to see what went wrong\n            }\n        }\n```\n\nOn success you'll obtain the enrollment information, that should be secured stored in your application. This information includes the enrollment identifier, and the token for Guardian API associated to your device for updating or deleting your enrollment.\n\n#### Signing and verification keys\n\nGuardian.swift provides a convenience class to generate a signing key:\n\n```\nlet signingKey = try DataRSAPrivateKey.new()\n```\n\nThis key only exists in memory but you can obtain its `Data` representation and store securely in, for example, an encrypted SQLiteDB:\n\n```\n// Store data\nlet data = signingKey.data\n// perform the storage\n\n// Load from Storage\nlet loadedKey = try DataRSAPrivateKey(data: data)\n```\n\nBut if you just want to store inside iOS Keychain:\n\n```\nlet signingKey = try KeychainRSAPrivateKey.new(with: \"com.myapp.mytag\")\n```\n\nThe above example creates a key and stores it automatically under the supplied tag. If you want to retrieve it, you can use the tag:\n\n```\nlet signingKey = try KeychainRSAPrivateKey(tag: \"com.myapp.mytag\")\n```\n\nFor the verification key, we can just obtain it from any `SigningKey`, for example:\n\n```\nlet verificationKey = try signingKey.verificationKey()\n```\n\n### Allow login requests\n\nOnce you have the enrollment in place, you will receive a push notification every time the user has to validate their identity with MFA. Guardian provides a method to parse the data received from APNs and return a `Notification` instance ready to be used.\n\n```\nif let notification = Guardian.notification(from: notificationPayload) {\n    // we have received a Guardian push notification\n}\n```\n\nOnce you have the notification instance, you can easily allow the authentication request by using the `allow` method. You'll also need some information from the enrolled device that you obtained previously. In case you have more than one enrollment, you'll have to find the one that has the same `id` as the notification (the `enrollmentId` property).\n\nWhen you have the information, `device` parameter is anything that implements the protocol `AuthenticatedDevice`:\n\n```\nstruct Authenticator: Guardian.AuthenticationDevice {\n    let signingKey: SigningKey\n    let localIdentifier: String\n}\n```\n\nLocal identifier is the local id of the device, by default on enroll `UIDevice.current.identifierForVendor`. Then just call:\n\n```\nGuardian\n        .authentication(forDomain: \"{yourGuardianDomain}\", device: device)\n        .allow(notification: notification)\n        .start { result in\n            switch result {\n            case .success:\n                // the auth request was successfuly allowed\n            case .failure(let cause):\n                // something failed, check cause to see what went wrong\n            }\n        }\n```\n\n### Reject login requests\n\nTo deny an authentication request call `reject` instead. You can also send an optional reject reason. The reject reason will appear in the Guardian logs.\n\n```\nGuardian\n        .authentication(forDomain: \"{yourGuardianDomain}\", device: device)\n        .reject(notification: notification)\n        // or reject(notification: notification, withReason: \"hacked\")\n        .start { result in\n            switch result {\n            case .success:\n                // the auth request was successfuly rejected\n            case .failure(let cause):\n                // something failed, check cause to see what went wrong\n            }\n        }\n```\n\n### Unenroll\n\nIf you want to delete an enrollment, for example, if you want to disable MFA, you can make the following request:\n\n```\nGuardian\n        .api(forDomain: \"{yourGuardianDomain}\")\n        .device(forEnrollmentId: \"{userEnrollmentId}\", token: \"{enrollmentDeviceToken}\")\n        .delete()\n        .start { result in\n            switch result {\n            case .success:\n                // success, the enrollment was deleted\n            case .failure(let cause):\n                // something failed, check cause to see what went wrong\n            }\n        }\n```\n\n### Set up mobile-only OTP enrollment\n\nYou can enable one-time passwords (OTP) as an MFA factor using the Auth0 Dashboard or Management API. This option does not require a QR code and allows users to enroll manually.\n\nTo invite a user to enroll, navigate to the [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users) and select a user. Then, access their Details tab and use the Multi-Factor Authentication section to send an enrollment invitation.\n\n![Auth0 Dashboard > User Management > Users > [Specific User] > Details](https://images.ctfassets.net/cdy7uua7fh8z/2p9KJ8OnVY99b3ytVLJVVQ/0502eb8ea888cc6d5d4225b7310e3884/image6.png)\n\n#### Connect a resource\n\nYou can connect a resource using the Auth0 Dashboard or the Guardian SDK.\n\n##### Use Auth0 Dashboard\n\n1.  Access the Auth0 login prompt and copy the provided code or a similar base32 encoded key obtained from another source. In the next step, you will enter this code into an authentication application.\n    \n    ![An example login prompt displaying a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/1yoqiIuERVTwCU8yfx6IM8/86283023dddbddd3a903a654bf28cac2/image1.png)\n2.  Add the code you copied to an authentication application, such as Guardian.\n    \n\n![An example authentication app showing OTPs. ](https://images.ctfassets.net/cdy7uua7fh8z/SgOzh869kU7cTU4ZoBEVA/30be4ae2791be497354b3e413f2a8b1d/image4-scaled.png)\n\n##### Use the SDK\n\n1.  Import the Guardian library.\n    \n2.  Create a code generator.\n    \n    ```\n    let codeGenerator = try Guardian.totp(\n    \n       base32Secret: enrollmentCode,  // Enrollment code entered by user\n    \n       algorithm: .sha1\t\t\t// Algorithm used by TOTP\n    \n    )\n    ```\n    \n3.  Retrieve generated code.\n    \n\n#### Enter one-time code\n\nOn the Auth0 login prompt, enter the code you generated in the previous step.\n\n![An example login prompt displaying a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/1yoqiIuERVTwCU8yfx6IM8/86283023dddbddd3a903a654bf28cac2/image1.png)\n\nAfter selecting Continue, a message displays stating your application has been added as an authentication factor for your user.\n\n![The success message that displays after entering your one-time code into the Auth0 login prompt. ](https://images.ctfassets.net/cdy7uua7fh8z/3Jm0ShXLZkeKcmpdHzuvs7/6c284b21a780cda8b6fac0ce1068ce2f/image5.png)\n\n#### Log in with your app\n\nAfter the factor has been enrolled, your user can log in using your app. First, choose the Guardian app as your authentication method.\n\n![The authentication method selection screen](https://images.ctfassets.net/cdy7uua7fh8z/1k7IsU9kfP5mrXU2jfGHuT/6f8f9deceb42737fbb68350afc3f387d/image2.png)\n\nThen, enter the one-time code into the login prompt to verify your identity.\n\n![The Verify Your Identity screen prompting the user for a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/S6uTieLjtuNUrQRMh8uch/901e7f08b431d1d48cc8eb4ba7dd6653/image3.png)",
  "title": "Guardian.swift iOS SDK",
  "description": "Describes how to install, use and configure options for the Guardian.swift iOS SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk",
  "markdown": "# Guardian for Android SDK\n\nThe [Guardian for Android SDK](https://github.com/auth0/Guardian.Android) helps you create Android apps with Guardian functionality, providing secure access to multi-factor authentication (MFA) with push notifications. With this toolkit, you can build your own customized version of the Guardian application that matches the look and feel of your organization. To learn more, read [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa#configure-push-notifications-for-apple-using-apn-).\n\nAndroid API level 15+ is required in order to use the Guardian for Android SDK.\n\n## Install Guardian Android SDK\n\nGuardian is available both in [Maven Central](http://search.maven.org/) and [JCenter](https://bintray.com/auth0/android/guardian).\n\n1.  To use Guardian, add these lines to your `build.gradle` dependencies file: `implementation 'com.auth0.android:guardian:0.4.0'` You can check for the latest version on the repository [Releases](https://github.com/auth0/GuardianSDK.Android/releases) tab, in [Maven](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22com.auth0.android%22%20AND%20a%3A%22guardian%22), or in [JCenter](https://bintray.com/auth0/android/guardian).\n    \n2.  After adding your Gradle dependency, make sure to sync your project with Gradle file.\n    \n\n### Enable Guardian push notifications\n\n1.  Go to [Dashboard > Security > Multifactor Auth > Push via Auth0 Guardian.](https://manage.auth0.com/#/security/mfa/guardian)\n    \n2.  Toggle the switch at the top to enable it.\n    \n\n![Auth0 Dashboard > Security > Multi-factor Auth > Guardian > Custom > Amazon SNS](https://images.ctfassets.net/cdy7uua7fh8z/6PKSyH99GJ2CalJoG38sfZ/fbe7229dcc6f7d303a582520001b3dc1/Amazon_SNS.png)\n\n3\\. [Configure push notifications](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa#configure-push-notifications-for-android-using-fcm).\n\n## Use SDK\n\nGuardian is the core of the SDK. You'll need to create an instance of this class for your specific tenant URL.\n\n```\nUri url = Uri.parse(\"https://{yourDomain}/appliance-mfa\");\n\nGuardian guardian = new Guardian.Builder()\n    .url(url)\n    .build();\n```\n\nor\n\n```\nString domain = \"{yourDomain}/appliance-mfa\";\n\nGuardian guardian = new Guardian.Builder()\n    .domain(domain)\n    .build();\n```\n\n### Enroll\n\nThe link between the second factor (an instance of your app on a device) and an Auth0 account is referred to as an **enrollment**.\n\nYou can create an enrollment using the `Guardian.enroll` function, but first, you'll have to create a new pair of RSA keys for it. The private key will be used to sign the requests to allow or reject a login. The public key will be sent during the enrollment process so the server can later verify the request's signature.\n\n```\nKeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\nkeyPairGenerator.initialize(2048); // you MUST use at least 2048 bit keys\nKeyPair keyPair = keyPairGenerator.generateKeyPair();\n```\n\nNext, obtain the enrollment information by scanning the Guardian QR code, and use it to enroll the account:\n\n```\nUri enrollmentUriFromQr = ...; // the URI obtained from a Guardian QR code\n\nCurrentDevice device = new CurrentDevice(context, \"fcmToken\", \"deviceName\");\n\nEnrollment enrollment = guardian\n    .enroll(enrollmentUriFromQr, device, keyPair)\n    .execute();\n```\n\nAlternatively, you can execute the request in a background thread:\n\n```\nguardian\n    .enroll(enrollmentUriFromQr, device, keyPair)\n    .start(new Callback<Enrollment> {\n        @Override\n        void onSuccess(Enrollment enrollment) {\n            // we have the enrollment data\n        }\n\n        @Override\n        void onFailure(Throwable exception) {\n            // something failed\n        }\n    });\n```\n\nYou must provide the following data:\n\n| Variable | Description |\n| --- | --- |\n| `deviceName` | Name for the enrollment displayed to the user when the second factor is required. |\n| `fcmToken` | Token for Firebase Cloud Messaging (FCM) push notification service. See [Sample Register](https://firebase.google.com/docs/cloud-messaging/android/client#sample-register \"sample register\") for details. |\n\n### Unenroll\n\nTo disable MFA, you can delete the enrollment:\n\n```\nguardian\n    .delete(enrollment)\n    .execute(); // or start(new Callback<> ...)\n```\n\n### Allow login requests\n\nOnce you have the enrollment in place, you'll receive a FCM push notification every time the user needs multi-factor authentication.\n\nGuardian provides a method to parse the `Map<String, String>` data inside the [RemoteMessage](https://firebase.google.com/docs/reference/android/com/google/firebase/messaging/RemoteMessage) received from FCM and return a `Notification` instance ready to be used.\n\n```\n// at the FCM listener you receive a RemoteMessage\n@Override\npublic void onMessageReceived(RemoteMessage message) {\n    Notification notification = Guardian.parseNotification(message.getData());\n    if (notification != null) {\n        // you received a Guardian notification, handle it\n        handleGuardianNotification(notification);\n        return;\n    }\n\n    /* handle other push notifications you might be using ... */\n}\n```\n\nOnce you have the notification instance, you can use the `allow` method to approve the authentication request. You'll also need the enrollment that you obtained previously. If there are multiple enrollments, be sure to use the one that has the same `id` as the notification (the `enrollmentId` property).\n\n```\nguardian\n    .allow(notification, enrollment)\n    .execute(); // or start(new Callback<> ...)\n```\n\n### Reject login requests\n\nTo deny an authentication request, use `reject` instead. You can also add an optional reason for the rejection, which will be available in the guardian logs.\n\n```\nguardian\n    .reject(notification, enrollment) // or reject(notification, enrollment, reason)\n    .execute(); // or start(new Callback<> ...)\n```\n\n### Set up mobile-only OTP enrollment\n\nYou can enable one-time passwords (OTP) as an MFA factor using the Auth0 Dashboard or Management API. This option does not require a QR code and allows users to enroll manually.\n\nTo invite a user to enroll, navigate to the [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users) and select a user. Then, access their Details tab and use the Multi-Factor Authentication section to send an enrollment invitation.\n\n![Auth0 Dashboard > User Management > Users > [Specific User] > Details](https://images.ctfassets.net/cdy7uua7fh8z/2p9KJ8OnVY99b3ytVLJVVQ/0502eb8ea888cc6d5d4225b7310e3884/image6.png)\n\n#### Connect a resource\n\nYou can connect a resource using the Auth0 Dashboard or the Guardian SDK.\n\n##### Use Auth0 Dashboard\n\n1.  Access the Auth0 login prompt and copy the provided code or a similar base32 encoded key obtained from another source.\n    \n    ![An example login prompt displaying a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/1yoqiIuERVTwCU8yfx6IM8/86283023dddbddd3a903a654bf28cac2/image1.png)\n2.  After obtaining your code, add it to the Guardian SDK:\n    \n\n**Java**\n\n`public String copiedCode = \"{copiedCode}\";`\n\n**Kotlin**\n\n`val copiedCode: String = \"{copiedCode}\"`\n\n##### Use Guardian SDK\n\nFirst, add the `LoginCodeGenerator` class to your project. Then, use `getCode (String copiedCode) to` generate a one-time code in your app.\n\n**Java**\n\n```\npublic class LoginCodeGenerator {\n\n   private static final int TOTP_LENGTH = 6;\n\n   private static final int TOTP_DURATION = 30;\n\n   private static final String TOTP_ALGORITHM = \"SHA1\";\n\n   public String getCode(String copedCode) {\n\n       byte[] key = new byte[0];\n\n       try {\n\n           key = Base32.decode(copedCode);\n\n       } catch (Base32.DecodingException ex) {\n\n//            handle exception\n\n       }\n\n       TOTP totp = new TOTP(TOTP_ALGORITHM, key, TOTP_LENGTH, TOTP_DURATION);\n\n       return totp.generate();\n\n   }\n\n}\n```\n\n**Kotlin**\n\n```\nclass LoginCodeGenerator {\n\n   fun getCode(copiedCode: String): String {\n\n       var key: ByteArray? = ByteArray(0)\n\n       try {\n\n           key = Base32.decode(copiedCode)\n\n       } catch (ex: Base32.DecodingException) {\n\n//            handle exception\n\n       }\n\n       val totp = TOTP(TOTP_ALGORITHM, key, TOTP_LENGTH, TOTP_DURATION)\n\n       return totp.generate()\n\n   }\n\n   companion object {\n\n       private const val TOTP_LENGTH = 6\n\n       private const val TOTP_DURATION = 30\n\n       private const val TOTP_ALGORITHM = \"SHA1\"\n\n   }\n\n}\n```\n\n#### Enter one-time code\n\nEnter the generated one-time password from `getCode()` into the Auth0 login prompt.\n\n![An example login prompt displaying a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/1yoqiIuERVTwCU8yfx6IM8/86283023dddbddd3a903a654bf28cac2/image1.png)\n\nAfter selecting Continue, a message displays stating your application has been added as an authentication factor for your user.\n\n![The success message that displays after entering your one-time code into the Auth0 login prompt. ](https://images.ctfassets.net/cdy7uua7fh8z/3Jm0ShXLZkeKcmpdHzuvs7/6c284b21a780cda8b6fac0ce1068ce2f/image5.png)\n\n#### Log in with your app\n\nAfter the factor has been enrolled, your user can log in using your app. First, choose the Guardian app as your authentication method.\n\n![The authentication method selection screen](https://images.ctfassets.net/cdy7uua7fh8z/1k7IsU9kfP5mrXU2jfGHuT/6f8f9deceb42737fbb68350afc3f387d/image2.png)\n\nTo generate the one-time code, call `getCode(copedCode: String)` using the code you copied from the Auth0 login prompt.\n\nThen, enter the one-time code into the login prompt to verify your identity.\n\n![The Verify Your Identity screen prompting the user for a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/S6uTieLjtuNUrQRMh8uch/901e7f08b431d1d48cc8eb4ba7dd6653/image3.png)\n\n## Learn more\n\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)",
  "title": "Guardian for Android SDK",
  "description": "Describes how to install, configure, and use options for the Auth0 Guardian for Android SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/clients/get-clients",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection",
  "markdown": "# Create Custom Database Connections\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nIf you have your own user database, you can use it as an identity provider in Auth0 to authenticate users. In this process, you will create the custom database connection, create database action scripts, and add configuration parameters.\n\nAuth0 allows you to create connections and scripts for most of the commonly-used databases, including:\n\n*   ASP.NET Membership Provider\n    \n*   MongoDB\n    \n*   MySQL\n    \n*   PostgreSQL\n    \n*   SQLServer\n    \n*   Windows Azure SQL Database\n    \n*   Web services accessed via Basic Auth\n    \n\nYou can connect to any kind of database or web service with a properly-configured custom script. Note that input sanitization must be completed on the customer end; Auth0 does not sanitize or validate any username/password combination passed by a custom database.\n\n#### Network firewall\n\nIf you are behind a firewall, this feature may require that you add the appropriate Auth0 IP addresses to the Allow List to work properly.\n\n## Create the connection in the Auth0 Dashboard\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), and select **Create DB Connection**.\n    \n    ![Select connection](https://images.ctfassets.net/cdy7uua7fh8z/6shISO4Uw6XqldxxGnbrqW/0215e069f09c6baebd1d7abb5b3ae253/2024-03-20_16-39-37.png)\n2.  Configure the connection's settings, and click **Create**:\n    \n    | **Parameter** | **Definition** |\n    | --- | --- |\n    | **Name** | The name of the connection. The name must start and end with an alphanumeric character, contain only alphanumeric characters and dashes, and not exceed 35 characters. |\n    | **Requires Username** | Forces users to provide a username _and_ email address during registration. |\n    | **Username length** | Sets the minimum and maximum length for a username. |\n    | **Disable Signups** | Prevents signups to your application. You will still be able to create users with your API credentials or via the Auth0 Dashboard. |\n    \n    Once Auth0 creates your connection, you'll have the following views (in addition to the **Settings** view):\n    *   Password Policy\n        \n    *   Custom Database\n        \n    *   Applications\n        \n    *   Try Connection\n        \n3.  Select the **Custom Database** view, and enable the **Use my own database** switch.\n    \n    ![Enable Custom Database Use My Own Database Option](https://images.ctfassets.net/cdy7uua7fh8z/3kgHDpBFdVWNq9XOfhsTXI/5a18f3634d4d9efa121db32b6cb3d93d/dashboard-connections-database-edit_view-custom-database_use-my-own-database__1_.png)\n\n## Create database action scripts\n\nToggling the **Use my own database** switch enables the **Database Action Scripts** area where you will create scripts to configure how authentication works when using your database. You can write your database action scripts, or you can select a template from the **Templates** dropdown and modifying it as necessary.\n\nYou **must** configure a `login` script; additional scripts for user functionality are optional.\n\nThe available database action scripts are:\n\n| **Name** | **Description** | **Parameters** |\n| --- | --- | --- |\n| **Login**  <br>Required | Executes each time a user attempts to log in. | `email`, `password` |\n| **Create** | Executes when a user signs up. | `user.email`, `user.password` |\n| **Verify** | Executes after a user follows the verification link. | `email` |\n| **Change Password** | Executes when a user clicks on the confirmation link after a reset password request. | `email`, `newPassword` |\n| **Get User** | Retrieves a user profile from your database without authenticating the user. | `email` |\n| **Delete** | Executes when a user is deleted using the API or Auth0 Dashboard. | `id` |\n| **Change Email** | Executes when a change in the email address, or the email address status, for a user occurs. | `email`, `newEmail`, `verified` |\n\nTo learn more about the scripts, read [Custom Database Action Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates) and [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution).\n\n### Create a Login script\n\n#### Avoid user ID collisions with multiple databases\n\nThe `id` (or alternatively `user_id`) property in the returned user profile will be used by Auth0 to identify the user.\n\nIf you are using multiple custom database connections, then `id` value must be unique across all the custom database connections to avoid user ID collisions. Our recommendation is to prefix the value of `id` with the connection name (omitting any whitespace). To learn more about user IDs, read [Identify Users](https://auth0.com/docs/manage-users/user-accounts/identify-users).\n\nThe following steps use an example for a MySQL database login script\n\n1.  After toggling the **Use my own database** switch, the **Database Action Scripts** area is enabled. Make sure you are on the **Login** tab.\n    \n2.  Use the **Templates** dropdown to select the MySQL database script template.\n    \n    ```\n    function login(email, password, callback) {\n      var bcrypt = require('bcrypt');\n      var mysql = require('mysql');\n      var connection = mysql.createConnection({\n        host: 'localhost',\n        user: 'me',\n        password: 'secret',\n        database: 'mydb'\n      });\n      connection.connect();\n      var query = \"SELECT id, nickname, email, password \" +\n        \"FROM users WHERE email = ?\";\n      connection.query(query, [email], function (err, results) {\n        if (err) return callback(err);\n        if (results.length === 0) return callback(new WrongUsernameOrPasswordError(email));\n        var user = results[0];\n        bcrypt.compare(password, user.password, function (err, isValid) {\n          if (err) {\n            callback(err);\n          } else if (!isValid) {\n            callback(new WrongUsernameOrPasswordError(email));\n          } else {\n            callback(null, {\n              // This prefix (replace with your own custom DB name)\n              // ensure uniqueness across different custom DBs if there's the\n              // possibility of collisions (e.g. if the user ID is an email address or an integer)\n              id: 'MyConnection1|' + user.id.toString(),\n              nickname: user.nickname,\n              email: user.email\n            });\n          }\n        });\n      });\n    }\n    ```\n    \n    The above script connects to a MySQL database and executes a query to retrieve the first user with `email == user.email`. With the `bcrypt.compareSync` method, it then validates that the passwords match, and if successful, returns an object containing the user profile information including `id`, `nickname`, and `email`. This script assumes that you have a `users` table containing these columns. The `id` returned by Login script is used to construct the user ID attribute of the user profile.\n3.  Click **Save**.\n    \n4.  Click **Try** to test the script. (This step will also save your script.)\n    \n\nScript templates are not used by Auth0 until you click **Save** or **Try**. This is true even if you only modify one script and haven't made changes to any others. You must click **Save** at least once for all the scripts to be in place.\n\n## Custom database support for Organizations\n\nIf you use custom database connections in conjunction with Organizations, you can use the `context` parameter in the script signature to make Organization details like `id`, `name`, and `metadata` available to your custom database action scripts. Organization data is passed in the context object when the associated action happens in the context of an organization; for example, when a user authenticates on an organization’s login prompt, the login action script is passed. To learn more, read [Database Connections](https://auth0.com/docs/authenticate/database-connections).\n\n### Enable context object\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/dashboard/us/#/connections/database/).\n    \n2.  Select your database connection.\n    \n3.  Under the **Custom Database** tab, find **Context objects in database scripts** and select **Enable**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/5XO1ypTfQXgRAGx1WBzZRq/a40fe281c749f64d37dabd44c2adffb7/2022-10-28_11-36-37.png)\n\n### Use Organization context\n\nOnce the context object is enabled in Dashboard, you can add a \\`context\\` object to your custom database action scripts, inserted directly preceding the callback parameter. When events are triggered with Organization context, the corresponding data is made available to your custom database action scripts in the format below:\n\n```\n{\n\"organization\": {\n\"display_name\": \"My Organization\",\n\"id\": \"org_XXXXXX\",\n\"metadata\": {\n\"foo\": \"bar\"\n},\n\"name\": \"my-organization\"\n}\n}\n```\n\n## Add configuration parameters\n\nYou can store parameters, like the credentials required to connect to your database, in the **Settings** section below the script editor. These will be available for all of your scripts, and you can access the parameter values using the `configuration` object in your database action scripts (i.e., `configuration.MYSQL_PASSWORD`).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5wa0UuUFCLBCc8WlLBax7m/9f88227b6f17cad3bbf4bef23398af26/Screenshot_2023-11-02_at_2.12.37_PM.png)\n\nUse the added parameters in your scripts to configure the connection. For example, you might add the following to the MySQL Login script:\n\n```\nfunction login (username, password, callback) {\n  var mysql = require('mysql');\n  var connection = mysql.createConnection({\n    host     : configuration.MYSQL_HOST,\n    user     : 'me',\n    password : configuration.MYSQL_PASSWORD,\n    database : 'mydb'\n  });\n}\n```\n\n## Learn more\n\n*   [Custom Database Connection and Action Script Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts)\n*   [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling)\n*   [Import and Export Users](https://auth0.com/docs/manage-users/user-migration)",
  "title": "Create Custom Database Connections",
  "description": "Learn how to create a database connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-enrollments-universal-login",
  "markdown": "# Customize MFA Enrollments for Universal Login\n\nAuth0 supports a variety of factors for securing user access with [multi-factor authentication (MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)). Using `post-login` Actions, you can customize your MFA flows to prompt users to enroll in specific factors. After a user enrolls in a factor, they can use that factor as a secondary method of authentication in future logins.\n\nYou can also use contextual information to further customize your MFA enrollment flows. For example, you can prompt users to enroll in SMS for one application while prompting them to enroll in push notifications or WebAuthN for a different application.\n\nThis feature allows you to customize your MFA enrollment flows. If you want to customize MFA flows for users who are already enrolled, review [Customize MFA Selection for Universal Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login).\n\n## How it works\n\nYou can use [Actions](https://auth0.com/docs/customize/actions) to customize your MFA enrollment flows. Specifically, you can modify the `post-login` trigger of the [Login Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) with the following Authentication API methods:\n\n*   `enrollWith`: Specifies the default factor presented to users during enrollment. Optionally, you can provide an alternative list of factors for users to choose from. If provided, a Try Another Method link displays on the enrollment prompt.\n    \n*   `enrollWithAny`: Specifies a set of factors users can choose from during enrollment. By default, this method presents a selection prompt that allows users to choose their desired factor. In some cases, the user experience may vary:\n    \n    *   If two or more factors have been specified, the selection prompt displays to the user.\n        \n    *   If the user has already enrolled in all specified factors except one, the selection prompt is skipped, and the user is prompted to enroll in the remaining factor.\n        \n    *   If the user has already enrolled in all specified factors, the command fails, and the login sequence continues.\n        \n\nYou can use a combination of these methods to customize your MFA enrollment flows. You can also incorporate user metadata, such as roles or last login date, to create more tailored experiences.\n\nCustomized enrollment flows support the following factors:\n\n*   `otp`\n    \n*   `recovery-code`\n    \n*   `push-notification`\n    \n*   `phone`\n    \n    *   `preferredMethod: voice`\n        \n    *   `preferredMethod: sms`\n        \n    *   `preferredMethod: both`\n        \n*   `webauthn-platform`\n    \n*   `webauthn-roaming`\n    \n\nAfter a user enrolls in a factor, its value is added to their `enrolledFactors`. This property represents the list of active factors associated with their user account.\n\nThe array `event.authentication.methods` includes a `type` field when the name of the method is set to `mfa`. This field contains factor values (string) that match those used by the `type` field from `enrolledFactors`.\n\nWhen an MFA enrollment occurs, `methods` contains the object of `name:mfa` with `type` set to the factor used for that event. `methods` and `enrolledFactors` are only updated when an Action first begins. You can access the results of an enrollment event in the next Action of the flow.\n\nTo learn more, review the following resources:\n\n*   [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object)\n    \n*   [Actions Triggers: post-login - API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object)\n    \n\n### Sequenced and contextual flows\n\nWith the `enrollWith` or `enrollWithAny` commands, you can use contextual information to determine the best enrollment or series of enrollments to present to users.\n\n*   The `enrollWith` command supports an initial or default factor and a list of alternatives. Users can only enroll in one factor per command.\n    \n*   The `enrollWithAny` command supports a list of factors. The specified order of factors determines how the list displays to users. Users can only enroll in one factor per command.\n    \n\nWith these commands, you can leverage the following:\n\n*   **Sequenced flows**: Enroll users with a series of factors in a specific order.\n    \n*   **Contextual flows**: Determine which factor to prompt the user with based on metadata or previous commands in the flow.\n    \n\nTo help illustrate these flows, consider the following example:\n\n```\n// Action 1\n\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.user.enrolledFactors.length) {\n    // already enrolled, challenge\n    api.authentication.challengeWithAny(event.user.enrolledFactors.map(m => ({type: m.type})));\n    if (event.user.app_metadata.isAdmin &&\n        !event.user.enrolledFactors.some(m => m.type === 'webauthn-roaming')) {\n          // if is admin and doesn't have a security key, meaning a different factor was used, enroll now\n          api.authentication.enrollWith({type: 'webauthn-roaming'})\n        }\n  }\n  else {\n    // not enrolled; choose a factor to enroll now\n    api.authentication.enrollWithAny([{type: 'webauthn-roaming'}, {type: 'otp'}]);\n    if (event.user.app_metadata.isAdmin) {\n      // one more factor for admins\n      api.authentication.enrollWithAny([{type: 'webauthn-roaming'}, {type: 'otp'}]);\n    }\n  }\n};\n\n// Action 2\n\nexports.onExecutePostLogin = async (event, api) => {\n  function performed(type) {\n    return event.authentication.methods.some(m => m.name === 'mfa' &&\n           m.type === type &&\n           Date.now() - new Date(m.timestamp).getTime() < 5000)\n  }\n  if (event.user.app_metadata.isAdmin) {\n      // enforce both factors are used by challenging the one that has not been used yet\n      if (!performed('webauthn-roaming')) {\n        api.authentication.challengeWith({type: 'webauthn-roaming'})\n      }\n      else if (!performed('otp')) {\n        api.authentication.challengeWith({type: 'otp'})\n      }\n  }\n};\n```\n\nThese two Actions combine to create a scenario where users **without** the admin role are required to enroll with either a one-time password (OTP) or a security key. Conversely, users **with** the admin role must enroll in both factors.\n\nAction 1 reviews the `app_metadata` to determine if the user is an admin, then prompts them to enroll in specific factors. If an admin user has only enrolled in OTP, they are first challenged with OTP to complete their authentication. They are then prompted to enroll with security keys (`webauthn-roaming`).\n\nThe flow pauses after Action 1 executes, and both `event.user.enrolledFactors` and `event.authentication.methods` will be updated when Action 2 runs. This allows the Action code to make decisions based on actual user data when users are given a choice to challenge or enroll in different factors.\n\n**Note**: This method of executing Actions only applies to those containing `enrollWith` or `enrollWithAny` commands. Actions serving other purposes are not affected.\n\n## Before you begin\n\nBefore you can customize your MFA flows, you must set up MFA in your tenant and enable the Customize MFA Factors using Actions setting. You can enable one or more factors and define your MFA policies on your Auth0 Dashboard under [Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa).\n\n*   To learn more about the setup process, review [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa).\n    \n*   For information about configuring specific factors, review [Multi-factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n    \n\nTo customize your flows, you must enable the Customize MFA Factors using Actions toggle in the Additional Settings section. Your customized flows will not work properly if this setting is not enabled.\n\n![Auth0 Dashboard > Security > Multi-factor Auth > Additional Settings](https://images.ctfassets.net/cdy7uua7fh8z/2hv0ELTkkka3t230SXfxw/46def5395652b2451cfc9e0ad01a371a/MFA_actions.png)\n\n**Note**: Actions with `enrollWith` or `enrollWithAny` commands override any existing policies or rules that enable or disable MFA in a tenant.\n\n## Customize MFA enrollment flows\n\nAfter setting up MFA for your tenant, you can create `post-login` Actions to customize your MFA enrollment flows.\n\n### Create your post-login Action\n\nYou can create Actions through the Auth0 Dashboard:\n\n1.  Navigate to [Actions > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**.\n    \n2.  In the Add Action panel, select the **plus sign (+)** icon and choose **Build from scratch**. \n    \n3.  On the Create Action popup:\n    \n    *   Enter a name for your Action.\n        \n    *   Select **Login / Post-Login** as the trigger.\n        \n    *   Use **Node 18 (Recommended)** for the runtime.\n        \n4.  Review the popup to ensure accuracy. Then, select **Create**.\n    \n5.  In the code editor, add your custom code to the `onPostExecute` command. \n    \n6.  When your command is ready, select **Deploy**.\n    \n7.  Select **Add to Flow** on the successful deployment notification.\n    \n    *   **Note**: If the notification closes, choose **Back to Flow** above the code editor.\n        \n8.  Drag and drop your new command from the Add Action panel into your Login flow. Then, select **Apply**.\n    \n\nTo make additional changes after saving, navigate to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your Action. You can then update and redeploy your code as needed.\n\n### Test your post-login Action\n\nTo ensure your commands function appropriately, you can test your Action through the Auth0 Dashboard:\n\n1.  Navigate to [Authentication > Authentication Profile](https://manage.auth0.com/#/authentication-profiles).\n    \n2.  Select **Try** to open a sample login prompt in a new tab.\n    \n3.  Enter your credentials and test your new MFA flow.\n    \n\nIf the flow is successful, a confirmation screen displays. If you encounter any issues, you can update your code by navigating to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) in your Auth0 Dashboard.\n\n## Troubleshooting\n\nIn the event that you experience errors or unexpected results from your customized MFA enrollments, you can use the information below to help identify and resolve these issues.\n\n### Tenant Logs\n\nYou can monitor your customized MFA enrollments through [tenant logs](https://auth0.com/docs/deploy-monitor/logs).\n\nTenant logs are available in the Auth0 Dashboard under [Monitoring > Logs](https://manage.auth0.com/#/logs). Alternatively, you can retrieve logs using the [Management API](https://auth0.com/docs/api/management/v2/introduction).\n\nIf you or your users experience unexpected behavior, review tenant logs for the following event codes to learn more:\n\n| Scenario | Event | Error Message |\n| --- | --- | --- |\n| A user is prompted to enroll with a specific factor. However, the requested factor meets one of the following conditions:  <br><br>*   The factor is not enabled in your tenant.<br>*   The factor is not supported by the user's browser.<br>*   The user has already enrolled in the requested factor.<br><br>In this scenario, the user can complete the flow if alternative factors are available. | w   | An MFA enrollment is used in a PostLogin action, but the requested factor ${factor.name} is not properly set up. Enable the requested factor and ensure the user is not already enrolled with it. |\n| A user is prompted to enroll with one or more factors, but the supplied factors cannot be used for enrollment. In this case, the user cannot complete the flow. | mfar | An MFA enrollment is used in a PostLogin action but the requested factors are not properly set up. To perform MFA, enable the requested factors and ensure the user is not already enrolled with them. |\n| A user attempts to enroll in a new factor without completing at least one challenge using an existing enrollment. | mfar | An MFA enrollment was requested but the user is already enrolled in MFA. Challenge with at least one existing factor before enrolling a new one. |\n\n### Troubleshooting checklist\n\nThe following checklist provides additional suggestions for identifying and resolving common issues with customized MFA flows.\n\n1.  The **Customize MFA factors with Actions** toggle must be enabled.\n    \n    *   Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure the toggle in the Additional Settings section is enabled.\n        \n2.  Factors referenced in your Actions must be enabled in your tenant.\n    \n    *   **Review your code**: Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and review your Actions code. Ensure all factors referenced are applicable to your use cases.\n        \n    *   **Review your factors**: Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure all factors referenced in your Actions are enabled.\n        \n3.  Ensure your Actions have been deployed and saved in your Pipeline.\n    \n    1.  Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library). Locate your Action in the list and ensure its status is **Deployed**. If a different status is listed, access your Action, review your code, and click **Deploy** to the top right.\n        \n    2.  Navigate to [Auth0 Dashboard > Actions > Library > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**. Ensure your Action is listed in the flow. If not, access the **Custom tab** of the Add Action panel and drag and drop your Action into your Login flow. Then, select **Apply**.\n        \n4.  Ensure you've upgraded to the latest version of `post-login` Actions.\n    \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your Action. If your Action is out-of-date, you will see a yellow banner prompting you to update the Action. If the banner displays, select **Update**.\n        \n    *   You can also specify the latest version of `post-login` Actions for deployment when using the Deploy CLI. For more information, review [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).",
  "title": "Customize MFA Enrollments for Universal Login",
  "description": "Customize MFA flows using post-login Actions to prompt users to enroll in specific factors.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login",
  "markdown": "# Customize MFA for Classic Login\n\nYou can enable multi-factor authentication in the [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) section. You can customize the MFA pages using basic branding options on the Auth0 Dashboard. For further customization, you can provide your own HTML for the MFA page. When using your own HTML, Classic Login uses the Auth0 MFA Widget with the following limitations:\n\n*   It does not support MFA with email.\n    \n*   If users enrolled in more than one factor, they cannot select which one to use. The MFA widget will ask them to login with the most secure factor.\n    \n*   It does not use Universal Login internationalization features. To learn more, read [Universal Login Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization).\n    \n\n## Customize HTML for the MFA page\n\nTo customize the MFA page, go to [Dashboard > Branding > Universal Login > Multi-factor Authentication](https://manage.auth0.com/#/mfa_page) tab and enable the **Customize MFA Page** toggle. You can then use the text editor to change your HTML, style your page using CSS, and alter the JavaScript used to retrieve custom variables. Once you've made your changes, and make sure to click **Save Changes**.\n\nMFA pages work without customization and Auth0 will update the included scripts as required. However, once you enable customization, you are responsible for updating and maintaining the script (including changing version numbers, such as that for the MFA Widget) since Auth0 can no longer update it automatically.\n\nTo learn more about how to override the text for many areas of the MFA process for Classic Login, read [MFA Theme Language Dictionary](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary). To learn more about the MFA Widget theme options, read [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options).\n\n## Reset page\n\nIf you'd like to revert to an earlier design, you have two options:\n\n*   Revert to the last saved template by clicking **Reset to Last**;\n    \n*   Revert to the default template provided by Auth0 by clicking **Reset to Default**.\n    \n\n## Render enrollment invitations\n\nThere are two different possible scenarios in which the page is rendered. If a user has been directed to this page specifically for enrollment (for instance, from an email with an enrollment link) then the property `ticket` will be available. Otherwise, the property `requestToken` will be available.\n\n## HTML and Liquid syntax\n\nThe hosted page uses Liquid syntax for templating. To learn more, read [Liquid for Designers](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers) on GitHub. The following parameters are available to assist in rendering your page:\n\n*   `userData.email`\n    \n*   `userData.friendlyUserId`\n    \n*   `userData.tenant`\n    \n*   `userData.tenantFriendlyName`\n    \n*   `iconUrl`\n    \n\nMost of the parameters that are used in the MFA Widget need to be passed to Guardian as shown in the default template provided in the customization area. If you need a higher level of customization you could use [auth0-guardian.js](https://github.com/auth0/auth0-guardian.js/tree/master/example).\n\nTo learn more, read [Customize MFA User Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa).\n\n## Learn more\n\n*   [MFA Theme Language Dictionary](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary)\n*   [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options)\n*   [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa)",
  "title": "Customize MFA for Classic Login",
  "description": "Learn how to customize MFA when using Classic Login.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options",
  "markdown": "# MFA Widget Theme Options\n\nWhen using your own HTML for MFA pages with Classic Login, it relies on the Auth0 MFA Widget which has the following limitations:\n\n*   It does not support MFA with email.\n    \n*   If users enrolled more than one factor, they cannot select which one to use, the MFA widget prompts them to login with the most secure factor.\n    \n*   It does not use Universal Login's [internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization) features.\n    \n\nThe theme options for the MFA Widget are namespaced under the `theme` property.\n\n| Option | Description |\n| --- | --- |\n| `icon` | The URL for the imaged used in the header. Default is the Auth0 logo. Recommended height is 58 pixels. |\n| `primaryColor` | Defines the primary color of the MFA widget. Useful when using a custom `icon` to ensure complimentary colors appear. Default is `#ea5323`. |\n\n## Examples\n\n```\nreturn new Auth0MFAWidget({\n\n...\n\n  theme: {\n    icon: 'https://example.com/assets/logo.png',\n    primaryColor: 'blue'\n  },\n  \n...  \n  \n})\n```\n\nSee a [Guardian basic widget example](https://github.com/auth0/auth0-guardian.js/blob/master/example/basic_widget.html) using [auth0-guardian.js](https://github.com/auth0/auth0-guardian.js). See the [readme](https://github.com/auth0/auth0-guardian.js/tree/master/example) for details.\n\n## Learn more\n\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)\n*   [MFA Theme Language Dictionary](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary)",
  "title": "MFA Widget Theme Options",
  "description": "Describes the MFA Widget theme options for customizing the theme properties of the MFA pages.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary",
  "markdown": "# MFA Theme Language Dictionary\n\n```\ndefaults: {\n  iddleHelpUrl: '#',\n  rememberBrowserCheckbox: 'Remember this browser',\n  title: 'Login to {tenantName}'\n},\n\ndownloadApp: {\n  headerText: 'Download Auth0 Guardian for free:',\n  pushEnrollmentAction: 'I\\'ve already downloaded it',\n  smsAndTotpEnrollmentActions: 'I\\'d rather use <sms>SMS</sms> or <ga>Google Authenticator</ga>',\n  pushAndTotpEnrollmentActions: 'I\\'d rather use <push>Guardian</push> or <ga>Google Authenticator</ga>',\n  pushAndSmsEnrollmentActions: 'I\\'d rather use <push>Guardian</push> or <sms>SMS</sms>',\n  totpEnrollmentActions: 'I\\'d rather use <ga>Google Authenticator</ga>',\n  smsEnrollmentActions: 'I\\'d rather use <sms>SMS</sms>',\n  pushEnrollmentActions: 'I\\'d rather use <push>Guardian</push>',\n  iosLabel: 'App Store',\n  iosUrl: 'https://itunes.apple.com/us/app/auth0-guardian/id1093447833?ls=1&mt=8',\n  iosImg: '<svg width=\"27px\" height=\"33px\" viewBox=\"37 22 27 33\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"auth0-mfa-svg-icon\"><g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(37.000000, 22.000000)\"><path d=\"M22.0964148,17.5965957 C22.0594667,13.4821277 25.4586963,11.4804255 25.6141333,11.387234 C23.6890074,8.57489362 20.7051259,8.1906383 19.656563,8.16 C17.1504593,7.89574468 14.7195259,9.66255319 13.4429037,9.66255319 C12.1408,9.66255319 10.1749037,8.18553191 8.05611852,8.22893617 C5.3296,8.27106383 2.7789037,9.85276596 1.37997037,12.3089362 C-1.50708148,17.3170213 0.646103704,24.6765957 3.41211852,28.7246809 C4.79576296,30.707234 6.41256296,32.9208511 8.5288,32.8429787 C10.5991704,32.7574468 11.3725333,31.5204255 13.8709926,31.5204255 C16.3465185,31.5204255 17.0727407,32.8429787 19.2310222,32.7931915 C21.4530074,32.7574468 22.8519407,30.8017021 24.1871704,28.8012766 C25.7861333,26.5289362 26.4282667,24.2910638 26.4537481,24.1761702 C26.4015111,24.1582979 22.1384593,22.5280851 22.0964148,17.5965957 L22.0964148,17.5965957 Z\" fill=\"#FFFFFF\"></path><path d=\"M18.0193778,5.49702128 C19.1329185,4.10170213 19.8948148,2.20340426 19.6833185,0.277021277 C18.0716148,0.348510638 16.0560296,1.39404255 14.8953481,2.7587234 C13.8684444,3.9612766 12.9511111,5.93234043 13.1880889,7.78595745 C14.9985481,7.9212766 16.8574222,6.8706383 18.0193778,5.49702128 L18.0193778,5.49702128 Z\" fill=\"#FFFFFF\"></path></g></svg>',\n  androidLabel: 'Google Play',\n  androidUrl: 'https://play.google.com/store/apps/details?id=com.auth0.guardian',\n  androidImg: '<svg width=\"30px\" height=\"34px\" viewBox=\"35 22 30 34\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"auth0-mfa-svg-icon\"><g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(35.000000, 22.000000)\"><polygon fill=\"#ffffff\" points=\"0.0311829399 32.9244984 0.0311829399 1.02956758 16.5681333 17.6173695\"></polygon><polygon fill=\"#ffffff\" points=\"0.60957618 0.0196753921 17.3854403 16.8471259 22.6948251 11.782715\"></polygon><polygon fill=\"#ffffff\" transform=\"translate(11.025248, 26.014581) scale(1, -1) translate(-11.025248, -26.014581)\" points=\"0.60957618 18.1008562 17.3854403 33.9283067 21.4409189 29.8631472\"></polygon><path d=\"M18.3964257,17.493946 L23.8211074,12.6992188 L28.7813766,15.7894686 C29.3871829,16.1668862 29.4042508,16.7930368 28.8086222,17.1953618 L22.3003286,21.5914726 L18.3964257,17.493946 Z\" fill=\"#ffffff\"></path></g></svg>'\n},\n\npushAuth: {\n  pushSent: {\n    useTotpFallback: 'If you haven\\'t received the notification,<br></br>just <manualInput>enter the code</manualInput> manually.'\n  },\n\n  pushTimeout: {\n    resendAction: 'Resend push notification',\n    timeoutText: 'Didn\\'t receive the push notification?',\n    useRecoveryCode: 'Lost your device? <recovery>Use the recovery code</recovery>',\n    useTotpFallback: '<manualInput>Enter the code manually</manualInput>'\n  }\n},\n\ntotpAuth: {\n  codePlaceholder: 'Enter the 6-digit code',\n  headerText: 'Get a verification code from the Google Authenticator (or similar) app:',\n  useRecoveryCode: 'Lost your device? <recovery>Use the recovery code</recovery>'\n},\n\nsmsAuth: {\n  codePlaceholder: 'Enter the 6-digit code',\n  headerText: 'Enter the 6-digit code we\\'ve just sent to your phone.',\n  useRecoveryCode: 'Lost your device? <recovery>Use the recovery code</recovery>'\n},\n\nguardianTotpAuth: {\n  codePlaceholder: 'Enter the 6-digit code',\n  headerText: 'Get a verification code from the Auth0 Guardian app.'\n},\n\nrecoveryCodeAuth: {\n  codePlaceholder: 'Enter your code here',\n  headerText: 'We will generate a new recovery code<br />once you\\'ve logged in:'\n},\n\npushEnrollment: {\n  headerText: 'Scan this code with Auth0 Guardian:'\n},\n\nenrollmentCongrats: {\n  congrats: 'Congratulations, you are all set.<br />In the future when logging in you\\'ll want your device handy.',\n  continueButtonText: 'Continue'\n},\n\nreportRecoveryCode: {\n  headerText: 'In the event that you need to login without your device you\\'ll need a recovery code. Take a note and keep this somewhere safe:',\n  confirmationLabel: 'I have safely recorded this code'\n},\n\ngeneralError: {\n  errorsRecoveryHelp: {\n    default: 'Looks like something went wrong.<br />Please try logging in again from the application.',\n\n    globalTransactionExpired: 'The login was not successful.<br />Please try again.',\n\n    // Auth0 Server Errors\n    guardianInvalidNonce: 'Please try logging in again from the application.',\n    guardianInvalidToken: 'Please try logging in again from the application.',\n    invalidLoginTokenStatus: 'Please try logging in again from the application.',\n    loginTokenInvalidSignature: 'Please try logging in again from the application.',\n    loginTokenTransactionExpired: 'Please try logging in again from the application.'\n  }\n},\n\nsmsEnrollmentConfirm: {\n  codePlaceholder: 'Enter the 6-digit code',\n  headerText: 'In order to confirm enrollment we need to confirm your phone. Please enter the received code.'\n},\n\ntotpEnrollment: {\n  codePlaceholder: 'Enter your passcode here',\n  headerText: 'Scan this QR code with Google Authenticator (or similar) app:',\n  troubleScanning: 'Trouble Scanning ?'\n},\n\ntotpEnrollmentCode: {\n  codePlaceholder: 'Enter your passcode here',\n  headerText: 'Manually enter the following code into your preferred authenticator app and then enter the provided one-time code below.',\n  copyCodeButton: 'Copy code'\n},\n\nsmsEnrollmentAddPhoneNumber: {\n  headerText: 'Please enter your phone<br />in order to enroll.',\n  phoneNumberLabel: 'A code will be sent to this number:',\n  phoneNumberPlaceholder: 'Your phone number'\n  // countryCodes: { 'US': 'Translation of United States', ... '<country code>': '<translation>' }\n},\n\nauthCongrats: {\n  congrats: 'We have verified your identity. Redirecting...',\n  congratsNoRedirect: 'We have verified your identity.',\n  continueButtonText: 'Continue'\n},\n\nerrorMessages: {\n  alreadyEnrolled: 'You are already enrolled, cannot enroll again',\n  authMethodDisabled: 'The specified authentication method is disabled',\n  connectionError: 'Looks like we cannot contact our server. Please check your internet connection and retry.',\n  default: 'Looks like something went wrong. Please retry.',\n  defaultRequest: 'Looks like we found a problem contacting our server. Please retry.',\n  enrollmentConflict: 'Seems that you have already enrolled. Try logging in again from the application.',\n  enrollmentMethodDisabled: 'The specified enrollment method is disabled',\n  enrollmentNotFound: 'We couldn\\'t find your enrollment. You\\'ve probably started enrollment from another device. Finish it there or try logging in again from the application.',\n  enrollmentTransactionNotFound: 'The mfa enrollment transaction is not active or has expired. Please try again.',\n  errorSendingPushNotification: 'We found an error sending your notification. Please try again.',\n  errorSendingPushNotificationManualFallback: 'We could not send the push. Please enter the code manually.',\n  errorSendingSms: 'We found an error sending your code. Please try again in a few seconds.',\n  errorSendingSmsManualFallback: 'We could not send the sms. Please try the recovery code.',\n  featureDisabled: 'This module is currently disabled.',\n  featureDisabledByAdmin: 'This module was disabled by the admin.',\n  fieldRequired: 'Please fill out required field.',\n  globalTransactionExpired: 'Your login attempt has timed out.',\n  guardianInvalidNonce: 'There was a problem authenticating your request origin. Have you started too many parallel logins?',\n  guardianInvalidToken: 'There was a problem validating authentication request format.',\n  insufficientScope: 'Seems that you are not authorized to perform this action.',\n  invalidBearerFormat: 'Seems that you are not authorized to perform this action.',\n  invalidLoginTokenStatus: 'Unexpected state validating your request.',\n  invalidOtp: 'Seems that your code is not valid, please check and retry.',\n  invalidOtpFormat: 'OTP Code must have 6 numeric characters',\n  invalidPhoneNumber: 'Seems that your phone number is not valid. Please check and retry.',\n  invalidRecoveryCode: 'Seems that your recovery code is not valid. Please check and try again.',\n  invalidRecoveryCodeFormat: 'Recovery code must have 24 alphanumeric characters',\n  invalidToken: 'Seems that you are not authorized to perform this action.',\n  loginRejected: 'Auth has been rejected. Try again.',\n  loginTokenInvalidSignature: 'We cannot verify who seems to be the issuer for this request',\n  loginTokenTransactionExpired: 'Your authentication request is expired. Is your connection slow?',\n  loginTransactionNotFound: 'Seems that your device has taken too long to login. Please try again.',\n  noMethodAvailable: 'There is currently no authentication method available.',\n  noPublicKeyAvailable: 'We cannot verify your identity. Contact tenant admin.',\n  pnEndpointDisabled: 'Seems that we cannot deliver messages to your cell phone. Please try again.',\n  pushNotificationNotConfigured: 'Seems that enrollment was not finished. Please try logging in again from the application.',\n  pushNotificationWrongCredentials: 'Seems that your device credentials are outdated. Please re-enroll your device or wait for them to be updated.',\n  smsNotConfigured: 'You cannot use this module because you\\'ve enrolled with a different one.',\n  // tenant_not_found | The tenant associated cannot be found. Should not normally happen at least that you delete the tenant\n  tooManyPn: 'You have exceeded the amount of push notifications per minute. Please wait and try again.',\n  tooManyPnPerTenant: 'There are too many push requests right now. Wait a few minutes and try again.',\n  tooManySms: 'You have exceeded the amount of SMSs per hour. Wait a few minutes and try again.',\n  tooManySmsPerTenant: 'There are too many SMSs right now.  Wait a few minutes and try again.'\n  // | transaction_expired | The transaction has already expired |\n},\n\nsuccessMessages: {\n  auth: 'We have successfully verified your identity. Redirecting...',\n  pushSent: 'We\\'ve sent a push to: {enrollmentName}',\n  smsSent: 'We\\'ve sent an sms to: {phoneNumber}'\n},\n\ninfoMessages: {\n  iddle: 'Can we help you?<br></br><iddleHelp>Click here to learn more</iddleHelp>'\n}\n```",
  "title": "MFA Theme Language Dictionary",
  "description": "Describes the MFA hosted page configuration options for customizing the theme properties of the MFA pages.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/classic-login/customization-classic",
  "markdown": "# Customize Classic Login Pages\n\n[Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience) is an Auth0-hosted login experience that relies on JavaScript for page customization.\n\nFrom the Auth0 Dashboard, you can configure basic customization options that apply to all login pages. For advanced customization, you can directly modify the HTML template of one or more pages.\n\nAdditionally, you can manage your page content using the [version control syste](https://auth0.com/docs/customize/login-pages/classic-login/version-control) of your choice.\n\n## Basic Customization\n\nYou can configure the following options from the Auth0 Dashboard under [Branding > Universal Login > Settings tab](https://manage.auth0.com/#/login_settings):\n\n*   Company Logo (recommended size: 150 x 150 pixels)\n    \n*   Primary Color\n    \n*   Background Color\n    \n\nBy default, these settings affect all Classic Login pages, such as the login screen or password reset page. If you directly modify the HTML template of one or more pages and edit any attributes related to these options, those attributes will supersede these settings.\n\n## Advanced Customization\n\nFor further customization, you can directly modify the HTML template of the following pages:\n\n*   Login (see below)\n    \n*   [Password reset](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page)\n    \n*   [Multi-factor authentication](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)\n    \n\n### Responsibility for updates\n\n**When you enable customization for a specific page, you assume responsibility for maintaining that page**, as it will no longer receive automatic updates from Auth0. Such maintenance includes updating the version numbers of any included Auth0 SDKs or widgets.\n\nAs sensitive security-related information often flows through the login page, introducing cross-site scripting (XSS) vulnerabilities is a point of concern. Additionally, if your organization uses [home realm discovery](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/authentication#home-realm-discovery) in conjunction with Classic Login, a list of available connections is publicly visible in the Auth0.setClient property. Considering this, Auth0 encourages you to exercise caution when using third-party JavaScript on your login page.\n\n### Enable page customization\n\nTo enable customization for a specific page, follow the steps below:\n\n1.  On the Auth0 Dashboard, navigate to [Branding > Universal Login](https://manage.auth0.com/#/login_settings).\n    \n2.  Select one of the following tabs:\n    \n    *   **Login**\n        \n    *   **Password Reset**\n        \n    *   **Multi-Factor Authentication**\n        \n3.  Enable the **Customize Page** toggle located at the top of the tab.\n    \n4.  Repeat steps 2 and 3 as needed.\n    \n\nAfter enabling customization for a page, you can modify its HTML template through the code editor located below the toggle.\n\n### Customize the Login page\n\nTo customize the login page template, you must first choose a base template to work from.\n\n1.  On the Auth0 Dashboard, navigate to [Branding > Universal Login > Login tab](https://manage.auth0.com/#/login_page).\n    \n2.  Enable the **Customize Login Page** toggle.\n    \n3.  Above the HTML code editor, select an option from the **Default Templates** menu.\n    \n\nThe available templates use the following libraries:\n\n*   [Lock](https://auth0.com/docs/libraries/lock)\n    \n*   [Lock (Passwordless Mode)](https://auth0.com/docs/libraries/lock)\n    \n*   [Auth0.js](https://auth0.com/docs/libraries/auth0js)\n    \n*   [Authentication API](https://auth0.com/docs/api/authentication)\n    \n\nYou can use these libraries within Classic Login or embed them directly into an application. To better understand how you can customize your login experience, review the documentation for your preferred library.\n\n#### Lock template\n\nIf you plan on using the default login page and require only minimal changes, you can use the Lock template to modify the behavior of the Lock widget on the login page.\n\nFor example, you can configure the Lock widget to:\n\n*   Direct users to the signup page instead of the login page by default\n    \n*   Customize the login page with different colors, text, or default languages\n    \n*   Present users with only one or more specific login methods\n    \n\nTo learn more about customizing the Lock widget, review the [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration).\n\n#### Custom Login Form template\n\nIf you want to significantly modify the login page, you can use the Custom Login Form template as a guide. This template shows you how to get the values you need with the Auth0.js SDK. You can then modify the style and layout of the login page as desired. Any CSS customization **must** be inline, as you cannot host a separate CSS file in your Auth0 tenant.\n\n## Learn more\n\n*   [Classic Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience)\n*   [Customize Classic Login Pages with Lock or SDK](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk)\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)",
  "title": "Customize Classic Login Pages",
  "description": "Learn how to customize the login page for the Classic Login experience.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk",
  "markdown": "# Customize Classic Login Pages with Lock or SDK\n\nClassic Login is an Auth0-hosted login experience that relies on JavaScript for [advanced customization](https://auth0.com/docs/customize/login-pages/classic-login/customization-classic). Implementing Classic Login is less complex than embedding the authentication process directly in your app, and it can help prevent the dangers of cross-origin authentication.\n\nBy default, the Classic Login page uses the Lock widget for user authentication. However, you can also customize templates for Lock in Passwordless Mode or a custom UI built with the Auth0.js SDK.\n\nTo customize your Classic Login page templates, you must first enable advanced customization. To do so, follow the steps below:\n\n1.  On the Auth0 Dashboard, navigate to [Branding > Universal Login > Login tab](https://manage.auth0.com/#/login_page).\n    \n2.  Enable the **Customize Login Page** toggle.\n    \n3.  Above the HTML code editor, select the Default Templates menu and choose the desired option.\n    \n\nThe templates available include:\n\n*   Lock\n    \n*   Lock (passwordless)\n    \n*   Custom Login Form\n    \n\nBoth Lock templates allow you to customize the Lock widget used for authentication. The Lock widget provides a standard set of behaviors and a customizable user interface. Alternatively, you can use the Custom Login Form template to customize your login page with the [Auth0 SDK for Web](https://auth0.com/docs/libraries/auth0js) or [Authentication API](https://auth0.com/docs/api/authentication).\n\nAuth0 SDKs are client-side libraries that **do not** offer a user interface but allow for expanded customization of the behavior and appearance of the login page. The Authentication API provides direct integration without the use of Auth0 SDKs.\n\nThe template you use to customize your login page will depend on the unique needs of your application. The sections below provide an overview of each option: Lock, Auth0 SDKs, or the Authentication API.\n\n## Using the Lock widget\n\n[Lock](https://auth0.com/docs/libraries/lock) is a login form that makes it easy for your users to authenticate using a selected connection. Lock automatically handles most of the details involved in creating and authenticating users.\n\nWith Lock, you will be implementing a UI that:\n\n*   Is robust and provides an excellent user experience on any device with any resolution\n    \n*   Has a simple design that fits in with most websites with just a few tweaks to its custom color\n    \n*   Adapts to your configuration, displaying the appropriate form controls for each available connection and only those that are allowed (such as signup or password reset)\n    \n*   Selects the correct connection automatically. You may specify a desired default behavior for ambiguous cases\n    \n*   Remembers the last used connection for a given user\n    \n*   Automatically accommodates internationalization\n    \n*   Provides instant password policy checking at signup\n    \n\nAlthough you cannot alter Lock's behavior significantly, you can configure several basic options to make Lock look and behave differently.\n\nConsider using Lock if:\n\n*   You like the structure, look, and feel of the widget.\n    \n*   You prefer a streamlined implementation of Classic Login with a ready-made responsive UI.\n    \n*   Your process includes many of the use cases that Lock handles out of the box:\n    \n    *   Enterprise logins\n        \n    *   Databases with password policies\n        \n    *   User signup and password reset\n        \n    *   Authentication using social providers\n        \n    *   Avatars\n        \n\n### Sample login customization scripts\n\n#### Customize the application logo\n\nThe example script below customizes the logo for each application, or you can set a default logo. The minimum recommended resolution is 200 pixels (width) by 200 pixels (height). Add the `logouturl` configuration to the `<scripts>` block:\n\n```\nvar logourl = \"https://example.com/defaultlogo1.png\"; //set default logo\nif(config.clientID === \"HUXwC72R3qr9JJo9ImPsdzJbtY8aD5kS\")\n{\n    logourl = \"https://example.com/defaultlogo2.png\";\n}\ntheme: {\n    logo: logourl,\n    primaryColor: colors.primary ? colors.primary : 'green'\n},\n```\n\n#### Customize the signup terms\n\nThe example below customizes the signup terms for your application. You can add custom language to display when users signup.\n\n```\nvar languageDictionary;\n\nlanguageDictionary = {\n    signUpTerms: \"I agree to the <a href='https://my-app-url.com/terms' target='_blank'>terms of service</a> and <a href='https://my-app-url.com/privacy' target='_blank'>privacy policy</a>.\"\n};\n```\n\n## Using the Auth0 SDK for Web\n\nIf the requirements of your app cannot be met by the standardized behavior of Lock, or if you have a complex custom authentication process, a custom user interface is needed. You may also prefer this option if you have an existing user interface that you wish to use.\n\nWith [Auth0's library for Web](https://auth0.com/docs/libraries/auth0js), you can customize the behavior and flow of the process used to trigger signup and authentication. You can also directly use the Authentication API, without any wrapper at all, if you so choose.\n\nUnlike with Lock, neither of these options includes a user interface. You will have complete control over the user experience for signup and authentication flow, and for the UI aspects of layout, look and feel, branding, internationalization, RTL support, and more.\n\nConsider implementing a custom user interface in conjunction with an Auth0 library or the Authentication API for your app if:\n\n*   You have strict requirements for the appearance of the user interface\n    \n*   You have strict requirements for file sizes - the Auth0 libraries are significantly smaller than Lock, and if you instead choose to deal with the API directly, that would not require any additional weight.\n    \n*   You are comfortable with HTML, CSS, and JavaScript - you'll be creating your own UI\n    \n*   You only need to handle username/password and social provider authentication\n    \n*   You have multiple database or Active Directory Connections\n    \n\nYou can also see specific examples of the usage of both Lock and Auth0 SDKs for a wide variety of programming languages and platforms in our [Quickstarts](https://auth0.com/docs/quickstart). These guides may further assist you in your decision about which to use for your specific app needs.\n\n## Learn more\n\n*   [Classic Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience)\n*   [Add Bot Detection to Custom Login Pages](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-custom-login-pages)\n*   [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors)",
  "title": "Customize Classic Login Pages with Lock or SDK",
  "description": "Learn how to customize the Classic Login page with Lock or a custom UI built on top of an Auth0 SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-android/lock-android-passwordless-with-magic-link",
  "markdown": "# Lock.Android: Passwordless with Magic Link\n\nIn order to avoid asking the user to input the one-time password sent for passwordless authentication in Android apps, we introduced the ability to send a link that the user can tap to login without any manual input involved.\n\nThese links include the same **code** that would be used in the traditional passwordless flow, but with the correct configuration, these links will open right into your application.\n\n## Auth0 Dashboard Configuration\n\nGo to your [application settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) and click **Show Advanced Settings** at the bottom of the page. Then in the \"Device Settings\" tab, you will need to provide both the Android Application's Package Name and certificate Key Hash.\n\n*   **App Package Name**: This is the package name, as declared in the app's manifest. It's also available in the `app/build.gradle` file as the `applicationId` attribute. If both values are not the same, use the one for the `applicationId`. An example would be `com.example.android.myapp`\n    \n*   **Key Hashes**: These are the SHA256 fingerprints of our Android app’s signing certificates. You can include multiple of them by separating them with commas. Both the release and debug keystore fingerprints can be specified here. The section below explains how to obtain them. An example would be `DE:1A:5B:75:27:AA:48:D5:A6:72:2F:76:43:95:9B:79:C6:86:1A:5B:75:27:AA:48:D5:A6:73:FE`.\n    \n\nAfter you set the values make sure to click **Save Changes**.\n\n### Getting your Signing Certificates Fingerprint\n\nUse the following command to generate the fingerprint via the Java keytool CLI:\n\n`keytool -list -v -keystore my-release-key.keystore`\n\nor obtain the default debug key:\n\n`keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android`\n\nThe value required by the dashboard is the one listed as \"SHA256\". You can read more about Keystores in this [official article](https://developer.android.com/studio/publish/app-signing).\n\n### Enable the Email Connection\n\nPasswordless using Magic Link works only with the passwordless connection of type \"email\". Go to Dashboard > [Authentication](https://manage.auth0.com/#/applications/authentication) for Passwordless connections and click on **Email**. A popup will open and the HTML + Liquid email template will become editable. Verify that the body contains a conditional like this:\n\n```\n{% if send == 'link' or send == 'link_ios' or send == 'link_android' %}\nYour verification link is: {{ link }}\n{% elsif send == 'code' %}\nYour verification code is: {{ code }}\n{% endif %}\n```\n\n## Configuring the SDK\n\nNow that the Auth0 application is configured follow the instructions and set up PasswordlessLock with `Lock.Android` as seen in the [passwordless docs](https://auth0.com/docs/libraries/lock-android/v2/passwordless).\n\n### SDK usage\n\nLock Passwordless authenticates users by sending them an Email with a one-time password, which in this case will be a LINK instead of a code. If you have followed the guide for Passwordless classic, you'd only need to remove the `useCode()` call and replace it with `useLink()`.\n\nFinally, launch the `PasswordlessLock` widget from inside your activity.\n\n```\nstartActivity(lock.newIntent(this))\n```\n\nAfter requesting the LINK, the next screen will indicate that in order to log in, the user should tap on it. In case this is not possible, the user can still input the code that will be visible after clicking the link from the received email.\n\n## Optional: Use Android App Links\n\nThe Lock library is ready to be used with App Links. This is a feature available in Android 6.0 (API level 23) and higher, that allows an app to designate itself as the default handler of a given type of link, without showing the disambiguation dialog that asks the user whether to use the Browser or your app to open the link.\n\nThis works as long as the user has not already chosen a default app to handle that URI pattern in the Android device settings.\n\nAutomatic handling of links requires the cooperation of your app and the Auth0 website. The app must declare the association with the website and request that the system verifies it. The website must, in turn, provide that verification by publishing a [Digital Asset Links](https://developers.google.com/digital-asset-links/) file.\n\nAuth0 will generate the [Digital Asset Links](https://developers.google.com/digital-asset-links/) file automatically for you when you configure the App Package Name and Key Hash as shown before. If you've followed all the steps in this article, the file should be available and will be verified the next time your android application is installed.\n\nYou could find more information about App Links in the [Android docs](http://developer.android.com/training/app-links/index.html).",
  "title": "Lock.Android: Passwordless with Magic Link",
  "description": "Passwordless with Magic Link with Lock.Android",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-web-apps",
  "markdown": "# Configure Step-up Authentication for Web Apps\n\nWith step-up authentication, applications that allow access to different types of resources can require users to authenticate with a stronger mechanism to access sensitive information or perform certain transactions.\n\nFor instance, a user may be allowed to access views with sensitive data or reset their password only after confirming their identity using multi-factor authentication (MFA).\n\nTo accomplish step-up authentication for your web app, you will create an Action that challenges the user to authenticate with MFA when the web app asks for it, check the ID Token claims for MFA if the user tries to access a restricted page, and then challenge the user if MFA is not included in the claim.\n\n## Validate ID tokens for MFA\n\nWhen a user logs in, you get an [ID token](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens) that contains information relevant to the user's session in the form of claims. The relevant claim is `amr` (authentication methods reference) which is a JSON array of strings that indicates the authentication method used during login. It must be present in the ID token's payload and must contain the value `mfa`.\n\nIts values may include any of the pre-defined [Authentication Method Reference Values](https://tools.ietf.org/html/rfc8176). Because it can contain claims other than `mfa`, when validating you must both test for its existence and examine its contents for a value of `mfa`.\n\nIf a user attempts to access a restricted page and the token shows that the user has not authenticated with MFA, then you can retrigger authentication, which you have configured to trigger MFA using an Action. Once the user provides the second factor, a new ID token that contains the `amr` claim is generated and sent to the app.\n\n1.  [Get the ID token](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens).\n    \n2.  Verify the token's signature, which is used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way.\n    \n3.  Validate the following claims:\n    \n    | Claim | Description |\n    | --- | --- |\n    | `exp` | Token expiration |\n    | `iss` | Token issuer |\n    | `aud` | Intended recipient of the token |\n    | `amr` | If `amr` does not exist in the payload or does not contain the value `mfa`, the user did not log in with MFA. If `amr` exists in the payload and contains the value `mfa`, then the user did log in with MFA. |\n    \n\n#### AMR claim exceptions\n\nThe `amr` claim is required except in the following use cases:\n\n1.  In hosted login flows, only after the user successfully passes an MFA challenge, the `amr` claim is injected into the ID token. If the app uses silent authentication or Refresh Tokens for newly issued ID tokens, the `amr` claim will not be present because the user previously completed login with MFA.\n    \n2.  MFA API issued tokens do not contain the `amr` claim. The `amr` claim flags the authentication methods used when the user receives the ID Token. In the MFA API authentication process, the application controls the authentication flow and can enforce MFA as needed.\n    \n\nIn the examples below, you can compare the potential values included in an ID token's payload when a user has authenticated with MFA versus when they have not.\n\n### Example: Values with MFA\n\nto configure this snippet with your account\n\n```\n{\n    \"iss\": \"https://{yourDomain}/\",\n    \"sub\": \"auth0|1a2b3c4d5e6f7g8h9i\",\n    \"aud\": \"{yourClientId}\",\n    \"iat\": 1522838054,\n    \"exp\": 1522874054,\n    \"acr\": \"http://schemas.openid.net/pape/policies/2007/06/multi-factor\",\n    \"amr\": [\n        \"mfa\"\n    ]\n}\n```\n\n### Example: Values without MFA\n\n```\n{\n    \"iss\": \"https://{yourDomain}/\",\n    \"sub\": \"auth0|1a2b3c4d5e6f7g8h9i\",\n    \"aud\": \"{yourClientId}\",\n    \"iat\": 1522838054,\n    \"exp\": 1522874054\n}\n```\n\n## Scenario: Salary data with push notifications\n\nIn the following scenario, a web app authenticates a user with a username and password. Some users want to access a specific screen that displays salary data, so they must authenticate with Guardian push factor.\n\n### Prerequisites\n\nFor this scenario, you must configure the following items in the Dashboard:\n\n*   [Register a web app](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps).\n    \n*   [Create a database connection](https://manage.auth0.com/#/connections/database).\n    \n*   [Enable MFA](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa) to use push notifications.\n    \n\n### Create an Action\n\nCreate an Action that challenges the user to authenticate with MFA when the web app requests it. Go to [Dashboard > Actions > Flows](https://manage.auth0.com/#/actions/flows), and create an Action that contains the following content:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n const CLIENTS_WITH_MFA = ['REPLACE_WITH_YOUR_CLIENT_ID'];\n // run only for the specified clients\n if (CLIENTS_WITH_MFA.includes(event.client.client_id)) {\n // ask for MFA only if the web app said so in the authentication request\n if (event.transaction?.acr_values.includes('http://schemas.openid.net/pape/policies/2007/06/multi-factor')) {\n api.multifactor.enable('any', { allowRememberBrowser: false });\n }\n }\n}\n```\n\n*   The `CLIENTS_WITH_MFA` variable contains the client IDs of the applications you want this Action to apply to. You can remove this (and the `if` conditional that follows) if you don't need it.\n    \n*   The `event.transaction.acr_values` property is an array of strings that contains the authentication context class reference(s) (`acr`). This is an optional property that only exists when the application includes it in the authentication request to the Authorization Server. In this example, our web app will include it in the authentication request, but only when a user who has not already authenticated with MFA tries to access salary information. When our web app includes it, it will set a value of `http://schemas.openid.net/pape/policies/2007/06/multi-factor`, which indicates that we want the Authorization Server to require MFA, and the `api.multifactor` property value that we set in our code will challenge the user for MFA using any of the available methods that have been configured in the tenant. To learn more about the `api.multifactor.enable()` method, read [Action Triggers: post-login API object](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset/api-object).\n    \n*   The `http://schemas.openid.net/pape/policies/2007/06/multi-factor` policy defines an authentication mechanism where the end user authenticates to the OpenID Provider by providing more than one authentication factor, or MFA. To learn more, read [OpenID Provider Authentication Policy Extension 1.0](https://openid.net/specs/openid-provider-authentication-policy-extension-1_0.html).\n    \n\n### Configure app\n\nConfigure the app to check that the user has authenticated using MFA when a user tries to access the restricted salary information page. (When a user has authenticated with MFA, the ID token claims contain the `amr` claim with a value of `mfa`.) If the user has already authenticated with MFA, then the web app will display the restricted page; otherwise, the web app will send a new authentication request that includes the `acr_values` parameter with a value of: `http://schemas.openid.net/pape/policies/2007/06/multi-factor` which will trigger the Action.\n\nThe web app in this scenario uses the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) to authenticate, so the request is as follows:\n\n```\nhttps://{yourDomain}/authorize?\n        audience=https://{yourDomain}/userinfo&\n        scope=openid&\n        response_type=code&\n        client_id={yourClientId}&\n        redirect_uri={https://yourApp/callback}&\n        state={yourOpaqueValue}&\n        acr_values=http://schemas.openid.net/pape/policies/2007/06/multi-factor\n```\n\nOnce the user authenticates with MFA, the web app receives the authorization code, which must be exchanged for the new ID token, which should now contain the `amr` claim with a value of `mfa`. To learn how to exchange the code for an ID token, read [Add Login Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow).\n\n### Validate ID token\n\nIn this scenario, perform the validations using the [JSON Web Token Sample Code](https://github.com/auth0/node-jsonwebtoken), which verifies the token's signature (`jwt.verify`), decodes the token, checks whether the payload contains `amr`, and if so, logs the results in the console.\n\n```\nconst AUTH0_CLIENT_SECRET = '{yourClientSecret}';\nconst jwt = require('jsonwebtoken');\n\njwt.verify(id_token, AUTH0_CLIENT_SECRET, { algorithms: ['HS256'] }, function(err, decoded) {\n  if (err) {\n    console.log('invalid token');\n    return;\n  }\n\n  if (Array.isArray(decoded.amr) && decoded.amr.indexOf('mfa') >= 0) {\n    console.log('You used mfa');\n    return;\n  }\n\n  console.log('you are not using mfa');\n});\n```\n\n## Learn more\n\n*   [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens)\n*   [Rule Use Cases](https://auth0.com/docs/rules/use-cases)\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [Configure Step-up Authentication for APIs](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-apis)",
  "title": "Configure Step-up Authentication for Web Apps",
  "description": "Learn how to check if a user has logged in your web app with Multi-factor Authentication (MFA) by examining their ID Token.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/dashboard/activity",
  "markdown": "# About the Activity Page\n\nThe Activity page provides a summary of key data about your Auth0 tenant, including information on active users, failed logins, and more.\n\n## Things to know\n\n*   Viewing a tenant's Activity page requires an account with an administrator role.\n    \n*   The **Support Access** role has limited access to the tenant's Activity page.\n    \n*   To ensure data is consistent, the current date cannot be selected in the date picker and data may take up to 12-24 hours to display.\n    \n\n## Metrics\n\nHere’s what you will see on your tenant's Activity page.\n\n### Totals\n\nAt the top of the page, you'll see your tenant's total number of users, applications, APIs, and connections.\n\n![Example Dashboard Activity page tenant totals](https://images.ctfassets.net/cdy7uua7fh8z/4wcwZDIhDQVD0vhLxg6k49/b5d36a70ad9a8bdbe8e83b984053ee99/dashboard-activity-totals.png)\n\n### Daily Active Users\n\nThe number of daily unique users with successful authentication or authorization activity. You can see the number of unique users for each day by hovering your mouse over a point in the graph.\n\n![Example Dashboard Activity page Active Users line graph](https://images.ctfassets.net/cdy7uua7fh8z/Ogdesg0DscG5NhPAQ4zS0/6dbcf4e3a114eeb7757c409d6b6d6f81/active_users.png)\n\n### User Retention\n\nThe percentage of users that were active during the given time frame, calculated from the number of active users out of the total number of users on the tenant.\n\n![Example Dashboard Activity page User Retention line graph](https://images.ctfassets.net/cdy7uua7fh8z/4Fm2nJoZl9yOpw6Siy5Vem/09cc8adb31ad0905456228551c0a9bc6/user_retention.png)\n\n### Signups\n\nThe number of successful user signups.\n\n![Example Dashboard Activity page Sign ups line graph](https://images.ctfassets.net/cdy7uua7fh8z/y9guAxVBfFaaKIEGwCGRI/9b1a933e2da2d7a4cf168892b5fbdc35/sign_ups.png)\n\n### Failed Logins\n\nThe number of failed user logins (the `f` log event type) over the given time period.\n\n![Example Dashboard Activity page Failed Logins line graph](https://images.ctfassets.net/cdy7uua7fh8z/35WccBqKhEd5z0uT4axrnZ/c964fdf97e1a33d298fa8906a77bef9c/failed_logins.png)\n\n## Compare to last period\n\nWhen **Compare to last period** is enabled:\n\n*   The percentage difference is included in the graph. Positive changes are colored green while negative changes are colored red.\n    \n*   Dotted lines are the last time period and solid lines are the current time period.\n    \n\n![Example of mouse hovering over the Dashboard Activity page Active Users line graph](https://images.ctfassets.net/cdy7uua7fh8z/3wbi2SCiWbI5JisOxMLD2Z/d6c800b50b9b3fcf8a3da004126fc6e6/hover.png)\n\n## View data by time frame\n\nYou can view data for a given time frame by using the datepicker next to the **Compare to last period** checkbox. There are builtin date ranges for the last 7/14/30/60 days, or you can provide the **From** and **To** dates for a custom range.\n\n![Example of Dashboard Activity page datepicker form](https://images.ctfassets.net/cdy7uua7fh8z/4ctRxO704Ufg3q5xn8riCi/e3b174f34a4b9e12f9321a975a10f6c5/date_picker.png)",
  "title": "About the Activity Page ",
  "description": "Learn about the metrics on the Activity page for your Auth0 tenant, including information on active users, failed logins, and more.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/light-and-dark-themes",
  "markdown": "# Light and Dark themes\n\nAuth0 customers can use light mode or dark mode in their tenant Dashboard. You can also set your Dashboard to use the same settings as your local system environment.\n\nThere are two ways to change your Dashboard theme:\n\n1.  Click the profile dropdown menu at the top-right of your Dashboard.\n    \n2.  Use the menu to switch between themes.\n    \n\n![Where to find the Dark mode and Light mode toggle](https://images.ctfassets.net/cdy7uua7fh8z/1BImxFvHXoULQVTkqCsQL0/f69999cd1c2a0c2a6f7ab9ffd8d1b376/Light_mode_dropdown.png)\n\nYou may also click **Your Profile** in the same dropdown and scroll to the bottom, where you can choose from the three themes. \n\n![Where you can change your theme in the Profile section](https://images.ctfassets.net/cdy7uua7fh8z/231W9kPYTeEABOsV3rOZxF/1c451d4942d86432a0e701f497c32f24/Light_mode_profile_section.png)",
  "title": "Light and Dark themes",
  "description": "How to toggle between light and dark themes for your Dashboard ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/profile-management",
  "markdown": "# Profile Management (B2B)\n\nAt some point, you may need to change the information stored in a user’s [profile](https://auth0.com/docs/videos/get-started-series/learn-user-profiles). A user’s profile (also known as the user’s account) is stored in Auth0, and changes to the information it contains may need to happen for a number of different reasons:\n\n*   Self-served information updates\n    \n*   Mandatory updates concerning your organizations T's & C’s\n    \n*   Changes due to regulatory compliance\n    \n\nAn [Identity Provider](https://auth0.com/docs/connections) populates a user’s profile using data supplied during the login process, and this is referred to as the [Normalized User Profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles).\n\nBy default, there is one user profile created for each user identity, and there are a number of things to consider:\n\n*   What should you do if you need to store information to help customize a user’s experience?\n    \n*   What if you need to store user information that didn’t originate from an identity provider?\n    \n*   Why would you need to store user-related information that a user cannot modify?\n    \n*   What do you do if you need to store user-related information that a user cannot modify?\n    \n*   What happens if a user forgets their password?\n    \n*   What should a user do if they want to change their password?\n    \n*   How do you provide an administrator from a third-party organization with the ability to manage their users?\n    \n\nAuth0 provides for the storage of metadata against a user’s profile, which allows for the capture of additional information, such as preference for language and/or accessibility in order to enhance the user experience. Metadata can be used to store both information that a user can change, and also information they can’t; the latter giving you the capability of associating, for example, a user profile with records in your existing systems without modifying existing implementation.\n\nFor users who forget their passwords or who are allowed to change their password via some existing self-service mechanism (or self-service mechanism you have planned), you can leverage Auth0-provided [Password Reset](#password-reset) functionality. This can be integrated with your existing implementation and comes already incorporated with any out-of-box Auth0 UI widgets including [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n\nYou’ll also want to make sure that you are working with a [verified user account](#account-verification) at all times. Auth0 provides out-of-box mechanisms for doing that too. You should also consider [regulatory compliance](https://auth0.com/docs/secure/data-privacy-and-compliance) such as ([GDPR](https://eugdpr.org/) which has very specific requirements when it comes to protecting EU citizens from privacy and data breaches.\n\nThough Auth0 doesn’t currently provide a centralized profile management portal out-of-the-box, for the purpose of self-serviced profile management, you can use the Auth0 Management API to build your own or utilize an already built UI. See our Auth0 [community guidance](https://community.auth0.com/t/how-to-allow-the-end-user-to-update-their-own-profile-information/6228) which describes the Management API endpoint. All calls to the Management API will require use of an [Access Token](https://auth0.com/docs/secure/tokens/access-tokens).\n\nAlternatively, you can use the Auth0 Dashboard to [manage aspects of a user’s profile](https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-dashboard). Managing a user’s profile via the Auth0 Dashboard is more of an administrative provision and **should not** be used for self-serviced profile management in a production environment. However, the interface provided by the Dashboard can be extremely useful during development as it provides a quick and simple way of manipulating a user’s profile information.\n\nIf you need to provide a way for your customers to have an administrator manage their own users when they are storing those credentials in your system, you can either build something yourself or use an Auth0 Extension. See [Admin Portal](#admin-portal) for more information.\n\n## Metadata\n\nIn addition to the Normalized User Profile information, [Metadata](https://auth0.com/docs/manage-users/user-accounts/metadata) can be stored in an Auth0 user profile. Metadata provides a way to store information that did not originate from an identity provider, or a way to store information that overrides what an identity provider supplies.\n\n### Best Practice\n\nUse of Metadata should follow Auth0 [user data storage best practices](https://auth0.com/docs/best-practices/user-data-storage-best-practices#metadata). Metadata storage is not designed to be a general purpose data store, and you should still use your own external storage facility when possible. Metadata size and complexity should also be kept to a minimum, and the Auth0 Management API has a strict set of guidance when it comes to updating and/or deleting metadata associated with a user.\n\nYou can manipulate metadata via both the Auth0 Management API and the Auth0 Authentication API. As is the case when managing the Normalized User Profile, calls to the Management API for manipulating Metadata requires use of an [Access Token](https://auth0.com/docs/api/management/v2/tokens).\n\n### User metadata\n\nUser metadata (also referred to as `user_metadata`) is information that can be stored against a user profile and that a user can read and update as part of any self-service profile management. Metadata of this nature may be something like salutation for a user, or a user’s preferred language which could be used to [customize the emails](https://auth0.com/docs/customize/email/email-templates) sent by Auth0.\n\n### Best Practice\n\nStore any information that you want use to customize Auth0 emails in metadata and preferably `user_metadata` if the user is allowed to change it, such as information used to determine the language for an email.\n\n### App metadata\n\nApp metadata (also referred to as `app_metadata`) is, on the other hand, information that can be stored with a user profile but can **only be read or updated with appropriate authorization**; `app_metadata` is not directly accessible to a user. This type of metadata could be something like a flag to indicate that the last set of valid terms and conditions was accepted by the user, and a date to indicate when the user accepted them.\n\n## Password reset\n\nFor users who forget their passwords or who are allowed to change their password via some existing self-service mechanism, Auth0 provides [Password Reset](https://auth0.com/docs/connections/database/password-change) functionality. You can integrate this with your existing implementation and comes already incorporated with out-of-the-box Auth0 UI widgets included as part of [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n\nAuth0 Universal Login provides built-in UX support for password reset using Auth0 Authentication API functionality. Alternatively, you can use the [Auth0 Authentication API](https://auth0.com/docs/connections/database/password-change#use-the-authentication-api), through one of the Auth0 SDKs appropriate to your development environment. Email templates used during password reset workflow can also be fully customized, whether you use Auth0 out-of-box UI widgets or customized Universal Login.\n\nYou can use the Auth0 Management API, on the other hand, to [directly change the password](https://auth0.com/docs/connections/database/password-change#directly-set-the-new-password) for a user identity defined using a Database Connection type. You can use the Auth0 Management API as part of any self-service profile management implementation, and also as part of any [Change Password page customization](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/branding).\n\n## Account verification\n\nYou’ll also need to work with a verified user account at all times and make use of the mechanisms Auth0 provides. You should also consider regulatory compliance like [GDPR](https://eugdpr.org/) which has very specific requirements for protecting EU citizens from privacy and data breaches.\n\nAuth0 provides out-of-box functionality for sending a [verification email](https://auth0.com/docs/customize/email/manage-email-flow) to a user's email address to verify their account. By default, Auth0 automatically sends verification emails for any [Database Connection](https://auth0.com/docs/connections/database) identity created as part of [self sign-up](https://auth0.com/docs/architecture-scenarios/b2b/provisioning#self-sign-up). However, Auth0 also provides a [Management API endpoint](https://auth0.com/docs/api/v2#!/Tickets/post_email_verification) that you can use to send verification emails in cases where email address validation is not performed by a Social Provider upon user registration.\n\n## Blocking users\n\n[Blocking user access](https://auth0.com/docs/manage-users/user-accounts/block-and-unblock-users) in Auth0 provides a way to prevent user login to applications under certain conditions. By default, the Auth0 Dashboard provides an out-of-the-box mechanism to give administrators the ability to both block and unblock user access to all applications, and you can implement this functionality via use of the [Auth0 Management API](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id). You can also use Auth0 extensibility to [disable user access to certain applications](https://auth0.com/docs/manage-users/user-accounts/manage-user-access-to-applications) as well as provide more fine-grained [access control](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/authorization).\n\nIn addition, the Auth0 Management API provides you with the ability to [unblock](https://auth0.com/docs/api/management/v2#!/User_Blocks/delete_user_blocks_by_id) users disabled due to excessive use of incorrect credentials.\n\n## Admin portal\n\nAn admin portal is an application where you can create new users, edit a user’s profile, see activity about a user, etc. This application should be accessible by administrators only. Though Auth0 provides its management dashboard, it is not advised to give access to the management dashboard to many people as there are a lot of ways someone can unintentionally break your Auth0 tenant. Instead, Auth0 provides two other options:\n\n*   [**Auth0 Management API**](https://auth0.com/docs/api/management/v2): With the Management API you can easily construct an application that provides administrators the ability to manage users. You can either incorporate this into an existing application that already exists for your administrators, or create a new one with a UI that matches your current applications.\n    \n*   [**Auth0 Delegated Administration Extension**](https://auth0.com/docs/customize/extensions/delegated-administration-extension): This powerful and flexible extension allows you to customize a user administration experience. You can tailor this extension so that you can allow your customer admins to log in and allow them to only see and manage users within their organization.\n    \n\n### Best practice\n\nIf you are providing your own way for an administrator to manage users, you should only allow administrators to send users a change password link through email rather than allowing administrators to set passwords directly. If you must go against this recommendation and allow your administrators to set someone’s password, you should force the user to change their password at their next login so that only they know the password (and not an administrator as well).\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)\n\n## Multiple Organization Architecture (Multitenancy)\n\nMany B2B platforms implement some form of isolation and/or branding for their customers' organization, and this can add complexity to any Identity and Access Management (IAM) system. If this applies to you, then we recommend you take some time to read through our guidance and best practice advice for this type of environment.\n\n[Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)",
  "title": "Profile Management (B2B)",
  "description": "User profile management planning considerations for your B2B IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-tenants/child-tenants",
  "markdown": "# Link Multiple Tenants to a Single Subscription\n\nAuth0 offers the ability for customers with an Enterprise subscription to link multiple tenants under a single Auth0 subscription (these linked tenants can also be referred to as child tenants).\n\nThis feature can be useful under the following situations:\n\n*   Separate development and production tenants while keeping the same feature access on development tenants as available in production tenants\n    \n*   Own more than one production tenant under a single Enterprise subscription\n    \n\n## Linking tenants\n\nEnterprise subscription automatically allows for users to link tenants under an existing Auth0 subscription by selection \"Custom Agreement\" option from Create Under when creating new tenants.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7ggqdv5yw011z0TsdlaHOO/7707d826dd585e074bd0d8e25b30d9d6/publiccloudtenants.png)\n\nIf you need to link previously created tenants that are not currently part of your Enterprise subscription, contact your designated Technical Account Manager.\n\n## Usage Consolidation\n\nUsage from linked tenants count toward the Enterprise subscription limits and are aggregated under applicable usage and quota reports.\n\n## Learn more\n\n*   [Create Multiple Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants/create-multiple-tenants)\n*   [Delete or Reset Tenants](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant)\n*   [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments)",
  "title": "Link Multiple Tenants to a Single Subscription",
  "description": "Learn how to request linking of multiple tenants under a single Auth0 subscription.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-fapi-compliance/configure-auth0-to-pass-openid-fapi-certification-tests",
  "markdown": "# Configure Auth0 to pass OpenID FAPI Certification Tests\n\nThis section contains some advice on how to configure your client if you would like to test your solution using the [OpenID FAPI Conformance Tests](https://openid.net/certification/certification-fapi_op_testing/).\n\nTo pass the OpenID FAPI Conformance Tests, first configure the following:\n\n*   Set the `compliance_level` property to the desired profile, either `fapi1_adv_pkj_par` or `fapi1_adv_mtls_par`\n    \n*   Either [Configure mTLS](https://auth0.com/docs/get-started/applications/configure-mtls) (including [mTLS aliases](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-tenant#enable-mtls-aliases)) or [Configure Private Key JWT](https://auth0.com/docs/get-started/applications/configure-private-key-jwt)\n    \n*   [Configure mTLS Token Binding](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#enable-token-binding)\n    \n\nThen, follow the instructions below to complete your OpenID FAPI Conformance Tests configuration:\n\n*   [Ensure Auth0 prompts users for consent](#ensure-auth0-prompts-users-for-consent)\n    \n*   [Configure supported ACR claims for the tenant](#configure-supported-acr-claims-for-the-tenant-)\n    \n*   [Remove the alg property from JWKS endpoint](#remove-the-alg-property-from-jwks-endpoint)\n    \n*   [Add Action to require scope and redirect\\_uri](#add-action-to-require-scope-and-redirect_uri)\n    \n\n### Ensure Auth0 prompts users for consent\n\nYou will need to ensure that Auth0 prompts users for consent. You may skip this step if the client is configured as a first-party app, and the Resource Server or API supports skipping consent for first-party apps. To ensure Auth0 requests users for consent, set the `is_first_party` property on the client to `false`:\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/clients/$client_id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"is_first_party\": false  \n}'\n```\n\nThen, promote your connection to the domain level:\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/connections/$connection_id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"is_domain_connection\": true\n}'\n```\n\n#### Configure supported ACR claims for the tenant\n\nThe FAPI tests pass a required ACR value of `urn:mace:incommon:iap:silver`. To include the required ACR value in the ID token, add `urn:mace:incommon:iap:silver` to the list of supported ACR values for the tenant:\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/tentants/settings' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"acr_values_supported\": [\"urn:mace:incommon:iap:silver\"]\n}'\n```\n\n#### Remove the alg property from JWKS endpoint\n\nTo allow for keys to be used with multiple algorithms, not just RS256, remove the tenant's `alg` property from the output of the `/.well-known/jwks.json` endpoint:\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/tentants/settings' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n    \"flags\": {\n        \"remove_alg_from_jwks\": true\n    }\n}'\n```\n\n#### Add Action to require scope and redirect\\_uri\n\nBy default, Auth0 allows requests without a scope, assuming the `openid` scope if no scope is present. Auth0 also allows requests without a `redirect_uri,` which you can set in [Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions). However, the FAPI conformance tests require Auth0 to be more restrictive.\n\nAdd the following Action to enforce the necessary restrictions on scope and `redirect_uri`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (!event.request.body || !event.request.body.refresh_token) {\n    // Require a scope\n    if (!event.request.query.scope) {\n      api.access.deny('scope must be provided in the request');\n    }\n    // To improve the error message if redirect_uri is not present\n    if (!event.request.query.redirect_uri) {\n      api.access.deny('redirect_uri must be provided in the request');\n    }\n  }\n};\n```\n\n## Learn more\n\n*   [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt)\n*   [Configure mTLS Authentication](https://auth0.com/docs/get-started/applications/configure-mtls)",
  "title": "Configure Auth0 to pass OpenID FAPI Certification Tests",
  "description": "Learn how to configure Auth0 to pass the OpenID FAPI Certification Tests.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa/add-mfa",
  "markdown": "# Add Multi-Factor Authentication for Auth0 Dashboard Access\n\nEach Auth0 Dashboard user should self-enroll in multi-factor authentication (MFA). You can enroll in most factors in [Your Profile](https://manage.auth0.com/#/profile). Device biometrics, however, require progressive enrollment.\n\n## Add MFA\n\nTo self-enroll for MFA, each Dashboard user must follow these steps:\n\n1.  Click on your username in the top right corner of the Dashboard and click [Your Profile](https://manage.auth0.com/#/profile).\n    \n2.  Find the supported method you want and click **\\+ ADD** in that row.\n    \n    ![Dashboard - Profile - Multi-Factor - Authentication](https://images.ctfassets.net/cdy7uua7fh8z/2NyLNvP92RruwZ46dLPm5x/8ece3df2b550af8dd78368ca36d8a661/MFA.png)\n3.  Follow the on-screen instructions to complete the enrollment.\n    \n\n## Device biometrics\n\nWebAuthn with device biometrics is the only method that you can't add on the Account Settings page. Instead, Auth0 progressively enrolls all of your WebAuthn-capable devices. Auth0 prompts you to enroll those devices after you enroll any other MFA method. These prompts recur each time you log in to Auth0 Dashboard.\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/1cBjDSZrIeHAS2Fyzbt5HK/7045d8e2c5b0b0588d5eb88f4a5620b0/deviceenrollment.png)\n\nAs part of the enrollment, Auth0 prompts you to name your devices. This makes it easy to manage them from the Account Settings page.\n\nBrowsers with Javascript disabled or without WebAuthn platform authenticator support can't enroll or authenticate with device biometrics. The latest versions of popular browsers and operating systems provide support for WebAuthn with Security Keys. To learn more, read the [browser support section on webauthn.me](https://webauthn.me/browser-support).\n\n## Recovery codes\n\nImmediately after successfully enabling two-factor authentication, Auth0 prompts you to copy a recovery code. If you lose access to all your enrolled factors, you can use this recovery code to log in to your account. Auth0 recommends copying and printing recovery codes or storing them in a safe place, such as a password manager. \n\nIf you lose the recovery codes or just want to generate new ones, you can do so from [Your Profile](https://manage.auth0.com/#/profile).\n\n## Log in to the Dashboard with MFA enabled\n\nLogging in with MFA enabled is only slightly different than a normal login. When you enter admin account credentials, a second prompt appears, depending on which type of MFA factors you’ve enabled. \n\nIf a user loses access to a primary factor, they can click on **Select Another Method** and try with any of the other factors, including recovery codes. This is why it's so important to enroll in multiple methods to prevent being locked out of your account.\n\nAfter you successfully add your second authentication factor and you log in from a new device that supports WebAuthn, you see a prompt to \"Log in Faster on this Device.\" This lets you use that device for multi-factor authentication the next time.\n\n## Learn more\n\n*   [Multi-Factor Authentication for Dashboard Users](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa)\n*   [Remove or Change Dashboard Multi-Factor Authentication](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa/remove-or-change-dashboard-multi-factor-authentication)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
  "title": "Add Multi-Factor Authentication for Auth0 Dashboard Access",
  "description": "Describes how Auth0 Dashboard users can enroll in multi-factor authentication (MFA).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data",
  "markdown": "# Export Data\n\nAll data in your Auth0 tenant is always under your control and is available through the Management API at any time.\n\n## User passwords\n\nThe only information which is not available through the API (for security reasons) are the password hashes of your Auth0-hosted database users and private keys. You can still request this information by opening a [support ticket](https://support.auth0.com/). This operation is not available for our Free subscription tier, and we are unable to accept or guarantee requests for exports at a specific time and date.\n\nIf you store user passwords in your database, set up a custom database connection which Auth0 will query each time a user logs in. In this case, Auth0 will never store any password hashes, unless you choose to progressively migrate users to Auth0.\n\n## Auth0 components\n\nAuth0 primarily uses OpenID Connect (OIDC) as its authentication protocol, so you should be able to implement an integration to your application using standard libraries. The same situation applies when integrating Auth0 through [SAML](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider). All of Auth0's SDKs, libraries, and samples [are published on GitHub as free software](https://github.com/auth0/).\n\nIf you choose not to use Auth0 but want to keep using the same OAuth client IDs and secrets for your social identity providers, you will retain access to user information without needing to display new consent dialogs.\n\n## Custom code\n\nAll of Auth0's custom code features (rules, custom database scripts, custom OAuth connections, and so on) run on a Node.js sandbox service. All libraries available on the sandbox service are also available on npm for use with standard Node.js code.\n\n## Additional resources\n\n*   [Auth0 Availability and Trust](https://auth0.com/availability-trust)\n    \n*   [Data Security and Confidentiality Policies](https://auth0.com/security)\n    \n\n## Learn more\n\n*   [Data Export and Transfer Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/data-export-and-transfer-policy)\n*   [Delete or Reset Tenants](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant)",
  "title": "Export Data",
  "description": "Describes how to export data from Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/monitor-subscription-usage",
  "markdown": "# Monitor Subscription Usage\n\nYour Auth0 subscription plan determines the user limits and features are that are available for you.\n\n## Quota utilization\n\nYou can view subscription utilization information from Auth0 Support Center by visiting [Reports > Quota Utilization](https://support.auth0.com/reports/quota). The subscription utilization information is available with the following details:\n\n*   User Consumption\n    \n    *   Active Users\n        \n*   Feature Consumption\n    \n    *   Enterprise Connections\n        \n    *   Machine to Machine Authentication\n        \n    *   Multi-factor Authentication\n        \n\n![Reports showing subscription feature usage](https://images.ctfassets.net/cdy7uua7fh8z/7g0PDAKl5D8YEf4vC5FjSI/188182aabbeb7e0af77b1bc9d292cfad/Screenshot_2023-02-07_at_5.35.40_PM.jpeg)\n\nEach high level summary card shows the current month utilization against the available subscription limit. It also offers a drill down interaction (by clicking the card) to view further details such as breakdown of usage by Auth0 Private Instance (if applicable) and Tenant for up to past 12 months.\n\nThere is also an option to download a CSV to export this data if required.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7bBqDuycQWsnUdd9hlXN10/040a04d458bff06e8392c1432e3308ce/Screenshot_2023-02-07_at_6.07.01_PM.jpeg)\n\n### Active Users\n\nYou can use this to get a count of unique users with an active event (login or signup) for a given calendar month. There is an ability to drill down and get a breakup of these active users by a Tenant and Private Auth0 Instance (if applicable) for up to 12 past months.\n\n### Enterprise connections\n\nAn [Enterprise connection](https://auth0.com/docs/authenticate/enterprise-connections) is considered active if (during the current month) it has both:\n\n*   Been enabled for an application.\n    \n*   Had user activity (for example, login, sign-up, or token exchange).\n    \n\nIf an Enterprise connection was never enabled for any application, or was enabled but did not have any user activity during the current month, it is not considered active.\n\nYou can use this report to get a count of active enterprise connections for a given calendar month with an breakdown of active connections by Private Auth0 Instance (if applicable) as well as count of active users by an active enterprise connection and tenant.\n\n### Machine to Machine Auth\n\nThis report provides a count of access tokens issued for the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow), also referred to as API Authentication Calls, per calendar month excluding any tokens issued for Auth0 Management API.\n\nYou can view the count of Authentication Calls by Private Auth0 Instance (if applicable) and Tenant.\n\nFor tenants in Auth0 Public Cloud deployment option the report also provides a breakdown of Authentication Calls by Tenant Application for the past 7 days.\n\n### Multi-factor Auth\n\nThere are two reports for Multi-factor Auth (MFA) usage which present a count of MFA events (enrolments or challenges) by calendar month.\n\nEnterprise MFA counts are MFA events related to push notifications, WebAuthn and one-time codes generated by SMS, Email or Phone. Pro MFA counts are MFA events related to one-time code apps like Google Authentication or Cisco DUO.\n\nBoth these report types provide a breakdown of MFA counts by Auth0 Private Instance\\* (if applicable) and Tenant.\n\n\\*Auth0 Private Instance MFA usage is only available since 1st January 2023.\n\n* * *\n\n## Tenant Usage\n\nYou can view total and active user counts by calendar month from Auth0 Support Center for a given tenant by visiting [Reports > Usage](https://support.auth0.com/reports/usage), and selecting a Subscription (and a Tenant for self-service subscriptions). This would provide the following breakdown:\n\n*   Active Users: Count of active users by month and user type (Social, Password, Passwordless, Enterprise) along with a Total Active count.\n    \n*   Active Users by Tenant: Count of active users by month, tenant, and user type (Social, Password, Passwordless, Enterprise) along with a Total Active count.\n    \n*   Total Users by Tenant\n    \n\n![Support Center -> Reports -> Usage](https://images.ctfassets.net/cdy7uua7fh8z/2RmWp1ZIWwV2JCPJcftll5/acd9c3c71b8dbd9cca12a44588e015af/Screen_Shot_2022-10-27_at_1.21.35_PM.png)\n\n## Learn more\n\n*   [Manage Subscriptions](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions)\n*   [Auth0 Dashboard](https://auth0.com/docs/get-started/auth0-overview/dashboard)\n*   [Enterprise Connections](https://auth0.com/docs/authenticate/enterprise-connections)\n*   [Tenant Settings](https://auth0.com/docs/get-started/tenant-settings)",
  "title": "Monitor Subscription Usage",
  "description": "Learn how to monitor your Auth0 subscription usage.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/resource-servers/patch-resource-servers-by-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections",
  "markdown": "# Authenticate with Your Own User Store\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nUse a custom database connection when you want to provide access to your own independent (legacy) identity data store for the following purposes:\n\n*   **Authentication**: Use your database as an identity provider in Auth0 to authenticate users. (Referred to as legacy authentication.)\n    \n*   **Import Users**: Use automatic migration (trickle or lazy migration)\n    \n*   **Proxy access to an Auth0 tenant**: Use Auth0 multi-tenant architecture.\n    \n\nYou can create and configure a custom database connection by doing one of the following tasks:\n\n1.  Use the [Create connections](https://auth0.com/docs/api/management/v2#!/Connections/post_connections) endpoint with the `auth0` strategy.\n    \n2.  Navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), create the connection, and enable the **Use my own database** option to allow database action script editing.\n    \n    ![Enable Custom Database Use My Own Database Option](https://images.ctfassets.net/cdy7uua7fh8z/3kgHDpBFdVWNq9XOfhsTXI/5a18f3634d4d9efa121db32b6cb3d93d/dashboard-connections-database-edit_view-custom-database_use-my-own-database__1_.png)\n\n## How it works\n\nAs shown in the diagram below, you use custom database connections as part of Universal Login workflow in order to obtain user identity information from your own, legacy identity store.\n\n![Custom Database Connections Anatomy](https://images.ctfassets.net/cdy7uua7fh8z/2lHqvZKFiEbAXURU2gmchc/626cac94211c266f2135a41456b2e49d/custom-database-connections.png)\n\nIn addition to artifacts common for all [database connection](https://auth0.com/docs/authenticate/database-connections) types, a custom database connection allows you to configure action scripts: custom code that’s used when interfacing with your legacy identity store. Auth0 provides [custom database action script templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates) for configuration, and the ones you use will depend on whether you are creating a custom database connection for legacy authentication or for automatic migration.\n\n#### Best practice\n\nAction scripts can be implemented as anonymous functions, however anonymous functions make it hard in debugging situations when it comes to interpreting the call-stack generated as a result of any exceptional error condition. For convenience, we recommend providing a function name for each action script.\n\n### Legacy authentication scenario\n\nIn a legacy authentication scenario, a new user record is created within Auth0 during the user's first login, but Auth0 does not store a hash of the user's password. Auth0 will always use the legacy identity store and the identity it contains when authenticating the user.\n\n### Automatic migration scenario\n\nDuring automatic or trickle migration, Auth0 creates a new user in an identity store (database) managed by Auth0. From then on, Auth0 always uses the identity in the Auth0 managed identity store for authenticating the user. For this to occur, first Auth0 requires the user be authenticated against the legacy identity store and only if this succeeds will the new user be created. The new user will be created using the same id and password that was supplied during authentication.\n\n#### Best practice\n\nCreation of a user in an automatic migration scenario typically occurs after the `login` action script completes. We therefore recommend that you do not attempt any deletion of a user from a legacy identity store as an inline operation (i.e., within the `login` script) but perform the deletion as an independent process. This will prevent accidental deletion of a user should an error condition occur during the migration process.\n\nIn an automatic migration scenario, users remain in the legacy identity store and can be deleted or archived if required. One side effect of this can occur if a user is deleted from Auth0 but still remains present in the legacy identity store. In this case, a login actioned by the deleted user could result in either the `login` and/or `getUser` script being executed and the user being migrated from the legacy identity store once again.\n\n#### Best practice\n\nWe recommend marking any legacy user identity as having been migrated before either `login` or `getUser` completes and prior to any eventual legacy store deletion.\n\n## Size\n\nThe total size of implementation for any action script should not exceed 100 kB. The larger the size the more latency is introduced due to the packaging and transport process employed by the Auth0 serverless Webtask platform, and this will have an impact on the performance of your system.\n\n## Environment\n\nAction scripts execute as a series of called JavaScript functions in an instance of a serverless Webtask container. As part of this, a specific environment is provided, together with a number of artifacts supplied by both the Webtask container and the Auth0 authentication server (your Auth0 tenant) itself.\n\n### npm modules\n\nAuth0 serverless Webtask containers can make use of a [wide range of npm modules](https://auth0-extensions.github.io/canirequire/); `npm` modules not only reduce the overall size of action script code implementation, but also provide access to a wide range of pre-built functionality.\n\nMany publicly available `npm` modules are supported out-of-the-box. The list has been compiled and vetted for any potential security concerns. If you require an `npm` module that is not supported out-of-the-box, then you can make a request through the [Auth0 support portal](https://support.auth0.com/) or your Auth0 representative. Auth0 will evaluate your request to determine suitability. There is currently no support in Auth0 for the user of `npm` modules from private repositories.\n\n### Variables\n\nAuth0 action scripts support environment variables, accessed via what is known as the globally-available `configuration` object. To learn more, read the Add Configuration Parameters section in [Create Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection).\n\n#### Best practice\n\nThe `configuration` object should be treated as read-only, and should be used for storing sensitive information such as credentials or API keys for accessing external identity stores. This mitigates having security sensitive values hard coded in an action script.\n\nThe configuration object can also be used to support whatever [Software Development Life Cycle (SDLC)](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments) strategies you employ by allowing you to define variables that have tenant specific values. This mitigates hard coded values in an action script which may change depending upon which tenant is executing it.\n\n### global object\n\nAuth0 serverless Webtask containers are provisioned from a pool that's associated with each Auth0 tenant. Each container instance makes available the `global` object, which can be accessed across all action scripts that execute within the container instance. The `global` object acts as a global variable that’s unique to the container, and that can be used to define information or functions used across all action scripts that run in the container instance.\n\nThis means that the `global` object can be used to cache expensive resources as long as those resources are not user-specific. For example, you could use it to store an Access Token for a third-party (logging) API that provides non-user-specific functionality. Or you could store an Access Token to your own non-user-specific API defined in Auth0 and obtained via the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).\n\nEach time a Webtask container is recycled, or for each instantiation of a new Webtask container, the `global` object it defines is reset. Thus, any declaration of assignment within the `global` object associated with a container should also include provision for initialization too.\n\n#### Best practice\n\nTo provide performance flexibility, serverless Webtask containers are provisioned in Auth0 on an ad-hoc basis and are also subject to various recycle policies. In general, we recommend that you do not consider the life of a `global` object to be anything more than 20 minutes.\n\n## Security\n\n### Access legacy identity storage via custom API\n\nProtecting legacy identity storage from general access is a recommended best practice. Exposing a database directly to the internet, for example, can be extremely problematic: database interfaces for SQL and the like are extremely open in terms of functionality, which violates the principle of least privilege when it comes to security.\n\n#### Best practice\n\nWe recommend that you implement an API to provide least privilege to your legacy identity store (database), rather than simply opening up general access via the internet.\n\nThe alternative is to create a simple (custom) API, protected via use of an access token, that each action script can call. This would act as the interface to the legacy identity store. Client credentials grant flow can then be used to obtain an access token from within a script, and this can subsequently be cached for reuse in the `global` object in order to improve performance. The API can then provide a discrete number of protected endpoints that perform only the legacy management functionality required (for example, `read user`, `change password`).\n\n#### Best practice\n\nBy default, Auth0 will give you a token for any API if you authenticate successfully and include the appropriate audience. Restricting access to the legacy identity store API by restricting access token allocation via use of a Rule, will prevent unauthorized usage and mitigate a number of attack vector scenarios, such as where redirect to `/authorize` is intercepted and the audience to the API is added.\n\n### Allowlist access to legacy identity storage\n\nWhether managing access to a legacy identity store via custom API, or using the native interface provided, restricting access to the list of IP addresses associated with your Auth0 tenant. Allowlisting constrains access to the legacy identity store ensuring that only custom database action scripts defined in Auth0 are permitted.\n\n## Learn more\n\n*   [Create Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection)\n*   [Custom Database Action Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates)\n*   [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling)\n*   [Import and Export Users](https://auth0.com/docs/manage-users/user-migration)",
  "title": "Authenticate with Your Own User Store",
  "description": "Learn about authenticating users using your database as an identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/test-custom-database-connections",
  "markdown": "# Test Custom Database Connections\n\nIf you use the Auth0-hosted database structure to store your users, you can test the connection by authenticating users against the same or a separate tenant.\n\n## Test with import users to Auth0 enabled\n\nWhen import users is enabled, users are gradually migrated from your external user store to Auth0 user store. In the process, users will be authenticated against the external store the first time they successfully log in. All further login attempts will be executed against the Auth0 user store. To learn more, read about automatic migrations in [Import and Export Users](https://auth0.com/docs/manage-users/user-migration).\n\n### Create a test tenant and application\n\n1.  Use the Auth0 Dashboard to [create a new tenant](https://auth0.com/docs/get-started/auth0-overview/create-tenants).\n    \n2.  Navigate to [Applications > Applications](https://manage.auth0.com/#/applications/applications) and create a [Machine-to-Machine](https://manage.auth0.com/#/applications/applications/create) application.\n    \n3.  Enable both the **Password** and **Client Credential** grant for this application (both grants should be enabled for this test).\n    \n    ![Auth0 Dashboard > Applications > Advanced Settings](https://images.ctfassets.net/cdy7uua7fh8z/4caAveuhYurCDb5F8mdImm/9e3afe264a82f96972026bfbedec263b/2024-03-13_16-29-39.png)\n4.  To authorize your application, navigate to [Applications > APIs](https://manage.auth0.com/#/apis).\n    \n5.  Select **Management API**.\n    \n6.  Under the **Machine-to-Machine Applications** tab, use the toggle to authorize your test application.\n    \n    ![Applications > APIs > Management API, Machine-to-machine tab](https://images.ctfassets.net/cdy7uua7fh8z/3bqp2332CdbVm7zNVZraFV/019eb5c15133b179e14f40006420a62b/2024-03-13_16-31-21.png)\n7.  Select the drop-down menu to enable the following Auth0 Management API scopes:\n    \n    *   `read:users`\n        \n    *   `update:users`\n        \n    *   `delete:users`\n        \n    *   `create:users`\n        \n    *   `read:users_app_metadata`\n        \n    *   `update:users_app_metadata`\n        \n    *   `create:users_app_metadata`\n        \n        ![Auth0 Dashboard > APIs > Management API > Scopes](https://images.ctfassets.net/cdy7uua7fh8z/2vW8zD1iIObuqb0i59yw77/c43bafa05b271a4343af51cb5c8ce1ce/2024-03-14_10-28-19.png)\n\n### Create test database connections\n\nAfter you create a tenant and an application in Dashboard, create a source database connection and a target database connection.\n\n1.  Navigate to [Authentication > Database](https://manage.auth0.com/#/connections/database) to create a new database connection to be the source.\n    \n2.  Name your test source connection, enable **Requires Username**, and select **Create**.\n    \n    ![Auth0 Dashboard > Authenticate > Database > Create new database connection](https://images.ctfassets.net/cdy7uua7fh8z/5xizPnXaAf8UkX33ozRqml/734d2bdd25a30e9a13ffdc696f25fb62/2024-03-15_09-34-40.png)\n3.  Create a second database to be the target with the same configuration from step 2.\n    \n4.  In your target database, switch to the **Custom Database** view and toggle on **Use my own database**.\n    \n    ![Auth0 Dashboard > Authenticate > Database > Select the target database > Custom Database](https://images.ctfassets.net/cdy7uua7fh8z/3RPDWRDxbR9OPfGvm2AAKm/2afdecaebc60701f718745412622e71c/2024-03-15_11-11-56.png)\n5.  Switch to the **Settings** view and enable **Import Users to Auth0**.\n    \n6.  Switch to the **Custom Database** view, and then locate the **Database settings** section. Add the following information from your source database created in step 1:\n    \n    | **Key** | **Value** |\n    | --- | --- |\n    | `client_id` | Client ID of the application you created. |\n    | `client_secret` | Client Secret of the application you created. |\n    | `auth0_domain` | Your tenant name in the Auth0 domain: `yourTenant.us.auth0.com`. |\n    | `source_database` | Name of the source connection. |\n    \n7.  Update the [Login](https://auth0.com/docs/authenticate/database-connections/test-custom-db#login) and [Get User](https://auth0.com/docs/authenticate/database-connections/test-custom-db#get-user) database action scripts in your target database. To learn more about best practices using database action scripts, read [Custom Database Connection and Action Scripts Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts).\n    \n8.  Select **Save and Try** on each script. You should monitor the Real-time Webtask Logs Extension `console.log` output. To learn more, read [Real-time Webtask Logs Extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs).\n    \n9.  Select **Try Connection** to test the connection live.\n    \n\n## Test without Import Users enabled\n\n1.  Repeat steps in [Create a test tenant and application](https://www.auth0.com/docs/authenticate/database-connections/test-custom-db#create-a-test-tenant-and-application).\n    \n2.  Create one test database connection.\n    \n3.  Make sure **Import Users to Auth0** under your source database settings is disabled. Users will authenticate against the external user store during each login attempt.\n    \n4.  Update all database actions scripts with the samples below.\n    \n\n### Get User script\n\nThe [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user) script implements an executable function that determines the current state of a user. \n\nWhen **Import Users to Auth0** is enabled, the Get User script runs when a user attempts to sign up to check if the user already exists in the external user store. \n\nThe Get User script also runs when a user attempts to:\n\n*   Change a user's email address ([Change Email](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email) script)\n    \n*   Log in ([Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login) script)\n    \n*   Change a user's password ([Change Password](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password) script)\n    \n\nWhen **Import Users to Auth0** is disabled, the Get User script runs when a user attempts to sign up to check if the user already exists in the external user store. If a user already exists in the external user store, it will not execute the Create script.\n\nThe Get User script also runs when a user attempts to:\n\n*   Create a user ([Create](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create) script)\n    \n*   Change a user's email address ([Change Email](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email) script)\n    \n*   Change a user's password ([Change Password](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password) script)\n    \n\n#### Example\n\n```\nasync function getUser(user, context, callback) {\n    log(`Script started.`);\n    log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n    let accessToken = await getAccessToken();\n    accessToken = accessToken.access_token;\n    if (!accessToken) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n    log(`The Access Token is available. Searching for user \"${user}\" in \"${configuration.source_database}\"`);\n    user = user.toLowerCase();\n    const searchQuery = encodeURI(`identities.connection:\"${configuration.source_database}\"+AND+(email:${user} OR username:${user})`);\n    var options = {\n        method: `GET`,\n        url: `https://${configuration.auth0_domain}/api/v2/users?q=${searchQuery}`,\n        headers: {\n            Authorization: `Bearer ${accessToken}`,\n        }\n    };\n    request(options, function (error, response) {\n        if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n        let search_results = JSON.parse(response.body);\n        let profile = null;\n        if (search_results.length > 0) {\n            log(`A user \"${user}\" is FOUND in \"${configuration.source_database}\" database.`);\n            profile = {\n                user_id: search_results[0].user_id.toString(),\n                nickname: search_results[0].nickname,\n                username: search_results[0].username,\n                email: search_results[0].email\n            };\n        } else {\n            log(`A user \"${user}\" is NOT FOUND in \"${configuration.source_database}\" database.`);\n        }\n        log(`Script completed!`);\n        return callback(null, profile);\n    });\n    /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n    async function getAccessToken() {\n        var options = {\n            method: `POST`,\n            url: `https://${configuration.auth0_domain}/oauth/token`,\n            headers: {\n                \"Content-Type\": `application/x-www-form-urlencoded`,\n            },\n            form: {\n                grant_type: `client_credentials`,\n                client_id: configuration.client_id,\n                client_secret: configuration.client_secret,\n                audience: `https://${configuration.auth0_domain}/api/v2/`\n            },\n            json: true\n        };\n        return new Promise(function (resolve) {\n            request(options, function (error, response) {\n                resolve(error || response.body);\n            });\n        });\n    }\n    /* -- LOGGING -- */\n    function log(message, error = false) {\n        const script_name = `GET USER`;\n        const error_label = error ? `(ERROR)` : ``;\n        const return_message = `${script_name}: ${error_label} ${message}`;\n        console.log(return_message);\n        if (error) return callback(new Error(return_message));\n    }\n}\n```\n\n### Login script\n\nThe [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login) script implements an executable function that authenticates a user when a user logs in. If the user exists in the target database (Auth0), it authenticates them using that record. Otherwise, it authenticates the user with their record in the source database (external).\n\n#### Example\n\n```\nfunction login(usernameOrEmail, password, context, callback) {\n  log(`Script started.`);\n  const jwt = require('jsonwebtoken');\n  const options = {\n    method: `POST`,\n    url: `https://${configuration.auth0_domain}/oauth/token`,\n    headers: { \"Content-Type\": `application/x-www-form-urlencoded` },\n    json: true,\n    form: {\n      grant_type: `http://auth0.com/oauth/grant-type/password-realm`,\n      client_id: configuration.client_id,\n      client_secret: configuration.client_secret,\n      username: usernameOrEmail,\n      password: password,\n      realm: `${configuration.source_database}`\n    }\n  };\n  request(options, function (error, response, body) {\n    log(`Attempting to authenticate a user \"${usernameOrEmail}\" against \"${configuration.source_database}\" database in \"${configuration.auth0_domain}\" tenant.`);\n    if (error) return log(`Cannot connect to \"${configuration.auth0_domain}\" database.`, true);\n    if (response.statusCode !== 200) {\n      console.log(`LOGIN: (ERROR) ${response.body.error_description}`);\n      return callback(new WrongUsernameOrPasswordError(usernameOrEmail, `LOGIN: (ERROR) ${response.body.error_description}`));\n    }\n    log(`Successfuly authenticated user \"${usernameOrEmail}\" against \"${configuration.source_database}\" database in \"${configuration.auth0_domain}\" tenant.`);\n    const decoded_id_token = jwt.decode(body.id_token);\n    const profile = {\n      user_id: decoded_id_token.sub,\n      nickname: decoded_id_token.nickname,\n      username: decoded_id_token.username,\n      email: decoded_id_token.email\n    };\n    log(`Script completed.`);\n    return callback(null, profile);\n  });\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `LOGIN`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Create script\n\nThe [Create script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create) implements an executable function that creates a corresponding user record in the external database when a user signs up through Universal Login, or is created in the Auth0 Dashboard or with the Auth0 Management API.\n\n#### Example\n\n```\nasync function create(user, context, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Attempting to create a user \"${user.email}\" in \"${configuration.source_database}\"`);\n  const options = {\n    method: `POST`,\n    url: `https://${configuration.auth0_domain}/api/v2/users`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": `application/x-www-form-urlencoded`\n    },\n    form: {\n      connection: configuration.source_database,\n      email: user.email,\n      password: user.password,\n      username: user.username\n    },\n    json: true\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    switch (response.statusCode) {\n      case 201:\n        log(`The user \"${user.email}\" is successfuly created in \"${configuration.source_database}\" database.`);\n        return callback(null);\n      case 409:\n        return callback(new ValidationError(`user_exists`, `The user already exists in \"${configuration.source_database}\" database.`));\n      default:\n        return log(`Failed to create a user \"${user.email}\" in \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `CREATE`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Delete script\n\nThe [Delete script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete) implements an executable function that deletes a user from Auth0 and the external database in the same operation when a user is deleted in the Auth0 Dashboard or with the Auth0 Management API.\n\n#### Example\n\n```\nasync function deleteUser(user, context, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Attempting to delete a user \"${user}\" from \"${configuration.source_database}\"`);\n  const options = {\n    method: `DELETE`,\n    url: `https://${configuration.auth0_domain}/api/v2/users/${user}`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": `application/x-www-form-urlencoded`\n    },\n    json: true\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    switch (response.statusCode) {\n      case 204:\n        log(`The user \"${user}\" is successfuly deleted from \"${configuration.source_database}\" database.`);\n        return callback(null);\n      default:\n        return log(`Failed to delete a user \"${user}\" from \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `DELETE`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Verify script\n\nThe [Verify script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify) implements an executable function that marks the verification status of a user’s email address in the external database when a user clicks on the link in the verification email sent by Auth0.\n\n#### Example\n\n```\nasync function verify(user, context, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Searching for user \"${user}\" in \"${configuration.source_database}\"`);\n  user = user.toLowerCase();\n  const searchQuery = encodeURI(`identities.connection:\"${configuration.source_database}\"+AND+(email:${user} OR username:${user})`);\n  var options = {\n    method: `GET`,\n    url: `https://${configuration.auth0_domain}/api/v2/users?q=${searchQuery}`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    }\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    let search_results = JSON.parse(response.body);\n    if (search_results.length > 0) {\n      log(`A user \"${user}\" is found in \"${configuration.source_database}\" database.`);\n      const user_id = search_results[0].user_id.toString();\n      log(`Attempting to mark user \"${user_id}\" as verified in \"${configuration.source_database}\" database`);\n      const options = {\n        method: `PATCH`,\n        url: `https://${configuration.auth0_domain}/api/v2/users/${user_id}`,\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          \"Content-Type\": `application/x-www-form-urlencoded`\n        },\n        form: {\n          email_verified: true,\n        },\n        json: true\n      };\n      request(options, function (error, response) {\n        if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n        switch (response.statusCode) {\n          case 200:\n            log(`The user \"${user}\" is marked as verified in \"${configuration.source_database}\" database.`);\n            return callback(null, true);\n          default:\n            return log(`Failed to mark a user \"${user}\" as verified in \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n        }\n      });\n    } else {\n      log(`A user \"${user}\" is not found in \"${configuration.source_database}\" database. Unable to verify.`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `VERIFY`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Change Password script\n\nThe [Change Password script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password) implements an executable function that updates a user's password in the external database when a password change workflow starts from the Auth0 Dashboard or the Auth0 Management API.\n\n#### Example\n\n```\nasync function changePassword(user, newPassword, context, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Searching for user \"${user}\" in \"${configuration.source_database}\" database.`);\n  user = user.toLowerCase();\n  const searchQuery = encodeURI(`identities.connection:\"${configuration.source_database}\"+AND+(email:${user} OR username:${user})`);\n  var options = {\n    method: `GET`,\n    url: `https://${configuration.auth0_domain}/api/v2/users?q=${searchQuery}`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    }\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    let search_results = JSON.parse(response.body);\n    if (search_results.length > 0) {\n      log(`A user \"${user}\" is found in \"${configuration.source_database}\" database.`);\n      const user_id = search_results[0].user_id.toString();\n      log(`Attempting to change password for user \"${user_id}\" in \"${configuration.source_database}\" database.`);\n      const options = {\n        method: `PATCH`,\n        url: `https://${configuration.auth0_domain}/api/v2/users/${user_id}`,\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          \"Content-Type\": `application/x-www-form-urlencoded`\n        },\n        form: {\n          password: newPassword,\n        },\n        json: true\n      };\n      request(options, function (error, response) {\n        if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n        switch (response.statusCode) {\n          case 200:\n            log(`The user \"${user}\" password successfully changed in \"${configuration.source_database}\" database.`);\n            return callback(null, true);\n          default:\n            return log(`Failed to change password for \"${user}\"  in \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n        }\n      });\n    } else {\n      log(`A user \"${user}\" is not found in \"${configuration.source_database}\" database. Unable to change password.`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `CHANGE PASSWORD`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Change Email script\n\nThe [Change Email](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email) script implements an executable function that updates a user's email address when the user changes their email address or their email address verification status.\n\nThis script is not available in the Auth0 Dashboard. You must call the Management API [Update a connection](https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id) endpoint and provide the `options.customScripts.change_email` property.\n\n#### Example\n\n```\nasync function changeEmail(user, newEmail, verified, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Searching for user \"${user}\" in \"${configuration.source_database}\" database.`);\n  user = user.toLowerCase();\n  const searchQuery = encodeURI(`identities.connection:\"${configuration.source_database}\"+AND+(email:${user} OR username:${user})`);\n  var options = {\n    method: `GET`,\n    url: `https://${configuration.auth0_domain}/api/v2/users?q=${searchQuery}`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    }\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    let search_results = JSON.parse(response.body);\n    if (search_results.length > 0) {\n      log(`A user \"${user}\" is found in \"${configuration.source_database}\" database.`);\n      const user_id = search_results[0].user_id.toString();\n      log(`Attempting to change email / verified status for user \"${user_id}\" in \"${configuration.source_database}\" database.`);\n      const options = {\n        method: `PATCH`,\n        url: `https://${configuration.auth0_domain}/api/v2/users/${user_id}`,\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          \"Content-Type\": `application/x-www-form-urlencoded`\n        },\n        form: {\n          email: newEmail,\n          email_verified: verified || false\n        },\n        json: true\n      };\n      request(options, function (error, response) {\n        if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n        switch (response.statusCode) {\n          case 200:\n            log(`The user \"${user}\" email / verified status successfully changed in \"${configuration.source_database}\" database.`);\n            return callback(null, true);\n          default:\n            return log(`Failed to change email / verified status for \"${user}\"  in \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n        }\n      });\n    } else {\n      log(`A user \"${user}\" is not found in \"${configuration.source_database}\" database. Unable to change email / verified status.`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `CHANGE EMAIL`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n## Learn more\n\n*   [Password Strength in Auth0 Database Connections](https://auth0.com/docs/authenticate/database-connections/password-strength)\n*   [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment)\n*   [Password Options in Auth0 Database Connections](https://auth0.com/docs/authenticate/database-connections/password-options)\n*   [Configure Identity Provider Connection for User Profile Updates](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0)\n*   [Connection Settings Best Practices](https://auth0.com/docs/authenticate/connection-settings-best-practices)\n*   [Create Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection)",
  "title": "Test Custom Database Connections",
  "description": "Describes how to test your custom database connections in Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/downgrade-or-cancel-subscriptions",
  "markdown": "# Downgrade or Cancel Auth0 Subscriptions\n\nYou can downgrade or cancel your Auth0 subscription at any time, and may be eligible for a credit on your next billing cycle or a refund depending on the circumstances.\n\n## Self-service plans\n\nIf you are subscribed to an Essential or Professional plan, you can downgrade or cancel your subscription in the [Auth0 Dashboard](https://manage.auth0.com/#).\n\n### Downgrade or cancel plan\n\n1.  Go to [Dashboard > Settings](https://manage.auth0.com/#/tenant), and then switch to the **Subscription** view.\n    \n2.  Locate the plan you'd like to downgrade to, and then select **Downgrade**.\n    \n3.  If you want to cancel your plan, locate the **Free** plan, and then select **Downgrade**.\n    \n    ![Auth0 Tenant Settings Subscription tab](https://images.ctfassets.net/cdy7uua7fh8z/3yISRVTJOwP4Yo2uG0iZdO/540ac52cb14f13899e2c55f549f9c11e/Screenshot_2023-12-05_at_3.50.08_PM.png)\n4.  To confirm your subscription change, select **Subscribe Now**.\n    \n\n### Request credit or refund\n\nIf you downgrade or cancel your Auth0 subscription, you may be eligible for a credit on your next billing cycle or a refund. To learn more, read our [Billing Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/billing-policy).\n\n## Enterprise plans\n\nIf you are subscribed to an Enterprise plan, contact your Technical Account Manager (TAM) and then [open a ticket with Auth0 Support](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets).\n\n## Learn more\n\n*   [Delete or Reset Tenants](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant)",
  "title": "Downgrade or Cancel Auth0 Subscriptions",
  "description": "Describes how to downgrade or cancel your Auth0 subscription.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password",
  "markdown": "# Change Password Script Templates\n\nThe Change Password script implements the defined function to change the specified user's password in the external database. We recommend naming this function `changePassword`.\n\nThe script is used only in a [legacy authentication scenario](https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections) and is required if you want to change a user's password in the external database. It will execute when a user performs a [password reset workflow](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page), or when a password change workflow is started from the Auth0 Dashboard or the Auth0 Management API.\n\n## ChangePassword function\n\nThe `changePassword` function should:\n\n*   Update the user's password in the external database.\n    \n*   Return `true` (or an object containing the `last_password_reset` property) if the password change operation succeeded. If the `last_password_reset` property is present in the object, it will be updated on the user's profile.\n    \n*   Return `false` if the password change operation failed.\n    \n*   Return an error if the external database could not be reached.\n    \n\n### Definition\n\nThe `changePassword` function accepts three parameters and returns a `callback` function:\n\n```\nchangePassword(email, newPassword, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `email` | String | User's email address in Auth0 and external database. |\n| `newPassword` | String | Value to be set as user's new password in the external database. This value is sent as plaintext to the function and [should be encrypted](#Encryption) before being sent to the external database. |\n| `callback` | Function | Used to pass data or operation result data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `changePassword` function. For language-specific examples, read [Language-specific script examples](#language-specific-script-examples).\n\n```\nfunction changePassword(email, newPassword, callback) {\n  // Hash the provided password \n  let hashedPassword = hash(newPassword);\n\n  // Prepare the API call\n  let options = {\n    url: \"https://example.com/api/users\",\n    body: {\n      email: email,\n      password: hashedPassword\n    }\n  };\n\n  // Call the API\n  send(options, err => {\n    if (err && err.id == \"FAIL_CHANGE_PASSWORD\") {\n      // Return false in callback if password change failed\n      return callback(null, false);\n    } else if (err) {\n      // Return error in callback if other error occurred\n      return callback(new Error(\"My custom error message.\");\n    } else {\n      // Return true in callback if password change operation succeeded\n      return callback(null, true);\n\n      // Or return an object containing the `last_password_reset` property \n      // if the password change operation succeeded.\n      // If the `last_password_reset` property is present in the object,\n      // it will be updated on the user's profile.\n      return callback(null, { \"last_password_reset\": Date.now() });\n    }\n  });\n}\n```\n\n### Encryption\n\nTo prevent any potential data leak, encrypt the password value using a cryptographic hash encryption library such as `bcrypt`.\n\n#### Example\n\n```\nbcrypt.hash(password, 10, function (err, hash) {\n    if (err) {\n        return callback(err);\n    } else {\n        // Return hashed password\n    }\n});\n```\n\n## Callback function\n\nThe `callback` function accepts two parameters and is used to pass error data or indicate the result of the operation.\n\n### Definition\n\n```\ncallback(error, operationResult | resultObj): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `operationResult` | Boolean | Optional | Indicates the result of the change password operation. |\n| `resultObj` | Object | Optional | Indicates that the change password operation succeeded. If the `last_password_reset` property is present, it will be updated on the user's profile. |\n\n### Return a success\n\nIf the change password operation succeeded, return the `callback` function, and pass a `null` value as the `error` parameter and a `true` value as the `operationResult` parameter.\n\n#### Example\n\n```\nreturn callback(null, true);\n```\n\n### Return a success and update last\\_password\\_reset attribute\n\nIf the change password operation succeeded, return the `callback` function, and pass a `null` value as the `error` parameter and an object value as the `profile` parameter. If `last_password_reset` attribute is provided in the object, it will be updated on the user's profile.\n\n#### Example\n\n```\nreturn callback(null, { \"last_password_reset\": Date.now() });\n```\n\n### Return a failure\n\nIf the change password operation failed, return the `callback` function, and pass a `null` value as the `error` parameter and a `false` value as the `operationResult` parameter.\n\n#### Example\n\n```\nreturn callback(null, false);\n```\n\n### Return an error\n\nIf an error occurs, return `callback` function, and pass relevant error information as the `error` parameter.\n\n#### Example\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n\n### JavaScript\n\n```\nfunction changePassword(email, newPassword, callback) {\n  // This script should change the password stored for the current user in your\n  // database. It is executed when the user clicks on the confirmation link\n  // after a reset password request.\n  // The content and behavior of password confirmation emails can be customized\n  // here: https://manage.auth0.com/#/emails\n  // The `newPassword` parameter of this function is in plain text. It must be\n  // hashed/salted to match whatever is stored in your database.\n  //\n  // There are three ways that this script can finish:\n  // 1. The user's password was updated successfully:\n  //     callback(null, true);\n  // 2. The user's password was not updated:\n  //     callback(null, false);\n  // 3. Something went wrong while trying to reach your database:\n  //     callback(new Error(\"my error message\"));\n  //\n  // If an error is returned, it will be passed to the query string of the page\n  // to which the user is being redirected after clicking the confirmation link.\n  // For example, returning `callback(new Error(\"error\"))` and redirecting to\n  // https://example.com would redirect to the following URL:\n  //     https://example.com?email=alice%40example.com&message=error&success=false\n  const msg = 'Please implement the Change Password script for this database ' +\n    'connection at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction changePassword(email, newPassword, callback) {\n  var crypto = require('crypto');\n  var Connection = require('tedious').Connection;\n  var Request = require('tedious').Request;\n  var TYPES = require('tedious').TYPES\n  var connection = new Connection({\n    userName:  'the username',\n    password:  'the password',\n    server:    'the server',\n    options: {\n      database:  'the db name',\n      // encrypt: true   for Windows Azure enable this\n    }\n  });\n  /**\n   * hashPassword\n   *\n   * This function creates a hashed version of the password to store in the database.\n   *\n   * @password  {[string]}      the password entered by the user\n   * @return    {[string]}      the hashed password\n   */\n  function hashPassword(password, salt) {\n    // the default implementation uses HMACSHA256 and since Key length is 64\n    // and default salt is 16 bytes, Membership will fill the buffer repeating the salt\n    var key = Buffer.concat([salt, salt, salt, salt]);\n    var hmac = crypto.createHmac('sha256', key);\n    hmac.update(Buffer.from(password, 'ucs2'));\n    var hashed = hmac.digest('base64');\n    return hashed;\n  }\n  connection.on('debug', function(text) {\n      // if you have connection issues, uncomment this to get more detailed info\n      //console.log(text);\n  }).on('errorMessage', function(text) {\n      // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    updateMembershipUser(email, newPassword, function(err, wasUpdated) {\n      if (err) {\n        return callback(err); // this will return a 500\n      }\n      callback(null, wasUpdated);\n    });\n  });\n  function updateMembershipUser(email, newPassword, callback) {\n    var salt            = crypto.randomBytes(16);\n    var hashedPassword  = hashPassword(newPassword, salt);\n    var updateMembership =\n      'UPDATE Memberships '+\n      'SET Password=@NewPassword, PasswordSalt=@NewSalt, LastPasswordChangedDate=GETDATE() '+\n      'WHERE Email=@Email';\n    var updateMembershipQuery = new Request(updateMembership, function (membershipErr, membershipCount) {\n      if (membershipErr) {\n        return callback(membershipErr);\n      }\n      callback(null, membershipCount > 0);\n    });\n    updateMembershipQuery.addParameter('NewPassword', TYPES.VarChar, hashedPassword);\n    updateMembershipQuery.addParameter('NewSalt',     TYPES.VarChar, salt.toString('base64'));\n    updateMembershipQuery.addParameter('Email',       TYPES.VarChar, email);\n    connection.execSql(updateMembershipQuery);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction changePassword(email, newPassword, callback) {\n  var crypto = require('crypto');\n  var Connection = require('tedious').Connection;\n  var Request = require('tedious').Request;\n  var TYPES = require('tedious').TYPES\n  var connection = new Connection({\n    userName:  'the username',\n    password:  'the password',\n    server:    'the server',\n    options: {\n      database:  'the db name',\n      // encrypt: true for Windows Azure enable this\n    }\n  });\n  /**\n   * hashPassword\n   *\n   * This function hashes a password using HMAC SHA256 algorithm.\n   *\n   * @password    {[string]}    password to be hased\n   * @salt        {[string]}    salt to be used in the hashing process\n   * @callback    {[function]}  callback to be called after hashing the password\n   */\n  function hashPassword(password, salt, callback) {\n    var iterations         = 1000;\n    var passwordHashLength = 32;\n    crypto.pbkdf2(password, salt, iterations, passwordHashLength, function (err, hashed) {\n      if (err) {\n        return callback(err);\n      }\n      var result = Buffer.concat([Buffer.from([0], 1), salt, Buffer.from(hashed, 'binary')]);\n      var resultBase64 = result.toString('base64');\n      callback(null, resultBase64);\n    });\n  }\n  connection.on('debug', function(text) {\n      // if you have connection issues, uncomment this to get more detailed info\n      //console.log(text);\n  }).on('errorMessage', function(text) {\n      // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    updateMembershipUser(email, newPassword, function(err, wasUpdated) {\n      if (err) {\n        return callback(err); // this will return a 500\n      }\n      callback(null, wasUpdated);\n    });\n  });\n  function findUserId(email, callback) {\n    var findUserIdFromEmail =\n      'SELECT UserProfile.UserId FROM ' +\n      'UserProfile INNER JOIN webpages_Membership ' +\n      'ON UserProfile.UserId = webpages_Membership.UserId ' +\n      'WHERE UserName = @Email';\n    var findUserIdFromEmailQuery = new Request(findUserIdFromEmail, function (err, rowCount, rows) {\n      if (err) {\n        return callback(err);\n      }\n      // No record found with that email\n      if (rowCount < 1) {\n        return callback(null, null);\n      }\n      var userId = rows[0][0].value;\n      callback(null, userId);\n    });\n    findUserIdFromEmailQuery.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(findUserIdFromEmailQuery);\n  }\n  function updateMembershipUser(email, newPassword, callback) {\n    findUserId(email, function (err, userId) {\n      if (err) {\n        return callback(err);\n      }\n      if (userId === null) {\n        return callback();\n      }\n      var salt = crypto.randomBytes(16);\n      var updateMembership =\n        'UPDATE webpages_Membership '+\n        'SET Password=@NewPassword, PasswordChangedDate=GETDATE() '+\n        'WHERE UserId=@UserId';\n      var updateMembershipQuery = new Request(updateMembership, function (err, rowCount) {\n        if (err) {\n          return callback(err);\n        }\n        if (rowCount < 1) {\n          return callback();\n        }\n        callback(null, rowCount > 0);\n      });\n      hashPassword(newPassword, salt, function (err, hashedPassword) {\n        if (err) {\n          return callback(err);\n        }\n        updateMembershipQuery.addParameter('NewPassword',   TYPES.VarChar, hashedPassword);\n        updateMembershipQuery.addParameter('UserId',        TYPES.VarChar, userId);\n        connection.execSql(updateMembershipQuery);\n      });\n    });\n  }\n}\n```\n\n### MongoDB\n\n```\nfunction changePassword(email, newPassword, callback) {\n  const bcrypt = require('bcrypt');\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    bcrypt.hash(newPassword, 10, function (err, hash) {\n      if (err) {\n        client.close();\n        return callback(err);\n      }\n      users.update({ email: email }, { $set: { password: hash } }, function (err, count) {\n        client.close();\n        if (err) return callback(err);\n        callback(null, count > 0);\n      });\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction changePassword(email, newPassword, callback) {\n  const mysql = require('mysql');\n  const bcrypt = require('bcrypt');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'UPDATE users SET password = ? WHERE email = ?';\n  bcrypt.hash(newPassword, 10, function(err, hash) {\n    if (err) return callback(err);\n    connection.query(query, [ hash, email ], function(err, results) {\n      if (err) return callback(err);\n      callback(null, results.length > 0);\n    });\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction changePassword (email, newPassword, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const bcrypt = require('bcrypt');\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    bcrypt.hash(newPassword, 10, function (err, hash) {\n      if (err) return callback(err);\n      const query = 'UPDATE users SET password = $1 WHERE email = $2';\n      client.query(query, [hash, email], function (err, result) {\n        // NOTE: always call `done()` here to close\n        // the connection to the database\n        done();\n        return callback(err, result && result.rowCount > 0);\n      });\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction changePassword (email, newPassword, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://tediousjs.github.io/tedious/\n  const bcrypt = require('bcrypt');\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'UPDATE dbo.Users SET Password = @NewPassword WHERE Email = @Email';\n  connection.on('debug', function(text) {\n    console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rows) {\n      if (err) return callback(err);\n      callback(null, rows > 0);\n    });\n    bcrypt.hash(newPassword, 10, function (err, hash) {\n      if (err) return callback(err);\n      request.addParameter('NewPassword', TYPES.VarChar, hash);\n      request.addParameter('Email', TYPES.VarChar, email);\n      connection.execSql(request);\n    });\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction changePassword (email, newPassword, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@1.11.0').Connection;\n  var Request = require('tedious@1.11.0').Request;\n  var TYPES = require('tedious@1.11.0').TYPES;\n  var bcrypt = require('bcrypt');\n  var connection = new Connection({\n    userName:  'your-user@your-server-id.database.windows.net',\n    password:  'the-password',\n    server:    'your-server-id.database.windows.net',\n    options:  {\n      database: 'mydb',\n      encrypt:  true\n    }\n  });\n  var query = 'UPDATE dbo.Users SET Password = @NewPassword ' +\n    'WHERE Email = @Email';\n  connection.on('debug', function(text) {\n    // Uncomment next line in order to enable debugging messages\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    // Uncomment next line in order to enable information messages\n    // console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var request = new Request(query, function (err, rows) {\n      if (err) { return callback(err); }\n      console.log('rows: ' + rows);\n      callback(null, rows > 0);\n    });\n    bcrypt.hash(newPassword, 10, function (err, hash) {\n      if (err) { return callback(err); }\n      request.addParameter('NewPassword', TYPES.VarChar, hash);\n      request.addParameter('Email', TYPES.VarChar, email);\n      connection.execSql(request);\n    });\n  });\n}\n```\n\n## Learn more\n\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
  "title": "Change Password Script Templates",
  "description": "Describes custom database action script templates for changing a user's password.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create",
  "markdown": "# Create Script Templates\n\nThe Create script implements the defined function when a user is created. We recommend naming this function `create`.\n\nThis script is optional. If it's enabled, when a user signs up through Universal Login or is created through the Auth0 Dashboard or Auth0 Management API, Auth0 will run the script to create a corresponding user record in the external database.\n\nWhen a user is created in Auth0, Auth0 calls a series of scripts:\n\n1.  [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user): Verifies that the user does not already exist in Auth0 or the external database.\n    \n2.  Create: Creates the user in the external database.\n    \n3.  [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login): Verifies that the user was created successfully.\n    \n\n## Create function\n\nThe `create` function should:\n\n*   Send the user's profile data to the external database's API.\n    \n*   Return an error if the user creation operation failed.\n    \n\n### Definition\n\nThe `create` function accept two parameters and returns a `callback` function:\n\n```\ncreate(user, callback): function\n```\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `user` | Object. Contains [user profile data](#user-object-parameter) sourced from the user creation process. |\n| `callback` | Function. Used to pass error data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `create` function. For language-specific examples, read [Language-specific script examples](#language-specific-script-examples).\n\n```\nfunction create(user, callback) {\n  // Send user profile data to external database API\n  let hashedPassword = hash(user.password);\n\n  let options = {\n    url: \"https://example.com/api/create\",\n    body: {\n      email: user.email,\n      username: user.username,\n      password: hashedPassword\n    }\n  };\n\n  send(options, err => {\n    // Return error in callback if user already exists\n    if (err && err.id === \"USER_ALREADY_EXISTS\") {\n      return callback(new ValidationError(\"user_exists\", \"My custom error message.\"));\n    } else if (err) {\n      // Return error in callback if error occurred\n      return callback(new Error(\"My custom error message.\"));\n    }\n\n    // Return `null` value in callback if user creation operation succeeded\n    return callback(null);\n  });\n}\n```\n\n### Encryption\n\nEncrypt the password value using a cryptographic hash encryption library such as `bcrypt` to prevent any potential data leak.\n\n#### Example\n\n```\nbcrypt.hash(password, 10, function (err, hash) {\n    if (err) {\n        return callback(err);\n    } else {\n        // Return hashed password\n    }\n});\n```\n\n## Callback function\n\nThe `callback` function accepts one parameter and returns a function.\n\n### Definition\n\n```\ncallback(error): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n\n### Return a success\n\nIf the user creation operation succeeded, return the `callback` function, and pass a `null` value as the `error` parameter.\n\n#### Example\n\n### Return an error\n\nIf an error occurs, return the callback function, and pass relevant error information to the the `error` parameter.\n\n#### ValidationError type object\n\nThe `ValidationError` custom error type object allows you to pass data that will be displayed in your [Tenant Logs](https://auth0.com/docs/deploy-monitor/logs).\n\n##### Constructor\n\nThe `ValidationError` constructor accepts up to two parameters:\n\n```\nnew ValidationError(errorCode[, message]): ValidationError\n```\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `errorCode` | (Required) String. Specifies the type of error. |\n| `message` | (Optional) String. Contains information about the error. |\n\n#### Return error that user already exists\n\nIf you return an error with the value of `user_exists` for the `errorCode` parameter, Auth0 will record an `fs` tenant log event.\n\n##### Example\n\n```\nreturn callback(new ValidationError(\"user_exists\", \"My custom error message.\"));\n```\n\n| **Tenant Log Event Field** | **Value** |\n| --- | --- |\n| **Code** | `fs` |\n| **Event** | Failed Signup |\n| **Description** | `My custom error message.` |\n\n## User object parameter\n\nThe `user` object parameter contains a predefined set of properties sourced from the user creation process:\n\n| **Property** | **Description** |\n| --- | --- |\n| `client_id` | The Auth0 application's client ID if the user signed up through Universal Login, or the API key if the user was created through the Auth0 Dashboard or Management API. |\n| `tenant` | The Auth0 tenant name. |\n| `email` | The user's email address. |\n| `password` | The user's password in plain text. |\n| `username` | The user's username. Required only if the custom database connection has the [**Requires Username**](https://auth0.com/docs/connections/database/require-username) setting enabled. |\n| `connection` | The Auth0 connection name. |\n| `user_metadata` | Contains the properties of the `user_metadata` object on the user's Auth0 profile, if the object exists. |\n| `app_metadata` | Contains the properties of the `app_metadata` object on the user's Auth0 profile, if the object exists. |\n\n### Username property\n\nIf your custom database connection has the [Requires Username](https://auth0.com/docs/authenticate/database-connections/require-username) setting enabled, then the [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login) and [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user) scripts must support the `username` property, so you should store it in your external database.\n\n### User and app metadata\n\nThe `user_metadata` and `app_metadata` properties do not need to be stored in your external database. Auth0 automatically stores these values as part of the [user profile](https://auth0.com/docs/videos/get-started-series/learn-user-profiles) record created internally.\n\n### Custom sign up fields\n\nIf you [create and use custom fields](https://auth0.com/docs/libraries/custom-signup#using-the-api) during the sign up process, they will be included in the `user` object.\n\n### Example\n\n```\n{\n    client_id: \"8tkMo6n1QkKOazqPcSQd8wU7LzXYibgK\",\n    tenant: \"{yourAuth0Tenant}\",\n    email: \"username@domain.com\",\n    password: \"mySuperSecretPassword123\",\n    username: \"username456\",\n    user_metadata: {\n        \"language\": \"en\"\n    },\n    app_metadata: {\n        \"plan\": \"full\"\n    }\n}\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n*   [Request with Basic Auth](#request-with-basic-auth)\n    \n\n### JavaScript\n\n```\nfunction create(user, callback) {\n  // This script should create a user entry in your existing database. It will\n  // be executed when a user attempts to sign up, or when a user is created\n  // through the Auth0 Dashboard or Management API.\n  // When this script has finished executing, the Login script will be\n  // executed immediately afterwards, to verify that the user was created\n  // successfully.\n  //\n  // The user object will always contain the following properties:\n  // * email: the user's email\n  // * password: the password entered by the user, in plain text\n  // * tenant: the name of this Auth0 account\n  // * client_id: the client ID of the application where the user signed up, or\n  //              API key if created through the Management API or Auth0 Dashboard\n  // * connection: the name of this database connection\n  //\n  // There are three ways this script can finish:\n  // 1. A user was successfully created\n  //     callback(null);\n  // 2. This user already exists in your database\n  //     callback(new ValidationError(\"user_exists\", \"my error message\"));\n  // 3. Something went wrong while trying to reach your database\n  //     callback(new Error(\"my error message\"));\n  const msg = 'Please implement the Create script for this database connection ' +\n    'at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction create(user, callback) {\n  const crypto = require('crypto');\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  const applicationId = 'your-application-id-goes-here';\n  /**\n   * hashPassword\n   *\n   * This function creates a hashed version of the password to store in the database.\n   *\n   * @password  {[string]}      the password entered by the user\n   * @return    {[string]}      the hashed password\n   */\n  function hashPassword(password, salt) {\n    // the default implementation uses HMACSHA256 and since Key length is 64\n    // and default salt is 16 bytes, Membership will fill the buffer repeating the salt\n    const key = Buffer.concat([salt, salt, salt, salt]);\n    const hmac = crypto.createHmac('sha256', key);\n    hmac.update(Buffer.from(password, 'ucs2'));\n    return hmac.digest('base64');\n  }\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) {\n      return callback(err);\n    }\n    createMembershipUser(user, function(err, user) {\n      if (err) return callback(err); // this will return a 500\n      if (!user) return callback(); // this will return a 401\n      callback(null, user);\n    });\n  });\n  function createMembershipUser(user, callback) {\n    const userData = {\n      UserName: user.email,\n      ApplicationId: applicationId\n    };\n    const createUser =\n      'INSERT INTO Users (UserName, LastActivityDate, ApplicationId, UserId, IsAnonymous) ' +\n      'OUTPUT Inserted.UserId ' +\n      'VALUES (@UserName, GETDATE(), @ApplicationId, NEWID(), \\'false\\')';\n    const createUserQuery = new Request(createUser, function(err, rowCount, rows) {\n      if (err) return callback(err);\n      // No records added\n      if (rowCount === 0) return callback(null);\n      const userId = rows[0][0].value;\n      const salt = crypto.randomBytes(16);\n      const membershipData = {\n        ApplicationId: applicationId,\n        Email: user.email,\n        Password: hashPassword(user.password, salt),\n        PasswordSalt: salt.toString('base64'),\n        UserId: userId\n      };\n      const createMembership =\n        'INSERT INTO Memberships (ApplicationId, UserId, Password, PasswordFormat, ' +\n        'PasswordSalt, Email, isApproved, isLockedOut, CreateDate, LastLoginDate, ' +\n        'LastPasswordChangedDate, LastLockoutDate, FailedPasswordAttemptCount, ' +\n        'FailedPasswordAttemptWindowStart, FailedPasswordAnswerAttemptCount, ' +\n        'FailedPasswordAnswerAttemptWindowsStart) ' +\n        'VALUES ' +\n        '(@ApplicationId, @UserId, @Password, 1, @PasswordSalt, ' +\n        '@Email, \\'false\\', \\'false\\', GETDATE(), GETDATE(), GETDATE(), GETDATE(), 0, 0, 0, 0)';\n      const createMembershipQuery = new Request(createMembership, function(err, rowCount) {\n        if (err) return callback(err);\n        if (rowCount === 0) return callback(null);\n        callback(null, rowCount > 0);\n      });\n      createMembershipQuery.addParameter('ApplicationId', TYPES.VarChar, membershipData.ApplicationId);\n      createMembershipQuery.addParameter('Email', TYPES.VarChar, membershipData.Email);\n      createMembershipQuery.addParameter('Password', TYPES.VarChar, membershipData.Password);\n      createMembershipQuery.addParameter('PasswordSalt', TYPES.VarChar, membershipData.PasswordSalt);\n      createMembershipQuery.addParameter('UserId', TYPES.VarChar, membershipData.UserId);\n      connection.execSql(createMembershipQuery);\n    });\n    createUserQuery.addParameter('UserName', TYPES.VarChar, userData.UserName);\n    createUserQuery.addParameter('ApplicationId', TYPES.VarChar, userData.ApplicationId);\n    connection.execSql(createUserQuery);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction create(user, callback) {\n  const crypto = require('crypto');\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  /**\n   * hashPassword\n   *\n   * This function hashes a password using HMAC SHA256 algorithm.\n   *\n   * @password    {[string]}    password to be hased\n   * @salt        {[string]}    salt to be used in the hashing process\n   * @callback    {[function]}  callback to be called after hashing the password\n   */\n  function hashPassword(password, salt, callback) {\n    const iterations = 1000;\n    const passwordHashLength = 32;\n    crypto.pbkdf2(password, salt, iterations, passwordHashLength, 'sha1', function (err, hashed) {\n      if (err) return callback(err);\n      const result = Buffer.concat([Buffer.from([0], 1), salt, Buffer.from(hashed, 'binary')]);\n      const resultBase64 = result.toString('base64');\n      callback(null, resultBase64);\n    });\n  }\n  connection.on('debug', function (text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    // console.log(text);\n  }).on('errorMessage', function (text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const createUser =\n      'INSERT INTO UserProfile (UserName) ' +\n      'OUTPUT Inserted.UserId ' +\n      'VALUES (@UserName)';\n    const createUserQuery = new Request(createUser, function (err, rowCount, rows) {\n      if (err || rowCount === 0) return callback(err);\n      const userId = rows[0][0].value;\n      const salt = crypto.randomBytes(16);\n      const createMembership =\n        'INSERT INTO webpages_Membership ' +\n        '(UserId, CreateDate, IsConfirmed, PasswordFailuresSinceLastSuccess, Password, PasswordSalt) ' +\n        'VALUES ' +\n        '(@UserId, GETDATE(), \\'false\\', 0, @Password, \\'\\')';\n      const createMembershipQuery = new Request(createMembership, function (err, rowCount) {\n        if (err || rowCount === 0) return callback(err);\n        callback(null, rowCount > 0);\n      });\n      hashPassword(user.password, salt, function (err, hashedPassword) {\n        if (err) return callback(err);\n        createMembershipQuery.addParameter('Password', TYPES.VarChar, hashedPassword);\n        createMembershipQuery.addParameter('PasswordSalt', TYPES.VarChar, salt.toString('base64'));\n        createMembershipQuery.addParameter('UserId', TYPES.VarChar, userId);\n        connection.execSql(createMembershipQuery);\n      });\n    });\n    createUserQuery.addParameter('UserName', TYPES.VarChar, user.email);\n    connection.execSql(createUserQuery);\n  });\n}\n```\n\n### MongoDB\n\n```\nfunction create(user, callback) {\n  const bcrypt = require('bcrypt');\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    users.findOne({ email: user.email }, function (err, withSameMail) {\n      if (err || withSameMail) {\n        client.close();\n        return callback(err || new Error('the user already exists'));\n      }\n      bcrypt.hash(user.password, 10, function (err, hash) {\n        if (err) {\n          client.close();\n          return callback(err);\n        }\n        user.password = hash;\n        users.insert(user, function (err, inserted) {\n          client.close();\n          if (err) return callback(err);\n          callback(null);\n        });\n      });\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction create(user, callback) {\n  const mysql = require('mysql');\n  const bcrypt = require('bcrypt');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'INSERT INTO users SET ?';\n  bcrypt.hash(user.password, 10, function(err, hash) {\n    if (err) return callback(err);\n    const insert = {\n      password: hash,\n      email: user.email\n    };\n    connection.query(query, insert, function(err, results) {\n      if (err) return callback(err);\n      if (results.length === 0) return callback();\n      callback(null);\n    });\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction create(user, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const bcrypt = require('bcrypt');\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    bcrypt.hash(user.password, 10, function (err, hashedPassword) {\n      if (err) return callback(err);\n      const query = 'INSERT INTO users(email, password) VALUES ($1, $2)';\n      client.query(query, [user.email, hashedPassword], function (err, result) {\n        // NOTE: always call `done()` here to close\n        // the connection to the database\n        done();\n        return callback(err);\n      });\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction create(user, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  const bcrypt = require('bcrypt');\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'INSERT INTO dbo.Users SET Email = @Email, Password = @Password';\n  connection.on('debug', function(text) {\n    console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rows) {\n      if (err) return callback(err);\n      callback(null);\n    });\n    bcrypt.hash(user.password, 10, function(err, hash) {\n      if (err) return callback(err);\n      request.addParameter('Email', TYPES.VarChar, user.email);\n      request.addParameter('Password', TYPES.VarChar, hash);\n      connection.execSql(request);\n    });\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction create (user, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@1.11.0').Connection;\n  var Request = require('tedious@1.11.0').Request;\n  var TYPES = require('tedious@1.11.0').TYPES;\n  var bcrypt = require('bcrypt');\n  var connection = new Connection({\n    userName:  'your-user@your-server-id.database.windows.net',\n    password:  'the-password',\n    server:    'your-server-id.database.windows.net',\n    options:  {\n      database: 'mydb',\n      encrypt:  true\n    }\n  });\n  var query = \"INSERT INTO users (Email, Password) VALUES (@Email, @Password)\";\n  connection.on('debug', function(text) {\n    // Uncomment next line in order to enable debugging messages\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    // Uncomment next line in order to enable information messages\n    // console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var request = new Request(query, function (err, rows) {\n      if (err) { return callback(err); }\n      console.log('rows: ' + rows);\n      callback(null);\n    });\n    bcrypt.hash(user.password, 10, function (err, hashedPassword) {\n      if (err) { return callback(err); }\n      request.addParameter('Email', TYPES.VarChar, user.email);\n      request.addParameter('Password', TYPES.VarChar, hashedPassword);\n      connection.execSql(request);\n    });\n  });\n}\n```\n\n### Request with Basic Auth\n\n```\nfunction create(user, callback) {\n  const request = require('request');\n  request.post({\n    url: 'https://myserviceurl.com/users',\n    json: user\n    //for more options check:\n    //https://github.com/mikeal/request#requestoptions-callback\n  }, function(err, response, body) {\n    if (err) return callback(err);\n    callback(null);\n  });\n}\n```\n\n## Troubleshoot\n\nIf you are unable to create a user in either your legacy database or Auth0:\n\n1.  Check the `console.log()` statements with the Auth0's [Real-time Webtask Logs extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs).\n    \n2.  Find the user in your legacy database and delete accordingly. If the partial user state is in Auth0, use the Management API's [Delete a User](https://auth0.com/docs/api/management/v2#!/Users/delete_users_by_id) endpoint or [Delete a Connection User](https://auth0.com/docs/api/management/v2#!/Connections/delete_users_by_email) endpoint.\n    \n3.  Make sure **Import Mode** is disabled, then configure the create script.\n    \n\n## Learn more\n\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
  "title": "Create Script Templates",
  "description": "Describes custom database action script templates for user creation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete",
  "markdown": "# Delete Script Templates\n\nThe Delete script implements the defined function to delete a specified user from an external database. We recommend naming this function `deleteUser`.\n\nThe script is only used in a [legacy authentication scenario](https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections), and is required if you want to delete a user from Auth0 and your external database in the same operation.\n\n## DeleteUser function\n\nThe `deleteUser` function should:\n\n*   Remove the specified user from the external database.\n    \n*   Return a `null` value if the deletion succeeded.\n    \n*   Return an error if the deletion failed.\n    \n\n### Definition\n\nThe `deleteUser` function accepts two parameters and returns a `callback` function:\n\n```\ndeleteUser(id, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `id` | String | User’s identity `user_id`. Does not start with `auth0`. |\n| `callback` | Function | Used to pass error or profile data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `deleteUser` function. For language-specific examples, read [Language-specific script examples](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete#language-specific-script-examples).\n\n```\nfunction deleteUser(id, callback) {\n  // Send user identifier to external database API\n  let options = {\n    url: \"https://example.com/api/deleteUser\",\n    body: {\n      id: id\n    }\n  };\n\n  send(options, (err, profileData) => {\n    // Return error in callback if deletion failed\n    if (err) {\n      return callback(new Error(\"My custom error message.\"));\n    }\n\n    // Return null value in callback if deletion succeeded\n    return callback(null);\n  });\n}\n```\n\n## Callback function\n\nThe `callback` function accepts one parameter and returns a function.\n\n### Definition\n\n```\ncallback(error): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n\n### Return a success\n\nIf the user was successfully deleted in your external database, return the `callback` function, and pass a `null` value for the `error` parameter.\n\n#### Example\n\n### Return an error\n\nIf an error occurs, return the `callback` function, and pass relevant error information to the `error` parameter.\n\n#### Example\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n\n### JavaScript\n\n```\nfunction remove (id, callback) {\n  // This script remove a user from your existing database.\n  // It is executed whenever a user is deleted from the Management API or Auth0 dashboard.\n  //\n  // There are two ways that this script can finish:\n  // 1. The user was removed successfully:\n  //     callback(null);\n  // 2. Something went wrong while trying to reach your database:\n  //     callback(new Error(\"my error message\"));\n  var msg = \"Please implement the Delete script for this database \" +\n       \"connection at https://manage.auth0.com/#/connections/database\";\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction remove(id, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    executeDelete(['Memberships', 'Users'], function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  });\n  function executeDelete(tables, callback) {\n    const query = tables.map(function(table) {\n      return 'DELETE FROM ' + table + ' WHERE UserId = @UserId';\n    }).join(';');\n    const request = new Request(query, function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n    request.addParameter('UserId', TYPES.VarChar, id);\n    connection.execSql(request);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction remove(id, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  connection.on('debug', function (text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    // console.log(text);\n  }).on('errorMessage', function (text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    executeDelete(['webpages_Membership', 'UserProfile'], function (err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  });\n  function executeDelete(tables, callback) {\n    const query = tables.map(function (table) {\n      return 'DELETE FROM ' + table + ' WHERE UserId = @UserId';\n    }).join(';');\n    const request = new Request(query, function (err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n    request.addParameter('UserId', TYPES.VarChar, id);\n    connection.execSql(request);\n  }\n}\n```\n\n### MongoDB\n\n```\nfunction remove(id, callback) {\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    users.remove({ _id: id }, function (err) {\n      client.close();\n      if (err) return callback(err);\n      callback(null);\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction remove(id, callback) {\n  const mysql = require('mysql');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'DELETE FROM users WHERE id = ?';\n  connection.query(query, [ id ], function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction remove(id, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    const query = 'DELETE FROM users WHERE id = $1';\n    client.query(query, [id], function (err) {\n      // NOTE: always call `done()` here to close\n      // the connection to the database\n      done();\n      return callback(err);\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction remove(id, callback) {\n  // this example uses the \"tedious\" library\n  // more info here: http://pekim.github.io/tedious/index.html\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'DELETE FROM dbo.Users WHERE id = @UserId';\n  connection.on('debug', function (text) {\n    console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n    request.addParameter('UserId', TYPES.VarChar, id);\n    connection.execSql(request);\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction remove (id, callback) {\n  // this example uses the \"tedious\" library\n  // more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@1.11.0').Connection;\n  var Request = require('tedious@1.11.0').Request;\n  var TYPES = require('tedious@1.11.0').TYPES;\n  var connection = new Connection({\n    userName: 'your-user@your-server-id.database.windows.net',\n    password: 'the-password',\n    server: 'your-server-id.database.windows.net',\n    options: {\n      database: 'mydb',\n      encrypt: true\n    }\n  });\n  connection.on('debug', function (text) {\n    console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var query = 'DELETE FROM users WHERE id = @UserId';\n    var request = new Request(query, function (err) {\n      if (err) { return callback(err); }\n      callback(null);\n    });\n    request.addParameter('UserId', TYPES.VarChar, id);\n    connection.execSql(request);\n  });\n}\n```\n\n## Learn more\n\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
  "title": "Delete Script Templates",
  "description": "Describes custom database action script templates for user deletion.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user",
  "markdown": "# Get User Script Templates\n\nThe Get User script implements the function executed to determine the current state of existence of a user. We recommend naming this function `getUser`.\n\nThis script is required for [automatic migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database), and conditionally required for legacy authentication depending on the operations configured for the connection.\n\nIf automatic migration is configured for the connection, the script is executed whenever the following operations occur:\n\n*   Change email\n    \n*   Sign up\n    \n*   Password reset\n    \n\nIf legacy authentication is configured for the connection, the script is executed whenever the following operations occur:\n\n*   Create user\n    \n*   Change email\n    \n*   Change password\n    \n*   Password reset\n    \n\n## Get User function\n\nThe `getUser` function should:\n\n*   Send the user's identifier to the external database's API.\n    \n*   Return the profile data of the user if the user was found.\n    \n*   Return an error if there was an issue determining whether the user exists or not.\n    \n\n### Definition\n\nThe `getUser` function accepts two parameters and returns a `callback` function:\n\n```\ngetUser(email, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `email` | String | The user's email address. |\n| `callback` | Function | Used to pass error or profile data through the pipeline |\n\n### Example\n\nThis is a pseudo-Javascript example of how you could implement the `getUser` function. For language-specific examples, read [Language-specific script examples](#language-specific-script-examples).\n\n```\nfunction getUser(email, callback) {\n  // Send user identifier to external database API\n  let options = {\n    url: \"https://example.com/api/search-users\",\n    body: {\n      email: email\n    }\n  };\n\n  send(options, (err, profileData) => {\n    // Return error in callback if there was an issue finding the user\n    if (err) {\n      return callback(new Error(\"Could not determine if user exists or not.\"));\n    } else {\n      // Return null in callback if user was not found, return profile data in callback if user was found\n      if (!profileData) {\n        return callback(null);\n      } else {\n        let profile = {\n          email: profileData.email,\n          user_id: profileData.userId\n        };\n\n        return callback(null, profile);\n      }\n    }\n  });\n}\n```\n\n## Callback function\n\nThe `callback` function is used to pass user profile data or error data through the pipeline.\n\n### Definition\n\nThe `callback` function accepts up to two parameters and returns a function:\n\n```\ncallback(error[,profile]): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `profile` | Object | Optional | Contains the user's profile data. |\n\n### Return the user profile (user found)\n\nIf the user is found, pass a `null` value to the `error` parameter, and pass the user's profile data to the `profile` parameter in [normalized form](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema). In addition to the standard fields, you can include the `user_metadata`, `app_metadata`, and `mfa_factors` fields.\n\n#### Example\n\n```\nreturn callback(null, {\n    username: \"username\",\n    user_id: \"my-custom-db|username@domain.com\",\n    email: \"username@domain.com\",\n    email_verified: false,\n    user_metadata: {\n        language: \"en\"\n    },\n    app_metadata: {\n        plan: \"full\"\n    },\n    mfa_factors: [\n      {\n        phone: {\n          value: \"+15551234567\"\n        }\n      },\n    ]\n});\n```\n\n### Return no user profile (user not found)\n\nIf the user is not found, pass a `null` value to the `error` parameter, and omit the `profile` parameter.\n\n#### Example\n\n### Return an error\n\nIf an error occurs, pass error data to the `error` parameter with relevant information about what went wrong. For more information, read [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling).\n\n#### Example\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n*   [Axios](#axios)\n    \n*   [Stormpath](#stormpath)\n    \n\n### JavaScript\n\n```\nfunction getByEmail(email, callback) {\n  // This script should retrieve a user profile from your existing database,\n  // without authenticating the user.\n  // It is used to check if a user exists before executing flows that do not\n  // require authentication (signup and password reset).\n  //\n  // There are three ways this script can finish:\n  // 1. A user was successfully found. The profile should be in the following\n  // format: https://auth0.com/docs/users/normalized/auth0/normalized-user-profile-schema.\n  //     callback(null, profile);\n  // 2. A user was not found\n  //     callback(null);\n  // 3. Something went wrong while trying to reach your database:\n  //     callback(new Error(\"my error message\"));\n  const msg = 'Please implement the Get User script for this database connection ' +\n    'at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction getByEmail(email, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true // for Windows Azure\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    var user = {};\n    const query =\n      'SELECT Memberships.UserId, Email, Users.UserName ' +\n      'FROM Memberships INNER JOIN Users ' +\n      'ON Users.UserId = Memberships.UserId ' +\n      'WHERE Memberships.Email = @Username OR Users.UserName = @Username';\n    const getMembershipQuery = new Request(query, function(err, rowCount) {\n      if (err) return callback(err);\n      if (rowCount < 1) return callback();\n      callback(null, user);\n    });\n    getMembershipQuery.addParameter('Username', TYPES.VarChar, email);\n    getMembershipQuery.on('row', function(fields) {\n      user = {\n        user_id: fields.UserId.value,\n        nickname: fields.UserName.value,\n        email: fields.Email.value\n      };\n    });\n    connection.execSql(getMembershipQuery);\n  });\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction getByEmail(email, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true // for Windows Azure\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    var user = {};\n    const query =\n      'SELECT webpages_Membership.UserId, UserName, UserProfile.UserName from webpages_Membership ' +\n      'INNER JOIN UserProfile ON UserProfile.UserId = webpages_Membership.UserId ' +\n      'WHERE UserProfile.UserName = @Username';\n    const getMembershipQuery = new Request(query, function (err, rowCount) {\n      if (err) return callback(err);\n      if (rowCount < 1) return callback();\n      callback(null, user);\n    });\n    getMembershipQuery.addParameter('Username', TYPES.VarChar, email);\n    getMembershipQuery.on('row', function (fields) {\n      user = {\n        user_id: fields.UserId.value,\n        nickname: fields.UserName.value,\n        email: fields.UserName.value\n      };\n    });\n    connection.execSql(getMembershipQuery);\n  });\n}\n```\n\n### MongoDB\n\n```\nfunction getByEmail(email, callback) {\n  const MongoClient = require('mongodb@5.1.0').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    users.findOne({ email: email }, function (err, user) {\n      client.close();\n      if (err) return callback(err);\n      if (!user) return callback(null, null);\n      return callback(null, {\n        user_id: user._id.toString(),\n        nickname: user.nickname,\n        email: user.email\n      });\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction getByEmail(email, callback) {\n  const mysql = require('mysql');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'SELECT id, nickname, email FROM users WHERE email = ?';\n  connection.query(query, [ email ], function(err, results) {\n    if (err || results.length === 0) return callback(err || null);\n    const user = results[0];\n    callback(null, {\n      user_id: user.id.toString(),\n      nickname: user.nickname,\n      email: user.email\n    });\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction loginByEmail(email, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    const query = 'SELECT id, nickname, email FROM users WHERE email = $1';\n    client.query(query, [email], function (err, result) {\n      // NOTE: always call `done()` here to close\n      // the connection to the database\n      done();\n      if (err || result.rows.length === 0) return callback(err);\n      const user = result.rows[0];\n      return callback(null, {\n        user_id: user.id,\n        nickname: user.nickname,\n        email: user.email\n      });\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction getByEmail(email, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'SELECT Id, Nickname, Email FROM dbo.Users WHERE Email = @Email';\n  connection.on('debug', function (text) {\n    console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rowCount, rows) {\n      if (err) return callback(err);\n      callback(null, {\n        user_id: rows[0][0].value,\n        nickname: rows[0][1].value,\n        email: rows[0][2].value\n      });\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction getByEmail (name, callback) {\n  var profile = {\n    user_id:     \"103547991597142817347\",\n    nickname:    \"johnfoo\",\n    email:       \"johnfoo@gmail.com\",\n    name:        \"John Foo\",\n    given_name:  \"John\",\n    family_name: \"Foo\"\n  };\n  callback(null, profile);\n}\n```\n\n### Axios\n\n```\nasync function getUserAsync(email, callback) {\n  //should be updated as new versions of axios are made available (https://auth0-extensions.github.io/canirequire/#axios)\n  const axios = require(\"axios@0.22.0\");\n\n  let response;\n\n  try {\n    response = await axios.post(\n      //store API url in connection settings to better support SDLC environments\n      configuration.baseAPIUrl + \"/getUser\",\n      //user credentials passed as request body\n      {\n        email: email,\n      },\n      {\n        timeout: 10000, //end call gracefully if request times out so script can do necessary callback\n        headers: {\n          //securing api call with apiKey stored in connection settings.\n          //quick and easy approach however using M2M tokens is more secure as\n          // a secret must not be shared between client and API.\n          \"x-api-key\": configuration.apiKey,\n        },\n      }\n    );\n  } catch (e) {\n    if (e.response.status === 404) {\n      //assuming api returns 404 when no user with specified email/username found\n      return callback(null, null);\n    }\n    //callback for any other error type\n    return callback(new Error(e.message));\n  }\n\n  try {\n    let user = response.data;\n\n    //if using multiple custom db connections in your tenant prefix the\n    //user_id with a connection specific key ex: \"connName|\" + user.user_id\n    //this ensures unique user ids across all db connections\n    return callback(null, {\n      user_id: user.user_id,\n      email: user.email,\n    });\n  } catch (e) {\n    return callback(new Error(e.message));\n  }\n}\n```\n\n### Stormpath\n\n```\nfunction getByEmail(email, callback) {\n  // Replace the {yourStormpathClientId} with your Stormpath ID\n  var url = 'https://api.stormpath.com/v1/applications/{yourStormpathClientId}/accounts';\n  // Add your Stormpath API Client ID and Secret\n  var apiCredentials = {\n    user : '{yourStormpathApiId}',\n    password: '{yourStormpathApiSecret}'\n  };\n  // Make a GET request to find a user by email\n  request({\n    url: url,\n    method: 'GET',\n    auth: apiCredentials,\n    qs: { q: email },\n    json: true\n  }, function (error, response, body) {\n    if (response.statusCode !== 200) return callback();\n    var user = body.items[0];\n    if (!user) return callback();\n    var id = user.href.replace('https://api.stormpath.com/v1/accounts/', '');\n    return callback(null, {\n      user_id: id,\n      username: user.username,\n      email: user.email,\n      email_verified: true\n      // Add any additional fields you would like to carry over from Stormpath\n    });\n  });\n}\n```\n\n## Learn more\n\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
  "title": "Get User Script Templates",
  "description": "Describes custom database action script templates for user search.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa/remove-or-change-dashboard-multi-factor-authentication",
  "markdown": "# Remove or Change Dashboard Multi-Factor Authentication\n\nDashboard users can remove or change multi-factor authentication (MFA) factors that are no longer available or wanted. To learn more about MFA for Dashboard users, read [Multi-Factor Authentication for Dashboard Users](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa).\n\n## Remove or change an MFA factor from the Dashboard\n\nDashboard users who can log in with their current MFA factors can follow these steps:\n\n1.  In the top right corner of the Dashboard, click your user name and click [Your profile](https://manage.auth0.com/#/profile).\n    \n    ![Dashboard - Profile - Multi-Factor - Authentication](https://images.ctfassets.net/cdy7uua7fh8z/2NyLNvP92RruwZ46dLPm5x/8ece3df2b550af8dd78368ca36d8a661/MFA.png)\n2.  Find the new authentication factor you want to use and click **\\+ ADD** in that row. Follow the on-screen instructions to complete the enrollment.\n    \n3.  Still in [Your profile](https://manage.auth0.com/#/profile), find the authentication factor you want to stop using and click **REMOVE**.\n    \n4.  Click **Yes** to confirm the removal. \n    \n5.  Auth0 prompts you to authenticate with your current (old) factors. After a successful authentication, Auth0 removes the factor.\n    \n\n## Remove or change a lost MFA factor \n\nDashboard users who **can’t** log in with their current MFA factors can follow these steps:\n\n1.  Attempt to log in to the Dashboard. Auth0 prompts you to authenticate with your current factors.\n    \n    ![Auth0 prompt for Dashboard users to verify their identity](https://images.ctfassets.net/cdy7uua7fh8z/vvOR70jYwToirLkAsl3B4/f5614ad5c9c584f2869829e97bc32ee8/try-another-method.png)\n2.  When Auth0 asks for the device or credentials you’ve lost, click on **Try another method**.\n    \n    ![Auth0 prompt to choose another authentication method to into the dashboard](https://images.ctfassets.net/cdy7uua7fh8z/5wq56Puj4898xL2Ygavhe/b86936213e8efa977cc91600847a08f7/selec-method.png)\n3.  In the Other Methods box, click a different method to authenticate.\n    \n4.  Log in to access the Dashboard.\n    \n5.  In the top right corner of the Dashboard, click your user name and click [Your profile](https://manage.auth0.com/#/profile).\n    \n    ![Dashboard - Profile - Multi-Factor - Authentication](https://images.ctfassets.net/cdy7uua7fh8z/2NyLNvP92RruwZ46dLPm5x/8ece3df2b550af8dd78368ca36d8a661/MFA.png)\n6.  Find the authentication method you can no longer use and click **REMOVE**.\n    \n7.  Click **Yes** to confirm the removal. \n    \n8.  Auth0 prompts you to authenticate using your current factors again. Repeat steps 2-4 to verify your identity. Auth0 removes the lost factor.\n    \n\n## Get help from Auth0 support\n\nIf you are locked out and don’t have access to any of your enabled MFA factors, there is no guarantee that you can regain access to your account. Another administrator must file an Auth0 support ticket on your behalf. In some cases, Auth0 can verify the request and proceed with an MFA reset. However, we may not be able to confirm account ownership. This is why it’s so important to enable multiple and varied factors.\n\nAuth0 support does not reset **end-user** accounts. You are responsible for accounts that access your applications and APIs. To learn about end-user accounts, read [Manage Users](https://auth0.com/docs/manage-users).\n\n## Learn more\n\n*   [Multi-Factor Authentication for Dashboard Users](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa)\n*   [Add Multi-Factor Authentication for Auth0 Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa/add-mfa)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
  "title": "Remove or Change Dashboard Multi-Factor Authentication",
  "description": "Provides steps for when you change authentication factors or lose/retire a device",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login",
  "markdown": "# Login Script Templates\n\nThe Login script implements the function executed each time a user is required to authenticate. We recommend naming this function `login`.\n\nThis script is required for both legacy authentication and for [automatic migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database). If automatic migration is configured for the connection, the migration process will be triggered after the first time the user logs in successfully.\n\n## Login function\n\nThe `login` function should:\n\n*   Send the provided user credentials to the external database’s API.\n    \n*   Return the profile data of the user if authentication is successful.\n    \n*   Return an error if authentication is unsuccessful.\n    \n\n### Definition\n\nThe `login` function accepts three parameters and returns a `callback` function:\n\n```\nlogin(userNameOrEmail, password, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `userNameOrEmail` | String | The user's username or email. |\n| `password` | String | The user's password in plain text. |\n| `callback` | Function | Used to pass error or profile data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `login` function. For language-specific examples, read [Language-specific script examples](#language-specific-script-examples).\n\n```\nfunction login(userNameOrEmail, password, callback) {\n  // Send credentials to external database API\n  let hashedPassword = hash(password);\n\n  let options = {\n    url: \"https://example.com/api/authenticate\",\n    body: {\n      email: userNameOrEmail,\n      password: hashedPassword\n    }\n  };\n\n  send(options, (err, profileData) => {\n    // Return error in callback if authentication is unsuccessful\n    if (err) {\n      return callback(new WrongUsernameOrPasswordError(userNameOrEmail, \"My custom error message.\"));\n    } else {\n      // Return profile data in callback if authentication is successful\n      let profile = {\n        username: profileData.username,\n        email: profileData.emailAddress,\n        user_id: profileData.userId\n      };\n\n      return callback(null, profile);\n    }\n  });\n}\n```\n\n### Encryption\n\nEncrypt the `password` value using a cryptographic hash encryption library such as `bcrypt` to prevent any potential data leak.\n\n#### Example\n\n```\nbcrypt.hash(password, 10, function (err, hash) {\n    if (err) {\n        return callback(err);\n    } else {\n        // Return hashed password\n    }\n});\n```\n\n## Callback function\n\nThe `callback` function is used to pass user profile data or error data through the pipeline.\n\n### Definition\n\nThe `callback` function accepts up to two parameters and returns a function:\n\n```\ncallback(error[, profile]): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `profile` | Object | Optional | Contains the user's profile data. |\n\n### Return the user profile\n\nIf the user authenticates successfully, their profile data must be returned in the `profile` object in [normalized form](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema). In addition to the standard fields, you can include the `user_metadata`, `app_metadata`, and `mfa_factors` fields.\n\n#### Example\n\n```\nreturn callback(null, {\n    username: \"username\",\n    user_id: \"my-custom-db|username@domain.com\",\n    email: \"username@domain.com\",\n    email_verified: false,\n    user_metadata: {\n        language: \"en\"\n    },\n    app_metadata: {\n        plan: \"full\"\n    },\n    mfa_factors: [\n      {\n        phone: {\n          value: \"+15551234567\"\n        }\n      },\n    ]\n});\n```\n\n### Return an error\n\nIf an error occurs, the `error` parameter should contain relevant information about what went wrong.\n\n#### WrongUsernameOrPasswordError type object\n\nThe `WrongUsernameOrPasswordError` custom error type object allows you to pass data that will be displayed in your [Tenant Logs](https://auth0.com/docs/deploy-monitor/logs).\n\n##### Constructor\n\nThe `WrongUsernameOrPasswordError` constructor accepts up to two parameters:\n\n```\nnew WrongUsernameOrPasswordError(userNameOrEmail[, message]): WrongUsernameOrPasswordError\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `userNameOrEmail` | String | Required | Contains the user's username or email, or a `null` value. |\n| `message` | String | Optional | Contains information about the error. |\n\n#### Return error with username or email\n\nIf you return an error with a value for the `userNameOrEmail` field, Auth0 will record an `fp` tenant log event.\n\n##### Example\n\n```\nreturn callback(new WrongUsernameOrPasswordError(userNameOrEmail, \"My custom error message\"));\n```\n\n| **Tenant Log Event Field** | **Value** |\n| --- | --- |\n| **Code** | `fp` |\n| **Event** | Failed Login (Incorrect Password) |\n| **Description** | `My custom error message` |\n\n#### Return error without username or email\n\nIf you return an error with a `null` value for the `userNameOrEmail` field, Auth0 will record an `fu` tenant log event.\n\n##### Example\n\n```\nreturn callback(new WrongUsernameOrPasswordError(null, \"My custom error message\"));\n```\n\n| **Tenant Log Event Field** | **Value** |\n| --- | --- |\n| **Code** | `fu` |\n| **Event** | Failed Login (Invalid Email/Username) |\n| **Description** | `My custom error message` |\n\n## Sync user profile attributes at each login\n\nEnable the **Sync user profile attributes at each login** setting if you want Auth0 to update the `name`, `nickname`, `given_name`, `family_name`, and/or `picture` fields with the values returned from the external database on each login.\n\nIf you do not enable this setting, the values returned from the external database the first time the user logs in will persist on subsequent logins, even if they've changed in the external database.\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n*   [Axios](#axios)\n    \n*   [Stormpath](#stormpath)\n    \n\n### JavaScript\n\n```\nfunction login(email, password, callback) {\n  // This script should authenticate a user against the credentials stored in\n  // your database.\n  // It is executed when a user attempts to log in or immediately after signing\n  // up (as a verification that the user was successfully signed up).\n  //\n  // Everything returned by this script will be set as part of the user profile\n  // and will be visible by any of the tenant admins. Avoid adding attributes\n  // with values such as passwords, keys, secrets, etc.\n  //\n  // The `password` parameter of this function is in plain text. It must be\n  // hashed/salted to match whatever is stored in your database. For example:\n  //\n  //     var bcrypt = require('bcrypt@0.8.5');\n  //     bcrypt.compare(password, dbPasswordHash, function(err, res)) { ... }\n  //\n  // There are three ways this script can finish:\n  // 1. The user's credentials are valid. The returned user profile should be in\n  // the following format: https://auth0.com/docs/users/normalized/auth0/normalized-user-profile-schema\n  //     var profile = {\n  //       user_id: ..., // user_id is mandatory\n  //       email: ...,\n  //       [...]\n  //     };\n  //     callback(null, profile);\n  // 2. The user's credentials are invalid\n  //     callback(new WrongUsernameOrPasswordError(email, \"my error message\"));\n  // 3. Something went wrong while trying to reach your database\n  //     callback(new Error(\"my error message\"));\n  //\n  // A list of Node.js modules which can be referenced is available here:\n  //\n  //    https://tehsis.github.io/webtaskio-canirequire/\n  const msg = 'Please implement the Login script for this database connection ' +\n    'at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction login(email, password, callback) {\n  const crypto = require('crypto');\n  const sqlserver = require('tedious@11.0.3');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true // for Windows Azure\n    }\n  });\n  /**\n   * hashPassword\n   *\n   * This function creates a hashed version of the password to store in the database.\n   *\n   * @password  {[string]}      the password entered by the user\n   * @return    {[string]}      the hashed password\n   */\n  function hashPassword(password, salt) {\n    // the default implementation uses HMACSHA256 and since Key length is 64\n    // and default salt is 16 bytes, Membership will fill the buffer repeating the salt\n    const key = Buffer.concat([salt, salt, salt, salt]);\n    const hmac = crypto.createHmac('sha256', key);\n    hmac.update(Buffer.from(password, 'ucs2'));\n    return hmac.digest('base64');\n  }\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    getMembershipUser(email, function(err, user) {\n      if (err || !user || !user.profile || !user.password) return callback(err || new WrongUsernameOrPasswordError(email));\n      const salt = Buffer.from(user.password.salt, 'base64');\n      if (hashPassword(password, salt).toString('base64') !== user.password.password) {\n        return callback(new WrongUsernameOrPasswordError(email));\n      }\n      callback(null, user.profile);\n    });\n  });\n\n  // Membership Provider implementation used on Microsoft.AspNet.Providers NuGet\n  /**\n   * getMembershipUser\n   *\n   * This function gets a username or email and returns a the user membership provider\n   * info, password hashes and salt\n   *\n   * @usernameOrEmail  {[string]}       the username or email, the method will do a\n   *                                    query on both with an OR\n   *\n   * @callback         {[Function]}     first argument will be the Error if any,\n   *                                    and second argument will be a user object\n   */\n  function getMembershipUser(usernameOrEmail, done) {\n    var user = null;\n    const query =\n      'SELECT Memberships.UserId, Email, Users.UserName, Password ' +\n      'FROM Memberships INNER JOIN Users ' +\n      'ON Users.UserId = Memberships.UserId ' +\n      'WHERE Memberships.Email = @Username OR Users.UserName = @Username';\n    const getMembershipQuery = new Request(query, function(err, rowCount) {\n      if (err || rowCount < 1) return done(err);\n      done(err, user);\n    });\n    getMembershipQuery.addParameter('Username', TYPES.VarChar, usernameOrEmail);\n    getMembershipQuery.on('row', function(fields) {\n      user = {\n        profile: {\n          user_id: fields.UserId.value,\n          nickname: fields.UserName.value,\n          email: fields.Email.value,\n        },\n        password: {\n          password: fields.Password.value,\n          salt: fields.PasswordSalt.value\n        }\n      };\n    });\n    connection.execSql(getMembershipQuery);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction login(email, password, callback) {\n  const crypto = require('crypto');\n  const sqlserver = require('tedious@11.0.3');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true // for Windows Azure\n    }\n  });\n  function fixedTimeComparison(a, b) {\n    var mismatch = (a.length === b.length ? 0 : 1);\n    if (mismatch) {\n      b = a;\n    }\n    for (var i = 0, il = a.length; i < il; ++i) {\n      const ac = a.charCodeAt(i);\n      const bc = b.charCodeAt(i);\n      mismatch += (ac === bc ? 0 : 1);\n    }\n    return (mismatch === 0);\n  }\n\n  /**\n   * validatePassword\n   *\n   * This function gets the password entered by the user, and the original password\n   * hash and salt from database and performs an HMAC SHA256 hash.\n   *\n   * @password      {[string]}      the password entered by the user\n   * @originalHash  {[string]}      the original password hashed from the database\n   *                                (including the salt).\n   * @return        {[bool]}        true if password validates\n   */\n  function validatePassword(password, originalHash, callback) {\n    const iterations = 1000;\n    const hashBytes = Buffer.from(originalHash, 'base64');\n    const salt = hashBytes.slice(1, 17);\n    const hash = hashBytes.slice(17, 49);\n    crypto.pbkdf2(password, salt, iterations, hash.length, 'sha1', function(err, hashed) {\n      if (err) return callback(err);\n      const hashedBase64 = Buffer.from(hashed, 'binary').toString('base64');\n      const isValid = fixedTimeComparison(hash.toString('base64'), hashedBase64);\n      return callback(null, isValid);\n    });\n  }\n\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    getMembershipUser(email, function(err, user) {\n      if (err || !user || !user.profile) return callback(err || new WrongUsernameOrPasswordError(email));\n      validatePassword(password, user.password, function(err, isValid) {\n        if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n        callback(null, user.profile);\n      });\n    });\n  });\n\n  // Membership Provider implementation used on Microsoft.AspNet.Providers NuGet\n  /**\n   * getMembershipUser\n   *\n   * This function gets a username or email and returns a user info, password hashes and salt\n   *\n   * @usernameOrEamil   {[string]}    the username or email, the method will do a query\n   *                                  on both with an OR\n   * @callback          {[Function]}  first argument will be the Error if any, and second\n   *                                  argument will be a user object\n   */\n  function getMembershipUser(usernameOrEmail, done) {\n    var user = null;\n    const query =\n      'SELECT webpages_Membership.UserId, UserName, UserProfile.UserName, Password from webpages_Membership ' +\n      'INNER JOIN UserProfile ON UserProfile.UserId = webpages_Membership.UserId ' +\n      'WHERE UserProfile.UserName = @Username';\n    const getMembershipQuery = new Request(query, function(err, rowCount) {\n      if (err || rowCount < 1) return done(err);\n      done(err, user);\n    });\n    getMembershipQuery.addParameter('Username', TYPES.VarChar, usernameOrEmail);\n    getMembershipQuery.on('row', function(fields) {\n      user = {\n        profile: {\n          user_id: fields.UserId.value,\n          nickname: fields.UserName.value,\n          email: fields.UserName.value,\n        },\n        password: fields.Password.value\n      };\n    });\n    connection.execSql(getMembershipQuery);\n  }\n}\n```\n\n### MongoDB\n\n```\nfunction login(email, password, callback) {\n  const bcrypt = require('bcrypt');\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    users.findOne({ email: email }, function (err, user) {\n      if (err || !user) {\n        client.close();\n        return callback(err || new WrongUsernameOrPasswordError(email));\n      }\n      bcrypt.compare(password, user.password, function (err, isValid) {\n        client.close();\n        if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n        return callback(null, {\n            user_id: user._id.toString(),\n            nickname: user.nickname,\n            email: user.email\n          });\n      });\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction login(email, password, callback) {\n  const mysql = require('mysql');\n  const bcrypt = require('bcrypt');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'SELECT id, nickname, email, password FROM users WHERE email = ?';\n  connection.query(query, [ email ], function(err, results) {\n    if (err) return callback(err);\n    if (results.length === 0) return callback(new WrongUsernameOrPasswordError(email));\n    const user = results[0];\n    bcrypt.compare(password, user.password, function(err, isValid) {\n      if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n      callback(null, {\n        user_id: user.id.toString(),\n        nickname: user.nickname,\n        email: user.email\n      });\n    });\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction login(email, password, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const bcrypt = require('bcrypt');\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    const query = 'SELECT id, nickname, email, password FROM users WHERE email = $1';\n    client.query(query, [email], function (err, result) {\n      // NOTE: always call `done()` here to close\n      // the connection to the database\n      done();\n      if (err || result.rows.length === 0) return callback(err || new WrongUsernameOrPasswordError(email));\n      const user = result.rows[0];\n      bcrypt.compare(password, user.password, function (err, isValid) {\n        if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n        return callback(null, {\n          user_id: user.id,\n          nickname: user.nickname,\n          email: user.email\n        });\n      });\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction login(email, password, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  const bcrypt = require('bcrypt');\n  const sqlserver = require('tedious@11.0.3');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb',\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  const query = 'SELECT Id, Nickname, Email, Password FROM dbo.Users WHERE Email = @Email';\n  connection.on('debug', function (text) {\n    console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rowCount, rows) {\n      if (err || rowCount < 1) return callback(err || new WrongUsernameOrPasswordError(email));\n      bcrypt.compare(password, rows[0][3].value, function (err, isValid) {\n        if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n        callback(null, {\n          user_id: rows[0][0].value,\n          nickname: rows[0][1].value,\n          email: rows[0][2].value\n        });\n      });\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction login(email, password, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@11.0.3').Connection;\n  var Request = require('tedious@11.0.3').Request;\n  var TYPES = require('tedious@11.0.3').TYPES;\n  var bcrypt = require('bcrypt');\n  var connection = new Connection({\n    userName: 'your-user@your-server-id.database.windows.net',\n    password: 'the-password',\n    server: 'your-server-id.database.windows.net',\n    options: {\n      database: 'mydb',\n      encrypt: true,\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  var query = \"SELECT Id, Email, Password \" +\n    \"FROM dbo.Users WHERE Email = @Email\";\n  connection.on('debug', function (text) {\n    // Uncomment next line in order to enable debugging messages\n    // console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n    return callback(text);\n  }).on('infoMessage', function (text) {\n    // Uncomment next line in order to enable information messages\n    // console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var request = new Request(query, function (err, rowCount, rows) {\n      if (err) {\n        callback(new Error(err));\n      } else if (rowCount < 1) {\n        callback(new WrongUsernameOrPasswordError(email));\n      } else {\n        bcrypt.compare(password, rows[0][2].value, function (err, isValid) {\n          if (err) { callback(new Error(err)); }\n          else if (!isValid) { callback(new WrongUsernameOrPasswordError(email)); }\n          else {\n            callback(null, {\n              user_id: rows[0][0].value,\n              email: rows[0][1].value\n            });\n          }\n        });\n      }\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n### Axios\n\n```\nasync function loginAsync(email, password, callback) {\n  //should be updated as new versions of axios are made available (https://auth0-extensions.github.io/canirequire/#axios)\n  const axios = require(\"axios@0.22.0\");\n\n  let response;\n\n  try {\n    response = await axios.post(\n      //store API url in connection settings to better support SDLC environments\n      configuration.baseAPIUrl + \"/login\",\n      //user credentials passed as request body\n      {\n        email: email,\n        password: password,\n      },\n      {\n        timeout: 10000, //end call gracefully if request times out so script can do necessary callback\n        headers: {\n          //securing api call with apiKey stored in connection settings.\n          //quick and easy approach however using M2M tokens is more secure as\n          // a secret must not be shared between client and API.\n          \"x-api-key\": configuration.apiKey,\n        },\n      }\n    );\n  } catch (e) {\n    if (e.response.status === 404) {\n      //assuming api returns 404 when email/username/password invalid\n      return callback(\n        new WrongUsernameOrPasswordError(email, \"Invalid credentials provided.\")\n      );\n    }\n    //callback for any other error type\n    return callback(new Error(e.message));\n  }\n\n  try {\n    let user = response.data;\n\n    //if using multiple custom db connections in your tenant prefix the\n    //user_id with a connection specific key ex: \"connName|\" + user.user_id\n    //this ensures unique user ids across all db connections\n    return callback(null, {\n      user_id: user.user_id,\n      email: user.email,\n    });\n  } catch (e) {\n    return callback(new Error(e.message));\n  }\n}\n```\n\n### Stormpath\n\n```\nfunction login(username, password, callback) {\n  // Replace the {yourStormpathClientId} with your Stormpath ID\n  var url = 'https://api.stormpath.com/v1/applications/{yourStormpathClientId}/loginAttempts';\n  // Add your Stormpath API Client ID and Secret\n  var apiCredentials = {\n    user : '{yourStormpathApiId}',\n    password: '{yourStormpathApiSecret}'\n  };\n  // Stormpath requires the user credentials be passed in as a base64 encoded message\n  var credentials = Buffer.from(username + ':' + password).toString('base64');\n  // Make a POST request to authenticate a user\n  request({\n    url: url,\n    method: 'POST',\n    auth: apiCredentials,\n    json: {\n      type: 'basic',\n      // Passing in the base64 encoded credentials\n      value: credentials\n    }\n  }, function (error, response, body) {\n    // If response is successful we'll continue\n    if (response.statusCode !== 200) return callback();\n    // A successful response will return a URL to get the user information\n    var accountUrl = body.account.href;\n    // Make a second request to get the user info.\n    request({\n      url: accountUrl,\n      auth: apiCredentials,\n      json: true\n    }, function (errorUserInfo, responseUserInfo, bodyUserInfo) {\n      // If we get a successful response, we'll process it\n      if (responseUserInfo.statusCode !== 200) return callback();\n      // To get the user identifier, we'll strip out the Stormpath API\n      var id = bodyUserInfo.href.replace('https://api.stormpath.com/v1/accounts/', '');\n      // Finally, we'll set the data we want to store in Auth0 and migrate the user\n      return callback(null, {\n        user_id : id,\n        username: bodyUserInfo.username,\n        email: bodyUserInfo.email,\n        // We set the users email_verified to true as we assume if they were a valid\n        // user in Stormpath, they have already verified their email\n        // If this field is not set, the user will get an email asking them to verify\n        // their account. You can decide how to handle this for your use case\n        email_verified: true\n        // Add any additional fields you would like to carry over from Stormpath\n      });\n    });\n  });\n}\n```\n\n## Learn more\n\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
  "title": "Login Script Templates",
  "description": "Describes custom database action script templates for user login.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email",
  "markdown": "# Change Email Script Template\n\nThe Change Email script implements the defined function when a user's email address or their email address verification status changes. We recommend naming this function `changeEmail`.\n\nThe script is only used in a [legacy authentication scenario](https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections), and is required if you want to update a user's email address (and/or email address verification status) in Auth0 and your external database in the same operation.\n\nThe Change Email script is not configurable through the Auth0 Dashboard. To manage this script, you must use the Auth0 Management API [Create a connection](https://auth0.com/docs/api/management/v2#!/Connections/post_connections) or [Update a connection](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) endpoint, or the [Auth0 Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool).\n\n## ChangeEmail function\n\nThe changeEmail function should:\n\n*   Update the user's email address in the external database.\n    \n*   Return an error if the operation failed or an error occurred.\n    \n\n### Definition\n\nThe `changeEmail` function accepts four parameters and returns a `callback` function:\n\n```\nchangeEmail(email, newEmail, verified, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `email` | String | User's current email address. |\n| `newEmail` | String | Value to be set as user's new email address in external database. |\n| `verified` | Boolean | Email verification status of the new email address. |\n| `callback` | Function | Used to pass error data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `changeEmail` function:\n\n```\nfunction (email, newEmail, verified, callback) {\n  // Prepare the API call\n  let options = {\n    url: \"https://example.com/api/users\",\n    action: \"PATCH\",\n    body: {\n      email: email,\n      new_email: newEmail,\n      email_verified: verified\n    }\n  };\n\n  // Call the API\n  send(options, err => {\n    // Return `false` value in callback if operation failed\n    if (err && err.id == \"FAIL_CHANGE_EMAIL\") {\n      return callback(null, false);\n    } else if (err) {\n      // Return error in callback if unspecified error occurred\n      return callback(new Error(\"My custom error message.\"));\n    }\n\n    // Return `true` value in callback if operation succeeded\n    return callback(null, true);\n  });\n```\n\n## Callback function\n\nThe `callback` function accepts two parameters and returns a function.\n\n### Definition\n\n```\ncallback(error, operationResult): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `operationResult` | Boolean | Optional | Indicates the result of the change email operation. |\n\n### Return a success\n\nIf the change email operation succeeded, return the `callback` function, and pass a `null` value as the `error` parameter and a `true` value as the `operationResult` parameter:\n\n```\nreturn callback(null, true);\n```\n\n### Return a failure\n\nIf the change email operation failed, return the `callback` function, and pass a `null` value as the `error` parameter and a `false` value as the `operationResult` parameter:\n\n```\nreturn callback(null, false);\n```\n\n### Return an error\n\nIf an error occurred, return the `callback` function, and pass relevant error information as the `error` parameter:\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Learn more\n\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)",
  "title": "Change Email Script Template",
  "description": "Describes the custom database action script for changing a user's email.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/manage-permissions",
  "markdown": "# Manage Role-Based Access Control Permissions\n\n##### Manage Role-Based Access Control Permissions\n\n[Contact sales](https://auth0.com/get-started?place=header&type=button&text=talk%20to%20sales) Log in\n\n[\n\n###### Manage Users\n\n](https://auth0.com/docs/manage-users)\n\nManage Users\n\n*   [User Accounts](https://auth0.com/docs/manage-users/user-accounts \"User Accounts\")\n*   [User Migration](https://auth0.com/docs/manage-users/user-migration \"User Migration\")\n*   [User Search](https://auth0.com/docs/manage-users/user-search \"User Search\")\n*   [Organizations](https://auth0.com/docs/manage-users/organizations \"Organizations\")\n\nManage Access\n\n*   [Access Control](https://auth0.com/docs/manage-users/access-control \"Access Control\")\n*   [Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/rbac \"Role-Based Access Control\")\n*   [Authorization Policies](https://auth0.com/docs/manage-users/access-control/authorization-policies \"Authorization Policies\")\n*   [Rules for Authorization Policies](https://auth0.com/docs/manage-users/access-control/rules-for-authorization-policies \"Rules for Authorization Policies\")\n*   [Sample Use Cases: Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/sample-use-cases-role-based-access-control \"Sample Use Cases: Role-Based Access Control\")\n*   [Sample Use Cases: Actions with Authorization](https://auth0.com/docs/manage-users/access-control/sample-use-cases-actions-with-authorization \"Sample Use Cases: Actions with Authorization\")\n*   [Sample Use Cases: Rules with Authorization](https://auth0.com/docs/manage-users/access-control/sample-use-cases-rules-with-authorization \"Sample Use Cases: Rules with Authorization\")\n*   [Authorization Core vs. Authorization Extension](https://auth0.com/docs/manage-users/access-control/authorization-core-vs-authorization-extension \"Authorization Core vs. Authorization Extension\")\n*   [Configure Core RBAC](https://auth0.com/docs/manage-users/access-control/configure-core-rbac \"Configure Core RBAC\")\n*   [Manage Role-Based Access Control Roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles \"Manage Role-Based Access Control Roles\")\n*   [Manage Role-Based Access Control Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users \"Manage Role-Based Access Control Users\")\n*   [Manage Role-Based Access Control Permissions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/manage-permissions \"Manage Role-Based Access Control Permissions\")\n*   [Enable Role-Based Access Control for APIs](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/enable-role-based-access-control-for-apis \"Enable Role-Based Access Control for APIs\")\n*   [Sessions](https://auth0.com/docs/manage-users/sessions \"Sessions\")\n*   [Cookies](https://auth0.com/docs/manage-users/cookies \"Cookies\")\n\nThis guide will show you how to manage permissions in a [role-based access control (RBAC)](https://auth0.com/docs/authorization/concepts/rbac) system. These permissions are used with the API Authorization Core feature set.\n\nWe provide various functions to help you manage your permissions, which you can access through either the Auth0 Dashboard or the Auth0 Management API:\n\n*   [Add API permissions](https://auth0.com/docs/get-started/apis/add-api-permissions)\n    \n*   [Delete API permissions](https://auth0.com/docs/get-started/apis/delete-api-permissions)\n    \n*   [Add permissions to roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/add-permissions-to-roles)\n    \n*   [Assign permissions to users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-permissions-to-users)\n    \n*   [View role permissions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/view-role-permissions)\n    \n*   [View user permissions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/view-user-permissions)\n    \n*   [Remove role permissions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/remove-permissions-from-roles)\n    \n*   [Remove user permissions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/remove-permissions-from-users)\n    \n\n## Learn more\n\n*   [Manage Role-Based Access Control Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users)\n*   [Manage Role-Based Access Control Roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles)\n\nWas this article helpful?",
  "title": "Manage Role-Based Access Control Permissions",
  "description": "Learn how to manage permissions in a role-based access control (RBAC) system using the Auth0 Management Dashboard. For use with Auth0's API Authorization Core feature set.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users",
  "markdown": "# Manage Role-Based Access Control Users\n\n##### Manage Role-Based Access Control Users\n\nManage Users\n\n*   [User Accounts](https://auth0.com/docs/manage-users/user-accounts \"User Accounts\")\n*   [User Migration](https://auth0.com/docs/manage-users/user-migration \"User Migration\")\n*   [User Search](https://auth0.com/docs/manage-users/user-search \"User Search\")\n*   [Organizations](https://auth0.com/docs/manage-users/organizations \"Organizations\")\n\nManage Access\n\n*   [Access Control](https://auth0.com/docs/manage-users/access-control \"Access Control\")\n*   [Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/rbac \"Role-Based Access Control\")\n*   [Authorization Policies](https://auth0.com/docs/manage-users/access-control/authorization-policies \"Authorization Policies\")\n*   [Rules for Authorization Policies](https://auth0.com/docs/manage-users/access-control/rules-for-authorization-policies \"Rules for Authorization Policies\")\n*   [Sample Use Cases: Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/sample-use-cases-role-based-access-control \"Sample Use Cases: Role-Based Access Control\")\n*   [Sample Use Cases: Actions with Authorization](https://auth0.com/docs/manage-users/access-control/sample-use-cases-actions-with-authorization \"Sample Use Cases: Actions with Authorization\")\n*   [Sample Use Cases: Rules with Authorization](https://auth0.com/docs/manage-users/access-control/sample-use-cases-rules-with-authorization \"Sample Use Cases: Rules with Authorization\")\n*   [Authorization Core vs. Authorization Extension](https://auth0.com/docs/manage-users/access-control/authorization-core-vs-authorization-extension \"Authorization Core vs. Authorization Extension\")\n*   [Configure Core RBAC](https://auth0.com/docs/manage-users/access-control/configure-core-rbac \"Configure Core RBAC\")\n*   [Manage Role-Based Access Control Roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles \"Manage Role-Based Access Control Roles\")\n*   [Manage Role-Based Access Control Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users \"Manage Role-Based Access Control Users\")\n*   [View Roles Assigned to Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/view-user-roles \"View Roles Assigned to Users\")\n*   [View User Permissions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/view-user-permissions \"View User Permissions\")\n*   [Remove Roles from Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/remove-roles-from-users \"Remove Roles from Users\")\n*   [Remove Permissions from Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/remove-permissions-from-users \"Remove Permissions from Users\")\n*   [Assign Roles to Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-roles-to-users \"Assign Roles to Users\")\n*   [Assign Permissions to Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-permissions-to-users \"Assign Permissions to Users\")\n*   [Manage Role-Based Access Control Permissions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/manage-permissions \"Manage Role-Based Access Control Permissions\")\n*   [Enable Role-Based Access Control for APIs](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/enable-role-based-access-control-for-apis \"Enable Role-Based Access Control for APIs\")\n*   [Sessions](https://auth0.com/docs/manage-users/sessions \"Sessions\")\n*   [Cookies](https://auth0.com/docs/manage-users/cookies \"Cookies\")\n\nWas this article helpful?",
  "title": "Manage Role-Based Access Control Users",
  "description": "Learn how to manage users in a role-based access control (RBAC) system using the Auth0 Management Dashboard. For use with Auth0's API Authorization Core feature set.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts",
  "markdown": "# Custom Database Connection and Action Script Best Practices\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nExtensibility provides the ability to add custom login in Auth0 as a mechanism for building out last-mile solutions for Identity and Access Management (IdAM). Auth0 extensibility comes in several forms:\n\n*   [**Actions**](https://auth0.com/docs/customize/actions): Actions are secure, tenant-specific, versioned functions written in Node.js that execute at certain points within the Auth0 platform. Use actions to customize and extend Auth0's capabilities with custom login.\n    \n*   [Rules](https://auth0.com/docs/customize/rules): Run when artifacts for user authenticity are generated. For example:\n    \n    *   ID Token in OpenID Connect (OIDC)\n        \n    *   Access Token in OAuth 2.0\n        \n    *   An assertion in SAML\n        \n*   [Hooks](https://auth0.com/docs/customize/hooks): Provide additional extensibility when there is an exchange of non-user-related artifacts and when user identities are created such as pre-user registration and post-user registration.\n    \n*   **Scripts for both custom database connections and migrations**: Used to integrate with an existing user identity store or where automatic user migration from an independent or legacy identity store are required. For more more configuration information, review [Create Custom Database Connections.](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection)\n    \n\nEach extensibility type uses Node.js running on the Auth0 platform in an Auth0 tenant.\n\nWhatever the use case, Auth0 extensibility provides comprehensive and sophisticated capability to tailor IdAM operations to your exact requirements. However, if not utilized in the right way, this can open up the potential for improper or unintended use which can lead to problematic situations down the line. In an attempt to address matters ahead of time, this document provides best practice guidance to both designers and implementers, and we recommend reading it in its entirety at least once, even if you've already started your journey with Auth0.\n\n## Learn more\n\n*   [Custom Database Connection Anatomy Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/anatomy)\n*   [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment)\n*   [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution)\n*   [Custom Database Connection Security Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/connection-security)\n*   [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices)\n*   [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)",
  "title": "Custom Database Connection and Action Script Best Practices",
  "description": "Learn about best practices for custom database connections and database action scripts.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify",
  "markdown": "# Verify Script Templates\n\nThe Verify script implements the function executed to mark the verification status of a user’s email address in an external database. We recommend naming this function `verify`.\n\nThis script is only used in legacy authentication scenarios, and is required to support user email address verification. A verified email address is critical to a number of workflow scenarios in Auth0, and implementing this script will provide support for these out of the box.\n\nIf it's enabled, this script is executed when a user clicks on the link in the verification email sent by Auth0.\n\n## Verify function\n\nThe `verify` function should:\n\n*   Update the `email_verified` (or equivalent) attribute in the user's profile in the external database.\n    \n*   Return `true` if the update action succeeded.\n    \n*   Return an error if the update action failed.\n    \n\n### Definition\n\nThe `verify` function accepts two parameters and returns a `callback` function:\n\n```\nverify(email, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `email` | String | User's email address. |\n| `callback` | Function | Used to pass error or profile data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `login` function. For language-specific examples, read [Language-specific script examples](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify#language-specific-script-examples).\n\n```\nfunction verify(email, callback) {\n  // Send email to external database API\n  let options = {\n    url: \"https://example.com/api/verify\",\n    body: {\n      email: email\n    }\n  };\n\n  send(options, (err) => {\n    // Return error in callback if update failed\n    if (err) {\n      return callback(new Error(email, \"My custom error message.\"));\n    } else {\n      // Return true in callback if update succeeded\n      return callback(null, true);\n    }\n  });\n}\n```\n\n## Callback function\n\nThe `callback` function is used to pass user profile data or error data through the pipeline.\n\n### Definition\n\nThe `callback` function accepts up to two parameters and returns a function:\n\n```\ncallback(error, [verified]): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `verified` | Boolean | Optional | Contains value that represents the user's verification status in the external database (`true` or `false`). Only required if the value is `true`. |\n\n### Return a success\n\nIf the user's verification status was updated successfully in the external database, pass a `null` value for the `error` parameter, and a `true` value for the `verified` parameter.\n\n#### Example\n\n### Return an error\n\nIf an error occurs, the `error` parameter should contain relevant information about what went wrong.\n\n#### Example\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n\n### JavaScript\n\n```\nfunction verify(email, callback) {\n  // This script should mark the current user's email address as verified in\n  // your database.\n  // It is executed whenever a user clicks the verification link sent by email.\n  // These emails can be customized at https://manage.auth0.com/#/emails.\n  // It is safe to assume that the user's email already exists in your database,\n  // because verification emails, if enabled, are sent immediately after a\n  // successful signup.\n  //\n  // There are two ways that this script can finish:\n  // 1. The user's email was verified successfully\n  //     callback(null, true);\n  // 2. Something went wrong while trying to reach your database:\n  //     callback(new Error(\"my error message\"));\n  //\n  // If an error is returned, it will be passed to the query string of the page\n  // where the user is being redirected to after clicking the verification link.\n  // For example, returning `callback(new Error(\"error\"))` and redirecting to\n  // https://example.com would redirect to the following URL:\n  //     https://example.com?email=alice%40example.com&message=error&success=false\n  const msg = 'Please implement the Verify script for this database connection ' +\n    'at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction verify(email, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    verifyMembershipUser(email, function(err, wasUpdated) {\n      if (err) return callback(err); // this will return a 500\n      callback(null, wasUpdated);\n    });\n  });\n  function verifyMembershipUser(email, callback) {\n    // isApproved field is the email verification flag\n    const updateMembership =\n      'UPDATE Memberships SET isApproved = \\'true\\' ' +\n      'WHERE isApproved = \\'false\\' AND Email = @Email';\n    const updateMembershipQuery = new Request(updateMembership, function(err, rowCount) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, rowCount > 0);\n    });\n    updateMembershipQuery.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(updateMembershipQuery);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction verify (email, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    verifyMembershipUser(email, function(err, wasUpdated) {\n      if (err) return callback(err); // this will return a 500\n      callback(null, wasUpdated);\n    });\n  });\n  function findUserId(email, callback) {\n    const findUserIdFromEmail =\n      'SELECT UserProfile.UserId FROM ' +\n      'UserProfile INNER JOIN webpages_Membership ' +\n      'ON UserProfile.UserId = webpages_Membership.UserId ' +\n      'WHERE UserName = @Username';\n    const findUserIdFromEmailQuery = new Request(findUserIdFromEmail, function (err, rowCount, rows) {\n      if (err || rowCount < 1) return callback(err);\n      const userId = rows[0][0].value;\n      callback(null, userId);\n    });\n    findUserIdFromEmailQuery.addParameter('Username', TYPES.VarChar, email);\n    connection.execSql(findUserIdFromEmailQuery);\n  }\n  function verifyMembershipUser(email, callback) {\n    findUserId(email, function (err, userId) {\n      if (err || !userId) return callback(err);\n      // isConfirmed field is the email verification flag\n      const updateMembership =\n        'UPDATE webpages_Membership SET isConfirmed = \\'true\\' ' +\n        'WHERE isConfirmed = \\'false\\' AND UserId = @UserId';\n      const updateMembershipQuery = new Request(updateMembership, function (err, rowCount) {\n        return callback(err, rowCount > 0);\n      });\n      updateMembershipQuery.addParameter('UserId', TYPES.VarChar, userId);\n      connection.execSql(updateMembershipQuery);\n    });\n  }\n}\n```\n\n### MongoDB\n\n```\nfunction verify (email, callback) {\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    const query = { email: email, email_verified: false };\n    users.update(query, { $set: { email_verified: true } }, function (err, count) {\n      client.close();\n      if (err) return callback(err);\n      callback(null, count > 0);\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction verify(email, callback) {\n  const mysql = require('mysql');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'UPDATE users SET email_Verified = true WHERE email_Verified = false AND email = ?';\n  connection.query(query, [ email ], function(err, results) {\n    if (err) return callback(err);\n    callback(null, results.length > 0);\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction verify (email, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    const query = 'UPDATE users SET email_Verified = true WHERE email_Verified = false AND email = $1';\n    client.query(query, [email], function (err, result) {\n      // NOTE: always call `done()` here to close\n      // the connection to the database\n      done();\n      return callback(err, result && result.rowCount > 0);\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction verify (email, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'UPDATE dbo.Users SET Email_Verified = true WHERE Email_Verified = false AND Email = @Email';\n  connection.on('debug', function(text) {\n    console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rows) {\n      if (err) return callback(err);\n      callback(null, rows > 0);\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction verify (email, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@1.11.0').Connection;\n  var Request = require('tedious@1.11.0').Request;\n  var TYPES = require('tedious@1.11.0').TYPES;\n  var connection = new Connection({\n    userName:  'your-user@your-server-id.database.windows.net',\n    password:  'the-password',\n    server:    'your-server-id.database.windows.net',\n    options:  {\n      database: 'mydb',\n      encrypt:  true\n    }\n  });\n  var query =\n    'UPDATE Users SET Email_Verified=\\'TRUE\\' ' +\n    'WHERE Email_Verified=\\'FALSE\\' AND Email=@Email';\n  connection.on('debug', function(text) {\n    // Uncomment next line in order to enable debugging messages\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    // Uncomment next line in order to enable information messages\n    // console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var request = new Request(query, function (err, rows) {\n      if (err) { return callback(err); }\n      console.log('rows: ' + rows);\n      callback(null, rows > 0);\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n## Learn more\n\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
  "title": "Verify Script Templates",
  "description": "Describes custom database action script templates for user email verification.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/spa",
  "markdown": "# Embedded Passwordless Authentication for SPAs\n\n## Using Auth0's SDKs to implement Embedded Login\n\nYou can implement Passwordless Login using Auth0's Lock widget, or if you need complete control of the user experience, you can implement it using Auth0.js:\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)\n    \n*   [Auth0.js v9 Reference](https://auth0.com/docs/libraries/auth0js)\n    \n\n### Configure Cross-Origin Resource Sharing (CORS)\n\nFor security purposes, your app's origin URL must be listed as an approved URL. If you have not already added it to the **Allowed Callback URLS** for your application, you will need to add it to the list of **Allowed Origins (CORS)**.\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select the name of your application to see its settings.\n    \n2.  Locate **Allowed Origins (CORS)**, enter your application's [origin URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin), and select **Save Changes**.",
  "title": "Embedded Passwordless Authentication for SPAs",
  "description": "Describes implementing Passwordless authentication with embedded login in single-page applications (SPAs).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/native",
  "markdown": "# Embedded Passwordless Login in Native Applications\n\nTo use the Embedded Passwordless APIs in Native applications, make sure you enable the **Passwordless OTP** grant at [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) in your application's settings under **Advanced Settings** > **Grant Types**.\n\nPasswordless authentication for Native applications consists of two steps:\n\n*   Capture the user identifier in your application (the user's email or phone number) and invoke the `/passwordless/start` endpoint to initiate the passwordless flow. The user will get an email or an SMS with a one-time password.\n    \n*   Prompt the user for the one-time-use code, and call the `/oauth/token` endpoint to get authentication tokens.\n    \n\nBelow we list a few code snippets that can be used to call these API endpoints for different scenarios.\n\n**Send a one-time-use password via email**\n\n*   [cURL](#65f3faa6ebb44cbe93f1f45cff96fb91_shell)\n*   [C#](#65f3faa6ebb44cbe93f1f45cff96fb91_csharp)\n*   [Go](#65f3faa6ebb44cbe93f1f45cff96fb91_go)\n*   [Java](#65f3faa6ebb44cbe93f1f45cff96fb91_java)\n*   [Node.JS](#65f3faa6ebb44cbe93f1f45cff96fb91_node)\n*   [Obj-C](#65f3faa6ebb44cbe93f1f45cff96fb91_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\",  \"connection\": \"email\",   \"email\": \"USER_EMAIL\",  \"send\": \"code\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    connection: 'email',\n    email: 'USER_EMAIL',\n    send: 'code'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"connection\": @\"email\",\n                              @\"email\": @\"USER_EMAIL\",\n                              @\"send\": @\"code\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"connection\": \"email\",\n  \"email\": \"USER_EMAIL\",\n  \"send\": \"code\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Send a magic link via email**\n\n*   [cURL](#503a5ab9c6664791a92a38b9b227d423_shell)\n*   [C#](#503a5ab9c6664791a92a38b9b227d423_csharp)\n*   [Go](#503a5ab9c6664791a92a38b9b227d423_go)\n*   [Java](#503a5ab9c6664791a92a38b9b227d423_java)\n*   [Node.JS](#503a5ab9c6664791a92a38b9b227d423_node)\n*   [Obj-C](#503a5ab9c6664791a92a38b9b227d423_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"connection\": \"email\", \"email\": \"USER_EMAIL\", \"send\": \"link\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    connection: 'email',\n    email: 'USER_EMAIL',\n    send: 'link'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"connection\": @\"email\",\n                              @\"email\": @\"USER_EMAIL\",\n                              @\"send\": @\"link\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"connection\": \"email\",\n  \"email\": \"USER_EMAIL\",\n  \"send\": \"link\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Send a one-time-use password via SMS**\n\n*   [cURL](#ad2f041ba0a94ba5992bfbb208223368_shell)\n*   [C#](#ad2f041ba0a94ba5992bfbb208223368_csharp)\n*   [Go](#ad2f041ba0a94ba5992bfbb208223368_go)\n*   [Java](#ad2f041ba0a94ba5992bfbb208223368_java)\n*   [Node.JS](#ad2f041ba0a94ba5992bfbb208223368_node)\n*   [Obj-C](#ad2f041ba0a94ba5992bfbb208223368_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\",  \"connection\": \"sms\",  \"phone_number\": \"USER_PHONE_NUMBER\", \"send\": \"code\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    connection: 'sms',\n    phone_number: 'USER_PHONE_NUMBER',\n    send: 'code'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"connection\": @\"sms\",\n                              @\"phone_number\": @\"USER_PHONE_NUMBER\",\n                              @\"send\": @\"code\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"connection\": \"sms\",\n  \"phone_number\": \"USER_PHONE_NUMBER\",\n  \"send\": \"code\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate an SMS user**\n\n*   [cURL](#f9da0850942e49eda8bd2bb8ddc50210_shell)\n*   [C#](#f9da0850942e49eda8bd2bb8ddc50210_csharp)\n*   [Go](#f9da0850942e49eda8bd2bb8ddc50210_go)\n*   [Java](#f9da0850942e49eda8bd2bb8ddc50210_java)\n*   [Node.JS](#f9da0850942e49eda8bd2bb8ddc50210_node)\n*   [Obj-C](#f9da0850942e49eda8bd2bb8ddc50210_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",  \"client_id\": \"{yourClientId}\",  \"username\": \"USER_PHONE_NUMBER\",  \"otp\": \"code\",  \"realm\": \"sms\", \"audience\": \"your-api-audience\", \"scope\": \"openid profile email\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/json'},\n  data: {\n    grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',\n    client_id: '{yourClientId}',\n    username: 'USER_PHONE_NUMBER',\n    otp: 'code',\n    realm: 'sms',\n    audience: 'your-api-audience',\n    scope: 'openid profile email'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"grant_type\": @\"http://auth0.com/oauth/grant-type/passwordless/otp\",\n                              @\"client_id\": @\"{yourClientId}\",\n                              @\"username\": @\"USER_PHONE_NUMBER\",\n                              @\"otp\": @\"code\",\n                              @\"realm\": @\"sms\",\n                              @\"audience\": @\"your-api-audience\",\n                              @\"scope\": @\"openid profile email\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"username\": \"USER_PHONE_NUMBER\",\n  \"otp\": \"code\",\n  \"realm\": \"sms\",\n  \"audience\": \"your-api-audience\",\n  \"scope\": \"openid profile email\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate an Email user**\n\n*   [cURL](#fec57df2255149c4bf86543d6d5e37ad_shell)\n*   [C#](#fec57df2255149c4bf86543d6d5e37ad_csharp)\n*   [Go](#fec57df2255149c4bf86543d6d5e37ad_go)\n*   [Java](#fec57df2255149c4bf86543d6d5e37ad_java)\n*   [Node.JS](#fec57df2255149c4bf86543d6d5e37ad_node)\n*   [Obj-C](#fec57df2255149c4bf86543d6d5e37ad_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\", \"client_id\": \"{yourClientId}\", \"username\": \"USER_EMAIL\", \"otp\": \"code\", \"realm\": \"email\", \"audience\": \"your-api-audience\", \"scope\": \"openid profile email\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/json'},\n  data: {\n    grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',\n    client_id: '{yourClientId}',\n    username: 'USER_EMAIL',\n    otp: 'code',\n    realm: 'email',\n    audience: 'your-api-audience',\n    scope: 'openid profile email'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"grant_type\": @\"http://auth0.com/oauth/grant-type/passwordless/otp\",\n                              @\"client_id\": @\"{yourClientId}\",\n                              @\"username\": @\"USER_EMAIL\",\n                              @\"otp\": @\"code\",\n                              @\"realm\": @\"email\",\n                              @\"audience\": @\"your-api-audience\",\n                              @\"scope\": @\"openid profile email\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"username\": \"USER_EMAIL\",\n  \"otp\": \"code\",\n  \"realm\": \"email\",\n  \"audience\": \"your-api-audience\",\n  \"scope\": \"openid profile email\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf you prefer, you can use the Android or iOS SDKs, which wrap this APIs in a platform-friendly way:\n\n*   [Lock.Android Passwordless](https://auth0.com/docs/libraries/lock-android/lock-android-passwordless)\n    \n*   [Lock.swift Passwordless](https://auth0.com/docs/libraries/lock-swift/lock-swift-passwordless)\n    \n*   [Auth0.Android Passwordless](https://auth0.com/docs/libraries/auth0-android/auth0-android-passwordless)\n    \n*   [Auth0.swift Passwordless](https://auth0.com/docs/libraries/auth0-swift/auth0-swift-passwordless)",
  "title": "Embedded Passwordless Login in Native Applications",
  "description": "Describes implementing Passwordless authentication with embedded login in native applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens",
  "markdown": "# Access Tokens with OIDC\n\nBecause applications and APIs (resources) are defined as separate Auth0 entities with the OIDC-conformant pipeline, you can get access tokens for your APIs. Consequently, all APIs should be secured with access tokens instead of ID tokens. To learn more, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens) and [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens).\n\n## Claims\n\nThe OIDC-conformant pipeline standardizes claims that you can add to ID and access tokens.\n\n### Standard claims\n\nThe OIDC specification defines a [](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)set of standard claims about users, such as profile and email, that can be returned in ID tokens or in the response from the `/userinfo` endpoint.\n\nTo learn about the OIDC standard claim specification, read [Section 5.1 Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) in the [OpenID Specification](https://openid.net/).\n\n### Custom claims\n\nWith the OIDC-conformant pipeline, custom claims may still be added to ID tokens or access tokens, but they must conform to a namespaced format to avoid possible collisions with standard OIDC claims.\n\nTo learn how to add a custom claim in the OIDC-conformant pipeline, read [Create Namespaced Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n## Scopes\n\nIn the OIDC-conformant pipeline, you can configure your applications in Auth0 to use scopes to request that:\n\n*   Standard OIDC claims, such as `profile` and `email`, be included in the ID token (if the user consents to provide this information to the application).\n    \n*   Permissions supported by the API they want to access be included in the access token. For example, you can define your custom API's audience and required scopes, which will allow you to segregate access to different operations within your API.\n    \n\nTo learn more, read [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes).\n\n## Learn more\n\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
  "title": "Access Tokens with OIDC",
  "description": "Learn how the OIDC-conformant pipeline affects the tokens used to secure APIs, including scopes and claims.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow",
  "markdown": "# Authorization Code Flow with OIDC\n\nThe [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) is used by server-side applications that are capable of securely storing secrets, or by native applications through [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n\nThe OIDC-conformant pipeline affects the Authorization Code Flow in the following areas:\n\n*   Authentication request\n    \n*   Authentication response\n    \n*   Code exchange request\n    \n*   Code exchange response\n    \n*   ID token structure\n    \n*   Access token structure\n    \n\n## Authentication request\n\n### Legacy\n\n```\nGET /authorize?\n    response_type=code\n    &scope=openid email favorite_color offline_access\n    &client_id=123\n    &state=af0ifjsldkj\n    &redirect_uri=https://app.example.com/callback\n    &device=my-device-name\n```\n\nThe `device` parameter is only needed if requesting a refresh token by passing the `offline_access` scope. To learn more, read, [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n### OIDC-conformant\n\n```\nGET /authorize?\n    response_type=code\n    &scope=openid email offline_access\n    &client_id=123\n    &state=af0ifjsldkj\n    &redirect_uri=https://app.example.com/callback\n    &audience=https://api.example.com\n```\n\n*   `favorite_color` is no longer a valid scope value.\n    \n*   The `device` parameter is removed.\n    \n*   The `audience` parameter is optional.\n    \n\n## Authentication response\n\nThe response from Auth0 is identical in both pipelines:\n\n```\nHTTP/1.1 302 Found\nLocation: https://app.example.com/callback?\n    code=SplxlOBeZQQYbYS6WxSbIA\n    &state=af0ifjsldkj\n```\n\nAn authorization code can be exchanged in the same way in both pipelines:\n\n*   [cURL](#e9233abc9e9f4c4386baf7d018642d2a_shell)\n*   [C#](#e9233abc9e9f4c4386baf7d018642d2a_csharp)\n*   [Go](#e9233abc9e9f4c4386baf7d018642d2a_go)\n*   [Java](#e9233abc9e9f4c4386baf7d018642d2a_java)\n*   [Node.JS](#e9233abc9e9f4c4386baf7d018642d2a_node)\n*   [Obj-C](#e9233abc9e9f4c4386baf7d018642d2a_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data code=YOUR_AUTHORIZATION_CODE \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    code: 'YOUR_AUTHORIZATION_CODE',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code=YOUR_AUTHORIZATION_CODE\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code=YOUR_AUTHORIZATION_CODE\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Code exchange request - Authorization Code flow with PKCE\n\nAn authorization code can be exchanged in the same way in both pipelines:\n\n*   [cURL](#6d9680d01c95404e9da638a6e11f91b6_shell)\n*   [C#](#6d9680d01c95404e9da638a6e11f91b6_csharp)\n*   [Go](#6d9680d01c95404e9da638a6e11f91b6_go)\n*   [Java](#6d9680d01c95404e9da638a6e11f91b6_java)\n*   [Node.JS](#6d9680d01c95404e9da638a6e11f91b6_node)\n*   [Obj-C](#6d9680d01c95404e9da638a6e11f91b6_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data code_verifier=YOUR_GENERATED_CODE_VERIFIER \\\n  --data code=YOUR_AUTHORIZATION_CODE \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    code_verifier: 'YOUR_GENERATED_CODE_VERIFIER',\n    code: 'YOUR_AUTHORIZATION_CODE',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code_verifier=YOUR_GENERATED_CODE_VERIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code=YOUR_AUTHORIZATION_CODE\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code_verifier=YOUR_GENERATED_CODE_VERIFIER\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code=YOUR_AUTHORIZATION_CODE\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Code exchange response\n\n### Legacy\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\nPragma: no-cache\n{\n    \"access_token\": \"SlAV32hkKG\",\n    \"token_type\": \"Bearer\",\n    \"refresh_token\": \"8xLOxBtZp8\",\n    \"expires_in\": 3600,\n    \"id_token\": \"eyJ...\"\n}\n```\n\n*   The returned Access Token is only valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n    \n*   A refresh token will be returned only if a `device` parameter was passed and the `offline_access` scope was requested.\n    \n\n### OIDC-conformant\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\nPragma: no-cache\n{\n    \"access_token\": \"eyJ...\",\n    \"token_type\": \"Bearer\",\n    \"refresh_token\": \"8xLOxBtZp8\",\n    \"expires_in\": 3600,\n    \"id_token\": \"eyJ...\"\n}\n```\n\n*   The returned access token is valid for optionally calling the API specified in the `audience` parameter and the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint (provided that the API uses `RS256` as the [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms) and `openid` is used as a `scope` parameter). If you are not implementing your own Resource Server (API), then you can use `https://{$account.namespace}/userinfo` as the `audience` parameter, which will return an opaque Access Token.\n    \n*   A refresh token will be returned only if the `offline_access` scope was granted.\n    \n\n## ID token structure\n\n### Legacy\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"favorite_color\": \"blue\"\n}\n```\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"https://app.example.com/favorite_color\": \"blue\"\n}\n```\n\nThe `favorite_color` claim must be added through an Auth0 Action. To learn more, read [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n## Access token structure (optional)\n\n### Legacy\n\nThe returned access token is opaque and only valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": [\n        \"https://api.example.com\",\n        \"https://{yourDomain}/userinfo\"\n    ],\n    \"azp\": \"123\",\n    \"exp\": 1482816809,\n    \"iat\": 1482809609,\n    \"scope\": \"openid email\"\n}\n```\n\nThe returned access token is valid for optionally calling the API specified in the `audience` parameter and the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint (provided that the API uses `RS256` as the signing algorithm and `openid` is used as a `scope` parameter).\n\nIf you are not implementing your own resource server (API), then you can use `https://{$account.namespace}/userinfo` as the `audience` parameter, which will return an opaque access token.\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)\n*   [Resource Owner Password Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-rop-flow)",
  "title": "Authorization Code Flow with OIDC",
  "description": "Learn how the OIDC-conformant pipeline affects the Authorization Code Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/webapps",
  "markdown": "# Embedded Passwordless Login in Regular Web Applications\n\nTo use the Embedded Passwordless APIs in Regular Web Applications, make sure you enable the **Passwordless OTP** grant at [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) in your application's settings under **Advanced Settings** > **Grant Types**.\n\nPasswordless authentication for Regular Web Applications consists of two steps:\n\n1.  Capture the user identifier in your application (the user's email or phone number) and invoke the `/passwordless/start` endpoint to initiate the passwordless flow. The user will get an email, an SMS with a one-time-use code, or a magic link.\n    \n2.  If you did not send a magic link, prompt the user for the one-time-use code, and call the `/oauth/token` endpoint to get authentication tokens.\n    \n\nNote that when using magic links, you don't need to call `/oauth/token`. The user will click the magic link and be redirected to the application's callback URL.\n\nBelow, we list a few code snippets that can be used to call these API endpoints for different scenarios. Auth0 SDKs for backend technologies (for example, Java, .NET, Ruby, PHP, Python, Node JS) haven't been updated to support these endpoints yet, so you will need to invoke them directly.\n\n**Send a one-time-use code via email**\n\n*   [cURL](#97124668b6ad4cfc81d4fba400d19c29_shell)\n*   [C#](#97124668b6ad4cfc81d4fba400d19c29_csharp)\n*   [Go](#97124668b6ad4cfc81d4fba400d19c29_go)\n*   [Java](#97124668b6ad4cfc81d4fba400d19c29_java)\n*   [Node.JS](#97124668b6ad4cfc81d4fba400d19c29_node)\n*   [Obj-C](#97124668b6ad4cfc81d4fba400d19c29_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"connection\": \"email\", \"email\": \"{userEmail}\",\"send\": \"code\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    connection: 'email',\n    email: '{userEmail}',\n    send: 'code'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"connection\": @\"email\",\n                              @\"email\": @\"{userEmail}\",\n                              @\"send\": @\"code\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"connection\": \"email\",\n  \"email\": \"{userEmail}\",\n  \"send\": \"code\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Send a magic link via email**\n\nYou need to specify `send: link`.\n\n*   [cURL](#c36dd90867684513b1ec399f2132e12f_shell)\n*   [C#](#c36dd90867684513b1ec399f2132e12f_csharp)\n*   [Go](#c36dd90867684513b1ec399f2132e12f_go)\n*   [Java](#c36dd90867684513b1ec399f2132e12f_java)\n*   [Node.JS](#c36dd90867684513b1ec399f2132e12f_node)\n*   [Obj-C](#c36dd90867684513b1ec399f2132e12f_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"connection\": \"email\", \"email\": \"{userEmail}\",\"send\": \"link\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    connection: 'email',\n    email: '{userEmail}',\n    send: 'link'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"connection\": @\"email\",\n                              @\"email\": @\"{userEmail}\",\n                              @\"send\": @\"link\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"connection\": \"email\",\n  \"email\": \"{userEmail}\",\n  \"send\": \"link\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Send a one-time-use password via SMS**\n\n*   [cURL](#37cf737d20734c27bf0b4c6ec73c32a0_shell)\n*   [C#](#37cf737d20734c27bf0b4c6ec73c32a0_csharp)\n*   [Go](#37cf737d20734c27bf0b4c6ec73c32a0_go)\n*   [Java](#37cf737d20734c27bf0b4c6ec73c32a0_java)\n*   [Node.JS](#37cf737d20734c27bf0b4c6ec73c32a0_node)\n*   [Obj-C](#37cf737d20734c27bf0b4c6ec73c32a0_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"connection\": \"sms\", \"phone_number\": \"{userPhoneNumber}\",\"send\": \"code\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    connection: 'sms',\n    phone_number: '{userPhoneNumber}',\n    send: 'code'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"connection\": @\"sms\",\n                              @\"phone_number\": @\"{userPhoneNumber}\",\n                              @\"send\": @\"code\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"connection\": \"sms\",\n  \"phone_number\": \"{userPhoneNumber}\",\n  \"send\": \"code\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate an SMS user**\n\n*   [cURL](#169673888b234c1ba73be88b2a2e5641_shell)\n*   [C#](#169673888b234c1ba73be88b2a2e5641_csharp)\n*   [Go](#169673888b234c1ba73be88b2a2e5641_go)\n*   [Java](#169673888b234c1ba73be88b2a2e5641_java)\n*   [Node.JS](#169673888b234c1ba73be88b2a2e5641_node)\n*   [Obj-C](#169673888b234c1ba73be88b2a2e5641_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\", \"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\", \"username\": \"USER_PHONE_NUMBER\", \"otp\": \"code\", \"realm\": \"sms\", \"audience\": \"your-api-audience\",\"scope\": \"openid profile email\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/json'},\n  data: {\n    grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    username: 'USER_PHONE_NUMBER',\n    otp: 'code',\n    realm: 'sms',\n    audience: 'your-api-audience',\n    scope: 'openid profile email'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"grant_type\": @\"http://auth0.com/oauth/grant-type/passwordless/otp\",\n                              @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"YOUR_CLIENT_SECRET\",\n                              @\"username\": @\"USER_PHONE_NUMBER\",\n                              @\"otp\": @\"code\",\n                              @\"realm\": @\"sms\",\n                              @\"audience\": @\"your-api-audience\",\n                              @\"scope\": @\"openid profile email\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"username\": \"USER_PHONE_NUMBER\",\n  \"otp\": \"code\",\n  \"realm\": \"sms\",\n  \"audience\": \"your-api-audience\",\n  \"scope\": \"openid profile email\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate an Email user**\n\n*   [cURL](#29e5b9edd5ea424c9f94653526147838_shell)\n*   [C#](#29e5b9edd5ea424c9f94653526147838_csharp)\n*   [Go](#29e5b9edd5ea424c9f94653526147838_go)\n*   [Java](#29e5b9edd5ea424c9f94653526147838_java)\n*   [Node.JS](#29e5b9edd5ea424c9f94653526147838_node)\n*   [Obj-C](#29e5b9edd5ea424c9f94653526147838_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\", \"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"username\": \"{userPhoneNumber}\", \"otp\": \"code\", \"realm\": \"email\", \"audience\": \"your-api-audience\", \"scope\": \"openid profile email\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/json'},\n  data: {\n    grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    username: '{userPhoneNumber}',\n    otp: 'code',\n    realm: 'email',\n    audience: 'your-api-audience',\n    scope: 'openid profile email'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"grant_type\": @\"http://auth0.com/oauth/grant-type/passwordless/otp\",\n                              @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"username\": @\"{userPhoneNumber}\",\n                              @\"otp\": @\"code\",\n                              @\"realm\": @\"email\",\n                              @\"audience\": @\"your-api-audience\",\n                              @\"scope\": @\"openid profile email\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"username\": \"{userPhoneNumber}\",\n  \"otp\": \"code\",\n  \"realm\": \"email\",\n  \"audience\": \"your-api-audience\",\n  \"scope\": \"openid profile email\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate a user through a magic link**\n\nWhen you send a magic link, you don't need to call an API to authenticate the user. Users will click the link and be redirected to the callback URL.\n\nThe `/passwordless/start` endpoint has a [rate limit](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) of 50 requests per hour per IP. If you call the API from the server-side, your backend's IP may easily hit these rate limits. To learn how to address this issue, read the Rate Limiting in Passwordless Endpoints section of [Using Passwordless APIs](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints).",
  "title": "Embedded Passwordless Login in Regular Web Applications",
  "description": "Describes implementing Passwordless authentication with embedded login in regular applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow",
  "markdown": "# Client Credentials Flow with OIDC\n\nThe OIDC-conformant pipeline enables the use of the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow), which allows applications to authenticate as themselves (rather than on behalf of a user) to programmatically and securely obtain access to an API.\n\nThis exchange does not exist in the legacy pipeline; instead, the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) is used to simulate it by creating a **service user**. We strongly discourage this approach in favor of using the Client Credentials Flow, which allows fine-grained permissions to be defined for each API app.\n\nTo learn how to execute a Client Credentials Flow, read [Call API Using the Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow).\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)\n*   [Resource Owner Password Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-rop-flow)",
  "title": "Client Credentials Flow with OIDC",
  "description": "Learn how the OIDC-conformant pipeline affects the Client Credentials Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis",
  "markdown": "# External APIs with OIDC\n\nWith the OIDC-conformant pipeline, you should define applications and APIs (resources) as separate Auth0 entities. Benefits include:\n\n*   Simpler API integration: APIs are no longer tied to applications that call them.\n    \n*   [Machine-to-machine (M2M)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) integration scenarios: Applications can authenticate as themselves (instead of acting on behalf of a user) to programmatically and securely get an Access Token.\n    \n\n## Architecture\n\nSuggested OIDC-conformant solutions for different scenarios include: \n\n*   **Multiple applications calling an API under a single client ID**: Represent each application with a single Auth0 application, each of which can interact with the API on which the applications depend.\n    \n*   **Exchange tokens obtained by one application for tokens for a different application with delegation**: Use a multi-application solution, with each application authenticating to the same resource server.\n    \n*   **Applications do not depend on external APIs; only used to authenticate users**: You do not need to define an API as long as ID tokens are:\n    \n    *   Processed only by the application.\n        \n    *   Not sent to any external services.\n        \n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
  "title": "External APIs with OIDC",
  "description": "Learn how the OIDC-conformant pipeline affects your use of external APIs and the tokens used to secure them.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens",
  "markdown": "# Refresh Tokens with OIDC\n\nWith the OIDC-conformant pipeline, refresh tokens:\n\n*   Will no longer be returned when using the [implicit grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) for authentication.\n    \n*   Can be used by [confidential applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n    \n*   Can be used with [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation) by public applications when using the Authorization Code Flow with PKCE.\n    \n*   Should use the [`/oauth/token`](https://auth0.com/docs/api/authentication#refresh-token) endpoint to get new tokens because the [`/delegation`](https://auth0.com/docs/api/authentication#delegation) endpoint is deprecated.\n    \n\nIn addition, differences exist in the refresh token structure. To learn more, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n## Legacy (delegation)\n\n```\nPOST /delegation\nContent-Type: 'application/json'\n{\n  \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n  \"client_id\": \"...\",\n  \"refresh_token\": \"...\",\n  \"scope\": \"openid profile\"\n}\n```\n\nWas this helpful?\n\n/\n\n## OIDC-conformant (token endpoint)\n\n```\nPOST /oauth/token\nContent-Type: application/x-www-form-urlencoded\ngrant_type=refresh_token&refresh_token=123&client_id=123&client_secret=123&scope=openid+profile&audience=https%3A%2F%2Fapi.example.com\n```\n\nWas this helpful?\n\n/\n\n*   `audience` and `client_secret` parameters are optional.\n    \n*   `client_secret` is not needed when requesting a `refresh_token` for a public application.\n    \n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)",
  "title": "Refresh Tokens with OIDC",
  "description": "Learn how the OIDC-conformant pipeline affects your use of refresh tokens.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-sso",
  "markdown": "# Single Sign-On with OIDC\n\nIn the context of the OIDC-conformant authentication pipeline, [](https://auth0.com/docs/authenticate/single-sign-on)single sign-on (SSO) must happen at the authorization server (i.e., Auth0) rather than the application, which means that you must employ Universal Login and redirect users to the login page. To learn more, read [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) and [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on).\n\nAt a general level, when performing SSO:\n\n1.  If the user is not logged in locally, you should redirect them to your Auth0 login page (`/authorize`) for authentication using a redirect-based flow, such as the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) or [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post), depending on the type of application.\n    \n2.  If the user was already logged in through SSO, Auth0 will immediately authenticate them without needing to re-enter credentials.\n    \n\nTo determine whether users are logged in via SSO, use silent authentication, which either re-authenticates a user if they are already logged in or returns an error if they need to authenticate. In the legacy authentication pipeline, this could be achieved by using the `/ssodata` endpoint, which is deprecated in the OIDC-conformant pipeline. To learn more about how to configure silent authentication, read [Configure Silent Authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication).\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
  "title": "Single Sign-On with OIDC",
  "description": "Learn how the OIDC-conformant pipeline affects your use of Single Sign-On (SSO).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-rop-flow",
  "markdown": "# Resource Owner Password Flow with OIDC\n\nThe [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) is used by highly-trusted applications to provide active authentication. Unlike the authorization code and implicit grants, this authentication mechanism does not redirect users to Auth0. It authenticates users with a single request, exchanging their password credentials for a token.\n\nThe OIDC-conformant pipeline affects the Resource Owner Password Flow in the following areas:\n\n*   Authentication request\n    \n*   Authentication response\n    \n*   ID token structure\n    \n*   Access token structure\n    \n\n## Authentication request\n\n### Legacy\n\n```\nPOST /oauth/ro HTTP 1.1\nContent-Type: application/json\n{\n  \"grant_type\": \"password\",\n  \"client_id\": \"123\",\n  \"username\": \"alice\",\n  \"password\": \"A3ddj3w\",\n  \"connection\": \"my-database-connection\",\n  \"scope\": \"openid email favorite_color offline_access\",\n  \"device\": \"my-device-name\"\n}\n```\n\nThe `device` parameter is only needed if requesting a refresh token by passing the `offline_access` scope.\n\n### OIDC-conformant\n\n```\nPOST /oauth/token HTTP 1.1\nContent-Type: application/x-www-form-urlencoded\ngrant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fpassword-realm&client_id=123&username=alice&password=A3ddj3w&realm=my-database-connection&scope=openid+email+offline_access&audience=https%3A%2F%2Fapi.example.com\n```\n\n*   The endpoint to execute credential exchanges is `/oauth/token`.\n    \n*   Auth0's own grant type is used to authenticate users from a specific connection (`realm`). The standard OIDC password grant is also supported, but it does not accept Auth0-specific parameters such as `realm`.\n    \n*   `favorite_color` is no longer a valid scope.\n    \n*   The `device` parameter is removed.\n    \n*   The `audience` parameter is optional.\n    \n\n## Authentication response\n\n### Legacy\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\nPragma: no-cache\n{\n    \"access_token\": \"SlAV32hkKG\",\n    \"token_type\": \"Bearer\",\n    \"refresh_token\": \"8xLOxBtZp8\",\n    \"expires_in\": 3600,\n    \"id_token\": \"eyJ...\"\n}\n```\n\n*   The returned access token is only valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n    \n*   A Refresh Token will be returned only if a `device` parameter was passed and the `offline_access` scope was requested.\n    \n\n### OIDC-conformant\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\nPragma: no-cache\n{\n    \"access_token\": \"eyJ...\",\n    \"token_type\": \"Bearer\",\n    \"refresh_token\": \"8xLOxBtZp8\",\n    \"expires_in\": 3600,\n    \"id_token\": \"eyJ...\"\n}\n```\n\n*   The returned access token is valid for calling the `/userinfo` endpoint (provided that the API specified by the `audience` param uses `RS256` as [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms)) and optionally the resource server specified by the `audience` parameter.\n    \n*   The ID token will be forcibly signed using `RS256` if requested by a public application. To learn more, read [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n    \n*   A refresh token will be returned only if the `offline_access` scope was granted.\n    \n\n## ID Token structure\n\n### Legacy\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"favorite_color\": \"blue\"\n}\n```\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"https://app.example.com/favorite_color\": \"blue\"\n}\n```\n\n*   The ID token will be forcibly signed using `RS256` if requested by a public application.\n    \n*   The `favorite_color` claim must be namespaced and added through a rule. To learn more, read [Create Namespaced Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n    \n\n## Access Token structure (optional)\n\n### Legacy\n\nThe returned Access token is opaque and only valid for calling the `/userinfo` endpoint.\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": [\n        \"https://api.example.com\",\n        \"https://{yourDomain}/userinfo\"\n    ],\n    \"azp\": \"123\",\n    \"exp\": 1482816809,\n    \"iat\": 1482809609,\n    \"scope\": \"openid email\"\n}\n```\n\n*   The returned access token is a JWT valid for calling the [](https://auth0.com/docs/api/authentication#get-user-info)`/userinfo` endpoin (provided that the API specified by the `audience` parameter uses `RS256` as signing algorithm) as well as the resource server specified by the `audience` parameter.\n    \n*   Note that an opaque access token could still be returned if `/userinfo` is the only specified audience.\n    \n\n## Standard password grant requests\n\nThe Auth0 password realm grant is not defined by standard OIDC, but it is suggested as an alternative to the legacy resource owner endpoint because it supports the Auth0-specific `realm` parameter. The [standard OIDC flow is also supported](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) when using OIDC authentication.\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
  "title": "Resource Owner Password Flow with OIDC",
  "description": "Learn how the OIDC-conformant pipeline affects the Resource Owner Password (ROP) Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods/use-sms-gateway-passwordless",
  "markdown": "# Set Up Custom SMS Gateway for Passwordless Connections\n\nThis guide will show you how to use a custom SMS gateway to send out your one-time-use codes.\n\nBy default, [Passwordless SMS connections](https://auth0.com/docs/authenticate/passwordless/authentication-methods/sms-otp) use [Twilio](https://www.twilio.com/) to send out one-time use codes. However, if you have a custom SMS gateway, you can modify your connection to use that instead.\n\n1.  Set up a SMS passwordless connection. To learn how, read the Implement Passwordless section in [Passwordless Connections](https://auth0.com/docs/authenticate/passwordless).\n    \n2.  [Get an Access Token for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens). You will need this to make calls to the Management API to update your Passwordless connection.\n    \n3.  Use the [GET Connections](https://auth0.com/docs/api/management/v2#!/Connections/get_connections) endpoint to retrieve information about the connections associated with your tenant. More specifically, you need to get the ID for your Passwordless SMS connection so that you can use it in a later API call that updates the connection itself. Be sure to replace `ACCESS_TOKEN` with the token you obtained in step 1 before making the following call to the Management API:\n    \n    *   [cURL](#e283aeb8361840ae8b727a26f71f4f57_shell)\n    *   [C#](#e283aeb8361840ae8b727a26f71f4f57_csharp)\n    *   [Go](#e283aeb8361840ae8b727a26f71f4f57_go)\n    *   [Java](#e283aeb8361840ae8b727a26f71f4f57_java)\n    *   [Node.JS](#e283aeb8361840ae8b727a26f71f4f57_node)\n    *   [Obj-C](#e283aeb8361840ae8b727a26f71f4f57_objc)\n    *   [...](#)\n    \n    ```\n    curl --request GET \\\n      --url https://your-auth0-tenant.com/api/v2/connections \\\n      --header 'authorization: Bearer {yourAccessToken}'\n    ```\n    \n    ```\n    var client = new RestClient(\"https://your-auth0-tenant.com/api/v2/connections\");\n    var request = new RestRequest(Method.GET);\n    request.AddHeader(\"authorization\", \"Bearer {yourAccessToken}\");\n    IRestResponse response = client.Execute(request);\n    ```\n    \n    ```\n    package main\n    \n    import (\n    \t\"fmt\"\n    \t\"net/http\"\n    \t\"io/ioutil\"\n    )\n    \n    func main() {\n    \n    \turl := \"https://your-auth0-tenant.com/api/v2/connections\"\n    \n    \treq, _ := http.NewRequest(\"GET\", url, nil)\n    \n    \treq.Header.Add(\"authorization\", \"Bearer {yourAccessToken}\")\n    \n    \tres, _ := http.DefaultClient.Do(req)\n    \n    \tdefer res.Body.Close()\n    \tbody, _ := ioutil.ReadAll(res.Body)\n    \n    \tfmt.Println(res)\n    \tfmt.Println(string(body))\n    \n    }\n    ```\n    \n    ```\n    HttpResponse<String> response = Unirest.get(\"https://your-auth0-tenant.com/api/v2/connections\")\n      .header(\"authorization\", \"Bearer {yourAccessToken}\")\n      .asString();\n    ```\n    \n    ```\n    var axios = require(\"axios\").default;\n    \n    var options = {\n      method: 'GET',\n      url: 'https://your-auth0-tenant.com/api/v2/connections',\n      headers: {authorization: 'Bearer {yourAccessToken}'}\n    };\n    \n    axios.request(options).then(function (response) {\n      console.log(response.data);\n    }).catch(function (error) {\n      console.error(error);\n    });\n    ```\n    \n    ```\n    #import <Foundation/Foundation.h>\n    \n    NSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourAccessToken}\" };\n    \n    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://your-auth0-tenant.com/api/v2/connections\"]\n                                                           cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                       timeoutInterval:10.0];\n    [request setHTTPMethod:@\"GET\"];\n    [request setAllHTTPHeaderFields:headers];\n    \n    NSURLSession *session = [NSURLSession sharedSession];\n    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                    if (error) {\n                                                        NSLog(@\"%@\", error);\n                                                    } else {\n                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                        NSLog(@\"%@\", httpResponse);\n                                                    }\n                                                }];\n    [dataTask resume];\n    ```\n    \n    ```\n    $curl = curl_init();\n    \n    curl_setopt_array($curl, [\n      CURLOPT_URL => \"https://your-auth0-tenant.com/api/v2/connections\",\n      CURLOPT_RETURNTRANSFER => true,\n      CURLOPT_ENCODING => \"\",\n      CURLOPT_MAXREDIRS => 10,\n      CURLOPT_TIMEOUT => 30,\n      CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n      CURLOPT_CUSTOMREQUEST => \"GET\",\n      CURLOPT_HTTPHEADER => [\n        \"authorization: Bearer {yourAccessToken}\"\n      ],\n    ]);\n    \n    $response = curl_exec($curl);\n    $err = curl_error($curl);\n    \n    curl_close($curl);\n    \n    if ($err) {\n      echo \"cURL Error #:\" . $err;\n    } else {\n      echo $response;\n    }\n    ```\n    \n    ```\n    import http.client\n    \n    conn = http.client.HTTPSConnection(\"your-auth0-tenant.com\")\n    \n    headers = { 'authorization': \"Bearer {yourAccessToken}\" }\n    \n    conn.request(\"GET\", \"/api/v2/connections\", headers=headers)\n    \n    res = conn.getresponse()\n    data = res.read()\n    \n    print(data.decode(\"utf-8\"))\n    ```\n    \n    ```\n    require 'uri'\n    require 'net/http'\n    require 'openssl'\n    \n    url = URI(\"https://your-auth0-tenant.com/api/v2/connections\")\n    \n    http = Net::HTTP.new(url.host, url.port)\n    http.use_ssl = true\n    http.verify_mode = OpenSSL::SSL::VERIFY_NONE\n    \n    request = Net::HTTP::Get.new(url)\n    request[\"authorization\"] = 'Bearer {yourAccessToken}'\n    \n    response = http.request(request)\n    puts response.read_body\n    ```\n    \n    ```\n    import Foundation\n    \n    let headers = [\"authorization\": \"Bearer {yourAccessToken}\"]\n    \n    let request = NSMutableURLRequest(url: NSURL(string: \"https://your-auth0-tenant.com/api/v2/connections\")! as URL,\n                                            cachePolicy: .useProtocolCachePolicy,\n                                        timeoutInterval: 10.0)\n    request.httpMethod = \"GET\"\n    request.allHTTPHeaderFields = headers\n    \n    let session = URLSession.shared\n    let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n      if (error != nil) {\n        print(error)\n      } else {\n        let httpResponse = response as? HTTPURLResponse\n        print(httpResponse)\n      }\n    })\n    \n    dataTask.resume()\n    ```\n    \n    The response from the endpoint will be an array of objects. Each object represents one connection affiliated with your tenant.\n4.  Identify your connection ID. You can find the ID associated with your Passwordless connection by reviewing the array of objects you returned from the [GET Connections endpoint](https://auth0.com/docs/api/management/v2#!/Connections/get_connections) in step 2. To find the specific object for your Passwordless connection, you can search for the `\"name\": \"sms\"` property. Notice that the connection currently displays the Twilio information you provided during the setup process.\n    \n    ```\n    [\n        {\n            \"id\": \"con_UX85K7K0N86INi9U\",\n            \"options\": {\n                \"disable_signup\": false,\n                \"name\": \"sms\",\n                \"twilio_sid\": \"TWILIO_SID\",\n                \"twilio_token\": \"TWILIO_AUTH_TOKEN\",\n                \"from\": \"+15555555555\",\n                \"syntax\": \"md_with_macros\",\n                \"template\": \"Your SMS verification code is: @@password@@\",\n                \"totp\": {\n                    \"time_step\": 300,\n                    \"length\": 6\n                },\n                \"messaging_service_sid\": null,\n                \"brute_force_protection\": true\n            },\n            \"strategy\": \"sms\",\n            \"name\": \"sms\",\n            \"is_domain_connection\": false,\n            \"realms\": [\n                \"sms\"\n            ],\n            \"enabled_clients\": []\n        }\n    ]\n    ```\n    \n5.  Update the connection. You can do this by making a PATCH call to the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). More specifically, you'll be updating the connections `options` object to provide information about the SMS Gateway.\n    \n    Make the following changes:\n    \n    *   Remove both the `twilio_sid` and `twilio_token` parameters\n        \n    *   Add the `provider` parameter, and set it to `sms_gateway`)\n        \n    *   Add the `gateway_url` parameter, and set it to the URL of your SMS gateway. Auth0 must be able to reach this URL for it to use your gateway to send messages on your behalf.\n        \n    \n    Your payload will look something like this:\n    \n    ```\n    {\n        \"options\": {\n          \"strategy\": \"sms\",\n          \"provider\": \"sms_gateway\",\n          \"gateway_url\": \"{urlOfYourGateway}\",\n          \"from\": \"+1 234 567\",\n          \"template\": \"Your verification code is: @@password@@\",\n          \"brute_force_protection\": true,\n          \"forward_req_info\": \"true\",\n          \"disable_signup\": false,\n          \"name\": \"sms\",\n          \"syntax\": \"md_with_macros\",\n          \"totp\": {\n            \"time_step\": 300,\n            \"length\": 6\n          }\n        },\n        \"is_domain_connection\": false,\n        \"enabled_clients\": []\n    }\n    ```\n    \n\n## Authenticated requests\n\nIf your SMS Gateway accepts authenticated requests that are token-based, you can add the following to your `options` object:\n\n```\n\"gateway_authentication\": {\n    \"method\": \"bearer\",\n    \"subject\": \"urn:Auth0\",\n    \"audience\": \"urn:MySmsGateway\",\n    \"secret\": \"MySecretToSignTheToken\",\n    \"secret_base64_encoded\": false\n}\n```\n\nWhen you include `gateway_authentication` in your `options` object, Auth0 adds a [JSON Web Token](https://auth0.com/docs/secure/tokens/json-web-tokens) to the `Authorization` header whenever it sends requests to your SMS gateway. The token contains the `gateway_authentication.subject` and `gateway_authentication.audience` values, and is signed with `gateway_authentication.secret`.\n\nIf your secret is base64-url-encoded, set `secret_base64_encoded` to `true`.\n\nOnce you have updated your connection, Auth0 will send the following to your SMS Gateway every time a user signs up or logs in with your Passwordless connection.\n\n```\n{\n  \"recipient\": \"+1 399 999\",\n  \"body\": \"Your verification code is: 12345\",\n  \"sender\": \"+1 234 567\"\n}\n```\n\nIf you set the `forward_req_info` property in the `options` object to `true`, the gateway will also receive information from the HTTP request that initiated the Passwordless process. This includes the IP address of the client calling `/passwordless/start` and its User Agent.\n\n```\n{\n  \"recipient\": \"+1 399 999\",\n  \"body\": \"Your verification code is: 12345\",\n  \"sender\": \"+1 234 567\",\n  \"req\" : { \n      \"ip\" : \"167.56.227.117\",\n      \"user-agent\" : \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36\"\n       }\n}\n```\n\n## Error handling\n\nAuth0 will only consider the HTTP code returned from the SMS Gateway; it ignores the rest of the response (e.g., response body and response type).\n\nIf the SMS Gateway returns an HTTP code other than 200, the `/passwordless/start` endpoint will return an HTTP 400 code and a response that looks like the following:\n\n```\n{\n \"error\":\"sms_provider_error\",\n \"error_description\":\"Unexpected response while calling the SMS gateway: <HTTP Code Returned by the SMS Gateway>\"}\n}\n```\n\nIf the SMS Gateway returns HTTP 401, the `error_description` will be **Authentication failed while calling the SMS gateway: 401**. (Please note that the error description verbiage is subject to change at any time.)\n\nAuth0 enforces a timeout of 30 seconds for HTTP calls to custom SMS Gateways. If the SMS Gateway fails to reply within this time frame, the `/passwordless/start` endpoint will also return an HTTP 400 code. The response will have the format shown above and the `error_description` field will be **Timeout while calling the SMS gateway: <Timeout Code>**. (Again, the error description verbiage is subject to change at any time.)",
  "title": "Set Up Custom SMS Gateway for Passwordless Connections",
  "description": "Learn how to set up a custom SMS gateway for Passwordless connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms",
  "markdown": "# Configure Email or SMS for Passwordless Authentication\n\nAuth0 lets you configure Universal Login so users can authenticate with a magic link or one-time password (OTP) through email, or an OTP through SMS.\n\nTo enable Passwordless authentication with SMS or email, you need to define a [Passwordless connection](https://auth0.com/docs/authenticate/passwordless) for your application.\n\nOnce you've created the connection, you need to configure Universal Login to use it. You have three options:\n\n## Universal Login\n\nThis method uses the Universal Login Experience, which natively supports Passwordless connections. To learn more, read [Passwordless with Universal Login](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login).\n\n## Universal Login + Lock (passwordless)\n\nThis method uses a custom login page with the **Lock (passwordless)** template, and authenticates user with the [Lock for Web SDK](https://auth0.com/docs/libraries/lock):\n\n1.  Go to [Dashboard > Branding > Universal Login](https://manage.auth0.com/#/login_settings) and click the **Login** tab.\n    \n2.  Enable the **Custom Login Page** toggle, and select the **Lock (passwordless)** template. The HTML template will update with code using the Lock widget with Passwordless customization options.\n    \n3.  Customize the template, and click **Save Changes**.\n    \n\nYou can use HTML and CSS to customize the login form, and preview the changes within the Dashboard. To learn more about how to customize the **Lock (passwordless)** template, read the Passwordless section in [Lock for Web SDK](https://auth0.com/docs/libraries/lock).\n\n## Universal Login + Custom UI + Auth0.js\n\nThis method uses a custom login page with the **Custom Login Form** template, and authenticates users with the [Auth0.js SDK](https://auth0.com/docs/libraries/auth0js). To learn more, read [Passwordless Authentication with Universal Login](https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login).\n\n## Learn more\n\n*   [Configure Universal Login with Passwordless](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login)\n*   [Configure WebAuthn with Device Biometrics for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics)",
  "title": "Configure Email or SMS for Passwordless Authentication",
  "description": "Learn how to configure email or SMS for Passwordless authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider",
  "markdown": "# Configure Amazon SES as External SMTP Email Provider\n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only.\n\n## Prerequisites\n\n*   To ensure that emails can be sent from Auth0 to your SMTP, open ports and allow inbound connections from specific IP addresses. To update the list of IPs, navigate to [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider). See [Add IP Addresses to AllowList](https://auth0.com/docs/secure/security-guidance/data-security/allowlist) for details.\n    \n*   You must have an [Amazon AWS](http://aws.amazon.com/ses/) account.\n    \n*   Determine which credentials you want to use: API or SMTP. For more info about SES credentials, see Amazon's [Using Credentials With Amazon SES](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/using-credentials.html).\n    \n\n## Configure Amazon SES with API credentials\n\n1.  Log in to your [Amazon AWS](http://aws.amazon.com/ses/) account.\n    \n2.  [Verify your domain](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-domains.html).\n    \n3.  [Verify email addresses](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html)\n    \n4.  [Request production access](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-access.html?icmpid=docs_ses_console).\n    \n5.  [Get your AWS access keys](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/get-aws-keys.html). Copy these keys; you will need to enter these values into Auth0.\n    \n6.  [Attach a policy with the proper permissions](http://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage.html). Attach a policy with the `ses:SendRawEmail` and `ses:SendEmail` permissions, as in this example:\n    \n    ```\n    {\n        \"Version\": \"2012-10-17\",\n        \"Statement\": [\n            {\n                \"Effect\": \"Allow\",\n                \"Action\": [\n                    \"ses:SendRawEmail\",\n                    \"ses:SendEmail\"\n                ],\n                \"Resource\": \"*\"\n            }\n        ]\n    }\n    ```\n    \n7.  Navigate to Auth0 [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n8.  Activate the **Use my own email provider** toggle.\n    \n9.  Click the **Amazon Web Services** logo.\n    \n10.  Provide a **From** email address, enter your AWS **Access Key Id** and **Secret Access Key**, select your **Region**.\n    \n    ![Dashboard - Branding - Email Provider - AWS SES Settings](https://images.ctfassets.net/cdy7uua7fh8z/5H5otPGIXAeRAVOfl95c3G/699d35584148a65727a1e04ef6291968/dashboard-email-providers_settings_amazon-ses.png)\n11.  Click **Save**.\n    \n\n### Configure Amazon SES with SMTP credentials\n\n1.  Sign up for an [Amazon AWS](http://aws.amazon.com/ses/) account, or log in.\n    \n2.  [Verify your domain](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-domains.html).\n    \n3.  [Request production access](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-access.html?icmpid=docs_ses_console).\n    \n4.  [Get your SMTP credentials](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/smtp-credentials.html). Copy the security credentials; you will need to enter these values into Auth0.\n    \n5.  Navigate to [Dashboard > Emails > Custom Email Providers](https://manage.auth0.com/#/emails/provider).\n    \n6.  Activate the **Use my own email provider** toggle.\n    \n7.  Click the **SMTP** logo.\n    \n8.  Provide a **From** email address, then enter your SMTP server **Host**, **Port**, **Username**, and **Password**, and click **Save**. You can use `email-smtp.us-east-1.amazonaws.com` (using the appropriate region rather than `us-east-1`) for **Host** and `587` for **Port**.\n    \n\n![Auth0 Branding Email Provider SMTP Provider Settings](https://images.ctfassets.net/cdy7uua7fh8z/7jYUb6ktBllv6yr25f5zJK/b18e9f1812afb7dced38acb3823e10e4/Dashboard_-_Branding_-_Email_Provider_-_SMTP_Provider_Settings.png)\n\n## Test email\n\nYou can now send a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email. If you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for any failures.\n\nThe [Amazon SES console](https://console.aws.amazon.com/ses) will now display delivery insights for all emails that have been sent to your users.",
  "title": "Configure Amazon SES as External SMTP Email Provider",
  "description": "Describes how to configure Amazon Simple Email Service (SES) as an external email provider so you can manage, monitor, and troubleshoot your email communications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider",
  "markdown": "# Configure Mandrill as External SMTP Email Provider\n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only.\n\n## Prerequisites\n\n*   To ensure that emails can be sent from Auth0 to your SMTP, open ports and allow inbound connections from specific IP addresses. To update the list of IPs, navigate to [Dashboard > Branding](https://manage.auth0.com/#/branding/email_provider) [\\>](https://manage.auth0.com/#/branding/email_provider) [Emails Provider](https://manage.auth0.com/#/branding/email_provider). See [Add IP Addresses to AllowList](https://auth0.com/docs/secure/security-guidance/data-security/allowlist) for details.\n    \n*   You must have a [Mandrill](https://www.mandrill.com/signup/) account.\n    \n\n## Configure Mandrill\n\n1.  Log in to [Mandrill](https://www.mandrill.com/signup/).\n    \n2.  Navigate to Mandrill [Settings](https://mandrillapp.com/settings), and click **Add API key**. Copy this key value.\n    \n3.  Navigate to Auth0 [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n4.  Activate the **Use my own email provider** toggle.\n    \n5.  Click the **Mandrill** logo.\n    \n6.  Provide a **From** email address, enter the Mandrill **API Key** you previously copied.\n    \n    ![Dashboard - Branding - Email Provider - Mandrill Settings](https://images.ctfassets.net/cdy7uua7fh8z/62q50dOHkUxzmTHYZKah2N/aa941549e5123d9a70e97319733ca10a/dashboard-email-providers_settings_mandrill.png)\n7.  Click **Save**.\n    \n\n## Test email\n\nYou can now send a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email. If you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for any failures.\n\nThe Mandrill [Outbound Activity](https://mandrillapp.com/activity) page will now display delivery insights for all emails that have been sent to your users.",
  "title": "Configure Mandrill as External SMTP Email Provider",
  "description": "Describes how to configure Mandrill as an external SMTP email provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-azure-comm-service-as-smtp-email-provider",
  "markdown": "# Configure Azure Communication Services as External SMTP Email Provider\n\n#### Before you start\n\n*   Configure your tenant to send emails from Auth0 to your SMTP provider.\n    \n\n1.  Open ports and allow inbound traffic from your Auth0 to Azure Communications Services.\n    \n2.  Navigate to [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n3.  Update the list of IPs. To learn more, read [Auth0 IP Addresses for Allow Lists](https://auth0.com/docs/secure/security-guidance/data-security/allowlist)\n    \n\n*   Create a [Microsoft Azure](https://azure.microsoft.com/) account with an active subscription.\n    \n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only.\n\n## Configure Azure Communication Services\n\n1.  Log in to your [Microsoft Azure](https://azure.microsoft.com/) account.\n    \n2.  Create a [Communication Services](https://learn.microsoft.com/en-us/azure/communication-services/quickstarts/create-communication-resource?tabs=windows&pivots=platform-azp#create-azure-communication-services-resource) resource if you do not have one.\n    \n3.  Enter \"Communication Services\" in the search bar.\n    \n4.  Select **Create**.\n    \n5.  Under the **Tools** settings, select **Keys**. Retrieve your Communication Services [Connection String](https://learn.microsoft.com/en-us/azure/communication-services/quickstarts/create-communication-resource?tabs=windows&pivots=platform-azp#create-azure-communication-services-resource).\n    \n6.  Under **Primary Key**, copy the **Connection string** value.\n    \n    1.  A valid connection string follows the format `endpoint={commuication services url};accesskey={access key}`.\n        \n7.  With the Connection string value, navigate to Auth0 [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n8.  Select the **Use my own email provider**.\n    \n9.  Select **Azure Communication Services**.\n    \n10.  Complete the configuration:\n    \n    1.  Enter a **From** email address\n        \n    2.  Add the Azure Communication Services **Connection string**.\n        \n        ![](https://images.ctfassets.net/cdy7uua7fh8z/16RcDk5NxOlKJBGutQ3n2l/52c7e2f7edc00d04d381af3f86d8e713/2023-04-18_17-00-39.png)\n    3.  Select **Save**.\n        \n\n## Send a test email\n\nSend a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email.\n\nIf you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for error codes. The Communication Services [Metrics Monitor](https://learn.microsoft.com/en-us/azure/communication-services/concepts/metrics#chat-api-request-metric-operations) page will now display delivery insights for all emails that have been sent to your users.",
  "title": "Configure Azure Communication Services as External SMTP Email Provider",
  "description": "Describes how to configure Azure Communication Services as an email provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-sendgrid-as-external-smtp-email-provider",
  "markdown": "# Configure SendGrid as External SMTP Email Provider\n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only.\n\n## Prerequisites\n\n*   To ensure that emails can be sent from Auth0 to your SMTP, open ports and allow inbound connections from specific IP addresses. To update the list of IPs, navigate to [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider). See [Add IP Addresses to AllowList](https://auth0.com/docs/secure/security-guidance/data-security/allowlist) for details.\n    \n*   You must have a [SendGrid](https://sendgrid.com/) account. If you have a Microsoft Azure subscription, you can get a free account in the Azure Marketplace.\n    \n\n## Configure SendGrid\n\n1.  Log in to your [SendGrid](https://sendgrid.com/) account.\n    \n2.  Navigate to SendGrid **Settings > API Keys**, and click **Create API Key**.\n    \n3.  Type a name for your key and select **Restricted Access**.\n    \n4.  Under **Access Details**, click to expand **Mail Send**.\n    \n5.  Set the **Mail Send** permission to **Full Access**.\n    \n6.  Click **Save** and copy the key value.\n    \n7.  Navigate to Auth0 [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n8.  Activate the **Use my own email provider** toggle.\n    \n9.  Click the **SendGrid** logo.\n    \n10.  Type a **From** email address, paste the SendGrid **API Key** you copied, and click **Save**.\n    \n\n![Dashboard - Branding - Email Provider - SendGrid Settings](https://images.ctfassets.net/cdy7uua7fh8z/6anIzrpxKwsExQp4COpiT8/2ac488b1bdc726798579788ea2303841/dashboard-email-providers_settings_sendgrid.png)\n\n**Note:** If you are using [passwordless authentication with email](https://auth0.com/docs/authenticate/passwordless#email), ensure that the **From** email address value for your passwordless connection matches the **From** email address value you're using for SendGrid.\n\n## Test email\n\nYou can now send a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email. If you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for any failures.\n\nThe SendGrid [Email Activity](https://sendgrid.com/logs/index) page will now display delivery insights for all emails that have been sent to your users.",
  "title": "Configure SendGrid as External SMTP Email Provider",
  "description": "Describes how to configure SendGrid as an external SMTP email provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-sparkpost-as-external-smtp-email-provider",
  "markdown": "# Configure SparkPost as External SMTP Email Provider\n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only.\n\n## Prerequisites\n\n*   To ensure that emails can be sent from Auth0 to your SMTP, open ports and allow inbound connections from specific IP addresses. To update the list of IPs, navigate to [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider). See [Add IP Addresses to AllowList](https://auth0.com/docs/secure/security-guidance/data-security/allowlist) for details.\n    \n*   You must have a [](https://www.mandrill.com/signup/)[](https://mailgun.com/)[SparkPost](https://www.sparkpost.com/) account.\n    \n\n## Configure SparkPost\n\n1.  Log in to your [SparkPost](https://www.sparkpost.com/) account.\n    \n2.  Navigate to SparkPost [Sending Domains](https://app.sparkpost.com/account/sending-domains), and add your custom domain. SparkPost allows sending emails from only verified domains.\n    \n3.  Navigate to SparkPost [Account API Keys](https://app.sparkpost.com/account/credentials), and click **New API key**. Save this key value and ensure it has `Transmissions: Read/Write` access. Copy this key value.\n    \n4.  Navigate to Auth0 [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n5.  Activate the **Use my own email provider** toggle.\n    \n6.  Click the **SparkPost** logo.\n    \n7.  Provide a **From** email address, enter the SparkPost **API Key** you previously copied, select your **Region**. If you are changing to the EU region in an account that was already configured for the US region, you must replace the **API Key** in Auth0 with a Sparkpost EU API Key.\n    \n    ![Emails Configure SparkPost SMTP Email Provider Values Screen](https://images.ctfassets.net/cdy7uua7fh8z/6ZLmp0ZUeSBVhphofziBC2/30e5ccc960fbcabbc2e3feba95f50425/dashboard-email-providers_select-provider.png)\n8.  Click **Save**.\n    \n\n## Test email\n\nYou can now send a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email. If you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for any failures.\n\nIf you haven't registered a custom domain with SparkPost, you can send a maximum of five test emails from the `sparkpostbox.com` domain. For more details, see SparkPost's [Transmissions: The Sandox Domain](https://developers.sparkpost.com/api/transmissions.html#header-the-sandbox-domain).\n\nThe SparkPost [Message Events](https://app.sparkpost.com/reports/message-events) page will now display delivery insights for all emails that have been sent to your users.",
  "title": "Configure SparkPost as External SMTP Email Provider",
  "description": "Describes how to configure SparkPost as an external SMTP email provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/provisioning",
  "markdown": "# Provisioning (B2B)\n\nDetermining how users get signed up is important to address early, and the decisions you make here will influence many of the decisions you will need to make going forward. We’ve found there are a typical set of patterns for how users will get added to your system, and things to take note of when considering workflow design too.\n\n### Best practice\n\nWhile Auth0 supports numerous workflows, web based workflows using Auth0 [Universal Login](https://auth0.com/docs/login/universal-login) for sign up are considered both industry and Auth0 best practice as they provide for optimal functionality and the best security.\n\nAuth0 supports user sign up via a number of different [identity providers](https://auth0.com/docs/authenticate/identity-providers). During sign up, Auth0 provisions the [user profile](https://auth0.com/docs/videos/get-started-series/learn-user-profiles) so that it contains the user’s account information. There are a number of things to consider when looking at functionality and workflow:\n\n*   Does a user get added to your company's domain or do they belong to or remain in their organization's domain?\n    \n*   If the user stays in their own domain, do they belong to a single organization or can they belong to multiple organizations?\n    \n*   How do you provision the organization itself in your system?\n    \n*   Should you use Auth0 as an identity store?\n    \n*   Can you use your own (legacy) identity store with Auth0?\n    \n*   How do you migrate user identities from your identity store to Auth0?\n    \n*   Can your users sign up using their organization's identity provider?\n    \n*   Can your users be invited or self register?\n    \n\nOne of the first determinations to make when providing your service(s) to other businesses is identifying to which domain users belong. Based on the answer to that question, there are a couple of different approaches you can take to provision those users. See [Provisioning organization users](#provisioning-organization-users) for more information. Once you know how you want organizations to be represented in your system, you will want to consider how you are going to provision the organization itself. See [Provisioning organizations](#provisioning-organizations) for more information.\n\nAuth0 provides out-of-the-box identity storage that can be leveraged to store user credentials safely and securely. See [Self Sign Up](#self-sign-up) for more information. If you already have a legacy identity store and you want to offload the management of it, then the [User Migration](#user-migration) capabilities provide you with a number of options to do so.\n\nAlternatively, if you have to maintain your legacy identity store - perhaps because you’ve got applications which you aren’t ready to migrate or which can’t be migrated - then you can use the [identity store proxy](#identity-store-proxy) capability. Allowing your customers to use “bring their own identity” is also an attractive proposition and though we find our customers don’t initially do so, you can use the [Social Sign Up](#social-sign-up) capability to provide it.\n\n### Get Started with Auth0 Videos\n\nWatch these two short videos [Provision: Users Stores](https://auth0.com/docs/videos/get-started/02-provision-user-stores) and [Provision: Import Users](https://auth0.com/docs/videos/get-started/03-provision-import-users) to learn how user profiles are provisioned within an Auth0 tenant and how Auth0 allows you to move your existing users to an Auth0 user store.\n\n## Provisioning organizations\n\nWhat you need to do when provisioning an organization will depend on how organizations are represented in your system. This can take some time to step back and consider how users of those organizations will be interacting with your applications. See [Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture) to determine how to configure organizations for your IAM system.\n\nWhen provisioning organizations you need to consider the following:\n\n*   You will need to add the organization to your own application configuration and/or database\n    \n*   You will need to make changes to your Auth0 configuration. This will include doing some or all of the following:\n    \n    *   In rare cases: create a unique tenant for the organization\n        \n    *   Create a new Organization in your Auth0 Tenant\n        \n    *   Add a new a database connection for that Organization (if you have isolated users per organization)\n        \n    *   Enable the existing shared database connection for that Organization (if you are sharing users)\n        \n    *   Add an enterprise connection for this Organization and enable it on the Organization\n        \n        *   This will include working with the organization to either update their existing configuration or add configuration for your Auth0 tenant if they are not a legacy organization.\n            \n    *   Provision an administrator for the organization\n        \n*   To avoid mistakes, you may want to create an [Organization Admin Portal](#organization-admin-portal) to make it easier to provision new organizations.\n    \n*   You may also want to create a Self-Signup portal for your Organizations. This allows your customers to create the organization themselves. This can be part of the [Organization Admin Portal](#organization-admin-portal).\n    \n\n### Organization Admin Portal\n\nAn organization admin portal is a portal that allows your administrators to create, modify, and remove organizations. These administrators can either be employees of your company, or customer admins. There are multiple activities that need to be done both in your own system and your Auth0 tenant. This portal will likely need to exist in your own system so it has access to your datastores and configuration. However, Auth0 provides the [Auth0 Management API](https://auth0.com/docs/api/management/v2) so that you can incorporate changes to your Auth0 tenant at the same time that you create the changes in your own system.\n\nThere are two main approaches that can be taken for creating a new organization. The one you choose depends highly on your tolerance for how long it would take to deploy a new organization.\n\n*   **Live Updates to your Auth0 Tenant**: If you want to be able to create new organizations in real-time, then you will likely want to make the changes directly to your Auth0 tenant using the Auth0 Management API. This allows the changes to take place in real-time and allow the addition of a new organization to take effect immediately. Particulary if you are providing Self-Signup for organizations you may want to do this approach.\n    \n\n*   **Change the Repository and Re-deploy**: If you are taking advantage of the Deploy CLI (or a custom CLI) as part of your [CI/CD pipeline](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/deployment), you may prefer to push your changes directly to your repository and then kickoff a new deployment instead. This can take a little more time, but it has benefits associated with version history and the ability to backout a change by re-deploying the previous version. You may want to have a separate repository just for the items that the organizations need so that you don't have to re-deploy other common components and risk making an error.\n    \n\n## User migration\n\nIn addition to hosting the [User Profile](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/profile-management), Auth0 also has the capability to both [proxy](#identity-store-proxy) your own legacy identity store and provide a secure Auth0 hosted replacement. Both of these capabilities are supported via the use of Auth0 [Database Connections](https://auth0.com/docs/authenticate/database-connections). If you decide to use Auth0 as a replacement for your legacy identity store then you can [migrate users](https://auth0.com/docs/manage-users/user-migration) either all at once with bulk migration, or progressively with automatic migration.\n\n### Best Practice\n\nCustomers often opt for a two-stage approach to user migration, using Automatic Migration first to migrate as many users as possible, then using Bulk Migration for the users that remain. See [User Migration Scenarios](https://auth0.com/docs/users/import-and-export-users/user-migration-scenarios) for more information.\n\nAutomatic Migration is preferred as it allows users to be migrated individually and also allows them to retain their existing passwords in almost all situations. For Bulk Migration, we recommend using the [Management API](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) over the [User Import/Export extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension) in all but the most simple cases, as the Management API provides for greater flexibility and control.\n\nWith Bulk Migration users typically need to **reset their password once the migration is complete** unless passwords are stored hashed in your legacy identity store using one of the supported algorithms. In this case, you may be able to use bulk migration and **preserve user passwords** as part of the process, depending on the algorithm and the number of salt rounds used. See [Bulk Import Database Schema Examples](https://auth0.com/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples) for more information.\n\n### Best Practice\n\nCalls to the Management API are subject to [Auth0 Rate Limiting policy](https://auth0.com/docs/support/policies/rate-limit-policy). You must take this into consideration, and to assist, Auth0 generally recommends use of the appropriate [Auth0 SDK](https://auth0.com/docs/libraries) for your development environment rather than calling our APIs directly.\n\n### Identity store proxy\n\nAuth0 Database Connection types can also be configured to proxy an existing (legacy) identity store. If you need to keep user identities defined in your own legacy store - for example, if you have one or more business critical applications that you can’t migrate to Auth0, but which still need access to these identities - then you can easily integrate with Auth0. See [Authenticate Users Using Your Database](https://auth0.com/docs/authenticate/database-connections/custom-db) for more information.\n\n## Provisioning organization users\n\nAn organization should map directly to one of your business customers/partners. Each business/partner that you are working with has users who will be logging in. We call those end users \"organization users\". There are two different approaches to how to store your organization users:\n\n*   **Isolated to the organization**: Every user belongs to exactly one organization. It would not make sense for that user to be a part of more than one organization, and even if they were, it would make sense for them to have a separate “identity” for that other organization. For example, a retail employee that works part time at two different stores has two different logins for each of those stores even if the stores both use the SaaS application. To learn more, see [Provisioning users isolated to the organization](#provisioning-users-isolated-to-the-organization).\n    \n*   **Shared between organizations**: In a case like this, users either create credentials in your company, or they can access other organizations instances of your application using credentials from their own organization. A simple way to look at this is that one user may be authorized to access more than one organization’s instance of the application. A user would understand that they can use the same credentials to access both instances of an application. For example, some doctors contract with multiple clinics and may need to be able to sign into each separate clinic with their same credentials. To learn more, see [Provisioning users shared between organizations](#provisioning-users-shared-between-organizations).\n    \n\n### Provisioning users isolated to the organization\n\nIsolating users to the organization can provide a nice clean barrier between organizations. If no users ever need to access more than one organization (or you would rather force them to create multiple accounts), then this is an attractive approach.\n\nYou need to provision those users at the IdP level. Each of the organizations will have its own IdP for accomplishing this. This IdP will come in one of three flavors:\n\n*   **Your Auth0 Tenant is the IdP**: A Database Connection in your main tenant dedicated to this organization.\n    \n*   **Organizations bring their own IdP**: You set up an Enterprise Connection for them.\n    \n*   **Organizations with more than one IdP**: You enable more than one Enterprise Connection, Social Connection, and also may have a single Database Connection. When the user chooses their organization and attempts to log in, they will be able to choose from all of the connections that have been enabled for that organization.\n    \n\nWe recommend using Auth0 as an IdP as a starting point because it’s simple to implement a [user invite workflow](https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members). Compared to other invite flows, the only thing special about this is that the person who is creating the user will have to either select the organization ahead of time, or the system will force the organization to match that of the user doing the inviting (in situations where there is an organization administrator who belongs to that organization only).\n\n### Provisioning users shared between organizations\n\nWhen sharing users between organizations, you will need a way to authorize access. Because you won’t know where a user might belong when authenticating, we typically recommend storing your users in a single domain and then figuring out which organizations they can access by adding them as [members of the organization](https://auth0.com/docs/manage-users/organizations/configure-organizations/assign-members). Because of this, provisioning will often be done by starting with a User Invite workflow for the single database connection, and then they will be added to the organization using the management API. You can then use the management API to retrieve which [organizations the user belongs to](https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-user-membership) if you need to provide a way for them to switch between organizations.\n\n### Deprovisioning limitations\n\nAuth0 will not communicate with the upstream IdP if there is an active SSO session with Auth0 unless you force it with a `prompt=login`. If one of your customer organizations can not manage logout for those users, they may still have access after they’ve been decommissioned. Depending on the IdP, if Auth0 gets a token for their API, you can request information about the user from the IdP in a [rule](https://auth0.com/docs/customize/rules) to poll whether that user should still have access or not. If you don’t have this ability, you will have to provide your customer organizations with a way to trigger a block or decommission of users in your system either through an API call or a UI.\n\n## User invite\n\nIn most B2B scenarios, only particular individuals are allowed access to the application. As a result, it is often simpler to have an administrator provision user accounts rather than having users sign up and then have an administrator approve them. Provisioning can often be done in an automated fashion when users are added to a centralized system as well.\n\nThere are three different personas who might be [inviting users](https://auth0.com/docs/design/creating-invite-only-applications):\n\n*   An administrator at your company may create the users for each organization.\n    \n*   An administrator from each organization may be assigned to creating users.\n    \n*   Another system responsible for creating users may exist, and that system may then create a user in Auth0. Regardless of the audience, the technique can be similar. The rest is a matter of using the right authorization model for the application.\n    \n\nThe recommended approach for user invite is to use the [Organizations Feature](https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members) to accomplish this. If you are **not** using the Organizations Feature to implement user invites and are building your own, it is important to create each user with the `user.email_verified` parameter set to `false` and a random temporary password. The generated password should only be known to Auth0 and **not** stored in any external system nor passed to the user! Then, use the [Management API](https://auth0.com/docs/api/management/v2#!/Tickets/post_password_change) to send an email to the user with a link to reset their password; you can even modify the email template in Auth0 to reflect that this is part of an invited sign-up workflow too. This ensures that the user's email address belongs to the user being created and the only person who knows the password is the user themselves.\n\n## Enterprise sign up\n\nEnterprise sign up is synonymous with sign in via [enterprise login](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/authentication)—there’s no distinction here per se, as user [profile](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/profile-management) creation happens automatically upon first enterprise login.\n\n### best practice\n\nA nice advantage of allowing your customers to use their own IdP is that they can administer their users and assign roles and access in their own IdP setup instead of forcing you to build administration for them. Working out the mapping for those customers will make this much easier.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)\n\n## Multiple Organization Architecture (Multitenancy)\n\nMany B2B platforms implement some form of isolation and/or branding for their customers' organization, and this can add complexity to any Identity and Access Management (IAM) system. If this applies to you, then we recommend you take some time to read through our guidance and best practice advice for this type of environment.\n\n[Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)",
  "title": "Provisioning (B2B)",
  "description": "User provisioning functionality and considerations for your B2B IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/architecture",
  "markdown": "# Architecture (B2B)\n\nUnderstanding your application is key to understanding how Auth0 can be leveraged to meet your needs. From experience, our most successful customers start with a visualization of their proposed - or in many cases existing - architecture and use this as a basis for reference as they progress. Understanding where your application fits within your organization is also important; Auth0 [Accounts and Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants) form the basis for the grouping and structuring of Auth0 assets, and it may be that you’ll need to leverage an existing Auth0 deployment in order to integrate with [Single Sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on), centralized user [Profile Management](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/profile-management), consolidated billing, or the like.\n\n### Best Practice\n\nIf you do have multiple applications, and you need to leverage SSO, then we recommend you check out our [How to Implement Single Sign-On](https://auth0.com/learn/how-to-implement-single-sign-on/) training guidance before continuing.\n\nThe value of investing time on the landscape of the architecture up-front is something that we have found pays dividends in the long run, and there are a number of things you will want to consider when looking at functionality and workflow:\n\n*   What should the URL look like when Auth0 needs to present a web page to a user?\n    \n*   How can Auth0 be structured to support your SDLC (Software Development Lifecycle)?\n    \n*   How can you ensure that your Auth0 tenants are appropriately associated with your contract?\n    \n*   What do you need to consider if there are other projects in your organization integrating with Auth0? Particularly projects that target their own, or a different domain of users (for example, applications that only employees will use)?\n    \n*   How can you align the structure and domain of your customers’ organization with your Auth0 deployment?\n    \n\nOrganizations often service more than one domain of user - customers, employees, and affiliates being the most frequently encountered, with typically little to no cross-over: employees, say, don’t use the same applications as customers and vice-versa. In some cases there can also be a need to partition further within a domain - separate groups of customers, say, who use different and unconnected products. Auth0 provides a way to segregate your users and the associated collateral, and [tenant provision](#tenant-provision) covers this in more detail. If you need to provision an independent tenant then you’ll also want to [associate this with your existing Auth0 account](#tenant-association), so that you can take full advantage of the benefits provided at your organization’s contracted subscription level.\n\n### Best Practice\n\nIt’s not uncommon for companies to have identity requirements that address multiple user communities: customers, partners, employees, etc. So be sure to consider other projects or future requirements when designing your architecture.\n\nIn addition, you’ll undoubtedly have an established set of processes and procedures as part of your Software Development Lifecycle (SDLC). So you’ll want to check out our [SDLC support](#sdlc-support) guidance regarding Auth0 Tenant provision in support of that too.\n\nFor customer-facing applications, we typically see [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) as being the most frequently used protocol. OIDC makes use of web based workflows with browser URLs that are presented to the user. Out-of-the-box, client facing URLs as part of Auth0 OIDC support are Auth0 branded, however we recommend using the Auth0 [custom domain](#custom-domains) capability to provide for consistent corporate identity and to also address potential user confidence concerns before they arise.\n\n### Best Practice\n\nOther groups within your organization may also be working with Auth0; it’s not uncommon for our customers to have disparate departments that serve different user communities. Identifying these will potentially influence your design choices, and doing so early could mitigate decisions that might prove costly later on.\n\nIf some or all of your customer organizations each need their own custom URL or they are using social providers that need a custom consent page branded to the organization, then we recommend that you create separate Auth0 tenants for those organizations; see [Tenant provision for complex organizations](#tenant-provision-for-complex-organizations) for further details.\n\n## Tenant provision\n\nEverything starts with an Auth0 tenant. This is where you will be configuring your use of Auth0, and the where Auth0 assets - such as [Applications](https://auth0.com/docs/get-started/applications), [Connections](https://auth0.com/docs/connections) and [user profiles](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/profile-management) are defined, managed and stored. Access to an Auth0 tenant is performed via the Auth0 [Dashboard](https://auth0.com/docs/get-started/auth0-overview/dashboard), and via the Dashboard you can also create additional, associated tenants; you’re allowed to create more than one Auth0 tenant so that you can structure your tenants in a way that will isolate different domains of users and also support your [Software Development Life Cycle](#sdlc-support) (SDLC).\n\nDetermining the level of isolation you require when it comes to your user domains is an important step, and together with your branding requirements will subsequently help you determine the number of Auth0 tenants that will be required in your production environment. As we recommend you create a full suite of [SDLC supporting tenants](#sdlc-support) for every Auth0 tenant you will run in a production environment, the number of Auth0 tenants you will need to manage can quickly grow. Therefore you should consider carefully before creating multiple Auth0 tenants for production, and should consult our guidance on [Branding](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/branding) before making your final decision.\n\n### Tenant provision for complex organizations\n\nIn most cases, provisioning separate Auth0 tenants for your customer's organizations is not necessary. This has become even easier with the release of our new [Organizations feature](https://auth0.com/docs/manage-users/organizations/organizations-overview). However, in certain circumstances this can be something that is valuable for reducing the complexity of your setup. For instance, we recommend provisioning a separate Auth0 tenant for your customers' organization as a best practice if:\n\n*   Your customer organizations need a custom login URL that is unique to the organization. This is generally the case only if you allow your organizations to have their own vanity URL instead of using a common login URL. Auth0 supports one custom domain per tenant.\n    \n*   Your customer organizations use social providers for login. In this case, it is often desirable for the organization to have a custom consent page for the social provider that is branded to their organization.\n    \n\nIf either of these situations is true, we recommend creating a separate Auth0 tenant for each organization that has one of the above criteria.\n\n## Tenant association\n\nTo ensure that your [tenants are all associated with your Auth0 contractual agreement](https://auth0.com/docs/get-started/auth0-overview/create-tenants/child-tenants) and have the same features, ensure all your tenants are associated with your company account. If you have individual developers that want to create their own sandboxes for testing, make sure they get associated with your account so they have the same permissions too. To do this you should contact your Auth0 representative or the [Auth0 Support Center](https://support.auth0.com/).\n\n## Custom domains\n\nWhen you setup your Auth0 tenant, the URL for accessing that tenant will be of the form `https://{yourTenant}.auth0.com`. Providing a [Custom Domain](https://auth0.com/docs/customize/custom-domains) (also known as a vanity URL), for your Auth0 tenant is not only an important factor for supporting your Branding requirements, but more importantly will also provide you with security benefits too:\n\n*   Some browsers will, by default, make it [difficult to communicate in an iFrame if you don't have a shared domain](https://auth0.com/docs/troubleshoot/authentication-issues/renew-tokens-when-using-safari).\n    \n*   It's [harder to phish your domain if you have a vanity URL](https://auth0.com/blog/introducing-custom-domains-preview-with-auth0/), as the phisher must also create a vanity URL to mimic yours. For example, with a custom domain you can use your own certificate to get an \"Extended Validation\", making phishing even harder.\n    \n\nYour custom domain name should also give the user confidence that this is the appropriate place to enter their credentials, and we recommend that you create your custom domain in all environments early on to ensure that you are testing consistently between environments. **It's extremely important to train your users to to look for suspicious URLs when entering their credentials!**\n\n### Best Practice\n\nCreate a custom domain (a.k.a. `CNAME`) for your Auth0 tenant, and also create one in development too so you can ensure you have managed the `CNAME` correctly. For example, you could create a `CNAME` which maps `login.mycompany.com` to `mycompany-prod.auth0.com`.\n\nIn almost all cases, customers have been most successful when adopting a strategy of a centralised domain for authentication across multiple product or service brands. This strategy provides users with a consistent UX, and also mitigates the complexity of deploying and maintaining multiple Auth0 tenants in a production environment. If you are considering having multiple domains for different brands, please refer to the [Branding](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/branding) guidance before you begin implementing.\n\n## SDLC support\n\nEvery company has some form of Software Development Life Cycle (SDLC), and throughout the development process you will want to align with that strategy. For instance, you need to be able to test your integration with Auth0 in a similar fashion as you test the applications themselves. It is therefore important to [structure Auth0 tenants to support your SDLC](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments), and there is a consistent pattern which our customers typically follow when it comes to the best practices associated with tenant layout for doing so:\n\n| Environment | Sample Tenant Name | Description |\n| --- | --- | --- |\n| Development | **company-dev** | A shared environment where most of your development work occurs |\n| QA/Testing | **company-qa** or **company-uat** | An environment for formal testing of the changes you've made |\n| Production | **company-prod** | The production tenant |\n\nIn some cases you may also want to create one or more sandboxes (e.g., **company-sandbox1**, **company-sandbox2**) so that you can test changes without compromising your development environment. This might be where you test deployment scripts and the like.\n\n### Best Practice\n\nYou can also take advantage of our [Implementation Checklists](https://auth0.com/docs/architecture-scenarios/checklists) that you can download and customize to meet your implementation project needs.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)\n\n## Multiple Organization Architecture (Multitenancy)\n\nMany B2B platforms implement some form of isolation and/or branding for their customers' organization, and this can add complexity to any Identity and Access Management (IAM) system. If this applies to you, then we recommend you take some time to read through our guidance and best practice advice for this type of environment.\n\n[Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)",
  "title": "Architecture (B2B)",
  "description": "How you configure your Auth0 tenant architecture affects your B2B IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-mailgun-as-external-smtp-email-provider",
  "markdown": "# Configure Mailgun as External SMTP Email Provider\n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only.\n\n## Prerequisites\n\n*   To ensure that emails can be sent from Auth0 to your SMTP, open ports and allow inbound connections from specific IP addresses. To update the list of IPs, navigate to [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider). See [Add IP Addresses to AllowList](https://auth0.com/docs/secure/security-guidance/data-security/allowlist) for details.\n    \n*   You must have a [](https://www.mandrill.com/signup/)[Mailgun](https://mailgun.com/) account.\n    \n\n## Configure Mailgun\n\n1.  Log in to your [Mailgun](https://mailgun.com/).\n    \n2.  Navigate to Mailgun **Sending > Domains**, and add your custom domain. Mailgun allows sending emails from only verified domains.\n    \n3.  Navigate to Mailgun **Settings > API Keys**. Your API key was created when you signed up for your account; copy it from **Private API Key**.\n    \n4.  Navigate to Auth0 [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n5.  Activate the **Use my own email provider** toggle.\n    \n6.  Click the **Mailgun** logo.\n    \n7.  Provide a **From** email address, enter the **Domain** you previously added to Mailgun, enter the Mailgun **API Key** you previously copied, select your **Region**.\n    \n    ![Emails Configure Mailgun External SMTP Email Provider Values Screen](https://images.ctfassets.net/cdy7uua7fh8z/7J5mFiePY4dnBDfRm3YN5O/1b8243430a7e1fd27bbf40907f4bb647/dashboard-email-providers_select-provider.png)\n8.  Click **Save**.\n    \n\n## Test email\n\nYou can now send a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email. If you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for any failures.\n\nThe [Mailgun Dashboard](https://app.mailgun.com/app/dashboard) will now display delivery insights for all emails that have been sent to your users.",
  "title": "Configure Mailgun as External SMTP Email Provider",
  "description": "Describes how to configure Mailgun as an external SMTP email provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation",
  "markdown": "# Delegation with OIDC\n\nTraditionally, delegation is used to:\n\n*   Exchange an ID token issued to one application for a new one issued to a different application.\n    \n*   Get a fresh ID token using a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens).\n    \n*   Exchange an ID token for a third-party (e.g., Firebase, AWS) API token.\n    \n\nBecause the OIDC-conformant pipeline requires that ID tokens no longer be used to secure APIs and refresh tokens be used only at the [`/oauth/token`](https://auth0.com/docs/api/authentication#refresh-token) endpoint; the [`/delegation`](https://auth0.com/docs/api/authentication#delegation) endpoint is deprecated.\n\nOIDC-conformant applications cannot be the source or target of delegation requests.\n\n## Third-party APIs\n\nBecause no OIDC-compliant mechanism exists to get third-party (e.g., Firebase, AWS) API tokens, delegation can still be used to obtain third-party API tokens.\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)\n*   [Single Sign-On with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-sso)",
  "title": "Delegation with OIDC",
  "description": "Learn how the OIDC-conformant pipeline affects your use of delegation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/branding",
  "markdown": "# Branding (B2B)\n\nAuth0 can be customized with a look and feel that aligns with your organization's brand requirements and user expectations. Branding Auth0 collateral provides a consistent user experience for your customers, and gives them peace of mind that they’re using a product from a trusted and secure provider.\n\nAuth0 provides support for [internationalization (I18N)](https://auth0.com/docs/customize/internationalization-and-localization) and localization (L10N), both of which are important if you work on branding for an international clientele. Out-of-box collateral, such as the Auth0 Lock UI widget and Universal Login, comes ready enabled for multiple language support, with built-in extensibility for adding more languages if what you require [doesn’t already exist](https://auth0.com/docs/customize/internationalization-and-localization/lock-internationalization).\n\n### Best Practice\n\nAlmost all applications need Internationalization and/or Localization in one form or another. Auth0 makes it easy to add, but you need to account for it up front: retro-fitting localization, for example, can be a painful process if left too late.\n\nWhen considering the items you want to brand, as well as how best to brand them, there are a number of things you'll want to review:\n\n*   Do you need to brand your login page?\n    \n*   Do you need to localize your login page?\n    \n*   If you are sharing an Auth0 tenant across customer organizations, should you add organization-specific branding to their login experience?\n    \n*   How can you customize emails so that they're not just branded, but vary based on user preference?\n    \n*   How will users know that they're still on your domain when they see your login page?\n    \n*   What do you need to do to provide additional browser security (e.g., implement Extended Validation)?\n    \n*   Where do you want to direct users in the event of errors?\n    \n\nAuth0 provides tremendous flexibility when it comes to customizing and configuring Auth0 pages such as [Universal Login](#universal-login-and-login-pages) and [Password Reset](#password-reset-page-customization). So you can pretty much set up whatever UX look and feel you require. For many, the out-of-the-box experience - with perhaps a little alteration - is all that's required. However, for others the value of their brand and brand awareness requires more extensive customization. This flexibility extends to not only Auth0 pages, but via extensibility can also be applied to the [email templates](#email-template-customization). Auth0 [Custom Domain](#custom-domain-naming) functionality further enhances consumer awareness by providing users with the confidence and peace of mind when it comes to safety and security.\n\nIf you are sharing an Auth0 tenant across multiple customer organizations, providing each organization with their own domain of users and managing their credentials, you will need to consider how each user will know which credentials they should use and how they will trust that they are entering them somewhere safe and secure. See [Branding login by organization](#branding-login-by-organization) for details.\n\nWhile Auth0 provides for default information when it comes to error situations, out-of-the-box information can be somewhat cryptic as the context that can only be provided by you is missing. Auth0 [error page customization](#error-page-customization) guidance can however help mitigate that by allowing you to provide information of a more context-specific nature via your own support organization.\n\n### Best Practice\n\nTo provide helpful resources for users who experience problems, you should also configure a friendly name and a logo, as well as provide the support email address and URL for your organization. To learn how, see [Dashboard Tenant Settings](https://auth0.com/docs/dashboard/reference/settings-tenant#settings).\n\n## Universal login and login pages\n\n[Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) is the recommended method for authenticating users, and it centers around use of the Login page. You can customize the Login page to support your organization's branding requirements.\n\n## Branding login by organization\n\nWhether or not you need to do special customization on the Universal Login page is determined by how you plan to manage your customers’ organization. Before reading through this section, make sure you have read through the [Universal Login section](#universal-login-and-login-pages) and know how you are approaching organizations by reviewing [Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture).\n\nIf your organization users will all be isolated from each other, it’s important to make it clear on the Universal Login page which organization the login page is for. The easiest way to do this is to use the [Organizations Feature](https://auth0.com/docs/manage-users/organizations/create-first-organization) which provides you a way to store logo, primary color, and background color which will be used to customize the branding on the Universal Login Page once the organization has been identified either by passing org\\_id from the application or the user entering their organization at the organization prompt.\n\n## Custom domain naming\n\nBy default, the URL associated with your tenant will include its name and possibly a region-specific identifier. For example, tenants based in the US have the a URL similar to `https://example.us.auth0.com` while those based in Europe have something that is of the fashion `https://example.eu.auth0.com`. A [Custom Domain](https://auth0.com/docs/customize/custom-domains) offers a way of providing your users with a consistent experience by using a name that’s consistent with your organization's brand.\n\nIn addition, Custom Domain functionality offers you complete control over the certificate management process. By default, Auth0 provides standard SSL certificates, but if you configure a custom domain, you can use Extended Validation (EV) SSL certificates or similar to provide the visual, browser-based cues that offer your visitors additional peace of mind.\n\nIn general, we see customers having the most success when they use a centralized domain for authentication - this is especially the case if the company offers multiple products or service brands. By using a centralized domain, you can provide end users with a consistent user experience while also minimizing the need to maintain multiple production tenants in Auth0.\n\n## Email template customization\n\nAuth0 makes extensive use of email to provide both user notifications and to drive the functionality needed for secure identity management (for example, email verification, account recovery, and brute force protections), and Auth0 provides a number of templates for these.\n\nOut of the box, the email templates used contain standard verbiage and Auth0 branding. However, you can configure almost every aspect of these templates to reflect the verbiage and user experience you want and make changes to things like the preferred language, accessibility options, and so forth.\n\nEmail templates are customized using [Liquid syntax](https://auth0.com/docs/customize/email/email-templates/use-liquid-syntax-in-email-templates). If you are interested in customizing your templates based on user preferences, you will also have access to the [metadata](https://auth0.com/docs/manage-users/user-accounts/metadata) located in users' profiles, as well as any specific application metadata too.\n\n## Password reset page customization\n\nThe [Password Reset](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page) page is used whenever a user takes advantage of password change functionality and, as with the login page, you can customize it to reflect your organization's particular branding requirements.\n\nIf your organization users will all be isolated from each other (i.e, each organization gets its own Auth0 [database connection](https://auth0.com/docs/connections/database)), and you are branding the [Universal Login](#universal-login-and-login-pages) pages by organization, then it's also important to brand things like the password reset page so users know for which organization the password change is occurring. This can be done in a couple of ways:\n\n*   Create JavaScript on the Password Reset page that can pull resources from a CDN based on the connection parameter that indicates from which organization the user is coming.\n    \n*   Create a separate tenant for an organization and use Universal Login to customize what is required for that organization.\n    \n\n## Error page customization\n\nIf there are issues encountered during user interactive workflow (e.g. user sign up or login), Auth0 provides error messages that indicate what the problem is under the hood. The default messages are somewhat cryptic, especially to the end user, since they will likely be missing context that only you can supply. As such, we recommend [customizing your error pages](https://auth0.com/docs/customize/login-pages/custom-error-pages) to provide the missing context-specific information directly to your users. Furthermore, customizing your error pages allows you to display your branding, not Auth0's, as well as provide useful information to your users as to what should be done next. This information might include a link to a FAQ or how to get in touch with your company's support team or help desk.\n\n### Best Practice\n\nOut-of-the-box there is no user interface for customizing Auth0 provided error pages, but you can use the [Tenant Settings endpoint of the Management API](https://auth0.com/docs/api/management/v2#!/Tenants/patch_settings) to configure them. Alternatively, if you can create and host your own error page, then you can have Auth0 direct users to that page instead of using the Auth0-hosted option.\n\n## Guardian multi-factor page customization\n\nThe Multi-factor Authentication pages can be customized by adjusting the Universal Login branding options in the [Universal Login Settings](https://manage.auth0.com/#/login_settings) section.\n\nIf you need further customization, you can also customize [the full HTML content](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login) to reflect your organization's particular UX requirements.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)",
  "title": "Branding (B2B)",
  "description": "How to configure Auth0 items to reflect your brand and desired user experience.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/deployment",
  "markdown": "# Deployment Automation (B2B)\n\nIn addition to adopting best practices for change management and [QA](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/quality-assurance), successful customers will also integrate Auth0 collateral management as part of some automated deployment process. As discussed in the Architecture section under [SDLC support](https://auth0.com/docs/architecture-scenarios/b2b/architecture#sdlc-support), you will want to ensure you configure separate Auth0 tenants for development, testing, and production environments, and you will want that configuration to be almost identical for the tenant in each environment. Using deployment automation helps ensure this, so that each environment tenant is configured the same, and you will be less likely to see bugs show up as a result of mismatched configurations between environments.\n\n### Best Practice\n\nHowever you configure deployment automation, we’d recommend you unit test your rules, custom DB scripts, and hooks prior to deployment, and run some integration tests against your tenant post-deployment too. For more details regarding this, see the [Quality Assurance](https://auth0.com/docs/architecture-scenarios/b2b/quality-assurance) guidance provided.\n\nAuth0 provides support for a couple of different options when it comes to the deployment automation approaches you can use, and each can be used in conjunction with the other if desired:\n\n*   The [Auth0 Deploy CLI tooling](https://auth0.com/docs/deploy-monitor/deploy-cli-tool) provides you with an easy-to-use script that can help you integrate with your existing Continuous Integration/Continuous Deployment (CI/CD) pipeline.\n    \n*   If you can’t integrate directly with, or for some reason you don’t have a CI/CD pipeline, then the Auth0 [Source Control Extensions](https://auth0.com/docs/customize/extensions) can provide an easy-to-set-up basic automation process with very low maintenance.\n    \n\nEach environment may also need some environment-specific configuration--Application Client ID’s and Client Secrets will be different between the Auth0 tenants, for example--so you’re going to want some way of being able to dynamically reference this rather than having hard-coded values. Auth0 provides support for handling environment-specific configuration information through one of the following two approaches:\n\n*   Use [Tenant-specific variables](#tenant-specific-variables)\n    \n*   Use keyword replacement if using the Auth0 Deploy CLI tool\n    \n\n## Tenant-specific variables\n\nAuth0 allows you to configure variables that are available from within custom [extensibility](https://auth0.com/docs/customize/extensions); these can be thought of as environment variables for your Auth0 tenant. Rather than hard code references that change when moving code between development, test, and production environments, you can use a variable name that is configured in the tenant and referenced by the custom extensibility code. This makes it easier for the same custom code to function, without changes, in different tenants because the code can reference variables that will be populated with tenant-specific values at execution time:\n\n*   For use of variables in Actions, read [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action) to learn how to configure secrets in the editor\n    \n*   For use of variables in Rules, see how to [configure values](https://auth0.com/docs/customize/rules/configuration)\n    \n*   For use of variables in Hooks, see how to [configure secrets](https://auth0.com/docs/customize/hooks/hook-secrets) in the editor\n    \n*   For use of variables in Custom DB Scripts, see the [configuration parameters](https://auth0.com/docs/connections/database/custom-db/create-db-connection#step-3-add-configuration-parameters)\n    \n\n### Best Practice\n\nIt’s a recommended best practice to use variables to contain tenant-specific values as well as any sensitive secrets that should not be exposed in your custom code. If your custom code is deployed in GitHub/Gitlab/Bitbucket/VSTS, then using a tenant-specific variable avoids exposure of sensitive values via your repository.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)\n\n## Multiple Organization Architecture (Multitenancy)\n\nMany B2B platforms implement some form of isolation and/or branding for their customers' organization, and this can add complexity to any Identity and Access Management (IAM) system. If this applies to you, then we recommend you take some time to read through our guidance and best practice advice for this type of environment.\n\n[Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)",
  "title": "Deployment Automation (B2B)",
  "description": "How Auth0 tooling helps to automate tenant deployment.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/authentication",
  "markdown": "# Authentication (B2B)\n\nIn order to provide services to your users, you must be able to identify who those users are. This process is called User Authentication. There are a number of ways to perform authentication of a user - via social media accounts, username and password, passwordless - and it's often recommended that you go beyond a first factor for authenticating the user by enabling multi-factor authentication (MFA).\n\n### Best Practice\n\nIt's important to consider both security and user experience when designing how you will authenticate your users. Providing for multiple primary factors, and/or enforcing more than one factor during authentication, are ways that you can provide both.\n\nThere are a number of things you will want to consider when looking at functionality and workflow:\n\n*   Where will users enter their credentials?\n    \n*   How will you keep user credentials safe?\n    \n*   How will you maintain your authentication system?\n    \n*   How can you provide password authentication for your users?\n    \n*   How can you prevent hackers from trying to log in as your users?\n    \n*   How will you implement authentication in different kinds of applications?\n    \n*   How can you make login easy for your users when they come from different language backgrounds?\n    \n*   How will you provide a good user experience as you migrate away from any legacy authentication system?\n    \n*   What should you consider when integrating applications with Auth0?\n    \n*   Do you need to provide multi-factor authentication?\n    \n*   What do you do if you have a service that doesn't have a way for the user to log in ahead of time?\n    \n*   Can you pass the same user access token from one API to another?\n    \n*   What do you do if you need to isolate users by organization?\n    \n*   How will you handle identifying which organization users belong to?\n    \n*   What’s the benefit of providing enterprise connections for your organizations?\n    \n\nAuth0 [Universal Login](#universal-login) provides users with a safe and secure experience - no matter whether you choose to provide for user ID/password credentials sign in, or allow the so-called Bring Your Own Identity scenarios provided via [Social Login](https://auth0.com/learn/social-login/). There are also brand recognition benefits to centralizing the login experience with Universal Login, even if you feel you will also have product-specific [branding](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/branding) requirements. The Auth0 UI widgets typically used with Universal Login also provide out-of-the-box support with regards to [internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization) for users with different language requirements, and out-of-the-box support for Auth0 features such as [MFA](#multi-factor-authentication-mfa-) and [attack protection](#anomaly-detection) allow you to put barriers in place in order to prevent hackers attempting to access users' accounts.\n\nAllowing users to sign in via user ID/password credentials means that you're not reliant on the status of third-party identity providers for your users to access your system. You also have the means to require the credentials used to align with your corporate policies. Auth0 assists with this by providing you with multiple options in support of user ID/password logins, and the [guidance provided](#username-and-password-authentication) will help you understand you can leverage these options. Adding [social](#social-authentication) support at some stage, as an additional primary authentication factor, gives you added flexibility and can help you better understand your users without the need to question them further by leveraging the information already stored by the various social login [providers](https://auth0.com/docs/connections/identity-providers-social).\n\nIf you have an existing legacy identity store, you’ll also want to see [User Migration](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/provisioning). This section discusses the advantages of migrating to Auth0’s managed identity storage in terms of safety and security.\n\nFor customer facing applications, OpenID Connect ([OIDC](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)) is the most frequently used industry standard protocol, and OIDC has first-class citizen support in Auth0. Auth0 provides support for various different approaches for integrating various different applications, so you'll want to see the section on [application integration](#application-integration) for the information you'll need to make an informed choice.\n\nWhen calling one API from another API, or from any situation where there is no authenticated user context - such as one or more cron jobs, report generators, or continuous integration/delivery systems - you will need a way to authorize the application instead of a user. This is a one step process where the application is authenticated (using a client ID and secret) and then authorized in one call. You can learn more about this in our authorization work stream under [machine-to-machine (m2m) authorization](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/authorization).\n\nOften companies need to segregate their users by organization and sometimes users can have access to more than one organization. Knowing which of these scenarios is relevant to your company will help define how to determine in which connection a user exists: whether you need to do it, when you need to do it, and how to accomplish it. See [Home Realm Discovery](#home-realm-discovery) to determine if this is something relevant to your company.\n\n## Universal Login\n\nDo you have, or will you have, more than one application in your system? If the answer to this question is yes, then you will want a centralized sign in experience. To achieve a seamless Single Sign-on (SSO) experience between multiple applications, it is critical to have a centralized location to redirect your users for authentication. This allows you a way to provide your users with a consistent experience if you add social authentication in the future, add third party applications to your system, or add multi-factor authentication as an option (or requirement) for your users - and also allow you to take advantage of new features for improving your users’ experience with little, if any, added development effort.\n\n### Best Practice\n\nIf you have more than one application, the best practice is to redirect to a [centralized location](https://auth0.com/docs/universal-login) to authenticate the user. With Auth0, this means taking advantage of [Universal Login](https://auth0.com/docs/universal-login), which provides many security and user experience benefits out-of-the-box, including [SSO](https://auth0.com/docs/sso/current).\n\nAuth0 Universal Login makes authenticating users a short, easy process which can be accomplished in three easy steps (all of our Quickstarts demonstrate this and our SDKs hide the complexity for you too):\n\n1.  Determine how and when you want to [redirect from your application](#application-integration).\n    \n2.  Set up the appropriate [branding](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/branding) and/or customized HTML in your Auth0 configuration.\n    \n3.  Set up your application to [receive and handle the response](#application-integration) from the Authorization Server.\n    \n\n## Home realm discovery\n\nHome realm discovery (HRD) is the process of identifying which identity provider (or which connection in Auth0) the user belongs to before authenticating them. There are two ways HRD can occur:\n\n*   Provide a way for the decision to be made at the application\n    \n*   Have Home Realm Discovery happen on the Universal Login page\n    \n\nYour system may need to do either or both methods so it is important to understand all approaches to HRD so that you can apply the one(s) that make the most sense to your applications.\n\n### Application driven HRD\n\nA common way of determining which realm a user belongs to is when an application is branded for each organization. As part of this, an organization will typically have its own instance of the application, typically accessed via a different URL. This copy or instance can be physically isolated (running on a separate set of servers) or virtually isolated (running on shared servers) and is generally denoted through either a custom hostname (`companyA.application1.yourcompany.com`) or path (`application1.yourcompany.com/companyA`).\n\n### Best practice\n\nIf your application already knows the specific connection (IdP) required then you can also pass that along when you redirect the user to `/authorize`, via use of the `connection` query parameter.\n\nIf this is the case for your application(s), then home realm discovery is a simple matter of storing the `org_id` with the organization-specific application configuration and sending that as the organization parameter when redirecting the user to Universal Login. Doing so will limit the user to that specific organization and its set of configured connections.\n\n### Best practice\n\nIf an organization needs more than one IdP, then you may have to do a second round of Home Realm Discovery (once the organization has been identified). Auth0 will typically manage this for you if you are using the Organizations Feature.\n\nIf the user is shared between multiple organizations using a single identity, you must support [Home Realm Discovery on the Universal Login Page](#hrd-through-universal-login). This will allow Universal Login to identify the user first and then present the realms appropriate for that user leading to a better user experience.\n\nSending the organization and/or connection parameters can be achieved by adding them as a query parameter when you redirect the user to the `/authorize` endpoint. For more information, see the [Authentication API docs](https://auth0.com/docs/api/authentication#authorization-code-flow). However, you will generally accomplish this using the SDK for whichever language your application is written in.\n\n### HRD through Universal Login\n\nThere are three main approaches to Home Realm Discovery:\n\n*   Discover the realm through the user’s email subdomain.\n    \n*   Discover the realm by looking up a user identifier in some sort of map of an identifier to realm map.\n    \n*   Allow the user to choose or enter their realm (or organization).\n    \n\nIn both of the first two approaches, you may consider doing “Identifier First Login”. This means that you present only the ability to enter an identifier first. After which, you collect the user’s identifier, and then, based on the identifier, you either automatically redirect the user or present a way for the user to enter their password if redirection is unnecessary. Auth0 provides implementation out of the box to take care of all of this, via the use of [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first).\n\n#### HRD through Universal Login using the email subdomain\n\nThe simplest way to implement home realm discovery on the universal login page is to utilize the email subdomain of the user’s identifier to map that to their Identity Provider. This, of course, only works in situations where the email subdomain will be a 1:1 mapping to an organization or at least to an Identity Provider.\n\nAuth0’s [Lock](https://auth0.com/docs/libraries/lock) widget or [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience) can do this for you if you are using the domain map in an enterprise connection; however, if you want to build this yourself, you can, but it requires you to build a mapping of email subdomain to connection.\n\nAdditionally, when using the Universal Login experience, the [Organizations Feature](https://auth0.com/docs/manage-users/organizations/organizations-overview) will help you in two ways:\n\n1.  If you have not passed an org\\_id to `/authorize` when you initiated the login request, Auth0 will present the user with a prompt to enter the organization they belong to.\n    \n2.  If the Organization has more than one IdP associated with it, Auth0 will present the user with buttons to choose the organization or a form to enter a username and password.\n    \n\n#### HRD through Universal Login using the Identifier to Realm Map\n\nA second, more complex alternative is to store a map of identifiers to IdP and provide a public endpoint to access that information. Then on the Universal Login page, you can find the connection and redirect back to /authorize with the connection. The main drawbacks to this approach are latency and, more importantly, security when it comes to identifier discovery: if you’re using email addresses, this makes it much easier for someone to discover whether a particular email address is a user of yours.\n\n### Best practice\n\nAny public endpoint should have rate limiting applied to it to prevent hackers from using it to discover information and to prevent denial of service attacks.\n\n#### HRD through Universal Login using user choice\n\nThe other option is to allow your users to choose from a list, if you don’t mind making public the list of organizations who use your product, or by allowing the user to enter their organization name explicitly. This would typically be done before redirecting the user to Universal Login. Once the user tells you which organization they belong to, you can redirect to Auth0 with the connection for that organization specified or have Auth0 simply prompt the user for their username and password if the connection is a database connection.\n\n## Username and password authentication\n\nNearly every B2C application provides the ability for its customers to create a new set of credentials. This is a common form of authentication that all users are familiar with.\n\nUsername password authentication comes in multiple flavors at Auth0. If your application is a green-field application with no existing user base, then a simple Auth0 out-of-the-box [Database Connection](https://auth0.com/docs/connections/database) will give you everything you need to start authenticating your users. However, if you have a legacy user store (such as your own database of users or an existing LDAP system) you have a couple of different options for migrating your users as discussed in our guidance on [User migration](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/provisioning).\n\nHowever you end up provisioning the users for your database connection, the authentication of those users is quite similar. It requires you to present users with a form to enter their username and password. As mentioned in the guidance concerning [Universal Login](#universal-login), the simplest and safest way to authenticate users with a username and password is to redirect them to a centralized login page and collect their username and password there. This allows Auth0 to determine whether they have already authenticated and skip the login form entirely when it's not needed.\n\n### Best Practice\n\nCollecting credentials only at the centralized login page will reduce the surface area for potential leak of user secrets. It will also reduce the need to collect credentials unnecessarily. See [Universal Login](#universal-login) for more information.\n\n## Application integration\n\nOnce you've figured out how you want to authenticate your users, the next step is to determine how you will initiate that authentication. Each application will typically have its own starting point.\n\nAs discussed, we've found that most of our customers use [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) as the industry-standard protocol when it comes to their customer-facing applications. Figuring out which OIDC flow to use is your first task, and you will want to start by reviewing the our [grant mapping](https://auth0.com/docs/get-started/applications/application-grant-types) guidance in the first instance.\n\nIf you want to allow anonymous users access to any part of our application then you need to determine if you will be redirecting right away or prompting your users to redirect only when required (or perhaps some combination of both; see [Redirect Users After Login](https://auth0.com/docs/authenticate/login/redirect-users-after-login) for further discussion). If users can [deep link](#deep-linking-to-protected-endpoints) to a protected version (or area) of your site then you will need to determine the links to your application that will result in an automatic redirect to Auth0.\n\n### Anonymous access\n\nIt is important to consider the user experience when someone first comes to your application. If your application supports anonymous user access (quite common for eCommerce applications) there are different scenarios to consider:\n\n*   Are they returning to the application after having already logged in, or\n    \n*   If this is the first time they are accessing the application:\n    \n    *   Have they already accessed a different application that uses the same Auth0 tenant,\n        \n    *   Have they ever (or perhaps not in a long time) authenticated on this device or browser.\n        \n\nWhen an anonymous user accesses your application, it can often be desirable for the application to discover if the user has already logged into a different application in the same family, or to remember this user even if the application is a [SPA](https://auth0.com/docs/quickstart/spa) with no state. For example, if you can determine that the user is already logged in, you might decide to have the UI header in the application skip displaying a login button and instead have an account or profile menu for the user. To accomplish this you will want to utilize \"[silent authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication)\". Silent authentication will allow you to check to see if the user is logged in without prompting them to log in if they are not. Then the application can present a login button if necessary. If the user is logged in already, however, then you will receive tokens and will not have to present the user with a login button again.\n\n### Deep linking to protected endpoints\n\nThere are a variety of reasons why someone might link directly to a particular page within your application that is only accessible by authenticated users. If this is possible for your application you should automatically redirect your user to Auth0 if they are not authenticated. Once they authenticate and the authorization server returns them to your application, you can [redirect them](https://auth0.com/docs/authenticate/login/redirect-users-after-login) to where they intended to go in the first place.\n\n### Best Practice\n\nMost modern authentication frameworks support middleware for redirecting to an authorization server such as Auth0. When selecting one, here are some key considerations:\n\n*   Support for confidential clients, non-nonfidential clients or both\n*   Support for configuration via [discovery endpoint](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery \"Configure Applications with OIDC Discovery\") or explicitly inline\n*   Support for token validation including expirations, signatures, claims and scopes\n*   Support for Refresh Tokens if needed\n\n### Authenticating the user\n\nAuthentication is the process of determining user identity. The result of authentication in an OIDC context is an ID Token. This token contains information about the user and should only be able to be obtained if the user authenticates using one or more factors as defined by the authorization server (the most common form being [user ID and password](#username-and-password-authentication)). There are a few things you may also need to consider in addition to obtaining an ID Token:\n\n*   Do we also need an [Access Token](https://auth0.com/docs/secure/tokens/access-tokens) in order to call a shared API?\n    \n*   Is your application a single-page application and only requires an [ID Token](https://auth0.com/docs/secure/tokens/id-tokens)? See [Authorization Code Grant with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce) for more information.\n    \n*   Is your application a native application (mobile or desktop) and/or do you need a [Refresh Token](https://auth0.com/docs/secure/tokens/refresh-tokens)? See [Authorization Code Grant with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce) for more information.\n    \n\nIf your SDK only supports the Authorization Code grant, or you need an Access Token or Refresh Token, then Authorization Code grant (with or without [PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)) can also be used to retrieve an ID Token. The Authorization Code grant includes an additional API call to exchange the code for a token which can result in additional unnecessary latency if all you need is the ID Token. In many cases the [hybrid flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow) is implemented to provide optimum access to the ID Token while still leveraging Authorization Code grant workflow for the secure and safe retrieval of Access and Refresh Tokens.\n\n## Attack protection\n\nThe reason that authentication systems are important is to prevent bad actors from accessing applications and user data that they should not. We want to place as many barriers as possible between those bad actors and access to our systems. One of the easiest ways to do this is to ensure that your [attack protection](https://auth0.com/docs/secure/attack-protection) with Auth0 is configured correctly, so take a moment to read the guidance on this subject and ensure that it's working correctly for you.\n\n### Best Practice\n\nAnomaly detection is handled behind the scenes by Auth0 and provides a great security feature for your product. If you're going to utilize it, ensure that you have set up your [Email Provider](https://auth0.com/docs/architecture-scenarios/b2b/operations#email-provider-setup) and configured your [Email Templates](https://auth0.com/docs/architecture-scenarios/b2b/branding#email-template-customization) before turning on email delivery to your users.\n\n## SSO with legacy systems\n\nIn a large scale re-structure it's not always possible—or practical—to update all your applications at once. In fact, our recommended best practice is to plan for an iterative-style approach when it comes to integrating with Auth0. If your applications already participate in Single Sign-on (SSO), and your legacy identity system supports protocols such as OIDC or SAML, then you have a couple of options available if you want to continue to provide SSO as you integrate with Auth0:\n\n*   Update your existing identity provider in your legacy SSO system to redirect to Auth0 for login (e.g., using [SAML](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider)), or\n    \n*   Have Auth0 redirect to your legacy SSO system to login. This requires configuring your legacy system as an IdP in Auth0 (i.e., either using [SAML](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider) or [OIDC](https://auth0.com/docs/connections/identity-providers-social)).\n    \n\n### Best Practice\n\nSupporting an SSO experience with your legacy system can add complexity, but may be worth it to generate a more seamless user experience as you integrate with Auth0. If you intend to go down this path, planning for it early can help ensure that it is possible to achieve. If you don't already have SSO at a centralized service, then the complexity to add it will unlikely be worth the benefits.\n\nThis is a complex topic that will likely need some additional investigation depending on your current legacy architecture, and we recommend you only look into this if you currently have SSO support in your legacy system. Note: if you are currently redirecting from your applications to a centralized system to authenticate your users and that system only asks for credentials if you don’t already have a session with the centralized system, then you have a legacy SSO implementation.\n\n## Enterprise Login\n\nThe “bring your own identity” scenario has become a must-have for almost all B2B applications. Most enterprise companies expect to be able to integrate their IdP into your application so their employees don't need to store another set of credentials. This is a valuable way of simplifying the user authentication experience without compromising security, and using [Universal Login](#universal-login) makes it easy to start adding support for [Enterprise Connections](https://auth0.com/docs/connections/identity-providers-enterprise) with minimal disruption.\n\n### Best Practice\n\nOnce you start supporting enterprise connections for users, you must do some form of [Home Realm Discovery](#home-realm-discovery) so that you can determine which connection to send the user to for authentication.\n\nWith enterprise connection support, user identities and credentials are managed by the identity provider of your customers' organization, as well as certain identity claims - which Auth0 will use to populate the user [profile](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/profile-management).\n\n### Best Practice\n\n\"Bring your own identity\" is a great feature to provide, but if you don't support this from day one, and sometimes even if you do, you may have an organization that wants to switch to their own IdP after already having used the application for a while. You will need a way to [link user accounts](https://auth0.com/docs/users/concepts/overview-user-account-linking) to provide an effective way of associating the new identity with the old database identity.\n\n## Multi-factor authentication (MFA)\n\nIn an era where misuse of user credentials is at an all-time high, protecting your systems when it’s so common for hackers to steal users identity information in general is a challenge. One of the most effective ways though is to provide users with the ability to configure a second factor for protecting their account. More commonly referred to as [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication). This will ensure that only a valid user can access their account, even if they use a username and password that may have been compromised from a different application.\n\n### Best Practice\n\nIt's quite common for customer facing applications to provide users with an _option_ for adding a second factor rather than _forcing_ them to use a second factor. For more information regarding this, see [providing your users with an option to add MFA](https://auth0.com/learn/multifactor-authentication-customers/).\n\nAuth0 supports a number of different options when it comes to enabling MFA for protecting user account access, and there are several practices to ensure that you will truly be providing a flexible second factor barrier to access:\n\n*   Auth0 [Guardian](https://auth0.com/multifactor-authentication): a service that provides both Push notification generation and an application for allowing or denying requests. Push sends notification to a user’s pre-registered device - typically a mobile or tablet - from which a user can immediately allow or deny account access via the simple press of a button.\n    \n*   Time-based One-Time Password ([TOTP](https://auth0.com/blog/from-theory-to-practice-adding-two-factor-to-node-dot-js/)): allows you to register a device - such as Google Authenticator - that will generate a one-time password which changes over time and which can be entered as the second factor to validate a user’s account.\n    \n*   SMS: for sending a one-time code over SMS which the user is then prompted to enter before they can finish authenticating.\n    \n*   Voice: for delivering a one-time code through a phone call which the user is then prompted to enter before they can finish authenticating.\n    \n*   Duo: allows you to use your Duo account for multi-factor authentication.\n    \n*   Email: allows you to use your email account for multi-factor authentication.\n    \n\nWhilst MFA workflow using technologies such as Guardian or Google Authenticator is typically provided via a separate application that runs on a mobile or tablet device, if you don’t want your customers to have to download a separate application Auth0 also provides you with an [SDK](https://auth0.com/blog/announcing-guardian-whitelabel-sdk/) that you can use to build second factor workflow right in your existing mobile device application(s).\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)\n\n## Multiple Organization Architecture (Multitenancy)\n\nMany B2B platforms implement some form of isolation and/or branding for their customers' organization, and this can add complexity to any Identity and Access Management (IAM) system. If this applies to you, then we recommend you take some time to read through our guidance and best practice advice for this type of environment.\n\n[Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)",
  "title": "Authentication (B2B)",
  "description": "How authentication works in your B2B IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/quality-assurance",
  "markdown": "# Quality Assurance (B2B)\n\nQuality Assurance is important in identifying issues before they impact your customers and, depending on the nature of your project, there are several different types of quality assurance testing that you’re going to want to consider as part of your integration with Auth0:\n\n*   Is your application easy to understand and use, even by those with a disability?\n    \n*   Does your application need to work across various different browsers and devices?\n    \n*   Does your application need to work in multinational and/or international environments?\n    \n*   How will your application perform when subjected to unexpected production loads?\n    \n*   How can you ensure your application is safe from security-related vulnerabilities?\n    \n\nAuth0 [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) and associated UI widgets (such as [Lock](https://auth0.com/docs/libraries/lock)) have already been designed and built following usability and accessibility best practices, and provide tested out-of-box support for a whole host of [browsers and devices](https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix). Support for [internationalization](https://auth0.com/docs/customize/internationalization-and-localization) (I18N) is also provided out-of-box, with built-in extensibility designed for custom multi-language and localization (L10N) situations.\n\nTo ensure functional requirements are met and unexpected events are handled correctly, guidance is provided for testing the [integration](#integration-testing) between your application(s) and Auth0, and for [unit testing](#unit-testing) individual extensibility modules (such as [Rules](https://auth0.com/docs/customize/rules/debug-rules), [Hooks](https://auth0.com/docs/customize/hooks/update-hooks), and Custom Database scripts). Guidance is also provided regarding Auth0's [penetration testing policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/penetration-testing-policy) to help when testing for security vulnerability, and also how [Mock](#mock-testing) testing can be leveraged in conjunction with our [load testing policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/load-testing-policy) to help ensure your application(s) perform under unexpected load.\n\n## Unit testing\n\nThe objective of unit testing is to test individual units of code. If you create custom code within Auth0 in the form of Rules, Hooks, and/or Custom DB scripts, you should consider use a testing framework (such as [Mocha](https://mochajs.org/)) to test your code. Companies who have been most successful with Auth0 have found it useful to execute these unit tests prior to [automatically deploying](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/deployment) Auth0 tenant configuration and collateral.\n\n## Integration testing\n\nIt is a recommended best practice that you set up different tenants for development, testing, and production as discussed in Architecture guidance for [SDLC support](https://auth0.com/docs/architecture-scenarios/b2b/architecture#sdlc-support). Auth0 allows you to configure variables that are available from within custom [extensibility](https://auth0.com/docs/customize/extensions); these can be thought of as environment variables for your Auth0 tenant. Rather than hard code references that change when moving code between development, test, and production environments, you can use a variable name that is configured in the tenant and referenced by the custom extensibility code. This makes it easier for the same custom code to function, without changes, in different tenants as the code can reference variables which will be populated with tenant-specific values at execution time:\n\n*   For use of variables in Rules, see how to [configure values](https://auth0.com/docs/customize/rules/configuration)\n    \n*   For use of variables in Hooks, see how to configure [secrets](https://auth0.com/docs/customize/hooks/hook-secrets) in the editor\n    \n*   For use of variables in Actions, see Explore Flows and Triggers\n    \n*   For use of variables in Custom DB Scripts, see the [configuration parameters](https://auth0.com/docs/connections/database/custom-db/create-db-connection#step-3-add-configuration-parameters)\n    \n\n### Best Practice\n\nIt’s a recommended best practice to use variables to contain tenant-specific values as well as any sensitive secrets that should not be exposed in your custom code. If your custom code is deployed in GitHub, then using a tenant-specific variable avoids exposure of sensitive values via your GitHub repository.\n\n### Test automation\n\nYou can automate your overall build process by incorporating deployment automation as well as test automation. This can be used to deploy new versions of configuration and/or custom code to Auth0 and execute automated tests. If the tests uncover any failures, the deployment automation capabilities can be used to revert to the last working version. For further information, see the [deployment automation guidance](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/deployment) provided.\n\n## Mock testing\n\nIn a balance between Auth0’s [load testing policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/load-testing-policy) and the desire to load test, it is common practice among Auth0’s customers to mock out Auth0’s endpoints. This is a valuable practice in order to ensure that your application works with your expected interfaces without having to restrict your testing, and tools such as [MockServer](http://www.mock-server.com/), [JSON Server](https://github.com/typicode/json-server) or even [Postman](https://learning.getpostman.com/docs/postman/mock_servers/setting_up_mock/) can be used to assist.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)\n\n## Multiple Organization Architecture (Multitenancy)\n\nMany B2B platforms implement some form of isolation and/or branding for their customers' organization, and this can add complexity to any Identity and Access Management (IAM) system. If this applies to you, then we recommend you take some time to read through our guidance and best practice advice for this type of environment.\n\n[Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)",
  "title": "Quality Assurance (B2B)",
  "description": "Quality Assurance considerations for your B2B IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/logout",
  "markdown": "# Logout (B2B)\n\n[Logout](https://auth0.com/docs/authenticate/login/logout) is the act of terminating an authenticated session when it's no longer needed, thus minimizing the likelihood that unauthorized parties can \"take over\" the session. This is typically achieved by provisioning a logout option on the user interface you provide to your users. Multiple types of sessions can be created when a user logs in (e.g., local application sessions, Auth0 session, third-party Identity Provider sessions), and you will need to determine which of these sessions need to be terminated when the user clicks any **Logout** option.\n\n### Best Practice\n\nYour logout behavior should make it clear to a user which session(s) are being terminated, and ideally, will display a visual confirmation of logout afterward.\n\nWhen configuring logout behavior, you'll need to consider:\n\n*   Which sessions should be terminated when the user initiates logout?\n    \n*   What information should you provide to users as confirmation of the sessions terminated?\n    \n*   Where should users be redirected to after logout completes?\n    \n*   How long do you want sessions to last in the event that users do not trigger the logout process?\n    \n*   Should the End User be logged out of all of their application sessions when they log out of one?\n    \n*   Should the session with an organization's IDP also be terminated at logout?\n    \n\nGiven the varying types of sessions that can be created whenever a user logs in, there are several types of logout possible. Local application logout ends the session with the application, whereas Auth0 logout [terminates the Auth0 session](https://auth0.com/docs/logout/guides/logout-auth0). If you have organizations that are using their own IDP, you may want to consider a [Federated Logout](#federated-logout) strategy and implement accordingly. Global, or [Single Logout](https://auth0.com/docs/logout/guides/logout-applications) (SLO), ends the Auth0 session and also sends a logout request/notice to applications relying on the Auth0 session.\n\nThe functionality provided by your application, as well as your use of features like [Single Sign-on (SSO)](https://auth0.com/docs/sso), will inform your decision as to what type of logout is required and what visual confirmation you'll need to provide to your users. Regardless of which option you choose, the logout process you implement should make it clear to the user which sessions are being terminated, and also when the logout process has completed.\n\nIn some situations, a user may be expected to logout of all associated applications when they log out of any one of the applications you provide. This is something that can add complexity. However if you have concerns that users could leave themselves vulnerable (perhaps due to data sensitivity or the like), then you will likely need to review [Single Logout](#single-logout) and implement accordingly.\n\n## Where to send users after logout\n\nOnce your user logs out, they will be redirected to a specific location of your choosing. This location is specified as the **logout redirect URL**, and you can [define this as a parameter](https://auth0.com/docs/logout/guides/redirect-users-after-logout) via the Auth0 Dashboard.\n\nThe URL(s) you use to redirect users after logging out must be [allowlisted in the Dashboard](https://auth0.com/docs/logout#redirect-users-after-logout) to mitigate open-redirect security vulnerabilities. You can allowlist them at the tenant or application levels.\n\n## Automatic termination of sessions\n\nNot all users will trigger the logout process manually, so Auth0 also provides **session timeout** to prevent overly long-lived sessions. This setting is [available and configurable via the Auth0 Dashboard](https://auth0.com/docs/dashboard/reference/settings-tenant#login-session-management).\n\n## Single Logout\n\nIf you are doing [Federated Logout](#federated-logout) you will likely also want to do Single Logout (SLO), and there are two main approaches you can take.\n\n### Short-lived tokens\n\n### Best Practice\n\nYou want to avoid making too many calls to your Auth0 tenant to avoid rate limiting and poor performance. A best practice is to only request new tokens if tokens have expired and a user takes an action. This will avoid applications that are simply open, but not in use, from continually polling for new tokens.\n\nThis is by far the simplest approach to Single Logout. Each application enforces a short time within which a user can use the system, say, 5-10 minutes. On each action a user performs, if the time has expired then either a redirect to Auth0 (for regular web apps), or [Silent Authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication) for client side Single Page Applications will be used to obtain new tokens. Ordinarily new tokens will be issued silently due to the Single Sign On (SSO) session. However, after logout, all applications will fail to get new tokens silently because the SSO session will have been removed, and the user will need to re-enter their credentials.\n\n### Build a logout service\n\nAnother technique you can use is to build a logout service that can track and destroy application sessions. Each application would notify the logout service when it creates and removes a session. The (logout) service would either have direct access to all application's server side sessions and destroy them directly, or it will have the ability to make a back-channel call to each application to tell the application that it must remove its session.\n\nThis technique can be quite effective as there is low-latency between when a user calls logout, and when they are then logged out of all applications. However it can add complexity and also additional development time for implementation. It will also require some way to ensure that new applications added to the system are added to this service.\n\n## Federated Logout\n\n[Federated User Logout](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps) may be something that you need to consider for your application. If you or your customers will be using a third-party IdP (i.e., something other than a [Database Identity Provider](https://auth0.com/docs/connections/database)) then the question of whether you need to log the user out of the IdP when they log out of your application is something you will need to answer. The answer depends on what your users would expect. If the application and/or IdP you use is tied closely to a customer organization and a central part of day-to-day operations, then it may be frustrating for users to get logged out of their IdP when they log out of your application. If not, then being logged out of the IdP may be expected, or in some cases even desired. In most B2B scenarios, our customers find that it is preferable \\*not\\* to perform federated logout for a user.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)",
  "title": "Logout (B2B)",
  "description": "User logout planning considerations for your B2B IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/launch",
  "markdown": "# Launch Preparation (B2B)\n\nUse this guide as you prepare for the launch of your application. We’ve included reminders about some content you may have viewed earlier during your planning or development phases as well as some new content unique to the launch phase. The sections below are useful to developers and project owners to ensure that you have everything lined up for a smooth launch. There are several things to check so it may help to assign ownership of different sections to different members of your team.\n\n*   [Tenant Check](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/launch/tenant-check): Tenant Checks to perform before launch of your B2B IAM implementation.\n    \n*   [Testing Complete](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/launch/testing): Testing preparation for the launch of your B2B IAM implementation.\n    \n*   [Operations Readiness](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/launch/operations-readiness): Operations checks to perform before launch of your B2B IAM implementation.\n    \n*   [Compliance Readiness](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/launch/compliance-readiness): Compliance checks to perform before launch of your B2B IAM implementation.\n    \n*   [Support Readiness](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/launch/support-readiness): Support readiness for the launch of your B2B IAM implementation.\n    \n*   [Launch Day Preparation](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/launch/launch-day): Launch preparation considerations for your B2B IAM implementation.\n    \n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)",
  "title": "Launch Preparation (B2B)",
  "description": "Launch preparation considerations for your B2B IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/authorization",
  "markdown": "# Authorization (B2B)\n\nLet's start by taking a step back and talking about Access Control. There isn't one clear cut definition of Access Control in the industry, but if you spend some time searching and reading, you'll see that most authoritative sources agree that it is the umbrella concept that puts all of Authentication, Authorization, Consent, and Policy Enforcement together to ensure that only the right people and services have access to your applications and APIs.\n\nNext, let's look more closely into the distinctions between Authentication, Authorization, Consent, and Policy Enforcement. Your Auth0 tenant (your Authorization Server) is typically responsible for Authentication and Consent, and some or all of Authorization and Policy Enforcement. Additionally, an Application or API itself almost always is the primary enforcer of policies, especially where contextual access is required:\n\n*   **Authentication**: the process of determining if a principal (a user or application) is who or what they say they are.\n    \n*   **Authorization**: the process of determining what is allowed, based on the principal, what permissions they have been given, and/or the set of contextually-specific access criteria.\n    \n*   **Consent**: what permissions the user (Resource Owner) has given permission to an application to do on its behalf. This is generally a requirement of delegated authorization. The user has to give permission to the Client to access the user's data in a different system.\n    \n*   **Policy Enforcement**: The act of enforcing the policies of the application or API, rejecting or allowing access based on a user's authentication and/or authorization information.\n    \n\nIn general, we typically group different types of access control into three distinct categories so that it's easier to understand a) which actor is responsible for storing the information, b) which actor is responsible for making decisions, and c) which is responsible for enforcing the restrictions.\n\n*   The first category is where access is either granted or denied to an application or an API in its entirety. Both the data required to enforce this and the enforcement process is typically defined in the context of the Authorization Server For example, by using [`app_metadata`](https://auth0.com/docs/manage-users/user-accounts/metadata) associated with a user and a [Rule](https://auth0.com/docs/customize/rules) defined in your Auth0 tenant.\n    \n*   The second category is where access is either granted or denied to a specific subset of application or API functionality. The data required to enforce this is typically stored in the Authorization Server For example, by using `app_metadata` on a user in your Auth0 tenant with the enforcement process performed in the application or API itself. In this scenario, the data is typically communicated as one or more custom claims in an [`id`](https://auth0.com/docs/secure/tokens/id-tokens) or [`access`](https://auth0.com/docs/secure/tokens/access-tokens) token.\n    \n*   The third category is where access is either granted or denied depending on what the principal (subject) can operate on within the context of an application or API. Both the data required to enforce this, and the enforcement process is typically defined in the context of the application or API. In this scenario, the data communicated as one or more custom claims in an `id` or `access` token may be consumed with or without data from an external source that is not Auth0.\n    \n\nIn addition, Role-based Access Control (RBAC) and Attribute-based Access Control (ABAC) mechanisms can be applied in any of the Access Control categories described above. Whatever your use case then, there are a number of things you will want to consider when looking at the functionality and workflow you require:\n\n*   Are there scenarios where access to an entire application or API should be rejected?\n    \n*   Will you be providing APIs that can be accessed by third-party applications?\n    \n*   Will your APIs also be accessed by your own (first-party) applications?\n    \n*   Will your application be calling a third-party API?\n    \n*   Should your applications and/or APIs be enforcing access control based on user claims?\n    \n*   What if I need to know which organization an access token or ID token is associated with?\n    \n\nAuth0 supports access restriction for either applications or APIs based on certain conditions. In certain scenarios, you may want to create a Rule that returns an `UnauthorizedError` when, for example, a user attempts access to an application or an API at an incorrect time (as described in this [example](https://auth0.com/docs/authorization/sample-use-cases-rules-with-authorization#allow-access-only-on-weekdays-for-a-specific-application))—or if the user doesn’t have the right claim(s) contained in their `app_metadata`. For an application using [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol), this would prevent the allocation of the [ID Token](https://auth0.com/docs/secure/tokens/id-tokens) used to authorize access. Similarly, for an API, allocation of any OAuth2 [Access Token](https://auth0.com/docs/secure/tokens/access-tokens) (used when calling the API), could be prevented as described in this [example](https://auth0.com/docs/authorization/sample-use-cases-rules-with-authorization#deny-access-to-anyone-calling-an-api).\n\n### Best Practice\n\nIn the main, we have found that [OIDC](https://auth0.com/docs/protocols/oidc) is the most commonly used industry-standard protocol used by Auth0 customers when it comes to authentication in their applications. We have also found that, even though [OAuth2](https://auth0.com/docs/protocols/oauth2) was created as a delegation protocol, it is commonly used within first party applications when there is an API that does not have a shared session with the application.\n\nAuth0 also can provide the information needed so that an application can enforce restrictions. For [application level integration](#application-integration), Auth0 allows you to add [custom claims](#id-token-claims) to an ID Token, which your application can then verify and subsequently use to perform policy enforcement. In this case you will need to decide what information you require for your application to make enforcement decisions. If you need to make decisions at an API instead of in your application, you will likely need to use an Access Token instead of an ID token. Continue reading for more information.\n\nFor [API level integration](#api-integration), Auth0 supports both [custom claims](#access-token-claims) as well as [scope](#access-token-scopes) re-configuration, both within the context of an Access Token. Again, you will need to decide what information will be required in order for your API to make access decisions, and your API will need to enforce that by validating the contents of the Access Token.\n\n### Best Practice\n\nWhen deciding whether you should use permissions through custom claims or scopes, you should make sure you understand the nature and purpose of scopes. There is a nice [blog post](https://auth0.com/blog/on-the-nature-of-oauth2-scopes/) on that which is easy to read and helps clear up the topic.\n\nFor multi-organization scenarios, it can often be important to know which organization an access token (or even an ID token) applies to. Taking care to follow the [best practices](#organization-data-in-an-access-token) can save you time and effort.\n\n## Application integration\n\nIn this scenario, your Auth0 tenant provides a token as an indicator of authorized access to an application. For applications utilizing [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol), the industry-standard protocol we typically find most utilized when it comes to customer facing applications, this would be an ID Token expressed as a [JWT](https://auth0.com/docs/secure/tokens/json-web-tokens).\n\n### ID Token claims\n\nUsing Rule extensibility, Auth0 allows you to easily [add custom claims to an ID Token](https://auth0.com/docs/scopes/sample-use-cases-scopes-and-claims#add-custom-claims-to-a-token) based on, for example, a user’s [metadata](https://auth0.com/docs/manage-users/user-accounts/metadata) content. Your application can then verify the ID Token for the necessary claims, and either allow or prevent access to certain functionality as required. Note that though the process of adding custom claims via Rule is streamlined, the Rule engine is flexible and allows you to write custom code that may have negative effects. Therefore it’s important to follow our [rules best practice](https://auth0.com/docs/rules-best-practices) guidance anytime you use this extensibility feature.\n\n### Best Practice\n\nWhen you are considering adding custom claims, we recommend that you store any access control data you may need to include within claims as part of the user's [`app_metadata`](https://auth0.com/docs/users/concepts/overview-user-metadata). Firstly, this prevents you from needing to call an external API to fetch the data, which can negatively impact the performance and scalability of the login sequence. Secondly `app_metadata` **cannot** be modified by a user - so the user cannot directly circumvent any access control restrictions by modifying their own metadata. Also remember to check out our [metadata best practices](https://auth0.com/docs/architecture-scenarios/b2b/profile-management#metadata) guidance too.\n\nIf you are creating different instances of your application for your customer organizations, a common practice is to create a custom claim in your ID token to represent the user's organization. For example:\n\n```\ncontext.idToken[\"http://yourdomain.com/claims/organization\"]= \"organization A\";\n```\n\n### ID Token scopes\n\n[OIDC Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes) are typically used by an application to obtain consent for authorized access to a user's details during authentication. Each of the pre-defined scopes returns the set of standard claims where defined, and as described in the [OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). The scopes an application requests depend on which user attributes the application needs. Once the requested scopes are authorized by the user, the claims are returned in the ID Token and are also made available via the [/userinfo](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n\n## API integration\n\nIn this scenario your Auth0 tenant can provide an OAuth2 [Access Token](https://auth0.com/docs/secure/tokens/access-tokens), typically expressed as a [JWT](https://auth0.com/docs/secure/tokens/json-web-tokens), which can be used by your API to restrict access to certain parties. In addition, Auth0 provides support for what is notionally described as both [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications).\n\nActing as the authorization server, and with the consent of the user (the resource owner), your Auth0 tenant can be used to provide an Access Token—typically expressed as a [JWT](https://auth0.com/docs/secure/tokens/json-web-tokens)—to an application (client) so that it can access a protected resources hosted by a resource server on behalf of the resource owner. The issued Access Token is typically passed as the Bearer token in the HTTP Authorization header sent to an API.\n\nWhether you have a single API, or perhaps a suite of logically related [microservice APIs](https://auth0.com/docs/get-started/apis/set-logical-api), you can leverage the Access Tokens that Auth0 provides in order to secure access to your service(s). Though relatively easy to set this up in the [Auth0 Dashboard](https://manage.auth0.com/) or through the [Auth0 Management API](https://auth0.com/docs/api/management/v2#!/Resource_Servers/post_resource_servers), it's important to review the different application scenarios and API layouts to determine the best architecture for your system.\n\nOAuth2 was designed specifically with third-party access in mind, For example, a scenario might be that a user (resource owner) wants to use an application (a client) that does not belong to the same organization as the service that provides the user's data (the reseource server). In this case, when the application needs to access data that the user owns, it redirects to the organization where the user’s data resides, which in turn authenticates the user and then prompts the user to give the application permission to access their data. This prompting for permission is referred to as providing [consent](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications) and is a large part of what providing support for [third party applications](https://auth0.com/docs/scopes/api-scopes#example-an-api-called-by-a-third-party-application) entails. If you are planning to integrate third-party applications, then it's important you mark them as third-party early on so that Auth0 will handle prompting for user consent.\n\nOn the other hand, if your organization owns the application(s), the user data itself and the API(s) through which that data is accessed, then consent is not typically required as the interactions are all [first-party](https://auth0.com/docs/scopes/api-scopes#example-an-api-called-by-a-first-party-application). If you're only creating first-party applications, then you can ensure that you are not presenting your users with any unnecessary consent screen(s) by [allowing user consent to be skipped](https://auth0.com/docs/get-started/apis) as part of any resource service definition.\n\nAlternatively, you may have data relating to a user for which additional [functionality is provided](https://auth0.com/docs/scopes/api-scopes#example-an-api-called-by-a-back-end-service) and for which explicit user consent cannot be obtained (i.e. there is no authenticated user who can provide it). In this scenario, a [list of applications for which Client Credentials grant is enabled](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) can be defined.\n\n### Access Token claims\n\nAs is the case with ID Tokens, you can [add custom claims to Access Tokens](https://auth0.com/docs/scopes/sample-use-cases-scopes-and-claims#add-custom-claims-to-a-token) using Auth0 Rule extensibility. Once added, your API can then verify an Access Token for the necessary claims and either allow or prevent access to certain functionality as required.\n\n### Best Practice\n\nWhen you are considering adding custom claims, we recommend that you store any access control data you may need to include within claims as part of the user's [`app_metadata`](https://auth0.com/docs/users/concepts/overview-user-metadata). Firstly, this prevents you from needing to call an external API to fetch the data, which can negatively impact performance and scalability. Secondly `app_metadata` **cannot** be modified by a user - so the user cannot directly circumvent any access control restrictions by modifying their own metadata. Also remember to check out our [metadata best practices](https://auth0.com/docs/architecture-scenarios/b2b/profile-management#metadata) guidance too.\n\n### Access Token scopes\n\n[OAuth2 Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes) are typically used as the mechanism by which an API can determine what actions can be performed on behalf of a user. Scopes can be added on a per API basis to [define specific access permissions](https://auth0.com/docs/get-started/apis/add-api-permissions) in the Auth0 Dashboard or through the Auth0 Management API). Scopes can also be manipulated via Auth0 extensibility (e.g. via a Rule, as in this [example](https://auth0.com/docs/architecture-scenarios/spa-api/part-2#create-a-rule-to-validate-token-scopes)). The scopes an application requests for accessing an API should depend on what functionality the application needs the user to give permission for the application to use. Once the requested scopes are authorized, they will be returned in the Access Token which can be subsequently [verified by said API](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens). A good example of this is when you log in to an application that is using a social provider for login: the social provider API requires that the application specifies whether the user will want the application to post items on your behalf. This allows the user to accept or deny this request. This example demonstrates how the user is delegating permission to the application—which is different than the API restricting access based on a user's role, and should be handled differently.\n\n### Best Practice\n\nEven though you have the ability to fully manipulate Access Token Scopes via Auth0 extensibility, as a security best practice you should only remove scopes which are not authorized and refrain from adding scopes that were not requested.\n\nThough scopes are often used as a way to enforce access permissions for a user, there are situations where it can become [tricky when you use them in this manner](https://auth0.com/blog/on-the-nature-of-oauth2-scopes/). We therefore recommend that you use scopes for their intended purpose (i.e. delegating permission to an application) and use [custom claims](#access-token-claims) for your role-based or other access control scenarios.\n\n[Fine Grained Authorization](https://docs.fga.dev/fga-concepts) allows you to grant individual users access to a specific resource or object based on:\n\n*   A user's role within an organization, such as `editor` or `admin`\n    \n*   An attribute of the user or object, such as `manager` for a user or `marketing` for an object\n    \n*   A relationship between a user and an object, such as a user with view access to a parent folder also has view access to the child folder\n    \n\nWith FGA, you can create an authorization model to determine what relationship you want to determine user access.\n\n## Role Based Access Control (RBAC)\n\nAuth0 has out-of-box support for Role Based Access Control ([RBAC](https://auth0.com/docs/manage-users/access-control/rbac)). RBAC refers to assigning permissions to users based on their role within an organization, and provides for simpler access control by offering a more manageable approach that is less prone to error.\n\nThe core RBAC feature can be used in many multi-organization scenarios. See [Organization Data in an Access Tokens](#organization-data-in-an-access-token) for more information on how to ensure your setup can support your RBAC needs.\n\n## Machine-to-Machine (M2M) Authorization\n\nThere are many scenarios that require an application without any user-interactive session to obtain an access token in order to call an API. In such scenarios you must authenticate the client instead of the user, and OAuth 2 provides the [client credentials](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) grant type to make this easy to achieve. Some common examples of where this is required include:\n\n*   A cron job or other service that needs to communicate with your API (e.g. where a daily report needs to be generated and emailed it to an administrator).\n    \n*   A separate API the supports privileged access (e.g. the API is not exposed to users directly, but instead to a backend only).\n    \n*   In certain microservice architectures, where some API layers need to communicate to other API layers without a user involvement, or after a user token has expired.\n    \n*   A privileged API that may need to be called before a user has authenticated (i.e. from a rule or custom DB script in your Auth0 tenant)\n    \n\n### best practice\n\nTraditionally, a special \"service account\" would have been created in order to cater for these scenarios: a user with a username and password that was configured for services which supported non-interactive use cases. That is no longer a recommended approach for many reasons, and the current best practice is to use [OAuth 2.0 Client Credentials Grant](https://auth0.com/docs/flows/concepts/client-credentials) in these situations.\n\n## Organization Data in an Access Token\n\nIf you have a separate API from your application in your system that supports your multi-organization application, it is important to restrict operations to only the organization that the token was generated for. This requires that there is some sort of information in the access token to tell the API which organization the access token was issued for. This can be done in a couple of different ways depending on the answers to a couple of simple questions:\n\n1.  Will the End Users in this organization potentially have more than one organization, or is each End User isolated to a specific organization?\n    \n2.  Will you be allowing any Machine-to-Machine (M2M) access to your API?\n    \n3.  If you are allowing Machine-to-Machine (M2M) access to your API, Will you have any developers who need a single client ID and secret to access multiple organizations (but not all organizations)?\n    \n4.  Will you be allowing the creating of third-party apps that require consent?\n    \n\nIf End Users are isolated to a single organization **and** you will either not be allowing M2M access to your API or you will have a separate client ID/secret for each organization that needs access **and** you will not be allowing third-party apps that require consent, then the simplest approach is to just create a custom claim in the access token [using rules for the user based tokens](#access-token-claims) and [using the client credentials hook for M2M calls](#machine-to-machine-m2m-authorization). You can store organization name in client metadata and extract it from rules or hooks to include in access\\_token as a custom claim. RBAC will work out of the box for this approach as well as long as each End User can only belong to one organization.\n\nIf End Users have more than one organization they can belong to or you might give a single developer a client ID and secret for M2M calls to more than one organization, the best approach is to create a separate audience (a separate API instance in your Auth0 tenant) for each organization. This gives you a few nice abilities:\n\n1.  First, it allows you to pass the audience as a first-class parameter to Auth0 without having to create a custom parameter. The benefit of this is that Auth0 will help enforce the existence of the audience, and it will pass it to your rules. It will also ensure that an issued refresh token will only work for the specific audience it was originally issued to.\n    \n2.  It allows you to restrict client grants to only specific organizations out of the box. The alternative is to create a more complicated client credentials hook to attempt to retrieve the restrictions from somewhere else and also require a much more complex and potentially troublesome way to tell the client credentials call which organization to issue the access token for.\n    \n3.  This also allows you to use the core RBAC feature with Auth0 and ensure that the End Users who have access to more than one organization can have a potentially different role for each organization.\n    \n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)\n\n## Multiple Organization Architecture (Multitenancy)\n\nMany B2B platforms implement some form of isolation and/or branding for their customers' organization, and this can add complexity to any Identity and Access Management (IAM) system. If this applies to you, then we recommend you take some time to read through our guidance and best practice advice for this type of environment.\n\n[Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)",
  "title": "Authorization (B2B)",
  "description": "User authorization and related planning considerations for your B2B IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/architecture-scenarios/b2b/operations",
  "markdown": "# Operations (B2B)\n\nOperationalization requires configuring or setting up infrastructure to support the scalable, measurable, and quantifiable operation that’s necessary for business continuity. In Auth0, this includes configuring supporting services (such as email providers), monitoring services for your deployment, detecting anomalous situations, and making preparations to recover quickly and smoothly when something goes wrong in a production environment.\n\nEstablishing effective operational behaviors is something that successful customers have found pays dividends, and there are a number of things you will want to consider when looking at your workflow:\n\n*   What should you do to proactively detect failures?\n    \n*   How can you obtain data on Auth0’s operational status?\n    \n*   What should you do about Auth0 security bulletins related to the Auth0 service?\n    \n*   Does Auth0 provide information regarding impending changes in the Auth0 service?\n    \n*   How can you check for important notices from Auth0?\n    \n*   What should you do with Auth0 log data so that you can analyze it and keep it for longer than Auth0’s limited data retention period?\n    \n*   How can you scan Auth0 logs to determine if peak loads in your application trigger any rate limits or other errors?\n    \n*   What email services should you use to support production volumes of email messages to users? Can I use Auth0's out-of-box email provider in my production environment?\n    \n*   Do you need to configure your firewall and what firewall ports will you need to open for internal services that need to receive communications from Auth0 (such as custom databases, web services, and email servers)?\n    \n*   How will you provision new organizations?\n    \n*   Do you need to provide self-service provisioning for your customer so that they can configure their own organizational IdPs?\n    \n\nAuth0 supports functionality for [monitoring](#monitoring) Auth0 service operation as well as providing information regarding Auth0 [service status](#service-status). In addition, Auth0 makes security-related bulletins as well as information regarding upcoming changes to the Auth0 service available via various [notifications](#notifications). Auth0 [logging](#logging) services also provide extensive functionality for tracing and identifying operational anomalies, including restrictions encountered due to rate limiting and/or excessive loading.\n\nOut-of-box, Auth0 provides email delivery services to help you accelerate your integration. These services, however, are not meant for scale-of-use in production environments, and do not provide for any specific service level or guarantee when it comes to email delivery. Our best practice recommendation, which customers typically follow, involves configuring your own [email service provider](#email-provider-setup).\n\nYou may also need to make changes to [infrastructure](#infrastructure) configuration in order to support integration with Auth0 and to support use of Auth0 extensibility. For example, if you need to provide callbacks to your internal or even external infrastructure (e.g., if you need to make external API calls in Actions, Rules, or Hooks, or via custom database scripts if you need to leverage existing legacy identity storage), then you may need to configure your Firewall settings.\n\nOnce you know how you want organizations to be represented in your system, you will want too consider how you are going to provision the organization itself. See [Provisioning organizations](#provisioning-organizations) for more information.\n\nIn addition, many of our customers have developed one or more self-service portals for use by their customers' organization admins to provide self-service capabilities for configuring their own [IdPs](#self-service-idp-provisioning).\n\n## Service status\n\nThe Auth0 [status dashboard](https://status.auth0.com/) together with the Auth0 [uptime dashboard](http://uptime.auth0.com/) shows current and past status of the Auth0 service in a human-readable format. If any monitoring alerts are triggered, and as a first step in troubleshooting, your operations staff should check the status dashboard to see if there is a current outage. The public cloud status page also provides a facility for subscribing to outage notifications, and we also recommend that you check the status of any third-party [external services](https://auth0.com/docs/deploy-monitor/monitor/check-external-services-status) you depend on, such as Social Providers. Having this information handy can help quickly eliminate possible causes when troubleshooting an issue and should be at the top of a troubleshooting checklist for developers as well as the help desk staff.\n\n### Best Practice\n\nInformation on how to check the status of Auth0 as well as any dependent services (such as Social Providers) should be at the top of a troubleshooting checklist for both developers and helpdesk staff, and we recommend you subscribe via the Auth0 status page to set up notification of any status updates.\n\nIn the event of an outage to the public cloud service, Auth0 performs a Root Cause Analysis (RCA) and publishes the results on the Auth0 status page. Auth0 performs a thorough investigation after an outage—including a determination of root cause, as well as contributing factors and how to prevent the issue from occurring again—and as a result, an RCA document can take a few weeks to be published.\n\n## Email provider setup\n\nAuth0 sends [emails](https://auth0.com/docs/customize/email) to users for events such as signup welcome, email validation, breached password, and password reset events. You can customize the email templates for each type of event, and advanced customization of email handling is also possible. Auth0 provides a test email provider with limited capacity for basic testing, but you must set up your own email provider for production use, and customization of email templates will not work until you have established your own provider.\n\n### Best Practice\n\nThe default Auth0 email provider does not support sending production volumes of email or customization of email templates. You should therefore configure your own email provider before deploying to production.\n\n## Infrastructure\n\n### Firewalls\n\nIf custom code executing in Auth0 (such as in an Action, Rule, Hook, or custom database scripts) will call a service inside your network, or if you configure an on-premise SMTP provider in Auth0, then you may need to configure your firewall to allow [inbound traffic from Auth0](https://auth0.com/docs/secure/security-guidance/data-security/allowlist). The IP addresses to allow through the firewall are specific to each region and are listed on the Rules, Hooks, custom database scripts, and email provider configuration screens in your Auth0 dashboard.\n\n## Logging\n\nAuth0 provides extensive capability when it comes to the logging of events, and also in the scanning of logs in order to identify event anomalies (see [logs documentation](https://auth0.com/docs/deploy-monitor/logs) for further details). Standard log retention period for Auth0 logs is determined by subscription level with the shortest period being 2 days and the longest period being only 30 days. Leveraging Auth0 support for integrating with external logging services will allow you to retain logs outside of this, and will also provide for log aggregation across your organization.\n\n### Best Practice\n\nYou should leverage one of the log streaming solutions to send log data to an external log analytics service. This will enable keeping data for longer periods of time and provide advanced analytics on the log data.\n\nYou should review the log data [retention period](https://auth0.com/docs/deploy-monitor/logs/log-data-retention) for your subscription level, and implement a log data export extension to send log data to an external log analytics service. You can use one of our [log streaming solutions](https://marketplace.auth0.com/features/log-streaming) in Auth0 Marketplace.\n\nDevelopment teams can use log files for troubleshooting and detecting intermittent errors that may be hard to find via QA tests. Security teams will probably want log data in case forensic data is ever needed. Exporting log files to services that provide comprehensive analytics can help you see patterns such as usage trends and attack protection triggers.\n\n### Rate limits and other errors\n\nAuth0 provides a unique error code for errors reported when the [rate limit is exceeded](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy). You should set up automatic scanning of logs to check for rate limit errors so you can proactively address activity that hits rate limits before it causes too much trouble for your users. Auth0 also publishes error codes for other types of errors, and you will find it helpful to scan logs for [authentication errors](https://auth0.com/docs/libraries/common-auth0-library-authentication-errors) as well as errors from Auth0 Management API calls (Management API error codes are shown below each call in the [Management API Explorer](https://auth0.com/docs/api/management/v2)).\n\n### Best Practice\n\nCalling the Management API to retrieve user profile information from within a Rule is a common cause of rate limit errors because such API calls can execute for every login as well as periodic session checks.\n\n## Monitoring\n\nYou should establish mechanisms for [monitoring Auth0 implementations](https://auth0.com/docs/deploy-monitor/monitor), so your support or operations team receives the timely information needed to proactively handle service outages. Auth0 provides monitoring endpoints that can be incorporated into your monitoring infrastructure. These endpoints are designed to provide a response suitable for consumption by monitoring services. It should be noted that they only provide data on Auth0. For complete end-to-end monitoring, which is essential for checking the ability of users to log in, we recommend that you set up synthetic transaction monitoring. This will provide greater granularity for your monitoring and enable you to detect outages unrelated to Auth0 as well as degradation of performance, so you can respond more proactively.\n\n### Best Practice\n\nYou should set up the ability to send synthetic login transactions to facilitate end-to-end monitoring of authentication. You can do this with a simple application that uses the [Resource Owner Password Grant](https://auth0.com/docs/api-auth/tutorials/password-grant) in combination with a test user that has no privileges, and don’t forget about [Auth0 rate limiting policies](https://auth0.com/docs/policies/rate-limits) too.\n\n## Notifications\n\nThere are several different types of notifications from Auth0 that you should watch for as they contain important information that could impact your tenant(s) and project.\n\n### Dashboard notifications\n\nFrom time to time, Auth0 may send an important announcement related to your tenant. These announcements about your service will be sent to your Auth0 dashboard and depending on the severity of the announcement, via email to the registered Auth0 dashboard administrators. You should make a regular practice of logging in to the dashboard and checking the bell icon at the top for any important notices. In addition, you should review emails from Auth0 in a timely fashion as they may convey important information about changes or actions you need to take.\n\n### Auth0 security bulletins\n\nAuth0 regularly conducts a number of security-related tests, and if any issues are found, will proactively identify and notify customers who need to make security-related changes. Due to the extensible nature of the Auth0 product, however, it may not be possible for Auth0 to identify every impacted customer, so you should regularly check Auth0 [security bulletins](https://auth0.com/docs/secure).\n\n### Best Practice\n\nIt is a best practice to check the Auth0 [Security Bulletins](https://auth0.com/docs/security/bulletins) page periodically and take the recommended action if you are impacted by any security bulletins.\n\n### Change log\n\nAuth0 provides information on changes to the service in the Auth0 [change log](https://auth0.com/changelog). You should make a regular practice of reviewing Auth0 change logs to be aware of changes. Support teams researching an issue may find it useful to review the change log to determine if recent changes might be related, especially if these are [breaking changes](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations). Development teams will also want to review the change logs to identify new features that may be beneficial.\n\n## Provisioning organizations\n\n### best practice\n\nWhat you need to do when provisioning an organization will depend on how organizations are represented in your system. This can take some time to step back and consider how users of those organizations will be interacting with your applications. See [Multiple Organization Architecture](https://auth0.com/docs/media/articles/architecture-scenarios/planning/Multiple-Organization-Architecture-Multitenancy-Overview.pdf) to determine how to configure organizations for your IAM system.\n\nWhen provisioning organizations you need to consider the following:\n\n*   You will need to add the organization to your own application configuration and/or database\n    \n*   You will need to make changes to your Auth0 configuration. This will include doing some or all of the following:\n    \n    *   Create a unique tenant\n        \n    *   Add a database connection (if you have isolated users per organization)\n        \n    *   Add an enterprise connection for this organization\n        \n        *   This will include working with the organization to either update their existing configuration or add configuration for your Auth0 tenant if they are not a legacy organization.\n            \n    *   Provision an administrator for the organization\n        \n*   To avoid mistakes, you may want to create an [Organization Admin Portal](#organization-admin-portal) to make it easier to provision new organizations.\n    \n\n### Organization Admin Portal\n\nAn organization admin portal is a portal that allows your administrators to create, modify, and remove organizations. There are multiple activities that need to be done both in your own system and your Auth0 tenant. This portal will likely need to exist in your own system so it has access to your datastores and configuration. However, Auth0 provides the [Auth0 Management API](https://auth0.com/docs/api/management/v2) so that you can incorporate changes to your Auth0 tenant at the same time that you create the changes in your own system.\n\nThere are two main approaches that can be taken for creating a new organization. The one you choose depends highly on your tolerance for how long it would take to deploy a new organization.\n\n*   **Live Updates to your Auth0 Tenant**: If you want to be able to create new organizations in real-time, then you will likely want to make the changes directly to your Auth0 tenant using the Auth0 Management API. This allows the changes to take place in real-time and allow the addition of a new organization to take effect immediately.\n    \n\n*   **Change the Repository and Re-deploy**: If you are taking advantage of the Deploy CLI (or a custom CLI) as part of your [CI/CD pipeline](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/deployment), you may prefer to push your changes directly to your repository and then kickoff a new deployment instead. This can take a little more time, but it has benefits associated with version history and the ability to backout a change by re-deploying the previous version.\n    \n\n### Best Practice\n\nYou may want to have a separate repository just for the items that the organizations need so that you don't have to re-deploy other common components and risk making an error.\n\n## Self-Service IdP provisioning\n\nWhile Auth0 [connections](https://auth0.com/docs/identityproviders) make it easy to configure IdPs, it can be a time-consuming process to onboard customer organization IdPs especially if you are selling to new customer organizations on a regular basis or existing organizations have changing IdP requirements. As a result, many of our customers have found it worthwhile to build a self-service portal for their customers' organization admins so that they can configure their own IdPs. This cuts down on your IT department's workload. The [Auth0 Management API](https://auth0.com/docs/api/management/v2) provides all necessary [connection management functionality](https://auth0.com/docs/api/management/v2#!/Connections/get_connections) to achieve this.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)\n\n## Multiple Organization Architecture (Multitenancy)\n\nMany B2B platforms implement some form of isolation and/or branding for their customers' organization, and this can add complexity to any Identity and Access Management (IAM) system. If this applies to you, then we recommend you take some time to read through our guidance and best practice advice for this type of environment.\n\n[Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)",
  "title": "Operations (B2B)",
  "description": "How to operationalize your Auth0 tenant environments.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/architecture",
  "markdown": "# Architecture (B2C)\n\nUnderstanding your application is key to understanding how Auth0 can be leveraged to meet your needs. From experience, our most successful customers start with a visualization of their proposed - or in many cases existing - architecture and use this as a basis for reference as they progress. Understanding where your application fits within your organization is also important; Auth0 [Accounts and Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants) form the basis for the grouping and structuring of Auth0 assets, and it may be that you’ll need to leverage an existing Auth0 deployment in order to integrate with [Single Sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on), centralized user [Profile Management](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/profile-management), consolidated billing, or the like.\n\n### Best Practice\n\nIf you do have multiple applications, and you need to leverage SSO, then we recommend you check out our [How to Implement Single Sign-On](https://auth0.com/learn/how-to-implement-single-sign-on/) training guidance before continuing.\n\nThe value of investing time on the landscape of the architecture up-front is something that we have found pays dividends in the long run, and there are a number of things you will want to consider when looking at functionality and workflow:\n\n*   What should the URL look like when Auth0 needs to present a web page to a user?\n    \n*   How can Auth0 be structured to support your SDLC (Software Development Lifecycle)?\n    \n*   How can you ensure that your Auth0 tenants are appropriately associated with your contract?\n    \n*   What do you need to consider if there are other projects in your organization integrating with Auth0? Particularly projects that target their own, or a different domain of users (for example, applications that only employees will use)?\n    \n\nOrganizations often service more than one domain of user - customers, employees, and affiliates being the most frequently encountered, with typically little to no cross-over: employees, say, don’t use the same applications as customers and vice-versa. In some cases there can also be a need to partition further within a domain - separate groups of customers, say, who use different and unconnected products. Auth0 provides a way to segregate your users and the associated collateral, and [tenant provision](#tenant-provision) covers this in more detail. If you need to provision an independent tenant then you’ll also want to [associate this with your existing Auth0 account](#tenant-association), so that you can take full advantage of the benefits provided at your organization’s contracted subscription level.\n\n### Best Practice\n\nIt’s not uncommon for companies to have identity requirements that address multiple user communities: customers, partners, employees, etc. So be sure to consider other projects or future requirements when designing your architecture.\n\nIn addition, you’ll undoubtedly have an established set of processes and procedures as part of your Software Development Lifecycle (SDLC). So you’ll want to check out our [SDLC support](#sdlc-support) guidance regarding Auth0 Tenant provision in support of that too.\n\nFor customer-facing applications, we typically see [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) as being the most frequently used protocol. OIDC makes use of web based workflows with browser URLs that are presented to the user. Out-of-the-box, client facing URLs as part of Auth0 OIDC support are Auth0 branded, however we recommend using the Auth0 [custom domain](#custom-domains) capability to provide for consistent corporate identity and to also address potential user confidence concerns before they arise.\n\n### Best Practice\n\nOther groups within your organization may also be working with Auth0; it’s not uncommon for our customers to have disparate departments that serve different user communities. Identifying these will potentially influence your design choices, and doing so early could mitigate decisions that might prove costly later on.\n\n## Tenant provision\n\nEverything starts with an Auth0 tenant. This is where you will be configuring your use of Auth0, and the where Auth0 assets - such as [Applications](https://auth0.com/docs/get-started/applications), [Connections](https://auth0.com/docs/connections) and [user profiles](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/profile-management) are defined, managed and stored. Access to an Auth0 tenant is performed via the Auth0 [Dashboard](https://auth0.com/docs/get-started/auth0-overview/dashboard), and via the Dashboard you can also create additional, associated tenants; you’re allowed to create more than one Auth0 tenant so that you can structure your tenants in a way that will isolate different domains of users and also support your [Software Development Life Cycle](#sdlc-support) (SDLC).\n\nDetermining the level of isolation you require when it comes to your user domains is an important step, and together with your branding requirements will subsequently help you determine the number of Auth0 tenants that will be required in your production environment. As we recommend you create a full suite of [SDLC supporting tenants](#sdlc-support) for every Auth0 tenant you will run in a production environment, the number of Auth0 tenants you will need to manage can quickly grow. Therefore you should consider carefully before creating multiple Auth0 tenants for production, and should consult our guidance on [Branding](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/branding) before making your final decision.\n\n## Tenant association\n\nTo ensure that your [tenants are all associated with your Auth0 contractual agreement](https://auth0.com/docs/get-started/auth0-overview/create-tenants/child-tenants) and have the same features, ensure all your tenants are associated with your company account. If you have individual developers that want to create their own sandboxes for testing, make sure they get associated with your account so they have the same permissions too. To do this you should contact your Auth0 representative or the [Auth0 Support Center](https://support.auth0.com/).\n\n## Custom domains\n\nWhen you setup your Auth0 tenant, the URL for accessing that tenant will be of the form `https://yourTenant.auth0.com`. Providing a [Custom Domain](https://auth0.com/docs/customize/custom-domains) (also known as a vanity URL), for your Auth0 tenant is not only an important factor for supporting your Branding requirements, but more importantly will also provide you with security benefits too:\n\n*   Some browsers will, by default, make it [difficult to communicate in an iFrame if you don't have a shared domain](https://auth0.com/docs/troubleshoot/authentication-issues/renew-tokens-when-using-safari).\n    \n*   It's [harder to phish your domain if you have a vanity URL](https://auth0.com/blog/introducing-custom-domains-preview-with-auth0/), as the phisher must also create a vanity URL to mimic yours. For example, with a custom domain you can use your own certificate to get an \"Extended Validation\", making phishing even harder.\n    \n\nYour custom domain name should also give the user confidence that this is the appropriate place to enter their credentials, and we recommend that you create your custom domain in all environments early on to ensure that you are testing consistently between environments. **It's extremely important to train your users to to look for suspicious URLs when entering their credentials!**\n\n### Best Practice\n\nCreate a custom domain (a.k.a. `CNAME`) for your Auth0 tenant, and also create one in development too so you can ensure you have managed the `CNAME` correctly. For example, you could create a `CNAME` which maps `login.mycompany.com` to `mycompany-prod.auth0.com`.\n\nIn almost all cases, customers have been most successful when adopting a strategy of a centralised domain for authentication across multiple product or service brands. This strategy provides users with a consistent UX, and also mitigates the complexity of deploying and maintaining multiple Auth0 tenants in a production environment. If you are considering having multiple domains for different brands, please refer to the [Branding](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/branding) guidance before you begin implementing.\n\n## SDLC support\n\nEvery company has some form of Software Development Life Cycle (SDLC), and throughout the development process you will want to align with that strategy. For instance, you need to be able to test your integration with Auth0 in a similar fashion as you test the applications themselves. It is therefore important to [structure Auth0 tenants to support your SDLC](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments), and there is a consistent pattern which our customers typically follow when it comes to the best practices associated with tenant layout for doing so:\n\n| Environment | Sample Tenant Name | Description |\n| --- | --- | --- |\n| Development | **company-dev** | A shared environment where most of your development work occurs |\n| QA/Testing | **company-qa** or **company-uat** | An environment for formal testing of the changes you've made |\n| Production | **company-prod** | The production tenant |\n\nIn some cases you may also want to create one or more sandboxes (e.g., **company-sandbox1**, **company-sandbox2**) so that you can test changes without compromising your development environment. This might be where you test deployment scripts and the like.\n\n### Best Practice\n\nYou can also take advantage of our [Implementation Checklists](https://auth0.com/docs/architecture-scenarios/checklists) that you can download and customize to meet your implementation project needs.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Architecture (B2C)",
  "description": "Learn how to configure your Auth0 tenant architecture affects your Business to Consumer (B2C) Identity and Access Management (IAM) implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/authentication",
  "markdown": "# Authentication (B2C)\n\nTo provide services to your users, you must be able to identify who those users are. This process is called User Authentication. There are a number of ways to perform authentication of a user—via social media accounts, username and password, passwordless—and it's often recommended that you go beyond a first factor for authenticating the user by enabling multi-factor authentication (MFA).\n\n### Best Practice\n\nIt's important to consider both security and user experience when designing how you will authenticate your users. Providing for multiple primary factors, and/or enforcing more than one factor during authentication, are ways that you can provide both.\n\nThere are a number of things you will want to consider when looking at functionality and workflow:\n\n*   Where will users enter their credentials?\n    \n*   How will you keep user credentials safe?\n    \n*   How will you maintain your authentication system?\n    \n*   How can you provide password authentication for your users?\n    \n*   How can you prevent hackers from trying to log in as your users?\n    \n*   How will you implement authentication in different kinds of applications?\n    \n*   How can you make login easy for your users when they come from different language backgrounds?\n    \n*   How will you provide a good user experience as you migrate away from any legacy authentication system?\n    \n*   What should you consider when integrating applications with Auth0?\n    \n*   Can users log in using their existing social (e.g., Facebook or Google) accounts?\n    \n*   Do you need to provide multi-factor authentication?\n    \n*   What do you do if you have a service that doesn't have a way for the user to log in ahead of time?\n    \n*   Can you pass the same user access token from one API to another?\n    \n\nAuth0 [Universal Login](#universal-login) provides users with a safe and secure experience—no matter whether you choose to provide for user ID/password credentials sign in, or allow the so-called Bring Your Own Identity scenarios provided via [Social Login](https://auth0.com/learn/social-login/). There are also brand recognition benefits to centralizing the login experience with Universal Login, even if you feel you will also have product-specific [branding](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/branding) requirements. The Auth0 UI widgets typically used with Universal Login also provide out-of-the-box support with regards to [internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization) for users with different language requirements, and out-of-the-box support for Auth0 features such as [MFA](#multi-factor-authentication-mfa-) and [attack protection](#anomaly-detection) allow you to put barriers in place in order to prevent hackers attempting to access users' accounts.\n\nAllowing users to sign in via user ID/password credentials means that you're not reliant on the status of third-party identity providers for your users to access your system. You also have the means to require the credentials used to align with your corporate policies. Auth0 assists with this by providing you with multiple options in support of user ID/password logins, and the [guidance provided](#username-and-password-authentication) will help you understand you can leverage these options. Adding [social](#social-authentication) support at some stage, as an additional primary authentication factor, gives you added flexibility and can help you better understand your users without the need to question them further by leveraging the information already stored by the various social login [providers](https://auth0.com/docs/connections/identity-providers-social).\n\nIf you have an existing legacy identity store, you’ll also want to see [User Migration](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/provisioning). This section discusses the advantages of migrating to Auth0’s managed identity storage in terms of safety and security.\n\nFor customer facing applications, OpenID Connect ([OIDC](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)) is the most frequently used industry standard protocol, and OIDC has first-class citizen support in Auth0. Auth0 provides support for various different approaches for integrating various different applications, so you'll want to see the section on [application integration](#application-integration) for the information you'll need to make an informed choice.\n\nWhen calling one API from another API, or from any situation where there is no authenticated user context—such as one or more cron jobs, report generators, or continuous integration/delivery systems—you will need a way to authorize the application instead of a user. This is a one step process where the application is authenticated (using a client ID and secret) and then authorized in one call. You can learn more about this in our authorization workstream under [machine-to-machine (m2m) authorization](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/authorization).\n\n## Universal Login\n\nDo you have, or will you have, more than one application in your system? If the answer to this question is yes, then you will want a centralized sign in experience. To achieve a seamless Single Sign-on (SSO) experience between multiple applications, it is critical to have a centralized location to redirect your users for authentication. This allows you a way to provide your users with a consistent experience if you add social authentication in the future, add third party applications to your system, or add multi-factor authentication as an option (or requirement) for your users—and also allow you to take advantage of new features for improving your users’ experience with little, if any, added development effort.\n\n### Best Practice\n\nIf you have more than one application, the best practice is to redirect to a [centralized location](https://auth0.com/docs/universal-login) to authenticate the user. With Auth0, this means taking advantage of [Universal Login](https://auth0.com/docs/universal-login), which provides many security and user experience benefits out-of-the-box, including [SSO](https://auth0.com/docs/sso/current).\n\nAuth0 Universal Login makes authenticating users a short, easy process which can be accomplished in three easy steps (all of our Quickstarts demonstrate this and our SDKs hide the complexity for you too):\n\n1.  Determine how and when you want to [redirect from your application](#application-integration).\n    \n2.  Set up the appropriate [branding](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/branding) and/or customized HTML in your Auth0 configuration.\n    \n3.  Set up your application to [receive and handle the response](#application-integration) from the Authorization Server.\n    \n\n## Username and password authentication\n\nNearly every B2C application provides the ability for their customers to create a new set of credentials. This is a common form of authentication that all users are familiar with.\n\nUsername password authentication comes in multiple flavors at Auth0. If your application is a green-field application with no existing user base, then a simple Auth0 out-of-the-box [Database Connection](https://auth0.com/docs/connections/database) will give you everything you need to start authenticating your users. However, if you have a legacy user store—such as your own database of users or an existing LDAP system—you have a couple of different options for migrating your users as discussed in our guidance on [User migration](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/provisioning).\n\nHowever you end up provisioning the users for your database connection, the authentication of those users is quite similar. It requires you to present users with a form to enter their username and password. As mentioned in the guidance concerning [Universal Login](#universal-login), the simplest and safest way to authenticate users with a username and password is to redirect them to a centralized login page and collect their username and password there. This allows Auth0 to determine whether they have already authenticated and skip the login form entirely when it's not needed.\n\n### Best Practice\n\nCollecting credentials only at the centralized login page will reduce the surface area for potential leak of user secrets. It will also reduce the need to collect credentials unnecessarily. See [Universal Login](#universal-login) for more information.\n\n## Application integration\n\nOnce you've figured out how you want to authenticate your users, the next step is to determine how you will initiate that authentication. Each application will typically have its own starting point.\n\nAs discussed, we've found that most of our customers use [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) as the industry-standard protocol when it comes to their customer-facing applications. Figuring out which OIDC flow to use is your first task, and you will want to start by reviewing the our [grant mapping](https://auth0.com/docs/get-started/applications/application-grant-types) guidance in the first instance.\n\nIf you want to allow anonymous users access to any part of our application then you need to determine if you will be redirecting right away or prompting your users to redirect only when required (or perhaps some combination of both; see [Redirect Users After Login](https://auth0.com/docs/authenticate/login/redirect-users-after-login) for further discussion). If users can [deep link](#deep-linking-to-protected-endpoints) to a protected version (or area) of your site then you will need to determine the links to your application that will result in an automatic redirect to Auth0.\n\n### Anonymous access\n\nIt is important to consider the user experience when someone first comes to your application. If your application supports anonymous user access (quite common for eCommerce applications) there are different scenarios to consider:\n\n*   Are they returning to the application after having already logged in, or\n    \n*   If this is the first time they are accessing the application:\n    \n    *   Have they already accessed a different application that uses the same Auth0 tenant,\n        \n    *   Have they ever (or perhaps not in a long time) authenticated on this device or browser.\n        \n\nWhen an anonymous user accesses your application, it can often be desirable for the application to discover if the user has already logged into a different application in the same family, or to remember this user even if the application is a [SPA](https://auth0.com/docs/quickstart/spa) with no state. For example, if you can determine that the user is already logged in, you might decide to have the UI header in the application skip displaying a login button and instead have an account or profile menu for the user. To accomplish this you will want to utilize \"[silent authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication)\". Silent authentication will allow you to check to see if the user is logged in without prompting them to log in if they are not. Then the application can present a login button if necessary. If the user is logged in already, however, then you will receive tokens and will not have to present the user with a login button again.\n\n### Deep linking to protected endpoints\n\nThere are a variety of reasons why someone might link directly to a particular page within your application that is only accessible by authenticated users. If this is possible for your application you should automatically redirect your user to Auth0 if they are not authenticated. Once they authenticate and the authorization server returns them to your application, you can [redirect them](https://auth0.com/docs/authenticate/login/redirect-users-after-login) to where they intended to go in the first place.\n\n### Best Practice\n\nMost modern authentication frameworks support middleware for redirecting to an authorization server such as Auth0. When selecting one, here are some key considerations:\n\n*   Support for confidential clients, non-nonfidential clients or both\n*   Support for configuration via [discovery endpoint](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery \"Configure Applications with OIDC Discovery\") or explicitly inline\n*   Support for token validation including expirations, signatures, claims and scopes\n*   Support for Refresh Tokens if needed\n\n### Authenticating the user\n\nAuthentication is the process of determining user identity. The result of authentication in an OIDC context is an ID Token. This token contains information about the user and should only be able to be obtained if the user authenticates using one or more factors as defined by the authorization server (the most common form being [user ID and password](#username-and-password-authentication)). There are a few things you may also need to consider in addition to obtaining an ID Token:\n\n*   Do we also need an [Access Token](https://auth0.com/docs/secure/tokens/access-tokens) in order to call a shared API?\n    \n*   Is your application a single-page application and only requires an [ID Token](https://auth0.com/docs/secure/tokens/id-tokens)? See [Authorization Code Grant with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce) for more information.\n    \n*   Is your application a native application (mobile or desktop) and/or do you need a [Refresh Token](https://auth0.com/docs/secure/tokens/refresh-tokens)? See [Authorization Code Grant with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce) for more information.\n    \n\nIf your SDK only supports the Authorization Code grant, or you need an Access Token or Refresh Token, then Authorization Code grant (with or without [PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)) can also be used to retrieve an ID Token. The Authorization Code grant includes an additional API call to exchange the code for a token which can result in additional unnecessary latency if all you need is the ID Token. In many cases the [hybrid flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow) is implemented to provide optimum access to the ID Token while still leveraging Authorization Code grant workflow for the secure and safe retrieval of Access and Refresh Tokens.\n\n## Attack protection\n\nThe reason that authentication systems are important is to prevent bad actors from accessing applications and user data that they should not. We want to place as many barriers as possible between those bad actors and access to our systems. One of the easiest ways to do this is to ensure that your [attack protection](https://auth0.com/docs/secure/attack-protection) with Auth0 is configured correctly, so take a moment to read the guidance on this subject and ensure that it's working correctly for you.\n\n### Best Practice\n\nAnomaly detection is handled behind the scenes by Auth0 and provides a great security feature for your product. If you're going to utilize it, ensure that you have set up your [Email Provider](https://auth0.com/docs/architecture-scenarios/b2c/operations#email-provider-setup) and configured your [Email Templates](https://auth0.com/docs/architecture-scenarios/b2c/branding#email-template-customization) before turning on email delivery to your users.\n\n## SSO with legacy systems\n\nIn a large scale re-structure it's not always possible—or practical—to update all your applications at once. In fact, our recommended best practice is to plan for an iterative-style approach when it comes to integrating with Auth0. If your applications already participate in Single Sign-on (SSO), and your legacy identity system supports protocols such as OIDC or SAML, then you have a couple of options available if you want to continue to provide SSO as you integrate with Auth0:\n\n*   Update your existing identity provider in your legacy SSO system to redirect to Auth0 for login (e.g., using [SAML](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider)), or\n    \n*   Have Auth0 redirect to your legacy SSO system to login. This requires configuring your legacy system as an IdP in Auth0 (i.e., either using [SAML](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider) or [OIDC](https://auth0.com/docs/connections/identity-providers-social)).\n    \n\n### Best Practice\n\nSupporting an SSO experience with your legacy system can add complexity, but may be worth it to generate a more seamless user experience as you integrate with Auth0. If you intend to go down this path, planning for it early can help ensure that it is possible to achieve. If you don't already have SSO at a centralized service, then the complexity to add it will unlikely be worth the benefits.\n\nThis is a complex topic that will likely need some additional investigation depending on your current legacy architecture, and we recommend you only look into this if you currently have SSO support in your legacy system. Note: if you are currently redirecting from your applications to a centralized system to authenticate your users and that system only asks for credentials if you don’t already have a session with the centralized system, then you have a legacy SSO implementation.\n\nThe “bring your own identity” scenario offered by Facebook, Google, etc., is a valuable way of simplifying the user authentication experience without compromising security, and using [Universal Login](#universal-login) makes it easy to start adding support for [Social Connections](https://auth0.com/docs/connections/identity-providers-social) with minimal disruption.\n\nWith [social](https://auth0.com/learn/social-login/) support, user identities and credentials are managed by the social provider, as are certain identity claims, which Auth0 will use to populate the user [profile](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/profile-management). Auth0 can also provide access to Social Identity Providers' (Social IdPs') [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens), so that your application can also call third-party Social IdP APIs on behalf of the user.\n\n### Best Practice\n\nSocial is a great feature to provide, but when you offer more than one way to sign in, you need to consider the possibility that your customers will actually use more than one way to sign in. By default, every user identity in Auth0 has its own user profile, so you’ll probably want to consider Auth0's capability to [link user accounts](https://auth0.com/docs/users/concepts/overview-user-account-linking) to provide an effective way of associating one user profile with multiple identities.\n\nThe Auth0 [Custom Social Connections extension](https://auth0.com/docs/connections/identity-providers-social) extends social authentication even further by allowing you to connect with any [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) third-party-compliant vendor not supported out of box. For example, support for the government-issued-identity provider [SwissID](https://www.swissid.ch/) can be configured in Auth0 by using a Custom Social Connection.\n\n## Multi-factor authentication (MFA)\n\nIn an era where misuse of user credentials is at an all-time high, protecting your systems when it’s so common for hackers to steal users identity information in general is a challenge. One of the most effective ways though is to provide users with the ability to configure a second factor for protecting their account. More commonly referred to as [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication). This will ensure that only a valid user can access their account, even if they use a username and password that may have been compromised from a different application.\n\n### Best Practice\n\nIt's quite common for customer facing applications to provide users with an _option_ for adding a second factor rather than _forcing_ them to use a second factor. For more information regarding this, see [providing your users with an option to add MFA](https://auth0.com/learn/multifactor-authentication-customers/).\n\nAuth0 supports a number of different options when it comes to enabling MFA for protecting user account access, and there are several practices to ensure that you will truly be providing a flexible second factor barrier to access:\n\n*   Auth0 [Guardian](https://auth0.com/multifactor-authentication): a service that provides both Push notification generation and an application for allowing or denying requests. Push sends notification to a user’s pre-registered device—typically a mobile or tablet—from which a user can immediately allow or deny account access via the simple press of a button.\n    \n*   Time-based One-Time Password ([TOTP](https://auth0.com/blog/from-theory-to-practice-adding-two-factor-to-node-dot-js/)): allows you to register a device—such as Google Authenticator—that will generate a one-time password which changes over time and which can be entered as the second factor to validate a user’s account.\n    \n*   SMS: for sending a one-time code over SMS which the user is then prompted to enter before they can finish authenticating.\n    \n*   Voice: for delivering a one-time code through a phone call which the user is then prompted to enter before they can finish authenticating.\n    \n*   Duo: allows you to use your Duo account for multi-factor authentication.\n    \n*   Email: allows you to use your email account for multi-factor authentication.\n    \n\nWhilst MFA workflow using technologies such as Guardian or Google Authenticator is typically provided via a separate application that runs on a mobile or tablet device, if you don’t want your customers to have to download a separate application Auth0 also provides you with an [SDK](https://auth0.com/blog/announcing-guardian-whitelabel-sdk/) that you can use to build second factor workflow right in your existing mobile device application(s).\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Authentication (B2C)",
  "description": "How authentication works in your B2C IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/provisioning",
  "markdown": "# Provisioning (B2C)\n\nDetermining how users get signed up is important to address early, and the decisions you make here will influence many of the decisions you will need to make going forward. We’ve found there are a typical set of patterns for how users will get added to your system, and things to take note of when considering workflow design too.\n\n### Best practice\n\nWhile Auth0 supports numerous workflows, web based workflows using Auth0 [Universal Login](https://auth0.com/docs/login/universal-login) for sign up are considered both industry and Auth0 best practice as they provide for optimal functionality and the best security.\n\nAuth0 supports user sign up via a number of different [identity providers](https://auth0.com/docs/connections). During sign up, Auth0 provisions the [user profile](https://auth0.com/docs/videos/get-started-series/learn-user-profiles) so that it contains the user’s account information. There are a number of things to consider when looking at functionality and workflow:\n\n*   Should you use Auth0 as an identity store?\n    \n*   Can you use your own (legacy) identity store with Auth0?\n    \n*   How do you migrate user identities from your identity store to Auth0?\n    \n*   Can your users sign up using their existing social accounts such as Google and Facebook?\n    \n\nAuth0 provides out-of-the-box identity storage that can be leveraged to store user credentials safely and securely. See [Self Sign Up](#self-sign-up) for more information. If you already have a legacy identity store and you want to offload the management of it, then the [User Migration](#user-migration) capabilities provide you with a number of options to do so.\n\nAlternatively, if you have to maintain your legacy identity store - perhaps because you’ve got applications which you aren’t ready to migrate or which can’t be migrated - then you can use the [identity store proxy](#identity-store-proxy) capability. Allowing your customers to use “bring their own identity” is also an attractive proposition and though we find our customers don’t initially do so, you can use the [Social Sign Up](#social-sign-up) capability to provide it.\n\n### Get Started with Auth0 Videos\n\nWatch these two short videos [Provision: Users Stores](https://auth0.com/docs/videos/get-started/02-provision-user-stores) and [Provision: Import Users](https://auth0.com/docs/videos/get-started/03-provision-import-users) to learn how user profiles are provisioned within an Auth0 tenant and how Auth0 allows you to move your existing users to an Auth0 user store.\n\n## User migration\n\nIn addition to hosting the [User Profile](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/profile-management), Auth0 also has the capability to both [proxy](#identity-store-proxy) your own legacy identity store and provide a secure Auth0 hosted replacement. Both of these capabilities are supported via the use of Auth0 [Database Connections](https://auth0.com/docs/connections/database). If you decide to use Auth0 as a replacement for your legacy identity store then you can [migrate users](https://auth0.com/docs/manage-users/user-migration) either all at once with bulk migration, or progressively with automatic migration.\n\n### Best Practice\n\nCustomers often opt for a two-stage approach to user migration, using Automatic Migration first to migrate as many users as possible, then using Bulk Migration for the users that remain. See [User Migration Scenarios](https://auth0.com/docs/users/import-and-export-users/user-migration-scenarios) for more information.\n\nAutomatic Migration is preferred as it allows users to be migrated individually and also allows them to retain their existing password in almost all situations. For Bulk Migration, we recommend using the [Management API](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) over the [User Import/Export extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension) in all but the most simple cases, as the Management API provides for greater flexibility and control.\n\nWith Bulk Migration users typically need to **reset their password once migration is complete**, unless passwords are stored hashed in your legacy identity store using bcrypt (or you can generate them in bcrypt form). In this case, you may be able to use bulk migration and **preserve user passwords** as part of the process, depending on the bcrypt algorithm and the number of salt rounds used. See [Bulk Import Database Schema Examples](https://auth0.com/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples) for more information.\n\n### Best Practice\n\nCalls to the Management API are subject to [Auth0 Rate Limiting policy](https://auth0.com/docs/support/policies/rate-limit-policy). You must take this into consideration, and to assist, Auth0 generally recommends use of the appropriate [Auth0 SDK](https://auth0.com/docs/libraries) for your development environment rather than calling our APIs directly.\n\n### Identity store proxy\n\nAuth0 Database Connection types can also be configured to proxy an existing (legacy) identity store. If you need to keep user identities defined in your own legacy store - for example, if you have one or more business critical applications that you can’t migrate to Auth0, but which still need access to these identities - then you can easily integrate with Auth0. See [Authenticate Users Using Your Database](https://auth0.com/docs/connections/database/custom-db) for more information.\n\n## Self sign up\n\nSelf sign up leverages Auth0 [Database Connections](https://auth0.com/docs/connections/database) to store the user ID, password, and (optional) username identity information collected from new users during the sign up process. Database connection policies governing things such as minimum [username length](https://auth0.com/docs/connections/database/require-username) or [password strength and complexity](https://auth0.com/docs/connections/database/password-options) can be configured via the Auth0 Dashboard.\n\n### Best Practice\n\nAuth0 [Universal Login](https://auth0.com/docs/universal-login) as well Auth0 widgets such as [Lock](https://auth0.com/lock) integrate with Database Connections to provide comprehensive user interface functionality for sign up out-of-the-box. These UI artifacts are fully reactive, and with feature rich configuration and comprehensive customization, you can deploy functionality for user self sign up as well as login.\n\nSocial signup is synonymous with sign in via [social authentication](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/authentication) - there’s no distinction here \\*per se\\*, as user [profile](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/profile-management) creation happens automatically upon first social login.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Provisioning (B2C)",
  "description": "User provisioning functionality and considerations for your B2C IAM  implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/branding",
  "markdown": "# Branding (B2C)\n\nAuth0 can be customized with a look and feel that aligns with your organization's brand requirements and user expectations. Branding Auth0 collateral provides a consistent user experience for your customers, and gives them peace of mind that they’re using a product from a trusted and secure provider.\n\nAuth0 provides support for [internationalization (I18N)](https://auth0.com/docs/customize/internationalization-and-localization) and localization (L10N), both of which are important if you work on branding for an international clientele. Out-of-box collateral, such as the Auth0 Lock UI widget, comes ready enabled for multiple language support, with built-in extensibility for adding more languages if what you require [doesn’t already exist](https://auth0.com/docs/customize/internationalization-and-localization/lock-internationalization).\n\n### Best Practice\n\nAlmost all applications need Internationalization and/or Localization in one form or another. Auth0 makes it easy to add, but you need to account for it up front: retro-fitting localization, for example, can be a painful process if left too late.\n\nWhen considering the items you want to brand, as well as how best to brand them, there are a number of things you'll want to review:\n\n*   Do you need to brand your login page?\n    \n*   Do you need to localize your login page?\n    \n*   How can you customize emails so that they're not just branded, but vary based on user preference?\n    \n*   How will users know that they're still on your domain when they see your login page?\n    \n*   What do you need to do to provide additional browser security (e.g., implement Extended Validation)?\n    \n*   Where do you want to direct users in the event of errors?\n    \n\nAuth0 provides tremendous flexibility when it comes to customizing and configuring Auth0 pages such as [Universal Login](#universal-login-and-login-pages) and [Password Reset](#password-reset-page-customization). So you can pretty much set up whatever UX look and feel you require. For many, the out-of-the-box experience - with perhaps a little alteration - is all that's required. However, for others the value of their brand and brand awareness requires more extensive customization. This flexibility extends to not only Auth0 pages, but via extensibility can also be applied to the [email templates](#email-template-customization). Auth0 [Custom Domain](#custom-domain-naming) functionality further enhances consumer awareness by providing users with the confidence and peace of mind when it comes to safety and security.\n\nWhile Auth0 provides for default information when it comes to error situations, out-of-the-box information can be somewhat cryptic as the context that can only be provided by you is missing. Auth0 [error page customization](#error-page-customization) guidance can however help mitigate that by allowing you to provide information of a more context-specific nature via your own support organization.\n\n### Best Practice\n\nTo provide helpful resources for users who experience problems, you should also configure a friendly name and a logo, as well as provide the support email address and URL for your organization. To learn how, see [Dashboard Tenant Settings](https://auth0.com/docs/dashboard/reference/settings-tenant#settings).\n\n## Universal login and login pages\n\n[Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) is the recommended method for authenticating users, and it centers around use of the Login page. You can customize the Login page to support your organization's branding requirements.\n\n### Best Practice\n\nIf you choose to customize the Universal Login page script, we strongly recommend that you make use of version control. To do this, you should deploy the script to your Auth0 tenant via [deployment automation](https://auth0.com/docs/architecture-scenarios/b2c/deployment) or via one of the [alternative strategies](https://auth0.com/docs/universal-login/version-control).\n\n## Custom domain naming\n\nBy default, the URL associated with your tenant will include its name and possibly a region-specific identifier. For example, tenants based in the US have the a URL similar to `https://example.auth0.com` while those based in Europe have something that is of the fashion `https://example.eu.auth0.com`. A [Custom Domain](https://auth0.com/docs/customize/custom-domains) offers a way of providing your users with a consistent experience by using a name that’s consistent with your organization's brand.\n\nIn addition, Custom Domain functionality offers you complete control over the certificate management process. By default, Auth0 provides standard SSL certificates, but if you configure a custom domain, you can use Extended Validation (EV) SSL certificates or similar to provide the visual, browser-based cues that offer your visitors additional peace of mind.\n\nIn general, we see customers having the most success when they use a centralized domain for authentication - this is especially the case if the company offers multiple products or service brands. By using a centralized domain, you can provide end users with a consistent user experience while also minimizing the need to maintain multiple production tenants in Auth0.\n\n## Email template customization\n\nAuth0 makes extensive use of email to provide both user notifications and to drive the functionality needed for secure identity management (for example, email verification, account recovery, and brute force protections), and Auth0 provides a number of templates for these.\n\nOut of the box, the email templates used contain standard verbiage and Auth0 branding. However, you can configure almost every aspect of these templates to reflect the verbiage and user experience you want and make changes to things like the preferred language, accessibility options, and so forth.\n\nEmail templates are customized using [Liquid syntax](https://auth0.com/docs/customize/email/email-templates/use-liquid-syntax-in-email-templates). If you are interested in customizing your templates based on user preferences, you will also have access to the [metadata](https://auth0.com/docs/manage-users/user-accounts/metadata) located in users' profiles, as well as any specific application metadata too.\n\n## Password reset page customization\n\nThe [Password Reset](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page) page is used whenever a user takes advantage of password change functionality and, as with the login page, you can customize it to reflect your organization's particular branding requirements.\n\n## Error page customization\n\nIf there are issues encountered during user interactive workflow (e.g. user sign up or login), Auth0 provides error messages that indicate what the problem is under the hood. The default messages are somewhat cryptic, especially to the end user, since they will likely be missing context that only you can supply. As such, we recommend [customizing your error pages](https://auth0.com/docs/customize/login-pages/custom-error-pages) to provide the missing context-specific information directly to your users. Furthermore, customizing your error pages allows you to display your branding, not Auth0's, as well as provide useful information to your users as to what should be done next. This information might include a link to a FAQ or how to get in touch with your company's support team or help desk.\n\n### Best Practice\n\nOut-of-the-box there is no user interface for customizing Auth0 provided error pages, but you can use the [Tenant Settings endpoint of the Management API](https://auth0.com/docs/api/management/v2#!/Tenants/patch_settings) to configure them. Alternatively, if you can create and host your own error page, then you can have Auth0 direct users to that page instead of using the Auth0-hosted option.\n\n## Guardian multi-factor page customization\n\nThe Multi-factor Authentication pages can be customized by adjusting the Universal Login branding options in the [Universal Login Settings](https://manage.auth0.com/#/login_settings) section.\n\nIf you need further customization, you can also customize [the full HTML content](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login) to reflect your organization's particular UX requirements.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Branding (B2C)",
  "description": "How to configure Auth0 items to reflect your brand and desired user experience.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/quality-assurance",
  "markdown": "# Quality Assurance (B2C)\n\nQuality Assurance is important in identifying issues before they impact your customers and, depending on the nature of your project, there are several different types of quality assurance testing that you’re going to want to consider as part of your integration with Auth0:\n\n*   Is your application easy to understand and use, even by those with a disability?\n    \n*   Does your application need to work across various different browsers and devices?\n    \n*   Does your application need to work in multinational and/or international environments?\n    \n*   How will your application perform when subjected to unexpected production loads?\n    \n*   How can you ensure your application is safe from security-related vulnerabilities?\n    \n\nAuth0 [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) and associated UI widgets (such as [Lock](https://auth0.com/docs/libraries/lock)) have already been designed and built following usability and accessibility best practices, and provide tested out-of-box support for a whole host of [browsers and devices](https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix). Support for [internationalization](https://auth0.com/docs/customize/internationalization-and-localization) (I18N) is also provided out-of-box, with built-in extensibility designed for custom multi-language and localization (L10N) situations.\n\nTo ensure functional requirements are met and unexpected events are handled correctly, guidance is provided for testing the [integration](#integration-testing) between your application(s) and Auth0, and for [unit testing](#unit-testing) individual extensibility modules (such as [Rules](https://auth0.com/docs/customize/rules/debug-rules), [Hooks](https://auth0.com/docs/customize/hooks/update-hooks), and Custom Database scripts). Guidance is also provided regarding Auth0's [penetration testing policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/penetration-testing-policy) to help when testing for security vulnerability, and also how [Mock](#mock-testing) testing can be leveraged in conjunction with our [load testing policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/load-testing-policy) to help ensure your application(s) perform under unexpected load.\n\n## Unit testing\n\nThe objective of unit testing is to test individual units of code. If you create custom code within Auth0 in the form of Rules, Hooks, and/or Custom DB scripts, you should consider use a testing framework (such as [Mocha](https://mochajs.org/)) to test your code. Companies who have been most successful with Auth0 have found it useful to execute these unit tests prior to [automatically deploying](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/deployment) Auth0 tenant configuration and collateral.\n\n## Integration testing\n\nIt is a recommended best practice that you set up different tenants for development, testing, and production as discussed in Architecture guidance for [SDLC support](https://auth0.com/docs/architecture-scenarios/b2c/architecture#sdlc-support). Auth0 allows you to configure variables that are available from within custom [extensibility](https://auth0.com/docs/customize/extensions); these can be thought of as environment variables for your Auth0 tenant. Rather than hard code references that change when moving code between development, test, and production environments, you can use a variable name that is configured in the tenant and referenced by the custom extensibility code. This makes it easier for the same custom code to function, without changes, in different tenants as the code can reference variables which will be populated with tenant-specific values at execution time:\n\n*   For use of variables in Rules, see how to [configure values](https://auth0.com/docs/customize/rules/configuration)\n    \n*   For use of variables in Hooks, see how to configure [secrets](https://auth0.com/docs/customize/hooks/hook-secrets) in the editor\n    \n*   For use of variables in Actions, see Explore Flows and Triggers\n    \n*   For use of variables in Custom DB Scripts, see the [configuration parameters](https://auth0.com/docs/connections/database/custom-db/create-db-connection#step-3-add-configuration-parameters)\n    \n\n### Best Practice\n\nIt’s a recommended best practice to use variables to contain tenant-specific values as well as any sensitive secrets that should not be exposed in your custom code. If your custom code is deployed in GitHub, then using a tenant-specific variable avoids exposure of sensitive values via your GitHub repository.\n\n### Test automation\n\nYou can automate your overall build process by incorporating deployment automation as well as test automation. This can be used to deploy new versions of configuration and/or custom code to Auth0 and execute automated tests. If the tests uncover any failures, the deployment automation capabilities can be used to revert to the last working version. For further information, see the [deployment automation guidance](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/deployment) provided.\n\n## Mock testing\n\nIn a balance between Auth0’s [load testing policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/load-testing-policy) and the desire to load test, it is common practice among Auth0’s customers to mock out Auth0’s endpoints. This is a valuable practice in order to ensure that your application works with your expected interfaces without having to restrict your testing, and tools such as [MockServer](http://www.mock-server.com/), [JSON Server](https://github.com/typicode/json-server) or even [Postman](https://learning.getpostman.com/docs/postman/mock_servers/setting_up_mock/) can be used to assist.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Quality Assurance (B2C)",
  "description": "Quality Assurance considerations for your B2C IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/deployment",
  "markdown": "# Deployment Automation (B2C)\n\nIn addition to adopting best practices for change management and [QA](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/quality-assurance), successful customers will also integrate Auth0 collateral management as part of some automated deployment process. As discussed in the Architecture section under [SDLC support](https://auth0.com/docs/architecture-scenarios/b2c/architecture#sdlc-support), you will want to ensure you configure separate Auth0 tenants for development, testing, and production environments, and you will want that configuration to be almost identical for the tenant in each environment. Using deployment automation helps ensure this, so that each environment tenant is configured the same, and you will be less likely to see bugs show up as a result of mismatched configurations between environments.\n\n### Best Practice\n\nHowever you configure deployment automation, we’d recommend you unit test your rules, custom DB scripts, and hooks prior to deployment, and run some integration tests against your tenant post-deployment too. For more details regarding this, see the [Quality Assurance](https://auth0.com/docs/architecture-scenarios/b2c/quality-assurance) guidance provided.\n\nAuth0 provides support for a couple of different options when it comes to the deployment automation approaches you can use, and each can be used in conjunction with the other if desired:\n\n*   The [Auth0 Deploy CLI tooling](https://auth0.com/docs/deploy-monitor/deploy-cli-tool) provides you with an easy-to-use script that can help you integrate with your existing Continuous Integration/Continuous Deployment (CI/CD) pipeline.\n    \n*   If you can’t integrate directly with, or for some reason you don’t have a CI/CD pipeline, then the Auth0 [Source Control Extensions](https://auth0.com/docs/customize/extensions) can provide an easy-to-set-up basic automation process with very low maintenance.\n    \n\nEach environment may also need some environment-specific configuration--Application Client ID’s and Client Secrets will be different between the Auth0 tenants, for example--so you’re going to want some way of being able to dynamically reference this rather than having hard-coded values. Auth0 provides support for handling environment-specific configuration information through one of the following two approaches:\n\n*   Use [Tenant Specific Variables](#tenant-specific-variables)\n    \n*   Use keyword replacement if using the Auth0 Deploy CLI tool\n    \n\n## Tenant specific variables\n\nAuth0 allows you to configure variables that are available from within custom [extensibility](https://auth0.com/docs/customize/extensions); these can be thought of as environment variables for your Auth0 tenant. Rather than hard code references that change when moving code between development, test, and production environments, you can use a variable name that is configured in the tenant and referenced by the custom extensibility code. This makes it easier for the same custom code to function, without changes, in different tenants as the code can reference variables which will be populated with tenant-specific values at execution time:\n\n*   For use of variables in Actions, see [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action) to learn how to configure secrets in the editor\n    \n*   For use of variables in Rules, see how to [configure values](https://auth0.com/docs/customize/rules/configuration)\n    \n*   For use of variables in Hooks, see how to configure [secrets](https://auth0.com/docs/customize/hooks/hook-secrets) in the editor\n    \n*   For use of variables in Custom DB Scripts, see the [configuration parameters](https://auth0.com/docs/connections/database/custom-db/create-db-connection#step-3-add-configuration-parameters)\n    \n\n### Best Practice\n\nIt’s a recommended best practice to use variables to contain tenant-specific values as well as any sensitive secrets that should not be exposed in your custom code. If your custom code is deployed in GitHub/Gitlab/Bitbucket/VSTS, then using a tenant-specific variable avoids exposure of sensitive values via your repository.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Deployment Automation (B2C)",
  "description": "How Auth0 tooling helps to automate tenant deployment.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/profile-management",
  "markdown": "# Profile Management (B2C)\n\nAt some point, you may need to change the information stored in a user’s [profile](https://auth0.com/docs/videos/get-started-series/learn-user-profiles). A user’s profile (also known as the user’s account) is stored in Auth0, and changes to the information it contains may need to happen for a number of different reasons:\n\n*   Self-served information updates\n    \n*   Mandatory updates concerning your organizations T's & C’s\n    \n*   Changes due to regulatory compliance\n    \n\nAn [Identity Provider](https://auth0.com/docs/connections) populates a user’s profile using data supplied during the login process, and this is referred to as the [Normalized User Profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles).\n\nBy default, there is one user profile created for each user identity, and there are a number of things to consider:\n\n*   What should you do if you need to store information to help customize a user’s experience?\n    \n*   What if you need to store user information that didn’t originate from an identity provider?\n    \n*   Why would you need to store user-related information that a user cannot modify?\n    \n*   What do you do if you need to store user-related information that a user cannot modify?\n    \n*   What happens if a user forgets their password?\n    \n*   What should a user do if they want to change their password?\n    \n\nAuth0 provides for the storage of metadata against a user’s profile, which allows for the capture of additional information, such as preference for language and/or accessibility in order to enhance the user experience. Metadata can be used to store both information that a user can change, and also information they can’t; the latter giving you the capability of associating, for example, a user profile with records in your existing systems without modifying existing implementation.\n\nFor users who forget their passwords or who are allowed to change their password via some existing self-service mechanism (or self-service mechanism you have planned), you can leverage Auth0-provided [Password Reset](#password-reset) functionality. This can be integrated with your existing implementation and comes already incorporated with any out-of-box Auth0 UI widgets including [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n\nYou’ll also want to make sure that you are working with a [verified user account](#account-verification) at all times. Auth0 provides out-of-box mechanisms for doing that too. You should also consider [regulatory compliance](https://auth0.com/docs/secure/data-privacy-and-compliance) such as ([GDPR](https://eugdpr.org/) which has very specific requirements when it comes to protecting EU citizens from privacy and data breaches.\n\nThough Auth0 doesn’t currently provide a centralized profile management portal out-of-the-box, for the purpose of self-serviced profile management, you can use the Auth0 Management API to build your own or utilize an already built UI. See our Auth0 [community guidance](https://community.auth0.com/t/how-to-allow-the-end-user-to-update-their-own-profile-information/6228) which describes the Management API endpoint. All calls to the Management API will require use of an [Access Token](https://auth0.com/docs/secure/tokens/access-tokens).\n\nAlternatively, you can use the Auth0 Dashboard to [manage aspects of a user’s profile](https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-dashboard). Managing a user’s profile via the Auth0 Dashboard is more of an administrative provision and **should not** be used for self-serviced profile management in a production environment. However, the interface provided by the Dashboard can be extremely useful during development as it provides a quick and simple way of manipulating a user’s profile information.\n\n## Metadata\n\nIn addition to the Normalized User Profile information, metadata can be stored in an Auth0 user profile. Metadata provides a way to store information that did not originate from an identity provider, or a way to store information that overrides what an identity provider supplies.\n\n### Best Practice\n\nUse of Metadata should follow Auth0 [user data storage best practices](https://auth0.com/docs/best-practices/user-data-storage-best-practices#metadata). Metadata storage is not designed to be a general purpose data store, and you should still use your own external storage facility when possible. Metadata size and complexity should also be kept to a minimum, and the Auth0 Management API has a strict set of guidance when it comes to updating and/or deleting metadata associated with a user.\n\nYou can manipulate metadata via both the Auth0 Management API and the Auth0 Authentication API. As is the case when managing the Normalized User Profile, calls to the Management API for manipulating Metadata requires use of an [Access Token](https://auth0.com/docs/api/management/v2/tokens).\n\n### User metadata\n\nUser metadata (also referred to as `user_metadata`) is information that can be stored against a user profile and that a user can read and update as part of any self-service profile management. Metadata of this nature may be something like salutation for a user, or a user’s preferred language which could be used to [customize the emails](https://auth0.com/docs/customize/email/email-templates) sent by Auth0.\n\n### Best Practice\n\nStore any information that you want use to customize Auth0 emails in metadata and preferably `user_metadata` if the user is allowed to change it, such as information used to determine the language for an email.\n\n### App metadata\n\nApp metadata (also referred to as `app_metadata`) is, on the other hand, information that can be stored with a user profile but can **only be read or updated with appropriate authorization**; `app_metadata` is not directly accessible to a user. This type of metadata could be something like a flag to indicate that the last set of valid terms and conditions was accepted by the user, and a date to indicate when the user accepted them.\n\n## Password reset\n\nFor users who forget their passwords or who are allowed to change their password via some existing self-service mechanism, Auth0 provides [Password Reset](https://auth0.com/docs/connections/database/password-change) functionality. You can integrate this with your existing implementation and comes already incorporated with out-of-the-box Auth0 UI widgets included as part of [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n\nAuth0 Universal Login provides built-in UX support for password reset using Auth0 Authentication API functionality. Alternatively, you can use the [Auth0 Authentication API](https://auth0.com/docs/connections/database/password-change#use-the-authentication-api), through one of the Auth0 SDKs appropriate to your development environment. Email templates used during password reset workflow can also be fully customized, whether you use Auth0 out-of-box UI widgets or customized Universal Login.\n\nYou can use the Auth0 Management API, on the other hand, to [directly change the password](https://auth0.com/docs/connections/database/password-change#directly-set-the-new-password) for a user identity defined using a Database Connection type. You can use the Auth0 Management API as part of any self-service profile management implementation, and also as part of any [Change Password page customization](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/branding).\n\n## Account verification\n\nYou’ll also need to work with a verified user account at all times and make use of the mechanisms Auth0 provides. You should also consider regulatory compliance like [GDPR](https://eugdpr.org/) which has very specific requirements for protecting EU citizens from privacy and data breaches.\n\nAuth0 provides out-of-box functionality for sending a [verification email](https://auth0.com/docs/customize/email/manage-email-flow) to a user's email address to verify their account. By default, Auth0 automatically sends verification emails for any [Database Connection](https://auth0.com/docs/connections/database) identity created as part of [self sign-up](https://auth0.com/docs/architecture-scenarios/b2c/provisioning#self-sign-up). However, Auth0 also provides a [Management API endpoint](https://auth0.com/docs/api/v2#!/Tickets/post_email_verification) that you can use to send verification emails in cases where email address validation is not performed by a Social Provider upon user registration.\n\n## Blocking users\n\n[Blocking user access](https://auth0.com/docs/manage-users/user-accounts/block-and-unblock-users) in Auth0 provides a way to prevent user login to applications under certain conditions. By default, the Auth0 Dashboard provides an out-of-the-box mechanism to give administrators the ability to both block and unblock user access to all applications, and you can implement this functionality via use of the [Auth0 Management API](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id). You can also use Auth0 extensibility to [disable user access to certain applications](https://auth0.com/docs/manage-users/user-accounts/manage-user-access-to-applications) as well as provide more fine-grained [access control](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/authorization).\n\nIn addition, the Auth0 Management API provides you with the ability to [unblock](https://auth0.com/docs/api/management/v2#!/User_Blocks/delete_user_blocks_by_id) users disabled due to excessive use of incorrect credentials.\n\n## Linking user accounts\n\nBy default, there is one [user profile](https://auth0.com/docs/videos/get-started-series/learn-user-profiles) (user account) for each user identity. If you enable login from multiple identity providers - via Facebook or Google [social authentication](https://auth0.com/docs/architecture-scenarios/b2c/authentication#social-authentication) as well as via Auth0 [username and password authentication](https://auth0.com/docs/architecture-scenarios/b2c/authentication#username-and-password-authentication) - then each will have a separate user profile. You can use Auth0’s functionality for [linking user accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking) to create one profile for a user as an aggregate of all their associated identities.\n\nThe process of linking accounts merges user profiles in pairs: a primary account and a secondary account must be specified in the linking process. The number of accounts that can be linked, however, extends beyond a single pair. For example, you can use an account which already has multiple accounts merged with it as the primary, and link an additional secondary account to it. This means that one user account can have multiple identities associated with it, which provides a number of advantages:\n\n*   Users can log in using multiple identities without creating a separate profile for each one.\n    \n*   Registered users can use new login identities, but continue using their existing profile.\n    \n*   Users can carry their profile around, irrespective of which identity they use for login.\n    \n*   Users can link to an account with more identity information in order to provide a more complete profile.\n    \n*   Your applications can retrieve connection-specific user profile data.\n    \n\n## De-provisioning\n\nYour application may need to support a user’s request to remove their account (for example, you might need to meet [GDPR](https://eugdpr.org/) requirements). You can implement such a feature, along with a number of other profile-related functions, using the [Management API](https://auth0.com/docs/api/management/v2#!/Users). The Management API allows you to retrieve information stored about a user and update it as required.\n\nAuth0 is capable of supporting various privacy-related requirements including the display of links to consent notices on signup and data protection to support the rights of users to view and correct data you’ve collected about them.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Profile Management (B2C)",
  "description": "User profile management planning considerations for your B2C IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/authorization",
  "markdown": "# Authorization (B2C)\n\nLet's start by taking a step back and talking about Access Control. There isn't one clear cut definition of Access Control in the industry, but if you spend some time searching and reading you'll see that most authoritative sources agree that it is the umbrella concept that puts all of Authentication, Authorization, Consent, and Policy Enforcement together to ensure that only the right people and services have access to your applications and APIs. Next, let's look more closely into the distinctions between Authentication, Authorization, Consent, and Policy Enforcement. Your Auth0 tenant (your Authorization Server) is typically responsible for Authentication and Consent, and some or all of Authorization and Policy Enforcement. Additionally, an Application or API itself almost always is the primary enforcer of policies, especially where contextual access is required:\n\n*   **Authentication**: the process of determining if a principal (a user or application) is who or what they say they are.\n    \n*   **Authorization**: the process of determining what is allowed, based on the principal, what permissions they have been given, and/or the set of contextually specific access criteria.\n    \n*   **Consent**: what permissions the user (Resource Owner) has given permission to an application to do on its behalf. This is generally a requirement of delegated authorization. The user has to give permission to the Client to access the user's data in a different system.\n    \n*   **Policy Enforcement**: The act of enforcing the policies of the application or API, rejecting or allowing access based on a user's authentication and/or authorization information.\n    \n\nIn general we typically group different types of access control into three distinct categories so that it's easier to understand a) which actor is responsible for storing the information, b) which actor is responsible for making decisions, and c) which is responsible for enforcing the restrictions.\n\n*   The first category is where access is either granted or denied to an application or an API in its entirety. Both the data required to enforce this and the enforcement process is typically defined in the context of the Authorization Server For example, by using [`app_metadata`](https://auth0.com/docs/manage-users/user-accounts/metadata) associated with a user and a [Rule](https://auth0.com/docs/customize/rules) defined in your Auth0 tenant.\n    \n*   The second category is where access is either granted or denied to a specific subset of application or API functionality. The data required to enforce this is typically stored in the Authorization Server For example, by using `app_metadata` on a user in your Auth0 tenant with the enforcement process performed in the application or API itself. In this scenario, the data is typically communicated as one or more custom claims in an [`id`](https://auth0.com/docs/secure/tokens/id-tokens) or [`access`](https://auth0.com/docs/secure/tokens/access-tokens) token.\n    \n*   The third category is where access is either granted or denied depending on what the principal (subject) can operate on within the context of an application or API. Both the data required to enforce this, and the enforcement process is typically defined in the context of the application or API. In this scenario, the data communicated as one or more custom claims in an `id` or `access` token may be consumed with or without data from an external source that is not Auth0.\n    \n\nIn addition, Role-based Access Control (RBAC) and Attribute-based Access Control (ABAC) mechanisms can be applied in any of the Access Control categories described above. Whatever your use case then, there are a number of things you will want to consider when looking at the functionality and workflow you require:\n\n*   Are there scenarios where access to an entire application or API should be rejected?\n    \n*   Will you be providing APIs that can be accessed by third-party applications?\n    \n*   Will your APIs also be accessed by your own (first-party) applications?\n    \n*   Will your application be calling a third-party API?\n    \n*   Should your applications and/or APIs be enforcing access control based on user claims?\n    \n\nAuth0 supports access restriction for either applications or APIs based on certain conditions. In certain scenarios, you may want to create a Rule that returns an `UnauthorizedError` when, for example, a user attempts access to an application or an API at an incorrect time (as described in this [example](https://auth0.com/docs/authorization/sample-use-cases-rules-with-authorization#allow-access-only-on-weekdays-for-a-specific-application)) - or if the user doesn’t have the right claim(s) contained in their `app_metadata`. For an application using [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol), this would prevent the allocation of the [ID Token](https://auth0.com/docs/secure/tokens/id-tokens) used to authorize access. Similarly, for an API, allocation of any OAuth2 [Access Token](https://auth0.com/docs/secure/tokens/access-tokens) (used when calling the API), could be prevented as described in this [example](https://auth0.com/docs/authorization/sample-use-cases-rules-with-authorization#deny-access-to-anyone-calling-an-api).\n\n### Best Practice\n\nIn the main, we have found that [OIDC](https://auth0.com/docs/protocols/oidc) is the most commonly used industry-standard protocol used by Auth0 customers when it comes to authentication in their applications. We have also found that, even though [OAuth2](https://auth0.com/docs/protocols/oauth2) was created as a delegation protocol, it is commonly used within first party applications when there is an API that does not have a shared session with the application.\n\nAuth0 also can provide the information needed so that an application can enforce restrictions. For [application level integration](#application-integration), Auth0 allows you to add [custom claims](#id-token-claims) to an ID Token, which your application can then verify and subsequently use to perform policy enforcement. In this case you will need to decide what information you require for your application to make enforcement decisions. If you need to make decisions at an API instead of in your application, you will likely need to use an Access Token instead of an ID token. Continue reading for more information.\n\nFor [API level integration](#api-integration), Auth0 supports both [custom claims](#access-token-claims) as well as [scope](#access-token-scopes) re-configuration, both within the context of an Access Token. Again, you will need to decide what information will be required in order for your API to make access decisions, and your API will need to enforce that by validating the contents of the Access Token.\n\n### Best Practice\n\nWhen deciding whether you should use permissions through custom claims or scopes, you should make sure you understand the nature and purpose of scopes. There is a nice [blog post](https://auth0.com/blog/on-the-nature-of-oauth2-scopes/) on that which is easy to read and helps clear up the topic.\n\n## Application integration\n\nIn this scenario, your Auth0 tenant provides a token as an indicator of authorized access to an application. For applications utilizing [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol), the industry-standard protocol we typically find most utilized when it comes to customer facing applications, this would be an ID Token expressed as a [JWT](https://auth0.com/docs/secure/tokens/json-web-tokens).\n\n### ID Token claims\n\nUsing Rule extensibility, Auth0 allows you to easily [add custom claims to an ID Token](https://auth0.com/docs/scopes/sample-use-cases-scopes-and-claims#add-custom-claims-to-a-token) based on, for example, a user’s [Metadata](https://auth0.com/docs/manage-users/user-accounts/metadata) content. Your application can then verify the ID Token for the necessary claims, and either allow or prevent access to certain functionality as required. Note that though the process of adding custom claims via Rule is streamlined, the Rule engine is flexible and allows you to write custom code that may have negative effects. Therefore it’s important to follow our [rules best practice](https://auth0.com/docs/rules-best-practices) guidance anytime you use this extensibility feature.\n\n### Best Practice\n\nWhen you are considering adding custom claims, we recommend that you store any access control data you may need to include within claims as part of the user's [`app_metadata`](https://auth0.com/docs/users/concepts/overview-user-metadata). Firstly, this prevents you from needing to call an external API to fetch the data, which can negatively impact the performance and scalability of the login sequence. Secondly `app_metadata` **cannot** be modified by a user - so the user cannot directly circumvent any access control restrictions by modifying their own metadata. Also remember to check out our [metadata best practices](https://auth0.com/docs/architecture-scenarios/b2c/profile-management#metadata) guidance too.\n\n### ID Token scopes\n\n[OIDC Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes) are typically used by an application to obtain consent for authorized access to a user's details during authentication. Each of the pre-defined scopes returns the set of standard claims where defined, and as described in the [OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). The scopes an application requests depend on which user attributes the application needs. Once the requested scopes are authorized by the user, the claims are returned in the ID Token and are also made available via the [/userinfo](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n\n## API integration\n\nIn this scenario your Auth0 tenant can provide an OAuth2 [Access Token](https://auth0.com/docs/secure/tokens/access-tokens), typically expressed as a [JWT](https://auth0.com/docs/secure/tokens/json-web-tokens), which can be used by your API to restrict access to certain parties. In addition, Auth0 provides support for what is notionally described as both [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications).\n\nActing as the authorization server, and with the consent of the user (the resource owner), your Auth0 tenant can be used to provide an Access Token - typically expressed as a [JWT](https://auth0.com/docs/secure/tokens/json-web-tokens) - to an application (client) so that it can access a protected resources hosted by a resource server on behalf of the resource owner. The issued Access Token is typically passed as the Bearer token in the HTTP Authorization header sent to an API.\n\nWhether you have a single API, or perhaps a suite of logically related [microservice APIs](https://auth0.com/docs/get-started/apis/set-logical-api), you can leverage the Access Tokens that Auth0 provides in order to secure access to your service(s). Though relatively easy to set this up in the [Auth0 Dashboard](https://manage.auth0.com/) or through the [Auth0 Management API](https://auth0.com/docs/api/management/v2#!/Resource_Servers/post_resource_servers), it's important to review the different application scenarios and API layouts to determine the best architecture for your system.\n\nOAuth2 was designed specifically with third-party access in mind, For example, a scenario might be that a user (resource owner) wants to use an application (a client) that does not belong to the same organization as the service that provides the user's data (the reseource server). In this case, when the application needs to access data that the user owns, it redirects to the organization where the user’s data resides, which in turn authenticates the user and then prompts the user to give the application permission to access their data. This prompting for permission is referred to as providing [consent](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications) and is a large part of what providing support for [third party applications](https://auth0.com/docs/scopes/api-scopes#example-an-api-called-by-a-third-party-application) entails. If you are planning to integrate third-party applications, then it's important you mark them as third-party early on so that Auth0 will handle prompting for user consent.\n\nOn the other hand, if your organization owns the application(s), the user data itself and the API(s) through which that data is accessed, then consent is not typically required as the interactions are all [first-party](https://auth0.com/docs/scopes/api-scopes#example-an-api-called-by-a-first-party-application). If you're only creating first-party applications, then you can ensure that you are not presenting your users with any unnecessary consent screen(s) by [allowing user consent to be skipped](https://auth0.com/docs/get-started/apis) as part of any resource service definition.\n\nAlternatively, you may have data relating to a user for which additional [functionality is provided](https://auth0.com/docs/scopes/api-scopes#example-an-api-called-by-a-back-end-service) and for which explicit user consent cannot be obtained (i.e. there is no authenticated user who can provide it). In this scenario, a [list of applications for which Client Credentials grant is enabled](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) can be defined.\n\n### Access Token claims\n\nAs is the case with ID Tokens, you can [add custom claims to Access Tokens](https://auth0.com/docs/scopes/sample-use-cases-scopes-and-claims#add-custom-claims-to-a-token) using Auth0 Rule extensibility. Once added, your API can then verify an Access Token for the necessary claims and either allow or prevent access to certain functionality as required.\n\n### Best Practice\n\nWhen you are considering adding custom claims, we recommend that you store any access control data you may need to include within claims as part of the user's [`app_metadata`](https://auth0.com/docs/users/concepts/overview-user-metadata). Firstly, this prevents you from needing to call an external API to fetch the data, which can negatively impact performance and scalability. Secondly `app_metadata` **cannot** be modified by a user - so the user cannot directly circumvent any access control restrictions by modifying their own metadata. Also remember to check out our [metadata best practices](https://auth0.com/docs/architecture-scenarios/b2c/profile-management#metadata) guidance too.\n\n### Access Token scopes\n\n[OAuth2 Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes) are typically used as the mechanism by which an API can determine what actions can be performed on behalf of a user. Scopes can be added on a per API basis to [define specific access permissions](https://auth0.com/docs/get-started/apis/add-api-permissions) in the Auth0 Dashboard or through the Auth0 Management API). Scopes can also be manipulated via Auth0 extensibility (e.g. via a Rule, as in this [example](https://auth0.com/docs/architecture-scenarios/spa-api/part-2#create-a-rule-to-validate-token-scopes)). The scopes an application requests for accessing an API should depend on what functionality the application needs the user to give permission for the application to use. Once the requested scopes are authorized, they will be returned in the Access Token which can be subsequently [verified by said API](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens). A good example of this is when you log in to an application that is using a social provider for login: the social provider API requires that the application specifies whether the user will want the application to post items on your behalf. This allows the user to accept or deny this request. This example demonstrates how the user is delegating permission to the application - which is different than the API restricting access based on a user's role, and should be handled differently.\n\n### Best Practice\n\nEven though you have the ability to fully manipulate Access Token Scopes via Auth0 extensibility, as a security best practice you should only remove scopes which are not authorized and refrain from adding scopes that were not requested.\n\nThough scopes are often used as a way to enforce access permissions for a user, there are situations where it can become [tricky when you use them in this manner](https://auth0.com/blog/on-the-nature-of-oauth2-scopes/). We therefore recommend that you use scopes for their intended purpose (i.e. delegating permission to an application) and use [custom claims](#access-token-claims) for your role-based or other access control scenarios.\n\n[Fine Grained Authorization](https://docs.fga.dev/fga-concepts) allows you to grant individual users access to a specific resource or object based on:\n\n*   A user's role within an organization, such as `editor` or `admin`\n    \n*   An attribute of the user or object, such as `manager` for a user or `marketing` for an object\n    \n*   A relationship between a user and an object, such as a user with view access to a parent folder also has view access to the child folder\n    \n\nWith FGA, you can create an authorization model to determine what relationship you want to determine user access.\n\n## Role Based Access Control (RBAC)\n\nAuth0 has out-of-box support for Role Based Access Control ([RBAC](https://auth0.com/docs/manage-users/access-control/rbac)). RBAC refers to assigning permissions to users based on their role within an organization, and provides for simpler access control by offering a more manageable approach that is less prone to error.\n\n## Machine-to-Machine (M2M) Authorization\n\nThere are many scenarios that require an application without any user-interactive session to obtain an access token in order to call an API. In such scenarios you must authenticate the client instead of the user, and OAuth 2 provides the [client credentials](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) grant type to make this easy to achieve. Some common examples of where this is required include:\n\n*   A cron job or other service that needs to communicate with your API (e.g. where a daily report needs to be generated and emailed it to an administrator).\n    \n*   A separate API the supports privileged access (e.g. the API is not exposed to users directly, but instead to a backend only).\n    \n*   In certain microservice architectures, where some API layers need to communicate to other API layers without a user involvement, or after a user token has expired.\n    \n*   A privileged API that may need to be called before a user has authenticated (i.e. from a rule or custom DB script in your Auth0 tenant)\n    \n\n### best practice\n\nTraditionally, a special \"service account\" would have been created in order to cater for these scenarios: a user with a username and password that was configured for services which supported non-interactive use cases. That is no longer a recommended approach for many reasons, and the current best practice is to use [OAuth 2.0 Client Credentials Grant](https://auth0.com/docs/flows/concepts/client-credentials) in these situations.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Authorization (B2C)",
  "description": "User authorization and related planning considerations for your B2C IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/logout",
  "markdown": "# Logout (B2C)\n\n[Logout](https://auth0.com/docs/authenticate/login/logout) is the act of terminating an authenticated session when it's no longer needed, thus minimizing the likelihood that unauthorized parties can \"take over\" the session. This is typically achieved by provisioning a logout option on the user interface you provide to your users. Multiple types of sessions can be created when a user logs in (e.g., local application sessions, Auth0 session, third-party Identity Provider sessions), and you will need to determine which of these sessions need to be terminated when the user clicks any **Logout** option.\n\n### Best Practice\n\nYour logout behavior should make it clear to a user which session(s) are being terminated, and ideally, will display a visual confirmation of logout afterward.\n\nWhen configuring logout behavior, you'll need to consider:\n\n*   Which sessions should be terminated when the user initiates logout?\n    \n*   What information should you provide to users as confirmation of the sessions terminated?\n    \n*   Where should users be redirected to after logout completes?\n    \n*   How long do you want sessions to last in the event that users do not trigger the logout process?\n    \n\nGiven the varying types of sessions that can be created whenever a user logs in, there are several types of logout possible. Local application logout ends the session with the application, whereas Auth0 logout [terminates the Auth0 session](https://auth0.com/docs/logout/guides/logout-auth0). If you have organizations that are using their own IDP, you may want to consider a [Federated Logout](https://auth0.com/docs/architecture-scenarios/implementation/b2c/b2c-logout#federated-logout) strategy and implement accordingly. Global, or [Single Logout](https://auth0.com/docs/logout/guides/logout-applications) (SLO), ends the Auth0 session and also sends a logout request/notice to applications relying on the Auth0 session.\n\nThe functionality provided by your application, as well as your use of features like [Single Sign-on (SSO)](https://auth0.com/docs/sso), will inform your decision as to what type of logout is required and what visual confirmation you'll need to provide to your users. Regardless of which option you choose, the logout process you implement should make it clear to the user which sessions are being terminated, and also when the logout process has completed.\n\n## Where to send users after logout\n\nOnce your user logs out, they will be redirected to a specific location of your choosing. This location is specified as the **logout redirect URL**, and you can [define this as a parameter](https://auth0.com/docs/logout/guides/redirect-users-after-logout) via the Auth0 Dashboard.\n\nThe URL(s) you use to redirect users after logging out must be [allowlisted in the Dashboard](https://auth0.com/docs/logout#redirect-users-after-logout) to mitigate open-redirect security vulnerabilities. You can allowlist them at the tenant or application levels.\n\n## Automatic termination of sessions\n\nNot all users will trigger the logout process manually, so Auth0 also provides **session timeout** to prevent overly long-lived sessions. This setting is [available and configurable via the Auth0 Dashboard](https://auth0.com/docs/dashboard/reference/settings-tenant#login-session-management).\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Logout (B2C)",
  "description": "User logout planning considerations for your B2C IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/operations",
  "markdown": "# Operations (B2C)\n\nOperationalization requires configuring or setting up infrastructure to support the scalable, measurable, and quantifiable operation that’s necessary for business continuity. In Auth0, this includes configuring supporting services (such as email providers), monitoring services for your deployment, detecting anomalous situations, and making preparations to recover quickly and smoothly when something goes wrong in a production environment.\n\nEstablishing effective operational behaviors is something that successful customers have found pays dividends, and there are a number of things you will want to consider when looking at your workflow:\n\n*   What should you do to proactively detect failures?\n    \n*   How can you obtain data on Auth0’s operational status?\n    \n*   What should you do about Auth0 security bulletins related to the Auth0 service?\n    \n*   Does Auth0 provide information regarding impending changes in the Auth0 service?\n    \n*   How can you check for important notices from Auth0?\n    \n*   What should you do with Auth0 log data so that you can analyze it and keep it for longer than Auth0’s limited data retention period?\n    \n*   How can you scan Auth0 logs to determine if peak loads in your application trigger any rate limits or other errors?\n    \n*   What email services should you use to support production volumes of email messages to users? Can I use Auth0's out-of-box email provider in my production environment?\n    \n*   Do you need to configure your firewall and what firewall ports will you need to open for internal services that need to receive communications from Auth0 (such as custom databases, web services, and email servers)?\n    \n\nAuth0 supports functionality for [monitoring](https://auth0.com/docs/architecture-scenarios/implementation/b2c/b2c-operations#monitoring) Auth0 service operation as well as providing information regarding Auth0 [service status](https://auth0.com/docs/architecture-scenarios/implementation/b2c/b2c-operations#service-status). In addition, Auth0 makes security-related bulletins as well as information regarding upcoming changes to the Auth0 service available via various [notifications](https://auth0.com/docs/architecture-scenarios/implementation/b2c/b2c-operations#notifications). Auth0 [logging](https://auth0.com/docs/architecture-scenarios/implementation/b2c/b2c-operations#logging) services also provide extensive functionality for tracing and identifying operational anomalies, including restrictions encountered due to rate limiting and/or excessive loading.\n\nOut-of-box, Auth0 provides email delivery services to help you accelerate your integration. These services, however, are not meant for scale-of-use in production environments, and do not provide for any specific service level or guarantee when it comes to email delivery. Our best practice recommendation, which customers typically follow, involves configuring your own [email service provider](https://auth0.com/docs/architecture-scenarios/implementation/b2c/b2c-operations#email-provider-setup).\n\nYou may also need to make changes to [infrastructure](https://auth0.com/docs/architecture-scenarios/implementation/b2c/b2c-operations#infrastructure) configuration in order to support integration with Auth0 and to support use of Auth0 extensibility. For example, if you need to provide callbacks to your internal or even external infrastructure (e.g., if you need to make external API calls in Actions, Rules, or Hooks, or via custom database scripts if you need to leverage existing legacy identity storage), then you may need to configure your Firewall settings.\n\n## Service status\n\nThe Auth0 [status dashboard](https://status.auth0.com/) together with the Auth0 [uptime dashboard](http://uptime.auth0.com/) shows current and past status of the Auth0 service in a human-readable format. If any monitoring alerts are triggered, and as a first step in troubleshooting, your operations staff should check the status dashboard to see if there is a current outage. The public cloud status page also provides a facility for subscribing to outage notifications, and we also recommend that you check the status of any third-party [external services](https://auth0.com/docs/deploy-monitor/monitor/check-external-services-status) you depend on, such as Social Providers. Having this information handy can help quickly eliminate possible causes when troubleshooting an issue and should be at the top of a troubleshooting checklist for developers as well as the help desk staff.\n\n### Best Practice\n\nInformation on how to check the status of Auth0 as well as any dependent services (such as Social Providers) should be at the top of a troubleshooting checklist for both developers and helpdesk staff, and we recommend you subscribe via the Auth0 status page to set up notification of any status updates.\n\nIn the event of an outage to the public cloud service, Auth0 performs a Root Cause Analysis (RCA) and publishes the results on the Auth0 status page. Auth0 performs a thorough investigation after an outage—including a determination of root cause, as well as contributing factors and how to prevent the issue from occurring again—and as a result, an RCA document can take a few weeks to be published.\n\n## Email provider setup\n\nAuth0 sends [emails](https://auth0.com/docs/customize/email) to users for events such as signup welcome, email validation, breached password, and password reset events. You can customize the email templates for each type of event, and advanced customization of email handling is also possible. Auth0 provides a test email provider with limited capacity for basic testing, but you must set up your own email provider for production use, and customization of email templates will not work until you have established your own provider.\n\n### Best Practice\n\nThe default Auth0 email provider does not support sending production volumes of email or customization of email templates. You should therefore configure your own email provider before deploying to production.\n\n## Infrastructure\n\n### Firewalls\n\nIf custom code executing in Auth0 (such as in an Action, Rule, Hook, or custom database scripts) will call a service inside your network, or if you configure an on-premise SMTP provider in Auth0, then you may need to configure your firewall to allow [inbound traffic from Auth0](https://auth0.com/docs/secure/security-guidance/data-security/allowlist). The IP addresses to allow through the firewall are specific to each region and are listed on the Rules, Hooks, custom database scripts, and email provider configuration screens in your Auth0 dashboard.\n\n## Logging\n\nAuth0 provides extensive capability when it comes to the logging of events, and also in the scanning of logs in order to identify event anomalies (see [logs documentation](https://auth0.com/docs/deploy-monitor/logs) for further details). Standard log retention period for Auth0 logs is determined by subscription level with the shortest period being 2 days and the longest period being only 30 days. Leveraging Auth0 support for integrating with external logging services will allow you to retain logs outside of this, and will also provide for log aggregation across your organization.\n\n### Best Practice\n\nYou should leverage one of the log streaming solutions to send log data to an external log analytics service. This will enable keeping data for longer periods of time and provide advanced analytics on the log data.\n\nYou should review the log data [retention period](https://auth0.com/docs/deploy-monitor/logs/log-data-retention) for your subscription level, and implement a log data export extension to send log data to an external log analytics service. You can use one of our [log streaming solutions](https://marketplace.auth0.com/features/log-streaming) in Auth0 Marketplace.\n\nDevelopment teams can use log files for troubleshooting and detecting intermittent errors that may be hard to find via QA tests. Security teams will probably want log data in case forensic data is ever needed. Exporting log files to services that provide comprehensive analytics can help you see patterns such as usage trends and attack protection triggers.\n\n### Rate limits and other errors\n\nAuth0 provides a unique error code for errors reported when the [rate limit is exceeded](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy). You should set up automatic scanning of logs to check for rate limit errors so you can proactively address activity that hits rate limits before it causes too much trouble for your users. Auth0 also publishes error codes for other types of errors, and you will find it helpful to scan logs for [authentication errors](https://auth0.com/docs/libraries/common-auth0-library-authentication-errors) as well as errors from Auth0 Management API calls (Management API error codes are shown below each call in the [Management API Explorer](https://auth0.com/docs/api/management/v2)).\n\n### Best Practice\n\nCalling the Management API to retrieve user profile information from within a Rule is a common cause of rate limit errors because such API calls can execute for every login as well as periodic session checks.\n\n## Monitoring\n\nYou should establish mechanisms for [monitoring Auth0 implementations](https://auth0.com/docs/deploy-monitor/monitor), so your support or operations team receives the timely information needed to proactively handle service outages. Auth0 provides monitoring endpoints that can be incorporated into your monitoring infrastructure. These endpoints are designed to provide a response suitable for consumption by monitoring services. It should be noted that they only provide data on Auth0. For complete end-to-end monitoring, which is essential for checking the ability of users to log in, we recommend that you set up synthetic transaction monitoring. This will provide greater granularity for your monitoring and enable you to detect outages unrelated to Auth0 as well as degradation of performance, so you can respond more proactively.\n\n### Best Practice\n\nYou should set up the ability to send synthetic login transactions to facilitate end-to-end monitoring of authentication. You can do this with a simple application that uses the [Resource Owner Password Grant](https://auth0.com/docs/api-auth/tutorials/password-grant) in combination with a test user that has no privileges, and don’t forget about [Auth0 rate limiting policies](https://auth0.com/docs/policies/rate-limits) too.\n\n## Notifications\n\nThere are several different types of notifications from Auth0 that you should watch for as they contain important information that could impact your tenant(s) and project.\n\n### Dashboard notifications\n\nFrom time to time, Auth0 may send an important announcement related to your tenant. These announcements about your service will be sent to your Auth0 dashboard and depending on the severity of the announcement, via email to the registered Auth0 dashboard administrators. You should make a regular practice of logging in to the dashboard and checking the bell icon at the top for any important notices. In addition, you should review emails from Auth0 in a timely fashion as they may convey important information about changes or actions you need to take.\n\n### Auth0 security bulletins\n\nAuth0 regularly conducts a number of security-related tests, and if any issues are found, will proactively identify and notify customers who need to make security-related changes. Due to the extensible nature of the Auth0 product, however, it may not be possible for Auth0 to identify every impacted customer, so you should regularly check Auth0 [security bulletins](https://auth0.com/docs/secure). Check with your Technical Account Manager to make sure security contacts for your organization are up to date.\n\n### Best Practice\n\nIt is a best practice to check the Auth0 [Security Bulletins](https://auth0.com/docs/security/bulletins) page periodically and take the recommended action if you are impacted by any security bulletins.\n\n### Change log\n\nAuth0 provides information on changes to the service in the Auth0 [change log](https://auth0.com/changelog). You should make a regular practice of reviewing Auth0 change logs to be aware of changes. Support teams researching an issue may find it useful to review the change log to determine if recent changes might be related, especially if these are [breaking changes](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations). Development teams will also want to review the change logs to identify new features that may be beneficial.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Operations (B2C)",
  "description": "How to operationalize your Auth0 tenant environments.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/launch",
  "markdown": "# Launch Preparation (B2C)\n\nUse this guide as you prepare for the launch of your application. We’ve included reminders about some content you may have viewed earlier during your planning or development phases as well as some new content unique to the launch phase. The sections below are useful to developers and project owners to ensure that you have everything lined up for a smooth launch. There are several things to check so it may help to assign ownership of different sections to different members of your team.\n\n*   [Tenant Check](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/launch/tenant-check): Tenant Checks to perform before launch of your B2C IAM implementation.\n    \n*   [Testing Complete](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/launch/testing): Testing preparation for the launch of your B2C IAM implementation.\n    \n*   [Operations Readiness](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/launch/operations-readiness): Operations checks to perform before launch of your B2C IAM implementation.\n    \n*   [Compliance Readiness](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/launch/compliance-readiness): Compliance checks to perform before launch of your B2C IAM implementation.\n    \n*   [Support Readiness](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/launch/support-readiness): Support readiness for the launch of your B2C IAM implementation.\n    \n*   [Launch Day Preparation](https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer/launch/launch-day): Launch preparation considerations for your B2C IAM implementation.\n    \n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)",
  "title": "Launch Preparation (B2C)",
  "description": "Launch preparation considerations for your B2C IAM implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock/v11/ui-customization",
  "markdown": "# Lock UI Customization\n\nYou can customize the appearance of your Lock widget in a few different ways. The best and safest way to do so is with the provided JavaScript options.\n\n## JavaScript Options\n\nYou can set up a variety of customizations to your Lock via the `options` parameter when you instantiate your Lock. Some of them allow you to customize your UI. The UI customization options are a work in progress - we expect to be adding more as we go.\n\nFirst, you'll define the `options` object, containing whichever options you're wanting to customize. Then you'll need to include that options object as the third parameter when you instantiate Lock; more on that below.\n\n### Theming Options\n\nThere are a couple of theming options currently available, namespaced under the `theme` property.\n\n#### logo {String}\n\n![Lock UI customization - Logo](https://images.ctfassets.net/cdy7uua7fh8z/FdOAKKy71rTbFjIlZEL8D/2eef96008095d85388daaa461707901d/lock-theme-logo.png)\n\nThe value for `logo` is a URL for an image that will be placed in the Lock's header, and defaults to Auth0's logo. The minimum recommended resolution is 200 pixels (width) by 200 pixels (height).\n\n```\nvar options = {\n  theme: {\n    logo: 'https://example.com/logo.png'\n  }\n};\n```\n\n#### primaryColor {String}\n\n![Lock UI customization - primary color](https://images.ctfassets.net/cdy7uua7fh8z/1qQjeTmXJyIziv400VPaOn/48dd3cb8a72a6e88b2634b4b8a8bed63/lock-theme-primarycolor.png)\n\nThe `primaryColor` property defines the primary color of the Lock; all colors used in the widget will be calculated from it. This option is useful when providing a custom `logo`, to ensure all colors go well together with the `logo`'s color palette. Defaults to `#ea5323`.\n\n```\nvar options = {\n  theme: {\n    logo: 'https://example.com/logo.png',\n    primaryColor: '#31324F'\n  }\n};\n```\n\n#### authButtons {Object}\n\nAllows the customization of buttons in Lock. Each custom connection whose button you desire to customize should be listed by name, each with their own set of parameters. The customizable parameters are listed below:\n\n*   **displayName** {String}: The name to show instead of the connection name when building the button title, such as `LOGIN WITH MYCONNECTION` for login).\n    \n*   **primaryColor** {String}: The button's background color. Defaults to `#eb5424`.\n    \n*   **foregroundColor** {String}: The button's text color. Defaults to `#FFFFFF`.\n    \n*   **icon** {String}: The URL of the icon for this connection. For example: `http://site.com/logo.png`.\n    \n\n```\nvar options = {\n  theme: {\n    authButtons: {\n      \"testConnection\": {\n        displayName: \"Test Conn\",\n        primaryColor: \"#b7b7b7\",\n        foregroundColor: \"#000000\",\n        icon: \"http://example.com/icon.png\"\n      },\n      \"testConnection2\": {\n        primaryColor: \"#000000\",\n        foregroundColor: \"#ffffff\",\n      }\n    }\n  }\n};\n```\n\n### Customizing Text\n\nThe `languageDictionary` option allows customization of every piece of text displayed in the Lock. Defaults to {}. See below for an example.\n\n```\nvar options = {\n  languageDictionary: {\n    emailInputPlaceholder: \"something@youremail.com\",\n    title: \"Log me in\"\n  },\n};\n```\n\n![Customizing text in the Lock UI via languageDictionary option](https://images.ctfassets.net/cdy7uua7fh8z/iNvBLxxmea2tiWBhzwKX5/db0d7f86d0f7f95f70e5edcd34ab736f/lock-languagedictionary.png)\n\nFor a complete list of the items able to be customized using `languageDictionary`, see the [English Language Dictionary Specification](https://github.com/auth0/lock/blob/master/src/i18n/en.js) in the repository.\n\n### Instantiating Lock\n\nFinally, you'll want to go ahead and instantiate your Lock, with the `options` object that you've defined with your custom options in it.\n\n`var lock = new Auth0Lock('{yourClientId}', '{yourDomain}', options);`\n\n## Overriding CSS\n\nCustomizing your Lock by overriding its CSS isn't recommended. The issue is that with new releases of Lock, some styling may change, leading to unintended problems if you are overriding the CSS. Additionally, it's possible to simply overlook use of styles in other places and while the change may look fine in one view, it might not in another.\n\nIf you still intend to override CSS to further style your Lock, we recommend that you use a specific patch version of Lock rather than a major or minor version, so that you limit the amount of unexpected results that may occur when you alter the styles, and then another patch is deployed that might cause unexpected behavior in your UI due to the changes. This can be done by ensuring that you specify that patch version (`x.y.z`) when including Lock, or downloading it.\n\nAdditionally, we of course recommend that you test your CSS changes exhaustively, to ensure that the experience is the one you intend it to be for your customers.\n\n## Further Information\n\nIf you're looking for more detailed information while working to customize Lock for your application, check out the [configuration options](https://auth0.com/docs/libraries/lock/lock-configuration) page or the [Lock API](https://auth0.com/docs/libraries/lock/lock-api-reference) page!\n\nIf you have specific theming options that you would like to see added, let us know. We are working on improving the customization options that are available through JavaScript, and this list will be updated as new options are added.",
  "title": "Lock UI Customization",
  "description": "Customizing the appearance of your Lock widget can be important for branding and a cohesive UI, and this resource highlights the ways in which you can do so while implementing Lock in your project.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/extensions/github-deploy",
  "markdown": "loading",
  "title": "",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-1",
  "markdown": "# Solution Overview (Server Apps + API)\n\nIn order to ensure that only authorized users and applications are allowed access to the Timesheets API, ExampleCo has decided to make use of the [OAuth 2.0 authorization framework](https://tools.ietf.org/html/rfc6749). The framework provides the flexibility the company wants since the different grants can allow them to easily authorize the various types of applications which need to communicate with the Timesheets API.\n\nAn API is a way to expose functionality of your application to other applications. An application can make a request by sending a message to an endpoint on an API and receive information as a response.\n\nAn API endpoint can be secured or not. In our case, since the timesheets are sensitive information that affect reviews and payments, it is important to ensure that only authorized users and applications can call the endpoints on our API. When a client application wants to access protected endpoints on an API, it needs to present an Access Token as proof that it has the required permissions for making the call to the endpoint.\n\nAn Access Token is obtained by authenticating the user with an Authorization Server and the user can then, in turn, authorize the application to access the API on their behalf.\n\n#### What is an Access Token?\n\nAn Access Token (also referred to as `access_token`) is an opaque string representing an authorization issued to the application. It may denote an identifier used to retrieve the authorization information or may self-contain the authorization information (for example, the user's identity, permissions, and so forth) in a verifiable manner.\n\nIt is quite common for Access Tokens to be implemented as [JSON Web Tokens](https://auth0.com/docs/tokens/concepts/jwts).\n\nFor more information on Auth0 Access Tokens refer to [Access Token](https://auth0.com/docs/tokens/concepts/access-tokens).\n\nAn API can enforce fine-grained control over who can access the various endpoints exposed by the API. These permissions are expressed as scopes.\n\nWhen a user authorizes a client application, the application can also indicate which permissions it requires. The user is then allowed to review and grant these permissions. These permissions are then included in the Access Token as part of the `scope` claim.\n\nSubsequently, when the client passes along the Access Token when making requests to the API, the API can inspect the `scope` claim to ensure that the required permissions were granted in order to call the particular API endpoint.\n\n#### What are Scopes?\n\nEach Access Token may include a list of the permissions that have been granted to the client. When a client authenticates with Auth0, it will specify the list of scopes (or permissions) it is requesting. If those scopes are authorized, then the Access Token will contain a list of authorized scopes.\n\nFor example, the timesheet API may accept four different levels of authorization: reading timesheets (scope `read:timesheets`), creating timesheets (scope `create:timesheets`), deleting timesheets (scope `delete:timesheets`) and approving timesheets (scope `approve:timesheets`).\n\nWhen a client asks the API to create a new timesheet entry, then the Access Token should contain the `create:timesheets` scope. In a similar fashion, in order to delete existing timesheets, the Access Token should contain the `delete:timesheets` scope.\n\nFor more information on scopes refer to [Scopes](https://auth0.com/docs/scopes).\n\nBy using the OAuth 2.0 authorization framework, you can give your own applications or third-party applications limited access to your APIs on behalf of the application itself. Using Auth0, you can easily support different flows in your own APIs without worrying about the OAuth 2.0/OpenID Connect (OIDC) specification, or the many other technical aspects of API authorization.\n\n#### OAuth roles\n\nIn any OAuth 2.0 flow we can identify the following roles:\n\n*   **Resource Owner**: the entity that can grant access to a protected resource. Typically this is the end-user.\n    \n*   **Resource Server**: the server hosting the protected resources. This is the API you want to access.\n    \n*   **Client**: an application requesting access to a protected resource on behalf of the Resource Owner.\n    \n*   **Authorization Server**: the server that authenticates the Resource Owner, and issues Access Tokens after getting proper authorization. In this case, Auth0.\n    \n\nUsing [different grants types (or flows)](https://auth0.com/docs/api-auth/which-oauth-flow-to-use), these participants will interact to grant to the client apps limited access to the APIs you are building. As a result, the client app will obtain an Access Token that can be used to call the API on behalf of the user.\n\n## Client Credentials Grant\n\nOAuth 2 provides several grant types for different use cases. In this particular use case where a cron job will be uploading timesheets via an API, there is no interactive user (or resource owner) who grants permission to the cron job to access the API.\n\nThe cron job is also not making the API calls on behalf of any user. Instead there is a machine to machine authorization and the application (the cron job) makes calls to the Resource Server (the API) on its own behalf.\n\nFor situations like this where there is no user interaction involved, the Client Credentials Grant is ideal. With Client Credentials Grant (defined in [RFC 6749, section 4.4](https://tools.ietf.org/html/rfc6749#section-4.4)) an Application can directly request an Access Token from the Authorization Server by using its Client Credentials (a Client Id and a Client Secret). Instead of identifying a Resource Owner, this token will represent the Application itself.\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/5CfNEkbyG1ZC5BqHwi9gEs/309babf8329b165f1241f4cbc8e002ba/client-credentials-grant.png)\n\n1.  The Application authenticates with the Authorization Server using its Client ID and Client Secret.\n    \n2.  The Authorization Server validates this information and returns an Access Token.\n    \n3.  The Application can use the Access Token to call the Resource Server on behalf of itself.",
  "title": "Solution Overview (Server Apps + API)",
  "description": "Solutions Overview for the Server + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/profile-management",
  "markdown": "# Single Identity Provider: Profile Management\n\nProfile Management in Organization-based scenarios is generally the same as in other architecture scenarios. In our architecture scenarios, we provide general purpose guidance on [B2B Profile Management](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/profile-management), which we recommend reviewing alongside the guidance provided here.\n\nYour application may have an associated specific set of user attributes (for example, user preferences or identifying information you use to better serve the customer) for which you provide some sort of self-service management to users. Additionally/alternatively, you may provide self-service profile management for attributes that are typically maintained by the Identity Provider (IdP).\n\n## Database Connection\n\nAuth0 provides you with the capability to implement self-service profile management support via the Auth0 Management API. If you are using Auth0 Organizations to provide [invitation-based user provisioning](https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members), you will likely need to restrict changes to fields that are typically owned by your Auth0 Tenant as the Identity Provider (IdP). For example, you would want to restrict changes to email address because you would not want a user to use an email address other than the one to which their invitation was sent. Restricting changes to the email address field would prevent company-specific emails from going to entered personal email addresses.\n\nAlternatively, you may want to consider providing a few self-service items for users who authenticate via a Database Connection in Auth0. You may want users to be able to:\n\n*   change their email address\n    \n*   change any associated phone numbers\n    \n*   change their username \n    \n*   de-provision their accounts as part of regulatory compliance (such as GDPR)\n    \n*   perform password change processing, which we typically recommend you implement via [password reset](https://auth0.com/docs/connections/database/password-change#trigger-an-interactive-password-reset-flow) and which will typically leverage the organization-specific branding described in [Branding: Password Reset Page](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/branding).\n    \n\n## Enterprise connection\n\nBecause the upstream Identity Provider (IdP) typically handles IdP-managed user profile attributes, profile management can be fairly non-existent for this use case. However, if you use application-specific user attributes, then you may still want to provide self-service capability.\n\nIn addition, you will almost certainly want to provide an organization with a way to de-provision users from your Auth0 Tenant. Auth0 does not communicate with an upstream IdP, except when the Auth0 SSO session expires. Because an SSO session's time to expiration will likely be too long for most scenarios in which a user is deleted, an organization administrator will need a way to block or delete a user independently.\n\nIn the context of Social Connections, profile management follows a similar pattern to that associated with an [Enterprise Connection](#enterprise-connection), but the upstream IdP is associated with the social provider rather than any specific organization.\n\n## Administration\n\nIn certain situations you will want to give your customers access to manage user accounts associated with their organization. This is often true for help-desk-type scenarios in which a help desk operator may update profile information on behalf of a user or help a user unblock an account.  \n\nOut of the box, Auth0 provides the Auth0 Dashboard, which is used for general management of an Auth0 Tenant. However, you would not want to give a customer access to your Auth0 Tenant Dashboard because they would then have the ability to manage all users across all organizations, which would not be desirable.\n\nIf you already provide help-desk-type capability for your customers, then you can use the Auth0 Management API to manage user accounts in Auth0. For example, the Management API can be used to [retrieve organization members](https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-members) and [organizations to which a user belongs](https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-user-membership). If you do not already provide help desk capability, then you will need to build this functionality if you require it.",
  "title": "Single Identity Provider: Profile Management",
  "description": "Learn about user profile management for Organizations in multi-tenant architectures.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/multiple-idp-orgs",
  "markdown": "# Multiple Identity Provider Organizations\n\nIn the Multiple Identity Provider (IdP) Organizations scenario, every organization that uses the [Auth0 Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview) feature uses more than one [Auth0 Connection](https://auth0.com/docs/connections). In many ways, the implementation for this scenario is identical to the implementation for [Single Identity Provider Organizations. I](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations)n fact, the Auth0 Organizations feature supports mix and match, as well as easy transition between the two. However, you should consider a few additional items.\n\n## Connections\n\nIn addition to the information that typically is included as part of [Authorization](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/authorization), you can add details regarding the specific [Auth0 Connection](https://auth0.com/docs/connections) via which first-factor authentication for the user was performed. While not explicitly required, you can add such information to an ID Token and/or Access Token as a custom claim in order to provide your application and/or API with additional context that can be used with access control.\n\nAs illustrated in the following example, custom claims are typically added via Rule extensibility, which can access Connection specifics via use of the [`context`](https://auth0.com/docs/customize/rules/context-object) object:\n\n```\ncontext.idToken['http://travel0.net/connection'] = context.connection;     // Connection name claim\ncontext.accessToken['http://travel0.net/connection'] = context.connection; // Connection name claim\n```\n\n### Database Connection\n\nWhile Auth0 allows you to [provision](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/provisioning) multiple [Database and Custom Database Connections](https://auth0.com/docs/connections/database), we do not recommend that you associate more than one of these types of connection with an Auth0 Organization. Because Database and Custom Database Connections do not currently support Home Realm Discovery, which is a key component of [Identifier-First Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first), the Universal Login New Experience cannot select between them if more than one is defined.\n\n### Enterprise Connection\n\nIf your enterprise application uses [Enterprise Federation](https://auth0.com/docs/authenticate/enterprise-connections), you can activate [Identifier First Authentication with Home Realm Discovery](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) in its Authentication Profile. Once enabled, Home Realm Discovery detects email addresses from a known domain and automatically sends them to the proper Workforce login.\n\nTo learn more, read [Identifier First Authentication](https://auth0.com/docs/manage-users/organizations/login-flows-for-organizations#identifier-first-authentication) in [Login Flows for Organizations](https://auth0.com/docs/manage-users/organizations/login-flows-for-organizations).\n\nOther than the considerations described in the [Authentication](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/authentication) section, no additional concerns need to be addressed when Social Connections are used as part of a multiple IdP organization scenario.",
  "title": "Multiple Identity Provider Organizations",
  "description": "Learn about multiple Identity Provider (IdP) Organizations, in which every Auth0 Organization has more than one Auth0 connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations",
  "markdown": "# Single Identity Provider Organizations\n\nIn the Single Identity Provider (IdP) Organizations scenario, every organization that uses the [Auth0 Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview) feature uses exactly one Auth0 connection[](https://auth0.com/docs/manage-users/organizations/organizations-overview). This feature allows each application to select the appropriate organization defined on the Auth0 Tenant, which will either authenticate user credentials directly or forward the authentication request to the appropriate IdP to handle.\n\nIn this scenario, we’ll continue to use the [Travel0 Corporate Booking](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture) example. In this example, the corporate booking application equates to your application and Travel0 corresponds to your company.\n\n![Architecture Scenarios - Multitenancy - Diagram - Isolated users, Shared Apps, Orgs A&B](https://images.ctfassets.net/cdy7uua7fh8z/1YBaMaMozamiTv8hXmNB2D/21e9270a59021a12209bdcb4345147cb/isolated-users_shared-apps_org-ab.png)\n\nRegardless of how credentials are processed--whether user credentials are stored in a database connection (like with Hoekstra & Associates) or are validated via an enterprise connection (like with MetaHexa Bank) or a social connection--your application behaves the same way. Leveraging the [Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview) feature allows you to configure and control the experience.\n\n## Learn more\n\n*   [Single Identity Provider: Provisioning](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/provisioning)\n*   [Single Identity Provider: Branding](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/branding)\n*   [Single Identity Provider: Authentication](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/authentication)\n*   [Single Identity Provider: Authorization](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/authorization)\n*   [Single Identity Provider: Profile Management](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/profile-management)\n*   [Single Identity Provider: Logout](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/logout)",
  "title": "Single Identity Provider Organizations",
  "description": "Learn about Single Identity Provider(IdP) Organizations, in which every Auth0 Organization has exactly one Auth0 connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-2",
  "markdown": "# Auth0 Configuration (Server Apps + API)\n\nIn this section, we will review all the configurations we need to apply using the [Auth0 Dashboard](https://manage.auth0.com/#).\n\n## Configure the API\n\nClick on the [APIs menu option](https://manage.auth0.com/#/apis) on the left, and click the **Create API** button.\n\nYou will be required to supply the following details for your API:\n\n*   **Name**: Friendly name for the API. Does not affect any functionality.\n    \n*   **Identifier**: Unique identifier for the API. We recommend using a URL, but this doesn't have to be a publicly available URL; Auth0 will not call your API at all. This value cannot be modified afterwards.\n    \n*   **Signing Algorithm**: Algorithm to sign the tokens with. Available values are `HS256` and `RS256`. When selecting RS256, the token will be signed with the tenant's private key. To learn more about signing algorithms, see [Signing Algorithms](https://auth0.com/docs/tokens/signing-algorithms).\n    \n\n![Dashboard - Applications - APIs - Create API - Popup](https://images.ctfassets.net/cdy7uua7fh8z/4kIH4BQc4vDel2zhJ6lwCE/6812a7ec36119cde0fbe10801e4c0394/dashboard-apis-create_create-popup_default-empty.png)\n\nFill in the required information, and click the **Create** button.\n\n### Signing Algorithms\n\nWhen you create an API, you must select the algorithm with which your tokens will be signed. The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.\n\nTo create the signature, you must take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that. That algorithm, which is part of the JWT header, is the one you select for your API: `HS256` or `RS256`.\n\n*   **RS256** is an [asymmetric algorithm](https://en.wikipedia.org/wiki/Public-key_cryptography) which means that there are two keys: one public and one private (secret). Auth0 has the secret key, which is used to generate the signature, and the consumer of the JWT has the public key, which is used to validate the signature.\n    \n*   **HS256** is a [symmetric algorithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm) which means that there is only one secret key, shared between the two parties. The same key is used both to generate the signature and to validate it. Special care should be taken in order for the key to remain confidential.\n    \n\nThe most secure practice, and our recommendation, is to use **RS256**. Some of the reasons are:\n\n*   With RS256, you are sure that only the holder of the private key (Auth0) can sign tokens, while anyone can check if the token is valid using the public key.\n    \n*   Under HS256, if the private key is compromised you would have to re-deploy the API with the new secret. With RS256, you can request a token that is valid for multiple audiences.\n    \n*   With RS256, you can implement key rotation without having to re-deploy the API with the new secret.\n    \n\n## Configure the Scopes\n\nOnce the application has been created, you will need to configure the Scopes that applications can request during authorization.\n\nIn the settings for your API, go to the Permissions tab. In this section, you can add all four of the scopes discussed before: `batch:upload`, `read:timesheets`, `create:timesheets`, `delete:timesheets`, and `approve:timesheets`. Also add an additional scope: `batch:upload`.\n\n![Dashboard - Applications - APIs - Permissions](https://images.ctfassets.net/cdy7uua7fh8z/xxMOKezob6gNHJ0CcKhcg/4a8d4bcffc6a641ae3d0fa1416687390/dashboard-apis-edit_view-permissions.png)\n\n## Create the Application\n\nWhen creating an API in the Auth0 Dashboard, a test application for the API will automatically be generated. In the Auth0 Dashboard, navigate to the [Application Section](https://manage.auth0.com/#/applications), and you will see the test application for the Timesheets API.\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/7lnuzFgs3IuWyL4bK5aVZV/7e3925f0d0fd54cac06f0fc4f78965bb/non-interactive-client.png)\n\nGo to the settings for the application by clicking on the gear icon, and rename the application to `Timesheets import Job`.\n\nFor the cron job, you will need a Machine-to-Machine Application. The test application that was generated when the API was created was automatically configured as a Machine-to-Machine Application:\n\n## Configure Application's access to the API\n\nFinally, you must allow the application access to the Timesheets API. Go back to the configuration of the API, and select the Machine to Machine Application tab.\n\nYou will see the **Timesheets Import Job** application listed, and it should have access to API as can be seen from the switch to the right of the application name which indicates a value of `Authorized`. If it does not indicate that the application is authorized, simply toggle the value of the switch from `Unauthorized` to `Authorized`.\n\n![Dashboard - Applications - APIs - Machine to Machine Applications - Authorize](https://images.ctfassets.net/cdy7uua7fh8z/3PjvkTaoOZKWCMJol4ajCu/f9b9e8bc653848c35bdc4b75103ac81b/dashboard-apis-edit_view-m2m-applications.png)\n\nYou will also need to specify which scopes will be included in Access Tokens that are issued to the application when the application authorizes with Auth0.\n\nExpand the settings for the application by clicking on the down arrow to the far right, and you will see the list of available scopes. The cron job will only require the `batch:upload` scope as it will simply create new timesheets based on the timesheet entries in the external system.\n\nOnce you have selected the `batch:upload` scope, save the settings by clicking the **Update** button.\n\nNow that we have designed our solution and discussed the configurations needed on Auth0's side, we can proceed with the implementation.",
  "title": "Auth0 Configuration (Server Apps + API)",
  "description": "Auth0 Configuration for the Server + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-3",
  "markdown": "# Application Implementation (Server Apps + API)\n\nIn this section of the tutorial, we will take an in-depth look into our API and its associated Machine to Machine Application.\n\n## Define the API endpoints\n\nFirst, we need to define the endpoints of our API.\n\n#### What is an API endpoint?\n\nAn **API endpoint** is a unique URL that represents an object. To interact with this object, you need to point your application to its URL. For example, if you had an API that could return either orders or customers, you might configure two endpoints: `/orders` and `/customers`. Your application would interact with these endpoints using different HTTP methods; for example, `POST /orders` could create a new order or `GET /orders` could retrieve the dataset of one or more orders.\n\nWe will configure one single endpoint that will be used to create timesheet entries. The endpoint will be `/timesheets/upload` and the HTTP method will be `POST`.\n\nAs input, the API will expect a JSON object containing the timesheet information. We will use the following JSON:\n\n```\n{\n  'user_id': '007',\n  'date': '2017-05-10T17:40:20.095Z',\n  'project': 'StoreZero',\n  'hours': 5\n}\n```\n\nThe API will print the JSON, so we can verify the contents and echo back a message like the following: `Created timesheet 14 for employee 007`.\n\n### Secure the API endpoints\n\nThe first step towards securing our API endpoint is to get an Access Token as part of the Header and validate it. If it's not valid, then we should return an HTTP Status 401 (Unauthorized) to the calling process.\n\n**See the implementation in** [**Node.js**](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/api-implementation-nodejs#2-secure-the-api-endpoint)**.**\n\n#### Get an Access Token\n\nTo get an Access Token without using our application sample implementation, perform a `POST` operation to the `https://{yourDomain}/oauth/token` endpoint with a payload in the following format:\n\n```\n{\n  audience: \"YOUR_API_IDENTIFIER\",\n  grant_type: \"client_credentials\",\n  client_id: \"${account.client_id}\",\n  client_secret: \"${account.client_secret}\"\n}\n```\n\n## Check the application permissions\n\nNow we have secured our API's endpoint with an Access Token, but we still haven't ensured that the process calling the API has the rights to post a new timesheet entry.\n\nAs discussed earlier in this doc, each Access Token may include a list of the permissions that have been granted to the client. These permissions are defined using the `scope` request parameter. To learn how to configure this, see the [Configure the Scopes](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-3#configure-the-scopes) paragraph.\n\nFor our endpoint, we will require the scope `batch:upload`.\n\n**See the implementation in** [**Node.js**](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/api-implementation-nodejs#3-check-the-client-permissions)**.**\n\n### Implement the Machine to Machine Application\n\nIn this section, we will see how we can implement a Machine-to-Machine Application for our scenario.\n\n### Get an Access Token\n\nWe will start by invoking the Auth0 `/oauth/token` API endpoint to get an Access Token.\n\nTo do so, we will need the following configuration values:\n\n*   **Domain**: Auth0 Domain, which you can retrieve from the Settings of your application in the [Auth0 Dashboard](https://manage.auth0.com/#/applications). This value will be a part of the API URL: `https://{yourDomain}/oauth/token`.\n    \n*   **Audience**: API Identifier, which you can retrieve from the Settings of your API in the [Auth0 Dashboard](https://manage.auth0.com/#/apis).\n    \n*   **Client ID**: Auth0 Application's Client ID, which you can retrieve from the Settings of your application in the [Auth0 Dashboard](https://manage.auth0.com/#/applications).\n    \n*   **Client Secret**: Auth0 application's Client Secret, which you can retrieve from the Settings of your application in the [Auth0 Dashboard](https://manage.auth0.com/#/applications).\n    \n\nOur implementation should perform a `POST` operation to the `https://{yourDomain}/oauth/token` endpoint with a payload in the following format:\n\n```\n{\n  \"audience\": \"YOUR_API_IDENTIFIER\",\n  \"grant_type\": \"client_credentials\",\n  \"client_id\": \"${account.client_id}\",\n  \"client_secret\": \"${account.client_secret}\"\n}\n```\n\nTo learn more, see [Call Your API Using the Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow).\n\n**See the implementation in** [**Python**](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/cron-implementation-python#get-an-access-token).\n\n## Invoke the API\n\nNow that we have an Access Token that includes the valid scopes, we can invoke our API.\n\nTo do so, we will:\n\n*   Build a hard-coded timesheet entry in JSON format.\n    \n*   Add the Access Token as an `Authorization` header to our request.\n    \n*   Make the HTTP POST request.\n    \n*   Parse the response, and print it in the terminal (optional).\n    \n\n**See the implementation in** [**Python**](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/cron-implementation-python#invoke-the-api).",
  "title": "Application Implementation (Server Apps + API)",
  "description": "Application Implementation for the Server + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/api-implementation-nodejs",
  "markdown": "# Server Apps + API: Node.js Implementation for the API\n\nThis document is part of the [Server + API Architecture Scenario](https://auth0.com/docs/architecture-scenarios/application/server-api) and it explains how to implement the API in Node.js. Please refer to the scenario for information on the implemented solution.\n\nFull source code for the Node.js API implementation can be found in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets/tree/master/timesheets-api/node).\n\n## 1\\. Define the API endpoint\n\nWe will use the [Express web application framework](http://expressjs.com/) to build our Node.js API.\n\n### Create a package.json File\n\nCreate a folder for your API, navigate into it and run `npm init`. This will setup your `package.json` file.\n\nYou can leave the default settings or change them as you see fit.\n\nOur sample’s `package.json` looks like the following:\n\n```\n{\n  \"name\": \"timesheets-api\",\n  \"version\": \"1.0.0\",\n  \"description\": \"API used to add timesheet entries for employees and contractors\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/auth0-samples/auth0-pnp-timesheets.git\"\n  },\n  \"author\": \"Auth0\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/auth0-samples/auth0-pnp-timesheets/issues\"\n  },\n  \"homepage\": \"https://github.com/auth0-samples/auth0-pnp-timesheets#readme\"\n}\n```\n\n### Install the Dependencies\n\nNext, we need to set our dependencies. We will use the following modules:\n\n*   **express**: This module adds the [Express web application framework](https://expressjs.com/).\n    \n*   **jwks-rsa**: This library retrieves RSA signing keys from a JWKS (JSON Web Key Set) endpoint. Using `expressJwtSecret` we can generate a secret provider that will provide the right signing key to `express-jwt` based on the `kid` in the JWT header. For more information refer to the [node-jwks-rsa GitHub repository](https://github.com/auth0/node-jwks-rsa).\n    \n*   **express-jwt**: This module lets you authenticate HTTP requests using JWT tokens in your Node.js applications. It provides several functions that make working with JWTs easier. For more information refer to the [express-jwt GitHub repository](https://github.com/auth0/express-jwt).\n    \n*   **body-parser**: This is a Node.js body parsing middleware. It extracts the entire body portion of an incoming request stream and exposes it on `req.body` as something easier to interface with.For more information and several alternatives refer to the body-parser GitHub repository.\n    \n\nTo install these dependencies run the following:\n\n```\nnpm install express express-jwt jwks-rsa body-parser --save\n```\n\n### Implement the Endpoint\n\nNavigate to your API directory and create a `server.js` file. Your code needs to:\n\n*   Set the dependencies.\n    \n*   Enable the request body parsing middleware.\n    \n*   Implement the endpoint.\n    \n*   Launch the API server.\n    \n\nThis is our sample implementation:\n\n```\n// set dependencies\nconst express = require('express');\nconst app = express();\nconst jwt = require('express-jwt');\nconst jwksRsa = require('jwks-rsa');\nconst bodyParser = require('body-parser');\n\n// enable the use of request body parsing middleware\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({\n  extended: true\n}));\n\n// create timesheets upload API endpoint\napp.post('/timesheets/upload', function(req, res){\n  res.status(201).send({message: \"This is the POST /timesheets/upload endpoint\"});\n})\n\n// launch the API Server at localhost:8080\napp.listen(8080);\n```\n\nLaunch your API server using `node server` and make an HTTP POST request to `localhost:8080/timesheets/upload`. You should see a JSON response with a message `This is the POST /timesheets/upload endpoint`.\n\nSo now we have our endpoint but anyone can call it. Continue to the next paragraph to see how we can fix this.\n\n## 2\\. Secure the API endpoint\n\nIn order to validate our token we will use the `jwt` function, provided by the [express-jwt middleware](https://github.com/auth0/express-jwt#usage), and the `jwks-rsa` package to retrieve the public key from Auth0. The libraries do the following:\n\n1.  `express-jwt` will decode the token and pass the request, the header and the payload to `jwksRsa.expressJwtSecret`.\n    \n2.  `jwks-rsa` will then download all signing keys from the JWKS endpoint and see if a one of the signing keys matches the `kid` in the header of the JWT. If none of the signing keys match the incoming `kid`, an error will be thrown. If we have a match, we will pass the right signing key to `express-jwt`.\n    \n3.  `express-jwt` will the continue its own logic to validate the signature of the token, the expiration, `audience` and the `issuer`.\n    \n\nThe steps we will follow in our code are:\n\n*   Create the middleware function to validate the Access Token.\n    \n*   Enable the use of the middleware in our routes.\n    \n\nThis is also a good time for you to implement the logic to save the timesheet entries to a local database, or whatever other storage mechanism you may prefer. This is our sample implementation (some code is omitted for brevity):\n\n```\n// set dependencies - code omitted\n\n// enable the use of request body parsing middleware - code omitted\n\n// Create middleware for checking the JWT\nconst checkJwt = jwt({\n  // Dynamically provide a signing key based on the kid in the header and the signing keys provided by the JWKS endpoint.\n  secret: jwksRsa.expressJwtSecret({\n    cache: true,\n    rateLimit: true,\n    jwksRequestsPerMinute: 5,\n    jwksUri: `https://{yourDomain}/.well-known/jwks.json`\n  }),\n\n  // Validate the audience and the issuer.\n  audience: process.env.AUTH0_AUDIENCE,\n  issuer: `https://{yourDomain}/`,\n  algorithms: ['RS256']\n});\n\n// create timesheets API endpoint\napp.post('/timesheets/upload', checkJwt, function(req, res){\n  var timesheet = req.body;\n\n  // Save the timesheet entry to the database...\n\n  //send the response\n  res.status(201).send(timesheet);\n})\n\n// launch the API Server at localhost:8080 - code omitted\n```\n\nIf we launch our server now and do an HTTP POST to `localhost:8080/timesheets/upload` we should get the error message `Missing or invalid token` (which is perfectly fine since we didn’t send an Access Token in our request).\n\nIn order to test the working scenario as well we need to:\n\n*   Get an Access Token. For details on how to do so refer to: [Get an Access Token](https://auth0.com/docs/architecture-scenarios/application/server-api#get-an-access-token)\n    \n*   Invoke the API while adding an `Authorization` header to our request with the value `Bearer ACCESS_TOKEN` (where ACCESS\\_TOKEN is the value of the token we retrieved in the first step).\n    \n\n## 3\\. Check the Client permissions\n\nIn this step we will add to our implementation the ability to check if the client has permissions (or `scope`) to use our endpoint in order to upload a timesheet. In particular we want to ensure that the token has the correct scope, which is `batch:upload`.\n\nIn order to do this we will make use of the `express-jwt-authz` Node.js package, so go ahead and add that to your project:\n\n```\nnpm install express-jwt-authz --save\n```\n\nNow it is as simple as adding a call to `jwtAuthz(...)` to your middleware to ensure that the JWT contain a particular scope in order to execute a particular endpoint. This is our sample implementation (some code is omitted for brevity):\n\n```\n// set dependencies - some code omitted\nconst jwtAuthz = require('express-jwt-authz');\n\n// Create middleware for checking the JWT\n\n// Enable the use of request body parsing middleware\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({\n  extended: true\n}));\n\n// Batch upload endpoint\napp.post('/timesheets/upload', checkJwt, jwtAuthz(['batch:upload']), function(req, res){\n  var timesheet = req.body;\n\n  // Save the timesheet entry to the database...\n\n  //send the response\n  res.status(201).send(timesheet);\n});\n\n// launch the API Server at localhost:8080 - code omitted\n```\n\nIf we invoke our API with a token that does not include this scope we should get the error message Forbidden with the HTTP status code `403`. You can test this by removing this scope from your API.\n\nThat's it! You are done!",
  "title": "Server Apps + API: Node.js Implementation for the API",
  "description": "The Node.js implementation of the API for the Server Client + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/cron-implementation-python",
  "markdown": "# Server Apps + API: Python Implementation for the Cron Job\n\nThis document is part of the [Server + API Architecture Scenario](https://auth0.com/docs/architecture-scenarios/application/server-api) and it explains how to implement the server process in Python. Please refer to the [Server + API Architecture Scenario](https://auth0.com/docs/architecture-scenarios/application/server-api) document for information on the implemented solution.\n\nFull source code for the Python implementation of the server process can be found in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets/tree/master/timesheets-cron/python).\n\n## Get an Access Token\n\nIn order to make the HTTP request to the Auth0 `/oauth/token` API endpoint we will use the libraries `json`, `urllib` and `urllib2`.\n\nThis is our sample implementation:\n\n```\ndef main():\n  import json, urllib, urllib2, httplib\n\n  # Configuration Values\n  domain = \"{yourDomain}\" # Your Auth0 Domain\n  api_identifier = \"API_IDENTIFIER\" # API Identifier of your API\n  client_id = \"{yourClientId}\" # Client ID of your Machine to Machine Application\n  client_secret = \"YOUR_CLIENT_SECRET\" # Client Secret of your Machine to Machine Application\n  api_url = \"http://localhost:8080/timesheets/upload\"\n  grant_type = \"client_credentials\" # OAuth 2.0 flow to use\n\n  # Get an Access Token from Auth0\n  base_url = \"https://{domain}\".format(domain=domain)\n  data = urllib.urlencode({'client_id': client_id,\n                            'client_secret': client_secret,\n                            'audience': api_identifier,\n                            'grant_type': grant_type})\n  req = urllib2.Request(base_url + \"/oauth/token\", data, headers={\"Accept\": \"application/x-www-form-urlencoded\"})\n  response = urllib2.urlopen(req)\n  resp_body = response.read()\n  oauth = json.loads(resp_body)\n  access_token = oauth['access_token']\n\n# Standard boilerplate to call the main() function.\nif __name__ == '__main__':\n  main()\n```\n\nTo test this modify your code to print the `access_token` variable and run the process using `python cron.py`.\n\n## Invoke the API\n\nThe steps we follow in our implementation are:\n\n*   Build a JSON object containing timesheet data and assign it to a `timesheet` variable.\n    \n*   Add the API URL and the `timesheet` variable contents to the request body using `urllib2.Request`.\n    \n*   Add the `Authorization` header to the request.\n    \n*   Set the `Content-Type` header to `application/json`.\n    \n*   Invoke the API using `urllib2.urlopen` and add some error handling. Retrieve the response using `json.loads` and print it in the console.\n    \n\nThis is our sample implementation (some code is omitted for brevity):\n\n```\ndef main():\n  # import libraries - code omitted\n\n  # Configuration Values - code omitted\n\n  # Get an Access Token from Auth0 - code omitted\n\n  #Post new timesheet to API\n  timesheet = {'user_id': '007',\n                          'date': '2017-05-10T17:40:20.095Z',\n                          'project': 'StoreZero',\n                          'hours': 5}\n  req = urllib2.Request(api_url, data = json.dumps(timesheet))\n  req.add_header('Authorization', 'Bearer ' + access_token)\n  req.add_header('Content-Type', 'application/json')\n\n  try:\n    response = urllib2.urlopen(req)\n    res = json.loads(response.read())\n    print 'Created timesheet ' + str(res['id']) + ' for employee ' + str(res['user_id'])\n  except urllib2.HTTPError, e:\n    print 'HTTPError = ' + str(e.code) + ' ' + str(e.reason)\n  except urllib2.URLError, e:\n    print 'URLError = ' + str(e.reason)\n  except httplib.HTTPException, e:\n    print 'HTTPException'\n  except Exception, e:\n    print 'Generic Exception' + str(e)\n\n# Standard boilerplate to call the main() function - code omitted\n```\n\nTo test this make sure your API is running and run the process using `python cron.py`.\n\nThat's it! You are done!",
  "title": "Server Apps + API: Python Implementation for the Cron Job",
  "description": "The Python implementation of the server cron job for the Server Client + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-4",
  "markdown": "# Conclusion (Server Apps + API)\n\nIn this document we covered a simple scenario: an API, used to import timesheet entries in ExampleCo's systems, and a cron job, used by external contractors to send in their timesheets using this API.\n\nWe learned about the Client Credentials Grant, what an Access Token is, how to configure an API in Auth0, how to configure a Machine to Machine Application to communicate securely with this API, how to define and secure our API endpoints, how to use the provided libraries to validate the Access Token and how to retrieve a new one from Auth0.\n\nWe started by describing the business case and the requirements and went on explaining how each requirement can be met and the thought process behind each choice that was made.\n\nWe used Node.js for the API implementation and Python for the non interactive server process, hopefully though after going through this document you are able to build this using the technologies you prefer.",
  "title": "Conclusion (Server Apps + API)",
  "description": "Conclusion for the Server + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension",
  "markdown": "# Install Single Sign-On Dashboard Extension\n\nUse the Single Sign-On (SSO) Dashboard Extension to manage SSO login for your users on multiple enterprise applications. To learn more, [view this extension on GitHub](https://github.com/auth0-extensions/auth0-sso-dashboard-extension).\n\n## Install extension\n\nYou can install the SSO Dashboard extension through the Auth0 Dashboard:\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **SSO Dashboard** from the list of provided extensions. The **Install Extension** window will open:\n    \n    ![Dashboard - Extensions - SSO Dashboard - Install Extension](https://images.ctfassets.net/cdy7uua7fh8z/75heEyuJAN6FGSszXx06Hm/cf130fc22931cd351179ba08787f835a/dashboard-extensions-install_sso-dashboard.png)\n2.  Set the following configuration variables:\n    \n    | **Variable** | **Required** | **Description** |\n    | --- | --- | --- |\n    | `EXTENSION_CLIENT_ID` | Required | **Client ID** of the Auth0 application you created for the extension. |\n    | `TITLE` | Optional | Custom title that will appear at the top of the SSO Dashboard page. |\n    | `CUSTOM_CSS` | Optional | Path to a custom CSS file to style the look of your SSO Dashboard page. |\n    | `FAVICON_PATH` | Optional | Path to a custom favicon. |\n    | `AUTH0_CUSTOM_DOMAIN` | Optional | [Custom domain](https://auth0.com/docs/customize/custom-domains) configured with Auth0. |\n    \n3.  Select **Install**.\n    \n\nIf you navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), you'll notice that an application named `auth0-sso-dashboard` was created automatically. This application is used by the extension to authorize access to the Management API, and you must not modify it.\n\n## Use extension\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select the **Installed Extensions** view.\n    \n2.  Select **SSO Dashboard**. When you first select your installed extension, you will be asked to grant it the required permissions. Once you agree, you will be directed to your custom **SSO Dashboard**, which will display the **Title** you provided at the top of the page. If you provided a custom CSS file, that styling will also be applied.\n    \n3.  To log in to the SSO Dashboard:\n    \n    1.  For **Admins,** use: `https://{yourTenant}.YOUR_REGION_KEY.webtask.io/auth0-sso-dashboard/admins/login`\n        \n    2.  For **Users,** use: `https://{yourTenant}.YOUR_REGION_KEY.webtask.io/auth0-sso-dashboard/login`\n        \n        | **Region** | **Region Key** |\n        | --- | --- |\n        | US-1 | `us12` |\n        | US-3 | `us` |\n        | EU  | `eu12` |\n        | AU  | `au12` |\n        | JP-1 | `jp` |\n        \n\n## Learn more\n\n*   [Create Single Sign-on (SSO) Dashboard Application](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application)\n*   [Add Applications to Single Sign-On Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard)\n*   [Update Applications in the SSO Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/update-applications-on-the-sso-dashboard)\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
  "title": "Install Single Sign-On Dashboard Extension",
  "description": "Learn how to install the Auth0 Single Sign-On (SSO) Dashboard Extension to enable SSO login for your applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/passkeys/configure-passkey-policy",
  "markdown": "# Configure Passkey Policy\n\nYou can enable passkeys as an authentication method and configure your passkey policy in the Auth0 Dashboard.\n\n## Prerequisites\n\nTo enable passkeys as an authentication method for your database connection, you must configure your Auth0 tenant to fulfill the following prerequisites.\n\nIf these prerequisites are not met and you try to enable passkeys, the Auth0 Dashboard displays the **Passkey Authentication Prerequisites** readiness checklist and shows any unmet requirements.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/51aI3GgLqE4rTw93V26DZ0/5a800debe7068edc41b948d16a0ec3f2/Passkey_Authentication_Prerequisities__popup_.png)\n\nAfter you enable passkeys as an authentication method for a database connection, you can use the readiness checklist to monitor the status of each requirement and access the relevant settings.\n\nTo view the **Passkey Authentication Prerequisites** readiness checklist:\n\n1.  In the Auth0 Dashboard, go to [Authentication > Database](https://manage.auth0.com/dashboard/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Authentication Methods** view.\n    \n4.  Select **Configure** on the **Passkeys** card.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/1aY0EHAVCx9zsDyy8FlrzH/cefbaceed45f33460d3a5feeab885909/Dashboard_-_Passkey_Authentication_Prerequisites__Checklist_.png)\n\n### Enable New Universal Login Experience\n\nEnable and configure the [New Universal Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience).\n\n#### Disable Custom Login Page setting\n\nThe **Customize Login Page** setting allows you to customize login pages when using a [custom domain](https://auth0.com/docs/customize/custom-domains).\n\n1.  In the Auth0 Dashboard, go to [Branding > Universal Login > Advanced Options > Login](https://manage.auth0.com/#/login_page).\n    \n2.  Disable the **Custom Login Page** toggle.\n    \n\n### Enable Identifier First authentication\n\nEnable and configure [Identifier First authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first).\n\n### Update database connection settings\n\nYou must update specific settings for your database connection to use passkeys as an authentication method.\n\n#### Disable Requires Username setting\n\nThe **Requires Username** setting requires users to provide both a username and their email when logging in to a database connection.\n\n1.  In the Auth0 Dashboard, go to [Authentication > Database](https://manage.auth0.com/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Settings** view.\n    \n4.  Disable the **Requires Username** toggle.\n    \n\n#### Disable Use my own database setting unless Import Users to Auth0 setting is enabled\n\nThe **Use my own database** setting allows you to use an external database to store users on a [custom database](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection) connection.\n\nThe **Import Users to Auth0** settings allows you to automatically import users from an external database to Auth0. For more information, read [Import and Export Users](https://auth0.com/docs/manage-users/user-migration/user-migration-scenarios).\n\nIf the **Import Users to Auth0** setting is not enabled on your tenant, you must disable the **Use my own database** setting to configure passkeys:\n\n1.  In the Auth0 Dashboard, go to [Authentication > Database](https://manage.auth0.com/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Custom Database** view.\n    \n4.  Disable the **Use my own database** toggle.\n    \n\n## Best practices\n\nTo ensure the best experience for end users when using passkeys, consider the items below.\n\n*   **Configure a custom domain:** When a user enrolls a passkey, it associates with the relying party domain. If the domain name changes at any time, all of the passkeys associated with the old domain become invalid. Configure a [custom domain](https://auth0.com/docs/customize/custom-domains) for your tenant prior to enabling passkeys to avoid any interruptions for end-users.\n    \n*   **Enable passkeys for a single database connection**: Enable passkeys for a maximum of one database connection.\n    \n*   **Consider limitations for Organization users:** Users cannot use passkeys when creating an account through an [Organization invitation email](https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members). To allow these users to create passkeys, use an alternate method of user creation or ensure [progressive enrollment](#progressive-enrollment) is enabled.\n    \n\n## Enable passkeys as an authentication method\n\nYou can enable passkeys as an authentication method for your database connection in the Auth0 Dashboard:\n\n1.  Go to [Authentication > Database](https://manage.auth0.com/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Authentication Methods** view.\n    \n4.  Enable the toggle on the **Passkey** card.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/2mSuzaVEsxVPD6WnGtfWjk/6979022362947098bc667e22ef0721b3/Dashboard_-_Authentication_Methods.png)\n\n## Configure your policy\n\nYou can configure the passkey policy for your database connection in the Auth0 Dashboard:\n\n1.  Go to [Authentication > Database](https://manage.auth0.com/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Authentication Methods** view.\n    \n4.  Select **Configure** on the **Passkey** card.\n    \n\n### Passkey Challenge\n\nThis setting determines how users can trigger passkey authentication during login and signup.\n\n| **Passkey authentication UI** | **Description** |\n| --- | --- |\n| Autofill | Users must log in with their browser’s autofill feature to leverage passkeys. Autofill allows users to select a saved account from a dropdown menu when engaging with the login prompt. With autofill, users do not need to manually enter their credentials. |\n| Passkey button | Users must select the **Continue with a passkey** button on the login prompt. |\n| Both | Users can trigger passkey authentication using autofill or by selecting the **Continue with a passkey** button on the login prompt. |\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/Q8xHHuKUvs4BMAJOKvq6M/9b21eedf85e43080cdbe673c97ffc378/login-passkey_default.png)\n\n### Progressive Enrollment\n\nEnabled by default, progressive enrollment prompts users to create a passkey (if they have not done so already) after logging in with their email and password. This step is not required and users can choose to delay this action every 30 days.\n\nProgressive enrollment is useful when migrating users to a new passkey flow as it offers a more seamless transition between authentication methods.\n\nWhen a user creates their passkey, it is added to their account as an authentication method. Their standard email or username and password remain valid and can be used to log in as needed. Passkeys do not replace or invalidate users’ standard credentials.\n\n### Local Enrollment\n\nEnabled by default, local enrollment prompts existing users to create a local passkey when using a cross-device passkey to log in to a new device.\n\nFor example, existing passkey users can use a QR code to log in to a new device that is within physical proximity of a previously-enrolled device. If local enrollment is enabled in this scenario, the user is prompted to create a local passkey on the new device after they log in with the QR code. If desired, users can choose to skip this action.",
  "title": "Configure Passkey Policy",
  "description": "Learn how to enable passkeys as an authentication method and configure your passkey policy.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/users/get-users",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/update-applications-on-the-sso-dashboard",
  "markdown": "# Update Applications in the SSO Dashboard\n\nUse the [](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension)SSO Dashboard Extension to manage SSO login for your users on multiple enterprise applications.\n\nTo learn more, see [Single Sign-On Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension) or [view this extension on GitHub](https://github.com/auth0-extensions/auth0-sso-dashboard-extension).\n\n## Prerequisites\n\n*   [Create the SSO Dashboard application](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application) in Auth0.\n    \n*   [Install the SSO Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension).\n    \n*   [Add applications to the SSO Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard).\n    \n\n## Update application\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions) and select the **Installed Extensions** view.\n    \n2.  Select **SSO Dashboard**. If you are an administrator, you can also log in to the SSO Dashboard using `https://{yourTenant}.<REGION>8.webtask.io/auth0-sso-dashboard/admins/login`.\n    \n3.  Select **Settings** from the dropdown below your tenant name.\n    \n    ![Dashboard - Extensions - SSO Dashboard - Application Settings - Administrator](https://images.ctfassets.net/cdy7uua7fh8z/2YoQ3x6K6moMRHuz7GfaFT/295b09d3fa6cbf0d45cf025c27fe8bb1/change-settings.png)\n\n*   To specify whether users can see the application when it is enabled, select **Publish** or **Unpublish**.\n    \n*   To update an application's settings, select its gear icon.\n    \n*   To delete an application, select its **X**. A confirmation popup will confirm the deletion.\n    \n\n## Learn more\n\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)\n*   [Enable Single Sign-On for Tenants](https://auth0.com/docs/get-started/tenant-settings/enable-sso-for-legacy-tenants)\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
  "title": "Update Applications in the SSO Dashboard",
  "description": "Describes how to update applications in the SSO Dashboard Extension to enable SSO login for your applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/passkeys/monitor-passkey-events-in-tenant-logs",
  "markdown": "# Monitor Passkey Events in Tenant Logs\n\nYou can monitor passkey flows associated with your database connections through [tenant logs](https://auth0.com/docs/deploy-monitor/logs).\n\nYou can view log events in the Auth0 Dashboard ([Monitoring > Logs](https://manage.auth0.com/#/logs)) or retrieve logs using the [Management API](https://auth0.com/docs/api/management/v2/logs/get-logs).\n\n| **Event code** | **Scenario** | **Notes** |\n| --- | --- | --- |\n| `ss` | During signup, a user registered a passkey as their primary authentication method. | This log event contains the `details.authentication_methods` array field with the entry value `passkey`.<br><br>If a user registered with a password, this array field contains the entry value `pwd`. |\n| `s` | During login, a user authenticated with a passkey. | This log event contains the `details.prompts` array which lists the set of prompts a user navigated through during login.<br><br>If a user authenticated using a passkey, the array contains an element with the following field: `\"performed_amr\": [\"phr\"]`. |\n| `gd_enrollment_complete` | A progressive or local enrollment flow was successfully completed. | This log event contains the `details.authenticator.type` field with the value `passkey` if a user enrolled a passkey. |\n| `gd_webauthn_enrollment_failed` | An error occurred during a progressive or local enrollment flow. | This log event contains the `details.authentication_methods array` field with the entry value `passkey` if a user tried to enroll a passkey. |",
  "title": "Monitor Passkey Events in Tenant Logs",
  "description": "Learn how to identify and monitor passkey events in your tenant logs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard",
  "markdown": "# Add Applications to Single Sign-On Dashboard\n\nUse the [](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension)Single Sign-On (SSO) Dashboard Extension to manage SSO login for your users on multiple enterprise applications.\n\n## Prerequisites\n\n*   [Create the SSO Dashboard application](https://auth0.com/docs/dashboard/guides/extensions/sso-dashboard-create-app).\n    \n*   [Install the SSO Dashboard Extension](https://auth0.com/docs/dashboard/guides/extensions/sso-dashboard-install-extension).\n    \n\n## Add applications\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select your new SSO Dashboard extension. If you are an administrator, you can also log in to the SSO Dashboard using `https://{yourTenant}.<REGION>8.webtask.io/auth0-sso-dashboard/admins/login`.\n    \n2.  In the upper right corner, select **Settings** from the dropdown below your tenant name.\n    \n3.  Click **Create App** to add a new application.\n    \n    ![Dashboard - Extensions - SSO Dashboard - Administrator - Create App Settings](https://images.ctfassets.net/cdy7uua7fh8z/7qPSaWPOPPhQHfqW38mbxH/9c52a16f51d9941b3741043c36bba08e/settings.png)\n    \n    The **New Application** form appears.\n    \n    ![Dashboard - Extensions - SSO Dashboard - New App](https://images.ctfassets.net/cdy7uua7fh8z/6wAZQYT8xDqgKa0Fj9AuBQ/009cb704da2f138faf8fafea2c785f45/new-app.png)\n4.  Complete the following fields for the new application:\n    \n    | Field | Description |\n    | --- | --- |\n    | **Type** | A dropdown where you select SAML, OpenID-Connect, or WS-Federation depending on the type of application. |\n    | **Application** | A dropdown where you select the application that you wish to add. |\n    | **Name** | The name is automatically populated based on the application you selected. You can change the name or use the default. |\n    | **Logo** | The url of the logo you wish to user as an icon for the application. |\n    | **Callback** | One of the **Allowed Callback URLs** under your [Application Settings](https://manage.auth0.com/#/applications) for the application. |\n    | **Connection** | (_Optional_) The connection type. You can add or edit your available connection types in the [Connections section of the Auth0 Management dashboard](https://manage.auth0.com/#/connections/database). If a connection is not set and the user is not logged, the user will see the Auth0 Login page. |\n    | **Custom URL** | (_Optional_) Checkbox to use a custom URL rather than the Auth0 URL. If you check the box, a field appears where you can enter your custom URL. |\n    | **Enabled** | Checkbox for this application to be visible (published) to your users. |\n    \n5.  Select **Create**. Your new application will then appear on the **Applications** page of the SSO dashboard with any other applications that have been created.\n    \n    ![Dashboard - Extensions - SSO Dashboard Applications](https://images.ctfassets.net/cdy7uua7fh8z/2W4AdIGU3nM7fp5900vS9x/de9cea49850bbfa7c8e45bac94cb783c/dashboard-apps.png)\n6.  Click on an application to test the connection.\n    \n\n## Learn more\n\n*   [Update Applications in the SSO Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/update-applications-on-the-sso-dashboard)\n*   [Create Single Sign-on (SSO) Dashboard Application](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application)\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
  "title": "Add Applications to Single Sign-On Dashboard",
  "description": "Learn how to add applications to the Auth0 Single Sign-On (SSO) Dashboard Extension to enable SSO login for your applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/users/get-users-by-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/patch-enabled-connections-by-connection-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/manage-users/user-search/v2/query-syntax",
  "markdown": "# User Search Query Syntax v2\n\nThis page explains query string syntax, the mini-language used by the Query String Query.\n\nWhen searching using Auth0's [List or Search Users](https://auth0.com/docs/api/v2/#!/Users/get_users) endpoint, you can construct custom queries using this syntax for the value of the `q` field.\n\nThe query string is parsed into a series of terms and operators. A term can be a single word  (`john` or `smith`) or a phrase surrounded by double quotes (`\"john smith\"`) which will match all the words in the phrase in the same order.\n\n## Searchable fields\n\nYou can search for users using the following fields:\n\n*   All the [normalized user profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema) fields\n    \n*   **Only** the profile information under the `user_metadata` object:\n    \n    *   `name`\n        \n    *   `nickname`\n        \n    *   `given_name`\n        \n    *   `family_name`\n        \n\nTo learn more, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata).\n\n### Field name examples\n\nSome examples of query string syntax are:\n\n*   Where the `created_at` field contains `2016`: `created_at:2016`\n    \n*   Where the `user_name` field contains `john` or `smith`. If you omit the OR operator the default operator will be used.\n    \n    `user_name: (john OR smith)` `user_name: (john smith)`\n    \n*   Where the `user_name` field contains the exact phrase `\"john smith\"`: `user_name: \"john smith\"`\n    \n*   Where the field `nickname` has no value or is missing: `NOT _exists_: nickname`\n    \n*   Where the field `nickname` has any non-null value: `_exists_: nickname`\n    \n*   Your query can search across more than one field by using the `AND` & `OR` condition. Where the username field is exactly `\"john\"` AND the field `nickname` has any non-null value: `username: \"john\" AND _exists_: nickname`\n    \n\n## Wildcards\n\nWildcard searches can be run on individual terms, using `?` to replace a single character, and `*` to replace zero or more characters: `2016-0?-*`\n\nNote that certain wildcard queries will require an enormous amount of memory and perform poorly. (For example, imagine how many terms need to be queried to match the query string `\"a* b* c*\"`.)\n\n## Regular expressions\n\nRegular expression patterns can be embedded in the query string by wrapping them in forward-slashes (\"/\"): `name:/joh?n(ath[oa]n)/`\n\nA detailed explanation of the supported regular expression syntax is explained on the Elastic's site at [Regular Expression Syntax](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html#regexp-syntax).\n\n## Fuzziness\n\nYou can search for terms that are similar to, but not exactly like, your search terms using the `~` as a \"fuzzy\" operator: `oauth~`\n\nThis is useful for commonly misspelled fields.\n\n## Proximity searches\n\nWhile a phrase query (eg `\"john smith\"`) matches all of the terms in the exact same order, a proximity query allows the specified words to be further apart or in a different order. In the same way that a fuzzy query can specify a maximum edit distance between characters in a word, a proximity search allows you to specify a maximum distance between words in a phrase: `\"fox quick\"~5`\n\nThe closer the text in a field is to the original order specified in the query string, the more relevant that result is ranked. When compared to the above example query, the phrase `\"quick fox\"` would be considered more relevant than `\"quick brown fox\"`.\n\n## Ranges\n\nInclusive ranges are specified with square brackets: `[min TO max]` and exclusive ranges with curly brackets: `{min TO max}`. Curly and square brackets can be combined in the same range expression: `logins_count:[100 TO 200}`.\n\nRanges can be specified for date, numeric or string fields.\n\nSome examples of range queries are:\n\n*   Last login date of 2015:\n    \n    `last_login:[2015-01-01 TO 2015-12-31]`\n    \n*   Users who have logged in between 1-5 times:\n    \n    `logins_count:[1 TO 5]`\n    \n*   Last login between two dates, excluding the first and last day:\n    \n    `last_login:{2012-01-01 TO 2012-12-31}`\n    \n*   Users that have logged on over 10 times:\n    \n    `logins_count:[10 TO *]`\n    \n*   Logins before 2015:\n    \n    `last_login{* TO 2015-01-01}`\n    \n\nCurly and square brackets can be combined in the same range expression:\n\n*   Logins count > 100 and < 200:\n    \n    `logins_count:[100 TO 200}`\n    \n\nFor ranges with one side unbounded, you can use the following syntax:\n\n`logins_count:>10` `logins_count:>=10` `logins_count:<10` `logins_count:<=10`\n\nTo combine an upper and lower bound with the simplified syntax, you need to join two clauses with an `AND` operator:\n\n`logins_count:(>=10 AND <20)` `logins_count:(+>=10 +<20)`\n\nThe parsing of ranges in query strings can be complex and error prone. It is more reliable to use an explicit [range query](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html).\n\n## Boosting\n\nUse the boost operator ^ to make one term more relevant than another. For instance, if you want to find all documents about foxes, but are especially interested in quick foxes:\n\n`quick^2 fox`\n\nThe default boost value is 1, but it can be any positive floating-point number. Boost values between 0 and 1 reduce relevance of the matching result.\n\nBoosts can also be applied to phrases or groups:\n\n`\"john smith\"^2 (foo bar)^4`\n\n## Boolean operators\n\nBy default, all terms are optional as long as one term matches. A search for `foo bar baz` will find any document that contains one or more of `foo` or `bar` or `baz`.\n\nUse of the `default_operator`, which allows you to force all terms to be required, is discussed above. However, there are Boolean operators that can be used in the query string itself for more control.\n\nThe preferred operators are `+` (this term must be present) and `-` (this term must not be present). All other terms are optional. For example, this query:\n\n`quick brown +fox -news`\n\nstates that:\n\n*   `fox` must be present\n    \n*   `news` must not be present\n    \n*   `quick` and `brown` are optional but their presence will increase the relevance of the result.\n    \n\nThe familiar operators `AND`,`OR` and `NOT`(also written `&&`,`||` and `!`) are also supported. However, the effects of these operators can be more complicated than is obvious at first. `NOT` takes precedence over `AND`, which takes precedence over `OR`. While the `+` and `-` only affect the term to the right of the operator, `AND` and `OR` can affect both the terms to the left and to the right.\n\n## Grouping\n\nMultiple terms or clauses can be grouped together with parentheses to form sub-queries:\n\n`(quick OR brown) AND fox`\n\nGroups can be used to target a particular field, or to boost the result of a sub-query:\n\n`status:(active OR pending) title:(full text search)^2`\n\n## Reserved characters\n\nIf you need to use any of the characters which function as operators in the query itself as literal text (not as operators), then you must escape them with a leading backslash. For instance, to search for \"(1+1)=2\", you would need to write your query as `\\(1\\+1\\)\\=2`.\n\nThe reserved characters are: `+ - = && || > < ! ( ) { } [ ] ^ \" ~ * ? : \\ /`\n\nFailing to escape these special characters correctly could lead to a syntax error which will prevent your query from executing correctly.\n\n## Empty query\n\nIf the query string is empty or contains only whitespaces, the query will yield an empty result set.\n\n## Additional Information\n\nFor example queries for searching users, see [Users Search](https://auth0.com/docs/manage-users/user-search/v2).\n\nThe preceding information is adapted from Elastic's [Elasticsearch Reference](http://elastic.co/).\n\n## Learn more\n\n*   [User Search Query Syntax](https://auth0.com/docs/manage-users/user-search/user-search-query-syntax)",
  "title": "User Search Query Syntax v2",
  "description": "Learn how to use search query string syntax to construct custom queries when searching using Auth0's Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/universal-login-pages/customize-new-universal-login-with-the-no-code-editor",
  "markdown": "# Customize Universal Login Page Themes\n\nYou can create a consistently branded login experience for your users by styling your Universal Login prompts. With the Universal Login no-code editor, you can easily customize the colors, fonts, borders, and backgrounds of the prompts displayed to users throughout the login flow.\n\nThe no-code editor allows you to customize your Universal Login branding theme. To customize the text included in each prompt, review [Customize Universal Login Text Elements](https://auth0.com/docs/customize/login-pages/universal-login/customize-text-elements). For expanded customization capabilities, review [Customize Universal Login Page Templates](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates).\n\n## Universal Login no-code editor\n\nTo customize your Universal Login theme, follow the steps below:\n\n1.  On the Auth0 Dashboard, navigate to [Branding > Universal Login > Customization Options](https://manage.auth0.com/#/universal-login/customizations/colors).\n    \n2.  Select a [theme component](#theme-components) (e.g., Colors) from the Styles menu. Then, customize the options listed to the right.\n    \n3.  After customizing your theme, select **Save and Publish**.\n    \n\nAfter you save your theme, you can access a live preview of your login experience to review and test your screens. To launch the preview in a new tab, select **Try** above the no-code editor.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/01nmAYzRb5U8xOpUWEClH9/de60b97b42c6de04bea69914d36e6984/branding-customize-NUL-Nocode-fullscreen0.png)\n\n### Theme components\n\nTo create your desired Universal Login theme, the Styles menu contains the following components:\n\n## Management API\n\nYou can also customize your Universal Login theme with the [Management API](https://auth0.com/docs/api/management/v2). Specifically, you can use the Branding endpoints to:\n\n*   [Create a new branding theme](https://auth0.com/docs/api/management/v2/branding/post-branding-theme)\n    \n*   [Retrieve the default branding theme](https://auth0.com/docs/api/management/v2/branding/get-default-branding-theme)\n    \n*   [Retrieve a specific branding theme](https://auth0.com/docs/api/management/v2/branding/get-branding-theme)\n    \n*   [Delete a branding theme](https://auth0.com/docs/api/management/v2/branding/delete-branding-theme)\n    \n*   [Update the current theme](https://auth0.com/docs/api/management/v2/branding/patch-branding-theme)",
  "title": "Customize Universal Login Page Themes",
  "description": "Describes how to use the no-code editor to customize themes for Universal Login pages.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/add-permissions-to-roles",
  "markdown": "# Add Permissions to Roles\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/roles/ROLE_ID/permissions' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"permissions\": [ { \"resource_server_identifier\": \"API_IDENTIFIER\", \"permission_name\": \"PERMISSION_NAME\" }, { \"resource_server_identifier\": \"API_IDENTIFIER\", \"permission_name\": \"PERMISSION_NAME\" } ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\"\n\n\tpayload := strings.NewReader(\"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/roles/ROLE_ID/permissions',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    permissions: [\n      {\n        resource_server_identifier: 'API_IDENTIFIER',\n        permission_name: 'PERMISSION_NAME'\n      },\n      {\n        resource_server_identifier: 'API_IDENTIFIER',\n        permission_name: 'PERMISSION_NAME'\n      }\n    ]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"permissions\": @[ @{ @\"resource_server_identifier\": @\"API_IDENTIFIER\", @\"permission_name\": @\"PERMISSION_NAME\" }, @{ @\"resource_server_identifier\": @\"API_IDENTIFIER\", @\"permission_name\": @\"PERMISSION_NAME\" } ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/roles/ROLE_ID/permissions\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"permissions\": [\n    [\n      \"resource_server_identifier\": \"API_IDENTIFIER\",\n      \"permission_name\": \"PERMISSION_NAME\"\n    ],\n    [\n      \"resource_server_identifier\": \"API_IDENTIFIER\",\n      \"permission_name\": \"PERMISSION_NAME\"\n    ]\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Add Permissions to Roles",
  "description": "Learn how to add permissions to roles using the Auth0 Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/create-roles",
  "markdown": "# Create Roles\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/roles' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"name\": \"ROLE_NAME\", \"description\": \"ROLE_DESC\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/roles\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"name\\\": \\\"ROLE_NAME\\\", \\\"description\\\": \\\"ROLE_DESC\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/roles\"\n\n\tpayload := strings.NewReader(\"{ \\\"name\\\": \\\"ROLE_NAME\\\", \\\"description\\\": \\\"ROLE_DESC\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/roles\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"name\\\": \\\"ROLE_NAME\\\", \\\"description\\\": \\\"ROLE_DESC\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/roles',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {name: 'ROLE_NAME', description: 'ROLE_DESC'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"name\": @\"ROLE_NAME\",\n                              @\"description\": @\"ROLE_DESC\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/roles\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/roles\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"name\\\": \\\"ROLE_NAME\\\", \\\"description\\\": \\\"ROLE_DESC\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"name\\\": \\\"ROLE_NAME\\\", \\\"description\\\": \\\"ROLE_DESC\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/roles\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/roles\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"name\\\": \\\"ROLE_NAME\\\", \\\"description\\\": \\\"ROLE_DESC\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"name\": \"ROLE_NAME\",\n  \"description\": \"ROLE_DESC\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/roles\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Create Roles",
  "description": "Learn how to create a role using the Auth0 Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/remove-roles-from-users",
  "markdown": "# Remove Roles from Users\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID/roles' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"roles\": [ \"ROLE_ID\", \"ROLE_ID\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID/roles\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID/roles\"\n\n\tpayload := strings.NewReader(\"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"DELETE\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/users/USER_ID/roles\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID/roles',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {roles: ['ROLE_ID', 'ROLE_ID']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"roles\": @[ @\"ROLE_ID\", @\"ROLE_ID\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID/roles\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID/roles\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_POSTFIELDS => \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/users/USER_ID/roles\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID/roles\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"roles\": [\"ROLE_ID\", \"ROLE_ID\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID/roles\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Remove Roles from Users",
  "description": "Learn how to remove roles assigned to a user using the Auth0 Dashboard or the Management API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa-selection-nul",
  "markdown": "# Customize MFA Selection for Universal Login\n\nAuth0 supports a variety of factors for securing user access with [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors). Using `post-login` Actions, you can customize your MFA flows to challenge users with a specific factor or sequence of factors. You can also use contextual information about users and their organizations to create more individualized experiences. For example, you can customize your flows to challenge users with specific factors based on their membership in certain Organizations or their assigned user roles.\n\n## How it works\n\nYou can use [Actions](https://auth0.com/docs/customize/actions) to customize your MFA flows. Specifically, you can modify the `post-login` trigger of the [Login Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) with the following Authentication API methods:\n\n*   `challengeWith`: Specifies the factor or factors users must use to authenticate, such as a one-time password (OTP). This method presents a default challenge to users and can optionally provide access to a factor picker that allows them to choose a different authentication method.\n    \n*   `challengeWithAny`: Sets a group of factors users can choose from when authenticating, such as email and OTP. By default, this method presents a factor picker to users rather than a specific challenge, in accordance with the following conditions:\n    \n    *   If two or more factors are specified, a factor picker displays to the user.\n        \n    *   If the user has only enrolled in one of the specified factors (or only one factor is supplied), the factor picker is skipped.\n        \n    *   If the user has not enrolled in any of the specified factors, the command fails.\n        \n\nYou can use a combination of these methods to tailor your MFA flows as needed. You can also incorporate user metadata, such as roles or previously used factors, into these methods to create more tailored flows.\n\nWhen choosing MFA challenges for your commands, you can use the factors listed below or the `enrolledFactors` value. `enrolledFactors` represents the list of active factors associated with a user's account.\n\n*   `otp`\n    \n*   `email`\n    \n*   `push-notification`\n    \n    *   `otpFallback`\n        \n*   `phone`\n    \n    *   `preferredMethod: voice`\n        \n    *   `preferredMethod: sms`\n        \n    *   `preferredMethod: both`\n        \n*   `webauthn-platform`\n    \n*   `webauthn-roaming`\n    \n\nThe array `event.authentication.methods` includes a `type` field when the name of the method is set to `mfa`. type is a string that contains factor values matching those used by the `type` field from `enrolledFactors` (listed above). When an MFA challenge is performed, `methods` contains an object of `name:mfa` with `type` set to the factor used for that challenge. `methods` is only updated when an Action begins. To see the results of a challenge, `methods` must be accessed in the next Action in the flow.\n\nTo learn more, review the following resources:\n\n*   [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object)\n    \n*   [Actions Triggers: post-login - API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object)\n    \n\n### Sequenced and contextual flows\n\nWith the `challengeWith` or `challengeWithAny` commands, you can use contextual information to determine the best challenge or series of challenges to present to users. Specifically, you can leverage the following:\n\n*   **Sequenced flows**: Challenge users with a series of different factors in a specific order.\n    \n*   **Contextual flows**: Determine which factor to next challenge the user with based on previous challenges in the flow.\n    \n\nTo help illustrate these flows, consider the following example:\n\n```\n// ACTION 1 \n\nexports.onExecutePostLogin = async (event, api) => {\n\n   api.authentication.challengeWithAny([{ type: 'phone'}, { type: 'push-notification' }]);\n\n} \n\n// ============================================ \n\n// ACTION 2 \n\n// Decide based on what the user did in the previous action \n\nexports.onExecutePostLogin = async (event, api) => { \n\n    if(event.authentication.methods.find(m => m.type === 'phone') && event.authorization?.roles.includes('admin')) { \n\n        api.authentication.challengeWith({ type: 'push-notification' }); \n\n    }\n\n}\n```\n\nIn this scenario, a user is first challenged with SMS via the `challengeWithAny` command in Action 1. Then, Action 2 challenges the user with a push notification because they have the Admin user role and also completed the SMS challenge.\n\nIn this flow, you can make decisions about which factor to challenge the user with due to the following:\n\n1.  The flow pauses after executing Action 1.\n    \n2.  The user completes the MFA flow prompted by Action 1.\n    \n3.  `event.authentication.methods.type` in Action 2 populates with information from the previous MFA challenge.\n    \n4.  The flow resumes to execute Action 2 using contextual information from Action 1.\n    \n\nWhile this example presents a similar experience to using redirects in your Actions, commands using `challengeWith` and `challengeWithAny` offer the following unique benefits:\n\n*   Flows pause after each command, allowing you to accumulate user information that can be used in subsequent Actions. Comparatively, redirects only occur a single time as the final command in a flow.\n    \n*   MFA is triggered after each Action containing `challengeWith` or `challengeWithAny` commands is executed. With redirects, MFA runs as the final Action in the pipeline.\n    \n\n**Note**: This method of executing Actions only applies to those containing `challengeWith` or `challengeWithAny` commands. Actions serving other purposes are not affected.\n\n## Before you begin\n\nBefore you can customize your MFA flows, you must first enable MFA in your tenant and prompt your users to enroll in the appropriate factors.\n\n### Prepare your tenant\n\nTo get started, set up MFA in your tenant and enable the Customize MFA Factors using Actions setting. You can set up one or more factors and define your MFA policies on the Auth0 Dashboard under [Security > Multifactor Auth](https://manage.auth0.com/#/security/mfa).\n\n*   To learn more about the setup process, review [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa).\n    \n*   For information about configuring specific factors, review [Multi-factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n    \n\nTo customize your flows, you **must enable** the Customize MFA Factors using Actions toggle in the Additional Settings section. Your customized flows will not work properly if this setting is not enabled.\n\n![Auth0 Dashboard > Security > Multi-factor Auth > Additional Settings](https://images.ctfassets.net/cdy7uua7fh8z/2hv0ELTkkka3t230SXfxw/46def5395652b2451cfc9e0ad01a371a/MFA_actions.png)\n\n### Enroll users in factors\n\nOnce MFA is configured, ensure your users enroll in one or more of the factors you enabled. Users must enroll in authenticators before they can be challenged by `post-login` Action commands.\n\nAfter a user signs up or is created in your tenant, you can create enrollments with the Management API [authentication-methods](https://auth0.com/docs/api/management/v2/users/post-authentication-methods) endpoint, or you can manage users' enrollments directly through their profile pages in the Auth0 Dashboard.\n\n## Customize your MFA flows\n\nOnce your tenant is ready, you can create `post-login` Actions to customize your MFA flows. Steps and example use cases are provided below.\n\n### Create your post-login Action\n\n1.  On your Auth0 Dashboard, navigate to [Actions > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**.\n    \n2.  Under Add Action, select **Custom** and choose **Create Action**.\n    \n3.  On the Create Action popup:\n    \n    *   Enter a name for your Action.\n        \n    *   Select **Login / Post-Login** as the trigger.\n        \n    *   Use **Node 18 (Recommended)** for the runtime.\n        \n4.  Review the popup to ensure accuracy. Then, select **Create**.\n    \n5.  After creation, the code editor displays the `onPostExecute` command. Add your custom code or code sample to the command.\n    \n6.  When your command is ready, select **Deploy**.\n    \n7.  Select **Add to Flow** on the successful deployment notification.\n    \n    *   **Note**: If the notification has closed, choose **Back to Flow** above the code editor.\n        \n8.  Drag and drop your new command from the Add Action panel into your Login flow. Then, select **Apply**.\n    \n\nTo make additional updates to your Action, navigate to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your command. You can then update and redeploy your code as needed.\n\n### Test your post-login Action\n\nTo ensure your commands function appropriately, you can test your Action through the Auth0 Dashboard:\n\n*   Navigate to [Authentication > Authentication Profile](https://manage.auth0.com/#/authentication-profiles).\n    \n*   Select **Try** to open a sample login prompt in a new tab.\n    \n*   Enter your credentials and test your new MFA flow.\n    \n\nIf the flow is successful, a confirmation screen displays. If you encounter any issues, you can update your code by navigating to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) on your Auth0 Dashboard.\n\n## Example use cases\n\nThe examples below outline common use cases for customizing MFA flows.\n\n### Use current enrollments to determine challenge method\n\nThe following sample challenges a user with MFA if they are enrolled with the following factors:\n\n*   One-time password (OTP)\n    \n*   Phone\n    \n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\n api.authentication.challengeWithAny([{type: 'otp'}, {type: 'phone'}]);\n\n}\n```\n\n### Use roles to determine challenge method\n\nThe following sample challenges all users with OTP. If a user has the Admin role and requires a higher level of access to your application, they are challenged with an additional factor as a form of [step-up authentication](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication).\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n    api.authentication.challengeWith({type: 'otp'});\n\n    const isAdmin = event.authorization?.roles.includes('admin');\n    if(isAdmin) {\n        api.authentication.challengeWith({type: 'phone'});\n    }\n}\n```\n\n### Use metadata to determine challenge method\n\nIn this example, MFA factors are enabled at the [Organization](https://auth0.com/docs/manage-users/organizations) level. This sample uses different categories of metadata to determine the right challenge for individual users:\n\n*   **Organization metadata**: Organization-level data, such as the specific factors enabled for an Organization.\n    \n*   **User metadata**: User-level data, such as whether a user has a phone number associated with their profile.\n    \n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const orgFactors = event.organization.metadata.factors ?? [];\n\n  // Get the intersection of factors available for the user and factors enabled for the org\n  const availableFactors = orgFactors.filter(f => event.user.enrolledFactors.some(ef => ef.type === f));\n\n  // Prefer push if available\n  if(availableFactors.includes('push-notification')) {\n    api.authentication.challengeWith({ type: 'push-notification' });\n    return;\n  }\n\n  // If the user has a verified phone number and the organization\n  // allows for SMS and email, prefer SMS and allow email as a fallback\n  // if available\n  if(event.user.phone_number && \n     event.user.phone_verified && \n     availableFactors.includes('phone')) {\n    if(availableFactors.includes('email') {\n      api.authentication.challengeWith({ type: 'phone' }, {\n        additionalFactors: [{\n          type: 'email'\n        }]\n      });\n    } else {\n      api.authentication.challengeWith({ type: 'phone' });\n    }\n\n    return;\n  }\n\n  // If push-notifications and/or phone couldn't be prioritized, fallback to email if\n  // enabled for the org, otherwise fail.\n  if(availableFactors.includes('email') {\n    api.authentication.challengeWith({ type: \"email\" });\n    return;\n  }\n\n  api.access.deny(\"No MFA factors available for this org + user\");\n};\n```\n\n### Allow users to select an alternate method of authentication\n\nFor a more flexible experience, you can present users with a **Try Another Method** link as part of their MFA challenge. This link allows users to select a different method of authentication than the default challenge.\n\nTo achieve this, include the `additionalFactors` parameter in your Actions code. You can set this parameter to a specific factor for all users or use `enrolledFactors` to let users choose their preferred factor.\n\n**Specific Factor**\n\nThe following sample challenges users with OTP by default. If desired, users can access the Try Another Method link to authenticate with email instead.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  api.authentication.challengeWith({ type: 'otp' }, \n    { additionalFactors: [{type: 'email'}] })\n};\n```\n\n**Enrolled Factors**\n\nThe following sample challenges users with OTP by default. If desired, users can access the Try Another Method link to authenticate with one of their other enrolled factors.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const enrolledFactors = event.user.enrolledFactors.map((f) => ({type: f.type}));\n\n  api.authentication.challengeWith({ type: 'otp' }, \n    { additionalFactors: enrolledFactors })\n};\n```\n\n### Use Adaptive MFA to determine when to challenge users\n\nThe following example uses [Adaptive MFA](https://auth0.com/docs/get-started/auth0-teams/tenant-management) to determine if users should be challenged.\n\nAdaptive MFA is a flexible MFA policy that protects your tenant from bad actors by assessing potential risk during login transactions and prompting users for additional verification when appropriate.\n\nIn this case, users are prompted with MFA if they log in from an unrecognized device and their overall confidence score is low or medium.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.authentication?.riskAssessment?.assessments.NewDevice) {\n\n  // Example condition: prompt MFA only based on the NewDevice \n    // confidence level, this will prompt for MFA when a user is logging in \n    // from an unknown device.\n    let shouldPromptMfa;\n\n    switch (event.authentication.riskAssessment.assessments.NewDevice.confidence) {\n      case 'low':\n      case 'medium':\n        shouldPromptMfa = true;\n        break;\n      case 'high':\n        shouldPromptMfa = false;\n        break;\n      case 'neutral':\n        // When this assessor has no useful information about the confidence, \n        // do not prompt MFA.\n        shouldPromptMfa = false;\n        break;\n    }\n\n      // It only makes sense to prompt for MFA when the user has at least one \n      // enrolled MFA factor.\n    const canPromptMfa = event.user.enrolledFactors?.length > 0;\n\n    if (shouldPromptMfa && canPromptMfa) {\n      const enrolledFactors = event.user.enrolledFactors.map((f) => ({type: f.type}));\n      api.authentication.challengeWithAny(enrolledFactors);\n    }\n\n  }\n\n};\n```\n\n### Use Actions to challenge users\n\nYou can use Actions to customize MFA flows by modifying the `post-login` trigger of the Login Flow. This example uses the `phone` method of authentication and `preferredMethod: 'both'`, referring to the active MFA factors associated with a user's account. For more information, refer to [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object).\n\n```\napi.authentication.challengeWith({ \n  type: 'phone', \n  options: { preferredMethod: 'both'} \n});\n```\n\n## Troubleshooting\n\nIn the event that you experience errors or unexpected results from your customized MFA flows, you can use the information below to help identify and resolve these issues.\n\n### Tenant logs\n\nYou can monitor your customized MFA flows through [tenant logs](https://auth0.com/docs/deploy-monitor/logs).\n\nTenant logs are available on the Auth0 Dashboard under [Monitoring > Logs](https://manage.auth0.com/#/logs). Alternatively, you can retrieve logs using the [Management API](https://auth0.com/docs/api/management/v2/introduction).\n\nIf you or your users experience unexpected behavior, review tenant logs for the following event codes for more information:\n\n| Scenario | Event Code | Descriptive Error |\n| --- | --- | --- |\n| A user is prompted with multi-factor authentication, but none of the requested factors can be used as a challenge. In this case, the user cannot complete MFA. | mfar | This scenario results in the following error message:<br><br>An MFA challenge is used in a PostLogin action but the requested factors are not properly set up. To perform MFA, enable the requested factors and ensure the user is enrolled with them. |\n| A user is prompted with multi-factor authentication, but one of the requested factors cannot be used as a challenge. In this case, the user can complete MFA using a different requested factor. | w   | This scenario results in the following warning message:<br><br>An MFA challenge is used in a PostLogin action, but the requested factor {factor name} is not properly set up. Enable the requested factor and ensure the user is enrolled with it. |\n\n### Troubleshooting checklist\n\nThe following checklist provides additional suggestions for identifying and resolving common issues with customized MFA flows.\n\n1.  The **Customize MFA factors with Actions** toggle must be enabled.\n    \n    *   Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure the toggle in the Additional Settings section is enabled.\n        \n2.  Factors referenced in your Actions must be enabled in your tenant.\n    \n    *   **Review your code**: Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and review your Actions code. Ensure all factors referenced are applicable to your use cases.\n        \n    *   **Review your factors**: Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure all factors referenced in your Actions are enabled.\n        \n3.  Users must be enrolled in the factors referenced in your Actions.\n    \n    *   If an individual receives an error, review their user details to ensure they are enrolled in the proper factors. Navigate to [**Auth0 Dashboard > User Management > Users**](https://manage.auth0.com/#/users) and select their name from the list.\n        \n        *   Review the Multi-factor Authentication section on the **Detail tab** to verify their enrollments. If the user is not enrolled, you can use the **Send an enrollment invitation** link available in this section.\n            \n        *   Alternatively, verify the user's enrollments through the **Raw JSON tab**. This information can also be retrieved using the [Management API](https://auth0.com/docs/api/management/v2/users/get-authentication-methods). However, it is important to note that the API does not list auto-enrolled authenticators, such as Email factors set up via an email verification link.\n            \n    *   If users are not enrolled in the appropriate factors, you can create enrollments with the Management API [authentication-methods](https://auth0.com/docs/api/management/v2/users/post-authentication-methods) endpoint. You can also manage users' enrollments directly through their profile pages in the Auth0 Dashboard.\n        \n4.  Ensure your Actions have been deployed and saved in your Pipeline.\n    \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library). Locate your Action in the list and ensure its status is **Deployed**. If a different status is listed, access your Action, review your code, and click **Deploy** to the top right.\n        \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**. Ensure your Action is listed in the flow. If not, access the **Custom tab** of the Add Action panel and drag and drop your Action into your Login flow. Then, select **Apply**.\n        \n5.  Ensure you've upgraded to the latest version of `post-login` Actions.\n    \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your Action. If your Action is out-of-date, you will see a yellow banner prompting you to update the Action. If the banner displays, select **Update**.\n        \n    *   You can also specify the latest version of `post-login` Actions for deployment when using the Deploy CLI. For more information, review [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).",
  "title": "Customize MFA Selection for Universal Login",
  "description": "Customize MFA flows using post-login Actions to challenge users with specific factors or sequences of factors. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/universal-login/text-customization",
  "markdown": "# Customize Universal Login Text Elements\n\n## Screen: reset-password-request\n\n![reset-password-request reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-request.png)\n\n| **Text** | **Key** |\n| --- | --- |\n| Reset your password ${clientName} | `pageTitle` |\n| Forgot Your Password? | `title` |\n| Back to ${clientName} | `backToLoginLinkText` |\n| Continue | `buttonText` |\n| Enter your email address and we will send you instructions to reset your password. | `descriptionEmail` |\n| Enter your username and we will send you instructions to reset your password. | `descriptionUsername` |\n| Email address | `placeholderEmail` |\n| Username | `placeholderUsername` |\n| ${companyName} | `logoAltText` |\n| Email is not valid. | `invalid-email-format` |\n| This ticket was expired. | `auth0-users-expired-ticket` |\n| Something went wrong, please try again later. | `custom-script-error-code` |\n| This ticket was already used. | `auth0-users-used-ticket` |\n| Something went wrong, please try again later | `auth0-users-validation` |\n| We had a problem sending the email, please try again later. | `reset-password-error` |\n| You have exceeded the amount of emails. Wait a few minutes and try again. | `too-many-email` |\n| You have exceeded the amount of emails. Wait a few minutes and try again. | `too-many-requests` |\n| Please enter an email address | `no-email` |\n| Username is required | `no-username` |\n\n## Screen: reset-password-email\n\n![reset-password-email reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-email.png)\n\n| **Text** | **Key** |\n| --- | --- |\n| Check your email ${clientName} | `pageTitle` |\n| Check Your Email | `title` |\n| Please check the email address ${email} for instructions to reset your password. | `emailDescription` |\n| Resend email | `resendLinkText` |\n| Please check the email address associated with the username ${email} for instructions to reset your password. | `usernameDescription` |\n\n## Screen: reset-password\n\n![reset-password reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password.png)\n\n| **Text** | **Key** |\n| --- | --- |\n| Reset your password ${clientName} | `pageTitle` |\n| Change Your Password | `title` |\n| Enter a new password below to change your password. | `description` |\n| Reset password | `buttonText` |\n| New password | `passwordPlaceholder` |\n| Re-enter new password | `reEnterpasswordPlaceholder` |\n| Your password must contain: | `passwordSecurityText` |\n| ${companyName} | `logoAltText` |\n| Show password | `showPasswordText` |\n| Hide password | `hidePasswordText` |\n| This ticket was expired. | `auth0-users-expired-ticket` |\n| Something went wrong, please try again later. | `custom-script-error-code` |\n| This ticket was already used. | `auth0-users-used-ticket` |\n| Something went wrong, please try again later | `auth0-users-validation` |\n| New password confirmation is missing | `no-re-enter-password` |\n| Password contains user information | `password-contains-user-information` |\n\n## Screen: reset-password-success\n\n![reset-password-success reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-success.png)\n\n| **Text** | **Key** |\n| --- | --- |\n| Password reset successful ${clientName} | `pageTitle` |\n| Password Changed! | `eventTitle` |\n| Your password has been changed successfully. | `description` |\n| Back to ${clientName} | `buttonText` |\n\n## Screen: reset-password-error\n\n![reset-password-error reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-error.png)\n\n| **Text** | **Key** |\n| --- | --- |\n| Password reset error ${clientName} | `pageTitle` |\n| Back to ${clientName} | `backToLoginLinkText` |\n| To reset your password, return to the login page and select \"Forgot Your Password\" to send a new email. | `descriptionExpired` |\n| To reset your password, return to the login page and select \"Forgot Your Password\" to send a new email. | `descriptionGeneric` |\n| This link has already been used. To reset your password, return to the login page and select \"Forgot Your Password\" to send a new email. | `descriptionUsed` |\n| Link Expired | `eventTitleExpired` |\n| Invalid Link | `eventTitleGeneric` |\n| Invalid Link | `eventTitleUsed` |\n| This ticket was expired. | `auth0-users-expired-ticket` |\n| Something went wrong, please try again later. | `custom-script-error-code` |\n| This ticket was already used. | `auth0-users-used-ticket` |\n| Something went wrong, please try again later | `auth0-users-validation` |\n| We had a problem sending the email, please try again later. | `reset-password-error` |\n\n## Screen: reset-password-mfa-email-challenge\n\n![reset-password-mfa-email-challenge reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-mfa-email-challenge.png)\n\n| **Text** | **Key** |\n| --- | --- |\n| Enter your one-time password to change your password for ${clientName} | `pageTitle` |\n| Go Back | `backText` |\n| Continue | `buttonText` |\n| We've sent an email with your code to | `description` |\n| Try another method | `pickAuthenticatorText` |\n| Enter the code | `placeholder` |\n| Remember this device for 30 days | `rememberMeText` |\n| Resend | `resendActionText` |\n| Didn't receive an email? | `resendText` |\n| Verify Your Identity | `title` |\n| ${companyName} | `logoAltText` |\n| OTP Code must have 6 numeric characters | `invalid-otp-code-format` |\n| The code you entered is invalid | `invalid-code` |\n| We couldn't verify the code. Please try again later. | `authenticator-error` |\n| Notification was not sent. Try resending the code. | `no-transaction-in-progress` |\n| You have exceeded the amount of emails. Wait a few minutes and try again. | `too-many-email` |\n| Your enrollment transaction expired, you will need to start again. | `transaction-not-found` |\n| We couldn't send the email. Please try again later. | `mfa-email-challenge-authenticator-error` |\n\n## Screen: reset-password-mfa-otp-challenge\n\n![reset-password-mfa-otp-challenge reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-mfa-otp-challenge.png)\n\n| Text | Key |\n| --- | --- |\n| Enter your one-time password to change your password for ${clientName} | `pageTitle` |\n| Verify Your Identity | `title` |\n| Check your preferred one-time password application for a code. | `description` |\n| Continue | `buttonText` |\n| Try another method | `pickAuthenticatorText` |\n| Enter your one-time code | `placeholder` |\n| Remember this device for 30 days | `rememberMeText` |\n| ${companyName} | `logoAltText` |\n| Use password | `usePasswordText` |\n| We couldn't verify the code. Please try again later. | `authenticator-error` |\n| Too many failed codes. Wait for some minutes before retrying. | `too-many-failures` |\n| Your enrollment transaction expired, you will need to start again. | `transaction-not-found` |\n\n## Screen: reset-password-mfa-phone-challenge\n\n![reset-password-mfa-phone-challenge reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-mfa-phone-challenge.png)\n\n| Text | Key |\n| --- | --- |\n| Enter your one-time password to change your password for ${clientName} | `pageTitle` |\n| Verify Your Identity | `title` |\n| We will send a 6-digit code to the following phone number: | `description` |\n| Continue | `continueButtonText` |\n| Choose another phone number. | `changePhoneText` |\n| Text message | `smsButtonText` |\n| Voice call | `voiceButtonText` |\n| How do you want to receive the code? | `chooseMessageTypeText` |\n| Try another method | `pickAuthenticatorText` |\n| Enter your phone number | `placeholder` |\n| ${companyName} | `logoAltText` |\n| There was a problem sending the SMS | `send-sms-failed` |\n| There was a problem making the voice call | `send-voice-failed` |\n| Phone number can only include digits. | `invalid-phone-format` |\n| It seems that your phone number is not valid. Please check and retry. | `invalid-phone` |\n| You have exceeded the maximum number of phone messages per hour. Wait a few minutes and try again. | `too-many-sms` |\n| You have exceeded the maximum number of phone messages per hour. Wait a few minutes and try again. | `too-many-voice` |\n| Your enrollment transaction expired, you will need to start again. | `transaction-not-found` |\n| Please enter a phone number | `no-phone` |\n\n## Screen: reset-password-mfa-push-challenge-push\n\n![reset-password-mfa-push-challenge-push reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-mfa-push-challenge-push.png)\n\n| Text | Key |\n| --- | --- |\n| Enter your one-time password to change your password for ${clientName} | `pageTitle` |\n| Verify Your Identity | `title` |\n| We’ve sent a notification to the following device via the ${appName} app: | `description` |\n| I've responded on my device | `buttonText` |\n| Try another method | `pickAuthenticatorText` |\n| Remember this device for 30 days | `rememberMeText` |\n| Resend | `resendActionText` |\n| Didn't receive a notification? | `resendText` |\n| Manually Enter Code | `enterOtpCode` |\n| OR  | `separatorText` |\n| ${companyName} | `logoAltText` |\n| You must accept the notification via the ${appName} app on your mobile device. | `challenge-transaction-pending` |\n| We have not received a confirmation, please slow down. | `polling-interval-exceeded` |\n| We have received too many notification requests. Wait a few minutes and try again. | `too-many-push` |\n| Your enrollment transaction expired, you will need to start again. | `transaction-not-found` |\n| We have not received a confirmation, please try scanning the code again. | `mfa-push-verify-transaction-pending` |\n| We couldn't verify the enrollment. Please try again later. | `mfa-push-verify-authenticator-error` |\n| We couldn't send the notification. Please try again later. | `mfa-push-challenge-authenticator-error` |\n| Notification rejected | `transaction-rejected` |\n\n## Screen: reset-password-mfa-recovery-code-challenge\n\n![reset-password-mfa-recovery-code-challenge reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-mfa-recovery-code-challenge.png)\n\n| Text | Key |\n| --- | --- |\n| Enter your one-time password to change your password for ${clientName} | `pageTitle` |\n| Verify Your Identity | `title` |\n| Enter the recovery code you were provided during your initial enrollment. | `description` |\n| Continue | `buttonText` |\n| Try another method | `pickAuthenticatorText` |\n| Enter your recovery code | `placeholder` |\n| ${companyName} | `logoAltText` |\n| The code you entered is invalid | `invalid-code` |\n| Recovery code must have 24 alphanumeric characters | `invalid-code-format` |\n| We couldn't verify the code. Please try again later. | `authenticator-error` |\n| Please confirm you have recorded the code | `no-confirmation` |\n| Too many failed codes. Wait for some minutes before retrying. | `too-many-failures` |\n| Your enrollment transaction expired, you will need to start again. | `transaction-not-found` |\n\n## Screen: reset-password-mfa-sms-challenge\n\n![reset-password-mfa-sms-challenge reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-mfa-sms-challenge.png)\n\n| Text | Key |\n| --- | --- |\n| Enter your one-time password to change your password for ${clientName} | `pageTitle` |\n| Verify Your Identity | `title` |\n| We've sent a text message to: | `description` |\n| Continue | `buttonText` |\n| Edit | `editText` |\n| Edit phone number | `editLinkScreenReadableText` |\n| Try another method | `pickAuthenticatorText` |\n| Enter the 6-digit code | `placeholder` |\n| Remember this device for 30 days | `rememberMeText` |\n| Resend | `resendActionText` |\n| Didn't receive a code? | `resendText` |\n| or  | `resendVoiceActionSeparatorTextBefore` |\n| get a call | `resendVoiceActionText` |\n| ${companyName}\" | `logoAltText` |\n| OTP Code must have 6 numeric characters | `invalid-otp-code-format` |\n| The code you entered is invalid | `invalid-code` |\n| There was a problem sending the SMS | `send-sms-failed` |\n| We couldn't verify the code. Please try again later. | `authenticator-error` |\n| We couldn't send the SMS. Please try again later. | `sms-authenticator-error` |\n| Notification was not sent. Try resending the code. | `no-transaction-in-progress` |\n| Too many failed codes. Wait for some minutes before retrying. | `too-many-failures` |\n| You have exceeded the maximum number of phone messages per hour. Wait a few minutes and try again. | `too-many-sms` |\n| Your enrollment transaction expired, you will need to start again. | `transaction-not-found` |\n\n## Screen: reset-password-mfa-voice-challenge\n\n![reset-password-mfa-voice-challenge reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-mfa-voice-challenge.png)\n\n| Text | Key |\n| --- | --- |\n| Enter your one-time password to change your password for ${clientName} | `pageTitle` |\n| Verify Your Identity | `title` |\n| We've sent a 6-digit code via voice phone call to the following phone number: | `description` |\n| Continue | `buttonText` |\n| Edit | `editText` |\n| Edit phone number | `editLinkScreenReadableText` |\n| Choose another phone number. | `changePhoneText` |\n| Try another method | `pickAuthenticatorText` |\n| Enter the 6-digit code | `placeholder` |\n| Remember this device for 30 days | `rememberMeText` |\n| Call again | `resendActionText` |\n| Didn't receive a call? | `resendText` |\n| or  | `resendSmsActionSeparatorTextBefore` |\n| send a text | `resendSmsActionText` |\n| ${companyName} | `logoAltText` |\n| OTP Code must have 6 numeric characters | `invalid-otp-code-format` |\n| The code you entered is invalid | `invalid-code` |\n| There was a problem making the voice call | `send-voice-failed` |\n| We couldn't verify the code. Please try again later. | `authenticator-error` |\n| We couldn't make the voice call. Please try again later. | `voice-authenticator-error` |\n| Notification was not sent. Try resending the code. | `no-transaction-in-progress` |\n| Too many failed codes. Wait for some minutes before retrying. | `too-many-failures` |\n| You have exceeded the maximum number of phone messages per hour. Wait a few minutes and try again. | `too-many-voice` |\n| Your enrollment transaction expired, you will need to start again. | `transaction-not-found` |\n\n## Screen: reset-password-mfa-webauthn-platform-challenge\n\n![reset-password-mfa-webauthn-platform-challenge reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-mfa-webauthn-platform-challenge.png)\n\n| Text | Key |\n| --- | --- |\n| Use fingerprint or face recognition to reset password ${clientName} | `title` |\n| Press the button below and follow your browser's steps to log in. | `description` |\n| Awaiting device confirmation | `awaitingConfirmation` |\n| Too many failed authentication attempts. Please try again later. | `too-many-webauthn-challenge-attempts-error` |\n| ${companyName} | `logoAltText` |\n| Continue | `continueButtonText` |\n| Try another method | `pickAuthenticatorText` |\n| Use password | `usePasswordText` |\n| Remember this device for 30 days | `rememberMeText` |\n| We could not start the device verification. Please try again later. | `webauthn-platform-challenge-error` |\n\n## Screen: reset-password-mfa-webauthn-roaming-challenge\n\n![reset-password-mfa-webauthn-roaming-challenge reference screenshot](https://auth0.com/docs/media/articles/universal-login/text-customization/reset-password-mfa-webauthn-roaming-challenge.png)\n\n| Text | Key |\n| --- | --- |\n| Use your security key to reset password ${clientName} | `pageTitle` |\n| Verify Your Identity | `title` |\n| Make sure your Security Key is nearby. Once you continue, you will be prompted to use it. | `description` |\n| Awaiting Security Key | `awaitingConfirmation` |\n| Too many failed authentication attempts. Please try again later. | `too-many-webauthn-challenge-attempts-error` |\n| ${companyName} | `logoAltText` |\n| Use security key | `continueButtonText` |\n| Try another method | `pickAuthenticatorText` |\n| Remember this device for 30 days | `rememberMeText` |\n| We could not start the security key verification. Please try again later. | `webauthn-challenge-error` |",
  "title": "Customize Universal Login Text Elements",
  "description": "Learn how to customize Universal Login text elements using the Auth0 Dashboard or Management API",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/2019-09-05-scopes",
  "markdown": "# Auth0 Security Bulletin for Assigning Scopes Based on Email Address\n\n## Overview\n\nIf you:\n\n*   Use rules to assign scopes to users based on their email addresses **and**\n    \n*   Your application uses multiple connections\n    \n\nThere is a possibility that your scopes could be compromised.\n\n## How This Works\n\nAuth0 requires that email addresses are unique on a per-connection basis. However, there are no limitations on a per-application basis.\n\nTherefore, it is possible for user A to sign up for the application using one connection and user B to sign up for the application with the same email address using a different connection.\n\nIf your rules assign scopes to users based on email address, the second user has now been given the same scopes as the first user, despite being a different individual.\n\n## How do I fix this?\n\nThe most straightforward mitigation is to require users to verify their email address after signing up and before being allowed to log in.",
  "title": "Auth0 Security Bulletin for Assigning Scopes Based on Email Address",
  "description": "Cases where improper custom rule code may create vulnerabilities in the authentication flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/classic-login/version-control",
  "markdown": "# Classic Login Page Version Control\n\nYou can use version control software to manage the source code of your Classic Login pages. Using version control for your content may be especially beneficial if you use a CI/CD flow for your tenant configuration and have customized the HTML of one or more Classic Login pages.\n\nTo implement version control, use the Auth0 Marketplace integration for your preferred method:\n\n*   [GitLab Pipelines](https://marketplace.auth0.com/integrations/gitlab-pipeline)\n    \n*   [GitHub Actions](https://marketplace.auth0.com/integrations/github-actions)\n    \n*   [Bitbucket Pipelines](https://marketplace.auth0.com/integrations/bitbucket-pipeline)\n    \n*   [Microsoft Azure Pipelines](https://marketplace.auth0.com/integrations/azure-pipeline)\n    \n\nThe general deployment process requires the following steps:\n\n1.  Create a folder in your version control repository with the appropriate name (`pages`).\n    \n2.  Create an HTML page (`login.html`, `password_reset.html`, `guardian_multifactor.html`, or `error_page.html`) within that folder.\n    \n3.  Create a JSON file with the same name as your HTML page for each hosted page that you wish to source control. To enable the page, the JSON file needs to contain the following:\n    \n\n`{ \"enabled\": true }`\n\nFor example: `your-repo/pages/error_page.html your-repo/pages/error_page.json`\n\n## Learn more\n\n*   [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login)",
  "title": "Classic Login Page Version Control",
  "description": "Learn how to back up your Classic Login pages using the Auth0 source control extensions",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles",
  "markdown": "# Manage Role-Based Access Control Roles\n\nFor role-based access control (RBAC) to work properly, you must enable it for your API using either the Dashboard or the Management API. The Authorization Core functionality is different from the Authorization Extension. For a comparison, read [Authorization Core vs. Authorization Extension](https://auth0.com/docs/manage-users/access-control/authorization-core-vs-authorization-extension).\n\nWe provide various functions to help you manage your roles, which you can access through either the Auth0 Dashboard or the Auth0 Management API:\n\n*   [Create roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/create-roles)\n    \n*   [Edit role definitions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/edit-role-definitions)\n    \n*   [Add permissions to roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/add-permissions-to-roles)\n    \n*   [Remove permissions from roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/remove-permissions-from-roles)\n    \n*   [View role permissions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/view-role-permissions)\n    \n*   [View role users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/view-users-assigned-to-roles)\n    \n*   [Delete roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/delete-roles)\n    \n\n## Learn more\n\n*   [Assign Roles to Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-roles-to-users)\n*   [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n*   [Add API Permissions](https://auth0.com/docs/get-started/apis/add-api-permissions)\n*   [Troubleshoot Role-Based Access Control and Authorization](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-rbac-authorization)",
  "title": "Manage Role-Based Access Control Roles",
  "description": "Learn how to manage roles using the Auth0 Management Dashboard. For use with Auth0's API Authorization Core feature set.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/enable-role-based-access-control-for-apis",
  "markdown": "# Enable Role-Based Access Control for APIs\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/resource-servers/API_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"enforce_policies\": \"true\", \"token_dialect\": \"TOKEN_DIALECT\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/resource-servers/API_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/resource-servers/API_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/resource-servers/API_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/resource-servers/API_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {enforce_policies: 'true', token_dialect: 'TOKEN_DIALECT'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"enforce_policies\": @\"true\",\n                              @\"token_dialect\": @\"TOKEN_DIALECT\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/resource-servers/API_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/resource-servers/API_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/resource-servers/API_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/resource-servers/API_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"enforce_policies\": \"true\",\n  \"token_dialect\": \"TOKEN_DIALECT\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/resource-servers/API_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Enable Role-Based Access Control for APIs",
  "description": "Learn how to enable role-based access control (RBAC) for an API using the Auth0 Dashboard or the Management API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-365-exchange-as-smtp-email-provider",
  "markdown": "# Configure Microsoft 365 Exchange Online as External SMTP Email Provider\n\n#### Before you start\n\n*   You must have a [Microsoft 365](https://www.microsoft.com/en-us/microsoft-365) account with an active subscription.\n    \n*   Ensure your Microsoft 365 subscription is licensed to send emails through Exchange Online.\n    \n    *   You need at a minimum a paid subscription to Microsoft Business Basic plan to use the Microsoft Graph API for Exchange Online.\n        \n*   Emails will be sent from Auth0 to your SMTP provider. Your ports should be open and allow inbound connections from specific Auth0 IP addresses. To learn more, read [Auth0 IP Addresses for Allow Lists](https://auth0.com/docs/secure/security-guidance/data-security/allowlist).\n    \n    *   Update the list of IPs in [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n        \n\nAuth0 allows you to configure your own SMTP email provider so you can manage, monitor, and troubleshoot your email communications.\n\n## Configure Microsoft 365\n\n1.  Log in to [Microsoft Azure](https://azure.microsoft.com/) account with your Microsoft 365 account.\n    \n2.  Register a [Azure Active Directory Application](https://learn.microsoft.com/en-us/azure/healthcare-apis/register-application) resource if you currently do not have one.\n    \n3.  Navigate to your Active Directory Application resource. Select **Services > App registrations**, and then select the application you will be using to send emails.\n    \n4.  Configure the required application permissions by navigating to **Manage > API permissions**.\n    \n5.  Add the `Mail.Send` [permission](https://learn.microsoft.com/en-us/azure/healthcare-apis/register-application#api-permissions) by selecting **Add a permission > Microsoft Graph > Application permissions** selector.\n    \n6.  Retrieve required provider configurations:\n    \n    1.  Navigate to the **Application Overview** to retrieve your application [Client ID and Tenant ID](https://learn.microsoft.com/en-us/azure/healthcare-apis/register-application#application-id-client-id).\n        \n    2.  Navigate to **Manage > Certificates & secrets** and collect the **Value** to create an application [secret](https://learn.microsoft.com/en-us/azure/healthcare-apis/register-application#certificates--secrets).\n        \n    3.  Retrieve the organization **User Email** that will send the emails through the application by **Search > Users**. Select **Services > Users**, select your authorized user, and then collect their **User Email** from their properties.\n        \n7.  Navigate to Auth0 [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n8.  Activate the **Use my own email provider** toggle.\n    \n9.  Click the **Microsoft 365** logo.\n    \n10.  Provide the **From** email address. Then, enter the **Tenant ID**, **Client ID**, and **Client Secret** from step 6, and then click **Save**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/1oXnSH0aPoGN5uDP6WDJNp/0d3b14e8530630215761c9b57bdc28b8/2024-02-29_13-53-34.png)\n\n## Send a test email\n\nSend a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email.\n\nIf you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for error codes. The Microsoft Exchange [Email Usage](https://admin.microsoft.com/#/reportsUsage/EmailActivity) page will now display delivery insights for all emails that have been sent to your users.",
  "title": "Configure Microsoft 365 Exchange Online as External SMTP Email Provider",
  "description": "Describes how to configure 365 Exchange Online as an SMTP email provider with Auth0. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/actions/get-actions",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/customize/email/configure-a-custom-email-provider/action-triggers-custom-email-provider-event-object",
  "markdown": "# Action Triggers: custom-email-provider Event Object\n\nThe `event` object for the `custom-email-provider` Actions trigger provides contextual information about email data.\n\n| Property | Description |\n| --- | --- |\n| `event.client` | Information about the Client with which this login transaction was initiated.<br><br>Includes the following properties:<br><br>*   `client_id` _String_. The client ID of the application the user is logging in to.<br>*   `metadata` _Dictionary_. An object for holding other application properties.<br>*   `name` _String_. The name of the application (as defined in the Dashboard). |\n| `event.connection`<br><br>_(Optional)_ | Details about the Connection that was used to authenticate the user.<br><br>Includes the following properties:<br><br>*   `id` _String_. The connection's unique identifier.<br>*   `metadata` _Optional dictionary_. Metadata associated with the connection.<br>*   `name` _String_. The name of the connection used to authenticate the user (such as `twitter` or `some-g-suite-domain`).<br>*   `strategy` _String_. The type of connection. For social connections, `event.connection.strategy === event.connection.name`. For enterprise connections, the strategy is `waad` (Windows Azure AD), `ad` (Active Directory/LDAP), `auth0` (database connections), and so on. |\n| `event.notification` | Includes the following properties:<br><br>*   `html` _String_. Rendered HTML template.<br>*   `locale` _String_. The locale we rendered the message in, for example `en_US`, as defined in the BCP-47 specification.<br>*   `message_type` _String_.<br>    <br>    The type of message that is being send, like `verify_email` or `welcome_email`.<br>    <br>    Possible values include:<br>    <br>    *   `verify_email`<br>    *   `verify_email_by_code`<br>    *   `reset_email`<br>    *   `welcome_email`<br>    *   `verification_code`<br>    *   `mfa_oob_code`<br>    *   `enrollment_email`<br>    *   `blocked_account`<br>    *   `stolen_credentials`<br>    *   `try_provider_configuration_email`<br>    *   `organization_invitation`<br>*   `text` _String_. Rendered text template.<br>*   `to` _String_. Email address of the recipient. |\n| `event.organization`<br><br>_(Optional)_ | Details about the Organization associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `display_name` _String_. The friendly name of the Organization.<br>*   `id` _String_. The Organization identifier.<br>*   `metadata` _Dictionary_. Metadata associated with the Organization.<br>*   `name` _String_. The name of the Organization. |\n| `event.request` | Includes the following properties:<br><br>*   `geoip` _Optional object_.<br>    <br>    Includes the following properties:<br>    <br>    *   `countryCode` _Optional string_.<br>*   `ip` _Optional string_. The originating IP address of the request.<br>*   `user_agent` _Optional string_. The value of the `User-Agent` header received when initiating the transaction. |\n| `event.tenant` | Includes the following properties:<br><br>*   `friendly_name` _Optional string_. The friendly name for the tenant, usually a more human-readable version of the ID.<br>*   `home_url` _Optional string_. The home URL for the tenant, if defined and as found in its settings.<br>*   `id` _String_. The name of the tenant.<br>*   `logo_url` _Optional string_. The logo URL for the tenant, if defined and as found in its settings.<br>*   `support_email` _Optional string_. The email to the tenant's support service, if defined and as found in its settings.<br>*   `support_url` _Optional string_. The url to the tenant's support service, if defined and as found in its settings. |\n| `event.user` | An object describing the user on whose behalf the current transaction was initiated.<br><br>Includes the following properties:<br><br>*   `app_metadata` _Dictionary_. Custom fields that store information about a user that influences the user's access, such as support plan, security roles, or access control groups.<br>*   `email` _Optional string_. (unique) User's email address.<br>*   `email_verified` _Boolean_. Indicates whether the user has verified their email address.<br>*   `family_name` _Optional string_. User's family name.<br>*   `given_name` _Optional string_. User's given name.<br>*   `name` _Optional string_. User's full name.<br>*   `nickname` _Optional string_. User's nickname.<br>*   `picture` _Optional string_. URL pointing to the [user's profile picture](https://auth0.com/docs/users/change-user-picture).<br>*   `user_id` _String_. (unique) User's unique identifier.<br>*   `user_metadata` _Dictionary_. Custom fields that store information about a user that does not impact what they can or cannot access, such as work address, home address, or user preferences.<br>*   `username` _Optional string_. (unique) User's username. |\n\n## Learn more\n\n*   [Configure a Custom Email Provider](https://auth0.com/docs/customize/email/configure-a-custom-email-provider)\n*   [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action)\n*   [Understand How Auth0 Actions Work](https://auth0.com/docs/customize/actions/actions-overview)\n*   [Action Coding Guidelines](https://auth0.com/docs/customize/actions/action-coding-guidelines)\n*   [Actions Limitations](https://auth0.com/docs/customize/actions/limitations)",
  "title": "Action Triggers: custom-email-provider Event Object",
  "description": "Learn about the custom-email-provider Action trigger's event object, which provides contextual information about the message data.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/custom-domains/get-custom-domains",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl",
  "markdown": "# TLS (SSL) Versions and Ciphers\n\nAuth0’s network edge has a secure set of allowed SSL/TLS version/cipher suite combinations. When connecting to Auth0 services using a reverse proxy with self-managed certificates, you **must** use a supported TLS version and cipher suite. During the TLS handshake, communication between the server and client specifies the TLS version and cipher suite. If you are not using a supported version, a failure could occur.\n\n## Supported Versions\n\nAuth requires using TLS version 1.2 or 1.3 with the supported ciphers.\n\n#### TLS 1.3 Supported Ciphers\n\nAEAD-AES128-GCM-SHA256  \nAEAD-AES256-GCM-SHA384  \nAEAD-CHACHA20-POLY1305-SHA256  \n\n#### TLS 1.2 Supported Ciphers\n\nECDHE-ECDSA-AES128-GCM-SHA256  \nECDHE-ECDSA-CHACHA20-POLY1305  \nECDHE-RSA-AES128-GCM-SHA256  \nECDHE-RSA-CHACHA20-POLY1305  \nECDHE-ECDSA-AES128-SHA256  \nECDHE-ECDSA-AES128-SHA  \nECDHE-RSA-AES128-SHA256  \nECDHE-RSA-AES128-SHA  \nAES128-GCM-SHA256  \nAES128-SHA256  \nAES128-SHA  \nECDHE-ECDSA-AES256-GCM-SHA384  \nECDHE-ECDSA-AES256-SHA384  \nECDHE-RSA-AES256-GCM-SHA384  \nECDHE-RSA-AES256-SHA384  \nECDHE-RSA-AES256-SHA  \nAES256-GCM-SHA384  \nAES256-SHA256  \nAES256-SHA  \n\n#### TLS RFCs\n\n[TLS 1.2](https://tools.ietf.org/html/rfc5246)[](https://tools.ietf.org/html/rfc8446)\n\n[TLS 1.3](https://tools.ietf.org/html/rfc8446)\n\n#### TLS Parameters\n\nTo learn more, read [Transport Layer Security (TLS) Parameters](https://www.iana.org/assignments/tls-parameters) for the Internet Assigned Numbers Authority (IANA) list of registered parameters including ciphers.\n\n## Learn more\n\n*   [Configure Cloudflare as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)",
  "title": "TLS (SSL) Versions and Ciphers",
  "description": "Check supported TLS versions and ciphers if you are using a reverse proxy configured for use with self-managed certificates",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/connection-security",
  "markdown": "# Custom Database Connection Security Best Practices\n\n## Access legacy identity storage via custom API\n\nWe recommend that you implement an API to provide least privilege to your legacy identity storage rather than simply opening up general access via the internet.\n\nProtecting legacy identity storage from general access is a recommended best practice. Exposing a (legacy identity) database directly to the internet, for example, can be extremely problematic: database interfaces for SQL and the like are extremely open in terms of functionality, which violates the principle of least privilege when it comes to security.\n\nThe alternative is to create a simple (custom) API—protected via use of an access token—that each action script can call. This would act as the interface to the legacy identity store. Client credentials grant flow can then be used to obtain an access token from within a script, and this can be subsequently cached for re-use within the `global` object to improve performance. The API can then provide a discrete number of protected endpoints that perform only the legacy (identity) management functionality required (e.g., read user, change password).\n\nBy default, Auth0 will give you a token for any API if you authenticate successfully and include the appropriate audience. Restricting access to the legacy identity store API by restricting access token allocation via the use of a rule will prevent unauthorized usage and will mitigate a number of attack vector scenarios, such as where redirect to `/authorize` is intercepted and the audience to the API is added.\n\n## Access to legacy identity storage\n\nWhether managing access to legacy identity storage via custom API or using the native interface provided, you should restrict access to the list of IP addresses associated with your Auth0 tenant. To see the list of IP addresses, read [Auth0 IP Addresses for AllowLists](https://auth0.com/docs/secure/security-guidance/data-security/allowlist). Adding URLs to the AllowList constrains access to the legacy identity store and ensures that only custom database actions scripts defined in Auth0 are permitted.\n\n## Learn more\n\n*   [Secure](https://auth0.com/docs/secure)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Custom Database Connection Security Best Practices",
  "description": "Learn about best practices for custom database connection security.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-atlassian",
  "markdown": "# Configure Atlassian as SAML Service Provider\n\nUse the following SAML configuration for Atlassian.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** from **SP Assertion Consumer Service URL** in the [Atlassian Admin dashboard](https://admin.atlassian.com/).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n      \"mappings\": {\n        \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"given_name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n        \"family_name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\"\n      },\n      \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n      ],\n      \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:2.0:nameid-format:email\"\n    }\n    ```\n    \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider (IdP).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Atlassian as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Atlassian. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-akamai-for-use-as-reverse-proxy",
  "markdown": "# Configure Akamai as Reverse Proxy\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nTo set up an Akamai product as a reverse proxy, complete the following:\n\n1.  Verify the ownership of your custom domain. To learn more, read [Verify Ownership](https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates#verify-ownership).\n    \n2.  Go to [Dashboard > Settings > Custom Domains](https://manage.auth0.com/#/tenant/custom_domains) to gather the distribution, origin custom header, origin hostname, and default cache behavior settings. Then, use this information to update your Akamai custom domain settings to point to the reverse proxy server domain. To learn more, read [Configure reserve proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates#configure-reverse-proxy).\n    \n3.  Update the custom domain client IP header using the Management API PATCH  `/api/v2/custom-domains/{id}` endpoint as below:\n    \n    ```\n    { \n    \"custom_client_ip_header\": \"true-client-ip\" \n    }\n    ```\n    \n    To learn more, read [Update custom domain configuration](https://auth0.com/docs/api/management/v2#!/Custom_Domains/patch_custom_domains_by_id).\n\nFor details on how to configure Akamai as a reverse proxy using the information above, refer to Akamai documentation or customer support.\n\n## Learn more\n\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)",
  "title": "Configure Akamai as Reverse Proxy",
  "description": "Learn how to set up Akamai for use as the custom domain proxy for Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-datadog",
  "markdown": "# Configure Datadog as SAML Service Provider\n\nUse the following SAML configuration for Datadog.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://app.datadoghq.com/account/saml/assertion`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://app.datadoghq.com/account/saml/metadata.xml\",\n           \"mappings\": {\n           },\n           \"createUpnClaim\":       false,\n           \"passthroughClaimsWithNoMapping\": false,\n           \"mapUnknownClaimsAsIs\": false,\n           \"mapIdentities\":        false,\n           \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n           \"nameIdentifierProbes\": [\n         \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n           ],\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider (IdP).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Datadog as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Datadog. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-cisco-webex",
  "markdown": "# Configure Cisco WebEx as SAML Service Provider\n\nUse the following SAML configuration for Cisco WebEx.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL.** Note that Webex has an option to automatically provision new users. You will need to send that information as claims (`lastname`, and so on). If you integrate Auth0 with Cisco Spark services, read [Single Sign-On with Cisco Spark Services](https://collaborationhelp.cisco.com/article/en-us/lfu88u).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n           \"mappings\": {\n         \"email\": [\"email\", \"uid\", \"Name_ID\"]\n           },\n          \"createUpnClaim\":       false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\":        false,\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n          \"nameIdentifierProbes\": [\n         \"email\",\n           ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider in Cisco WebEx.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Cisco WebEx as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Cisco WebEx.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-egencia",
  "markdown": "# Configure Egencia as SAML Service Provider\n\nUse the following SAML configuration for Egencia.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://www.egencia.com/auth/v1/artifactConsumer`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://{yourAccountName}.egencia.com\",\n           \"mappings\": {\n           },\n           \"createUpnClaim\":       false,\n           \"passthroughClaimsWithNoMapping\": false,\n           \"mapUnknownClaimsAsIs\": false,\n           \"mapIdentities\":        false,\n           \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n           \"nameIdentifierProbes\": [\n         \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n           ],\n        }\n    ```\n    \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider (IdP).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Egencia as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon  for Egencia.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-idp-for-google-g-suite",
  "markdown": "# Configure Google Workspace as SAML Service Provider\n\nUse the following SAML configuration for Google Workspace.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://www.google.com/a/{YOUR-GOOGLE-DOMAIN}/acs`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://www.google.com/a/{yourGoogleDomain}/acs\",\n          \"mappings\": {\n        \"nickname\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\",\n          },\n          \"createUpnClaim\": false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\": false,\n          \"signatureAlgorithm\": \"rsa-sha256\",\n          \"digestAlgorithm\": \"sha256\",\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:2.0:nameid-format:email\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n          ],\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider (IdP).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Google Workspace as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App for Google Workspace.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-litmos",
  "markdown": "# Configure Litmos as SAML Service Provider\n\nUse the following SAML configuration for Litmos.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://{yourDomain}.litmos.com/integration/samllogin`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"mappings\": {\n           \"user_id\":     \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n           \"email\":       \"Email\",\n           \"given_name\":  \"FirstName\",\n           \"family_name\": \"LastName\"\n         },\n         \"createUpnClaim\":       false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\":        false,\n         \"signatureAlgorithm\":   \"rsa-sha1\",\n         \"digestAlgorithm\":      \"sha1\",\n         \"destination\":          \"https://{yourDomain}.litmos.com/integration/samllogin\",\n         \"lifetimeInSeconds\":    3600,\n         \"signResponse\":         false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n         ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Litmos as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Litmos.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-pluralsight",
  "markdown": "# Configure Pluralsight as SAML Service Provider\n\nUse the following SAML configuration for Pluralsight.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://prod-pf.pluralsight.com/sp/ACS.saml2`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\":  \"www.pluralsight.com\",\n          \"mappings\": {\n        \"user_id\":     \"id\",\n        \"email\":       \"email\",\n        \"given_name\":  \"firstName\",\n        \"family_name\": \"lastName\"\n          },\n          \"createUpnClaim\":       false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\":        false,\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n          ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Pluralsight as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Pluralsight.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-freshdesk",
  "markdown": "# Configure Freshdesk as SAML Service Provider\n\nUse the following SAML configuration for Freshdesk.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://{FD Domain}.freshdesk.com/login/saml`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n    1.  It can be found at: **Freshworks Dashboard > Security > SAML SSO > Assertion Consumer Service(ACS) URL**\n        \n    2.  The audience can be found at: **Freshworks Dashboard > Security > SAML SSO > Service Provider(SP) Entity ID URL**\n        \n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://{FD Domain}.freshworks.com/sp/SAML/{xxxxxxxxxxxxxxxxxxx}/metadata\",\n          \"mappings\": {\n        \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n        \"given_name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n        \"family_name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\"\n          },\n          \"createUpnClaim\": false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\": false,\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n          ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Freshdesk as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Freshdesk.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-hosted-graphite",
  "markdown": "# Configure Hosted Graphite as SAML Service Provider\n\nUse the following SAML configuration for Hosted Graphite.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://www.hostedgraphite.com/complete/saml/{yourUserId}/`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://www.hostedgraphite.com/metadata/{yourUserId}/\",\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n          ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Hosted Graphite as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Hosted Graphite.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-online",
  "markdown": "# Configure Tableau Online as SAML Service Provider\n\nUse the following SAML configuration for Tableau Online.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://sso.online.tableau.com/public/sp/SSO/{yourTableauAlias}`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"audience\":  \"https://sso.online.tableau.com/public/sp/metadata?alias={yourTableauAlias}\",\n         \"recipient\": \"https://sso.online.tableau.com/public/sp/SSO/{yourTableauAlias}\",\n         \"mappings\": {\n        \"email\": \"Email\"\n         },\n         \"createUpnClaim\":       false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\":        false,\n         \"signatureAlgorithm\":   \"rsa-sha256\",\n         \"digestAlgorithm\":      \"sha256\",\n         \"destination\":          \"https://sso.online.tableau.com/public/sp/SSO/{yourTableauAlias}\",\n         \"lifetimeInSeconds\":    3600,\n         \"signResponse\":         false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n         ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Tableau Online as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Tableau Online.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-sprout-video",
  "markdown": "# Configure Sprout Video as SAML Service Provider\n\nUse the following SAML configuration for Sprout Video.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** that you can obtain from your Sprout Video settings. It will typically be something like: `https://app.sproutvideo.com/auth/sso/consumption`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"audience\":  \"https://{yourSproutVideoAccount}.vids.io\",\n         \"mappings\": {  \n           \"user_id\":     \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n           \"email\":       \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n         },\n         \"createUpnClaim\":       false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\":        false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n         ],\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Sprout Video as SAML Service Provider",
  "description": "Describes how to configure Auth0 to serve as an identity provider for Sprout Video.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workday",
  "markdown": "# Configure Workday as SAML Service Provider\n\nUse the following SAML configuration for Workday.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://impl.workday.com/<tenant>/login-saml.htmld`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"http://www.workday.com\",\n          \"recipient\": \"https://www.myworkday.com/<tenant>/login-saml.htmld\",\n          \"mappings\": {\n          },\n          \"createUpnClaim\":       false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\":        false,\n          \"signResponse\":         true,\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n          ],\n          \"authnContextClassRef\": \"urn:oasis:names:tc:SAML:2.0:ac:classes:X509\",\n        }\n    ```\n    \n    Change the subdomain `impl` depending on the Workday data center you are using.\n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Workday as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Workday.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-server",
  "markdown": "# Configure Tableau Server as SAML Service Provider\n\nUse the following SAML configuration for Tableau Server.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `http://{yourTableauServer}/wg/saml/SSO/index.html`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"audience\":  \"{yourTableauAudience}\",\n         \"recipient\": \"http://{yourTableauServer}/wg/saml/SSO/index.html\",\n         \"mappings\": {\n        \"email\": \"username\"\n         },\n         \"createUpnClaim\":       false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\":        false,\n         \"signatureAlgorithm\":   \"rsa-sha1\",\n         \"digestAlgorithm\":      \"sha1\",\n         \"destination\":          \"http://{yourTableauServer}/wg/saml/SSO/index.html\",\n         \"lifetimeInSeconds\":    3600,\n         \"signResponse\":         false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n         ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Tableau Server as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using SAML2 Web App addon for Tableau Server.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workpath",
  "markdown": "# Configure Workpath as SAML Service Provider\n\nUse the following SAML configuration for Workpath.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://api.workpath.com/v1/saml/assert/{yourWorkpathSubdomain}`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://api.workpath.com/v1/saml/metadata/{yourWorkpathSubdomain}\",\n          \"mappings\": {\n        \"email\": \"email\",\n        \"given_name\": \"first_name\",\n        \"family_name\": \"last_name\"\n          }\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
  "title": "Configure Workpath as SAML Service Provider",
  "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Workpath.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connector/modify",
  "markdown": "# Point AD/LDAP Connector to Auth0 Connections\n\nYou may need to point your AD/LDAP Connector instance to a new connection in Auth0, for example, If you have migrated to a new Auth0 tenant, or if you changed the name of the Auth0 connection. Because you can't rename connections in Auth0, you must create a new AD/ LDAP connection and point your existing Connector instances to it.\n\n1.  Create the new AD/LDAP connection in the Auth0 dashboard and copy the resulting **TICKET URL**. If you are using the custom domains, you will need to replace the `{yourDomain}` part of the **TICKET URL** with your custom domain, such as `identity.fabrikam.com`.\n    \n2.  On the AD/LDAP Connector host in the Connector Admin app, perform an export of the existing settings via the **Import / Export** tab. This is just a precaution in case something were to happen in the following steps that would accidentally overwrite your custom settings. If you are running the Connector on a host that does not have a web browser to access to the Connector Admin website, simply make a copy of your `config.json` file.\n    \n3.  On the AD/LDAP Connector host, edit the `config.json` file and change the value of the `PROVISIONING_TICKET` property to the **TICKET URL** you copied in Step 1.\n    \n4.  If you moved from one Auth0 tenant to another, remove the property in the `config.json` file that has the name `urn:auth0:{oldAuth0TenantName}`. If this is not removed, the Connector will still function but this old configuration data is not needed.\n    \n5.  Restart the AD/LDAP Connector service (the **Auth0 ADLDAP** service in Windows).\n    \n6.  Take a look at the Connector logs (**Troubleshooting** tab in the Connector Admin tool or tail the `logs.log` file) and make sure there is a recent entry that looks something like: `2016-03-10T22:47:32.970Z - debug: [2016-03-10 22:47:32] Loading settings from ticket: {yourTicketUrl}/info`\n    \n7.  Make sure the new AD/LDAP connection in the Auth0 dashboard is now showing as connected (the dot to the left of the new connection is green and not red).\n    \n8.  Perform a test authentication through your new connection and make sure you see activity in your Connector logs as well.\n    \n\n## Learn more\n\n*   [Troubleshoot AD/LDAP Connector](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-ad-ldap-connector)",
  "title": "Point AD/LDAP Connector to Auth0 Connections",
  "description": "Describes how to point AD/LDAP Connector instances to a new connections in Auth0. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/logout/back-channel-logout/configure-back-channel-logout",
  "markdown": "# Configure OIDC Back-Channel Logout\n\n## Availability\n\nOIDC Back-Channel Logout is available for all Enterprise plan customers. You should check the OIDC standard `/.well-known/*` metadata endpoint to determine if your application meets the requirements.\n\n```\nGET https://acme.eu.auth0.com/.well-known/openid-configuration\n\nHTTP 200\n{ ..., \"backchannel_logout_supported\": true, \n  \"backchannel_logout_session_supported\": true }\n```\n\n## Back-Channel Logout restrictions\n\nBack-Channel Logout URLs are called on publicly-exposed endpoints and must adhere to certain restrictions:\n\n1.  You must use the HTTPS protocols. Unencrypted HTTP or other protocols are not permitted.\n    \n2.  You must not use Auth0 subdomains. Some Auth0 subdomains are:\n    \n    *   auth0.com\n        \n    *   auth0app.com\n        \n    *   webtask.io\n        \n    *   webtask.run\n        \n3.  We do not recommend using IP addresses without domains. IP addresses must be public IPs to use Back-Channel Logout. IP addresses from internal, reserved, or loopback ranges are not permitted.\n    \n\n## Configure Auth0\n\nRegister your application to receive Logout Tokens via Auth0 Dashboard or Management API.\n\n#### Subscribe applications\n\n1.  Navigate to [**Auth0 Dashboard > Applications**](https://manage.auth0.com/#/applications).\n    \n2.  Choose the application you want to register.\n    \n3.  Select the **Settings** tab.\n    \n4.  Under the **OpenID Connect Back-Channel Logout > Back-Channel Logout URI**, add the application logout URI that will receive the logout\\_tokens\n    \n5.  Once complete, select **Save Changes**.\n    \n    ![Auth0 Dashboard > Applications > Settings](https://images.ctfassets.net/cdy7uua7fh8z/19uQRkVswdmaO8gHTVTXCc/012f80894579d766a4263612018f9c39/back-channel-logout-dashboard.png)\n\n#### Unsubscribe applications\n\nUnsubscribing your application stops the service from tracking new logins and sending logout events. The service discards pending logout events once your application is unsubscribed.\n\nTo unsubscribe your application, delete the back-channel logout URL.\n\n1.  Navigate to [Auth0 Dashboard > Applications](http://manage.auth0.com/#/applications).\n    \n2.  Choose the application you want to register.\n    \n3.  Select the **Settings** tab.\n    \n4.  Under the **OpenID Connect Back-Channel Logout > Back-Channel Logout URI**\n    \n5.  Remove the back-channel URL.\n    \n6.  Once complete, select **Save Changes**.\n    \n    ![Auth0 Dashboard > Applications > Settings](https://images.ctfassets.net/cdy7uua7fh8z/5SlrBhwrNbJx0Wdw2kQ19t/48c4d897090e424dc1b5da5c91674876/back-channel-logout-dashboard.png)\n\nFor auditing purposes, the service always logs subscribing or unsubscribing back-channel logout URLs as `API Operation Event` in Auth0 tenant logs. To learn more, read [Logs](https://auth0.com/docs/deploy-monitor/logs).\n\n![Auth0 Dashboard > Monitoring > Logs](https://images.ctfassets.net/cdy7uua7fh8z/66sFzlAX2427dKMquiL9cQ/fd7a69aa960e37b90a876ff879b73a0e/2023-05-30_17-44-21.png)\n\n## Configure your application\n\nOnce you have configured Back-Channel Logout via the Auth0 Dashboard or Management API, configure your application to use the service based on the technology or framework.\n\n1.  Implement end-user authentication according to your application type. \n    \n    1.  End-users should be able to log in to the application, and a session should be created. \n        \n    2.  An ID token should be issued from Auth0 and should be accessible in the application backend for further processing.\n        \n2.  Extend the login process to save the `sid` and, optionally, sub claims after the ID token is validated. \n    \n    1.  These claims must be saved against the current application session. \n        \n    2.  The session management functions should be able to retrieve a specific session by the `sid` value.\n        \n3.  Configure the Back-Channel Logout endpoint:\n    \n    1.  The endpoint must process only `HTTP POST` requests.\n        \n    2.  Extract the `logout_token` parameter and validate it as a regular JWT according to the spec.\n        \n    3.  Verify that the token contains an events claim with a JSON object value and a member named `http://schemas.openid.net/event/backchannel-logout`.\n        \n    4.  Verify that the token contains the `sid` and/or `sub` claims.\n        \n    5.  Verify that the token does NOT contain the `nonce` claim. This is required to prevent abuse by distinguishing the Logout Token from the ID token.\n        \n    6.  Once the token is validated, retrieve the session corresponding to the received `sid` and/or `sub` value and terminate it. The exact application session termination process depends on the implementation details. For example, this event may need to be communicated to the front-end.\n        \n\n## OIDC Back-Channel Logout request example\n\nCoded token payload:\n\n```\nPOST /backchannel-logout HTTP/1.1\nHost: rp.example.org\nContent-Type: application/x-www-form-urlencoded\n\nlogout_token=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImdwY3ZFT0FPREE2T3pXRmw3ODVxbCJ9.eyJpc3MiOiJodHRwczovL2FydGV4LWRldi5ldS5hdXRoMC5jb20vIiwic3ViIjoiYXV0aDB8NjAyZTkzZGI4M2ZhNmYwMDc0OWEyM2U2IiwiYXVkIjoiVHVoTkx2N3VsWEQzUmZ5TGxTTWJPdnN6endKSkZQcE8iLCJpYXQiOjE2OTgxNjA5MjgsImV4cCI6MTY5ODE2MTA0OCwianRpIjoiNDRhOTEyMTUtZGZiNC00ZGZlLWExZWItZmNhZmE5MTFkZWJhIiwiZXZlbnRzIjp7Imh0dHA6Ly9zY2hlbWFzLm9wZW5pZC5uZXQvZXZlbnQvYmFja2NoYW5uZWwtbG9nb3V0Ijp7fX0sInRyYWNlX2lkIjoiODFiMzM2YTk0YTRhNTcwNyIsInNpZCI6IjM3NVVJcF9JRDVtQ1RDbEllQkVIcFhmR3dxNTF0Rl9MIn0.aEoAL_U-EPlf3f7Fup-bu7Yv0S0GOnrkL8Njd6j6UNqZcr5VrWWFf3CWvkRi7Cm6wMgU2qIMhb7643ca8-ajR7zHlMu0Z3r-gfd2D1xudKLyUSC3v2D5WJZz5I8xMZ_LWtIN2W3l4SQFO9MgK_7F3x0WIWXo9KPC9tgOaOLPnsiv__MutM1ZakoCsJPddl5gVM4TYtHOue6WM7SOXZNa3SSiv57YQOX2KNCL7sWmZp_J1OXKy8lsgkNFqiOVwu39p4sgjKYEXQU0G-I0yY_aeNbnlnxFG6OuxaDt_zwg6AvKglLSNGqrrvzy4GsYJi5HMGZ1GsSs7rQLg7Iuu6JM-A\n```\n\nDecoded token payload:\n\n```\n{\n  \"iss\": \"https://artex-dev.eu.auth0.com/\",\n  \"sub\": \"auth0|602e93db83fa6f00749a23e6\",\n  \"aud\": \"TuhNLv7ulXD3RfyLlSMbOvszzwJJFPpO\",\n  \"iat\": 1698160928,\n  \"exp\": 1698161048,\n  \"jti\": \"44a91215-dfb4-4dfe-a1eb-fcafa911deba\",\n  \"events\": {\n    \"http://schemas.openid.net/event/backchannel-logout\": {}\n  },\n  \"trace_id\": \"81b336a94a4a5707\",\n  \"sid\": \"375UIp_ID5mCTClIeBEHpXfGwq51tF_L\"\n}\n```\n\n## Expected responses\n\n*   **HTTP 200**:  Confirms user logout from the specific application.\n    \n*   **HTTP 400**: Indicates an incorrect request. The request is not understood or the token failed validation. Auth0 records the problem in tenant logs but does not attempt further requests for this specific session.\n    \n\n## Troubleshoot issues\n\n### Application did not receive the logout events\n\nIf your application did not receive a logout request after a logout event.\n\n1.  Make sure your application has a Back-Channel Logout URL registered in Auth0 Dashboard.\n    \n2.  Ensure the Back-Channel Logout URL is reachable from the Auth0 tenant.\n    \n3.  Ensure a valid session is established. The end-user must log in to your specific application via Auth0.\n    \n4.  Check Auth0 tenant logs for messages about unsuccessful logout message delivery.\n    \n    ![Auth0 Dashboard > Monitoring > Logs](https://images.ctfassets.net/cdy7uua7fh8z/3INGdmv1w9H4yiERpsHPsz/9472b517200e4ac8e612be9916e08632/2023-10-02_10-48-29.png)\n5.  Make sure the logout is triggered via the standard logout endpoint. Other events do not trigger the logout events.\n    \n6.  If possible, check for blocked requests on the web server and/or application firewall logs.\n    \n\n#### I can't find OIDC Back-Channel Logout tenant logs\n\nThis feature will be gradually released to all tenants starting 3 October 2023. You may still receive [tenant log event codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes) `sslo` for `oidc_backchannel_logout_succeeded` or `fslo` for `oidc_backchannel_logout_failed`.\n\n### Client app cannot verify the received Logout Token\n\nIf the transaction still fails with a 400 error:\n\n1.  Check if the token is a standard base64-encoded JWT. Some web servers may truncate long parameters. To learn more, read [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms).\n    \n2.  If possible, capture a token and verify that it’s a JWT. Use a verified source, like [JWT.IO](http://jwt.io/).\n    \n3.  Make sure the verification function fetches the tenant signing key dynamically via [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets) (JWKS).\n    \n\n### Response Timeout Errors\n\nAuth0 will wait five seconds for the application OIDC Back-Channel Logout URL to respond. After this time, it will record a \"Failed OIDC Back-Channel Logout request\" in the tenant logs with an empty response description.\n\n## Learn more\n\n*   [Check Login and Logout Issues](https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues)\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)",
  "title": "Configure OIDC Back-Channel Logout",
  "description": "Describes how to configure OIDC back-channel logout with your Auth0 services.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/logout/back-channel-logout/oidc-back-channel-logout-initiators",
  "markdown": "# OIDC Back-Channel Logout Initiators\n\nOIDC Back-Channel Logout Initiators allow you to remotely log out users from their applications based on session termination events. OIDC Back-Channel Logout Initiators work across protocols—for example, an identity provider\\-initiated (IdP-initiated) SAML logout request—and are unaffected by third-party cookie restrictions.\n\nThis feature is an extension to the standard OIDC back-channel specification. You can configure it to initiate an OIDC Back-Channel Logout request for specific session termination events, such as a password change or session expiration, or for all session termination events.\n\nAdministrators can enable this feature for specific applications with the Auth0 Management API.\n\n## How OIDC Back-Channel Logout Initiators work\n\nInitiators bind an OIDC Back-Channel Logout response to a session termination event. They capture the event and use it to trigger an OIDC logout token in all applications associated with the given session.\n\nThe following diagram illustrates how an OIDC Back-Channel Logout Initiator works for a password change event:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/2GwtCTwecxYONxL1DbewxO/b504426017276605735ab59dc3242794/OIDC_Back-Channel_Logout_Initiators_Diagram.png)\n\n## Configure OIDC Back-Channel Logout Initiators\n\nYou can configure OIDC Back-Channel Logout Initiators with the Auth0 Management API.\n\n### Management API\n\nYou can configure the OIDC Back-Channel Logout Initiators for an application with the Management API by using the [Update a Client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id) endpoint.\n\n1.  Get an [Management API access token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) with the `update:clients` scope.\n    \n2.  Call the [Update a Client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id) endpoint with the appropriate configuration data in the payload. For example, to log out an application after a password change event, provide the following:\n    \n    to configure this snippet with your account\n    \n    ```\n    PATCH /api/v2/clients/{yourClientId}\n    {\n      ...\n      \"oidc_logout\": {\n        \"backchannel_logout_urls\": [\"https://example.com/cb\"]\n        \"backchannel_logout_initiators\": {\n          \"mode\":\"custom\",\n          \"selected_initiators\": [\"rp-logout\", \"idp-logout\", \"password-changed\"]\n        }\n      }\n      ...\n    }\n    ```\n    \n\n#### Properties\n\nThe `backchannel_logout_initiators` object supports the following properties:\n\n| **Property** | **Type** | **Required?** | **Description** | **Supported values** |\n| --- | --- | --- | --- | --- |\n| `mode` | string | Required | Configuration method for enabling initiators. | `custom`, `all` |\n| `selected_initiators` | array | Required if `mode` is `custom` | List of initiators to enable. | `rp-logout`, `idp-logout`, `password-changed`, `session-expired`, `session-revoked`, `account-deleted`, `email-identifier-changed` |\n\n##### mode property\n\nThe `mode` property determines the configuration method for enabling initiators.\n\nBy default, it is set to `custom`, which allows you to specify which initiators you want to enable. If you want your application to logout anytime the IdP session ends, set it to `all`.\n\nThe `mode` property supports the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `custom` | Enables only the initiators listed in the `selected_initiators` array. |\n| `all` | Automatically enables all current and future initiators. |\n\n##### selected\\_initiators property\n\nThe `selected_initiators` property contains the list of initiators to be enabled for the given application.\n\nThe `selected_initiators` property supports the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `rp-logout` | Request was initiated by a relying party (RP). |\n| `idp-logout` | Request was initiated by an external identity provider (IdP). |\n| `password-changed` | Request was initiated by a password change. |\n| `session-expired` | Request was initiated by session expiration. |\n| `session-revoked` | Request was initiated by session deletion. |\n| `account-deleted` | Request was initiated by an account deletion. |\n| `email-identifier-changed` | Request was initiated by an email identifier change. |\n\n#### Examples\n\n##### Subscribe an application to all current and future initiators\n\nto configure this snippet with your account\n\n```\nPATCH /api/v2/clients/{yourClientId}\n\n{\n  ...\n  \"oidc_logout\": {\n    \"backchannel_logout_urls\": [\"https://example.com/cb\"]\n    \"backchannel_logout_initiators\": {\n      \"mode\":\"all\"\n    }\n  }\n  ...\n}\n```\n\n##### Subscribe an application to password-changed initiator only (rp-logout and idp-logout are required)\n\nto configure this snippet with your account\n\n```\nPATCH /api/v2/clients/{yourClientId}\n\n{\n  ...\n  \"oidc_logout\": {\n    \"backchannel_logout_urls\": [\"https://example.com/cb\"]\n    \"backchannel_logout_initiators\": {\n      \"mode\":\"custom\",\n      \"selected_initiators\": [\"rp-logout\", \"idp-logout\", \"password-changed\"]\n    }\n  }\n  ...\n}\n```\n\n##### Unsubscribe all initiators (rp-logout remains the default)\n\nto configure this snippet with your account\n\n```\nPATCH /api/v2/clients/{yourClientId}\n\n{\n  ...\n  \"oidc_logout\": {\n\t  \"backchannel_logout_urls\": [\"https://example.com/cb\"]\n  }\n  ...\n}\n```\n\n### Dashboard\n\nOpenID Connect Back-Channel Logout can be configured alongside the rest of your application settings. This feature automatically activates once a Back-Channel Logout URI is provided.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/vgN0wudP38zgRZNL59Mhy/99349b00a02fee72fe48e62935485f0c/OIDC_Back-Channel_Logout_Initiators_-_Dashboard.png)\n\n#### Selected initiators only\n\nOnly the required initiators (`rp-logout` and `idp-logout`) will be subscribed to by default. Any additional initiators, including any added in the future, must first be selected before they can initiate a logout from your application.\n\nSelect this option if you want your application to log out only for initiators you select.\n\n#### All supported initiators\n\nAll supported initiators, including any added in the future, will be subscribed to by default.\n\nSelect this option if you want your application to log out any time the IdP session ends.",
  "title": "OIDC Back-Channel Logout Initiators",
  "description": "Learn how OIDC Back-Channel Logout Initiators work and how to configure them for your application(s).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-lock",
  "markdown": "# GDPR: Track Consent with Lock\n\nIn this tutorial, we will see how you can use Lock to ask for consent information, and then save this input in the user's metadata. To learn more, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata).\n\nIf you would instead like to track consent using a custom UI, see [GDPR: Track Consent with Custom UI](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-custom-ui).\n\nThe contents of this document are **not** intended to be legal advice, nor should they be considered a substitute for legal assistance. The final responsibility for understanding and complying with GDPR resides with you, though Auth0 will assist you in meeting GDPR requirements where possible.\n\n## Overview\n\nWe will configure a simple JavaScript Single-Page Application and a database connection (we will use Auth0's infrastructure, instead of setting up our own database).\n\nInstead of building an app from scratch, we will [use Auth0's JavaScript Quickstart sample](https://auth0.com/docs/quickstart/spa/vanillajs). We will also use Auth0's Universal Login pages so we can implement a Universal Login experience, instead of embedding the login in our app. To learn more about Universal Login, read [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). To learn more about the differences between Universal Login and embedded login, read [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\nWe will capture consent information, under various scenarios, and save this at the user's metadata.\n\nAll scenarios will save the following properties at the user's metadata:\n\n*   a `consentGiven` property, with true/false values, shows if the user has provided consent (true) or not (false)\n    \n*   a `consentTimestamp` property, holding the Unix timestamp of when the user-provided consent\n    \n\nFor example:\n\n```\n{\n  \"consentGiven\": \"true\"\n  \"consentTimestamp\": \"1525101183\"\n}\n```\n\nWe will see three different implementations for this:\n\n*   one that displays links to other pages where the Terms & Conditions and/or privacy policy information can be reviewed\n    \n*   one that adds custom fields at the signup widget and works for database connections\n    \n*   one that redirects to another page where the user can provide consent, and works for social connections\n    \n\n## Configure the application\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and create a new application. Choose `Single Web Page Applications` as type.\n    \n2.  Go to **Settings** and set the **Allowed Callback URLs** to `http://localhost:3000`.\n    \n    This field holds the set of URLs to which Auth0 is allowed to redirect the users after they authenticate. Our sample app will run at `http://localhost:3000` hence we set this value.\n    \n3.  Copy the **Client Id** and **Domain** values. You will need them in a while.\n    \n4.  Go to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database) and create a new connection. Click **Create DB Connection**, set a name for the new connection, and click **Save**. You can also enable a social connection at [Auth0 Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) (we will enable Google login for the purposes of this tutorial).\n    \n5.  Go to the connection's **Applications** tab and make sure your newly created application is enabled.\n    \n6.  [Download the JavaScript SPA Sample](https://auth0.com/docs/quickstart/spa/vanillajs).\n    \n\n## Option 1: Display Terms & Conditions link\n\nIn this section, we will customize the login widget to add a flag that users must check in order to sign up. The flag's label will include links to pages that display the Terms & Conditions and privacy policy.\n\nThis works both for database connections and social logins.\n\n1.  Go to [Auth0 Dashboard > Branding > Universal Login](https://manage.auth0.com/#/login_page).\n    \n2.  Select the **Login** view, and enable the **Customize Login Page** toggle.\n    \n3.  Locate the **Default Templates** dropdown, and select `Lock`. The code block will be pre-populated for you.\n    \n4.  To add a field for the `consentGiven` metadata, use the `mustAcceptTerms` option. To include links to your Terms & Conditions and/or privacy policy pages, use the `languageDictionary` option. To learn more, read [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration). The example below displays text that says `I agree to the terms of service and privacy policy` (including links to both pages) next to the flag: \n    \n    ```\n    //code reducted for simplicity\n        var lock = new Auth0Lock(config.clientID, config.auth0Domain, {\n          auth: {\n            //code reducted for simplicity\n          },\n          languageDictionary: {\n            signUpTerms: \"I agree to the <a href='https://my-app-url.com/terms' target='_blank'>terms of service</a> and <a href='https://my-app-url.com/privacy' target='_blank'>privacy policy</a>.\"\n          },\n          mustAcceptTerms: true,\n          //code reducted for simplicity\n        });\n    ```\n    \n    To see what this will look like, select the **Preview** view, then when Lock loads, select **Sign Up**.\n5.  This flag forces users to accept the terms before they can sign up, but it does not set any metadata. To save the user's selection in the `consentGiven` metadata property, [create a new Action](https://auth0.com/docs/customize/actions/write-your-first-action). Enter a descriptive **Name** for your Action (for example, `Set consent flag upon signup`), select the `Login / Post Login` trigger because you’ll be adding the Action to the Login flow, then select **Create**.\n    \n6.  The following screen is the Actions code editor. Copy the following JavaScript code into it, then select **Save Draft** to save your changes:\n    \n    ```\n    exports.onExecutePostLogin = async (event, api) => {\n      const { consentGiven } = event.user.user_metadata || {};\n    \n      // short-circuit if the user signed up already\n      if ( consentGiven ) {\n        return;\n      }\n    \n      // first time login/signup\n      api.user.setUserMetadata(\"consentGiven\", true);\n      api.user.setUserMetadata(\"consentTimestamp\", Date.now());\n      return;\n    }\n    ```\n    \n    This code sets the `consentGiven` metadata to `true` if it is not already set (which means it's the first login after a signup).\n7.  From the Actions Code Editor sidebar, select Test (play icon), then select **Run** to [test your code](https://auth0.com/docs/customize/actions/test-actions).\n    \n8.  When you’re ready for the Action to go live, select **Deploy**.\n    \n\nFinally, add the Action you created to the [Login Flow](https://manage.auth0.com/#/actions/flows/login/). To learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\n## Option 2: Add custom fields for database connections\n\nIn this section, we will customize the login widget to add a flag that users will check if they agree to the processing of their information.\n\nThis works only for database connections (if you use social logins, see the next paragraph).\n\n1.  Navigate to [Auth0 Dashboard > Branding > Universal Login](https://manage.auth0.com/#/login_page).\n    \n2.  Select the **Login** view, and enable the **Customize Login Page** toggle.\n    \n3.  Locate the **Default Templates** dropdown, and select `Lock`. The code block will be pre-populated for you.\n    \n4.  To add a field for the `consentGiven` metadata, use the `additionalSignUpFields` option. To learn more, read [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration). The example below sets the type to `checkbox` (so we have a flag), the label to `I consent to data processing`, and the default value to `checked`.\n    \n    ```\n    //code reducted for simplicity\n        var lock = new Auth0Lock(config.clientID, config.auth0Domain, {\n          auth: {\n            //code reducted for simplicity\n          },\n          additionalSignUpFields: [{\n            type: \"checkbox\",\n            name: \"consentGiven\",\n            prefill: \"true\",\n            placeholder: \"I consent to data processing\"\n          }],\n          //code reducted for simplicity\n        });\n    ```\n    \n5.  To see what this will look like, select the **Preview** view, and when Lock loads, select **Sign Up**.\n    \n\nNote that in this option, we only set the flag and not the timestamp. Displaying the current time in the login widget is not optimal, that's why we didn't add an additional signup field. What you should do is set the timestamp in the background, with a rule that will check the value of `consentGiven` and set the additional `consentTimestamp` metadata to the current timestamp.\n\n## Option 3: Redirect to another page\n\nIf you are using social logins, adding custom fields is not an option, but you can redirect the user to another page where you ask for consent and any additional info, and then redirect back to finish the authentication transaction. This can be done with Redirect Actions. To learn more, read [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions). We will use this same Action to save the consent information in the user's metadata, so we can track this information and not ask for consent upon the next login.\n\nFor simplicity, we will use a [sample consent form](https://github.com/auth0/rules/blob/master/redirect-rules/simple/webtask.js#L31). You will need to host this form, and the URL for the form must be publicly-accessible. You'll need to provide the URL where the form can be accessed to Auth0 in Step 2. If you need a specialized consent prompt (for example, a parental consent), you must build your own custom consent form. Be aware that laws vary according to country.\n\n1.  [Create a new Action](https://auth0.com/docs/customize/actions/write-your-first-action). Enter a descriptive **Name** for your Action (for example, `Redirect to consent form`), select the `Login / Post Login` trigger because you’ll be adding the Action to the Login flow, then select **Create**.\n    \n2.  Locate the Actions Code Editor, and select the **Secrets** (key) icon in its sidebar. Add the consent form URL as a Secret by creating a key/value pair:\n    \n    *   **Key**: `CONSENT_FORM_URL`\n        \n    *   **Value**: `your-consent-form-url.com` (Be sure to provide the publicly-accessible URL where your consent form can be found.)\n        \n3.  Copy the following JavaScript code into the Actions Code Editor, and select **Save Draft** to save your changes:\n    \n    ```\n    exports.onExecutePostLogin = async (event, api) => {\n        const { consentGiven } = event.user.user_metadata || {};\n    \n        // redirect to consent form if user has not yet consented\n        if (!consentGiven && api.redirect.canRedirect()) {\n          const options = {\n            query: {\n              auth0_domain: `${event.tenant.id}.auth0.com`,\n            },\n          };\n          api.redirect.sendUserTo(event.secrets.CONSENT_FORM_URL, options);\n        }\n    };\n    \n    // if user clicks 'I agree' on the consent form, save it to their profile so they don't get prompted again\n    exports.onContinuePostLogin = async (event, api) => {\n      if (event.request.body.confirm === \"yes\") {\n        api.user.setUserMetadata(\"consentGiven\", true);\n        api.user.setUserMetadata(\"consentTimestamp\", Date.now());\n        return;\n      } else {\n        return api.access.deny(\"User did not consent\");\n      }\n    };\n    ```\n    \n4.  From the Actions Code Editor sidebar, select Test (play icon), then select **Run** to [test your code](https://auth0.com/docs/customize/actions/test-actions).\n    \n5.  When you’re ready for the Action to go live, select **Deploy**.\n    \n\nFinally, add the Action you created to the [Login Flow](https://manage.auth0.com/#/actions/flows/login/). To learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\nWhen setting up redirection to your consent form for use in a Production environment, be sure to review [Trusted Callback URLs](https://github.com/auth0/rules/tree/master/redirect-rules/simple#trusted-callback-urls) and [Data Integrity](https://github.com/auth0/rules/tree/master/redirect-rules/simple#data-integrity) regarding security concerns.\n\nWe are done with the configuration part; let's test!\n\n## Test the configuration\n\n1.  Go to the folder where you downloaded the application and run it.\n    \n2.  Go to `http://localhost:3000`. Click **Login**. Once Lock is displayed, click **Sign Up**. The login page will be served by default at `YOUR_DOMAIN/login`. To learn how to use your own domain, read [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n    \n3.  If you followed the first implementation option, you should see the flag to accept the terms of service and privacy policy. Note that the **Sign up** button remains disabled until you check the flag. Follow the links to check they are working. Set an email and password and accept the terms and click **Sign Up**. Alternatively, if you use a social connection, accept the terms, and choose **Sign Up with Google**.\n    \n4.  If you followed the second implementation option, you should see the new custom field we added. Set an email and password and leave the `I consent to data processing` flag checked. Click **Sign Up**.\n    \n    ![Application Sign Up Widget Lock Signup New Field](https://images.ctfassets.net/cdy7uua7fh8z/4eYL5N5DshzunjsnkiBha2/3b98225aec012fe2253cc4fb902bbd65/lock-signup-new-field.png)\n5.  If you followed the third implementation option, choose **Sign Up with Google**. You will be navigated to the consent form. Check the **I agree** flag and click **Submit**.\n    \n    ![Application Sign Up Widget Lock Consent Form Agree](https://images.ctfassets.net/cdy7uua7fh8z/dk2NIuhs47m3eU28cgEkI/0d73b6c33d438da1e82454da17ce8e6a/lock-consent-form-agree.png)\n    \n    If you do not check the **I agree** flag before clicking **Submit**, then you will see a popup error `Unauthorized. Check the console for details.`. At the console you will see this JSON:\n    \n    ```\n    {\n          error: \"unauthorized\", \n          errorDescription: \"User did not consent!\", \n          state: \"q0GjMwzZN_q5r8XPHvfakkMYcYM2q1N3\"\n        }\n    ```\n    \n    Note, that the user is created but they won't be able to log in. If they try to, they will be prompted again to provide consent.\n6.  Go to [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users) and search for the new user.\n    \n7.  Go to **User Details** and scroll down to the **Metadata** section. At the **user\\_metadata** text area you should see the following:\n    \n    ```\n    {\n          \"consentGiven\": \"true\"\n          \"consentTimestamp\": \"1525101183\"\n        }\n    ```\n    \n\nThat's it; you are done!",
  "title": "GDPR: Track Consent with Lock",
  "description": "Describes how you can customize Lock to capture consent information",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/migrate/actions-migration-limitations",
  "markdown": "# Actions Migration Limitations\n\nTo take advantage of the features provided by Auth0 Actions, you may need to migrate your current code from Rules, Hooks, or earlier versions of Actions. However, you should be aware of the current limitations when migrating between legacy extensibility offerings and Actions.\n\nFor more information, see [Migrate to Actions](https://auth0.com/docs/customize/actions/migrate).\n\n## Rule specific differences\n\n*   Re-use of functions between Actions is not currently supported, as each Action execution is autonomous. You must explicitly define the required functions for each Action.\n    \n*   Passing of variables between Actions is not supported. If you have Rules that depend on passing of state or variable data between one Rule to another, you can consolidate those Rules into a singular Action.\n    \n*   [`accessToken`](https://auth0.com/docs/libraries/lock/lock-api-reference#getuserinfo-) is currently limited to 100 scopes.\n    \n*   The event object in Actions does not currently provide an alternative for the following [context attributes](https://auth0.com/docs/customize/rules/context-object) from within a Rule:\n    \n    *   `context.sso.*`\n        \n    *   `context.connectionOptions`\n        \n    *   `context.sessionID`\n        \n*   Actions does not currently provide an API method for updating the following attributes possible within a Rule:\n    \n    *   `context.samlConfiguration.issuer`\n        \n    *   `context.samlConfiguration.logout`\n        \n    *   `context.samlConfiguration.binding`\n        \n    *   `context.samlConfiguration.RelayState`\n        \n    *   `context.samlConfiguration.authnContextDeclRef`\n        \n\n*   Actions only supports the following properties within [`event.user.identities`](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object)`:`\n    \n    *   `connection`\n        \n    *   `provider`\n        \n    *   `user_id`\n        \n    *   `profileData`\n        \n    *   `isSocial`\n        \n\n*   Actions support a max secret length of 1024 bytes.\n    \n*   Standard claims of an `idToken` or `accessToken` cannot be deleted using an Action.\n    \n*   Actions can only return `access denied` error codes and does not support returning an `unauthorized` error code.\n    \n*   Actions only support modifying the primary user between linked accounts.\n    \n\n## Hooks specific differences\n\n*   You can not modify scopes in a machine-to-machine client credential flow as was possible with a Hook.",
  "title": "Actions Migration Limitations",
  "description": "Limitations for migration-specific activities when migrating from Rules & Hooks to Actions",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow/event-object",
  "markdown": "# Actions Triggers: post-change-password - Event Object\n\nThe `event` object for the post-change-password Actions trigger provides contextual information about the newly created user.\n\n| Property | Description |\n| --- | --- |\n| `event.connection` | Details about the Connection that was used for the current transaction.<br><br>Includes the following properties:<br><br>*   `id` _String_. The connection's unique identifier.<br>*   `metadata` _Optional dictionary_. Metadata associated with the connection.<br>*   `name` _String_. The name of the connection used to authenticate the user (such as `twitter` or `some-g-suite-domain`).<br>*   `strategy` _String_. The type of connection. For social connections, `event.connection.strategy === event.connection.name`. For enterprise connections, the strategy is `waad` (Windows Azure AD), `ad` (Active Directory/LDAP), `auth0` (database connections), and so on. |\n| `event.request` | Details about the request that initiated the transaction.<br><br>Includes the following properties:<br><br>*   `geoip` _Object_.Contains geographical information about the request.<br>    <br>    Includes the following properties:<br>    <br>    *   `cityName` _Optional string_.<br>    *   `continentCode` _Optional string_.<br>    *   `countryCode` _Optional string_.<br>    *   `countryCode3` _Optional string_.<br>    *   `countryName` _Optional string_.<br>    *   `latitude` _Optional number_.<br>    *   `longitude` _Optional number_.<br>    *   `subdivisionCode` _Optional string_.<br>    *   `subdivisionName` _Optional string_.<br>    *   `timeZone` _Optional string_.<br>    <br>*   `hostname` _Optional string_. The hostname that is being used for the authentication flow.<br>*   `ip` _String_. The originating IP address of the request.<br>*   `language` _Optional string_. The language requested by the browser.<br>*   `method` _String_. The HTTP method used for the request<br>*   `user_agent` _Optional string_. The value of the `User-Agent` header received when initiating the transaction. |\n| `event.tenant` | Details about the Tenant associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `id` _String_. The name of the tenant. |\n| `event.user` | An object describing the user on whose behalf the current transaction was initiated.<br><br>Includes the following properties:<br><br>*   `email` _Optional string_. (unique) User's email address.<br>*   `email_verified` _Optional boolean_. Indicates whether the user has verified their email address.<br>*   `last_password_reset` _Optional string_. Timestamp indicating the last time the user's password was reset/changed. At user creation, this field does not exist. This property is only available for Database connections.<br>*   `phone_number` _Optional string_. (unique) User's phone number.<br>*   `phone_verified` _Optional boolean_. Indicates whether the user has verified their phone number.<br>*   `user_id` _Optional string_. (unique) User's unique identifier.<br>*   `username` _Optional string_. (unique) User's username. |",
  "title": "Actions Triggers: post-change-password - Event Object",
  "description": "Learn about the post-change-password Action trigger's event object, which provides contextual information about the newly created user.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow/event-object",
  "markdown": "# Actions Triggers: credentials-exchange - Event Object\n\nThe `event` object for the credentials-exchange Actions trigger provides contextual information about the request for a client credentials exchange.\n\n| Property | Description |\n| --- | --- |\n| `event.accessToken` | Information about the access token to be issued.<br><br>Includes the following properties:<br><br>*   `customClaims` _Dictionary_.<br>*   `scope` _Array of strings_. |\n| `event.client` | Information about the Client used during this token exchange.<br><br>Includes the following properties:<br><br>*   `client_id` _String_. The client ID of the application the user is logging in to.<br>*   `metadata` _Dictionary_. An object for holding other application properties.<br>*   `name` _String_. The name of the application (as defined in the Dashboard). |\n| `event.request` | Details about the request that initiated the transaction.<br><br>Includes the following properties:<br><br>*   `body` _Dictionary_. The body of the POST request. This data will only be available during refresh token, Client Credential Exchange flows and PreUserRegistration Action.<br>*   `geoip` _Object_.Contains geographical information about the request.<br>    <br>    Includes the following properties:<br>    <br>    *   `cityName` _Optional string_.<br>    *   `continentCode` _Optional string_.<br>    *   `countryCode` _Optional string_.<br>    *   `countryCode3` _Optional string_.<br>    *   `countryName` _Optional string_.<br>    *   `latitude` _Optional number_.<br>    *   `longitude` _Optional number_.<br>    *   `subdivisionCode` _Optional string_.<br>    *   `subdivisionName` _Optional string_.<br>    *   `timeZone` _Optional string_.<br>*   `hostname` _Optional string_. The hostname that is being used for the authentication flow.<br>*   `ip` _String_. The originating IP address of the request.<br>*   `language` _Optional string_. The language requested by the browser.<br>*   `method` _String_. The HTTP method used for the request<br>*   `user_agent` _Optional string_. The value of the `User-Agent` header received when initiating the transaction. |\n| `event.resource_server` | Information about the Resource Server that is issuing the access token.<br><br>Includes the following properties:<br><br>*   `identifier` _String_. The identifier of the resource server (for example, `https://your-api.example.com`). |\n| `event.tenant` | Information about the Tenant used during this token exchange.<br><br>Includes the following properties:<br><br>*   `id` _String_. The identifier of the tenant. |\n| `event.transaction` | Information about the Credentials Exchange transaction.<br><br>Includes the following properties:<br><br>*   `requested_scopes` _Array of strings_. The scopes specified (if any) when requesting the access token. |",
  "title": "Actions Triggers: credentials-exchange - Event Object",
  "description": "Learn about the credentials-exchange Action trigger's event object, which provides contextual information about the request for a client credentials exchange.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow/event-object",
  "markdown": "# Actions Triggers: post-user-registration - Event Object\n\nThe `event` object for the post-user-registration Actions trigger provides contextual information about the newly-created user.\n\n| Property | Description |\n| --- | --- |\n| `event.connection` | Details about the Connection that was used to register the user.<br><br>Includes the following properties:<br><br>*   `id` _String_. The connection's unique identifier.<br>*   `metadata` _Optional dictionary_. Metadata associated with the connection.<br>*   `name` _String_. The name of the connection used to authenticate the user (for example, `twitter` or `some-g-suite-domain`).<br>*   `strategy` _String_. The type of connection. For social connections, `event.connection.strategy === event.connection.name`. For enterprise connections, the strategy is `waad` (Windows Azure AD), `ad` (Active Directory/LDAP), `auth0` (database connections), and so on. |\n| `event.request`<br><br>_(Optional)_ | Details about the request that initiated the transaction.<br><br>Includes the following properties:<br><br>*   `geoip` _Object_. Contains geographical information about the request.<br>    <br>    Includes the following properties:<br>    <br>    *   `cityName` _Optional string_.<br>    *   `continentCode` _Optional string_.<br>    *   `countryCode` _Optional string_.<br>    *   `countryCode3` _Optional string_.<br>    *   `countryName` _Optional string_.<br>    *   `latitude` _Optional number_.<br>    *   `longitude` _Optional number_.<br>    *   `subdivisionCode` _Optional string_.<br>    *   `subdivisionName` _Optional string_.<br>    *   `timeZone` _Optional string_.<br>*   `hostname` _Optional string_. The hostname that is being used for the authentication flow.<br>*   `ip` _String_. The originating IP address of the request.<br>*   `language` _Optional string_. The language requested by the browser.<br>*   `method` _String_. The HTTP method used for the request<br>*   `user_agent` _Optional string_. The value of the `User-Agent` header received when initiating the transaction. |\n| `event.tenant` | Details about the Tenant associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `id` _String_. The name of the tenant. |\n| `event.transaction`<br><br>_(Optional)_ | Details about the current transaction.<br><br>Includes the following properties:<br><br>*   `acr_values` _Array of strings_. Any `acr_values` provided in the original authentication request.<br>*   `locale` _String_. The locale to be used for this transaction as determined by comparing the browser's requested languages to the tenant's language settings.<br>*   `login_hint` _Optional string_. Hint to the authorization server about the login identifier the end-user might use to log in (if necessary).<br>*   `prompt` _Optional array of strings_. List of instructions indicating whether the user may be prompted for re-authentication and consent.<br>*   `protocol` _Optional string_. Contains information about the authentication protocol.<br>    <br>    Possible values include:<br>    <br>    *   `oidc-basic-profile` Most used, web-based login.<br>    *   `oidc-implicit-profile` Used on mobile devices and single-page apps.<br>    *   `samlp` SAML protocol used on SaaS apps.<br>    *   `wsfed` WS-Federation used on Microsoft products like Office365.<br>    *   `wstrust-usernamemixed` WS-trust User/password login used on CRM and Office365.<br>    *   `oauth2-device-code` Transaction using the Device Authorization Flow.<br>    *   `oauth2-resource-owner` User/password login typically used on database connections.<br>    *   `oauth2-resource-owner-jwt-bearer` Login using a bearer JWT signed with user's private key.<br>    *   `oauth2-password` Login using the password exchange.<br>    *   `oauth2-access-token` Refreshing a token using the refresh token exchange.<br>    *   `oauth2-refresh-token` Refreshing a token using the refresh token exchange.<br>    *   `oauth2-token-exchange`<br>    *   `oidc-hybrid-profile` Allows your application to have immediate access to an ID token while still providing for secure and safe retrieval of access and refresh tokens.<br>*   `redirect_uri` _Optional string_. The URL to which Auth0 will redirect the browser after the transaction is completed.<br>*   `requested_scopes` _Array of strings_. The scopes requested (if any) when starting this authentication flow.<br>*   `response_mode` _Optional string_.<br>    <br>    Informs the authorizationsServer of the mechanism to be used for returning parameters from the authorization endpoint.<br>    <br>    Possible values include:<br>    <br>    *   `query`<br>    *   `fragment`<br>    *   `form_post`<br>    *   `web_message`<br>*   `response_type` _Optional array of strings_.<br>    <br>    Possible values include:<br>    <br>    *   `code`<br>    *   `token`<br>    *   `id_token`<br>*   `state` _Optional string_. An opaque arbitrary alphanumeric string your app adds to the initial request that Auth0 includes when redirecting back to your application.<br>*   `ui_locales` _Array of strings_. The `ui_locales` provided in the original authentication request. |\n| `event.user` | An object describing the user on whose behalf the current transaction was initiated.<br><br>Includes the following properties:<br><br>*   `app_metadata` _Dictionary_. Custom fields that store info about a user that influences the user's access, such as support plan, security roles, or access control groups.<br>*   `created_at` _String_. Timestamp indicating when the user profile was first created.<br>*   `email` _Optional string_. (unique) User's email address.<br>*   `email_verified` _Boolean_. Indicates whether the user has verified their email address.<br>*   `family_name` _Optional string_. User's family name.<br>*   `given_name` _Optional string_. User's given name.<br>*   `last_password_reset` _Optional string_. Timestamp indicating the last time the user's password was reset/changed. At user creation, this field does not exist. This property is only available for Database connections.<br>*   `name` _Optional string_. User's full name.<br>*   `nickname` _Optional string_. User's nickname.<br>*   `phone_number` _Optional string_. User's phone number.<br>*   `phone_verified` _Optional boolean_. Indicates whether the user has verified their phone number.<br>*   `picture` _Optional string_. URL pointing to the [user's profile picture](https://auth0.com/docs/users/change-user-picture).<br>*   `updated_at` _String_. Timestamp indicating when the user's profile was last updated/modified.<br>*   `user_id` _String_. (unique) User's unique identifier.<br>*   `user_metadata` _Dictionary_. Custom fields that store info about a user that does not impact what they can or cannot access, such as work address, home address, or user preferences.<br>*   `username` _Optional string_. (unique) User's username. |",
  "title": "Actions Triggers: post-user-registration - Event Object",
  "description": "Learn about the post-user-registration Action trigger's event object, which provides contextual information about the newly-created user.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow/event-object",
  "markdown": "# Actions Triggers: pre-user-registration - Event Object\n\nThe `event` object for the pre-user-registration Actions trigger provides contextual information about the request to register a new user.\n\n| Property | Description |\n| --- | --- |\n| `event.client`<br><br>_(Optional)_ | Information about the Client with which this transaction was initiated.<br><br>Includes the following properties:<br><br>*   `client_id` _String_. The client ID of the application the user is logging in to.<br>*   `metadata` _Dictionary_. An object for holding other application properties.<br>*   `name` _String_. The name of the application (as defined in the Dashboard). |\n| `event.connection` | Details about the Connection that was used to register the user.<br><br>Includes the following properties:<br><br>*   `id` _String_. The connection's unique identifier.<br>*   `metadata` _Optional dictionary_. Metadata associated with the connection.<br>*   `name` _String_. The name of the connection used to authenticate the user (for example, `twitter` or `some-g-suite-domain`).<br>*   `strategy` _String_. The type of connection. For social connections, `event.connection.strategy === event.connection.name`. For enterprise connections, the strategy is `waad` (Windows Azure AD), `ad` (Active Directory/LDAP), `auth0` (database connections), and so on. |\n| `event.request` | Details about the request that initiated the transaction.<br><br>Includes the following properties:<br><br>*   `body` _Dictionary_. The body of the POST request. This data will only be available during refresh token, Client Credential Exchange flows, and PreUserRegistration Action.<br>*   `geoip` _Object_. Contains geographical information about the request.<br>    <br>    Includes the following properties:<br>    <br>    *   `cityName` _Optional string_.<br>    *   `continentCode` _Optional string_.<br>    *   `countryCode` _Optional string_.<br>    *   `countryCode3` _Optional string_.<br>    *   `countryName` _Optional string_.<br>    *   `latitude` _Optional number_.<br>    *   `longitude` _Optional number_.<br>    *   `subdivisionCode` _Optional string_.<br>    *   `subdivisionName` _Optional string_.<br>    *   `timeZone` _Optional string_.<br>*   `hostname` _Optional string_. The hostname that is being used for the authentication flow.<br>*   `ip` _String_. The originating IP address of the request.<br>*   `language` _Optional string_. The language requested by the browser.<br>*   `method` _String_. The HTTP method used for the request<br>*   `user_agent` _Optional string_. The value of the `User-Agent` header received when initiating the transaction. |\n| `event.tenant` | Details about the Tenant associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `id` _String_. The name of the tenant. |\n| `event.transaction`<br><br>_(Optional)_ | Details about the current transaction.<br><br>Includes the following properties:<br><br>*   `acr_values` _Array of strings_. Any `acr_values` provided in the original authentication request.<br>*   `locale` _String_. The locale to be used for this transaction as determined by comparing the browser's requested languages to the tenant's language settings.<br>*   `login_hint` _Optional string_. Hint to the authorization server about the login identifier the end-user might use to log in (if necessary).<br>*   `prompt` _Optional array of strings_. List of instructions indicating whether the user may be prompted for re-authentication and consent.<br>*   `protocol` _Optional string_. Contains information about the authentication protocol used for the transaction.<br>    <br>    Possible values include:<br>    <br>    *   `oidc-basic-profile` Most used, web-based login.<br>    *   `oidc-implicit-profile` Used on mobile devices and single-page apps.<br>    *   `samlp` SAML protocol used on SaaS apps.<br>    *   `wsfed` WS-Federation used on Microsoft products like Office365.<br>    *   `wstrust-usernamemixed` WS-trust User/password login used on CRM and Office365.<br>    *   `oauth2-device-code` Transaction using the Device Authorization Flow.<br>    *   `oauth2-resource-owner` User/password login typically used on database connections.<br>    *   `oauth2-resource-owner-jwt-bearer` Login using a bearer JWT signed with user's private key.<br>    *   `oauth2-password` Login using the password exchange.<br>    *   `oauth2-access-token` Refreshing a token using the refresh token exchange.<br>    *   `oauth2-refresh-token` Refreshing a token using the refresh token exchange.<br>    *   `oauth2-token-exchange`<br>    *   `oidc-hybrid-profile` Allows your application to have immediate access to an ID token while still providing for secure and safe retrieval of access and refresh tokens.<br>    <br>*   `redirect_uri` _Optional string_. The URL to which Auth0 will redirect the browser after the transaction is completed.<br>*   `requested_scopes` _Array of strings_. The scopes requested (if any) when starting this authentication flow.<br>*   `response_mode` _Optional string_. Informs the authorization server of the mechanism to be used for returning parameters from the authorization endpoint.<br>    <br>    Possible values include:<br>    <br>    *   `query`<br>    *   `fragment`<br>    *   `form_post`<br>    *   `web_message`<br>*   `response_type` _Optional array of strings_. Contains information about the response type sent by the authorization server.<br>    <br>    Possible values include:<br>    <br>    *   `code`<br>    *   `token`<br>    *   `id_token`<br>*   `state` _Optional string_. An opaque arbitrary alphanumeric string your app adds to the initial request that Auth0 includes when redirecting back to your application.<br>*   `ui_locales` _Array of strings_. The `ui_locales` provided in the original authentication request. |\n| `event.user` | An object describing the user who is attempting to register.<br><br>Includes the following properties:<br><br>*   `app_metadata` _Optional dictionary_. Custom fields that store info about a user that influences the user's access, such as support plan, security roles, or access control groups.<br>*   `email` _Optional string_. (unique) User's email address.<br>*   `family_name` _Optional string_. User's family name.<br>*   `given_name` _Optional string_. User's given name.<br>*   `name` _Optional string_. User's full name.<br>*   `nickname` _Optional string_. User's nickname.<br>*   `phone_number` _Optional string_. User's phone number.<br>*   `picture` _Optional string_. URL pointing to the [user's profile picture](https://auth0.com/docs/users/change-user-picture).<br>*   `user_metadata` _Optional dictionary_. Custom fields that store info about a user that does not impact what they can or cannot access, such as work address, home address, or user preferences.<br>*   `username` _Optional string_. (unique) User's username. |",
  "title": "Actions Triggers: pre-user-registration - Event Object",
  "description": "Learn about the pre-user-registration Action trigger's event object, which provides contextual information about the request to register a new user.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow/api-object",
  "markdown": "# Actions Triggers: credentials-exchange - API Object\n\nThe API object for the credentials-exchange Actions trigger includes:\n\n## `api.access`\n\nControl availability to the access token.\n\n### `api.access.deny(code, reason)`\n\nMark the current token exchange as denied.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `code` | _String_. The OAuth error code justifying the rejection of the login. Should be one of: `'invalid_scope'`, `'invalid_request'`, or `'server_error'` |\n| `reason` | _String_. A human-readable explanation for rejecting the access token grant. |\n\n## `api.accessToken`\n\nRequest changes to the access token being issued.\n\n### `api.accessToken.setCustomClaim(name, value)`\n\nSet a custom claim on the Access Token that will be issed as a part of this exchange.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. Name of the claim (note that this may need to be a fully-qualified url). |\n| `value` | _Any value_. The value of the claim. |\n\n## `api.cache`\n\nStore and retrieve data that persists across executions.\n\n### `api.cache.delete(key)`\n\nDelete a record describing a cached value at the supplied key if it exists.\n\nReturns a `CacheWriteResult` object with `type: \"success\"` if a value was removed from the cache. A failed operation returns `type: \"error\"`. For errors, the returned object will have a `code` property that indicates the nature of the failure.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.get(key)`\n\nRetrieve a record describing a cached value at the supplied `key`, if it exists. If a record is found, the cached value can be found at the `value` property of the returned object.\n\nReturns a cache record if an item is found in the cache for the supplied `key`. Cache records are objects with a `value` property holding the cached value as well as an `expires_at` property indicating the maximum expiry of the record in milliseconds since the Unix epoch.\n\n**Important:** This cache is designed for short-lived, ephemeral data. Items may not be available in later transactions even if they are within their supplied their lifetime.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.set(key, value, [options])`\n\nStore or update a string value in the cache at the specified key.\n\nValues stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\nValues stored in this way will have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default of lifetime of 15 minutes will be used. Lifetimes may not exceed the maximum duration listed at [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n| `value` | _String_. The value of the record to be stored. |\n| `options` | _Optional object_. Options for adjusting cache behavior. |\n| `options.expires_at` | _Optional number_. The absolute expiry time in milliseconds since the unix epoch. While cached records may be evicted earlier, they will never remain beyond the the supplied `expires_at`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `ttl`. If both options are supplied, the earlier expiry of the two will be used. |\n| `options.ttl` | _Optional number_. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the the supplied `ttl`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `expires_at`. If both options are supplied, the earlier expiry of the two will be used. |",
  "title": "Actions Triggers: credentials-exchange - API Object",
  "description": "Learn about the credentials-exchange Action trigger's API object.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow/event-object",
  "markdown": "# Actions Triggers: send-phone-message - Event Object\n\nThe `event` object for the send-phone-message Actions trigger provides contextual information about the message to be sent and the user to be challenged or enrolled.\n\n| Property | Description |\n| --- | --- |\n| `event.client`<br><br>_(Optional)_ | Information about the Client with which this transaction was initiated.<br><br>Includes the following properties:<br><br>*   `client_id` _String_. The Client ID of the application the user is logging in to.<br>*   `metadata` _Dictionary_. An object for holding other application properties.<br>*   `name` _String_. The name of the application (as defined in the Dashboard). |\n| `event.message_options` | Details about the message that is sent to the user.<br><br>Includes the following properties:<br><br>*   `action` _String_. The flow that triggered this action.<br>    <br>    Possible values include:<br>    <br>    *   `enrollment`<br>    *   `second-factor-authentication`<br>*   `code` _String_. One-time password that the user needs to use to enter in the form.<br>*   `message_type` _String_. How the message will be delivered.<br>    <br>    Possible values include:<br>    <br>    *   `sms`<br>    *   `voice`<br>*   `recipient` _String_. Phone number where the message will be sent.<br>*   `text` _String_. Content of the message to be sent. |\n| `event.request` | Details about the request that initiated the transaction.<br><br>Includes the following properties:<br><br>*   `geoip` _Object_. Contains geographical information about the request.<br>    <br>    Includes the following properties:<br>    <br>    *   `cityName` _Optional string_.<br>    *   `continentCode` _Optional string_.<br>    *   `countryCode` _Optional string_.<br>    *   `countryCode3` _Optional string_.<br>    *   `countryName` _Optional string_.<br>    *   `latitude` _Optional number_.<br>    *   `longitude` _Optional number_.<br>    *   `subdivisionCode` _Optional string_.<br>    *   `subdivisionName` _Optional string_.<br>    *   `timeZone` _Optional string_.<br>*   `hostname` _Optional string_. The hostname that is being used for the authentication flow.<br>*   `ip` _String_. The originating IP address of the request.<br>*   `language` _Optional string_. The language requested by the browser.<br>*   `method` _String_. The HTTP method used for the request<br>*   `user_agent` _Optional string_. The value of the `User-Agent` header received when initiating the transaction. |\n| `event.tenant` | Details about the Tenant associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `id` _String_. The name of the tenant. |\n| `event.user` | An object describing the user on whose behalf the current transaction was initiated.<br><br>Includes the following properties:<br><br>*   `app_metadata` _Dictionary_. Custom fields that store info about a user that influences the user's access, such as support plan, security roles, or access control groups.<br>*   `created_at` _String_. Timestamp indicating when the user profile was first created.<br>*   `email` _Optional string_. (unique) User's email address.<br>*   `email_verified` _Boolean_. Indicates whether the user has verified their email address.<br>*   `family_name` _Optional string_. User's family name.<br>*   `given_name` _Optional string_. User's given name.<br>*   `identities` _Optional array of objects_.<br>    <br>    Contains info retrieved from the identity provider with which the user originally authenticates. Users may also link their profile to multiple identity providers; those identities will then also appear in this array. The contents of an individual identity provider object varies by provider.<br>    <br>    Elements include the following properties:<br>    <br>    *   `connection` _Optional string_. Name of the Auth0 connection used to authenticate the user.<br>    *   `isSocial` _Optional boolean_. Indicates whether the connection is a social one.<br>    *   `profileData` _Optional dictionary_. User information associated with the connection. When profiles are linked, it is populated with the associated user info for secondary accounts.<br>    *   `provider` _Optional string_. Name of the entity that is authenticating the user, such as Facebook, Google, SAML, or your own provider.<br>    *   `user_id` _Optional string_. User's unique identifier for this connection/provider.<br>*   `last_password_reset` _Optional string_. Timestamp indicating the last time the user's password was reset/changed. At user creation, this field does not exist. This property is only available for Database connections.<br>*   `name` _Optional string_. User's full name.<br>*   `nickname` _Optional string_. User's nickname.<br>*   `phone_number` _Optional string_. User's phone number.<br>*   `phone_verified` _Optional boolean_. Indicates whether the user has verified their phone number.<br>*   `picture` _Optional string_. URL pointing to the [user's profile picture](https://auth0.com/docs/users/change-user-picture).<br>*   `updated_at` _String_. Timestamp indicating when the user's profile was last updated/modified.<br>*   `user_id` _String_. (unique) User's unique identifier.<br>*   `user_metadata` _Dictionary_. Custom fields that store info about a user that does not impact what they can or cannot access, such as work address, home address, or user preferences.<br>*   `username` _Optional string_. (unique) User's username. |",
  "title": "Actions Triggers: send-phone-message - Event Object",
  "description": "Learn about the send-phone-message Action trigger's event object, which provides contextual information about the message to be sent and the user to be challenged or enrolled.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow/api-object",
  "markdown": "# Actions Triggers: pre-user-registration - API Object\n\nThe API object for the pre-user-registration Actions trigger includes:\n\n## `api.access`\n\nModify the access of the user that is logging in, such as rejecting the registration attempt.\n\n### `api.access.deny(reason, userMessage)`\n\nDeny the user from being able to register. The signup flow will immediately stop following the completion of this action and no further Actions will be executed.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `reason` | _String_. An internal reason describing why this registration attempt is being denied. This value will appear in tenant logs. |\n| `userMessage` | _String_. A human-readable explanation for rejecting the registration attempt. This may be presented directly in end-user interfaces. |\n\n## `api.cache`\n\nStore and retrieve data that persists across executions.\n\n### `api.cache.delete(key)`\n\nDelete a record describing a cached value at the supplied key if it exists.\n\nReturns a `CacheWriteResult` object with `type: \"success\"` if a value was removed from the cache. A failed operation returns `type: \"error\"`. For errors, the returned object will have a `code` property that indicates the nature of the failure.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.get(key)`\n\nRetrieve a record describing a cached value at the supplied `key`, if it exists. If a record is found, the cached value can be found at the `value` property of the returned object.\n\nReturns a cache record if an item is found in the cache for the supplied `key`. Cache records are objects with a `value` property holding the cached value as well as an `expires_at` property indicating the maximum expiry of the record in milliseconds since the Unix epoch.\n\n**Important:** This cache is designed for short-lived, ephemeral data. Items may not be available in later transactions even if they are within their supplied their lifetime.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.set(key, value, [options])`\n\nStore or update a string value in the cache at the specified key.\n\nValues stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\nValues stored in this way will have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default of lifetime of 15 minutes will be used. Lifetimes may not exceed the maximum duration listed at [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n| `value` | _String_. The value of the record to be stored. |\n| `options` | _Optional object_. Options for adjusting cache behavior. |\n| `options.expires_at` | _Optional number_. The absolute expiry time in milliseconds since the unix epoch. While cached records may be evicted earlier, they will never remain beyond the the supplied `expires_at`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `ttl`. If both options are supplied, the earlier expiry of the two will be used. |\n| `options.ttl` | _Optional number_. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the the supplied `ttl`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `expires_at`. If both options are supplied, the earlier expiry of the two will be used. |\n\n## `api.user`\n\nMake changes to the metadata of the user that is registering.\n\n### `api.user.setUserMetadata(name, value)`\n\nSet metadata for the user that is registering. Data stored within user\\_metadata is visible and editable by the user.\n\nNote: This trigger makes a call to the Management API, consuming the Management API rate limit. If this request reaches the rate limit and fails to retry within the timeout window, the API returns a `Deadline Exceeded` error.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. The name of metadata property. |\n| `value` | _Any value_. The value of the metadata property. This may be set to \\`null\\` to remove the metadata property. |\n\n### `api.user.setAppMetadata(name, value)`\n\nSet application metadata for the user that is registering. Data stored within app\\_metadata is not visible or editable by the user.\n\nNote: This trigger makes a call to the Management API, consuming the Management API rate limit. If this request reaches the rate limit and fails to retry within the timeout window, the API returns a `Deadline Exceeded` error.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. The name of metadata property. |\n| `value` | _Any value_. The value of the metadata property. This may be set to \\`null\\` to remove the metadata property. |",
  "title": "Actions Triggers: pre-user-registration - API Object",
  "description": "Learn about the pre-user-registration Action trigger's API object.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers/configure-twilio-as-a-phone-messaging-provider",
  "markdown": "# Configure Twilio as a Phone Messaging Provider\n\n## Prerequisites\n\nYou must have a [Twilio](https://twilio.com/) account with a valid SMS and/or phone delivery option.\n\n## Configure Twilio\n\n1.  Log in to your [Twilio](https://www.twilio.com/login) account.\n    \n2.  Go to your [Twilio Console](https://console.twilio.com/). You will need your Twilio SID and Twilio Auth Token when configuring Twilio in your Auth0 Dashboard.  \n    \n3.  Go to Auth0 [Dashboard > Branding > Phone Provider](https://manage.auth0.com/#/branding/phone/provider). Select **Twilio** as your **Phone Provider**.\n    \n4.  Select a **Delivery Method**. You can choose **Text**, **Voice**, or both as delivery methods for your customers.\n    \n5.  For the **Twilio Provider Settings**, select an **SMS Source**: \n    \n    1.  If you select **Use From**, enter a default phone number from which customers will receive phone messages.\n        \n    2.  If you select [Messaging Service](https://www.twilio.com/docs/messaging/services), enter your Twilio Messaging Service SID. You can find this value in your Twilio Console.\n        \n    3.  Enter your Twilio SID and Twilio Auth Token from the Twilio Console. Click **Save**.\n        \n\n## Test phone\n\nClick the **Try** button to send a test phone message. If you have successfully configured Twilio as an external phone provider, Auth0 will send a confirmation phone message using the selected delivery method. If you do not receive a phone message after a few minutes, check your [Auth0 logs](https://manage.auth0.com/#/logs) for failures.\n\nThe Twilio [Messaging Activity](https://console.twilio.com/us1/develop/sms/overview) page displays delivery insights for all SMS that have been sent to your users.",
  "title": "Configure Twilio as a Phone Messaging Provider",
  "description": "Learn how to configure Twilio as a Phone Messaging Provider in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks/hook-secrets/create-hook-secrets",
  "markdown": "# Create Hook Secrets\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ], [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\"\n\n\tpayload := strings.NewReader(\"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: '{ [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ], [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ] }'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ], [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ] }\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/hooks/HOOK_ID/secrets\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\n\nlet postData = NSData(data: \"{ [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ], [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ] }\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Create Hook Secrets",
  "description": "Learn how to create Hook Secrets using the Dashboard and Management API. Hook Secrets may also be imported and exported using the Auth0 Deploy Command-Line Interface (CLI) tool.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks/hook-secrets/view-hook-secrets",
  "markdown": "# View Hook Secrets\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/hooks/HOOK_ID/secrets\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "View Hook Secrets",
  "description": "Learn how to view Hook Secrets using the Dashboard and Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks/hook-secrets/delete-hook-secrets",
  "markdown": "# Delete Hook Secrets\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --data '{ [ \"HOOK_SECRET_NAME\", \"HOOK_SECRET_NAME\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"undefined\", \"{ [ \\\"HOOK_SECRET_NAME\\\", \\\"HOOK_SECRET_NAME\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\"\n\n\tpayload := strings.NewReader(\"{ [ \\\"HOOK_SECRET_NAME\\\", \\\"HOOK_SECRET_NAME\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"DELETE\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ [ \\\"HOOK_SECRET_NAME\\\", \\\"HOOK_SECRET_NAME\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'},\n  data: '{ [ \"HOOK_SECRET_NAME\", \"HOOK_SECRET_NAME\" ] }'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ [ \"HOOK_SECRET_NAME\", \"HOOK_SECRET_NAME\" ] }\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_POSTFIELDS => \"{ [ \\\"HOOK_SECRET_NAME\\\", \\\"HOOK_SECRET_NAME\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ [ \\\"HOOK_SECRET_NAME\\\", \\\"HOOK_SECRET_NAME\\\" ] }\"\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/hooks/HOOK_ID/secrets\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ [ \\\"HOOK_SECRET_NAME\\\", \\\"HOOK_SECRET_NAME\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet postData = NSData(data: \"{ [ \"HOOK_SECRET_NAME\", \"HOOK_SECRET_NAME\" ] }\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Delete Hook Secrets",
  "description": "Learn how to delete Hook Secrets using the Dashboard and Management API. Hook Secrets may also be imported and exported using the Auth0 Deploy Command-Line Interface (CLI) tool.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks/hook-secrets/update-hook-secrets",
  "markdown": "# Update Hook Secrets\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ], [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\"\n\n\tpayload := strings.NewReader(\"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: '{ [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ], [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ] }'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ], [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ] }\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/hooks/HOOK_ID/secrets\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ], [ \\\"HOOK_SECRET_KEY\\\", \\\"HOOK_SECRET_VALUE\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\n\nlet postData = NSData(data: \"{ [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ], [ \"HOOK_SECRET_KEY\", \"HOOK_SECRET_VALUE\" ] }\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/hooks/HOOK_ID/secrets\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Update Hook Secrets",
  "description": "Learn how to update Hook Secrets using the Dashboard or Management API. Hook Secrets may also be imported and exported using the Auth0 Deploy Command-Line Interface (CLI) tool.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/authorization-extension/install-authorization-extension",
  "markdown": "# Install Authorization Extension\n\n## Prerequisite\n\nBefore you begin, make sure that you have an existing application that can be used with the Authorization Extension. You can use the following types of applications:\n\n*   Native apps\n    \n*   Regular web apps\n    \n*   Single-page apps\n    \n\nApplications without an assigned type or machine-to-machine apps cannot be used with this extension.\n\n## Install extension\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions).\n    \n2.  Select **Auth0 Authorization** and answer the prompt to install.\n    \n3.  Choose where you would like to store your data: Webtask Storage or Amazon S3 bucket.\n    \n    ![Dashboard - Extensions - Authorization Extension - Install](https://images.ctfassets.net/cdy7uua7fh8z/40vWVkfrRl7zdlEIl3oaK4/c35eb141f557a38ad2584b9f2e38885a/extensions-auth-install.png)\n\nOnce the extension is installed, you will see it listed under the **Installed Extensions**.\n\n![Dashboard - Extensions - Installed Extensions - Authorization Extension](https://images.ctfassets.net/cdy7uua7fh8z/5gJ26ZetkEXOur9Z7WFxzY/5bd99cdb615204a615cd7446fe7cd17b/extensions-auth-installed.png)\n\nWhen you click the link to open the extension for the first time, you will be asked to provide permission for the extension to access your Auth0 account. If you do, you will be taken to the Authorization Dashboard.\n\n![Dashboard - Extensions - Authorization Dashboard - Users](https://images.ctfassets.net/cdy7uua7fh8z/1ALaqm8mvtleQfm3XKvBtf/73fb69c35e2eed4dae74b1baa8e372a2/auth-dashboard-v2.png)\n\n### Webtask storage\n\nThe extension will use Webtask Storage by default, and you are limited to 500 KB of data. This is equivalent to:\n\n*   1000 groups and 3000 users, where each user is a member of 3 groups\n    \n*   20 groups and 7000 users, where each user is a member of 3 groups\n    \n\n### Amazon S3\n\nAlternatively, you can use Amazon S3 as a storage provider. Amazon S3 is a file-based storage platform, which means it writes in parallel. This may cause issues, but the extension's storage logic attempts to take this into account. However, if you automate the creation of groups, roles, or permissions, Auth0 recommends that you use sequential calls to the API.\n\nTo use Amazon S3, you need to:\n\n1.  Create an S3 bucket.\n    \n2.  Create an IAM user and get the Key ID for that user.\n    \n3.  Create a policy for the IAM user that allows the user to make changes to the bucket.\n    \n\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:DeleteObject\",\n                \"s3:GetObject\",\n                \"s3:ListBucket\",\n                \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::{nameOfYourBucket}/*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:ListBucket\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::{nameOfYourBucket}\"\n            ],\n            \"Condition\": {}\n        }\n    ]\n}\n```\n\n## Learn more\n\n*   [Configure Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/configure-authorization-extension)\n*   [Set Up Users in Authorization Extension Dashboard](https://auth0.com/docs/customize/extensions/authorization-extension/set-up-authorization-extension-users)\n*   [Enable API Access to Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/enable-api-access-to-authorization-extension)\n*   [Import and Export Authorization Extension Data](https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data)\n*   [Troubleshoot Authorization Extension](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension)",
  "title": "Install Authorization Extension",
  "description": "Describes how to install the Auth0 Authorization Extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/authorization-extension/configure-authorization-extension",
  "markdown": "# Configure Authorization Extension\n\nBefore the extension can enforce your authorization logic, you need to configure how it will behave during the login transaction. Your configuration settings will be captured in a [rule](https://auth0.com/docs/customize/rules) that executes during runtime.\n\n## Prerequisites\n\n[Install the Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/migrate-to-authorization-extension-v2)\n\n## Configure extension\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **Auth0 Authorization**.\n    \n2.  Choose **Configuration** at the top right of the **Authorization Dashboard**.\n    \n    ![Dashboard - Authorization Extension Dashboard - Configuration](https://images.ctfassets.net/cdy7uua7fh8z/r8Ic6OYMcVfXDvIKePLrb/ed9c75536d20c12149e8b8e62a8edc44/click-configuration.png)\n3.  This brings you to the **Rule Configuration** section of the **Configuration** page. All of the changes you make in the sections under **Token Contents**, such as those related to groups, roles, and permissions, will be reflected in the rule you export at the completion of this step.\n    \n    ![Authorization Extension Configuration](https://images.ctfassets.net/cdy7uua7fh8z/4ydHJBdKGs4XVLnRst66A3/1f61ad2e087252c6c3aa10add13d99cd/configuration0auth.png)\n\n### ApiKey\n\nThe rule uses the ApiKey to communicate with the Authorization Extension API and get the policy. The ApiKey is stored as a rule config and will be created automatically when the rule is published. To rotate the ApiKey, click the **Rotate** button; when the ApiKey is rotated, the rule config will be updated automatically.\n\n![Authorization Extension - Configuration - ApiKey](https://images.ctfassets.net/cdy7uua7fh8z/5PEBRO9ox7CaDUCaFOH46O/c24f253e90359143eea97a75a68ba52f/apikey-config.png)\n\nYou can store authorization data like groups, roles, or permissions in the outgoing token issued by Auth0. Your application can then consume this information by inspecting the token and take appropriate actions based on the user's current authorization context.\n\n![Authorization Extension - Configuration - User Info](https://images.ctfassets.net/cdy7uua7fh8z/7IwRUnCsiC61sq8tUH7m50/db49bb0f6942ca93b86dd3f783d5745d/user-info.png)\n\nTo add groups, roles, and/or permissions information to the outgoing token, enable the slider next to the option you want to be included.\n\n### Merge authorization data from IdP\n\nYou might have users that receive groups, roles, or permissions from the identity provider (IdP) you're using, such as Active Directory. If you want to merge these items (to preserve them) with the ones defined in the Authorization Extension, make sure you enable the appropriate **Passthrough** options. Enable the slider next to the appropriate merges you want enabled.\n\n![Authorization Extension - Configuration - Passthrough](https://images.ctfassets.net/cdy7uua7fh8z/3iDtMjVci6iAzs7mkWnZSr/36939acc06b48f3fe3e8a630f40d8dde/passthrough.png)\n\n### Store authorization information in user profiles\n\nIf your authorization context is large (for example, the user might belong to many groups or have been granted many permissions), you might find it useful to store some of the authorization content in the users' profiles. This allows you to store less information in the token, which means you're less likely to see performance-related issues or even problems with token issuance. **Persistence** is the process by which you store groups, roles, and permissions information in the users' profiles.\n\nThe data will be stored in the user's `app_metadata` field, and you can then use the Management API or the [Dashboard](https://manage.auth0.com/#/users) to retrieve this information after the user has logged in.\n\n![Authorization Extension - Configuration - Persistence](https://images.ctfassets.net/cdy7uua7fh8z/5kfgcLhwwZkQ2Oh5uxaGxF/de5cf05429d1d1730a0165f4c61ac629/persistence.png)\n\n## Save changes to rule\n\nOnce you've configured your rule, click **Publish Rule**. This creates a rule for your tenant that executes after each user login.\n\n### View rule\n\nIf you'd like to see the rule you've created, you can do so at [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules).\n\n![Auth0 Pipeline - Rules](https://images.ctfassets.net/cdy7uua7fh8z/6SyIeDsVhO0UwvFhSU0Lfl/5e9535ad6f2961234837ab4baebdb7ec/Dashboard_-_Auth_Pipeline_-_Rules.png)\n\nYou can open the rule to see the exact rules configuration.\n\n## Learn more\n\n*   [Import and Export Authorization Extension Data](https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data)\n*   [Enable API Access to Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/enable-api-access-to-authorization-extension)\n*   [Use Rules with the Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/use-rules-with-the-authorization-extension)\n*   [Set Up Users in Authorization Extension Dashboard](https://auth0.com/docs/customize/extensions/authorization-extension/set-up-authorization-extension-users)\n*   [Troubleshoot Authorization Extension](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension)\n*   [Migrate to Authorization Extension v2](https://auth0.com/docs/customize/extensions/authorization-extension/migrate-to-authorization-extension-v2)",
  "title": "Configure Authorization Extension",
  "description": "Learn how to configure the Authorization Extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/migrate/migrate-a-rule-to-an-action",
  "markdown": "# Migration tooling\n\nSimplify the migration process of Rules to Actions by using the Rule Migration tooling in the [Auth0 Dashboard](https://manage.auth0.com/). In addition to facilitating the switch from a Rule to an Action, the new tooling also offers built-in guidance and fixes for common Rule patterns.\n\n## Before migration\n\nBefore you start the migration, visit [Migrate from Rules to Actions](https://auth0.com/docs/customize/actions/migrate/migrate-from-rules-to-actions). This migration guide is an excellent resource that explains the differences between Rules and Actions and is a helpful tool in the migration journey.\n\n### Rule migration order\n\nRules execute before Actions, which implies that Rules should be migrated in reverse runtime order. Migrate the last Rule to execute in your existing flow and work your way to the first Rule in reverse, chronological order.\n\nFailing to migrate in this order can result in errors due to unanticipated side effects caused by dependencies in the ordering of Rules and Actions.\n\n### Safely rolling back\n\nThe migration tooling allows you to safely and easily roll back if something goes wrong. Re-enable your Rule and skip the corresponding Action logic.\n\n## Migrating a Rule\n\nTo begin migrating your Rule, select **Auth Pipeline > Rules**. Once selected, your Rules appear with an option to migrate each of them individually.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/79DmJp8C2vYZpdos51Z0nM/5a665d04c66dd9f0b8f0e25198cb9e4e/SS1_Dashboard_migration_screenshot.png)\n\n### Migrate to Action\n\nAfter selecting **Migrate to Action**, the tooling prompts you to create a new Action.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/1A8FnVyvqAwW8hbrkOQDoG/f83ba9d5157db14ac2a3a666b2280574/SS2_Migrate_to_Action_screenshot.png)\n\nAfter you select **Create,** the new Action is created and you are presented with the Actions Editor.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/2A10fE69aVngEcL2ZQCqWX/720dca2a8e6005c9378efad3bc140af0/Screenshot_2024-06-06_at_11.55.38_AM.png)\n\nIf the Rule is migrated to Actions and still active, the Rule exits before the logic runs.\n\nThis runs by calling `api.rules.wasExecuted()`. If the `wasExecuted` function consumes a string containing the Rule ID, it returns `true` if the Rule has already run (and otherwise, returns `false`).\n\nThis is a helpful tool to prevent your logic from running twice. As soon as you disable the referenced Rule, the function returns `false` and the business logic now executes in the Action.\n\nFor more information about the `api.rules.wasExecuted()` function, refer to [Actions Triggers: post-login - API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object).\n\n## Rewrite Rule code\n\nSelect the **Rules** button in the Actions Editor to load the Rules Migration tool. There, you can quickly reference the code of the migrated Rule. You should review the code of the selected Rule in the sidebar.\n\nCopy the contents of the Rule function and paste it under the `// YOUR CODE HERE` comment in the Action. It’s likely that this code is not adapted for the Actions programming model.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/2jWCZFnfERuN7NzBPrpCDn/80ba271699893a007dac7baaf2dd44cb/Screenshot_2024-06-06_at_11.57.03_AM.png)\n\nThe Actions Editor provides feedback where code must be refactored. The editor also provides suggestions on how to automatically fix most situations - to review the suggestion or fix, hover over the underlined code:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5jRGI4iDX9ZgwcPRADTbZ1/caa90923a76800526871b137806e2af3/Screenshot_2024-06-06_at_11.58.07_AM.png)\n\nYou may be able to apply Action-specific updates by selecting an option from the **Quick Fix** modal.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/qTS4RD6cjWFVfI0T9Uph3/45776c464f7247ddd8e91860f4646f2e/Screenshot_2024-06-06_at_11.58.48_AM.png)\n\nWhen you select the recommended fix, your code automatically updates to be compatible.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/1cAq5A1MNVLPAsinHjtROh/c71276afd1f6df9e01d71cc869778907/Screenshot_2024-06-06_at_11.59.37_AM.png)\n\nThere are some situations where fixes cannot be applied automatically but guidance is still provided:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/4Lx3RxJh8v4tj1J2SpPVvU/0ff35b0f40bb24d195ab2f4b06817d86/Screenshot_2024-06-06_at_12.00.22_PM.png)\n\nFor example: in the case of the Rule’s `callback` function, it is recommended to use [`api.access.deny`](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow/api-object) for errors, or just `return` in successful cases.\n\n### Test the new Action\n\nActions can be tested directly in the editor, as this is an essential part of the migration journey. For more information, review [Test Actions](https://auth0.com/docs/customize/actions/test-actions).\n\n### Automatically enabling the Action\n\nWhen the Action code is updated and you are ready to make the switch:\n\n1.  Select **Deploy**.\n    \n2.  On the alert that confirms your deployment, select **Add to flow**.\n    \n3.  Add your newly created Action to the flow, then select **Apply.**\n    \n4.  Select **Continue**, **and disable any Rules selected** to simultaneously enable the new Action and disable the original Rule. If you are not ready, select **Cancel**, and you can disable the Rule later to activate the migrated Action logic.\n    \n\nFor more information on adding your Action to the flow, refer to [Write your first Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/47iWYB5o5CyhxvQyHdSTS4/833e6d4541fea132faf793c3e12563a8/SS10.png)\n\n## Migrate remaining rules\n\nThis process can be repeated to migrate each Rule in your login flow. Remember, Rules should be migrated in the reverse order they execute during the login flow.",
  "title": "Migration tooling",
  "description": "Description on how to use the Rule migration tooling in the Auth0 dashboard",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/authorization-extension/set-up-authorization-extension-users",
  "markdown": "# Set Up Users in Authorization Extension Dashboard\n\nIf you have an application that is accessible to everyone within your corporation, the **users** are the individuals to whom you'd like to grant access to your application. If you have a large number of users, managing the access rights and permissions for each one individually can become unwieldy. The **groups** functionality helps make this process easier. For example, your groups can reflect the various departments of your organization: accounting, information technology, engineering, support, and so on. You might also create nested groups, such as by dividing the engineering group into two nested groups: internal tools and client-facing applications. Your organization hierarchy therefore looks like this:\n\n*   Corporation\n    \n    *   Accounting\n        \n    *   Information Technology\n        \n    *   Engineering\n        \n        *   Internal Tools\n            \n        *   Client-Facing Applications\n            \n    *   Support\n        \n\n![Authorization Extension Corporate Groups Diagram](https://images.ctfassets.net/cdy7uua7fh8z/jRZWY5HDZRf1dzXVI0L2C/19a192472218b704d675d9bec966ebd4/corporation.png)\n\nYou can add users to your groups manually or dynamically based on the Connection(s) they're using to access your application. For example, if someone logs in using the Active Directory Connection and their AD profile indicates that they're in the Marketing group, the Authorization Extension can also add them to the Marketing group you're managing with the extension.\n\nFinally, we have permissions and roles, which are groups of permissions. The purpose of the latter is to make it easier to assign several permissions simultaneously to either a user or a group.\n\n![Authorization Extension Roles Permissions Diagram](https://images.ctfassets.net/cdy7uua7fh8z/5EOgccyg3hxlSu00MIEZ1f/8e38920f5b67a0dc2e51be0be1f532f6/roles-permissions.png)\n\nFor example, you may want to grant permissions to:\n\n*   Approve requests for travel\n    \n*   Approve travel expenses\n    \n\nRather than assigning both permissions to groups/users, you can roll the two (along with many others) into a role called **Travel Administrator**. You can then assign Travel Administrator to individual users or to one or more groups.\n\n![Authorization Extension Groups Roles Permissions Diagram](https://images.ctfassets.net/cdy7uua7fh8z/uAkCNyDbbGjUxDhWJPScV/6bec8d56519c319e4a3df683be7707c0/groups-roles-permissions.png)\n\n## Users\n\nThe **Users** section lists all the current users of your applications. Here you can find a specific user, see their profile, change their group affiliations, and change their roles.\n\n![Dashboard - Extensions - Authorization Dashboard - Users](https://images.ctfassets.net/cdy7uua7fh8z/1ALaqm8mvtleQfm3XKvBtf/73fb69c35e2eed4dae74b1baa8e372a2/auth-dashboard-v2.png)\n\n## Groups\n\nTo create and manage the groups with which you'll manage users' settings, click **Groups** in the Authorization Dashboard.\n\nClick **Create Group** to create a new group for your users. You'll be asked to provide a **name** for the group, as well as a **description** for that group.\n\n![Dashboard - Extensions - Authorization Extension - Create New Group](https://images.ctfassets.net/cdy7uua7fh8z/1ur4HTbdZz7PKlNdYFcX16/39ec8e20f833fcc6b56f6ba951a1f68f/create-group-v2.png)\n\nYou can manage your users and their group affiliations in one of two ways:\n\n*   Opening the **group** and managing the group's users\n    \n    ![Dashboard - Extensions - Authorization Extension - Group Membership - Group Management](https://images.ctfassets.net/cdy7uua7fh8z/5mGdeDG5kWbbEm8NQK7h8L/8c9371d19b7987c0251086181353fc78/group-membership-v2.png)\n*   Opening the **user** and managing the user's group membership(s)\n    \n    ![Dashboard - Extensions - Authorization Extension - Group Membership - User Management](https://images.ctfassets.net/cdy7uua7fh8z/3a5gnzfB6PNxvyeJ6Zjk6z/c4986b454485b34715bd9e2f428e1451/user-membership-v2.png)\n\nThe groups you'll create are dependent on the needs of your business process. For example, you might have a group for your users in finance, a group for your users in IT, and so on. Additionally, you may create nested groups that are similar to the following:\n\n*   Example Company\n    \n    *   Accounting\n        \n        *   External Accountants\n            \n    *   Human Resources\n        \n    *   Finance\n        \n        *   Finance IT Support\n            \n    *   Management\n        \n\nTo create nested groups, you must first create all of the individual groups via the **CREATE** button on the Groups page of the Authorization Dashboard.\n\n![Dashboard - Extensions - Authorization Extension - Add Nested Groups](https://images.ctfassets.net/cdy7uua7fh8z/1crGcKf5Hutc4N6s3q4iss/bfeb57a9f916e77ac4d8216412d8c13b/add-nested-groups-v2.png)\n\nTo nest the groups:\n\n1.  Open up the top-level Group (in the example above, this would be the Example Company Group)\n    \n2.  Click on the **Nested Groups** tab\n    \n3.  Click on the **ADD NESTED GROUP** button. You will be presented with a list of Groups that can be added to the primary Group. To select a particular Group, click on the checkbox to the left of the name. After each selection, you will be returned to the primary group page. Continue this process until you have included all the Groups you need.\n    \n\nWith nested groups, adding a user to a sub-group also grants the user permissions granted to the groups that are parents (and grandparents) of that group. For example, adding a user to the External Accountants group automatically makes them a member of the Finance and Company Groups. However, the user is only explicitly a member of External Accountants; all other memberships are purely dynamic and are calculated as needed (for example, when loading the user's group memberships).\n\n![Dashboard - Authorization Extension - Nested Groups - Membership Details](https://images.ctfassets.net/cdy7uua7fh8z/5R17H673JPJkjpC45FjZ1E/b440ef81e3c1b5eb86dd8b12877cb1a6/nested-groups-v2.png)\n\nTo prevent confusion, you will be shown both the explicit members AND the \"calculated members\" that result from nested groups whenever you open a specific group's page in the Authorization Dashboard.\n\n### Group mappings\n\nGroup Mappings allow you to dynamically add users to different Groups based on the users' Connections. Essentially, using the Connection and the groups information provided by the IdP, you can dynamically make the user a member of the group in which you've created the appropriate mapping.\n\nFor example, suppose your users are logging in using their Active Directory (AD) credentials. As part of their identity, AD allows users to have group information associated (such as \"Administrative\" and \"Marketing\").\n\nYou can then configure group mappings to look at a user's profile if they're connecting with the Active Directory connection. When the extension sees that the person is a part of the \"Administrative\" group, it will automatically make the user a member of your company's Admin group.\n\n![Dashboard - Extensions - Authorization Extensions Dashboard - Group Mapping](https://images.ctfassets.net/cdy7uua7fh8z/o77WUpuOKc5LOPZw2Bcu4/d0275f49951fbb114852f04ffd8acd19/group-mapping-v2.png)\n\n## Roles\n\nThe roles that you will create will depend on the access to certain permissions in your application. For example, let's say that you have an application that allows employees to enter in company expenses. You want all employees to be able to submit expenses, but want certain Finance users to have more admin type of actions such as being able to approve or delete expenses. These actions can be mapped to [Permissions](#permissions) and then assigned to a certain Role.\n\nYou can create different types of Roles such as: Expense Admins, Expense Manager, and Expense User for your Expense Management Tool.\n\n![Dashboard - Extensions - Authorization Extensions Dashboard - Permissions](https://images.ctfassets.net/cdy7uua7fh8z/4nTv8DofRA0Xyz6mbJASCl/eeca2e8bd741b764a98ddfdfea24aee4/roles.png)\n\nTo add a role, click the **CREATE ROLE** button from the **Roles** section of the dashboard. Then choose the application this Role applies to (such as Expense Management Tool) and then add a name of the role (such as Expense Admins) and a description of the role. Then select the permissions you wish to grant to this role. If you haven't yet created your permissions you can add them later to an existing Role.\n\n![Dashboard - Extensions - Authorization Extensions Dashboard - Add Role to User](https://images.ctfassets.net/cdy7uua7fh8z/3adPx2VSqkK7560VixOZLN/926e19500a0633f602469bb975f4a0f7/add-role-to-user.png)\n\nOnce you have a **Role** created, you can add it to a user so they can then have the associated **Permissions**. To add a role to a user, find the user in the **Users** section, then click the **Roles** tab. Then click **ADD ROLE TO USER** to choose which roles you wish to assign to a user, then click **SAVE**.\n\n## Permissions\n\nPermissions are the actions or functions that can be added to Roles.\n\nUsing the previous example of an Expense application, let's look at possible roles and how they can be associated with certain permissions:\n\n*   Role: Expense User\n    \n    *   Permissions:\n        \n        *   View their own expenses\n            \n        *   Add a new expense\n            \n*   Role: Expense Admin\n    \n    *   Permissions:\n        \n        *   Approve expenses\n            \n        *   View all user expenses\n            \n        *   Delete expenses\n            \n        *   Add a new expense\n            \n\nTo create a new permission, go to the **Permissions** section of the Authorization Extension dashboard.\n\n![Dashboard - Extensions - Authorization Extensions Dashboard - Permissions](https://images.ctfassets.net/cdy7uua7fh8z/1KuY9kChurITXwOkfvT7Jd/44b2996aa8976acd0fd27b7360bd2c56/permissions.png)\n\nThen click the **CREATE PERMISSION** button. Then enter the name of the permission, the description and select the application for which this permission applies.\n\n![Dashboard - Extensions - Authorization Extensions Dashboard - Create Permissions](https://images.ctfassets.net/cdy7uua7fh8z/4iyUqIAjXwutcNa5pKjeie/6295453f5a9c956c006e481eabc6df0c/create-permission.png)\n\nOnce you have your permissions created, you can associate them with roles.\n\n## Learn more\n\n*   [Configure Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/configure-authorization-extension)\n*   [Enable API Access to Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/enable-api-access-to-authorization-extension)\n*   [Import and Export Authorization Extension Data](https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data)\n*   [Troubleshoot Authorization Extension](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension)\n*   [Use Rules with the Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/use-rules-with-the-authorization-extension)",
  "title": "Set Up Users in Authorization Extension Dashboard",
  "description": "Learn how to set up users, groups, roles, and permissions in the Authorization Extension Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/authorization-extension/enable-api-access-to-authorization-extension",
  "markdown": "# Enable API Access to Authorization Extension\n\nOnce configured and set up, your extension should contain users, as well as groups, roles, and permissions. You can automate provisioning and query the authorization context of your users in real-time if you enable API access to your extension.\n\n## Enable API access\n\n1.  Go to [Auth0 Dashboard > Extensions > Auth0 Authorization](https://manage.auth0.com/#/extensions).\n    \n2.  To get to **API** section, select your Auth0 tenant name on the top right of the **Authorization Dashboard**, then select **API**.\n    \n    ![Dashboard - Extensions - Authorization Extensions Dashboard - Select API](https://images.ctfassets.net/cdy7uua7fh8z/6cF78dwvbK7Sc0JbuxJF85/fbd895fb6f7338559628ea71b3003f52/click-configuration_select-api.png)\n3.  On the **Settings** page, enable the **API Access** switch.\n    \n    ![Dashboard - Extensions - Authorization Extensions Dashboard - Enable API Access](https://images.ctfassets.net/cdy7uua7fh8z/5toxhsSik9EWMnQoK5wTjH/fc40d80a32461e9216f5c69a89e031ec/enable-api-access.png)\n4.  Once API Access is enabled, you'll be able to see or control (within the extension) some of the parameters of the tokens issued by the API. You can control the **time to expiration** of the token, as well as view the token's **audience**, **issuer**, and **URL** to access the API.\n    \n    ![Dashboard - Extensions - Authorization Extensions Dashboard - API Access Enabled](https://images.ctfassets.net/cdy7uua7fh8z/3WfHXaEyi8FvD8pTDlYQpt/cbe92c5b5f4baf9c35a8c686ff4f511d/api-access-enabled.png)\n\n## Access extension API\n\nWhen you enabled API access to the extension, Auth0 automatically created an API for your use in the [Auth0 Dashboard](https://manage.auth0.com/#/apis). To access the API, you'll need to create a Machine to Machine Application, which is the entity that interacts with the API itself.\n\n### Create applications\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **Create Application**. Name your new Application, and choose the **Machine to Machine Application** type. Select **Create** to proceed. You'll be redirected to the **Quick Start** page of the Application, where you can customize the living documentation based on the API with which you'll use the Application. Select the API that Auth0 created for your extension (it should be called **auth0-authorization-extension-api** or similar). Since this is the first time you're working with the API and Application together, you'll see a message that says, \"This application is not authorized for this API.\" To authorize the application for use with the API, select **Navigate to the API and Authorize**.\n    \n    ![Dashboard - Authorization Extensions - Client Quick Start](https://images.ctfassets.net/cdy7uua7fh8z/UbMM1C6a1GjMIhNlk8cCD/462b9dcd29e5d7f5bbd261490e6a46b0/Dashboard_-_Authorization_Extensions_-_Client_Quick_Start.png)\n2.  You'll see a list of Machine to Machine Applications you can use with your API. Enable the switch next to the Application you just created to authorize it.\n    \n    ![Dashboard - Authorization Extension - Clients for API](https://images.ctfassets.net/cdy7uua7fh8z/4WFJ3BhCf2kZjbRWhQ0sCp/38aeb0ca9360fd75bd7d54f897ac1735/Dashboard_-_Authorization_Extension_-_Clients_for_API.png)\n    \n    Once you've authorized the Application, you'll see the **Grant ID**. You can also select the **Scopes** to be granted to the Application. The scopes you grant depends on the endpoints you want to access. For example, you'd grant `read:users` to [get all users](https://auth0.com/docs/api/authorization-extension#get-all-users).\n    \n3.  If you make any changes to the scopes, select **Update** to save.\n    \n    ![Dashboard - Authorization Extension Dashboard - Client Scopes](https://images.ctfassets.net/cdy7uua7fh8z/2RvMFmLusnUOmBp1uXPh1/a78add868b094d37cec63365f745f196/extensions-auth-api-scopes.png)\n\n### Get access token\n\nTo access the API, you'll need to [ask for and obtain the appropriate token](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow).\n\n### Call the API\n\nYou can call the API via:\n\n*   An HTML request\n    \n*   A cURL command\n    \n\nYou can also find detailed information about the endpoints, as well as samples on how to call each endpoint using the three methods above, in the [Authorization Extension API Explorer](https://auth0.com/docs/api/authorization-extension).\n\nYou can also refer to the **API Explorer**, which documents everything you can do via command line once you've enabled access to your extension via API.\n\nSelect the **Explorer** page for the API documentation.\n\n![Authorization Extension API Explorer](https://images.ctfassets.net/cdy7uua7fh8z/5mwKE5muQHYbXKqYZvWOwR/aa0ecec3e5cb803a105d857f24c8b6b7/api-explorer.png)\n\n## Learn more\n\n*   [Use Rules with the Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/use-rules-with-the-authorization-extension)\n*   [Import and Export Authorization Extension Data](https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data)\n*   [Troubleshoot Authorization Extension](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension)",
  "title": "Enable API Access to Authorization Extension",
  "description": "Describes how to enable API access to the Authorization Extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data",
  "markdown": "# Import and Export Authorization Extension Data\n\n```\n{\n  \"configuration\": [\n    {\n      \"_id\": \"v1\",\n      \"rolesInToken\": true\n    }\n  ],\n  \"groups\": [\n    {\n      \"name\": \"Admin\",\n      \"description\": \"Administrators of the company\",\n      \"_id\": \"f185e4aa-0c28-4da7-8639-ae998512c838\"\n    },\n    {\n      \"_id\": \"5f5371c6-c8ff-4c7c-825e-c5ef8ac51cad\",\n      \"name\": \"HR\",\n      \"description\": \"Human Resources\",\n      \"members\": [\n        \"auth0|59c13f5ed6e34e41877c0810\"\n      ],\n      \"roles\": [\n        \"6ab494d6-2592-4af0-a62f-2c13646143d0\"\n      ],\n      \"nested\": [\n        \"59f2adac-9016-4051-ad02-dd5196b8f99e\"\n      ]\n    },\n    {\n      \"name\": \"Trainers\",\n      \"description\": \"HR Trainers for New Employees\",\n      \"_id\": \"59f2adac-9016-4051-ad02-dd5196b8f99e\"\n    }\n  ],\n  \"permissions\": [\n    {\n      \"applicationType\": \"client\",\n      \"applicationId\": \"fhginJh46igC6Rj630UeZBhUyDrgvJ08\",\n      \"description\": \"approve company expenditures\",\n      \"name\": \"Approve Expenses\",\n      \"_id\": \"e61f10f4-837e-4011-a52f-53618bd659e7\"\n    },\n    {\n      \"applicationType\": \"client\",\n      \"applicationId\": \"fhginJh46igC6Rj630UeZBhUyDrgvJ08\",\n      \"description\": \"approve hiring of employees\",\n      \"name\": \"Hire employees\",\n      \"_id\": \"03b94d9b-8893-413d-bdb3-451192264594\"\n    }\n  ],\n  \"roles\": [\n    {\n      \"applicationType\": \"client\",\n      \"applicationId\": \"fhginJh46igC6Rj630UeZBhUyDrgvJ08\",\n      \"description\": \"Control over HR-related tasks\",\n      \"name\": \"HR Manager\",\n      \"permissions\": [\n        \"e61f10f4-837e-4011-a52f-53618bd659e7\",\n        \"03b94d9b-8893-413d-bdb3-451192264594\"\n      ],\n      \"_id\": \"6ab494d6-2592-4af0-a62f-2c13646143d0\"\n    }\n  ]\n}\n```",
  "title": "Import and Export Authorization Extension Data",
  "description": "Describes how to import and export Authorization Extension Data.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/authorization-extension/use-rules-with-the-authorization-extension",
  "markdown": "# Use Rules with the Authorization Extension\n\nYou can use Auth0 Rules with the Authorization Extension to do things like:\n\n*   Add custom claims to the issued token.\n    \n*   Determine the user's group membership, roles, and permissions.\n    \n*   Store the user's groups, roles, and permissions info as part of the `app_metadata`.\n    \n*   Add the user's groups, roles, and permissions to the outgoing token (which can be requested via the `openid groups permissions roles` scope).\n    \n\nBecause the above logic is part of a rule, it will only be executed in the context of a login. If users are added to or removed from a group, this change will only be reflected in Auth0 after the user's next login.\n\nTo learn more, read [Auth0 Rules](https://auth0.com/docs/customize/rules).\n\n## Add custom claims to the issued token\n\nTo add custom claims to your tokens, you can do so by creating an additional rule that allows the Authorization Extension to do so. Custom claims can be namespaced or non-namespaced.\n\nTo learn more, read [Create Custom Claims.](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims)\n\nYou should limit the number of claims you add to the token.\n\n```\nfunction (user, context, callback) {\n  var namespace = 'http://yourdomain/claims/'; // You can set your own namespace, but do not use an Auth0 domain\n\n  // Add the namespaced tokens. Remove any which is not necessary for your scenario\n  context.idToken[namespace + \"permissions\"] = user.permissions;\n  context.idToken[namespace + \"groups\"] = user.groups;\n  context.idToken[namespace + \"roles\"] = user.roles;\n  \n  callback(null, user, context);\n}\n```\n\nThis rule must run **after** the Authorization Extension rule. To make sure this happens, make sure that you place it below the Authorization Extension rule.\n\nWhen calling the `/authorize` endpoint or configuring Lock, you'll need to specify the information you want in the `scope` by indicating `groups`, `permissions` and/or `roles`.\n\n## Control app access\n\nYou can also write rules that are executed after the Authorization Extension rule to do things like control access to your application. One method of doing this is to specify the roles that are required for each application using the application metadata.\n\nFor more details, review [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules).\n\n### Set app metadata required roles\n\nYou can set the app's metadata with roles, which are groups of permissions that you group together to create a specific set of functionality. You can think of this step as \"tagging\" the app so that the rules you set up know which app to act on.\n\n1.  ⁠⁠⁠⁠To set the `context.clientMetadata` field with `required_roles`, select the application you want to work at [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications). This brings you to the application's **Settings**. Scroll down, and select **Show Advanced Settings** at the bottom of the page.\n    \n2.  Under **Application Metadata** add an item setting the **Key** to `required_roles` and in **Value** field list your roles in comma separated style. Select **\\+ Add** to add the field.\n    \n    ![Dashboard - Extensions - Authorization Extension - Advanced Settings - Application Metadata](https://images.ctfassets.net/cdy7uua7fh8z/6Cn2r0OzoMi1xnQVIbto8k/e5eebc82808a73a9e83ba953dc1e8dcd/Dashboard_-_Extensions_-_Authorization_Extension_-_Advanced_Settings_-_Application_Metadata.png)\n3.  When finished, select **Save Changes**. Now, when you log in from this application, in `context.clientMetadata`, you will have the `required_roles` with the roles value string you entered.\n    \n\n### Create rule enforcing app roles\n\nNow that each app has a role associated with it, you can create the rule executes with this piece of app information in context.\n\n1.  Before creating this rule, enable **Roles** under the **Token Contents** and publish the Authorization Extension rule.\n    \n2.  Add this rule and make sure it is listed after the generated \"auth0-authorization-extension\" rule.\n    \n3.  After setting `required_roles`, create a new [rule](https://manage.auth0.com/#/rules) with the following body:\n    \n    ```\n    function (user, context, callback) {\n      context.clientMetadata = context.clientMetadata || {};\n      if (context.clientMetadata.required_roles && context.clientMetadata.required_roles.length){\n        if (user.roles) {\n          var _ = require('lodash');\n          var roles = context.clientMetadata.required_roles.split(',');\n          var matchingRoles =_.filter(user.roles, function(roleName) {\n            return _.includes(roles, roleName);\n          });\n    \n          if (matchingRoles && matchingRoles.length) {\n            return callback(null, user, context);\n          }\n        }\n    \n        return callback(new UnauthorizedError('You do not have the required role to access ' + context.clientName));\n      }\n    \n     callback(null, user, context);\n    }\n    ```\n    \n\n## Learn more\n\n*   [Import and Export Authorization Extension Data](https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data)\n*   [Enable API Access to Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/enable-api-access-to-authorization-extension)\n*   [Troubleshoot Authorization Extension](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension)",
  "title": "Use Rules with the Authorization Extension",
  "description": "Describes how to use information from the Authorization Extension in rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/delegated-administration-extension/create-delegated-admin-applications",
  "markdown": "# Create Delegated Admin Applications\n\nUse the [Delegated Admin Extension](https://auth0.com/docs/customize/extensions/delegated-administration-extension) to expose the **Users** section of the Auth0 Dashboard to a select group of users without allowing them access to the rest of the Dashboard. Before you add the Delegated Admin extension, you need to create the Delegated Admin application in Auth0.\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **Create Application**.\n    \n2.  Enter a descriptive name for your Application (for example, **Users Dashboard**), select an application type of **Single-Page Web Application**, and click **Create**.\n    \n3.  In the **Settings** view, set the **Allowed Callback URLs** and **Allowed Logout URLs** based on your location, and click **Save Changes**.\n    \n    If you are using Node 8:\n    \n    | Location | Name | Login Link for Node.js 8 |\n    | --- | --- | --- |\n    | USA | US-1 | `https://YOUR_TENANT.us8.webtask.io/auth0-delegated-admin` |\n    | Europe | EU  | `https://YOUR_TENANT.eu8.webtask.io/auth0-delegated-admin` |\n    | Australia | AU  | `https://YOUR_TENANT.au8.webtask.io/auth0-delegated-admin` |\n    \n    If you are using Node 12:\n    \n    | Location | Name | Login Link |\n    | --- | --- | --- |\n    | Australia | AU  | `https://{yourTenant}.au.webtask.io/auth0-delegated-admin` |\n    | Europe | EU  | `https://{yourTenant}.eu.webtask.io/auth0-delegated-admin` |\n    | Europe | EU-2 | `https://{yourTenant}.eu.webtask.run/auth0-delegated-admin` |\n    | Japan | JP-1 | `https://{yourTenant}.jp.webtask.run/auth0-delegated-admin` |\n    | UK  | UK  | `https://{yourTenant}.uk.webtask.run/auth0-delegated-admin` |\n    | USA | US-1 | `https://{yourTenant}.us.webtask.io/auth0-delegated-admin` |\n    | USA | US-3 | `https://{yourTenant}.us.webtask.run/auth0-delegated-admin` |\n    \n\nNext, [install the Delegated Admin Extension](https://auth0.com/docs/customize/extensions/delegated-administration-extension/install-delegated-admin-extension).\n\n## Learn more\n\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)",
  "title": "Create Delegated Admin Applications",
  "description": "Learn how to create an application to use with the Delegated Admin Extension, allowing you to selectively expose the users section of the dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-manage-users",
  "markdown": "# Delegated Administration: Manage Users\n\nIn the Application exposed by the Delegated Administration extension, there are two views available: **Users** and **Logs**. On the **User**s view, you can see the display and modify users associated with your Auth0 account.\n\nBy default, all users are displayed, but you can filter the displayed list by configuring a Filter Hook.\n\nFor more information on the Filter Hook, see [Delegation Administration: Filter Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-filter-hook).\n\n## User actions in Delegated Administration dashboard\n\nTo limit the number of options someone with access to the Dashboard exposed by the Delegated Administration extension, configure an Access Hook.\n\nRead more about Access Hooks at [Delegated Administration: Access Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-access-hook).\n\nThe **Change Profile** option is available only if you have configured custom fields.\n\nNotice the new **Reset Password** option available via the extension. This option will send an email to the user allowing them to choose a new password. To do this, select a user, and select **Actions** > **Reset Password**.\n\n![Extensions - Administration Dashboard - Reset password](https://images.ctfassets.net/cdy7uua7fh8z/pb5CYFkEPisB5h06OzgKT/d45bb0831310219088cf2b2d35299c7e/reset-pass-01.png)\n\nThis will send an email to the user, containing a link to change the password.\n\nIf your profile indicates that you have the `Delegated Admin - Administrator` role, the **Logs** view allows you to see a list of authentications made by your users (this view is only visible to users with the `Delegated Admin - Administrator` role). The contents of this view are a subset of the data displayed in [Auth0 Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs). The Logs dashboard also displays data on administrative actions taken in the Auth0 Dashboard.\n\n## Create users\n\nYou can create a new user by selecting the **\\+ Create User** button on the **Users** view. You need to specify email and password. Depending on your role, you may not be able to set the **Departmen**t to which the new user belongs.\n\nFor example, users with the `Delegated Admin - Administrator` role can see the **Department** field and select any of its values.\n\n![Extensions - Administration Dashboard - Create admin](https://images.ctfassets.net/cdy7uua7fh8z/4vrbU6nRuIkF30ZPM4yHnG/73fd2060fe9618c9f465025cb56deb02/create-user-admin.png)\n\nOn the other hand, Kelly, who has the `Delegated Admin - User` role and belongs to the Finance department, cannot see the **Department** field. The user she creates will be automatically assigned to the Finance department.\n\n![Extensions - Delegated Administration Dashboard - Create user](https://images.ctfassets.net/cdy7uua7fh8z/2CSdiPbyiyPsURHH9X5VVZ/8416222627933bd35c044aa15c22dfae/create-user-kelly.png)\n\n#### Delegated Administration session timeout\n\nBy default, token expiration time is 10 hours. However, for security reasons, when using Delegated Administration, Auth0 doesn't save a token to cookies or `sessionStorage`. You must start a new session on each page reload.\n\n## Learn more\n\n*   [Delegated Administration: Extension Hooks](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks)",
  "title": "Delegated Administration: Manage Users",
  "description": "Learn how to manage users in the Delegated Administration Extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks",
  "markdown": "# Delegated Administration: Extension Hooks\n\nIf you're a user assigned the **Delegated Admin - Administrator** role, you can manage the different Extension Hooks and queries that allow you to customize the behavior of the Delegated Administration extension.\n\nTo access the configuration area:\n\n1.  Log in to the Delegated Administration Dashboard.\n    \n2.  Click on your name in the top-right corner. You'll see a dropdown menu; click on the **Configure** option.\n    \n\nThe **Configuration** page to which you're redirected is where you can manage your Hooks and queries.\n\n## Extension Hooks Context\n\nThe context (**ctx**) object will expose a few helpers and information about the current request. The following methods and properties are available in every Extension Hook:\n\n*   Logging\n    \n*   Caching\n    \n*   Custom Data\n    \n*   Payload and Request\n    \n*   Remote Calls\n    \n\n### Logging\n\nTo add a message to the Webtask logs (which you can view using the Realtime Webtask Logs extension), call the **log** method:\n\n```\nfunction(ctx, callback) {\n  ctx.log('Logging action:', ctx.payload.action);\n  return callback();\n}\n```\n\nTo learn more about the Realtime Webtask Log extension, read [Realtime Webtask Logs](https://auth0.com/docs/customize/extensions/real-time-webtask-logs).\n\n### Caching\n\nTo cache something (such as a long list of departments), you can store it on the context's **global** object. This object will be available until the Webtask container recycles.\n\n```\nfunction(ctx, callback) {\n  ctx.global.departments = [ 'IT', 'HR', 'Finance' ];\n  return callback();\n}\n```\n\n### Custom data\n\nYou can store custom data within the extension. This field is limited to 400kb of data.\n\n```\nvar data = {\ndepartments: [ 'IT', 'HR', 'Finance' ]\n};\n\nctx.write(data)\n.then(function() {\n    // ...\n})\n.catch(function(err) {\n    // ...\n});\n```\n\nTo read the data:\n\n```\nctx.read()\n.then(function(data) {\n    // ...\n})\n.catch(function(err) {\n    // ...\n});\n```\n\n### Payload and request\n\nEach Extension Hook exposes the current payload or request with specific information. The request will always contain information about the user that is logged into the Users Dashboard:\n\n```\nfunction(ctx, callback) {\n  ctx.log('Current User:', ctx.request.user);\n  return callback();\n}\n```\n\n### Remote calls\n\nIf you want to call an external service (such as an API) to validate data or to load memberships, you can do this using the `request` module.\n\n```\nfunction(ctx, callback) {\nvar request = require('request');\n    request('http://api.mycompany.com/departments', function (error, response, body) {\n        if (error) {\n        return callback(error);\n        }\n\n        // ...\n    });\n}\n```\n\n### Hook contract\n\n*   `ctx`: The context object\n    \n    *   `payload`: The payload object\n        \n        *   `action`: The current action (for example, `delete:user`) that is being executed\n            \n        *   `user`: The user on which the action is being executed\n            \n*   `callback(error)`: The callback to which you can return an error if access is denied\n    \n\n### Sample use\n\nKelly manages the Finance department, and she should only be able to access users within her department.\n\n```\nfunction(ctx, callback) {\n  if (ctx.payload.action === 'delete:user') {\n    return callback(new Error('You are not allowed to delete users.'));\n  }\n\n  // Get the department from the current user's metadata.\n  var department = ctx.request.user.app_metadata && ctx.request.user.app_metadata.department;\n  if (!department || !department.length) {\n    return callback(new Error('The current user is not part of any department.'));\n  }\n\n  // The IT department can access all users.\n  if (department === 'IT') {\n    return callback();\n  }\n\n  ctx.log('Verifying access:', ctx.payload.user.app_metadata.department, department);\n\n  if (!ctx.payload.user.app_metadata.department || ctx.payload.user.app_metadata.department !== department) {\n    return callback(new Error('You can only access users within your own department.'));\n  }\n\n  return callback();\n}\n```\n\nIf this hook is not configured, all users will be accessible.\n\nSupported action names:\n\n*   `read:user`\n    \n*   `delete:user`\n    \n*   `reset:password`\n    \n*   `change:password`\n    \n*   `change:username`\n    \n*   `change:email`\n    \n*   `read:devices`\n    \n*   `read:logs`\n    \n*   `remove:multifactor-provider`\n    \n*   `block:user`\n    \n*   `unblock:user`\n    \n*   `send:verification-email`\n    \n\n## Available Extension Hooks\n\nThe following Extension Hooks are available for use with the Delegated Administration Application:\n\n*   [Access Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-access-hook)\n    \n*   [Filter Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-filter-hook)\n    \n*   [Memberships Query Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-memberships-query-hook)\n    \n*   [Settings Query Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-settings-query-hook)\n    \n*   [Write Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-write-hook)\n    \n\n## Learn more\n\n*   [Delegated Administration: Access Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-access-hook)\n*   [Delegated Administration: Filter Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-filter-hook)\n*   [Delegated Administration: Memberships Query Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-memberships-query-hook)\n*   [Delegated Administration: Settings Query Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-settings-query-hook)\n*   [Delegated Administration: Write Hook](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks/delegated-administration-write-hook)",
  "title": "Delegated Administration: Extension Hooks",
  "description": "Learn how to customize the behavior of the Delegated Administration Extension using Extension Hooks.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/authorization-extension/migrate-to-authorization-extension-v2",
  "markdown": "# Migrate to Authorization Extension v2\n\nOne of the major changes between versions 1 and 2 of the Authorization Extension is the removal of the **Applications** section. This section was removed to simplify its inherent complexity, such as when it was used to define a policy for access control. The desired approach for such use cases is to use [rules](https://auth0.com/docs/customize/rules).\n\n## Upgrade extension version\n\nTo upgrade the Authorization Extension, go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select the **Installed Extensions** view.\n\nOn the Authorization Extension row, you'll see a link that will begin the upgrade process to the latest version.",
  "title": "Migrate to Authorization Extension v2",
  "description": "Describes how to upgrade the Authorization Extension v2.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/delegated-administration-extension/install-delegated-admin-extension",
  "markdown": "# Install Delegated Admin Extension\n\nYou can install the [Delegated Admin Extension](https://auth0.com/docs/customize/extensions/delegated-administration-extension), which allows you to expose the **Users** section of the Auth0 Dashboard to a select group of users without allowing them access to the rest of the Dashboard.\n\n## Prerequisite\n\n[Create a Delegated Admin Dashboard application](https://auth0.com/docs/dashboard/guides/extensions/delegated-admin-create-app) in Auth0.\n\n## Install extension\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and filter for **Delegated Admin**.\n    \n2.  Select **Delegated Administration Dashboard** in the list of provided extensions. The **Install Extension** window will open.\n    \n    ![Dashboard - Extensions - Delegated Admin - Install](https://images.ctfassets.net/cdy7uua7fh8z/51vm5Sttau4SgnuLbUrKOK/c988e2a52c4b0fc1d091287f14edccda/dashboard-extensions-install_delegated-admin.png)\n3.  Set the following configuration variables, and select **Install**:\n    \n    | Variable | Description |\n    | --- | --- |\n    | **EXTENSION\\_CLIENT\\_ID** | **Client ID** of the application with which you plan to use this extension. |\n    | **TITLE** | Custom title that will appear at the top of the Delegated Administration Dashboard page. |\n    | **CUSTOM\\_CSS** | (_Optional_) Link to a custom CSS you can use to style the look of your Delegated Administration Dashboard page. |\n    | **FAVICON\\_PATH** | (_Optional_) Path to custom favicon. |\n    | **AUTH0\\_CUSTOM\\_DOMAIN** | (_Optional_) If you have a custom domain name configured, enter it here (e.g., `login.example.com`). This will change the authorization endpoint to `https://login.example.com/login`. |\n    | **FEDERATED\\_LOGOUT** | (_Optional_) Indicates whether to sign out from the connection when users log out. |\n    \n    Setting the `AUTH0_CUSTOM_DOMAIN` variable does not affect the extension URL; it only changes the authorization endpoint. When a custom domain is used, users that are logging into the extension will be navigated to `https://AUTH0_CUSTOM_DOMAIN/login` instead of the default `https://tenant-name.us.auth0.com/login`. If you navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), you will see that the extension created an additional application. This application is authorized to access the Management API, so you shouldn't modify it.\n\n## Add callback URLs to Application\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select the name of the application with which you plan to use this extension. This should be the application with the Client ID you entered earlier when setting the configuration variables for the Delegated Administration Dashboard.\n    \n2.  Locate **Allowed Callback URLs**, and add the appropriate callback URL for your region and your tenant's extensibility runtime.\n    \n    | Location | Name | Allowed Callback URL for Node.js 12 |\n    | --- | --- | --- |\n    | USA | US-1 | `https://{yourTenant}.us12.webtask.io/auth0-delegated-admin/login` |\n    | USA | US-3 | `https://{yourTenant}.us.webtask.run/auth0-delegated-admin/login` |\n    | Australia | AU  | `https://{yourTenant}.au12.webtask.io/auth0-delegated-admin/login` |\n    | Europe | EU  | `https://{yourTenant}.eu12.webtask.io/auth0-delegated-admin/login` |\n    | Japan | JP-1 | `https://{yourTenant}.jp.webtask.run/auth0-delegated-admin/login` |\n    \n    | Location | Name | Allowed Callback URL for Node.js 8 |\n    | --- | --- | --- |\n    | USA | US-1 | `https://YOUR_TENANT.us8.webtask.io/auth0-delegated-admin/login` |\n    | Europe | EU  | `https://YOUR_TENANT.eu8.webtask.io/auth0-delegated-admin/login` |\n    | Australia | AU  | `https://YOUR_TENANT.au8.webtask.io/auth0-delegated-admin/login` |\n    \n3.  Select **Save Changes**.\n    \n\n## Use extension\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select the **Installed Extensions** view.\n    \n2.  Select **Delegated Administration Dashboard**. A new tab will open to display the login prompt.\n    \n    ![Extensions - Delegated Admin - Login prompt](https://images.ctfassets.net/cdy7uua7fh8z/3vMz5sulIjCU3BHCfQDJyE/1fd90600422c7d6ae4ca909f37db6784/login-prompt.png)\n    \n    Because we disabled signups for the database connection while configuring it, the login screen will not display a Sign Up option.\n    \n    Once you provide valid credentials, you will be directed to your custom **Delegated Administration Dashboard** page, which will have the **Title** you provided at the top of the page, and if you provided a custom CSS file, that styling will be applied.\n    \n    ![Extensions - Delegated Admin - Standard dashboard](https://images.ctfassets.net/cdy7uua7fh8z/3TqngvmqfsSSajsAzP3M9N/e44325f2d60b05769ed2c7c395c26f25/standard-dashboard.png)\n\n## Learn more\n\n*   [Create Delegated Admin Applications](https://auth0.com/docs/customize/extensions/delegated-administration-extension/create-delegated-admin-applications)",
  "title": "Install Delegated Admin Extension",
  "description": "Describes how to install the Delegated Administration Extension, which allows you to expose the Users section of the Auth0 Dashboard to a select group of users without allowing them access to the rest of the Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/aws/how-to-set-up-aws-for-delegated-authentication",
  "markdown": "# Configure Amazon Web Services for Delegated Authentication\n\nYou can configure Amazon Web Services (AWS) for delegated authentication with Auth0. To learn more, [Configure Amazon Web Services for Single Sign-on](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso) and [Secure AWS API Gateway Endpoints Using Custom Authorizers](https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-custom-authorizers).\n\n## Create a SAML provider in AWS\n\n1.  Log in to AWS, and go to the [IAM console](https://console.aws.amazon.com/iam). Using the left-hand navigation menu, select **Identity Providers**. Click **Create Provider**. Set the following parameters:\n    \n    | Parameter | Description and Sample Value |\n    | --- | --- |\n    | Provider Type | The type of provider. Set as `SAML` |\n    | Provider Name | A descriptive name for the provider, such as `auth0SamlProvider` |\n    | Metadata Document | Upload the file containing the Auth0 metadata, found in **Dashboard > Applications > Application Settings > Advanced Settings > Endpoints > SAML Metadata URL** |\n    \n2.  Click **Next Step**.\n    \n3.  Verify your settings and click **Create** if everything is correct.\n    \n\n## Create a role for your SAML provider\n\nTo use the provider, you must create an IAM role using the provider in the role's trust policy.\n\n1.  In the IAM console, go to [Roles](https://console.aws.amazon.com/iam/home#/roles). Click **Create role**. You'll be redirected to the **Trust** page. Indicate **Saml 2.0 federation** under **Select type of trusted entity**. Provide the following values:\n    \n    | Parameter | Value |\n    | --- | --- |\n    | SAML Provider | The name for your new role |\n    | Attribute | `SAML:iss` |\n    | Value | `urn:{yourDomain}` |\n    \n2.  Click **Next: Permissions** to proceed.\n    \n3.  You will need to attach permissions policies to your new role. You'll attach a custom policy. To create one, click **Create Policy**.\n    \n4.  In the **Create policy** editor that launches, switch over to the **JSON** tab. Provide a custom policy.\n    \n    ```\n    {\n      \"Version\": \"2012-10-17\",\n      \"Statement\": [{\n          \"Effect\": \"Allow\",\n          \"Action\": [\n            \"*\"\n          ],\n          \"Resource\": [\n          \"arn:aws:s3:::{yourBucket}/<%= '${saml:sub}' %>\",\n          \"arn:aws:s3:::{yourBucket}/<%= '${saml:sub}' %>/*\"]\n      }]\n    }\n    ```\n    \n    This defines the permissions that users granted this role will have with AWS. Click **Review policy**.\n5.  Review the policy that you've created. Be sure to provide a **Name** for your policy and (optionally) a **Description**.\n    \n6.  Click **Create policy** when done. If successful, you'll see the following message confirming the creation of your new policy: \"auth0SamlRolePolicy has been created\".\n    \n7.  Returning to the role creation wizard (you should be on step **2 - Permissions**), find the new policy you just create and click its checkbox to attach the policy to your role. We recommend using the **Customer managed** filter to find your policy.\n    \n8.  Click **Next: Review** to proceed.\n    \n9.  Review the information about your role, provide a **Role name**, and optionally a **Role description**. You'll see the policy you attached as well. If everything looks correct, click **Create role** to proceed.\n    \n10.  Once created, you can find your roles located on the primary **Roles** page.\n    \n\n## Copy the ARN Values\n\nThe following instructions will show you where you can find the Provider and Role ARN values.\n\n### Provider ARN\n\nIn the IAM console, go to [Identity providers](https://console.aws.amazon.com/iam/home#/providers). Select the role in which you're interested to open up its summary page. Copy the **Provider ARN** value, which is listed first under **Summary**.\n\n### Role ARN\n\nIn the IAM console, go to [Roles](https://console.aws.amazon.com/iam/home#/roles). Select the role in which you're interested to open up its summary page. Copy the **Role ARN** value, which is listed first under **Summary**.",
  "title": "Configure Amazon Web Services for Delegated Authentication",
  "description": "Learn how to configure Amazon Web Services (AWS) for delegated authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/aws/session-tags",
  "markdown": "# Use Amazon Web Services Session Tags for Role-Based Access Control\n\nWith Amazon Web Services (AWS) Session Tags, you can tag resources and assign users key/value pairs, which allows you to implement role-based access control (RBAC) for AWS APIs and resources.\n\nIn the example included in this guide, we will tag our AWS resources with AWS Session Tags, then create a policy for an AWS IAM role that will allow users with this role and the appropriate tags to perform specific actions on our AWS resources. We will then create a rule in Auth0 that will attach our AWS IAM role and appropriate AWS Session Tags to an Auth0 user and pass them through SAML assertions in the token. This example builds on the example provided in [Configure Amazon Web Services for Single Sign-On](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso).\n\nTo use AWS Session Tags with AWS APIs and Resources, you must:\n\n1.  Tag AWS instances.\n    \n2.  Create a specialized AWS IAM role.\n    \n3.  Create an Auth0 rule.\n    \n4.  Test your configuration.\n    \n\n## Prerequisites\n\n*   You'll need an [Amazon Web Services (AWS) account](https://portal.aws.amazon.com/billing/signup#/start) for which you are an administrator.[](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso)\n    \n*   [Configure AWS for SSO](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso)[](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html#ec2-launch-instance)[](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html#ec2-launch-instance)\n    \n*   [Set up some AWS VM Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html#ec2-launch-instance). For the example in this guide, we use three separate instances.\n    \n\n### Tag AWS instances\n\nAdd tags to your AWS resources. Follow instructions in [Amazon Elastic Compute Cloud User Guide for Linux Instances: Adding and Deleting Tags on an Individual Resource](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#adding-or-deleting-tags).\n\nYou should have created three instances. Add the following tags:\n\n| Instance | Tags |\n| --- | --- |\n| 1   | Key: `CostCenter`, Value: `marketing`.  <br>Key: `Project`, Value: `website`. |\n| 2   | Key: `CostCenter`, Value: `engineering`.  <br>Key: `Project`, Value: `management_dashboard`. |\n| 3   | Key: `CostCenter`, Value: `marketing`.  <br>Key: `Project`, Value: `community_site`. |\n\n### Create a specialized AWS IAM role\n\nCreate an IAM role using the AWS SAML identity provider you set up during the prerequisites. Follow the instructions in [AWS Identity and Access Management User Guide: Creating a Role for SAML 2.0 Federation (Console)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-idp_saml.html).\n\nWhile setting up your role, make sure you use the following parameters:\n\n| Parameter | Description and Sample Value |\n| --- | --- |\n| SAML Provider | Name of the identity provider you created in the prerequisites, such as `auth0SamlProvider`. Select **Allow programmatic and AWS Management Console access**. |\n\nWhen asked to **Attach permissions policies**, create a policy with the following JSON and name it `VirtualMachineAccessByCostCenter`.\n\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ec2:DescribeInstances\"\n            ],\n            \"Resource\": \"*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ec2:StartInstances\",\n                \"ec2:StopInstances\"\n            ],\n            \"Resource\": \"*\",\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"ec2:ResourceTag/CostCenter\": \"<%= \"${aws:PrincipalTag/CostCenter}\" %>\"\n                }\n            }\n        }\n    ]\n}\n```\n\nOnce the policy has been created, refresh the policy list for the role, then filter and select the new policy.\n\nWhen reviewing your settings, make sure you use the following parameters:\n\n| Parameter | Description |\n| --- | --- |\n| Role name | Descriptive name for your role, such as `AccessByCostCenter`. |\n| Role description | Description of the purpose for which your role is used. |\n\n### Create an Auth0 rule\n\nTo map the AWS role and tags to a user, you'll need to [create a rule](https://auth0.com/docs/customize/rules/create-rules) in Auth0. These values will then be passed through the SAML assertions in the token. For the example:\n\n```\nfunction(user, context, callback) {\n  var awsAccount = '013823792818';\n  var rolePrefix = `arn:aws:iam::` + awsAccount; \n  var samlIdP = rolePrefix + `:saml-provider/auth0SamlProvider`;\n\n  user.awsRole = rolePrefix + `:role/AccessByCostCenter,` + samlIdP;\n  user.awsRoleSession = user.email;\n  user.awsTagKeys = ['CostCenter', 'Project'];\n  user.CostCenter = 'marketing';\n  user.Project = 'website';\n\n  context.samlConfiguration.mappings = {\n    'https://aws.amazon.com/SAML/Attributes/Role': 'awsRole',\n    'https://aws.amazon.com/SAML/Attributes/RoleSessionName': 'awsRoleSession',\n    'https://aws.amazon.com/SAML/Attributes/PrincipalTag:CostCenter': 'CostCenter',\n    'https://aws.amazon.com/SAML/Attributes/PrincipalTag:Project': 'Project'\n  };\n\n  callback(null, user, context);\n}\n```\n\n### Test configuration\n\nYou should now be able to log in to the AWS Console using an Auth0 user and test your implementation.\n\nTo log in, you will need the SSO login for the AWS Console. To find it:\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the name of the Application to view.\n    \n2.  On the **Addons** tab, enable the **SAML2 Web App** add-on.\n    \n3.  On the **Usage** tab, locate **Identity Provider Login URL**.\n    \n4.  Go to the indicated URL.\n    \n5.  Once you have signed in, from **EC2**, select **Instances**. Click one of the instances tagged with a `CostCenter` of `marketing`, and click **Actions** > **Instance State** > **Stop**. Notice that the action completes successfully.\n    \n6.  Click the instance tagged with a `CostCenter` of `engineering`, and click **Actions** > **Instance State** > **Stop**. Notice that the action fails with an error.\n    \n\n## Learn more\n\n*   [Configure Amazon Web Services for Single Sign-On](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso)\n*   [Configure Amazon Web Services as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)",
  "title": "Use Amazon Web Services Session Tags for Role-Based Access Control",
  "description": "Learn how to use Amazon Web Services (AWS) Session Tags to implement role-based access control (RBAC) for AWS APIs and Resources.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/authorization-extension",
  "markdown": "# Authorization Extension API Explorer\n\n## Introduction\n\nThe Authorization Extension API enables you to:\n\n*   automate provisioning for your users, roles, groups, and permissions\n*   query the authorization context of your users in real time\n\nIn order to use it, you first have to [enable API access](https://auth0.com/docs/extensions/authorization-extension/v2#enable-api-access) from your Authorization Dashboard.\n\nFor more information on the Authorization Extension and how to configure it, refer to [Auth0 Authorization Extension](https://auth0.com/docs/extensions/authorization-extension).\n\nFor each endpoint in this explorer, you will find sample snippets you can use, in three available formats:\n\n*   HTTP request\n*   Curl command\n*   JavaScript: depending on the endpoint each snippet may use Node.js or simple JavaScript\n\nEach request should be sent with a Content-Type of `application/json`.\n\n## Find your extension URL\n\nAll endpoints in this explorer start with `https://{extension_url}`. This is the URL of your Authorization Dashboard. It differs based on you tenant's region:\n\n| Region | Extension URL |\n| --- | --- |\n| US West | `https://{yourTenant}.us.webtask.io/adf6e2f2b84784b57522e3b19dfc9201/api` |\n| Europe | `https://{yourTenant}.eu.webtask.io/adf6e2f2b84784b57522e3b19dfc9201/api` |\n| Australia | `https://{yourTenant}.au.webtask.io/adf6e2f2b84784b57522e3b19dfc9201/api` |\n\n## Get an Access Token\n\nWhen you [enabled API access for your tenant](https://auth0.com/docs/extensions/authorization-extension/v2#enable-api-access), an API was created at your [dashboard](https://manage.auth0.com/#), which you can use to access the Authorization Extension API.\n\nTo do so you will have to configure a machine to machine application which will have access to this API and which you will use to get an Access Token.\n\nFollow these steps to set up your application (you will have to do this only once):\n\n1.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications) and create a new application of type `Machine to Machine`.\n2.  Go to the [Dashboard > APIs](https://manage.auth0.com/#/apis) and select the `auth0-authorization-extension-api`.\n3.  Go to the `Machine to Machine Applications` tab, find the application you created at the first step, and toggle the `Unauthorized` to `Authorized`.\n4.  Select the [scopes](https://auth0.com/docs/scopes/current/api-scopes) that should be granted to your application, based on the endpoints you want to access. For example, `read:users` to [get all users](#get-all-users).\n\nTo get an Access Token, you need to `POST` to the `/oauth/token` endpoint. You can find detailed instructions [here](https://auth0.com/docs/flows/guides/client-credentials/call-api-client-credentials#request-token).\n\nUse this Access Token to access the Authorization Extension API.\n\n## Groups\n\nGroups are collections of users. The groups that you will create are dependent on the needs of your business process. For example, you might have a group for your users in Finance, a group for your users in IT, and so on.\n\nFor more information, refer to [Auth0 Authorization Extension](https://auth0.com/docs/extensions/authorization-extension#groups).\n\n## Get all Groups\n\n##### Examples\n\n```\nGET https://{extension_url}/groups\nAuthorization:  'Bearer {access_token}'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"groups\":[\n      {\n         \"_id\":\"2a1e2b9f-3435-4954-8c5d-56e8e9ce763f\",\n         \"name\":\"Test\",\n         \"description\":\"Test\",\n         \"members\":[\n            \"auth0|59396da1b3c34a15589c780d\"\n         ],\n         \"mappings\":[\n\n         ]\n      },\n      {\n         \"_id\":\"81097bea-f7a3-48b6-a3fc-e2c3eb6c1ace\",\n         \"name\":\"Google\",\n         \"description\":\"Google\",\n         \"mappings\":[\n            {\n               \"_id\":\"529e053f-285b-4f7f-b73c-c8c37b0ae4f2\",\n               \"groupName\":\"Google\",\n               \"connectionName\":\"google-oauth2\"\n            }\n         ],\n         \"members\":[\n            \"auth0|59396da1b3c34a15589c780d\",\n            \"google-oauth2|113108011846505476166\"\n         ],\n         \"nested\":[\n            \"2a1e2b9f-3435-4954-8c5d-56e8e9ce763f\"\n         ],\n         \"roles\":[\n            \"9b814aac-87ba-4d84-8de6-3bcd0afee761\"\n         ]\n      }\n   ],\n   \"total\":2\n}\n```\n\n### GET /groups\n\nUse this endpoint to retrieve all groups.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n\n## Get a single Group\n\n##### Examples\n\n```\nGET https://{extension_url}/groups/{group_id}\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"_id\": \"2a1e2b9f-3435-4954-8c5d-56e8e9ce763f\",\n  \"name\": \"Test\",\n  \"description\": \"Test\"\n}\n```\n\n### GET /groups/{group\\_id}\n\nUse this endpoint to get a single group based on its unique identifier. Add \"?expand\" to also load all roles and permissions for this group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group to retrieve. |\n\n## Create Group\n\n##### Examples\n\n```\ncurl --request POST \\\n  --url 'https://{extension_url}/groups' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"name\": \"My name\", \"description\": \"My description\"}'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"name\":\"My name\",\n  \"description\":\"My description\",\n  \"_id\":\"3ea7dc85-3e50-4ba8-ae5a-4956ed6b26d5\"\n}\n```\n\n### POST /groups\n\nUse this endpoint to create a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\ncreate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `name`  <br>Required | The name of the new group |\n| `description` | A description of the new group |\n\n## Delete Group\n\n##### Examples\n\n```\nPOST https://{extension_url}/groups/{group_id}\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n```\n\n```\ncurl --request POST \\\n  --url 'https://{extension_url}/groups/{group_id}' \\\n  --header 'Authorization: Bearer {access_token}' \\\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### DELETE /groups/{group\\_id}\n\nUse this endpoint to delete a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\ndelete:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group to delete |\n\n## Update Group\n\n##### Examples\n\n```\nPUT https://{extension_url}/groups/{group_id}\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n{\n  name: \"New name\",\n  description: \"New description\"\n}\n```\n\n```\ncurl --request PUT \\\n  --url 'https://{extension_url}/groups/{group_id}' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --data '{ \"name\": \"New name\", \"description\": \"New description\" }'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"_id\": \"2a1e2b9f-3435-4954-8c5d-56e8e9ce763f\",\n  \"name\": \"New name\",\n  \"description\": \"New description\",\n  \"members\": [\n    \"auth0|59396da1b3c34a15589c780d\"\n  ]\n}\n```\n\n##### PUT /groups/{group\\_id}\n\nUse this endpoint to update the name or the description of a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group to update |\n| `name`  <br>Required | The updated group name |\n| `description`  <br>Required | The updated group description |\n\n## Get Group Mappings\n\n##### Examples\n\n```\nGET https://{extension_url}/groups/{group_id}/mappings\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"_id\":\"529e053f-285b-4f7f-b73c-c8c37b0ae4f2\",\n  \"groupName\":\"Google\",\n  \"connectionName\":\"google-oauth2 (google-oauth2)\"\n}\n```\n\n### GET /groups/{group\\_id}/mappings\n\nUse this endpoint to retrieve the mappings of a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group whose mappings you want to retrieve |\n\n## Create Group Mappings\n\n##### Examples\n\n```\nPATCH https://{extension_url}/groups/{group_id}/mappings\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n{\n  groupName: \"Test\",\n  connectionName: \"google-oauth2\"\n}\n```\n\n```\ncurl -v -X PATCH \\\n  --url 'https://{extension_url}/api/groups/{group_id}/mappings' \\\n  --header 'Content-Type: application/json' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --data '[{\"groupName\": \"Test\", \"connectionName\": \"google-oauth2\"}]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n##### PATCH /groups/{group\\_id}/mappings\n\nUse this endpoint to create one or more mappings in a group.\n\nGroup Mappings allow you to dynamically \"add\" users to different Groups based on the users' Connections. Essentially, using the Connection and the Groups information provided by the Identity Provider, you can dynamically make the user a member of the group in which you've created the appropriate mapping. For more information, refer to [Group Mappings](https://auth0.com/docs/extensions/authorization-extension/v2/implementation/setup#group-mappings).\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group whose mappings you want to retrieve |\n| `groupName`  <br>Required | Group to add the users to |\n| `connectionName`  <br>Required | Connection for the mapping |\n\n## Delete Group Mappings\n\n##### Examples\n\n```\nDELETE https://{extension_url}/groups/{group_id}/mappings\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n{\n  _id: [\n    \"7b57312c-579a-4798-bd91-9647563e1b8a\"\n  ],\n}\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{extension_url}/groups/{group_id}/mappings' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --data '{\"_id\": [\"7b57312c-579a-4798-bd91-9647563e1b8a\"]}'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### DELETE /groups/{group\\_id}/mappings\n\nUse this endpoint to delete one or more group mappings from a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more information on how to implement this, refer to our [machine-to-machine flow implementation guide](https://auth0.com/docs/flows/guides/client-credentials/call-api-client-credentials) |\n| `{group_id}`  <br>Required | The id of the group whose mappings you want to delete |\n\n## Get Group Members\n\n##### Examples\n\n```\nGET https://{extension_url}/groups/{group_id}/members\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"total\":1,\n   \"users\":[\n      {\n         \"email\":\"richard.dowinton@auth0.com\",\n         \"email_verified\":true,\n         \"user_id\":\"auth0|59396da1b3c34a15589c780d\",\n         \"picture\":\"https://s.gravatar.com/avatar/3e8ce75cfe7c53f13715df274f63e129?s=480&r=pg&d=https%3A%2F%2Fcdn.auth0.com%2Favatars%2Fri.png\",\n         \"nickname\":\"richard.dowinton\",\n         \"identities\":[\n            {\n               \"user_id\":\"59396da1b3c34a15589c780d\",\n               \"provider\":\"auth0\",\n               \"connection\":\"Username-Password-Authentication\",\n               \"isSocial\":false\n            }\n         ],\n         \"updated_at\":\"2017-06-25T07:28:54.719Z\",\n         \"created_at\":\"2017-06-08T15:30:41.237Z\",\n         \"name\":\"richard.dowinton@auth0.com\",\n         \"app_metadata\":{\n            \"authorization\":{\n               \"roles\":[\n\n               ],\n               \"permissions\":[\n\n               ]\n            }\n         },\n         \"last_ip\":\"83.208.22.80\",\n         \"last_login\":\"2017-06-25T07:28:54.719Z\",\n         \"logins_count\":12\n      }\n   ]\n}\n```\n\n### GET /groups/{group\\_id}/members\n\nUse this endpoint to get the members for a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group whose members you want to retrieve |\n| `{page}` | The page number. One-based. |\n| `{per_page}` | The amount of entries per page. Default: `25`. Max value: `25`. |\n\n## Add Group Members\n\n##### Examples\n\n```\nPATCH https://{extension_url}/groups/{group_id}/members\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n[ \"google-oauth2|113108011846505476166\" ]\n```\n\n```\ncurl --request PATCH \\\n  --url 'https://{extension_url}/groups/{group_id}/members' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --data '[ \"{user_id}\" ]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### PATCH /groups/{group\\_id}/members\n\nUse this endpoint to add one or more members in a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group to which you want to add members |\n| `{user_id}` | Id of the user to add in a group |\n\n## Delete Group Members\n\n##### Examples\n\n```\nDELETE https://{extension_url}/groups/{group_id}/members\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n[\"7b57312c-579a-4798-bd91-9647563e1b8a\"]\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{extension_url}/groups/{group_id}/members' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --data '[\"7b57312c-579a-4798-bd91-9647563e1b8a\"]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### DELETE /groups/{group\\_id}/members\n\nUse this endpoint to remove one or more members from a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group from which you want to remove members |\n\n## Get Nested Group Members\n\n##### Examples\n\n```\nGET https://{extension_url}/groups/{group_id}/members/nested\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"total\":1,\n   \"nested\":[\n      {\n         \"user\":{\n            \"user_id\":\"auth0|59396da1b3c34a15589c780d\",\n            \"name\":\"richard.dowinton@auth0.com\",\n            \"nickname\":\"richard.dowinton\",\n            \"email\":\"richard.dowinton@auth0.com\"\n         },\n         \"group\":{\n            \"_id\":\"2a1e2b9f-3435-4954-8c5d-56e8e9ce763f\",\n            \"name\":\"New name\",\n            \"description\":\"New description\"\n         }\n      }\n   ]\n}\n```\n\n### GET /groups/{group\\_id}/members/nested\n\nUse this endpoint to get the nested members for a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group from which the nested members will be retrieved |\n| `{page}` | The page number. One-based. |\n| `{per_page}` | The amount of entries per page. Default: `25`. Max value: `25`. |\n\n## Get Nested Groups\n\n##### Examples\n\n```\nGET https://{extension_url}/groups/{group_id}/nested\n```\n\n> RESPONSE SAMPLE:\n\n```\n[\n   {\n      \"_id\":\"2a1e2b9f-3435-4954-8c5d-56e8e9ce763f\",\n      \"name\":\"Test\",\n      \"description\":\"Test\",\n      \"members\":[\n         \"auth0|59396da1b3c34a15589c780d\"\n      ]\n   }\n]\n```\n\n### GET /groups/{group\\_id}/nested\n\nUse this endpoint to get the nested groups for a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group from which the nested members will be retrieved |\n\n## Add Nested Groups\n\n##### Examples\n\n```\nPATCH https://{extension_url}/groups/{group_id}/nested\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n[ \"{group_id_to_add}\" ]\n```\n\n```\ncurl --request PATCH \\\n  --url 'https://{extension_url}/groups/{group_id}/nested' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --header 'Content-Type: application/json' \\\n  --data '[ \"{group_id_to_add}\" ]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### PATCH /groups/{group\\_id}/nested\n\nUse this endpoint to add nested groups.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group to which you want to add members |\n| `{group_id_to_add}` | List of group IDs that you want to add in the group |\n\n## Delete Nested Groups\n\n##### Examples\n\n```\nDELETE https://{extension_url}/groups/{group_id}/nested\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n[\"{NESTED_GROUP_ID}\"]\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{extension_url}/groups/{group_id}/nested' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --data '[\"{NESTED_GROUP_ID}\"]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### DELETE /groups/{group\\_id}/nested\n\nUse this endpoint to remove one or more nested groups.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group from which you want to remove other group members |\n| `{NESTED_GROUP_ID}`  <br>Required | The id of the group to remove |\n\n## Get Group Roles\n\n##### Examples\n\n```\nGET https://{extension_url}/groups/{group_id}/roles\n```\n\n> RESPONSE SAMPLE:\n\n```\n[\n   {\n      \"applicationType\":\"client\",\n      \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n      \"description\":\"Test\",\n      \"name\":\"Test\",\n      \"permissions\":[\n\n      ],\n      \"_id\":\"9b814aac-87ba-4d84-8de6-3bcd0afee761\"\n   }\n]\n```\n\n### GET /groups/{group\\_id}/roles\n\nUse this endpoint to get the roles for a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group from which the nested members will be retrieved |\n\n## Add Group Roles\n\n##### Examples\n\n```\nPATCH https://{extension_url}/groups/{group_id}/roles\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n[ \"google-oauth2|113108011846505476166\" ]\n```\n\n```\ncurl --request PATCH \\\n  --url 'https://{extension_url}/groups/{group_id}/roles' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --data '[ \"{role_id}\" ]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### PATCH /groups/{group\\_id}/roles\n\nUse this endpoint to add roles to a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group to which you want to add members |\n| `{role_id}` | List of role IDs to add in the group |\n\n## Delete Group Roles\n\n##### Examples\n\n```\nDELETE https://{extension_url}/groups/{group_id}/roles\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n[\"{GROUP_ROLES_ID}\"]\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{extension_url}/groups/{group_id}/roles' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --data '[\"{role_id}\"]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### DELETE /groups/{group\\_id}/roles\n\nUse this endpoint to remove one or more groups roles.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group from which you want to remove members |\n| `{role_id}`  <br>Required | The IDs of the roles to be removed from the group |\n\n## Get Nested Group Roles\n\n##### Examples\n\n```\nGET https://{extension_url}/groups/{group_id}/roles/nested\n```\n\n> RESPONSE SAMPLE:\n\n```\n[\n   {\n      \"role\":{\n         \"_id\":\"9b814aac-87ba-4d84-8de6-3bcd0afee761\",\n         \"applicationType\":\"client\",\n         \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n         \"description\":\"Test\",\n         \"name\":\"Test\",\n         \"permissions\":[\n\n         ],\n         \"users\":[\n            \"auth0|59396da1b3c34a15589c780d\"\n         ]\n      },\n      \"group\":{\n         \"_id\":\"81097bea-f7a3-48b6-a3fc-e2c3eb6c1ace\",\n         \"name\":\"Google\",\n         \"description\":\"Google\",\n         \"mappings\":[\n            {\n               \"_id\":\"529e053f-285b-4f7f-b73c-c8c37b0ae4f2\",\n               \"groupName\":\"Google\",\n               \"connectionName\":\"google-oauth2\"\n            }\n         ],\n         \"members\":[\n            \"auth0|59396da1b3c34a15589c780d\",\n            \"google-oauth2|113108011846505476166\"\n         ],\n         \"nested\":[\n            \"2a1e2b9f-3435-4954-8c5d-56e8e9ce763f\"\n         ],\n         \"roles\":[\n            \"9b814aac-87ba-4d84-8de6-3bcd0afee761\"\n         ]\n      }\n   }\n]\n```\n\n### GET /groups/{group\\_id}/roles/nested\n\nUse this endpoint to get the nested roles for a group.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your application retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{group_id}`  <br>Required | The id of the group from which the nested members will be retrieved |\n\n## Roles\n\nRoles are collections of permissions. For example, let's say that you have an application that allows employees to enter in company expenses. You want all employees to be able to submit expenses, but want certain Finance users to have more admin type of actions such as being able to approve or delete expenses. These actions can be mapped to [Permissions](https://auth0.com/docs/extensions/authorization-extension#permissions) and then assigned to a certain role.\n\nFor more information, refer to [Auth0 Authorization Extension](https://auth0.com/docs/extensions/authorization-extension#roles).\n\n## Get all Roles\n\n##### Examples\n\n```\nGET https://{extension_url}/roles\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"roles\":[\n      {\n         \"applicationType\":\"client\",\n         \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n         \"description\":\"Test\",\n         \"name\":\"Test\",\n         \"permissions\":[\n\n         ],\n         \"_id\":\"9b814aac-87ba-4d84-8de6-3bcd0afee761\"\n      },\n      {\n         \"applicationType\":\"client\",\n         \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n         \"description\":\"Example\",\n         \"name\":\"Example 2\",\n         \"permissions\":[\n\n         ],\n         \"_id\":\"7f3d03a7-b44e-4605-ad68-c2d94912a692\"\n      }\n   ],\n   \"total\":2\n}\n```\n\n### GET /roles\n\nUse this endpoint to retrieve all roles.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:roles\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n\n## Get a single Role\n\n##### Examples\n\n```\nGET https://{extension_url}/roles/{role_id}\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"_id\":\"9b814aac-87ba-4d84-8de6-3bcd0afee761\",\n   \"name\":\"Test\",\n   \"description\":\"Test\"\n}\n```\n\n### GET /roles/{role\\_id}\n\nUse this endpoint to get a single role based on its unique identifier.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:roles\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{role_id}`  <br>Required | The id of the role to retrieve. |\n\n## Create Role\n\n##### Examples\n\n```\ncurl --request POST \\\n  --url 'https://{extension_url}/roles' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"name\":\"My new example name\", \"description\":\"Example description\", \"applicationType\":\"client\", \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\", \"permissions\":[\"{permission_id}\"] }'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"name\":\"Example name\",\n   \"description\":\"Example description\",\n   \"applicationType\":\"client\",\n   \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n   \"permissions\":[\n      \"bc6945e0-393a-4405-99d9-96903eaec4a1\"\n   ],\n   \"_id\":\"22787849-f39c-4165-814f-6996ad8e72a0\"\n}\n```\n\n### POST /roles\n\nUse this endpoint to create a role.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\ncreate:roles\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `name` | The new role's name |\n| `description` | The new role's description |\n| `applicationType` | The new role's application type |\n| `applicationId` | The new role's application Id |\n| `permissions` | A comma separated list of permissions (`{permission_id}`) for the new role |\n\n## Update Role\n\n##### Examples\n\n```\nPUT https://{extension_url}/roles/{role_id}\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n{\n   \"name\":\"My new example name\",\n   \"description\":\"Example description\",\n   \"applicationType\":\"client\",\n   \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n   \"permissions\":[\n      \"{permission_id}\"\n   ]\n}\n```\n\n```\ncurl --request PUT \\\n  --url 'https://{extension_url}/roles/{role_id}' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --header 'Content-Type: application/json' \\\n  --data '{ \"name\":\"My new example name\", \"description\":\"Example description\", \"applicationType\":\"client\", \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\", \"permissions\":[\"{permission_id}\"] }'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"_id\":\"22787849-f39c-4165-814f-6996ad8e72a0\",\n   \"name\":\"My new example name\",\n   \"description\":\"Example description\",\n   \"applicationType\":\"client\",\n   \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n   \"permissions\":[\n      \"deeb552d-2d98-4efb-bb84-0c8babe5f431\"\n   ]\n}\n```\n\n##### PUT /roles/{role\\_id}\n\nUse this endpoint to update the details of a role.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:roles\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{role_id}`  <br>Required | The id of the role to update |\n| `name` | The updated role name |\n| `description` | The updated role description |\n| `applicationType` | The updated application type |\n| `applicationId` | The updated application Id |\n| `permissions` | The updated list of permissions |\n\n## Delete Role\n\n##### Examples\n\n```\nDELETE https://{extension_url}/roles/{role_id}\nAuthorization:  'Bearer {access_token}'\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{extension_url}/roles/{role_id}' \\\n  --header 'Authorization: Bearer {access_token}'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### DELETE /roles/{role\\_id}\n\nUse this endpoint to remove a role.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\ndelete:roles\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{role_id}`  <br>Required | The id of the role to delete |\n\n## Permissions\n\nPermissions are actions or functions that a user, or group of user, is allowed to do. For example, let's say that you have an application that allows employees to enter in company expenses. You want all employees to be able to submit expenses, but want certain Finance users to have more admin type of actions such as being able to approve or delete expenses. These actions can be mapped to [permissions](https://auth0.com/docs/extensions/authorization-extension#permissions) (which later on can be grouped in [roles](https://auth0.com/docs/extensions/authorization-extension#roles)):\n\nFor more information, refer to [Auth0 Authorization Extension](https://auth0.com/docs/extensions/authorization-extension#permissions).\n\n## Get all Permissions\n\n##### Examples\n\n```\nGET https://{extension_url}/permissions\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"permissions\":[\n      {\n         \"applicationType\":\"client\",\n         \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n         \"description\":\"Example permission\",\n         \"name\":\"Example\",\n         \"_id\":\"deeb552d-2d98-4efb-bb84-0c8babe5f431\"\n      }\n   ],\n   \"total\":1\n}\n```\n\n### GET /permissions\n\nUse this endpoint to retrieve all permissions.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:permissions\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n\n## Get a single Permission\n\n##### Examples\n\n```\nGET https://{extension_url}/permissions/{permission_id}\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"_id\":\"deeb552d-2d98-4efb-bb84-0c8babe5f431\",\n   \"name\":\"Example\",\n   \"description\":\"Example permission\"\n}\n```\n\n### GET /permissions/{permission\\_id}\n\nUse this endpoint to get a single permission based on its unique identifier.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:permissions\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{permission_id}`  <br>Required | The id of the permission to retrieve. |\n\n## Create Permission\n\n##### Examples\n\n```\ncurl --request POST \\\n  --url 'https://{extension_url}/permissions' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"name\":\"Example name\", \"description\":\"Example description\", \"applicationType\":\"client\", \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\" }'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"name\":\"Example name\",\n   \"description\":\"Example description\",\n   \"applicationType\":\"client\",\n   \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n   \"_id\":\"4dcdbcbb-e598-4b8f-abc1-7feb57dc54fe\"\n}\n```\n\n### POST /permissions\n\nUse this endpoint to create a permission.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\ncreate:permissions\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `name` | The new permission's name |\n| `description` | The new permission's description |\n| `applicationType` | The new permission's application type |\n| `applicationId` | The new permission's application Id |\n\n## Update Permission\n\n##### Examples\n\n```\nPUT https://{extension_url}/permissions/{permission_id}\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n{\n   \"name\":\"New example name\",\n   \"description\":\"Example description\",\n   \"applicationType\":\"client\",\n   \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\"\n}\n```\n\n```\ncurl --request PUT \\\n  --url 'https://{extension_url}/permissions/{permission_id}' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --data '{ \"name\":\"New example name\", \"description\":\"Example description\", \"applicationType\":\"client\", \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\" }'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"_id\":\"bc6945e0-393a-4405-99d9-96903eaec4a1\",\n   \"name\":\"New example name\",\n   \"description\":\"Example description\",\n   \"applicationType\":\"client\",\n   \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\"\n}\n```\n\n##### PUT /permissions/{permission\\_id}\n\nUse this endpoint to update the details of a permission.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:permissions\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{permission_id}`  <br>Required | The id of the permission to update |\n| `name` | The updated permission name |\n| `description` | The updated permission description |\n| `applicationType` | The updated application type |\n| `applicationId` | The updated application Id |\n\n## Delete Permission\n\n##### Examples\n\n```\nDELETE https://{extension_url}/permissions/{permission_id}\nAuthorization:  'Bearer {access_token}'\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{extension_url}/permissions/{permission_id}' \\\n  --header 'Authorization: Bearer {access_token}'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### DELETE /permissions/{permission\\_id}\n\nUse this endpoint to remove a permission.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\ndelete:permissions\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{permission_id}`  <br>Required | The id of the permission to delete |\n\n## Users\n\nThese endpoints enable you to manage all the current users of your applications. You can retrieve their profile and edit or view their groups and their roles.\n\nFor more information, refer to [Auth0 Authorization Extension](https://auth0.com/docs/extensions/authorization-extension/v2#users).\n\n## Get all Users\n\n##### Examples\n\n```\nGET https://{extension_url}/users\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"start\":0,\n   \"limit\":100,\n   \"length\":5,\n   \"users\":[\n      {\n         \"logins_count\":12,\n         \"identities\":[\n            {\n               \"isSocial\":false,\n               \"user_id\":\"59091da1b3c34a15589c780d\",\n               \"provider\":\"auth0\",\n               \"connection\":\"Username-Password-Authentication\"\n            }\n         ],\n         \"user_id\":\"auth0|59091da1b3c34a15589c780d\",\n         \"last_login\":\"2017-06-25T07:28:54.719Z\",\n         \"name\":\"placeholder.user@example.com\",\n         \"picture\":\"https://s.gravatar.com/avatar/your-gravatar.png\",\n         \"email\":\"richard.dowinton@auth0.com\"\n      }\n   ],\n   \"total\":1\n}\n```\n\n### GET /users\n\nUse this endpoint to retrieve all users.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:users\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{page}` | The page number. One-based. |\n| `{per_page}` | The amount of entries per page. Default: `100`. Max value: `200`. |\n\n## Get a single User\n\n##### Examples\n\n```\nGET https://{extension_url}/users/{user_id}\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"email\":\"placeholder.user@example.com\",\n   \"email_verified\":true,\n   \"user_id\":\"auth0|59091da1b3c34a15589c780d\",\n   \"picture\":\"https://s.gravatar.com/avatar/your-gravatar.png\",\n   \"nickname\":\"placeholder.user\",\n   \"identities\":[\n      {\n         \"user_id\":\"59091da1b3c34a15589c780d\",\n         \"provider\":\"auth0\",\n         \"connection\":\"Username-Password-Authentication\",\n         \"isSocial\":false\n      }\n   ],\n   \"updated_at\":\"2017-06-25T07:28:54.719Z\",\n   \"created_at\":\"2017-06-08T15:30:41.237Z\",\n   \"name\":\"placeholder.user@example.com\",\n   \"app_metadata\":{\n      \"authorization\":{\n         \"roles\":[\n\n         ],\n         \"permissions\":[\n\n         ]\n      }\n   },\n   \"last_ip\":\"83.208.22.80\",\n   \"last_login\":\"2017-06-25T07:28:54.719Z\",\n   \"logins_count\":12\n}\n```\n\n### GET /users/{user\\_id}\n\nUse this endpoint to get a single user based on its unique identifier.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:users\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{user_id}`  <br>Required | The id of the user to retrieve. |\n\n## Get User Groups\n\n##### Examples\n\n```\nGET https://{extension_url}/users/{user_id}/groups\n```\n\n> RESPONSE SAMPLE:\n\n```\n[\n   {\n      \"_id\":\"2a1e2b9f-3435-4954-8c5d-56e8e9ce763f\",\n      \"name\":\"Test\",\n      \"description\":\"Test\"\n   },\n   {\n      \"_id\":\"81097bea-f7a3-48b6-a3fc-e2c3eb6c1ace\",\n      \"name\":\"Google\",\n      \"description\":\"Google\"\n   }\n]\n```\n\n### GET /users/{user\\_id}/groups\n\nUse this endpoint to get the groups of a single user, based on its unique identifier. Add \"?expand\" to also load all roles and permissions for these groups.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:users\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{user_id}`  <br>Required | The id of the user to retrieve. |\n\n## Add User to Groups\n\n##### Examples\n\n```\nPATCH https://{extension_url}/users/{user_id}/groups\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n[ \"{group_id}\" ]\n```\n\n```\ncurl --request PATCH \\\n  --url 'https://{extension_url}/users/{user_id}/groups' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --header 'Content-Type: application/json' \\\n  --data '[ \"{group_id}\" ]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### PATCH /users/{user\\_id}/groups\n\nUse this endpoint to add a user to one or more groups.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{user_id}`  <br>Required | The id of the user that you want to add to groups |\n| `{group_id}`  <br>Required | The id of the group to which you want to add users |\n\n## Calculate Group Memberships\n\n##### Examples\n\n```\nGET https://{extension_url}/users/{user_id}/groups/calculate\n```\n\n> RESPONSE SAMPLE:\n\n```\n[\n   {\n      \"_id\":\"2a1e2b9f-3435-4954-8c5d-56e8e9ce763f\",\n      \"name\":\"Test\",\n      \"description\":\"Test\"\n   },\n   {\n      \"_id\":\"81097bea-f7a3-48b6-a3fc-e2c3eb6c1ace\",\n      \"name\":\"Google\",\n      \"description\":\"Google\"\n   }\n]\n```\n\n### GET /users/{user\\_id}/groups/calculate\n\nUse this endpoint to calculate the group memberships for a user (including nested groups).\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:groups\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{user_id}`  <br>Required | The id of the user for whom you want to calculate the group memberships |\n\n## Get User Roles\n\n##### Examples\n\n```\nGET https://{extension_url}/users/{user_id}/roles\n```\n\n> RESPONSE SAMPLE:\n\n```\n[\n   {\n      \"_id\":\"9b814aac-87ba-4d84-8de6-3bcd0afee761\",\n      \"name\":\"Test\",\n      \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n      \"description\":\"Test\"\n   },\n   {\n      \"_id\":\"7f3d03a7-b44e-4605-ad68-c2d94912a692\",\n      \"name\":\"Example 2\",\n      \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n      \"description\":\"Example\"\n   }\n]\n```\n\n### GET /users/{user\\_id}/roles\n\nUse this endpoint to get the roles of a single user, based on its unique identifier.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:users\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{user_id}`  <br>Required | The id of the user for whom you want to retrieve the roles |\n\n## Add User to Roles\n\n##### Examples\n\n```\nPATCH https://{extension_url}/users/{user_id}/roles\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n[ \"{role_id}\" ]\n```\n\n```\ncurl --request PATCH \\\n  --url 'https://{extension_url}/users/{user_id}/roles' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --header 'Content-Type: application/json' \\\n  --data '[ \"{role_id}\" ]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### PATCH /users/{user\\_id}/roles\n\nUse this endpoint to assign a role to a user.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:users\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{user_id}`  <br>Required | The id of the user that you want to assign to roles |\n| `{role_id}`  <br>Required | The id of the role to which you want to assign users |\n\n## Remove User from Roles\n\n##### Examples\n\n```\nDELETE https://{extension_url}/users/{user_id}/roles\nContent-Type:   'application/json'\nAuthorization:  'Bearer {access_token}'\n[ \"{role_id}\" ]\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{extension_url}/users/{user_id}/roles' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --header 'Content-Type: application/json' \\\n  --data '[ \"{role_id}\" ]'\n```\n\n> RESPONSE SAMPLE:\n\n```\n(empty response body)\n```\n\n### DELETE /users/{user\\_id}/roles\n\nUse this endpoint to remove one or more user from a role.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nupdate:roles\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{user_id}`  <br>Required | The id of the user you want to remove from roles |\n| `body`  <br>Required | The id of the role(s) you want to remove users from (i.e. `[ \"{role_id}\" ]`) |\n\n## Calculate Roles\n\n##### Examples\n\n```\nGET https://{extension_url}/users/{user_id}/roles/calculate\n```\n\n> RESPONSE SAMPLE:\n\n```\n[\n   {\n      \"_id\":\"9b814aac-87ba-4d84-8de6-3bcd0afee761\",\n      \"name\":\"Test\",\n      \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n      \"description\":\"Test\"\n   },\n   {\n      \"_id\":\"7f3d03a7-b44e-4605-ad68-c2d94912a692\",\n      \"name\":\"Example 2\",\n      \"applicationId\":\"LcGQZRtjVPPtZfq33I8vtKxldPKPRwBa\",\n      \"description\":\"Example\"\n   }\n]\n```\n\n### GET /users/{user\\_id}/roles/calculate\n\nUse this endpoint to calculate the roles assigned to the user (including through group memberships).\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:roles\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 in order to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{user_id}`  <br>Required | The id of the user for whom you want to calculate the roles |\n\n##### Examples\n\n```\ncurl --request POST \\\n  --url 'https://{extension_url}/users/{user_id}/policy/{client_id}' \\\n  --header 'Authorization: Bearer {access_token}' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"connectionName\": \"Username-Password-Database\", \"groups\": [{group_id}] }'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n   \"groups\":[\n      \"New name\",\n      \"Google\",\n      \"My name\"\n   ],\n   \"permissions\":[\n\n   ],\n   \"roles\":[\n      \"Test\",\n      \"Example 2\"\n   ]\n}\n```\n\n### POST /users/{user\\_id}/policy/{client\\_id}\n\nUse this endpoint to execute the authorization policy for a user in the context of a client. This will return the user's groups but also roles and permissions that apply to the current client.\n\n### Scopes\n\nThe [Access Token](#get-an-access-token) should have the following scopes:\n\nread:users\n\n### Parameters\n\n| Parameter | Description |\n| --- | --- |\n| `{extension_url}`  <br>Required | The URL of your Authorization Extension. For more info, see [Find your extension URL](#find-your-extension-url) |\n| `{access_token}`  <br>Required | The token your client retrieved from Auth0 to access the API. For more info, see [Get an Access Token](#get-an-access-token) |\n| `{user_id}`  <br>Required |     |\n| `{client_id}`  <br>Required |     |\n| `connectionName`  <br>Required | The name of the connection with which the user logged in |\n| `groups` | List of group names received from the IdP (AD, ADFS, and so on) |",
  "title": "Authorization Extension API Explorer",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-delegation",
  "markdown": "# Build Serverless Applications Using Token-Based Authentication with AWS API Gateway and Lambda\n\nWith AWS, you can create powerful, serverless, highly scalable APIs and applications through AWS Lambda, Amazon API Gateway, and a JavaScript application.\n\nA serverless application runs custom code as a compute service without the need to maintain an operating environment to host your service. Instead, a service like [AWS Lambda](https://aws.amazon.com/lambda/) executes your code on your behalf.\n\nAmazon API Gateway extends the capabilities of AWS Lambda by adding a service layer in front of your Lambda functions to extend security, manage input and output message transformations, and provide capabilities like throttling and auditing. A serverless approach simplifies your operational demands, since concerns like scaling out and fault tolerance are now the responsibility of the compute service that is executing your code.\n\nHowever, you often want to tie your APIs to your existing users, either from social providers like Twitter and Facebook, or within your own organization from Active Directory or a customer database. This tutorial demonstrates how to authorize access of your Amazon API Gateway methods for your existing users using Auth0 delegation for AWS and integration with AWS Identity and Access Management (IAM).\n\nNext, the tutorial walks you through setting up the Amazon API Gateway using AWS Lambda functions, securing those functions with AWS IAM roles, and then using Auth0 delegation to obtain a token for the AWS IAM role. It will then show you how to assign different permissions to various classes of users, like internal database or social users, and how to flow identity using a JSON Web Token (JWT).\n\nYou will be taken through the following steps:\n\n*   [Step 1 - Set up the AWS API Gateway](https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-delegation/aws-api-gateway-delegation-1)\n    \n*   [Step 2 - Secure and Deploy the Amazon API Gateway](https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-delegation/aws-api-gateway-delegation-2)\n    \n*   [Step 3 - Build the Application](https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-delegation/aws-api-gateway-delegation-3)\n    \n*   [Step 4 - Use Multiple Roles with Amazon API Gateway](https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-delegation/aws-api-gateway-delegation-4)\n    \n*   [Step 5 - Use Identity Tokens to Flow Identity](https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-delegation/aws-api-gateway-delegation-5)",
  "title": "Build Serverless Applications Using Token-Based Authentication with AWS API Gateway and Lambda",
  "description": "How to build a serverless application using Token-based Authentication with AWS API Gateway and Lambda.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/aws/amazon-cognito",
  "markdown": "# Integrate with Amazon Cognito\n\nAmazon Cognito is a backend-as-a-service that lets you focus on developing the user experience for your application. To learn more and sign up for services, read [Amazon Cognito](http://aws.amazon.com/cognito/).\n\n## Configure Amazon Web Services\n\n### Get Auth0 application details\n\nFirst, you'll need to get some information about your application in Auth0:\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select your application, and then switch to the **Settings** view.\n    \n3.  Record the **Domain** and the **Client ID**.\n    \n\n### Create new OpenID Connect (OIDC) provider\n\nIn AWS, create a new identity provider (IdP):\n\n1.  Open the [IAM Console](https://console.aws.amazon.com/), select **Identity Providers** in the left sidebar, and then select **Create Provider**.\n    \n2.  Select **OpenID Connect** as the **Provider Type**.\n    \n3.  For the **Provider URL**:\n    \n    1.  Enter your **Domain** into the **Provider URL** field.\n        \n    2.  Enter your **Client ID** into the **Audience** field.\n        \n4.  Use the certificate thumbprint to verify the server certificate of your IdP. To learn more, read [Obtaining the Thumbprint for an OpenID Connect Identity Provider on AWS Docs](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc_verify-thumbprint.html).\n    \n5.  Select **Add Provider**.\n    \n6.  Navigate to your newly created provider and record the **Provider ARN.**\n    \n\n### Get Auth0 tenant certificate thumbprint\n\nNext, generate the certificate thumbprint for your Auth0 tenant:\n\n1.  Retrieve your [Auth0 tenant's certificate chain.](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc_verify-thumbprint.html?icmpid=docs_iam_console)\n    \n2.  Isolate the last certificate in the chain. This should be the certificate of your root Certificate Authority (CA).\n    \n3.  Using the CA certificate, [compute the fingerprint](https://www.samltool.com/fingerprint.php).\n    \n4.  Convert the fingerprint to a thumbprint by removing all of the colon (`:`) characters.\n    \n5.  Use the computed thumbprint when calling the `aws iam create-open-id-connect-provider` command.\n    \n\n### Create Identity Pool\n\nCreate an Identity Pool in AWS to allow Cognito to use the Auth0 OIDC identity provider for authentication:\n\n1.  Sign in to the [Cognito Console.](https://console.aws.amazon.com/cognito/home)\n    \n2.  Select **Federated Identities**.\n    \n3.  For **Identity Pool Name**, specify a name for the pool (for example, `Auth0`).\n    \n4.  Under **Authentication Providers**, select the **OpenID** tab, then select the name of the provider you created in the previously.\n    \n5.  Select **Create Pool**, and then select **Allow** to finish creating the new identity pool.\n    \n6.  Under Dashboard, select **Edit Identity Pool** to view the **Identity Pool ID**.\n    \n7.  Record the **ARN** of the IAM role that was automatically created. This value will be used when sending credentials to Cognito.\n    \n\n## Configure Auth0\n\nCognito uses the public signing key from the [OpenID Provider Metadata](https://subscription.auth0.com/.well-known/jwks.json) to validate the signature of the JSON Web Token (JWT).\n\nConfirm that your Auth0 application is configured to use the RS256 signature algorithm:\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), select your application, and then switch to the **Settings** view.\n    \n2.  Expand the **Advanced Settings** section, and then switch to the **OAuth** view.\n    \n3.  Locate the **JSON Web Token (JWT) Signature Algorithm** field, and select **RS256** from the dropdown menu.\n    \n4.  Select **Save Changes**.\n    \n\n## Implementation\n\nYou can use the [Auth0 Lock SDK](https://auth0.com/docs/libraries#lock) to integrate Auth0 within your application.\n\nOnce the user logs in with Auth0, the next step is to send their credentials to Cognito. To learn more, read [Open ID Connect providers (identity pools) on AWS Docs](http://docs.aws.amazon.com/cognito/latest/developerguide/open-id.html).\n\nCognito takes the ID token a user receives from Auth0, and uses it to generate unique Cognito IDs. When the user logs in to Cognito through Auth0, you can store information in Cognito that only they can access.\n\n## Troubleshooting\n\n### \"Invalid login token\" error\n\nIf you receive a \"Invalid login token\" error, confirm that the Auth0 application is configured to use the RS256 signature algorithm:\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), select your application, and then switch to the **Settings** view.\n    \n2.  Expand the **Advanced Settings** section, and then switch to the **OAuth** view.\n    \n3.  Locate the **JSON Web Token (JWT) Signature Algorithm** field, and select **RS256** from the dropdown menu.",
  "title": "Integrate with Amazon Cognito",
  "description": "How to integrate Auth0 with Amazon Cognito using an OpenID Connect (OIDC) Provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso",
  "markdown": "# Configure Amazon Web Services for Single Sign-On\n\nBy integrating Auth0 with AWS, you'll allow your users to log in to AWS using any supported identity provider.\n\nTo configure AWS for SSO, you need to complete the following steps:\n\n1.  Create an external identity provider in AWS.\n    \n2.  Configure the SAML2 Web App addon for your Auth0 application.\n    \n3.  Complete AWS identity provider configuration.\n    \n4.  Create an AWS IAM role.\n    \n5.  Map the AWS role to a user.\n    \n\n## Create an external identity provider in AWS\n\n1.  Set up an external identity provider in AWS using AWS's [Connect to your External Identity Provider](https://docs.aws.amazon.com/singlesignon/latest/userguide/manage-your-identity-source-idp.html) guide with one change.\n    \n    1.  Rather than downloading the AWS metadata file, click **Show Individual Metadata Values**.\n        \n    2.  Copy the **AWS SSO issuer URL** and **AWS SSO ACS URL** values. You will use these in the next section.\n        \n2.  Leave this page open in your browser because you'll need to complete the configuration in a future section.\n    \n\n## Configure SAML SSO for Auth0\n\nConfigure the SAML2 Web App add-on for your application using the Auth0 Dashboard. To learn how, read [Configure Auth0 as Identity Provider for Amazon Web Services](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws).\n\n## Complete AWS identity provider configuration\n\n1.  Return to the open AWS SSO identity provider page in your browser.\n    \n2.  Upload the metadata file you downloaded and saved in the previous section.\n    \n3.  Review and **Confirm** that you are changing the identity source.\n    \n\n## Create AWS IAM role\n\nTo use the provider, you must create an IAM role using the provider in the role's trust policy.\n\n1.  In the sidebar, under **Access Management**, navigate to [**Roles**](https://console.aws.amazon.com/iam/home#/roles). Click **Create Role**.\n    \n2.  On the next page, you will be asked to select the type of trusted entity. Select **SAML 2.0 Federation**.\n    \n3.  When prompted, set the provider you created above as the **SAML provider**. Select **Allow programmatic and AWS Management Console access**. Click **Next** to proceed.\n    \n4.  On the **Attach Permission Policies** page, select the appropriate policies to attach to the role. These define the permissions that users granted this role will have with AWS. For example, to grant your users read-only access to IAM, filter for and select the `IAMReadOnlyAccess` policy. Once you are done, click **Next Step**.\n    \n5.  The third **Create Role** screen is **Add Tags**. You can use tags to organize the roles you create if you will be creating a significant number of them.\n    \n6.  On the **Review** page, set the **Role Name** and review your settings. Provide values for the following parameters:\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Role name** | Descriptive name for your role. |\n    | **Role description** | Description of what your role is used for. |\n    \n7.  Review the **Trusted entities** and **Policies** information, then click **Create Role**.\n    \n\n## Map AWS role to a user\n\nThe **AWS roles** specified will be associated with an **IAM policy** that enforces the type of access allowed to a resource, including the AWS Consoles. To learn more about roles and policies, read [Creating IAM Roles](http://docs.aws.amazon.com/IAM/latest/UserGuide/roles-creatingrole.html).\n\n1.  To map an AWS role to a user, create a [rule](https://auth0.com/docs/customize/rules):\n    \n    ```\n    function (user, context, callback) {\n    \n      user.awsRole = 'arn:aws:iam::951887872838:role/TestSAML,arn:aws:iam::951887872838:saml-provider/MyAuth0';\n      user.awsRoleSession = user.name;\n    \n      context.samlConfiguration.mappings = {\n        'https://aws.amazon.com/SAML/Attributes/Role': 'awsRole',\n        'https://aws.amazon.com/SAML/Attributes/RoleSessionName': 'awsRoleSession'\n      };\n    \n      callback(null, user, context);\n    \n    }\n    ```\n    \n    In the code snippet above, `user.awsRole` identifies the AWS role and the IdP. The AWS role identifier comes before the comma, and the IdP identifier comes after the comma.\n    1.  Your rule can obtain these two values in multiple ways. You can get these values from the IAM Console by selecting the items you created in AWS in the previous steps from the left sidebar. Both the Identity Provider and the Role you created have an ARN available to copy if you select them in the Console.\n        \n    2.  In the example above, both of these values are hard-coded into the rule. Alternatively, you might also store these values in the [user profile](https://auth0.com/docs/videos/get-started-series/learn-user-profiles) or derive them using other attributes. For example, if you're using Active Directory, you can map properties associated with users, such as `group` to the appropriate AWS role:\n        \n        ```\n        var awsRoles = {\n          'DomainUser': 'arn:aws:iam::951887872838:role/TestSAML,arn:aws:iam::95123456838:saml-provider/MyAuth0',\n          'DomainAdmins': 'arn:aws:iam::957483571234:role/SysAdmins,arn:aws:iam::95123456838:saml-provider/MyAuth0'\n        };\n        user.awsRole = awsRoles[user.group];\n        user.awsRoleSession = user.email;\n        \n        context.samlConfiguration.mappings = {\n          'https://aws.amazon.com/SAML/Attributes/Role': 'awsRole',\n          'https://aws.amazon.com/SAML/Attributes/RoleSessionName': 'awsRoleSession',\n        };\n        ```\n        \n\n### Map multiple roles\n\nYou can also assign an array to the role mapping (so you'd have `awsRoles = [ role1, role2 ]` instead of `awsRoles: role1`)\n\nFor example, let's say that you have Active Directory Groups with the following structure:\n\n```\nvar user = {\n  app_metadata: {\n    ad_groups: {\n      \"admins\": \"some info not aws related\",\n      \"aws_dev_Admin\": \"arn:aws:iam::123456789111:role/Admin,arn:aws:iam::123456789111:saml-provider / Auth0\",\n      \"aws_prod_ReadOnly\": \"arn:aws:iam::123456789999:role/ReadOnly,arn:aws:iam::123456789999:saml-provider / Auth0\"\n    }\n  }\n};\n```\n\nYour rule might therefore look like this:\n\n```\nfunction (user, context, callback) {\n\n  var userGroups = user.app_metadata.ad_groups;\n\n  function awsFilter(group) {\n    return group.startsWith('aws_');\n  }\n\n  function mapGroupToRole(awsGroup) {\n    return userGroups[awsGroup];\n  }\n\n  user.awsRole = Object.keys(userGroups).filter(awsFilter).map(mapGroupToRole);\n  user.awsRoleSession = 'myawsuser'; // unique per user http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html\n\n  context.samlConfiguration.mappings = {\n    'https://aws.amazon.com/SAML/Attributes/Role': 'awsRole',\n    'https://aws.amazon.com/SAML/Attributes/RoleSessionName': 'awsRoleSession'\n  };\n\n  callback(null, user, context);\n\n}\n```\n\n## Configure session expiration\n\nTo extend the amount of time allowed to elapse before the AWS session expires (3600 seconds), use a custom [rule](https://auth0.com/docs/customize/rules). Your rule sets the [**SessionDuration** attribute](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_saml_assertions.html) that changes the duration of the session.\n\nto configure this snippet with your account\n\n```\nfunction (user, context, callback) {\n    if(context.clientID !== '{yourClientId}'){\n      return callback(null, user, context);\n    }\n\n  user.awsRole = '{yourArn}';\n  user.awsRoleSession = '{yourRoleSession}';\n  user.time = 1000; // time until expiration in seconds\n\n  context.samlConfiguration.mappings = {\n    'https://aws.amazon.com/SAML/Attributes/Role': '{yourAwsRoleName}',\n    'https://aws.amazon.com/SAML/Attributes/RoleSessionName': '{yourAwsRoleSessionName}',\n    'https://aws.amazon.com/SAML/Attributes/SessionDuration': 'time'   };\n\n  callback(null, user, context);\n}\n```\n\n## Test configuration\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click the name of your application.\n    \n2.  On the **Addons** tab, select the **SAML2 Web App** add-on.\n    \n3.  On the **Usage** tab, locate the **Identity Provider Login URL**. You should be redirected to the Auth0 account login page. If you successfully log in, you'll be redirected to AWS.\n    \n\n## Learn more\n\n*   [Configure Amazon Web Services as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)",
  "title": "Configure Amazon Web Services for Single Sign-On",
  "description": "Learn how to configure single sign-on (SSO) for Auth0 with Amazon Web Services (AWS).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/constant-contact",
  "markdown": "# Export User Data to Constant Contact\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into the Constant Contact dashboard.\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard and open the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. Constant Contact accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n## Import a user data file\n\nBefore you get started, you can find more information by visiting [Constant Contact Knowledge Base: Import or Upload a File of Contact Email Addresses](https://knowledgebase.constantcontact.com/articles/KnowledgeBase/5296-import-or-upload-a-file-of-contact-email-addresses)\n\nTo import your CSV file into Constant Contact, follow these steps:\n\n1.  [Log in to Constant Contact](https://login.constantcontact.com/) and navigate to **Contacts**.\n    \n2.  From the **Contacts** page, click **Add Contacts > Upload from file**.\n    \n3.  Provide you CSV file on the **Upload from file** page then click **Continue**.\n    \n4.  Review the columns and match them with your Constant Contact fields. Once you're finished click **Continue**.\n    \n5.  On the **Select lists** page, choose the list or lists to add your contacts to.\n    \n6.  Click **Upload**.\n    \n\nThat's it! You successfully imported your Auth0 users into Constant Contact.",
  "title": "Export User Data to Constant Contact",
  "description": "Learn how to export your Auth0 user data and import it into Constant Contact.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/alterian",
  "markdown": "# Export User Data to Alterian\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into Alterian with the campaign manager's data import tool.\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard and open the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. Alterian accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n## Import a user data file\n\nBefore you get started, you can find more information by visiting [Alterian Campaign Manager: Data Import](http://cm.help.alterian.com/CM404/Default.htm#Customer_Analytics/Import_Export/Data_Import.htm).\n\nTo import your CSV file into Alterian, follow these steps:\n\n1.  Open your Alterian Campaign Manager and click **Documents**.\n    \n2.  Choose the directory to import the file to.\n    \n3.  Click **Upload Files** and select your CSV file.\n    \n4.  Click **Upload**.\n    \n5.  Once the upload is complete, open the **Data Import** tool.\n    \n6.  Configure your import settings using the provided fields on the **New Imports data** window.\n    \n7.  After you've reviewed your settings, click **Run Processes**.\n    \n\nThat's it! You successfully imported your Auth0 users into Alterian.",
  "title": "Export User Data to Alterian",
  "description": "Learn how to export your Auth0 user data and import it into Alterian.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/eloqua",
  "markdown": "# Export User Data to Oracle Eloqua\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into Eloqua with the contact upload wizard.\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard and open the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. Eloqua accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n## Import a user data file\n\nBefore you get started, you can find more information by visiting [Oracle Eloqua Help Center: Uploading Contacts](https://docs.oracle.com/cloud/latest/marketingcs_gs/OMCAA/index.html#Help/Contacts/Tasks/UploadingContacts.htm).\n\nTo import your CSV file into Eloqua, follow these steps:\n\n1.  Log in to Eloqua and navigate to **Audience > Contacts > Upload** to open the **Contact Upload Wizard**.\n    \n2.  Configure the import using the provided fields on the **Pick Data Source** tab.\n    \n3.  Click the **Cloud** button and select the file to upload.\n    \n4.  After you've verified the file contents on the **Review** tab, click **Next Step**.\n    \n5.  Under the **Map Fields** tab, enter the field mapping settings to match your CSV file data to contact fields. Click **Next Step** to continue.\n    \n6.  Complete the final step of the wizard and click **Finish**.\n    \n\nThat's it! You successfully imported your Auth0 users into Eloqua.",
  "title": "Export User Data to Oracle Eloqua",
  "description": "Learn how to export your Auth0 user data and import it into Oracle Eloqua.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/integrations/sso/ad-rms",
  "markdown": "loading",
  "title": "",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/connections/social/amazon",
  "markdown": "loading",
  "title": "",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/adobe-campaign",
  "markdown": "# Export User Data to Adobe Campaign\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into Adobe Campaign with the [Adobe Campaign Import Wizard](https://docs.adobe.com/content/help/en/campaign-classic/using/getting-started/importing-and-exporting-data/importing-data.html).\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard, and opening the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. Adobe Campaign accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n## Import a user data file\n\nBefore you get started, you can find more information by visiting [Adobe Campaign Documentation: Importing Data](https://docs.adobe.com/content/help/en/campaign-classic/using/getting-started/importing-and-exporting-data/importing-data.html).\n\nLog in to your Adobe Campaign client dashboard and navigate to **Profiles and Targets > Jobs**. Create a new import job by clicking the **Create** button and selecting **New Import**.\n\nA new **Import Wizard** window should open. On the **Template Selection** step you can set your import parameters.\n\nOnce you've configured your import parameters, click the **Next** button to continue.\n\nOn the **File to Import** step upload the user data CSV file you exported from Auth0 in the previous section. Click the **Next** button to proceed to **Field Mapping**.\n\nNext, map the export file schema to your Adobe Campaign database schema. Check that the field names and field types are correct, then click the **Next** button.\n\nComplete the remaining configuration steps by defining your data reconciliation mode and selecting a folder, list, or service for the users being imported.\n\nFinally, begin the import by clicking the **Start** button on the **Data Import Execution** window.\n\nThat's it! You successfully imported your Auth0 users into Adobe Campaign.",
  "title": "Export User Data to Adobe Campaign",
  "description": "Learn how to export your Auth0 user data and import it into Adobe Campaign.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/mailchimp",
  "markdown": "# Export User Data to MailChimp\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into the [MailChimp dashboard](https://login.mailchimp.com/).\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard and open the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. MailChimp accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nTo learn more, review [MailChimp Knowledge Base: Format Guidelines for Your Import File](https://kb.mailchimp.com/lists/growth/format-guidelines-for-your-import-file).\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For MailChimp, an email field with the column name `Email Address` is required, so make sure to include it. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n## Import a user data file\n\nBefore you get started, you can find more information by visiting [MailChimp Knowledge Base: Import Subscribers to a List](https://kb.mailchimp.com/lists/growth/import-subscribers-to-a-list).\n\nLog in to your MailChimp account and go to the **Lists** page. Select a list to import your Auth0 users into ([or create a new list](https://kb.mailchimp.com/lists/growth/create-a-new-list)).\n\n1.  On your MailChimp List page, click on **Import Contacts** from the **Add Contacts** menu.\n    \n2.  Select the `CSV or tab-delimited text file` option to import contacts from.\n    \n3.  Upload the user data CSV file you exported from Auth0 in the previous section. MailChimp will interpret your user data on the following page.\n    \n4.  Check that the column names and field types are correct.\n    \n5.  Click the **Next** button.\n    \n6.  Review your selections and set the import category.\n    \n7.  Click the **Import** button to start the user import.\n    \n\nThat's it! You successfully imported your Auth0 users into MailChimp.",
  "title": "Export User Data to MailChimp",
  "description": "Learn how to export your Auth0 user data and import it into MailChimp.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/watson-campaign-automation",
  "markdown": "# Export User Data to Watson Campaign Automation\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into the Watson Campaign Automation dashboard.\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard and open the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. Watson Campaign Automation accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n## Import a user data file\n\nTo import your CSV file into Watson Campaign Automation, follow these steps:\n\n1.  Log in to Watson Campaign Automation and navigate to **Data > Import New**.\n    \n2.  On the **Select File** step, enter the new database's settings in the provided fields.\n    \n3.  Select the option to upload a file from a local hard drive, then click **Browse** to select the file.\n    \n4.  Set the file type to CSV (comma-separated values).\n    \n5.  Click **Next** to proceed to the **Define Data Format** step.\n    \n6.  Make sure your data was processed correctly, then click **Next**.\n    \n7.  On the **Map Fields** step, choose which fields to include in the import as well as their types.\n    \n8.  Click **Next** to proceed to the **Edit Field Settings** step.\n    \n9.  Edit the settings on default or new fields as needed.\n    \n10.  To start the import click **Next**.\n    \n\nThat's it! You successfully imported your Auth0 users into Watson Campaign Automation.",
  "title": "Export User Data to Watson Campaign Automation",
  "description": "Learn how to export your Auth0 user data and import it into Watson Campaign Automation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/export-user-data-salesforce",
  "markdown": "# Export User Data to Salesforce\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into Salesforce using the Data Import Wizard. To review system requirements, visit the Salesforce article [Data Import Wizard](https://help.salesforce.com/articleView?id=data_import_wizard.htm).\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard and open the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. Salesforce accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n## Import a user data file\n\nDifferent account types may require addition steps for successful import. Take a moment to review the Salesforce article [Prepare Your Data for Import](https://help.salesforce.com/articleView?id=import_prepare.htm). For additional instructions, visit [Salesforce: Import Data with the Data Import Wizard](https://help.salesforce.com/articleView?id=import_with_data_import_wizard.htm).\n\nBefore you begin, make sure your Salesforce account has the required [user permissions](https://help.salesforce.com/articleView?id=faq_import_general_permissions.htm) to import records.\n\nTo import your CSV file into Salesforce, follow these steps:\n\n1.  Login to [Salesforce](https://login.salesforce.com/).\n    \n2.  Navigate to **Setup** and open the **Data Import Wizard**.\n    \n3.  Click **Launch Wizard**.\n    \n4.  Configure the import and select your CSV file to upload using the fields provided.\n    \n5.  Click **Next**.\n    \n6.  On the **Edit Field Mapping** page, map your CSV file's data fields to Salesforce data fields. Click **Next** to proceed.\n    \n7.  After you've verified the information on the **Review** page, click **Start Import**.\n    \n8.  Check out the **Recent Import Jobs** tab on the **Data Import Wizard** home page for updates on the status of your import.\n    \n\nThat's it! You successfully imported your Auth0 users into Salesforce.",
  "title": "Export User Data to Salesforce",
  "description": "Learn how to export your Auth0 user data and import it into Salesforce.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/cms/wordpress-plugin",
  "markdown": "# Login by Auth0 WordPress Plugin\n\nAuth0 provides a WordPress Plugin to integrate your sites with your Auth0 account. This plugin enables Single Sign-on (SSO) for Enterprises, social login, user/password, and passwordless login through all your instances.\n\nLogin features are implemented through a new form (powered by Auth0) that enables:\n\n*   SSO with Enterprise Directories (LDAP, AD, Google Workspace, Office365, and SAML Provider)\n    \n*   SSO with over 30 [Social Providers](https://auth0.com/docs/identityproviders)\n    \n*   SSO between WordPress installs and other applications\n    \n*   User Management Dashboard\n    \n*   Optional Multi-factor Authentication\n    \n*   Optional Passwordless Authentication\n    \n*   Reporting and Analytics\n    \n\n## Learn more\n\n*   [Integrate with WordPress](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/integrate-with-wordpress)\n*   [Install Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/install-login-by-auth0)\n*   [Configure Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0)\n*   [Troubleshoot Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/troubleshoot-login-by-auth0)",
  "title": "Login by Auth0 WordPress Plugin",
  "description": "This page explains the basics of the Login by Auth0 WordPress plugin",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/salesforce-marketing-cloud",
  "markdown": "# Export User Data to Salesforce Marketing Cloud\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into Salesforce Marketing Cloud using Email Studio.\n\nTo read more, review the Salesforce article [Get Started Checklist for Email Studio](https://help.salesforce.com/articleView?id=mc_es_get_started_with_email_studio.htm&type=5).\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard and open the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. Salesforce Marketing Cloud accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n## Import a user data file\n\nBefore you begin, make sure your Salesforce account has the required [](https://help.salesforce.com/articleView?id=faq_import_general_permissions.htm)user permissions to import records. Also, you should take a moment to review the steps in the Salesforce article [Email Studio: Import Subscribers](https://help.marketingcloud.com/en/documentation/exacttarget/subscribers/subscribers_for_interactive_marketing_hub/imports/importing_subscribers/) along with [What permissions do I need to import records](https://help.salesforce.com/articleView?id=faq_import_general_permissions.htm).\n\nTo import your CSV file into Salesforce Marketing Cloud, follow these steps:\n\n1.  Log in to Salesforce Marketing Cloud and open **Email Studio**.\n    \n2.  Navigate to **Subscribers > Lists**.\n    \n3.  Choose the list to import to and select the **Import** action.\n    \n4.  After the import wizard's introduction, select your CSV file as the **Upload Source** and select CSV as the **Data Format**. Enter the remaining settings and click **Next**.\n    \n5.  In the **Map Attributes** dialog, map your CSV file's data fields to the correct data fields. When you've finished your mappings click **Next**.\n    \n6.  After you've verified your mappings in the **Confirmed Mappings** dialog, click **Begin** to start the import.\n    \n\nThat's it! You successfully imported your Auth0 users into Salesforce Marketing Cloud.",
  "title": "Export User Data to Salesforce Marketing Cloud",
  "description": "Learn how to export your Auth0 user data and import it into Salesforce Marketing Cloud.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/sailthru",
  "markdown": "# Export User Data to Sailthru\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into the Sailthru dashboard.\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard and open the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. Sailthru accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n### Import a user data file\n\nBefore you get started, you can find more information by visiting [Sailthru Documentation: Adding Users to Sailthru and Sailthru Lists](https://getstarted.sailthru.com/audience/managing-users/add-users-to-sailthru-and-lists/#List_File_Upload).\n\nTo import your CSV file into Sailthru, follow these steps:\n\n1.  Log in to Sailthru and navigate to [Lists](https://my.sailthru.com/lists).\n    \n2.  Choose a list, then click **Upload List** and select your CSV file.\n    \n3.  Select **Add To List** for the **Action**.\n    \n4.  Set your **Replace Vars** option and enter an email to receive notifications if desired.\n    \n5.  Review your settings and click **Submit** to upload the file.\n    \n\nThat's it! You successfully imported your Auth0 users into Sailthru.",
  "title": "Export User Data to Sailthru",
  "description": "Learn how to export your Auth0 user data and import it into Sailthru.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations/marketo",
  "markdown": "# Export User Data to Marketo\n\nIn this article, you’ll learn how to export user data in Auth0 to a CSV file then import it into Marketo using the [Bulk Leads endpoint](http://developers.marketo.com/rest-api/endpoint-reference/lead-database-endpoint-reference/#/Bulk_Leads) of the Marketo REST API.\n\n## Create a user data file\n\nStart by navigating to the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard and open the **User Import / Export Extension**. On the extension page, select **Export** from the menu.\n\nNext, set the **Export Format** to the required file format. Marketo accepts file imports in CSV format so choose the `Tab Separated Value file (*.csv)` option.\n\n![Dashboard - Extensions - User Import/Export Extension - Set Format](https://images.ctfassets.net/cdy7uua7fh8z/7t85LanHsA9xUIfiYgtmRt/a2ac89c7a1a5dbf46b686993ac41b8f3/import-export-set-format.png)\n\nAt the top in the **Fields** section, provide a **User Field** and **Column Name** for each user attribute to include in the export. For example:\n\n| User Field | Column Name |\n| --- | --- |\n| `email` | Email Address |\n| `created_at` | Created At |\n| `given_name` | First Name |\n| `family_name` | Last Name |\n\n![Dashboard - Extensions - User Import/Export - Extension Fields](https://images.ctfassets.net/cdy7uua7fh8z/3LtGPiE6o0aefYj0gMP3Q9/73dae2d5699c2322b62ff4de65ff862a/import-export-fields.png)\n\nAfter adding the user fields, click on the **Export Users** button to start the export. Once the export is complete, download the CSV file to use in the following section.\n\n### Import a user data file\n\nBefore you get started, you can find more information by visiting [Marketo Documentation: Bulk Lead Import](http://developers.marketo.com/rest-api/bulk-import/bulk-lead-import/).\n\nTo import the user data file to Marketo, perform a POST request to the [Bulk Leads endpoint](http://developers.marketo.com/rest-api/endpoint-reference/lead-database-endpoint-reference/#/Bulk_Leads). Set the content-type header of the request to `multipart/form-data` and include a `file` parameter with your exported CSV file as well as format parameter set to `csv`. For example:\n\n*   [cURL](#16de1efb58d34ac38cb12aed97d92757_shell)\n*   [C#](#16de1efb58d34ac38cb12aed97d92757_csharp)\n*   [Go](#16de1efb58d34ac38cb12aed97d92757_go)\n*   [Java](#16de1efb58d34ac38cb12aed97d92757_java)\n*   [Node.JS](#16de1efb58d34ac38cb12aed97d92757_node)\n*   [Obj-C](#16de1efb58d34ac38cb12aed97d92757_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url https://marketo_rest_api_base_url/bulk/v1/leads.json \\\n  --header 'authorization: Bearer {MARKETO_ACCESS_TOKEN}' \\\n  --form file=@auth0_users.csv \\\n  --form format=csv\n```\n\n```\nvar client = new RestClient(\"https://marketo_rest_api_base_url/bulk/v1/leads.json\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {MARKETO_ACCESS_TOKEN}\");\nrequest.AddHeader(\"content-type\", \"multipart/form-data; boundary=---011000010111000001101001\");\nrequest.AddParameter(\"multipart/form-data; boundary=---011000010111000001101001\", \"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"auth0_users.csv\\\"\\r\\nContent-Type: text/csv\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"format\\\"\\r\\nContent-Type: text/plan\\r\\n\\r\\ncsv\\r\\n-----011000010111000001101001--\\r\\n\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://marketo_rest_api_base_url/bulk/v1/leads.json\"\n\n\tpayload := strings.NewReader(\"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"auth0_users.csv\\\"\\r\\nContent-Type: text/csv\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"format\\\"\\r\\nContent-Type: text/plan\\r\\n\\r\\ncsv\\r\\n-----011000010111000001101001--\\r\\n\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {MARKETO_ACCESS_TOKEN}\")\n\treq.Header.Add(\"content-type\", \"multipart/form-data; boundary=---011000010111000001101001\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://marketo_rest_api_base_url/bulk/v1/leads.json\")\n  .header(\"authorization\", \"Bearer {MARKETO_ACCESS_TOKEN}\")\n  .header(\"content-type\", \"multipart/form-data; boundary=---011000010111000001101001\")\n  .body(\"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"auth0_users.csv\\\"\\r\\nContent-Type: text/csv\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"format\\\"\\r\\nContent-Type: text/plan\\r\\n\\r\\ncsv\\r\\n-----011000010111000001101001--\\r\\n\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://marketo_rest_api_base_url/bulk/v1/leads.json',\n  headers: {\n    authorization: 'Bearer {MARKETO_ACCESS_TOKEN}',\n    'content-type': 'multipart/form-data; boundary=---011000010111000001101001'\n  },\n  data: '-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\"file\"; filename=\"auth0_users.csv\"\\r\\nContent-Type: text/csv\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\"format\"\\r\\nContent-Type: text/plan\\r\\n\\r\\ncsv\\r\\n-----011000010111000001101001--\\r\\n'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {MARKETO_ACCESS_TOKEN}\",\n                           @\"content-type\": @\"multipart/form-data; boundary=---011000010111000001101001\" };\nNSArray *parameters = @[ @{ @\"name\": @\"file\", @\"fileName\": @\"auth0_users.csv\", @\"contentType\": @\"text/csv\" },\n                         @{ @\"name\": @\"format\", @\"value\": @\"csv\", @\"contentType\": @\"text/plan\" } ];\nNSString *boundary = @\"---011000010111000001101001\";\n\nNSError *error;\nNSMutableString *body = [NSMutableString string];\nfor (NSDictionary *param in parameters) {\n    [body appendFormat:@\"--%@\\r\\n\", boundary];\n    if (param[@\"fileName\"]) {\n        [body appendFormat:@\"Content-Disposition:form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\\r\\n\", param[@\"name\"], param[@\"fileName\"]];\n        [body appendFormat:@\"Content-Type: %@\\r\\n\\r\\n\", param[@\"contentType\"]];\n        [body appendFormat:@\"%@\", [NSString stringWithContentsOfFile:param[@\"fileName\"] encoding:NSUTF8StringEncoding error:&error]];\n        if (error) {\n            NSLog(@\"%@\", error);\n        }\n    } else {\n        [body appendFormat:@\"Content-Disposition:form-data; name=\\\"%@\\\"\\r\\n\\r\\n\", param[@\"name\"]];\n        [body appendFormat:@\"%@\", param[@\"value\"]];\n    }\n}\n[body appendFormat:@\"\\r\\n--%@--\\r\\n\", boundary];\nNSData *postData = [body dataUsingEncoding:NSUTF8StringEncoding];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://marketo_rest_api_base_url/bulk/v1/leads.json\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://marketo_rest_api_base_url/bulk/v1/leads.json\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"auth0_users.csv\\\"\\r\\nContent-Type: text/csv\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"format\\\"\\r\\nContent-Type: text/plan\\r\\n\\r\\ncsv\\r\\n-----011000010111000001101001--\\r\\n\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {MARKETO_ACCESS_TOKEN}\",\n    \"content-type: multipart/form-data; boundary=---011000010111000001101001\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"marketo_rest_api_base_url\")\n\npayload = \"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"auth0_users.csv\\\"\\r\\nContent-Type: text/csv\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"format\\\"\\r\\nContent-Type: text/plan\\r\\n\\r\\ncsv\\r\\n-----011000010111000001101001--\\r\\n\"\n\nheaders = {\n    'authorization': \"Bearer {MARKETO_ACCESS_TOKEN}\",\n    'content-type': \"multipart/form-data; boundary=---011000010111000001101001\"\n    }\n\nconn.request(\"POST\", \"/bulk/v1/leads.json\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://marketo_rest_api_base_url/bulk/v1/leads.json\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {MARKETO_ACCESS_TOKEN}'\nrequest[\"content-type\"] = 'multipart/form-data; boundary=---011000010111000001101001'\nrequest.body = \"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"auth0_users.csv\\\"\\r\\nContent-Type: text/csv\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"format\\\"\\r\\nContent-Type: text/plan\\r\\n\\r\\ncsv\\r\\n-----011000010111000001101001--\\r\\n\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {MARKETO_ACCESS_TOKEN}\",\n  \"content-type\": \"multipart/form-data; boundary=---011000010111000001101001\"\n]\nlet parameters = [\n  [\n    \"name\": \"file\",\n    \"fileName\": \"auth0_users.csv\",\n    \"contentType\": \"text/csv\"\n  ],\n  [\n    \"name\": \"format\",\n    \"value\": \"csv\",\n    \"contentType\": \"text/plan\"\n  ]\n]\n\nlet boundary = \"---011000010111000001101001\"\n\nvar body = \"\"\nvar error: NSError? = nil\nfor param in parameters {\n  let paramName = param[\"name\"]!\n  body += \"--\\(boundary)\\r\\n\"\n  body += \"Content-Disposition:form-data; name=\\\"\\(paramName)\\\"\"\n  if let filename = param[\"fileName\"] {\n    let contentType = param[\"content-type\"]!\n    let fileContent = String(contentsOfFile: filename, encoding: String.Encoding.utf8)\n    if (error != nil) {\n      print(error)\n    }\n    body += \"; filename=\\\"\\(filename)\\\"\\r\\n\"\n    body += \"Content-Type: \\(contentType)\\r\\n\\r\\n\"\n    body += fileContent\n  } else if let paramValue = param[\"value\"] {\n    body += \"\\r\\n\\r\\n\\(paramValue)\"\n  }\n}\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://marketo_rest_api_base_url/bulk/v1/leads.json\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe response should look something like this:\n\n```\n{\n    \"requestId\": \"e42b#14272d07d78\",\n    \"success\": true,\n    \"result\": [{\n        \"batchId\": 1234,\n        \"status\": \"Importing\"\n    }]\n}\n```\n\nYou can check the status of your import using the [Get Import Lead Status API](https://auth0.com/docs/) and your import job's `batchId`. For example:\n\n*   [cURL](#c98372be32434a0aa72b83b3313d004a_shell)\n*   [C#](#c98372be32434a0aa72b83b3313d004a_csharp)\n*   [Go](#c98372be32434a0aa72b83b3313d004a_go)\n*   [Java](#c98372be32434a0aa72b83b3313d004a_java)\n*   [Node.JS](#c98372be32434a0aa72b83b3313d004a_node)\n*   [Obj-C](#c98372be32434a0aa72b83b3313d004a_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://marketo_rest_api_base_url/bulk/v1/leads/batch/BATCH_ID.json \\\n  --header 'authorization: Bearer {MARKETO_ACCESS_TOKEN}'\n```\n\n```\nvar client = new RestClient(\"https://marketo_rest_api_base_url/bulk/v1/leads/batch/BATCH_ID.json\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {MARKETO_ACCESS_TOKEN}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://marketo_rest_api_base_url/bulk/v1/leads/batch/BATCH_ID.json\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {MARKETO_ACCESS_TOKEN}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://marketo_rest_api_base_url/bulk/v1/leads/batch/BATCH_ID.json\")\n  .header(\"authorization\", \"Bearer {MARKETO_ACCESS_TOKEN}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://marketo_rest_api_base_url/bulk/v1/leads/batch/BATCH_ID.json',\n  headers: {authorization: 'Bearer {MARKETO_ACCESS_TOKEN}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {MARKETO_ACCESS_TOKEN}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://marketo_rest_api_base_url/bulk/v1/leads/batch/BATCH_ID.json\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://marketo_rest_api_base_url/bulk/v1/leads/batch/BATCH_ID.json\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {MARKETO_ACCESS_TOKEN}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"marketo_rest_api_base_url\")\n\nheaders = { 'authorization': \"Bearer {MARKETO_ACCESS_TOKEN}\" }\n\nconn.request(\"GET\", \"/bulk/v1/leads/batch/BATCH_ID.json\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://marketo_rest_api_base_url/bulk/v1/leads/batch/BATCH_ID.json\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {MARKETO_ACCESS_TOKEN}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {MARKETO_ACCESS_TOKEN}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://marketo_rest_api_base_url/bulk/v1/leads/batch/BATCH_ID.json\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nAnd the response:\n\n```\n{\n    \"requestId\": \"8136#146daebc2ed\",\n    \"success\": true,\n    \"result\": [{\n        \"batchId\": 1234,\n        \"status\": \"Complete\",\n        \"numOfLeadsProcessed\": 123,\n        \"numOfRowsFailed\": 0,\n        \"numOfRowsWithWarning\": 0\n    }]\n}\n```\n\nThat's it! You successfully imported your Auth0 users into Marketo.",
  "title": "Export User Data to Marketo",
  "description": "Learn how to export your Auth0 user data and import it into Marketo.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/integrate-with-wordpress",
  "markdown": "# Integrate with WordPress\n\nThe Login by Auth0 plugin handles login and account creation flows automatically by creating or matching user accounts with incoming Auth0 profile data. The login process and the signup process are similar and an account will be created or matched based on the data in your WordPress database. Logging in via Auth0 creates a WordPress account, and sign up via Auth0 matches an existing WordPress account.\n\nIf you are using the User Migration setting in the plugin, the login flow will be slightly different from what is explained below. To learn more, read [User Migration in Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/user-migration-in-login-by-auth0).\n\nBelow are the steps in the process:\n\n1.  The user accesses the WordPress site's login page. This could be the main login page at `[SITE URL]/wp-login.php` or a page containing a widget or shortcode.\n    \n2.  The user provides their username and password, clicks on a social icon to use another identity provider, or completes the Passwordless process in the Auth0 login form, Lock.\n    \n3.  Auth0 attempts to authenticate the user with the method selected.\n    \n    1.  If login or signup with a username + password or with Passwordless fails, an error message appears on Lock.\n        \n    2.  If it is successful, the process continues.\n        \n4.  The user is redirected to the `/authorize` endpoint with a login ticket and a `state` value generated by the plugin. Once this is complete, the Auth0 user record has been created and the rest of the process happens on the WordPress site.\n    \n5.  The actual login process differs whether you are using the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) or the [Implicit Flow](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow):\n    \n    1.  For Authorization Code Flow logins:\n        \n        1.  The user is redirected back to a callback URL, `SITE URL/index.php?auth0=1` with an authorization code and the same `state` value in URL parameters.\n            \n        2.  The `state` value is validated. If validation does not pass, an \"Invalid state\" error is shown and the login process stops. To learn more about state validation, read [Troubleshoot Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/troubleshoot-login-by-auth0).\n            \n        3.  The ID token is validated to make sure nothing was modified during transit. If the ID token is invalid, an error message is shown and the login process stops (see the Troubleshooting page for more information on ID token validation)\n            \n        4.  The user profile data is retrieved via the Management API using the Machine-to-Machine Flow. To learn more, read [Machine-to-Machine Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).\n            \n    2.  For Implicit Flow logins:\n        \n        1.  The user is redirected back to a callback URL, `SITE URL/wp-login.php?auth0=implicit` with an ID token and the same `state` value in an anchor link.\n            \n        2.  This anchor link is parsed in JS and then POSTed back to a callback URL `SITE URL/index.php?auth0=implicit` with those 2 same values in URL parameters.\n            \n        3.  The ID token is validated to make sure nothing was modified during transit. If the ID token is invalid, an error message is shown and the login process stops (see the Troubleshooting page for more information on ID token validation)\n            \n        4.  The information in the valid ID token is used as the user profile data.\n            \n6.  The Auth0 authentication process is complete and the plugin attempts to match the profile data with a user in WordPress.\n    \n7.  The plugin checks whether the site requires an email address (plugin settings **Advanced** tab) and if the incoming profile has an `email_verified` flag set.\n    \n    1.  If the site requires an email address and the incoming user does not provide an email address (some social identity providers, like X, do not include an email address), the login process stops with an error message stating \"This account does not have an email associated.\"\n        \n    2.  If the site requires an email address and the incoming user does not have the `email_verified` flag set to `true`, the login process stops with an error message stating \"This site requires a verified email address\" and a link to re-send the verification email. This continues to show until the user successfully verifies their email address.\n        \n    3.  If the site does not require an email address or the incoming user has the `email_verified` flag set to `true`, then the login process continues.\n        \n8.  The plugin checks to see if there is a user in the WordPress database with a `usermeta` value that matches the incoming Auth0 user ID (meaning that the user has signed up or logged in with Auth0 before):\n    \n    1.  If a user is found that has the incoming user ID then the login process continues.\n        \n    2.  If a user is not found with the incoming Auth0 user ID, the plugin looks for an email address matching the incoming user:\n        \n        1.  If a match is found, that user is selected and the login process continues.\n            \n        2.  If a match is not found, the plugin checks if registration is turned on for the WordPress site:\n            \n            1.  If registration is turned off, the login process stops with an error message stating \"Could not create user. The registration process is not available\"`.`\n                \n            2.  If registration is turned on, a new user is created and the login process continues.\n                \n9.  The found or created user is updated with the incoming Auth0 profile data, including their Auth0 user ID.\n    \n10.  The user is logged into their WordPress account with `wp_set_auth_cookie` and the core `do_login` action fires.\n    \n11.  The user is redirected to a page on the site, which could be the default set in the plugin settings **Advanced** tab or the original login URL if a shortcode or widget was used or a different one provided during the login process.\n    \n\nThe user is now logged into Auth0 and their WordPress account with the two associated by their Auth0 user ID.\n\n## Learn more\n\n*   [Install Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/install-login-by-auth0)\n*   [Configure Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0)\n*   [Troubleshoot Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/troubleshoot-login-by-auth0)\n*   [Extend Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/extend-login-by-auth0)",
  "title": "Integrate with WordPress",
  "description": "Describes the scenarios of how Auth0 integrates with WordPress",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/install-login-by-auth0",
  "markdown": "# Install Login by Auth0\n\nThis plugin can be added to your WordPress site using the **Plugins** screen in the wp-admin:\n\n1.  Log in to an existing WordPress site as an administrator.\n    \n2.  Go to **Plugins > Add New** in the admin menu on the left.\n    \n3.  Search for \"Login by Auth0\"\n    \n4.  For the Login by Auth0 plugin, click **Install Now**, then **Activate**.\n    \n\nTo learn more about this process, read [WordPress.com and WordPress.org on wordpress.com](https://wordpress.com/support/com-vs-org/)[](https://wordpress.org/support/article/managing-plugins/#installing-plugins).\n\nAs soon as the plugin is activated, you are redirected to the start of the Setup Wizard.\n\nIf you don't already have an Auth0 account, [s**ign up for free to create one**](https://auth0.com/signup) before proceeding.\n\n## Multisite setup\n\nThe Login by Auth0 plugin is compatible with WordPress multisite networks. The plugin can be network activated to automatically protect network sites (once configuration is complete) or activated only on a sub-set of the network.\n\nThere are a few ways that a network of sites can be set up in Auth0:\n\n1.  **All sites can share both an Application and a database connection**\n    \n    1.  Run the Setup Wizard steps to completion for the main site.\n        \n    2.  Configure all other sites manually using the **Domain**, **Client ID**, and **Client Secret** from the main site in the Basic tab of the Auth0 settings page.\n        \n    3.  Update the Application's **Allowed Callback URLs**, **Allowed Web Origins**, and **Allowed Logout URLs** to include each site (wildcards can be used if your network uses subdomains).\n        \n2.  **Each site can have its own Application and share a database connection**\n    \n    1.  Run the Setup Wizard steps to completion for the main site.\n        \n    2.  Next, [manually create an Application for each site](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0) and add each one to the previously-created database connection.\n        \n    3.  Add the **Domain**, **Client ID**, and **Client Secret** values to the Basic tab of the Auth0 settings page for each site.\n        \n3.  **Each site can have its own Application and its own database connection.** In this case, Run the Setup Wizard steps to completion for each site.\n    \n\nEach of the options above has trade-offs. Option 1 has the least number of different entities to manage in Auth0 but, if your network has hundreds of sites and you're not using subdomains, you might run into limitations with the number of callback URLs. Option 2 will require managing many different Applications but will allow you to configure each site's Application differently.\n\nAs always, if you have any questions about this configuration process, [create a post in our Community and tag it \"wordpress\"](https://community.auth0.com/tags/wordpress).\n\n## Setup Wizard\n\nThe Setup Wizard will attempt to create all the necessary components needed to use Auth0 on your WordPress site. If you have an existing Application or Database Connection you want to use, please see the Manual Setup steps below.\n\n### Option 1: Standard Setup\n\nThis will create and configure an Application and a Database Connection for this site.\n\nFirst, [generate a Management API token](https://auth0.com/docs/api/management/v2/get-access-tokens-for-test#get-access-tokens-manually). Once the token is generated, make a note of the domain name used in the **Identifier** field under the **Settings** tab. For example, if your Identifier is `https://tenant-name.auth0.com/api/v2/`, then the tenant domain is `tenant-name.auth0.com`. To learn more about tenant domains, read [Create Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants).\n\nBack in the WordPress admin's Setup Wizard, click **Standard**. In the modal that appears, click **Start Standard Setup**.\n\nEnter the tenant domain and API token from above. This token is only used for the setup process and will not be saved in the database.\n\nIf the first part of the setup successfully completes, you'll see the \"Configure your social connections\" screen. Click **Next** to continue the setup process by migrating your administrator account.\n\nThis step connects your WordPress user with an Auth0 user that authorizes you to log in. You can choose the same password as your admin account or a different one, but make sure it conforms to the password strength policies[](https://auth0.com/docs/connections/database/password-strength#password-policies) for the database Connection being used. To learn more, read [Password Strength in Auth0 Database Connections: Password Policies](https://auth0.com/docs/connections/database/password-strength#password-policies).\n\nThe Setup Wizard must run to completion for your site to be configured correctly. If the Wizard fails for any reason before the \"setup successful\" screen, check the plugin error log at **wp-admin > Auth0 > Error Log** and the steps below to determine the issue.\n\nTo start the process over completely, delete any Applications or Database Connections that were created in the Auth0 Dashboard. In WordPress, go to **Auth0 > Settings > Basic**, delete the Domain, Client ID, and Client Secret fields, and click **Save**. Now, click **Setup Wizard** in the admin menu to start the process over again.\n\nIf you're still not able to install, [post a thread in our Community](https://community.auth0.com/tags/wordpress) with the error messages you're seeing in the Error Log, and we'll be happy to help!\n\n### Option 2: User Migration Setup\n\nThis will create and configure an Application and a database connection plus data migration from your WordPress database. This requires an inbound connection from Auth0 servers and cannot be changed later without losing data. To learn more, read [User Migration in Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/user-migration-in-login-by-auth0).\n\n::: warning If you have more than one custom database connection in Auth0, you'll need to make sure that the user IDs are namespaced to avoid conflicts. This is done automatically for sites installing version 3.11.0 or later. If your connections are/were being created with an earlier version, read the troubleshooting steps in [User Migration in Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/user-migration-in-login-by-auth0). :::\n\nOnce the configuration process is complete, log out of your WordPress site and attempt to log back in using your existing WordPress credentials in the Auth0 login form. This should create an Auth0 user linked to your WordPress account.\n\n### Option 3: Manual Setup\n\nThis will skip the automatic setup and allow you to create and configure your own Application and database connection (see below). This should be used if you want this site to use an existing Application or database connection.\n\n### Option 4: Import Setup\n\nThe site can also be set up by importing settings from another site. This is useful if you're migrating between environments or have a similar WordPress site that is already configured.\n\n## Setup complete\n\nWhen you see the \"Done\" screen, Auth0 is enabled and ready to accept logins and, if configured, signups.\n\nThis is a good time to confirm that the basics are working for your site before changing any of the default settings:\n\n1.  Log out of WordPress and confirm that the Auth0 form now appears at `/wp-login.php`.\n    \n2.  Log in with the Auth0 user created above.\n    \n3.  Log out and try creating an account with a different email address (if you have \"Anyone can register\" turned on in your General WordPress settings).\n    \n4.  Try logging in using a social connection (if you've turned those on).\n    \n\nNow you're ready to [configure the application](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0).\n\n## Manual setup\n\nThe plugin can be configured using the built-in Setup Wizard (covered below) or manually by creating an Application and assigning connections. The completely manual setup process can be used if you're having trouble with the wizard, have been through the setup process before, or want to share a database connection between Applications.\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#), and select **Create**.\n    \n2.  Give your application a descriptive name, select **Regular Web Applications**, then select **Create**.\n    \n3.  Configure the application for your WordPress installation. To learn how to configure the application, read [Configure Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0) and follow all sections through \"Update Auth0 settings in WordPress\".\n    \n\nOnce the steps above are complete, your site will be configured and ready to use.\n\n## Learn more\n\n*   [Integrate with WordPress](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/integrate-with-wordpress)\n*   [Configure Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0)\n*   [Troubleshoot Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/troubleshoot-login-by-auth0)\n*   [Extend Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/extend-login-by-auth0)",
  "title": "Install Login by Auth0",
  "description": "Explains how to install the Auth0 WordPress plugin",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0",
  "markdown": "# Configure Login by Auth0\n\nLogin by Auth0 can be configured using the Setup Wizard in the plugin or manually for more control over the process. To learn more, read [Install Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/install-login-by-auth0). The instructions below can also be used if the Setup Wizard did not complete or as part of troubleshooting login issues.\n\n## Auth0 configuration\n\nYour Auth0 tenant must be configured to accept login requests from your WordPress site and source user identities from at least one Connection, whether that's an Auth0 database, a social connection, or a business directory. To learn more about tenants, read [Create Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants). To learn more about connections, read [Identity Providers](https://auth0.com/docs/authenticate/identity-providers).\n\n### Application setup\n\n1.  Create an Application for your WordPress site:\n    \n\n*   **If you're troubleshooting the Setup Wizard**, navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and look for an Application that is similar to your WordPress site name. If you don't find one, it means that an Application was not created by the Wizard. Restart the Setup Wizard in WordPress or follow the step just below to create an Application manually.\n    \n*   **If you're configuring manually**, navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **Create**. Enter a name for the Application, select **Regular Web Applications**, and select **Create**.\n    \n\n1.  Select the **Settings** view for the Application. You will see your Domain, Client ID, and Client Secret, which are used in **wp-admin > Auth0 > Settings** to connect to Auth0.\n    \n2.  **Application Type** must be set to **Regular Web Application** and **Token Endpoint Authentication Method** must be set to **Post**\n    \n3.  Scroll down to **Allowed Callback URLs** and provide the WordPress site URL with `?auth0=1` appended:\n    \n\n1.  Enter your WordPress site's **WordPress Address (URL)** (where the WordPress site appears publicly) and, if different, the **Site Address (URL)** (where wp-admin is served from) in the **Allowed Web Origins** field. Both of these values are found on your WordPress site's general settings screen.\n    \n2.  Enter your WordPress site's login URL in the **Allowed Logout URLs** field\n    \n3.  Leave the **Allowed Origins (CORS)** field blank (it will use the **Allowed Callback URLs** values from above)\n    \n\n1.  Scroll down and select **Show Advanced Settings**, then select the **OAuth** view and make sure **JsonWebToken Signature Algorithm** is set to RS256. If this needs to be changed later, it should be changed here as well as in wp-admin (see Settings > Basic below).\n    \n2.  Turn on **OIDC Conformant**.\n    \n3.  Click the **Grant Types** tab and select at least **Authorization Code** and **Client Credentials**.\n    \n4.  Click **Save Changes**.\n    \n\nIn order for your WordPress site to perform certain actions on behalf of your Auth0 tenant, you'll need to authorize the Application created above to access the Management API. This is not required but will enable retrieving complete user data on login (including `user_metadata` and `app_metadata`), email and password changes for users, and email verification re-sending when verified emails are required.\n\n1.  Make sure your Application allows the Client Credentials grant (step 10 in the section above).\n    \n2.  Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis).\n    \n3.  Select **Auth0 Management API**, then the **Machine to Machine Applications** view.\n    \n4.  Look for the WordPress Application and select **Unauthorized** to grant access.\n    \n5.  In the panel that appears, select only the `read:users` and `update:users` scopes, then select **Update** (you can search using the **Filter scopes** field).\n    \n\n### Database Connection setup\n\nDatabase Connections enable username and password login with user records stored at Auth0. This type of Connection is not required and can be skipped if you're using passwordless, social, or enterprise logins only.\n\n1.  If you used the wizard during setup, navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database) and look for a Connection that has a similar name to the Application setup above. Otherwise, you can create a new Connection, use an existing Connection, or use the default **Username-Password-Authentication**. Select an existing Connection name to view settings or select **Create DB Connection** and follow the steps.\n    \n2.  Select the **Applications** view and activate the Application created above.\n    \n\nTo learn how to activate and configure this login method, read [Social Identity Providers](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers).\n\n### Enterprise Connection setup\n\nTo learn how to activate and configure this login method, read [Enterprise Identity Providers](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers).\n\n## WordPress configuration\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the Application created above.\n    \n2.  In a new tab/window, log in to wp-admin for your WordPress site and go to **wp-admin > Auth0 > Settings**.\n    \n3.  Copy **Domain**, **Client ID**, and **Client Secret** from your Auth0 Application page to your WordPress settings using the **Copy to Clipboard** buttons next to each field.\n    \n4.  Scroll down and select **Save Changes**.\n    \n\n## PHP constant setting storage\n\nPlugin settings can be saved to the database (default) or they can be set using a specifically named PHP constant. This will allow for sensitive data like the client secret, API token, and migration token to be stored more securely (assuming that file they are defined in is stored securely; to learn more, read [Hardening WordPress on wordpress.org](https://wordpress.org/support/article/hardening-wordpress/)).\n\nThe constant **must** be defined before the plugin is loaded or it will not be used. This should happen in your `wp-config.php` file or in a must-use plugin. To learn more, read [Must Use Plugins on wordpress.org](https://wordpress.org/support/article/must-use-plugins/). If the constant is defined in your theme's `functions.php` or in a plugin that loads after Auth0, the value will be ignored.\n\nThe PHP constants are defined like so:\n\nThe default constant name should be `AUTH0_ENV_` followed by the option name to override in all caps (the prefix can be modified with the `auth0_settings_constant_prefix` filter; to learn more, read [Extend Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/extend-login-by-auth0)). All plugin options can be overridden and their keys can be found in the `WP_Auth0_Options::defaults()` method. To see which options are available, [view WordPress Auth0 Lock Options in our GitHub repository](https://github.com/auth0/wp-auth0/blob/master/lib/WP_Auth0_Lock.php).\n\n**Note:** The `migration_token` value is generated by the plugin when user migration is turned on. If there is already a value in the admin, make sure to set the constant to the same value. If that value needs to change, it also must be changed in the custom scripts for the database Connection being used in the Auth0 dashboard.\n\nThe settings field will change its display based on this new value and show the constant being used for reference. This value will be used everywhere in the plugin automatically.\n\n**Important:** Saving the settings page after setting a constant value will validate the constant-set values (but not change them) and delete them from the options array being saved to the database. If you are just testing this functionality, do not save settings in the WordPress admin page until you're ready to delete that value.\n\nAll sites in a WordPress multi-site network will use the same constant value making this an easy way to setup a network using a single Application and database Connection.\n\n## Plugin settings\n\n### Basic\n\n*   **Domain:** The Domain copied from the Application settings in your dashboard. Option name is `domain`.\n    \n*   **Custom Domain:** The Custom Domain for your tenant, if one is configured. To learn more, read [Custom Domains](https://auth0.com/docs/customize/custom-domains). Option name is `custom_domain`.\n    \n*   **Client ID:** The Client ID copied from the Application settings in your dashboard. Option name is `client_id`.\n    \n*   **Client Secret:** The Client Secret copied from the Application settings in your dashboard. Option name is `client_secret`.\n    \n*   **JWT Signature Algorithm** The algorithm used for signing tokens from the Advanced Application Settings, OAuth tab; default is RS256. Option name is `client_signing_algorithm`.\n    \n*   **JWKS Cache Time (in minutes):** How long the JWKS information should be stored when using the RS256 JWT Signature Algorithm. Option name is `cache_expiration`.\n    \n*   **Original Login Form on wp-login.php:** Provides ways to access or block the core WordPress login page. Option name is `wordpress_login_enabled`. Login page code option name is `wle_code`.\n    \n    *   **Never** will not allow the core WordPress login form to display.\n        \n    *   **Via a link under the Auth0 form** will display a link to the WordPress core login form directly below the Auth0 embedded one on `wp-login.php`. The login page can also be accessed directly by adding `?wle` to the login URL.\n        \n    *   **When \"wle\" query parameter is present** will allow the login page to be accessed directly by adding `?wle` to the login URL. This will bypass the Universal Login Page redirect.\n        \n    *   **When \"wle\" query parameter contains specific code** will allow the login page to be accessed directly by adding `?wle=` plus a code to the login URL. The code is generated automatically and will be shown below the controls for this setting. This will bypass the Universal Login Page redirect.\n        \n*   **Allow Signups:** User signup will be available only if the WordPress Anyone can register option is enabled. You can find this setting under **Settings > General > Membership**.\n    \n\n### Features\n\n*   **Universal Login Page:** Redirects the `wp-login.php` page to the Universal Login Page for Single Sign-on (SSO) authentication using all active Connections for this Application. Option name is `auto_login`.\n    \n*   **Auto Login Method:** A single, active connection to use for authentication when **Universal Login Page** is turned on. Leave this blank to show all active Connections on the Universal Login Page. Option name is `auto_login_method`.\n    \n*   **Auth0 Logout:** Enable this option to log out of Auth0 when logging out of WordPress. Option name is `singlelogout`.\n    \n*   **Override WordPress Avatars:** Forces WordPress to use Auth0 avatars. Option name is `override_wp_avatars`.\n    \n\n### Embedded\n\nOptions here do not affect the Universal Login Page (To learn about customization options, read [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login)).\n\n*   **Passwordless Login:** Enable this option to turn on Passwordless login on all embedded Auth0 login forms. Passwordless connections are managed in the Auth0 dashboard and at least one must be active and enabled on this Application for this to work. Option name is `passwordless_enabled`.\n    \n*   **Icon URL:** Sets the icon above the embedded Auth0 login form. Option name is `icon_url`.\n    \n*   **Form Title:** Sets the title of the embedded Auth0 login form. Option name is `form_title`.\n    \n*   **Enable Gravatar Integration:** When user enters their email, their associated Gravatar picture is displayed in the embedded Auth0 login form. Option name is `gravatar`.\n    \n*   **Login Name Style:** Selecting **Email** will require users to enter their email address to login. Set this to **Username** if you do not want to force a username to be a valid email address. Option name is `username_style`. Option name is `client_secret_b64_encoded`.\n    \n*   **Primary Color:** To learn more about this setting, read [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration). Option name is `primary_color`.\n    \n*   **Extra Settings:** A valid JSON object that includes options to call Lock with. This overrides all other options set above. For a list of available options, see the Lock: User configurable options (e.g.: `{\"disableResetAction\": true }`). Option name is `extra_conf`.\n    \n*   **Use Custom Lock JS URL:** When turned off, WordPress will use the latest tested version of Lock (Auth0 embedded login form) automatically. When turned on, administrators can provide a custom Lock URL to use. Option name is `custom_cdn_url`.\n    \n*   **Custom Lock JS URL:** A valid URL pointing to a version of Lock. This field will be automatically hidden when **Use Custom Lock JS URL** is turned off. Option name is `cdn_url`.\n    \n*   **Connections to Show:** List here each of the identity providers you want to allow users to login with. If left blank, all enabled providers will be allowed. (To learn more, read [Lock UI Customization](https://auth0.com/docs/libraries/lock/lock-ui-customization).) Option name is `lock_connections`.\n    \n\n### Advanced\n\n*   **Require Verified Email:** If set, requires the user to have a verified email to log in. This can prevent some Connections from working properly if they do not provide an email address or an `email_verified` flag in the user profile data. Option name is `requires_verified_email`.\n    \n*   **Skip Strategies:** If Require Verified Email is turned on, this setting will display. This field accepts strategy names to skip the verified email requirement on login and account association. This should **only** be used for strategies that do not provide an `email_verified` flag.\n    \n*   **Remember User Session:** By default, user sessions live for two days. Enable this setting to keep user sessions live for 14 days. Option name is `remember_users_session`.\n    \n    *   This setting must be less than or equal to your tenant's [Inactivity Timeout](https://auth0.com/docs/manage-users/sessions/session-lifetime-limits)docs/manage-users/sessions/session-lifetime-limits setting to ensure that the user's session is properly maintained.\n        \n*   **Login Redirection URL:** If set, redirects users to the specified URL after login. This does not affect logging in via the `[auth0]` shortcode. Option name is `default_login_redirection`. To change the redirect for the shortcode, add a `redirect_to` attribute, like so:\n    \n    `[auth0 redirect_to=\"http://yourdomain.com/redirect-here\"]`\n    \n*   **Force HTTPS Callback:** Enable this option if your site allows HTTPS but does enforce it. This will force Auth0 callbacks to HTTPS in the case where your home URL is not set to HTTPS. Option name is `force_https_callback`.\n    \n*   **Auto Provisioning:** Should new users from Auth0 be stored in the WordPress database if new registrations are not allowed? This will create WordPress users that do no exist when they log in via Auth0 (for example, if a user is created in the Auth0 dashboard). Option name is `auto_provisioning`.\n    \n*   **User Migration:** Enabling this option will expose the Auth0 migration web services. However, the Connection will need to be manually configured in the [Auth0 Dashboard](https://manage.auth0.com/#). To learn more about the migration process, read [User Migration in Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/user-migration-in-login-by-auth0). The **Generate New Migration Token** button can be used to replace the saved token with a new one. Make sure to have your database Connection configuration page open to the **Custom Database** tab so you can replace the existing token with the new one in both scripts. Option name is `migration_ws`. Migration token option name is `migration_token`.\n    \n*   **Migration IPs AllowList:** Only requests from listed IPs will be allowed access to the migration webservice. Option name is `migration_ips_filter`.\n    \n*   **Valid Proxy IP:** List the IP address of your proxy or load balancer to enable IP checks for logins and migration web services. Option name is `valid_proxy_ip`.\n    \n*   **Auth0 Server Domain:** The Auth0 domain, it is used by the setup wizard to fetch your account information. Option name is `auth0_server_domain`.\n    \n\n## Learn more\n\n*   [Integrate with WordPress](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/integrate-with-wordpress)\n*   [Install Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/install-login-by-auth0)\n*   [Troubleshoot Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/troubleshoot-login-by-auth0)\n*   [Extend Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/extend-login-by-auth0)",
  "title": "Configure Login by Auth0",
  "description": "How to configure WordPress as an application with Auth0",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketplace-partners/introduction-to-integrating-with-auth0",
  "markdown": "# Introduction to Integrating with Auth0\n\nAuth0 provides an authentication and authorization service built on open standards like OIDC, OAuth2, SAML, and others. But, more than that, we provide tools so our customers can outsource user centralization and management, components of application security, and connecting networks of applications to a single source of identity.\n\nAn important part of this is enabling partners, such as yourself, to create an ecosystem of integrations that can be used to enhance and extend what we already provide. We do this by providing extensibility points and methods to allow customization. This means more functionality for customers with less maintenance burden for them.\n\nAlmost 90% of our customers extend the Auth0 platform for their unique requirements. By working with you to solve for common identity problems and use cases, we can expedite the time it takes our customers to implement their identity workflows.\n\n## What can be extended?\n\nThis video below is a quick walk-through of Auth0 under the hood, identifying the places where you are able to add an integration.\n\nThe list below is a list of the different ways that Auth0 can be customized. Some extensibility points allow integrations to be installed directly while others would need a guide that a customer can follow. Also note that some of the extensibility points require a paid Auth0 account.\n\n*   **Single-Sign On to an external service**\n    \n    *   [SAML](https://auth0.com/docs/customize/integrations/marketplace-partners/sso-integrations-for-partners)\n        \n    *   OpenID Connect\n        \n    *   WS-Fed\n        \n*   [**Customize user-facing Auth0 UI**](https://auth0.com/docs/customize)\n    \n    *   Load custom JavaScript and CSS on the login form\n        \n    *   Custom email templates\n        \n*   **Sources of identity**\n    \n    *   [OpenID Connect](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc)\n        \n    *   [OAuth2](https://auth0.com/docs/customize/integrations/marketplace-partners/social-connections-for-partners)\n        \n    *   [SAML](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/saml)\n        \n    *   [Active Directory/LDAP](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap)\n        \n    *   [Custom code pointing to a remote identity source](https://auth0.com/docs/authenticate/database-connections/custom-db)\n        \n*   **Custom code** [**before**](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow) **and** [**after**](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow) **Auth0 database registration**\n    \n    *   Database Connections\n        \n    *   Passwordless Connections\n        \n*   [**Custom code after successful authentication**](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow)\n    \n    *   Call an external API to enrich the user profile, block logins, etc.\n        \n    *   [Redirect to an external service](https://auth0.com/docs/customize/integrations/marketplace-partners/redirect-actions-for-partners)\n        \n    \n    *   Enrich the user profile stored in Auth0\n        \n    *   Provide a second factor for authentication\n        \n    *   [Step-up authentication](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication)\n        \n    *   Trigger Auth0 MFA\n        \n*   **Custom code** [**before**](https://auth0.com/docs/actions/triggers/pre-user-registration) **and** [**after**](https://auth0.com/docs/actions/triggers/post-user-registration) **Auth0 database registration**\n    \n    *   Database Connections\n        \n    *   Passwordless Connections\n        \n*   [**Send MFA codes using a custom SMS provider**](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow)\n    \n*   **Integration with customer applications**\n    \n    *   Integrate via your own SDK\n        \n*   **Application calling a resource/API**\n    \n    *   [Modify access tokens at login](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow)\n        \n    *   [Modify access tokens for machine-to-machine applications](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow)\n        \n*   [**Log streams**](https://auth0.com/docs/customize/log-streams/custom-log-streams)\n    \n*   [**Email providers via SMTP**](https://auth0.com/docs/customize/email/smtp-email-providers)\n    \n*   **Tenant and user management**\n    \n    *   [Via API using a machine-to-machine application](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)\n        \n        *   [User management](https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-management-api)\n            \n        *   [Application management](https://auth0.com/docs/api/management/v2#!/Clients/get_clients)\n            \n        *   [Connection management](https://auth0.com/docs/api/management/v2#!/Connections/get_connections)\n            \n    *   [Via CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool)\n        \n\n## Learn more\n\n*   [Marketplace Partners](https://auth0.com/docs/customize/integrations/marketplace-partners)\n*   [Redirect Actions for Partners](https://auth0.com/docs/customize/integrations/marketplace-partners/redirect-actions-for-partners)\n*   [Social Connections for Partners](https://auth0.com/docs/customize/integrations/marketplace-partners/social-connections-for-partners)\n*   [SSO Integrations for Partners](https://auth0.com/docs/customize/integrations/marketplace-partners/sso-integrations-for-partners)",
  "title": "Introduction to Integrating with Auth0",
  "description": "Describes available integrations for Auth0's partners",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/troubleshoot-login-by-auth0",
  "markdown": "# Troubleshoot Login by Auth0 WordPress Plugin\n\nHere are some common troubleshooting questions. If the items below do not solve your issue, then consider the following alternatives:\n\n*   If you're setting up the plugin for the first time or having problems with users logging in, please read [Configure Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0).\n    \n*   If you found a bug in the plugin code, [submit an issue](https://github.com/auth0/wp-auth0/issues) or [create a pull request](https://github.com/auth0/wp-auth0/pulls) in GitHub.\n    \n*   If you have questions about how to use Auth0 or the plugin, please [post on our community site](https://community.auth0.com/) or [create a request in the plugin's WordPress support forum](https://wordpress.org/support/plugin/auth0).\n    \n*   To see additional documentation and find more answers, [visit our support site](https://support.auth0.com/). Customers on a paid Auth0 plan can [submit a trouble ticket](https://support.auth0.com/tickets) for a fast response.\n    \n\n## I'm seeing the error message \"Invalid state\" that prevents me from logging in\n\nState validation is a security feature added in [version 3.6.0](https://github.com/auth0/wp-auth0/releases/tag/3.6.0). A cached callback URL usually causes this error message (see your Application settings for the callback URLs that should not be cached). To learn more, read [Troubleshoot WordPress Plugin Invalid State Errors](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/troubleshoot-wordpress-plugin-invalid-state-errors).\n\n## I'm having an issue logging in or changing email/password using a custom database\n\nTo learn about possible solutions, read [User Migration in Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/user-migration-in-login-by-auth0).\n\n## I'm seeing the error message \"Invalid ID token\" or \"Expired ID token\" that prevents me from logging in\n\nThis is typically caused by a server set to an incorrect time. If the error message includes \"used too early,\" then your server time is set in the future. If it says that the token is expired, then the server time is set too far in the past. A difference in time between two servers is common. Output `echo date(DateTime::ISO8601)` in PHP on your server and compare that, including seconds, to the current UTC time. If your server's time is more than 60 seconds (the default leeway) off from UTC time, then you’ll need to set a longer leeway to account for your server’s clock skew. You can paste the below code in your theme's `functions.php` or anywhere else that would run it after the plugin loads and before the login hook runs:\n\nThis would provide a 120 second leeway. You may need to adjust this depending upon how skewed your server's time is.\n\n## I see the error message \"This account does not have an email associated...\" that prevents me from logging in\n\nIf you get this error, make sure you are requesting an email from each provider in the Auth0 Dashboard under **Connections > Social** (expand each provider). Take into account that not all providers return email addresses for users (e.g., X). If this happens, you can always add an Email address to any logged in user through the Auth0 Dashboard (or API). See **Users > Edit**.\n\nFor Connections that don't provide an `email_verified` flag (some Enterprise connections will not include this) or to skip this validation for specific Social Connections, add the strategy for that Connection in the \"Skip Strategies\" field. This field is located below the **Require Verified Email** switch accessible via **wp-admin** > **Auth0** > **Settings** > **Advanced**.\n\n**This field should only be used if necessary because it circumvents the security precautions recommended by Auth0.**\n\n## I see the error message \"There is a user with the same email\" that prevents me from logging in\n\nThis means that there is a user in WordPress that has the same email as the one being used to login associated with a different Auth0 user. If you're in the process of testing the plugin or want to associate the existing user with the new Auth user instead:\n\n1.  Log in as an admin\n    \n2.  Go to **wp-admin > Users** and search for the email being used\n    \n3.  View the user's profile and scroll down to the bottom\n    \n4.  Click **Delete Auth0 Data** and confirm\n    \n\nIf you have 2 user accounts in Auth0 with the same email address, this error message will persist. We recommend that you [link user accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts).\n\n## I see the error message \"Failed cross origin authentication\" or \"No verifier returned from client\" in my browser's console logs when trying to log in\n\nGo to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), select your WordPress application to view its settings, and check that the **Allowed Callback URLs** and **Allowed Origins (CORS)** match your WordPress site.\n\nIf you're using a Chromium-based browser, make sure you don't have third-party cookies turned off. To learn more, read [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication).\n\nThis means that the plugin is already configured with a Domain, Client ID, and Client Secret. Running the Setup Wizard a second time can have unpredictable results. If you're setting up WordPress for the first time and want to start over before any logins have occurred:\n\n1.  Go to **wp-admin** > **Auth0** > **Settings** > **Basic**.\n    \n2.  Delete the Domain and Client ID. Scroll down and click **Save Changes**.\n    \n3.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n4.  Find the Application that was created by WordPress (its name should be the site name of your WordPress site).\n    \n5.  Select the Application to view its settings. Scroll down, and select **Delete Application**.\n    \n6.  Go to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database).\n    \n7.  Find the Connection that was created by WordPress (its name should be the site name of your WordPress site prepended with \"DB-\").\n    \n8.  Select the Connection to view its settings. Scroll down, and select **I Want To Delete This Connection.** Please note that this will delete the Connection and all users that were created within it.\n    \n9.  Return to WordPress. You will now see the Setup Wizard option under Auth0 in the admin menu.\n    \n\n## How do I setup Passwordless login?\n\nPasswordless login is possible any Auth0-enabled website using email or SMS. To make this work on your WordPress site:\n\n1.  Turn on **Passwordless Login** from the plugin settings' **Features** view and save.\n    \n2.  Go to [Auth0 Dashboard > Authentication > Passwordless](https://manage.auth0.com/#/connections/passwordless).\n    \n\n*   To use email, turn on the **Email** connection and modify the settings if desired. This will turn on email code login (users are emailed a code which is then typed into the login form on your site).\n    \n*   To use a \"magic link\" (emailed link will automatically log users in), add `{passwordlessMethod: 'code'}` to the \"Extra Settings\" field in the plugin settings' **Advanced** tab.\n    \n*   To use SMS login, turn on the **SMS** connection and follow the steps to set up a Twilio developer account (this will require a paid Twilio account depending on usage).\n    \n\nThe Auth0 login form will select a Passwordless method depending on which connection is activated above. If you have both connections active, it will default to email. In this case, either turn off the email connection to show SMS or add `sms` to the **Connections** field in the plugin settings' **Advanced** tab.\n\n## I have two accounts for the same user in WordPress\n\nUnder some situations, you may end up with a user with two accounts. WordPress allows you to merge users by deleting one of the accounts and attributing that account's content to another user. Go to wp-admin > Users, select the account you want to remove, and in the confirmation dialog select another user to transfer the content.\n\n## My configuration is wrong, and I can't authenticate using Auth0. Is there another way to access the plugin?\n\nThe plugin can be accessed using valid WordPress credentials through the regular WordPress login by adding `?wle` to the login URL. For example: `http://yourdomain.com/wp-login.php?wle`.\n\n## I am having problems when a user logs in. Where can I find a log of what is happening?\n\nThe plugin provides an error log where you can check what has happened. Access it through the **Error Log** sub-item of the **Auth0** plugin menu. You can find additional information at [Auth0 Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs).\n\n## How can I show the widget or shortcode in signup mode by default?\n\nYou can use the widget `Extra configuration` setting (or the `extra_conf` attribute in the shortcode) and add this JSON `{\"mode\":\"signup\" }` that will force the plugin to be shown in this mode.\n\n## When using a plugin to force the login, the user is not logged in\n\nThis is typically caused by a cached page after login. Check with your host for strategies to mitigate this or try adding a cache-busting parameter to the URL. To learn more, [use this gist on GitHub](https://gist.github.com/joshcanhelp/e3eb693749f0fe66aad097c3bbb3b415).\n\n### The user is not logged in when using the \"Force Login\" plugin\n\nThis is because the callback URL has not been added to the AllowList. Try adding this code to the `my_forcelogin_whitelist` filter:\n\n## How can I redirect the users to a specific URL after login?\n\nAll redirects are checked using `wp_safe_redirect()` before being performed. If you're trying to redirect to a domain that is not your main domain, add that domain to the check using the core WordPress `allowed_redirect_hosts` filter. To learn more, read [apply\\_filters( 'allowed\\_redirect\\_hosts', string\\[\\] $hosts, string $host ) on wordpress.org](https://developer.wordpress.org/reference/hooks/allowed_redirect_hosts/).\n\n### On the login page\n\nThis plugin leverages WordPress features to work seamlessly with default settings. To add a redirect, you can append the `redirect_to` query parameter to the URL when you direct the user to the login page. The plugin will redirect the user to this URL after a successful login.\n\nYou can also use the **Login redirection URL** setting in the Auth0 plugin settings page. This will URL be used to redirect the user when the `redirect_to` parameter is not provided.\n\n### Using the widget\n\nThe widget will automatically redirect to the same page where the user was before authentication. You can override this using the `Redirect after login:` setting.\n\n### Using the shortcode\n\nThe shortcode will automatically redirect to the same page where the user was before authentication. You can override this using the `redirect_to` attribute.\n\n## How can I migrate my WordPress users to Auth0?\n\nThe current version of the plugin does not provide a way to migrate users to Auth0 automatically, but you have a few options:\n\n*   The plugin exposes two endpoints to mark your custom database connection for **import to Auth0** mode. To learn more about the endpoints, read [Configure Automatic Migration from Your Database](https://auth0.com/docs/connections/database/migrating). You can [use these plugin scripts](https://github.com/auth0/wp-auth0/blob/master/lib/WP_Auth0_CustomDBLib.php) to set up your connection.\n    \n*   Export your user data to a JSON file and upload it for batch-import into Auth0. Initially, your users will have to reset their passwords when logging in using Auth0 because there is no way for Auth0 to decrypt the WordPress passwords during migration. To learn how to generate the JSON file, read [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports). Then you will need to upload the file using the Auth0 Management API's [Import Users endpoint](https://auth0.com/docs/api/v2#!/Jobs/post_users_imports).\n    \n*   [Use this script](https://gist.github.com/glena/b31716e3c8fe48927be2) and the WordPress XML RPC endpoint to set up the migration flow using a custom database connection. To learn more about setting up the migration flow, read [Configure Automatic Migration from Your Database](https://auth0.com/docs/connections/database/migrating). To learn more about the WordPress XML RPC endpoint, read [XML-RPC Support on wordpress.org](https://codex.wordpress.org/XML-RPC_Support).\n    \n\n## The form\\_title setting is ignored when I set up the dict setting\n\nInternally, the plugin uses the dict setting to change the Auth0 widget title. When you set up the dict field, it overrides the form\\_title one.\n\nTo change the form\\_title in this case, you need to add the following attribute to the dict JSON:\n\n## How can I modify the embedded Auth0 login form?\n\nThere are many options on the **Appearance** tab of the plugin settings page that can change the look and feel of the login form that is embedded on your site (`wp-login/php` page, shortcodes, or widgets). To learn more about these options, read [Configure Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0). This will not affect the the login form on the Auth0-hosted Universal Login Page.\n\nThere is also a field called \"Extra Settings\" on the **Advanced** tab that accepts a valid JSON object with all the settings you want to configure. This will override any changes made on the **Appearance** tab. To see all possible configuration options, read [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration).\n\nExternal style sheets and JS files should be loaded in your theme using the `wp_enqueue_scripts` hook for shortcodes/widgets and the `login_enqueue_scripts` hook for `wp-login.php`. To learn more, read [`do_action( 'wp_enqueue_scripts' )` on wordpress.org](https://developer.wordpress.org/reference/hooks/wp_enqueue_scripts/) and [`do_action( 'login_enqueue_scripts' )` on wordpress.org](https://developer.wordpress.org/reference/hooks/login_enqueue_scripts/).\n\n## The session expires too soon\n\nThe Auth0 plugin does not handle sessions; it uses the WordPress settings. By default, user sessions are kept alive for two days. You can enable the `Remember users session` setting on the plugin settings' **Advanced** tab to allow sessions to remain live for up to 14 hours.\n\n## How do I implement a Refresh Token?\n\nWe implemented additional parameters in the login methods used by the plugin to allow for Refresh Tokens. Use the `auth0_auth_scope` filter combined with the `auth0_user_login` action to accomplish this.\n\n## Profile data saved in WordPress is not being synced to the Auth0 user account.\n\nThis is a current limitation of the plugin but something we're looking at in a future release. The one exception to this is the user password. If the password is changed in WordPress and it passes the security policy set for the database connection being used, then that password will update for the Auth0 user as well. We'll be adding an error message in a future release to stop the process if the password is not strong enough.\n\nHistorically, Auth0 has maintained two WordPress plugins:\n\n*   [Login by Auth0](https://wordpress.org/plugins/auth0/)\n    \n*   [Social Login with Auth0](https://wordpress.org/plugins/social-login-with-auth0/)\n    \n\nThese two plugins are effectively the same, but **Social Login with Auth** will not receive any updates past version 3.7.0 (released 13 August 2018). Migrating from **Social Login with Auth** to **Login by Auth0** is simple and won't result in any Auth0 or WordPress data loss.\n\nMoving from **Social Login with Auth** to **Login by Auth0** will update the version number you see, so make sure to test this change out on a staging or development server first (just as you would if you were updating the plugin in wp-admin). Furthermore, logins may not work during the migration process, so be sure to use a maintenance mode plugin or complete the migration during off-peak hours.\n\nThe easiest way to migrate is via (S)FTP:\n\n1.  Log in to the WordPress site as an administrator.\n    \n2.  [Download Login by Auth0](https://downloads.wordpress.org/plugin/auth0.zip) and unzip it locally.\n    \n3.  Deactivate the **Social Login with Auth0** plugin from the WordPress admin > Plugins screen.\n    \n4.  Log in to the server you want to migrate to and navigate to `wp-content/plugins`.\n    \n5.  Move the `social-login-with-auth0` folder out of the plugins folder to back up the contents.\n    \n6.  Upload the new `auth0` plugin folder to the plugins directory.\n    \n7.  Activate the new \"Login by Auth0\" plugin from the WordPress **Admin** > **Plugins** screen.\n    \n\nIf you're unable to access the site via FTP, you can also run the process directly from the WordPress admin:\n\n1.  Log in to the WordPress site as an administrator.\n    \n2.  Go to **Auth0** > **Import-Export Settings**.\n    \n3.  Click **Export Settings**, then **Export**.\n    \n4.  Deactivate the **Social Login with Auth0** plugin from the WordPress **Admin** > **Plugins** screen.\n    \n5.  Delete the **Social Login with Auth0** plugin and confirm.\n    \n6.  Go to **Plugins** > **Add New** and search for \"Auth0\".\n    \n7.  For the **Login by Auth0** plugin (make sure to check the name), click **Install Now**.\n    \n8.  When this completes, click **Activate**.\n    \n9.  Check **Auth0** > **Settings** and make sure the previous settings remain. If not:\n    \n    1.  Go to **Auth0** > **Import-Export Settings**.\n        \n    2.  Paste in the settings JSON exported previously and click **Import**.\n        \n10.  Completely delete the settings file export JSON (it contains sensitive information).\n    \n\nEverything should now be working as expected with the new plugin and updates will resume as usual.\n\n## Learn more\n\n*   [Integrate with WordPress](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/integrate-with-wordpress)\n*   [Install Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/install-login-by-auth0)\n*   [Configure Login by Auth0](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0)\n*   [Extend Login by Auth0 WordPress Plugin](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/extend-login-by-auth0)",
  "title": "Troubleshoot Login by Auth0 WordPress Plugin",
  "description": "This page explains common troubleshooting issues with the Login by Auth0 WordPress plugin",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketplace-partners/actions-integrations-for-partners",
  "markdown": "# Actions Integrations for Partners\n\nPartners like you use Actions Integrations to build zero-code solutions that tie their products into Auth0 workflows. Actions Integrations let Auth0 customers implement solutions like identity verification or consent management without writing any code. You write the Actions Integration; customers drag and drop it into their workflow.\n\nActions Integrations are self-contained functions that execute at chosen points in the Auth0 platform. Written in JavaScript, they are closed source; customers can’t modify the code. \n\n## Create and publish an Actions Integration\n\nCreating an Actions Integration involves planning, building, and testing. Before you make it available to customers in the [Auth0 Marketplace](https://marketplace.auth0.com/), Auth0 reviews the Actions Integration. For information about the Auth0 Marketplace, read [Marketplace Partners](https://auth0.com/docs/customize/integrations/marketplace-partners).\n\n### 1\\. Determine your use case\n\nIdentify what use case your Actions Integration will address. What problem will it solve for customers? How will it solve the problem? For more information, read [Defining an Integration Use Case](https://auth0.com/docs/customize/integrations/marketplace-partners/defining-an-integration-use-case). \n\n### 2\\. Choose a flow\n\nAction Integrations consist of a single [Action](https://auth0.com/docs/customize/actions). What an Action can do is determined by where it is executed within the Auth0 runtime environment, its Action [flow](https://auth0.com/docs/customize/actions/flows-and-triggers). Available Action flows are:\n\n*   **Login flow** runs synchronously after a user successfully signs up or logs in. Login events include interactive flows (like username/password or federated login) and non-interactive flows (like session checks and refresh token exchanges). To learn more about this flow, read [Login Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow).\n    \n*   **Machine to Machine flow** runs synchronously when an application requests an access token using the client credentials grant. To learn more about this flow, read [Machine to Machine Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow).\n    \n*   **Pre User Registration flow** runs synchronously before Auth0 adds a user to a database or passwordless connection. This flow does not run for federated logins like enterprise or social connections. To learn more about this flow, read [Pre User Registration Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow).\n    \n*   **Post User Registration flow** runs asynchronously after Auth0 adds a user to a database or passwordless connection. This flow does not run for federated logins like enterprise or social connections. To learn more about this flow, read [Post User Registration Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow).\n    \n*   **Post Change Password flow** runs asynchronously after the customer changes a password for a database connection user. This flow does not run for password changes on other types of connections. To learn more about this flow, read [Post Change Password Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow).\n    \n*   **Send Phone Message** **flow** delivers a phone or SMS message as part of a custom MFA provider. To learn about custom MFA providers, read [Customize Multi-factor Authentication SMS and Voice Messages](https://auth0.com/docs/customize/customize-sms-or-voice-messages). To learn more about this flow, read [Send Phone Message Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).\n    \n\nTo learn more about Action flows, read [Explore Flows and Triggers](https://auth0.com/docs/customize/actions/flows-and-triggers). If you need to redirect users to an endpoint during login, read [Redirect Actions for Partners](https://auth0.com/docs/customize/integrations/marketplace-partners/redirect-actions-for-partners).\n\n## 3\\. Build an Actions Integration\n\nOnce you’ve decided which flow fits your Action Integration's use case, build your Action in a testing tenant. For instructions, read [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action). This Action will be the basis for your Action Integration code.\n\nTo learn how to make your Actions Integration secure and stable, read [Actions Coding Guidelines](https://auth0.com/docs/customize/actions/action-coding-guidelines). Also follow these guidelines specific to Actions Integrations:\n\n*   When building your Action in a test tenant, use secrets for all values that a customer needs to provide (such as identifiers, tenant names, and thresholds). When you submit your Actions Integration, Auth0 asks which fields must be encrypted at rest (remain secrets) and which can be editable text fields.\n    \n*   Use a debug/test mode configuration flag for logging that helps with setup or troubleshooting. Actions Integrations should rarely output logs for all executions.\n    \n*   Write secret names in `ALL_CAPS_SNAKE_CASE` to ease review.\n    \n*   Action Integrations are closed source; customers can neither see nor modify the code. Any customer-specific input required to control the Action Integration must come from secrets or configuration.\n    \n\n### 4\\. Test your Actions Integration\n\nBecause Auth0 reviewers don't have access to your service, you must test your Action before submitting it for review. Manually test both successful executions and edge cases. Include these checks:\n\n*   Does the Action fail silently or block further execution?\n    \n*   How does the Action work if an HTTP request fails?\n    \n*   What, if any, error messages are exposed to users?\n    \n*   What information is logged?\n    \n*   Can the Action be bypassed or spoofed?\n    \n\nDuring the submission process, Auth0 asks for unit test coverage for the success path. Auth0 provides all the tooling and examples needed to make this as simple as possible.\n\n### 5\\. Submit your Actions Integration\n\nOnce you’ve written and thoroughly tested your Actions Integration, submit it to Auth0 for review: submit an [Auth0 Marketplace service request](https://autheco.atlassian.net/servicedesk/customer/portal/1/group/1/create/43). After an initial review of the request, Auth0 sends you a link to a GitHub repository with instructions on how to document, test, and submit your Actions Integration.\n\n### 6\\. Publish your Actions Integration\n\nOnce Auth0 reviews your Actions Integration, we send you a preview of your listing and confirm when to publish it in the Auth0 Marketplace. Once it’s live, we send you a URL to the published Actions Integration. When you promote your Actions Integration, you can share the link with customers and potential customers.",
  "title": "Actions Integrations for Partners",
  "description": "Instructions for Auth0 business partners to create zero-code solutions that tie third-party products into Auth0 workflows",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketplace-partners/redirect-actions-for-partners",
  "markdown": "# Redirect Actions for Partners\n\nWhen a user is logging in or signing up, a Redirect Action lets you redirect them to an external page (such as a consent form) and then then back to Auth0 to complete their login or signup. You can redirect users to access an external application that prompts them to:\n\n*   Take an action, like ID proofing\n    \n*   Provide information, like progressive profiling\n    \n*   Agree to something, like consent or terms of service\n    \n\n![Diagram of Redirect Action on Post Login trigger: The Customer Application redirects the user to Auth0 to log in.  If the login is successful, all Actions in the Post Login trigger execute (this happens before MFA, if it is active). If an Action triggers a redirect, the user is sent to the designated URL along with a state parameter. This URL must be hosted by your service or the customer. The user is redirected or POSTed back to Auth0 at a specific path on their domain, along with the original state value, and the Action runs any code that exists in onContinuePostLogin. The user is sent back to the application with their identity or, if something failed, an error message.](https://images.ctfassets.net/cdy7uua7fh8z/7fNydolHKmq8Ke9AuyDxTT/9f406931d88332856b67072965a55612/Action_Flow_-_Redirect.png)\n\nThis process occurs in a Redirect Action:\n\n1.  The **Customer Application** redirects the user to Auth0 to log in.\n    \n2.  If the login is successful, all Actions in the [Post Login trigger](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) execute (this happens before MFA, if it is active).\n    \n3.  If an Action triggers a redirect, the user is sent to the designated URL along with a state parameter. This URL must be hosted by your service or the customer.\n    \n4.  The user is redirected or POSTed back to Auth0 at a specific path on their domain, along with the original state value, and the Action runs any code that exists in `onContinuePostLogin`.\n    \n5.  The user is sent back to the application with their identity or, if something failed, an error message.\n    \n\nOnce you’re ready to tie your service into the process, there are important elements to consider:\n\n*   How do you determine when to redirect out of Auth0?\n    \n    *   Flag in the [user’s app\\_metadata](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)?\n        \n    *   Based on a particular metadata field on the Client?\n        \n*   How do you handle existing user profile data that should be verified? (This data could be user-provided or from a federated identity source, such as Google, Facebook, or Azure AD.)\n    \n*   What data do you need from Auth0 in your service and how do you get it there securely?\n    \n*   How do you persist the state value from Auth0 in your service?\n    \n*   How do you get and persist the `/continue` URL to which you want to POST/redirect?\n    \n*   What do you send back to Auth0 and how do you accomplish this securely?\n    \n*   How do you indicate that ID proofing is complete and pass status?\n    \n*   How do you store necessary information in the [user’s app\\_metadata](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules) or the [normalized user profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure)\n    \n*   Be mindful of [rate limits](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits) and update only when necessary\n    \n*   How do you send information back to the requesting application using [custom token claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims)?\n    \n\nTo help answer all of these questions and more, read [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions). When you're ready to submit your Action Integration, follow steps 4-6 in [Action Integrations for Partners.](https://auth0.com/docs/customize/integrations/marketplace-partners/actions-integrations-for-partners)",
  "title": "Redirect Actions for Partners",
  "description": "Learn about redirect Actions and how Auth0 Marketplace partners can use them to customize the login flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketplace-partners/sso-integrations-for-partners",
  "markdown": "# SSO Integrations for Partners\n\nSSO (single sign-on) integrations use an Auth0 identity to log in, via SAML, to an external service. This allows customers with internal applications to use SSO to access third-party vendors using the Auth0 identity.\n\nThe [SSO integrations available on Marketplace](https://marketplace.auth0.com/features/sso-integrations) define both the standard SAML configuration values needed to connect Auth0 to external vendors, and the fields necessary for additional customer-specific values. In these integrations, Auth0 acts as the identity provider in a service provider (SP)-initiated scenario. To learn how to configure Auth0 for these integrations, see [Configure Auth0 as a SAML Identity Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider).\n\nThe part that our partners will provide is the default SAML configuration to make this transaction work. This will consist of values or customer-requested fields for some or all of the attributes listed in [Customize SAML Assertions: SAML Assertion Attributes](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions).\n\nTo build and test an integration, [create a tenant](https://auth0.com/signup) in Auth0 and follow the documentation above to create a working SSO integration with your service.\n\n## Submit your SSO Integration\n\nOnce you have an integration working, Auth0 will work with you to publish the integration in the [Auth0 Marketplace](http://marketplace.auth0.com/). When you submit your integration you must provide this information:\n\n1.  The business and marketing content for your Auth0 Marketplace listing. This includes your company's description and logo and describes what the integration does.\n    \n2.  The code and configuration you used for the integration. Partners typically submit the code using GitHub.\n    \n3.  An installation guide in Markdown format with instructions on how to configure your service to work with Auth0. Please follow our [Writing Tips for Installation Guides](https://auth0.com/docs/customize/integrations/marketplace-partners/writing-tips-for-installation-guides) when you create this document.\n    \n\nIf you're ready to become a partner and submit your integration to list in the Auth0 Marketplace, please fill out the [Auth0 Marketplace support center](https://autheco.atlassian.net/servicedesk/customer/portal/1). If you ware a new partner, you will need to Apply to become a Marketplace partner, after that you can fill out the \"Submit a new Integration\" form with the information described above.\n\n**We will need the following configuration and documentation:**\n\n*   The JSON used to configure the working SAML add-on Application\n    \n*   A list of fields that should be shown to the customer configuring the integration (like **Callback URL**, **Audience**, and **Signing Certificate**)\n    \n*   An installation guide written in Markdown following the [SSO Integration installation guide template](https://gist.githubusercontent.com/joshcanhelp/c70b8512a85e38c3370cc5c55d3fbdcb/raw/f3d21c73ef55678e3746e379fa05d0354a721972/sso-template.md)",
  "title": "SSO Integrations for Partners",
  "description": "Learn how to build an SSO Integration as a member of our partner community.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketplace-partners/social-connections-for-partners",
  "markdown": "# Social Connections for Partners\n\nIn Auth0, Connections are a source of user identity for logging in ([video](https://auth0-1.wistia.com/medias/tet170a1vt)). Social Connection is the term we use for a consumer-level source of identity, like Google or Facebook ([video](https://auth0-1.wistia.com/medias/5kshjcduya)). Customers can provide their users with the option of using one or more social connections on the login form, or just use a single provider by including a URL parameter when redirecting to the login form.\n\n![Social Connections for Partners - Universal Login with Social Connections - Example login page](https://images.ctfassets.net/cdy7uua7fh8z/4mQxtOyW7bdSznrNA91eky/cf97d19b6136748cbbdc3076fadd77cc/connections-for-partners_sample-login-screen.png)\n\nOnce a user is logged in, their identity from the social provider is mapped to an Auth0 profile, and the result is sent to the application that requested login. This creates an Auth0 user record using the identity from the selected Social Connection. The attributes used for this record are mapped from the external identity source to an [Auth0 user profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles).\n\nYour Marketplace Social Connection will start as a [Custom Social Connection](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/oauth2) that can be built on any Auth0 tenant, so you can see how the transaction will work and make sure that users can log in with your authorization server. The following video will show you how to build and test a Connection in Auth0.\n\nOnce you have an integration working, Auth0 will work with you to publish the integration in the [Auth0 Marketplace](http://marketplace.auth0.com/). When you submit your integration you must provide this information:\n\n1.  The business and marketing content for your Auth0 Marketplace listing. This includes your company's description and logo and describes what the integration does.\n    \n2.  The code and configuration you used for the integration. Partners typically submit the code using GitHub.\n    \n3.  An installation guide in Markdown format with instructions on how to configure your service to work with Auth0. Please follow our [Writing Tips for Installation Guides](https://auth0.com/docs/customize/integrations/marketplace-partners/writing-tips-for-installation-guides) when you create this document.\n    \n\nIf you're ready to become a partner and submit your integration to list in the Auth0 Marketplace, please fill out the [Auth0 Marketplace support center](https://autheco.atlassian.net/servicedesk/customer/portal/1). If you ware a new partner, you will need to Apply to become a Marketplace partner, after that you can fill out the \"Submit a new Integration\" form with the information described above.\n\n**We will need the following configuration and documentation:**\n\n*   The Authorization and Token URLs that should be used; if your authorization server uses a tenant architecture, include the pattern to use, and we will include a **Tenant Domain** field or similar.\n    \n*   A list of fields that the customer configuring the integration should see, including **Client ID** and **Client Secret**\n    \n*   A list of scopes that can be requested, including whether to require them and/or request them by default\n    \n*   A profile mapping script (following the [mapping script template](https://gist.github.com/joshcanhelp/26e1fc3581d2ced737c4f50a694ea10f)). This script must map a unique identifier to `user_id` and, if possible, `email`, `email_verified`, and `name`\n    \n*   An installation guide written in Markdown and following the [social connection installation guide template](https://gist.githubusercontent.com/joshcanhelp/b7d51a5b55aff499ea4f2b49aa0123c6/raw/4c087e286f4b8b6405f98d0730e0276611bb2411/social-connection-template.md)",
  "title": "Social Connections for Partners",
  "description": "Learn about social connections and how Auth0 Marketplace partners can use, build, and test them.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketplace-partners/defining-an-integration-use-case",
  "markdown": "# Defining an Integration Use Case\n\nOne of the most important parts of integrating with Auth0 is defining what the integration will do and how it will do it. Customers need to understand what problem your integration will solve and how it will go about solving it. This is probably an easy question to answer about your service on its own but, in the context of an identity platform like Auth0, it can be more nuanced.\n\nThis guide will help you understand the integration environment a little better and guide you to designing a great integration with Auth0.\n\n#### Review: What does Auth0 do?\n\nHere at Auth0 we ...\n\n*   Enable easy and secure access to any application.\n    \n*   Provide an authentication and authorization service built on open standards like OIDC, OAuth2, SAML, and others.\n    \n*   Build an identity platform that exposes the appropriate building blocks targeted to different operators in the ecosystem.\n    \n*   Handle our customers' outsourced application security, user centralization, and user management by connecting networks of applications to a single source of identity.\n    \n\n#### What does your service do?\n\nIt's helpful for us to understand what your service is capable of doing and what use cases your customers rely on you to handle. A few questions that can help with framing your answer:\n\n*   Are you a source of user identity?\n    \n*   Do you provide data or analytics?\n    \n*   Does your service expose a user interface of any kind?\n    \n*   Do you increase security? Observability?\n    \n\n#### Do you target specific industries or customer types?\n\nAuth0 customers span throughout industries like software/tech, financial services, media, to travel and hospitality. we can handle application networks of all types but our main focus is [Customer Identity and Access Management or CIAM](https://auth0.com/blog/what-is-ciam/). More specifically, we focus on B2C and B2B use cases where the goal is to help our customers generate revenue (B2B) and convert more customers (B2C) while making sure we protect our customers at all cost. We work with companies to create integrations that solve CIAM for any use case.\n\nCompanies that are a good fit with Auth0:\n\n*   Are striving to change the perception that identity is hard\n    \n*   Focus on growing their B2B customers\n    \n*   Aim to increase revenue for their B2C customers\n    \n*   Don't compromise on security\n    \n\nDoes your service do any of the following?\n\n*   Focus on government, medical, eCommerce, or other specific applications?\n    \n*   Typically get used at a certain scale or traffic level?\n    \n*   Get installed on premise?\n    \n\n#### What problem(s) does your service solve for your customers?\n\nIn a general sense, it's important to know why, exactly, our mutual customers would use your service. Focusing on the problems that your service solves can help us find common ground and understand why an integration would be valuable.\n\nSome examples are:\n\n*   Low conversation rates caused by interruptive security measures like MFA\n    \n*   Spam sign ups and content submission\n    \n*   Too much or unhelpful log data\n    \n\n#### How does your service solve those problems in the context of an identity platform?\n\nThis is where we start connecting what your service does to the platform we maintain. We handle many different forms of authentication and authorization, all of which flow through a central context. The question here is asking what parts of our service might cause or exacerbate the problem(s) listed above.\n\nA few ideas:\n\n*   Centralized login creates lots and lots of log data that is impossible to monitor manually\n    \n*   A central user store makes augmenting a user profile beneficial for all applications in the network\n    \n*   Identity verification is easier to provision in one place rather than individually for specific applications\n    \n\n#### Can you provide a visual representation of how this integration will work?\n\nSystem and/or sequence diagrams are helpful to explain how your integration is working to our partner technical team as well as our customers.\n\n#### Are there any limitations to this integration?\n\nOur identity platform enables logging in using a browser, mobile device, CLI, cloud functions, and more. We also gate some features by the type of plan that a customer is on.\n\nDoes your service have:\n\n*   Technology limitations of any kind, including OS, language, platform, or devices?\n    \n*   Rate limits or payment gateways?\n    \n*   Asynchronous processing requirements?\n    \n*   Auth0 plan level limitations? See [our pricing page](https://auth0.com/pricing) for information on specific features.\n    \n\n#### What's next?\n\nNow that you have a sense of how your service can work with Auth0, you are ready to learn more about [Integrating with Auth0](https://auth0.com/docs/customize/integrations/marketplace-partners/introduction-to-integrating-with-auth0).",
  "title": "Defining an Integration Use Case",
  "description": "Describes methodology to plan an Auth0 integration",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/integrations/aws-api-gateway/part-2",
  "markdown": "# AWS API Gateway Tutorial Step 2\n\n## Step 2 - Secure and Deploy the Amazon API Gateway\n\nNow that you have your API running, you need to add security. In this step, you will:\n\n*   Secure the update API to limit access to authenticated users with a specific AWS IAM role;\n    \n*   Configure Auth0 delegation to use AWS IAM federation capabilities;\n    \n*   Obtain an AWS Access Token that uses the AWS IAM role.\n    \n\nOnce your API is secure, you'll build a serverless, single-page application (SPA). The SPA will rely on federating identity to determine which users are allowed access. By combining AWS IAM Integration for AWS Gateway API, AWS IAM Identity Federation for SAML, and Auth0 Delegation for AWS, you can enable users from many different sources, including Social Providers or enterprise connections, to access your APIs. The following diagram illustrates a sample flow using a SAML-based Identity Provider and Auth0 SAML Federation and Delegation for AWS.\n\nYou will see two ways of implementing this flow:\n\n1.  Using Auth0 Delegation with AWS IAM;\n    \n2.  Adding an identity token to flow identity to the Lambda function.\n    \n\nDelegation makes it easy for you to obtain tokens from AWS to access AWS services in your application.\n\n### Ways to Secure the Amazon API Gateway\n\nAWS API Gateway provides several different methods to secure your APIs:\n\n1.  API keys;\n    \n2.  IAM;\n    \n3.  [Amazon Cognito](https://auth0.com/docs/integrations/aws-api-gateway/secure-api-with-cognito).\n    \n\nUsing API keys is typically appropriate for a service-to-service interaction, as illustrated below. However, there are several downsides to this approach:\n\n*   Placing a secret with a long lifetime on the application is risky (applications are easier to compromise);\n    \n*   Creating a framework to issue and manage API keys requires a secure implementation that can be challenging to develop.\n    \n\nThis section of the tutorial will utilize IAM roles and policies to secure your API in API Gateway, but you can also choose to do so using user pools in Amazon Cognito. To review detailed instructions on securing your AWS API, read [Secure AWS API Gateway Using Cognito](https://auth0.com/docs/integrations/aws-api-gateway/secure-api-with-cognito). For more information on using IAM roles and policies, read the Amazon article, [Control access to an API with IAM permissions](http://docs.aws.amazon.com/apigateway/latest/developerguide/permissions.html). To read more about user pools in Cognito, visit [Amazon Cognit user pool](http://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html).\n\n### 1\\. Configure IAM and Auth0 for SAML Integration with the API Gateway\n\nYou can specify an AWS IAM role for the SAML token you exchange for an AWS token. Depending on the permissions granted to that IAM role (which are set using your identity provider), the received token possesses those same permissions. By issuing different SAML tokens, each with its own AWS IAM role, you can control the levels of access for your users.\n\nFor example, the IDP could specify the IAM role based on group membership (for example, an administrator in Active Directory) or authentication source (for example, a database connection or a social provider like Facebook). This approach lets you differentiate user access to your Amazon API Gateway methods when secured using AWS IAM.\n\n#### Configure Auth0\n\nLog in to your Auth0 account. You will be brought to the Management Dashboard. Click on **\\+ New Application**, which is located in the top right corner of the page.\n\nName your new application AWS API Gateway, and indicate that this Application is going to be a Single-Page Application. Click **Create**.\n\nNavigate to the Addons tab for your newly-created Application. Using the appropriate slide, enable Amazon Web Services. This turns on AWS Delegation.\n\n#### Configure AWS\n\nFollow the [How to Set Up AWS for Delegated Authentication](https://auth0.com/docs/aws-api-setup) tutorial to configure AWS for delegated access, which uses SAML. Some caveats:\n\n*   Follow the [instructions below](#setting-the-permissions-policy-on-your-iws-iam-role) for attaching the permissions policy to your role instead of the one for the linked tutorial;\n    \n*   Name the SAML provider you create `auth0`;\n    \n*   Name the AWS IAM role `auth0-api-role`.\n    \n\n##### Set the Permissions Policy on Your IWS IAM Role\n\nOnce you have configured the AWS IAM role, you will add a policy to `auth0-api-role` that lets you execute your API Gateway methods. For more information on this process, please see [User Access Permissions for Amazon API Gateway](http://docs.aws.amazon.com/apigateway/latest/developerguide/permissions.html).\n\n#### Getting the Gateway API ARN\n\nBefore you begin, you will need the ARN for your Gateway API:\n\n1.  Navigate to [Amazon API Gateway Console](https://console.aws.amazon.com/apigateway) and log in.\n    \n2.  Select the appropriate API.\n    \n3.  Click on any of the Methods associated with the API to bring up the Method Execution page.\n    \n4.  On the Method Execution page, the Method Request box in the top left corner displays the **ARN** for the API, though it includes the Method name:\n    \n\n`arn:aws:execute-api:us-east-2:484857107747:97i1dwv0j4/*/POST/`\n\nYou'll strip the method name to get the base ARN for the API:\n\n`arn:aws:execute-api:us-east-2:484857107747:97i1dwv0j4/*`\n\nThe wildcard (`*`) in the ARN above enables permissions to your API for all stages, but you can deploy different stages individually (for example, development, then test, then production).\n\nSelect the `auth0-api-role` role you just created to open its Summary page.\n\nExpand **Inline Policies**, and click **click here**.\n\nSelect **Custom Policy** and click **Select**.\n\nEdit your policy document. You can set the **Policy Name** to whatever you would like, but we suggest something like `api-gateway-policy`. To enable access to the API methods for this role, apply the following policy after updating the ARN with the one for your API.\n\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"execute-api:*\"\n            ],\n            \"Resource\": [\n                \"arn:[{yourArn}]\"\n            ]\n        }\n    ]\n}\n```\n\nClick **Apply Policy**.\n\nSince the API Gateway will assume this role on behalf of the user, the trust policy needs to permit this action. To do so, edit the role's Trust Relationships by navigating to this tab on the role's Summary page.\n\nThe final trust relationship should look similar to the following:\n\n```\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"auth0\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::012345670:saml-provider/auth0-api\"\n      },\n      \"Action\": \"sts:AssumeRoleWithSAML\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"SAML:iss\": \"urn:{yourDomain}\"\n        }\n      }\n    },\n    {\n      \"Sid\": \"gateway\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"apigateway.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\n```\n\nAt this point, you will need to set the Authorization Settings on the [API Gateway](https://console.aws.amazon.com/apigateway).\n\nIn the **Resources** view, select the POST method under `/pets`.\n\nClick the **Method Request** link.\n\nClick the edit icon beside the **Authorization Type**, and select AWS\\_IAM. Now click the **Check Button** beside the field to save the setting.\n\n### 2\\. Set Up CORS and Deploy the API\n\nOur Single-Page Application (SPA) will access web API methods from a domain different from that of the page. The Cross-Origin Resource Sharing setting needs to explicitly permit this action for the browser to allow access to the AWS API Gateway. Typically, the browser will first issue an `OPTIONS` request to see what actions the site will permit.\n\nSelect `/pets` under Resources, and click **Create Method**. In the drop-down, select **OPTIONS**, and click the **checkmark** to save the setting.\n\nThe Options method is used by the browser to get the necessary HTTP headers, but the function needs further instructions on what to do. Under the `OPTIONS` Setup screen, set the following variables/parameters:\n\n*   **Integration Type**: Lambda Function;\n    \n*   **Use Lambda Proxy Integration**: leave unchecked;\n    \n*   **Lambda Region**: select your region;\n    \n*   **Lambda Function**: NoOp.\n    \n\nClick **Save**. On the next pop-up screen, grant your Lambda function the permissions it needs.\n\nYou will then be auto-directed to the `OPTIONS` Method Execution page. Open the Method Response page.\n\nExpand the **200** section located under the HTTP Status bar and add the following response headers:\n\n*   Access-Control-Allow-Headers;\n    \n*   Access-Control-Allow-Methods;\n    \n*   Access-Control-Allow-Origin.\n    \n\nNext, map the appropriate values to each of the response headers. After returning to the Method Execution page, click on **Integration Response**. After expanding the row associated with the **200** method response status, expand the **Header Mappings**, and apply the following mappings:\n\n*   Access-Control-Allow-Headers: `'Content-Type,X-Amz-Date,Authorization,x-api-key,x-amz-security-token'`;\n    \n*   Access-Control-Allow-Origin: `'*'`\n    \n*   Access-Control-Allow-Methods: `'POST, GET, OPTIONS'`\n    \n\nFinally, repeat the above steps to enable CORS for the POST and GET methods. However, for these two methods, you will add one header, Access-Control-Allow-Origin, and its value should be set to `'*'`.\n\n### Deploy the API\n\nReturn to the **Resources** view for your API. Click on **Actions**, and select **DEPLOY API**.\n\nSelect **New Stage** for Deploy State, and name the stage `Test`. Click the **Deploy** button.\n\nOn the result page, navigate to **SDK Generation**. Select JavaScript as the **Platform**. Click the **Generate SDK** button.\n\nSave the downloaded zip file for later use.",
  "title": "AWS API Gateway Tutorial Step 2",
  "description": "Step 2 of Amazon API Gateway Tutorial",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketplace-partners/writing-tips-for-installation-guides",
  "markdown": "# Writing Tips for Installation Guides\n\nIf you can't consult a full style guide, review these tips to significantly improve your content.\n\n## Use active voice\n\nAvoid passive voice (to be verb + past-tense verb). To make your text more dynamic, clear, and (often) shorter, try to use actors and active voice wherever possible.\n\n| **Preferred** | **Discouraged** |\n| --- | --- |\n| Once you add the required configuration, Auth0 will process all logins for your tenant using this Rule. Before you activate the integration in production, make sure you have configured all components correctly and verified on a test tenant. | Once the required configuration is added, all logins for your tenant will be processed by this Rule. Please make sure all components have been configured correctly and verified on a test tenant before activating the integration in production. |\n\n## Make link titles scannable\n\nWhen you link to other resources, make sure the link describes the action or task in the document to which the link is pointing. Generic link text reduces scannability by forcing readers to read all of the text surrounding a link to identify what to select.\n\n## Write device-agnostic directions\n\nRemember that user interfaces display differently on different devices. Also, remember that users may be using adaptive devices to view your content.\n\n| **Preferred** | **Discouraged** |\n| --- | --- |\n| Select **Create**. | Click **Create**. |\n| Switch to the **Applications** view. | Switch to the **Applications** tab. |\n| Locate **Client Secret**. | Scroll up to **Client Secret**. |\n\n## Use verbs and noun/adjectives properly\n\nBe careful about words that can be used as both verbs and nouns or adjectives. Verb forms usually require a space between words, while nouns and adjectives can be compounded.\n\n| **Preferred** | **Discouraged** |\n| --- | --- |\n| Log in to your account. | Login to your account. |\n| Auth0 processes logins. | Auth0 processes log ins. |\n| Set up your hardware. | Setup your hardware. |\n| Describe your hardware setup. | Describe your hardware set up. |\n\n## Use sentence case for headings\n\nOnly capitalize the first word and any other proper nouns or Auth0 product names.\n\n| **Preferred** | **Discouraged** |\n| --- | --- |\n| Add a dependency | Add a Dependency |\n| Validate resumed login | Validate Resumed Login |\n| Create an Action | Create an action |\n\n## Use simple tense for headings\n\nAvoid unnecessary wordiness by using simple tenses for headings.\n\n| **Preferred** | **Discouraged** |\n| --- | --- |\n| Assign and change users | Assigning and changing users |\n| Connect a custom database | How to connect a custom database |\n\n## Write steps concisely\n\nWhen writing introductory text for steps, be direct and concise. Remember that users already know what they need to do with a numbered list of steps.\n\n| **Preferred** | **Discouraged** |\n| --- | --- |\n| To install the SDK: | Follow the steps below: |\n\n## Set user expectations in steps\n\nTell users what the outcome of their behavior should be before describing the behavior they need to take.\n\n| **Preferred** | **Discouraged** |\n| --- | --- |\n| To activate this integration, select **Save Changes**. | Select **Save Changes** to activate this integration. |\n\n## List actions within steps in order\n\nWithin individual steps, tell the user what to do in the order they need to do it.\n\n| **Preferred** | **Discouraged** |\n| --- | --- |\n| Locate the **Integrations** section, and select **Add Integration**. | Select **Add Integration** under the **Integrations** section. |\n\n## Use notes and warning appropriately\n\nNotes and warnings have different functions. Notes should include general information that would be nice to know, whereas warnings contain information that may cause failure if not followed.\n\nIf information warrants being presented as a warning, you should include the warning exactly where the user would need to perform the related action. Users should not have to hunt for warnings.\n\n## Learn more\n\n*   [Marketplace Partners](https://auth0.com/docs/customize/integrations/marketplace-partners)\n*   [Redirect Actions for Partners](https://auth0.com/docs/customize/integrations/marketplace-partners/redirect-actions-for-partners)\n*   [Social Connections for Partners](https://auth0.com/docs/customize/integrations/marketplace-partners/social-connections-for-partners)\n*   [SSO Integrations for Partners](https://auth0.com/docs/customize/integrations/marketplace-partners/sso-integrations-for-partners)",
  "title": "Writing Tips for Installation Guides",
  "description": "Describes writing guidelines for Partners submitting integrations",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/integrations/aws-api-gateway/part-3",
  "markdown": "# AWS API Gateway Tutorial Step 3\n\n## Step 3 - Build the Application\n\nIn this step, you will build a single-page, serverless application using the AngularJS framework that you will serve out of an AWS S3 bucket configured to act as a static website.\n\n### 1\\. Set Up Your Sample Application\n\nFor a simple starter app, [download a sample project](https://github.com/auth0/auth0-aws/tree/master/examples/api-gateway/client) specific to this tutorial to get started. Log In to have your Auth0 credentials preconfigured.\n\nCopy the contents of this seed project to a local folder called `pets`, which you will be using for the remainder of this tutorial. Within this folder, update `auth0-variables.js` with your Auth0 Application `AUTH0_CLIENT_ID` and `AUTH0_CLIENT_ID` (this information is available in the [Management Dashboard](https://manage.auth0.com/#/applications) for the application in question).\n\n#### AWS S3 bucket\n\nBe sure that you have [created the AWS S3 bucket configured to act as a static website](http://docs.aws.amazon.com/gettingstarted/latest/swh/website-hosting-intro.html). During the setup process, copy the contents of the `pets` folder to your S3 bucket to provide content for the website.\n\nIf you are using a pre-existing bucket, you can move the files with the AWS CLI using the following command.\n\n```\naws s3 cp --recursive --acl \"public-read\" ./ s3://{yourBucket}/\n```\n\nPrior to proceeding, please be sure that you have at least one user associated with your Username-Password-Authentication (or the Database Connection associated with the Application you are using) Connection. To fully utilize the functionality of your sample app and its integration with AWS, you will need that user to test authentication and gain access.\n\nLastly, ensure that Auth0 allows authentication from your website by providing the URL in the **Allowed Origins** field in the Settings page of your Application. Your website's URL should look something like this:\n\n`http://your-bucket.s3-website-us-east-1.amazonaws.com`\n\nIf you don't know what your URL is, you can find it listed under the **Properties** tab of your S3 bucket.\n\nBefore going further, test logging into your application. Open `http://your-bucket-domain/index.html` in your browser. After logging in, you should see an alert box pop up that says \"getPets not implemented\":\n\nYou should also see the page for viewing pets.\n\n### Use Delegation to Get an AWS Token\n\nAt this point, you have authentication set up with Auth0, and you have an OpenID JWT. Here is the directory structure for the generated code:\n\n![AWS API Gateway - project directory](https://images.ctfassets.net/cdy7uua7fh8z/5fYL14NE1L9WuzUyA0xTky/35e78ca14e6d0c5b36582b5b74a6fc55/aws-api-gateway-project.png)\n\nYou can use Auth0's delegation capability to obtain an AWS Access Token that is based on the Auth0 identity token. Behind the scenes, Auth0 authenticates your identity token, and then uses SAML based on the addon that you configured.\n\nUpdate `pets/login/login.js` as follows to get an AWS delegation token from the identity token after a successful signin with `auth.signin`. Note that you are treating any user not logged in using a Social Connection as an admin. Later, we'll code a second role and show better ways to enforce role selection.\n\n```\nauth.signin(params, function(profile, token) {\n  //Set user as admin if they did not use a social login.\n  profile.isAdmin = !profile.identities[0].isSocial;\n  store.set('profile', profile);\n  store.set('token', token);\n\n  // get delegation token from identity token.\n  var options = getOptionsForRole(profile.isAdmin, token);\n\n  // TODO: Step 3: Enable this section once you setup AWS delegation.\n  /*\n  auth.getToken(options)\n    .then(\n      function(delegation)  {\n        store.set('awstoken', delegation.Credentials);\n        $location.path(\"/\");\n      },\n    function(err) {\n       console.log('failed to acquire delegation token', err);\n  });\n  */\n  // TODO: Step 3: Remove this redirect after you add the get token API.\n  $location.path(\"/\");\n\n}, function(error) {\n  console.log(\"There was an error logging in\", error);\n});\n```\n\n#### Modify the role and principal Strings\n\nTo modify the `role` and `principal` strings (which are the final two lines of the `if` statement contained in the provided function), specify the appropriate values via [Rules](https://manage.auth0.com/#/rules):\n\n```\nfunction (user, context, callback) {\n  if (context.clientID === 'CLIENT_ID' &&\n      context.protocol === 'delegation') {\n    // set AWS settings\n    context.addonConfiguration = context.addonConfiguration || {};\n    context.addonConfiguration.aws = context.addonConfiguration.aws || {};\n    context.addonConfiguration.aws.principal = 'arn:aws:iam::[omitted]:saml-provider/auth0-provider';\n    context.addonConfiguration.aws.role = 'arn:aws:iam::[omitted]:role/auth0-role';\n  }\n\n  callback(null, user, context);\n}\n```\n\nBe sure to update the `role` and `[principal]` ARN values with the ones for your integration.\n\nCopy the updated files to your S3 bucket for your website.\n\nOptionally, you can set a breakpoint in the browser at `store.set('awstoken', delegation.Credentials);`. When you log out and and log back in, inspect `delegation.Credentials` when you arrive at the breakpoint. You will see a familiar values like AccessKeyId and SecretAccessKey:\n\n```\n{\n    AccessKeyId: \"ASIAJB...BNQ\",\n    SecretAccessKey: \"vS+b6...2Noav\",\n    SessionToken: \"AQoDYBqsivOV...DdQW0gsKr8rgU=\",\n    Expiration: \"2015-08-27T14:48:32.000Z\"\n}\n```\n\nIf you don't see these values, be sure that you have the Amazon Web Services addon enabled in the Addons tab for your Auth0 Application.\n\n### Display Pets with the AWS API Service\n\nThe first thing you will do is show the pets to the end users.\n\n#### Add the API Code to Call Your API\n\nTo add the API code for adding a call to your service, copy the contents of apiGateway-js-sdk.zip you previously downloaded to the `pets` directory. The contents should include:\n\n*   `apiClient.js`;\n    \n*   `lib` folder;\n    \n*   `README.md`.\n    \n\nTo review the download, see [AWS API Gateway Tutorial Part 2](https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-delegation/aws-api-gateway-delegation-2#deploy-the-api).\n\nThere is already a `README.md` in the `pets` directory, so you will need to rename one of the files to keep both in the directory. The `README.md` for the API gateway explains how to use the API application from your Auth0 Application.\n\nOpen the `index.html` file located in the root of your `pets` folder to add all of the scripts listed at the top of the API readme to `index.html`:\n\n```\n<!-- scripts for aws api gateway include after you create your package from aws for api gateway. -->\n<script type=\"text/javascript\" src=\"/docs/lib/axios/dist/axios.standalone.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/CryptoJS/rollups/hmac-sha256.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/CryptoJS/rollups/sha256.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/CryptoJS/components/hmac.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/CryptoJS/components/enc-base64.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/moment/moment.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/url-template/url-template.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/apiGatewayCore/sigV4Client.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/apiGatewayCore/apiGatewayClient.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/apiGatewayCore/simpleHttpClient.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/lib/apiGatewayCore/utils.js\"></script>\n<script type=\"text/javascript\" src=\"/docs/apigClient.js\"></script>\n```\n\nIf you open `apigClient.js`, you can see that the downloaded library has created wrappers like `petsPost` and `petsGet` for your API methods. You do not need to modify this generated code.\n\n#### Configure the getPets Method\n\nOpen `home.js` in the `home` folder, and update the contents of `getPets` with a method for retrieving pets data (be sure to update the region if you are not running in `us-east-1`):\n\n```\nfunction getPets() {\n    // this is unauthenticated\n    var apigClient = apigClientFactory.newClient({\n        region: 'us-east-1' // The region where the API is deployed\n    });\n\n    apigClient.petsGet({},{})\n      .then(function(response) {\n        console.log(response);\n        $scope.pets = response.data;\n        $scope.$apply();\n      }).catch(function (response) {\n        alert('pets get failed');\n        showError(response);\n    });\n}\n```\n\nCopy the updated code to your S3 bucket. Refresh the page to see two animals listed (if you ran the previously described test on your APIs that created these pets).\n\n### Update Pets with the AWS API Service\n\nNow that you have a working Auth0 Application with the API Gateway, you will add a method for updating the `pets` table.\n\nModify the `putPets` method logic to update pets using your API function. This function will be used for both adding and removing pets.\n\n```\nfunction putPets(updatedPets) {\n    var body = {pets: updatedPets};\n\n    var apigClient = apigClientFactory.newClient({\n        region: 'us-east-1' // set this to the region you are running in.\n    });\n\n    apigClient.petsPost({},body)\n      .then(function(response) {\n        console.log(response);\n       }).catch(function (response) {\n        alert('pets update failed');\n        showError(response);\n      });\n}\n```\n\nCopy the updated code to your S3 bucket. Test the method:\n\n1.  Log out and log back in.\n    \n2.  Enter in values for `Pet Type` and `Pet Price`.\n    \n3.  Click **Save** to post your data.\n    \n\nYou should see a message that says, \"We have a `<Pet Type>` for sale for `<Pet Price>`\" with a red **REMOVE** button to its left.\n\nTo add security, add the `getSecureApiClient` function at the start of the `putPets` method:\n\n```\nfunction putPets(updatedPets) {\n     var apigClient = getSecureApiClient();\n}\n```\n\nCopy the code to your S3 bucket.\n\nThe `getSecureApiClient` function provided for you retrieves the AWS token from local storage acquired using delegation to the API, and uses the access key, secret, and session token:\n\n```\nfunction getSecureApiClient() {\n    var awstoken = store.get('awstoken');\n\n    return apigClientFactory.newClient({\n        accessKey: awstoken.AccessKeyId,\n        secretKey: awstoken.SecretAccessKey,\n        sessionToken: awstoken.SessionToken,\n        region: 'us-east-1' // The region you are working out of.\n    });\n  }\n```",
  "title": "AWS API Gateway Tutorial Step 3",
  "description": "Step 3 of Amazon API Gateway Tutorial",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-cognito",
  "markdown": "# Secure AWS API Gateway Using Cognito\n\nInstead of using IAM roles and policies to secure your API, you can do so using user pools in Amazon Cognito.\n\nPlease [create the appropriate Amazon Cognito User Pools](http://docs.aws.amazon.com/cognito/latest/developerguide/setting-up-cognito-user-identity-pools.html) prior to beginning this tutorial.\n\n## Integrate the Cognito User Pool with the API Gateway API\n\nGo to the [Amazon API Gateway Console](https://console.aws.amazon.com/apigateway). Using the left-hand navigation bar, select the **SecurePets** API.\n\nThen, select **Authorizers** for the **SecurePets** API.\n\nOn the Authorizers column near the center of the screen, choose **Create** and indicate that you are creating a **Cognito User Pool Authorizer**.\n\nTo configure your authorizer:\n\n1.  Choose the **Cognito region** in which you created your User Pool.\n    \n2.  Customize the **Authorizer name** field, if desired (it will be automatically populated with the name of the chosen User Pool, so you can opt to leave it as is)\n    \n3.  Customize the **Identity token source** field. By default, this field is set to `method.request.header.Authorization`, which sets the name of the incoming request header containing the API caller's identity token to `Authorization`.\n    \n4.  If desired, add a regular expression to the **App client ID regex** field to validate client IDs associated with the User Pool.\n    \n\nWhen you've finished configuring your authorizer, click **Create** to integrate the User Pool with your API.\n\nFor each method that you want the User Pool to act as an authorizer, you must enable the User Pool to do so for that particular method.\n\nTo enable the User Pool authorizer on the `GET` method:\n\n1.  After selecting the SecurePets API, select the `GET` method listed under `/pets`.\n    \n2.  Click on **Method Request**.\n    \n3.  Under Authorization Settings, click on the **edit icon** next to the Authorization field.\n    \n4.  Choose the appropriate Cognito User Pool authorizer from the list. Click the **checkmark icon** to save your selection.\n    \n\nRepeat this process for any additional methods for which you want the Cognito User Pool to act as an authorizer (`GET` and `PURCHASE` for `/pets`, as well as `POST` for `/purchase`).",
  "title": "Secure AWS API Gateway Using Cognito",
  "description": "How to secure the API Gateway Tutorial using Cognito instead of IAM roles and policies.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/rules-best-practices/rules-anatomy-best-practices",
  "markdown": "# Rules Anatomy Best Practices\n\nA rule is essentially an anonymous JavaScript function that is passed three parameters: a `user` object, a `context` object, and a `callback` function.\n\n```\nfunction (user, context, callback) {\n     // TODO: implement your rule\n     return callback(null, user, context);\n    }\n```\n\n**Do not** add a trailing semicolon at the end of the function declaration as this will break rule execution. Anonymous functions make it hard to interpret the call-stack generated as a result of any exceptional error condition. For convenience, use compact and unique naming conventions to assist with diagnostic analysis (e.g., `function MyRule1 (user, context, callback) {...}`). To learn more, read [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices).\n\nRules execute in the pipeline associated with the generation of artifacts for authenticity that forms part of the overall Auth0 engine. When a pipeline is executed, all enabled rules are packaged together in the order in which they are listed and sent as one code blob to be executed as an Auth0 serverless Webtask. To see the entire Auth0 engine, download [Inside the Auth0 Engine](https://cdn.auth0.com/blog/auth0-raises-100m-to-fuel-the-growth/inside-the-auth0-engine-high-res.jpg).\n\n![Rule Anatomy Best Practices Rules Pipeline Diagram](https://images.ctfassets.net/cdy7uua7fh8z/1IdyXP3cxbukXrMYuCk3VG/ac5a8d8bc8b595b79ae544c7bcc0468b/rules-best-practice-pipeline.png)\n\n## Size\n\nWe recommend that the total size of implementation for all enabled rules should not exceed 100 kB. The larger the size, the more latency is introduced due to the packaging and transport process employed by the Auth0 serverless Webtask platform, and this will have an impact on the performance of your system. Note that the 100 kB limit does not include any `npm` modules that may be referenced as part of any `require` statements.\n\n## Order\n\nThe order in which rules are displayed in the Auth0 Dashboard dictates the order in which the rules will be executed. This is important because one rule may make one or more definitions within the environment associated with execution that another rule may depend upon. In this case, the rule making the definition(s) should execute before the rule that makes use of it. To learn more, read [Rules Environment Best Practices](https://auth0.com/docs/rules-best-practices/rules-environment-best-practices).\n\nRun expensive rules that call APIs (including the Auth0 Management API) as late as possible. If you have other, less expensive rules that could cause an `unauthorized` access determination, then you should run these first.\n\n## Learn more\n\n*   [Rules Environment Best Practices](https://auth0.com/docs/rules-best-practices/rules-environment-best-practices)\n*   [Rules Execution Best Practices](https://auth0.com/docs/rules-best-practices/rules-execution-best-practices)\n*   [Rules Security Best Practices](https://auth0.com/docs/rules-best-practices/rules-security-best-practices)\n*   [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)",
  "title": "Rules Anatomy Best Practices",
  "description": "Learn about best practices for building Auth0 rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/rules-best-practices/rules-security-best-practices",
  "markdown": "# Rules Security Best Practices\n\n### Always use HTTPS\n\nAlways use HTTPS, not HTTP, when making calls to external services or when executing redirect as part of your rule implementation.\n\n### Store security sensitive values in rule Settings\n\nSecurity-sensitive information, such as credentials or API keys, should be stored in your rule settings where they'll be obfuscated, encrypted, and available via the `configuration` object. Do not store these values as literals in your rules code. For example, do not write code like this:\n\n`const myApiKey = 'abc123';`\n\nInstead, prefer to store (secret) information so that it's accessible via the `configuration` object:\n\n`const myApiKey = configuration.myApiKey;`\n\n### Do not send entire context object to external services\n\nFor rules that send information to an external service, make sure you are not sending the entire context object, since this object may contain tokens or other sensitive data. For rules that send information to external services, you should only send a subset of the less sensitive attributes from the `context` object when and where necessary.\n\nIn a similar fashion, avoid passing any aspect of the `auth0` object outside of a rule.\n\n### Check if an email is verified\n\nYou can check to see if a user's email address is verified in a rule:\n\n```\nfunction (user, context, callback) {\n      // Access should only be granted to verified users.\n      if (!user.email || !user.email_verified) {\n    return callback(new UnauthorizedError('Access denied.'));\n      }\n    \t  .\n    \t  .\n    }\n```\n\nHowever, if you want to execute different code depending on the company the user belongs to, you should not rely on the email domain, but instead, on data that can link the user to the identity provider that they authenticated with (the connection or identity-provider-specific fields such as Azure’s `tenant id`).\n\n### Check for exact string matches\n\nFor rules that determine access control based on a particular string, such as an email domain, check for an exact string match instead of checking for a substring match. If you check only for a substring, your rule may not function as you intend. For example, in:\n\n`if( _.findIndex(connection.options.domain_aliases, function(d){ return user.email.indexOf(d) >= 0;`\n\nthe code (above) would return `true` given emails such as:\n\n*   `user.domain.com@not-domain.com`\n    \n*   \"`user@domain.com`\"`@not-domain.com` (quotes included)\n    \n\nwhich may not be as desired. Instead, prefer to perform exact matches using code such as:\n\n`const emailSplit = user.email.split('@'); const userEmailDomain = emailSplit[emailSplit.length - 1].toLowerCase();`\n\nTo learn more, [see the **Check if user email domain matches configured domain rule template** on GitHub](https://github.com/auth0/rules/blob/master/src/rules/check-domains-against-connection-aliases.js), or navigate to [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules/new), and select **Create**.\n\n### Contextual bypass for Multi-Factor Authentication\n\nMulti-Factor Authentication (MFA) provides an additional layer of security in order to guard against unauthorized access. From a user experience perspective, this typically requires additional user interaction to provide a second authentication factor—i.e., typically presenting some additional credential(s) or authorizing some form of access request.\n\nThere are situations, though, when it may be desirable to bypass MFA for a user who has been designated as requiring multi-factor authentication. For instance, it maybe desirable to bypass MFA if a user has already presented both primary and secondary factors as part of authentication in the current browser context. Contextual checking in this way can help improve the user experience. However, if not done properly, it can open up serious security loop-holes which could lead to subsequent security breaches due to MFA being skipped. We therefore recommend that you observe the following guidance when considering whether to employ contextual bypass of MFA or not.\n\nAs a recommended best practice, use of `allowRememberBrowser` or `context.authentication` should be the only options considered for contextual bypass when using out-of-box MFA. Setting `allowRememberBrowser` to `true` lets users check a box so they will only be prompted for MFA periodically, whereas `context.authentication` can be used safely and accurately to determine when MFA was last performed in the current browser context; you can see some sample use of `context.authentication` in the out-of-box supplied rule, Require MFA once per session.\n\n*   **Do not perform MFA bypass** based on conditional logic related to silent authentication (e.g., `context.request.query.prompt === 'none'`)\n    \n*   **Do not perform MFA bypass** based on conditional logic using some form of device fingerprinting (e.g., where `user.app_metadata.lastLoginDeviceFingerPrint === deviceFingerPrint`)\n    \n*   **Do not perform MFA bypass** based on conditional logic using geographic location (e.g., where `user.app_metadata.last_location === context.request.geoip.country_code`)\n    \n\n#### Context checking when using custom MFA providers\n\nIn a similar fashion to that already discussed, we recommend following guidance provided in the items listed above for any rules that redirect users to custom multi-factor authentication providers. For example, for custom providers, there's no safe way to effectively bypass MFA during silent authentication because redirection (required for custom MFA) will always fail in silent authentication situations.\n\n## Learn more\n\n*   [Rules Anatomy Best Practices](https://auth0.com/docs/rules-best-practices/rules-anatomy-best-practices)\n*   [Rules Environment Best Practices](https://auth0.com/docs/rules-best-practices/rules-environment-best-practices)\n*   [Rules Execution Best Practices](https://auth0.com/docs/rules-best-practices/rules-execution-best-practices)\n*   [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)\n*   [Secure](https://auth0.com/docs/secure)",
  "title": "Rules Security Best Practices",
  "description": "Learn about best practices for Auth0 rules security.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-php",
  "markdown": "# PHP: Getting Started using Auth0-PHP\n\nThe Auth0-PHP SDK integrates into your PHP applications providing straightforward user login and signup. It supports social identity providers such as Facebook, Google, or Twitter, as well as enterprise providers such as Active Directory. The SDK provides convenient methods for accessing Auth0's Authentication and Management endpoints.\n\nThe Auth0-PHP repository is open source and [hosted on GitHub](https://github.com/auth0/auth0-PHP). We appreciate all contributions, including bug reports, enhancement proposals, and pull requests.\n\n## Requirements\n\n*   PHP 7.4+ (8.0+ recommended)\n    \n*   [Composer](https://getcomposer.org/doc/00-intro.md)\n    \n\n## Installation\n\nInstalling the Auth0 PHP SDK requires [Composer](https://getcomposer.org/doc/00-intro.md#installation-linux-unix-macos), the standard dependency management utility for PHP. Composer allows you to declare the dependent libraries your project needs and installs them for you. Please ensure Composer is installed and accessible from your shell before continuing.\n\nNext, run the following shell command within your project directory to install the SDK:\n\n```\ncomposer require auth0/auth0-php\n```\n\nThis will create a `vendor` subfolder within your project and download all the dependencies needed to use the PHP SDK. This will also create a `vendor/autoload.php` file necessary for the SDK to work with your application, which we'll import later.\n\n## Getting Started\n\nTo use the Auth0 Authentication and Management APIs, you'll need a free Auth0 account and an Application:\n\n1.  Go to [auth0.com/signup](https://auth0.com/signup) and create your account.\n    \n2.  Once you are in the dashboard, go to **Applications**, then **Create Application**.\n    \n3.  Give your Application a name, select **Regular Web Application**, then **Create**\n    \n4.  Click the **Settings** tab for the required credentials used below. To learn more, see [Application Settings](https://auth0.com/docs/get-started/applications/application-settings).\n    \n\n## Configure the SDK\n\nYou should use [environment variables](https://secure.php.net/manual/en/reserved.variables.environment.php) to store and load sensitive Auth0 credentials. This eliminates the need for hard-coding them into your application. Let's create an `.env` file within the root of our project directory to store our application's credentials:\n\nThe easiest way to use environment variables in your project is to use a library like [PHP Dotenv](https://github.com/josegonzalez/php-dotenv) along with a local `.env` file. Create a `.env` file (make sure this is not accessible publicly and is excluded from version control) and add the following values:\n\n```\n# The URL of our Auth0 Tenant Domain.\n# If we're using a Custom Domain, be sure to set this to that value instead.\nAUTH0_DOMAIN='https://{yourDomain}'\n\n# Our Auth0 application's Client ID.\nAUTH0_CLIENT_ID='{yourClientId}'\n\n# Our Auth0 application's Client Secret.\nAUTH0_CLIENT_SECRET='{yourClientSecret}'\n\n# A long secret value we'll use to encrypt session cookies. This can be generated using `openssl rand -hex 32` from our shell.\nAUTH0_COOKIE_SECRET='SEE COMMENT ABOVE'\n\n# The base URL of our application.\nAUTH0_BASE_URL='http://127.0.0.1:3000'\n```\n\nYou should never commit this file to version control or share it in an unsecure manner. The contents should be handled with care and treated like a password. As PHP is unable to read our `.env` file natively, you'll need to install a PHP library to do so. For the purposes of this documentation we'll be using `vlucas/phpdotenv`, but any \"dotenv\" library you prefer will work. From our project directory, run the following shell command to install the library:\n\n```\ncomposer require vlucas/phpdotenv\n```\n\n## Initialize the SDK\n\nWe're ready to configure and initialize an instance of the SDK within our new PHP application. Let's start by creating the PHP source file we'll be working with for this demonstration, `index.php`, and use the following snippet to get started:\n\n```\n<?php\n\n// Import the Composer Autoloader to make the SDK classes accessible:\nrequire 'vendor/autoload.php';\n\n// Load our environment variables from the .env file:\n(Dotenv\\Dotenv::createImmutable(__DIR__))->load();\n\n// Now instantiate the Auth0 class with our configuration:\n$auth0 = new \\Auth0\\SDK\\Auth0([\n    'domain' => $_ENV['AUTH0_DOMAIN'],\n    'clientId' => $_ENV['AUTH0_CLIENT_ID'],\n    'clientSecret' => $_ENV['AUTH0_CLIENT_SECRET'],\n    'cookieSecret' => $_ENV['AUTH0_COOKIE_SECRET']\n]);\n```\n\nCongratulations! Your application is now set up and ready to use with Auth0. You can now move on to building an example application using one of our PHP quickstarts. Choose the type of application you're looking to build to follow along with a quickstart suited for your needs:\n\n*   [PHP Web Application](https://auth0.com/docs/quickstart/webapp/php/)\n    \n*   [PHP Backend API](https://auth0.com/docs/quickstart/backend/php/)\n    \n\n## Learn more\n\n*   [PHP: Logging in, out, and returning user profiles with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/auth0-php-basic-use)\n*   [PHP: Using the Management API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-management-api-with-auth0-php)\n*   [PHP: Validating JWTs (JSON Web Tokens) with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/validating-jwts-with-auth0-php)\n*   [PHP: Troubleshooting your Auth0-PHP integration](https://auth0.com/docs/libraries/auth0-php/troubleshoot-auth0-php-library)",
  "title": "PHP: Getting Started using Auth0-PHP",
  "description": "Integrate a frictionless login and signup experience for your PHP applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-php/auth0-php-basic-use",
  "markdown": "# PHP: Logging in, out, and returning user profiles with Auth0-PHP\n\nThe Auth0-PHP SDK bundles three core classes: `Auth0\\SDK\\Auth0`, `Auth0\\SDK\\API\\Authentication` and `Auth0\\SDK\\API\\Management`, each offering interfaces for different functionality across Auth0's APIs. If you're building a stateful web application that needs to keep track of users' sessions, the base `Auth0` class is what you'll be working with the most. It provides methods for handling common authentication and session handling tasks such as logging in and out, retrieving user credentials, checking of an available session, and callback handling. These tasks are explained below.\n\nFor additional information on these capabilities and more, please see the [documentation page for the Authentication API](https://auth0.com/docs/libraries/auth0-php/using-the-authentication-api-with-auth0-php).\n\n## Prerequisites\n\nThe documentation below assumes that you followed the steps in the [Auth0-PHP](https://auth0.com/docs/libraries/auth0-php), and continue off from the code provided there.\n\n### Logging In\n\nThe default login process in the PHP SDK uses an [Authentication Code grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow) combined with Auth0's Universal Login Page. In short, that process is:\n\n1.  A user requesting access is redirected to the Universal Login Page.\n    \n2.  The user authenticates using one of [many possible connections](https://auth0.com/docs/authenticate/identity-providers): social (Google, X, Facebook), database (email and password), passwordless (email, SMS), or enterprise (ActiveDirectory, ADFS, Office 365).\n    \n3.  The user is redirected or posted back to your application's callback URL with `code` and `state` values if successful or an `error` and `error_description` if not.\n    \n4.  If the authentication was successful, the `state` value is validated.\n    \n5.  If the `state` is valid, the `code` value is exchanged with Auth0 for an ID Token and/or an Access Token.\n    \n6.  The identity from the ID token can be used to create an account, to start an application-specific session, or to persist as the user session.\n    \n\nAuth0-PHP handles most of these steps automatically for you. Your application will need to:\n\n1.  Call `Auth0\\SDK\\Auth0::login()` when users need to login (for example: click a link, visit walled content, etc.)\n    \n2.  Call `Auth0\\SDK\\Auth0::exchange()` when users are redirected to your callback URL.\n    \n3.  Call `Auth0\\SDK\\Auth0::getCredentials()` when you need to check if a user is logged in and retrieve user information.\n    \n\nA simple implementation of these steps looks like this:\n\n```\n// 👆 We're continuing from the \"getting started\" guide linked in \"Prerequisites\" above. Append this to the index.php file you created there.\n\n// getExchangeParameters() can be used on your callback URL to verify all the necessary parameters are present for post-authentication code exchange.\nif ($auth0->getExchangeParameters()) {\n    // If they're present, we should perform the code exchange.\n    $auth0->exchange();\n}\n\n// Check if the user is logged in already\n$session = $auth0->getCredentials();\n\nif ($session === null) {\n    // User is not logged in!\n    // Redirect to the Universal Login Page for authentication.\n    header(\"Location: \" . $auth0->login());\n    exit;\n}\n\n// 🎉 At this point we have an authenticated user session accessible from $session; your application logic can continue from here!\necho \"Authenticated!\";\n```\n\nFinally, you'll need to add your application's URL to your Auth0 Application's \"Allowed Callback URLs\" field on the settings page. After that, loading your scripted page should:\n\n1.  Immediately redirect you to an Auth0 login page for your tenant.\n    \n2.  After successfully logging in using any connection, redirect you back to your app.\n    \n3.  Display a simple page showing 'Authenticated!'.\n    \n\n### Profile\n\nNow that we have authenticated a user, we can work with their persisted session data to do things like display user profiles.\n\n```\n// 👆 We're continuing from code above. Append this to the index.php file.\n\nprintf(\n    '<h1>Hi %s!</h1>\n    <p><img width=\"100\" src=\"/docs/%s\"></p>\n    <p><strong>Last update:</strong> %s</p>\n    <p><strong>Contact:</strong> %s %s</p>\n    <p><a href=\"/docs/logout.php\">Logout</a></p>',\n    isset($session->user['nickname']) ? strip_tags($session->user['nickname']) : '[unknown]',\n    isset($session->user['picture']) ? filter_var($session->user['picture'], FILTER_SANITIZE_URL) : 'https://gravatar.com/avatar/',\n    isset($session->user['updated_at']) ? date('j/m/Y', strtotime($session->user['updated_at'])) : '[unknown]',\n    isset($session->user['email']) ? filter_var($session->user['email'], FILTER_SANITIZE_EMAIL) : '[unknown]',\n    ! empty($session->user['email_verified']) ? '✓' : '✗'\n);\n```\n\n### Logout\n\nIn addition to logging in, we also want users to be able to log out. When users log out, they must invalidate their session for the application. For this SDK, that means destroying their persistent user and token data:\n\n```\n// Log out of the application.\nheader(\"Location: $auth0->logout());\n```\n\nIf you're using Single Sign-on (SSO) and also want to end their Auth0 session, see the [SSO Logout section here](https://auth0.com/docs/libraries/auth0-php/using-the-authentication-api-with-auth0-php). More information about logging out, in general, can be found [here](https://auth0.com/docs/authenticate/login/logout).\n\n## Learn more\n\n*   [PHP: Getting Started using Auth0-PHP](https://auth0.com/docs/libraries/auth0-php)\n*   [PHP: Using the Authentication API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-authentication-api-with-auth0-php)\n*   [PHP: Using the Management API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-management-api-with-auth0-php)\n*   [PHP: Validating JWTs (JSON Web Tokens) with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/validating-jwts-with-auth0-php)\n*   [PHP: Troubleshooting your Auth0-PHP integration](https://auth0.com/docs/libraries/auth0-php/troubleshoot-auth0-php-library)",
  "title": "PHP: Logging in, out, and returning user profiles with Auth0-PHP",
  "description": "Integrate a frictionless login and signup experience for your PHP applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-php/using-the-authentication-api-with-auth0-php",
  "markdown": "# PHP: Using the Authentication API with Auth0-PHP\n\nThe Auth0 PHP SDK provides a `Auth0\\SDK\\API\\Authentication` class, which houses the methods you can use to access the [Authentication API](https://auth0.com/docs/api/authentication) directly. Please note that this interface is intended for more advanced applications and in general does provide a means of keeping track of user sessions. For most use cases, you'll want to work with the [Auth0 base class](https://auth0.com/docs/libraries/auth0-php/auth0-php-basic-use).\n\nIn this article, you'll find examples of common authentication operations.\n\n## Prerequisites\n\nThe documentation below assumes that you followed the steps in the [Installation and Getting Started sections](https://auth0.com/docs/libraries/auth0-php), and continue off from the code provided there.\n\nAn [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) is the basic way to grant users access to your application. This flow is the same one used on the [Auth0-PHP Basic Use page](https://auth0.com/docs/libraries/auth0-php/auth0-php-basic-use). If you need more granular control over the login or callback process, this section walks through how to use the Authentication API directly.\n\nUsers must authenticate with Auth0 to generate the authorization code. This is done by redirecting to the \\`/authorize\\` endpoint for your tenant domain. The following code would appear on a page that requires authentication:\n\n```\n// 👆 We're continuing from the \"getting started\" guide linked in \"Prerequisites\" above. Append this to the index.php file you created there.\n\n// Setup a PHP session, which we'll use as a custom session store for the authenticated user.\nsession_start();\n\n// $user will be null if no session is available; otherwise it will contain user data.\n$user = $_SESSION['user'] ?? null;\n\n// Has the user authenticated with us yet?\nif ($user === null) {\n    // Generates cryptographically secure pseudo-random bytes to use as a CSRF mitigating value.\n    // Store this for retrieval after authentication.\n    $_SESSION['state'] = bin2hex(random_bytes(16));\n\n    // Generate the authorize URL, and redirect the user to it.\n    header('Location: ' . $auth0->authentication()->getLoginLink($_SESSION['state']));\n    exit;\n}\n\necho '<h1>Sensitive data!</h1>';\n```\n\nThe process above does the following:\n\n1.  We check if there is an authenticated user state stored in our custom session handler. Your application might handle user sessions differently.\n    \n2.  If there is no session, then we need to log the user in by redirecting them to the Universal Login Page.\n    \n3.  We set a state value with the login request and then verify that value when the code is returned on the callback URL. We're storing this in our PHP session under the 'state' key.\n    \n4.  The `getLoginLink()` call builds the correct `/authorize` link with the correct response type (`code` in this case), redirect URI (wherein the application we will handle the response, explained below), and state (from above).\n    \n5.  We then redirect to this URL and wait for the user to be redirected back to us.\n    \n\nAfter authentication, the user is redirected back to our application at the callback URL, which is handled with the following:\n\n```\n// 👆 We're continuing from the \"getting started\" guide linked in \"Prerequisites\" above. Append this to the index.php file you created there.\n\n// Ensure we have our PHP session open so we can retrieve our stored state for comparison.\nsession_start();\n\n// Extract `code` and `state` parameters from the request query, if present.\n$code = filter_var($_GET['code'] ?? null, FILTER_UNSAFE_RAW, FILTER_NULL_ON_FAILURE);\n$state = filter_var($_GET['state'] ?? null, FILTER_UNSAFE_RAW, FILTER_NULL_ON_FAILURE);\n\n// Check if a code is present in the request query.\nif ($code === null) {\n    die('No authorization code found.');\n}\n\n// Check if a state is present, and compare it with the one we generated and stored before redirecting the user.\nif ($state === null || $state !== $_SESSION['state']) {\n    die('Invalid state.');\n}\n\n// We have compared states, we should discard this stored value now.\nunset($_SESSION['state']);\n\n// Attempt to get an access_token with the code returned and original redirect URI. (This returns a PSR-7 ResponseInterface.)\n$response = $auth0->authentication()->codeExchange($code);\n\n// Does the status code of the response indicate failure?\nif ($response->getStatusCode() !== 200) {\n    die(\"Code exchange failed.\");\n}\n\n// Decode the JSON response into a PHP array:\n$response = json_decode(response->getBody()->__toString(), true, 512, JSON_THROW_ON_ERROR);\n\n// Create an array to store our session information in.\n$session = [\n    'id_token' => $response['id_token'] ?? null,\n    'access_token' => $response['access_token'] ?? null,\n    'scope' => $response['scope'] ?? null,\n    'refresh_token' => $response['refresh_token'] ?? null,\n    'expires_in' => $response['expires_in'] ?? null,\n    'user' => null\n];\n\n// We retrieved an ID token; let's process it!\nif ($session['id_token'] !== null) {\n    // The Auth0 SDK includes a helpful token processing utility we'll leverage for this:\n    $token = new \\Auth0\\SDK\\Token($auth0->configuration(), $session['id_token'], \\Auth0\\SDK\\Token::TYPE_ID_TOKEN);\n\n    // Verify the token, and validate it's claims. These will throw an \\Auth0\\SDK\\Exception\\InvalidTokenException if a check fails.\n    $token->verify();\n    $token->validate();\n\n    $session['user'] => $token->toArray();\n}\n\n// Store our authenticated session state.\n$_SESSION['user'] = $session;\n\n// Let's echo the user claims/identity as a demo of a successful authentication flow:\nprint_r($session['user']);\n```\n\nWalking through the process in detail:\n\n1.  We look for a `code` parameter in a request query. If it's missing, we abort authentication.\n    \n2.  We check to make sure we have a `state` value and make sure it matches the same one we generated. [This is important to avoid CSRF attacks.](https://auth0.com/docs/secure/attack-protection)\n    \n3.  We attempt a code exchange with the c`odeExchange()` call, making sure to pass in the `code` Auth0 gave our application when it returned the authenticating user back to us.\n    \n4.  If this succeeds, we know the exchange was successful, and we have an ID Token and an Access Token among other potential values.\n    \n5.  We validate the ID Token and use the claims for the user identity.\n    \n6.  If this last step succeeds, we store the user and redirect back to our sensitive data.\n    \n\n## Client Credentials Flow\n\nThe [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) gives an application access to a specific API based on the scopes set in the dashboard. This is how applications can, for example, make calls to the Management API. Successful authentication will result in an Access Token being issued for the API requested.\n\nFirst, turn on the **Client Credentials** grant on then **Advanced settings > Grant Types** tab on the Application settings page.\n\nNext, authorize the Application for the API being used on the **Machine to Machine Applications** tab on the API's **Settings** page. Make sure all necessary scopes are selected (but no more) and **Update**. Switch back to the **Settings** tab and copy the **Identifier** value. This needs to be added to a `AUTH0_MANAGEMENT_AUDIENCE` key in your `.env` file.\n\nRequest an Access Token for the API using the example below:\n\n```\n// 👆 We're continuing from the \"getting started\" guide linked in \"Prerequisites\" above.\n\n// Begin a client credentials exchange:\n$response = $auth0->authentication()->clientCredentials([\n    'audience' => $_ENV['AUTH0_MANAGEMENT_AUDIENCE']\n]);\n\n// Does the status code of the response indicate failure?\nif ($response->getStatusCode() !== 200) {\n    die(\"Code exchange failed.\");\n}\n\n// Decode the JSON response into a PHP array:\n$response = json_decode(response->$getBody()->__toString(), true, 512, JSON_THROW_ON_ERROR);\n\n// Echo the response to the browser\nprint_r($response, true);\n```\n\nIf the grant was successful, you should see the following:\n\n```\nArray\n(\n    [access_token] => eyJ0eXAi...eyJpc3Mi...QoB2c24w\n    [scope] => read:users read:clients ...\n    [expires_in] => 86400\n    [token_type] => Bearer\n)\n```\n\nSee [Using the Management API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-management-api-with-auth0-php) for more information on how to use this Access Token.\n\n## Single Sign-on Logout\n\nWhile destroying the local session with a `session_destroy()` would be sufficient in de-authenticating a user from your application, you should close your end user's session with Auth0 as well. This ensures that the next time the user sees an Auth0 login form, they will be required to provide their credentials to log in. First, determine where the user should end up after the logout has completed. Save this in the Auth0 Application settings in the \"Allowed Logout URLs\" field. Also, add an `AUTH0_LOGOUT_RETURN_URL` key with this URL as the value in your `.env` file. Add the following to your application logout code:\n\n```\n// 👆 We're continuing from the \"getting started\" guide linked in \"Prerequisites\" above.\n\n// Deauthenticate the user's local session in your application.\nsession_destroy();\n\n// Redirect to Auth0's logout URL to end their Auth0 session:\nheader(\"Location: \" . $auth0->authentication()->getLogoutLink($_ENV['AUTH0_LOGOUT_RETURN_URL']);\n```\n\n## Learn more\n\n*   [PHP: Getting Started using Auth0-PHP](https://auth0.com/docs/libraries/auth0-php)\n*   [PHP: Logging in, out, and returning user profiles with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/auth0-php-basic-use)\n*   [PHP: Using the Management API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-management-api-with-auth0-php)\n*   [PHP: Validating JWTs (JSON Web Tokens) with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/validating-jwts-with-auth0-php)\n*   [PHP: Troubleshooting your Auth0-PHP integration](https://auth0.com/docs/libraries/auth0-php/troubleshoot-auth0-php-library)",
  "title": "PHP: Using the Authentication API with Auth0-PHP",
  "description": "Using Auth0's Authentication API with your PHP applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-php/using-the-management-api-with-auth0-php",
  "markdown": "# PHP: Using the Management API with Auth0-PHP\n\nThe Auth0 PHP SDK provides a `Auth0\\SDK\\API\\Management` class, which houses the methods you can use to access the [Management API](https://auth0.com/docs/api/management/v2) and perform operations on your Auth0 tenant. Using this interface, you can easily:\n\n*   Search for and create users\n    \n*   Create and update Applications\n    \n*   Retrieve log entries\n    \n*   Manage rules\n    \n\n... and much more. See our [API reference](https://auth0.com/docs/api/management/v2) for information on what's possible! Authentication\n\nTo use the Management API, you must authenticate one of two ways:\n\n*   For temporary access or testing, you can [manually generate an API token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) and save it in your `.env` file.\n    \n*   For extended access, you must create and execute and Client Credentials grant when access is required. This process is detailed on the [Authentication API page](https://auth0.com/docs/libraries/auth0-php/using-the-authentication-api-with-auth0-php).\n    \n\nRegardless of the method, the token generated must have the scopes required for the operations your app wants to execute. Consult the [API documentation](https://auth0.com/docs/api/management/v2) for the scopes required for the specific endpoint you're trying to access.\n\nTo grant the scopes needed:\n\n1.  Go to [APIs](https://manage.auth0.com/#/apis) > Auth0 Management API > **Machine to Machine Applications** tab.\n    \n2.  Find your Application and authorize it.\n    \n3.  Click the arrow to expand the row and select the scopes required.\n    \n\nNow you can authenticate one of the two ways above and use that token to perform operations:\n\n```\n// 👆 We're continuing from the \"getting started\" guide linked in \"Prerequisites\" above. Append this to the index.php file you created there.\n\nif (isset($env['AUTH0_MANAGEMENT_API_TOKEN'])) {\n    $auth0->configuration()->setManagementToken($env['AUTH0_MANAGEMENT_API_TOKEN']);\n}\n\n// Create a configured instance of the `Auth0\\SDK\\API\\Management` class, based on the configuration we setup the SDK ($auth0) using.\n// If no AUTH0_MANAGEMENT_API_TOKEN is configured, this will automatically perform a client credentials exchange to generate one for you, so long as a client secret is configured.\n$management = $auth0->management();\n```\n\nThe `Management` class stores access to endpoints as factory methods of its instances, for example `$management->users()` returns an instance of `Auth0\\SDK\\API\\Management\\Users` that you can use to interact with the /users Management API endpoints.\n\n### Example - Search Users by Email\n\nThis endpoint is documented [here](https://auth0.com/docs/api/management/v2#!/Users/get_users).\n\n```\n// 👆 We're continuing from the code above. Append this to your source code file.\n\n$response = $management->users()->getAll(['q' => 'josh']);\n\n// Does the status code of the response indicate failure?\nif ($response->getStatusCode() !== 200) {\n    die(\"API request failed.\");\n}\n\n// Decode the JSON response into a PHP array:\n$response = json_decode(response->getBody()->__toString(), true, 512, JSON_THROW_ON_ERROR);\n\nif (! empty($response)) {\n    echo '<h2>User Results</h2>';\n\n    foreach ($response as $result) {\n        printf(\n            '<p><strong>%s</strong> &lt;%s&gt; - %s</p>',\n            !empty($result['nickname']) ? $result['nickname'] : 'No nickname',\n            !empty($result['email']) ? $result['email'] : 'No email',\n            $result['user_id']\n        );\n    }\n}\n```\n\n### Example - Get All Clients\n\nThis endpoint is documented [here](https://auth0.com/docs/api/management/v2#!/Clients/get_clients).\n\n```\n// 👆 We're continuing from the code above. Append this to your source code file.\n\n$response = $management->clients()->getAll(['q' => 'josh']);\n\n// Does the status code of the response indicate failure?\nif ($response->getStatusCode() !== 200) {\n    die(\"API request failed.\");\n}\n\n// Decode the JSON response into a PHP array:\n$response = json_decode(response->getBody()->__toString(), true, 512, JSON_THROW_ON_ERROR);\n\nif (! empty($response)) {\n    echo '<h2>Get All Clients</h2>';\n\n    foreach ($response as $result) {\n        printf(\n            '<p><strong>%s</strong> - %s</p>',\n            $result['name'],\n            $result['client_id']\n        );\n    }\n}\n```\n\n## Learn more\n\n*   [PHP: Getting Started using Auth0-PHP](https://auth0.com/docs/libraries/auth0-php)\n*   [PHP: Logging in, out, and returning user profiles with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/auth0-php-basic-use)\n*   [PHP: Using the Authentication API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-authentication-api-with-auth0-php)\n*   [PHP: Validating JWTs (JSON Web Tokens) with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/validating-jwts-with-auth0-php)\n*   [PHP: Troubleshooting your Auth0-PHP integration](https://auth0.com/docs/libraries/auth0-php/troubleshoot-auth0-php-library)",
  "title": "PHP: Using the Management API with Auth0-PHP",
  "description": "Integrating Auth0's Management API endpoints with your PHP applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-php/validating-jwts-with-auth0-php",
  "markdown": "# PHP: Validating JWTs (JSON Web Tokens) with Auth0-PHP\n\nThe Auth0 PHP SDK provides a `Auth0\\SDK\\Token` class used for processing JSON Web Tokens (JWT). It enables you to decode, validate and verify tokens for use by your application. More information on JWTs and how to build and decode them can be found [jwt.io](https://jwt.io/).\n\nThe class can process both HS256 and RS256 tokens. Both types require the algorithm and valid audiences to be configured with the SDK before processing. HS256 tokens require the client secret to be configured. RS256 tokens require an authorized issuer, which is used to fetch a JWKs file during the decoding process. ([More about signing algorithms here](https://auth0.com/blog/navigating-rs256-and-jwks/).)\n\n## Prerequisites\n\nThe documentation below assumes that you followed the steps in the [PHP getting started guide](https://auth0.com/docs/libraries/auth0-php), and continue off from the code provided there.\n\n## Example Usage\n\nThe following is an example of a small, URL-based JSON Web Token processor based on the SDK's `Token` class.\n\n```\n<?php\n\n// Import the Composer Autoloader to make the SDK classes accessible:\nrequire 'vendor/autoload.php';\n\n// Load our environment variables from the .env file:\n(Dotenv\\Dotenv::createImmutable(__DIR__))->load();\n\n$token = filter_var($_GET['token'] ?? null, FILTER_UNSAFE_RAW, FILTER_NULL_ON_FAILURE);\n$algorithm = filter_var($_GET['algorithm'] ?? 'HS256', FILTER_UNSAFE_RAW, FILTER_NULL_ON_FAILURE);\n\nif ($token === null) {\n    die('No `token` request parameter.');\n}\n\nif (! in_array($algorithm, ['HS256', 'RS256'])) {\n    die('Invalid `algorithm` supplied.');\n}\n\n// The Auth0 SDK includes a helpful token processing utility we'll leverage for this:\n$token = new \\Auth0\\SDK\\Token([\n    'domain' => $env['AUTH0_DOMAIN'],\n    'clientId' => $env['AUTH0_CLIENT_ID'],\n    'clientSecret' => $env['AUTH0_CLIENT_SECRET'],\n    'tokenAlgorithm' => $algorithm\n], $token, \\Auth0\\SDK\\Token::TYPE_ID_TOKEN);\n\n// Verify the token: (This will throw an \\Auth0\\SDK\\Exception\\InvalidTokenException if verification fails.)\n$token->verify();\n\n// Validate the token claims: (This will throw an \\Auth0\\SDK\\Exception\\InvalidTokenException if validation fails.)\n$token->validate();\n\necho '<pre>';\nprint_r($token->toArray(), true);\necho '</pre>';\n```\n\nBoth `verify()` and `validate()` offer a number of options arguments that can be used to customize their behavior, including validating nonce claims, restricting maximum time since a token's `auth_time`, `leeway` clock tolerance for time checks, and more. These methods are fully commented for review of these options either via the source code or your IDE of choice.\n\n## Learn more\n\n*   [PHP: Logging in, out, and returning user profiles with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/auth0-php-basic-use)\n*   [PHP: Using the Authentication API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-authentication-api-with-auth0-php)\n*   [PHP: Using the Management API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-management-api-with-auth0-php)\n*   [PHP: Troubleshooting your Auth0-PHP integration](https://auth0.com/docs/libraries/auth0-php/troubleshoot-auth0-php-library)",
  "title": "PHP: Validating JWTs (JSON Web Tokens) with Auth0-PHP",
  "description": "Integrate JWT (JSON Web Token) validation within your PHP application to parse, verify and validate tokens.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/attack-protection/bot-detection/configure-captcha",
  "markdown": "# Configure Third-Party CAPTCHA Provider Integrations\n\nAuth0 supports several third-party CAPTCHA provider integrations for [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection).\n\n## Google reCAPTCHA Enterprise on Google Cloud Platform (GCP)\n\nYou can use Google reCAPTCHA Enterprise as a Bot Detection service for traffic exceeding 1 million assessments per month.\n\nTo learn how to configure reCAPTCHA Enterprise on GCP, read [Set up reCAPTCHA Enterprise ... on Google Documentation](https://cloud.google.com/recaptcha-enterprise/docs/authenticate-apis).\n\n### Locate your GCP project ID\n\n1.  Go to your [Google Cloud Dashboard](https://console.cloud.google.com/).\n    \n2.  Select your project in the drop-down menu to see the corresponding **Project ID**.\n    \n3.  Make a note of the **Project ID** as you will need it later.\n    \n\n### Enable reCAPTCHA Enterprise\n\n1.  In the [Google Cloud Dashboard](https://console.cloud.google.com/), enter reCAPTCHA Enterprise API in the search bar, and then select it from the Marketplace results.\n    \n2.  Select **Enable** to enable the API.\n    \n\n### Create a site key\n\n1.  In the [Google Cloud Dashboard](https://console.cloud.google.com/), enter reCAPTCHA Enterprise in the search bar, and then select it from the Marketplace results.\n    \n2.  Select **Create Key**.\n    \n3.  Under **Domain List**, add your Auth0 tenant domain.\n    \n4.  Enable the toggle for **Disable domain verification**.\n    \n5.  Enable the toggle for **Use checkbox challenge** to enable Google's \"I am not a robot\" verification checkbox.\n    \n6.  Under **Challenge Security**, select a difficulty level for the challenge.\n    \n7.  Select **Create Key**.\n    \n8.  Make a note of the **Site Key** as you will need it later.\n    \n\n### Create an API key\n\n1.  In the [Google Cloud Dashboard](https://console.cloud.google.com/), enter Credentials in the search bar, and then select it from the results.\n    \n2.  Select **Create Credentials > API Key**. Make a note of the **API Key** as you will need it later.\n    \n3.  In the pop-up, select **Edit Key**.\n    \n4.  Under **Application Restrictions**, select **IP addresses (web servers, cron jobs, etc.)**, and then enter the [Auth0 IP Addresses for Allow Lists](https://auth0.com/docs/secure/security-guidance/data-security/allowlist).\n    \n5.  Under **API Restrictions**, select **Restrict Key**, select **reCAPTCHA Enterprise API** from the drop-down list, and click OK.\n    \n6.  Select **Save**.\n    \n\n## hCaptcha\n\nThe hCaptcha widget can protect your applications from bots, spam, and other forms of automated abuse.\n\nTo learn more about hCaptcha and how to get configuration details, read [Switch from reCAPTCHA to hCaptcha on hCaptcha Docs](https://docs.hcaptcha.com/switch).\n\n## Friendly Captcha\n\nFriendly Captcha is a system for preventing spam on your website. You can add the Friendly Captcha widget to your web app to fight spam, with little impact to the user experience.\n\nTo learn more about Friendly Captcha and how to get configuration details, read [Installation on Friendly Captcha Docs](https://docs.friendlycaptcha.com/#/installation?id=installation).\n\n## Arkose\n\nArkose Labs provides a bot detection solution for mitigating human-based and bot-driven attacks. For more information on seamlessly integrating with Arkose as your CAPTCHA provider, see [Arkose Bot Manager](https://www.arkoselabs.com/arkose-bot-manager/).\n\n### Configure callback action with Auth0.js\n\nWhen using Arkose as the CAPTCHA provider, the Auth0.js WebAuth client’s `renderCaptcha` method allows you to pass a callback function. The second parameter of the callback will be a payload object containing the `triggerCaptcha` function. The `triggerCaptcha` function can be used to configure how your application handles and renders the CAPTCHA prompt.\n\nTo learn more about configuring the `renderCaptcha` method, read [renderCaptcha](https://auth0.github.io/auth0.js/WebAuth.html#renderCaptcha) in the Auth0.js documentation.",
  "title": "Configure Third-Party CAPTCHA Provider Integrations",
  "description": "Learn how to configure third-party CAPTCHA provider integrations with Auth0 Bot Detection. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment",
  "markdown": "# Custom Database Action Script Environment Best Practices\n\nAction scripts execute as a series of called JavaScript functions in an instance of a serverless Webtask container. As part of this, a specific environment is provided, together with a number of artifacts supplied by both the Webtask container and the Auth0 authentication server (your Auth0 tenant) itself.\n\n## npm modules\n\nAuth0 serverless Webtask containers can make use of a wide range of [`npm`](https://www.npmjs.com/) modules; `npm` modules not only reduce the overall size of action script code implementation, but also provide access to a wide range of pre-built functionality.\n\nBy default, a large list of publicly-available `npm` modules are supported out-of-the-box. This list has been compiled and vetted for any potential security concerns. To see which `npm` modules are supported, read [Can I require: Auth0 Extensibility](https://auth0-extensions.github.io/canirequire/).\n\nIf you require an `npm` module that is not supported out-of-the-box, then you can [make a request via the Auth0 support portal](https://support.auth0.com/) or through your Auth0 representative. Auth0 will evaluate your request to determine suitability. There is currently no support in Auth0 for the user of `npm` modules from private repositories.\n\n## Variables\n\nAuth0 action scripts support the notion of environment variables, accessed via what is defined as the globally-available `configuration` object. The `configuration` object should be treated as read-only and should be used for storing sensitive information, such as credentials or API keys for accessing external identity stores. This mitigates having security-sensitive values hardcoded in an action script.\n\nThe `configuration` object can also be used to support whatever Software Development Life Cycle (SDLC) best practice strategies you employ, such as [setting up multiple environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments), by allowing you to define variables that have tenant-specific values. This mitigates hardcoded values in an action script, which may change depending upon which tenant is executing it.\n\n## global object\n\nAuth0 serverless Webtask containers are provisioned from a pool that is associated with each Auth0 tenant. Each container instance makes available a global object, which can be accessed across all action scripts that execute within it (the container instance). The global object acts as a global variable that is unique to the container and that can be used to define information—or even functions—that can be used across all action scripts that run in it (the container instance).\n\nThis means that the global object can be used to cache expensive resources, as long as those resources are not user-specific. For example, an Access Token for a third-party (e.g., logging) API that provides non user-specific functionality could be stored. Or it could be used to store an Access Token to your own non user-specific API defined in Auth0 and obtained via use of the Client Credentials flow.\n\nEach time a Webtask container is recycled, or for each instantiation of a new Webtask container, the global object it defines is reset. Thus, any declaration of assignment within the global object associated with a container should also include provision for initialization. To provide performance flexibility, serverless Webtask containers are provisioned in Auth0 on an ad-hoc basis and are also subject to various recycle policies. In general, we recommend that you do not consider the life of a global object to be anything more than 20 minutes.\n\n## Custom database connection environment checklist\n\n*   Make sure that your database has the appropriate fields to store user profiles attributes, such as **id**, **nickname**, **email**, and **password**. To learn more about Auth0's user profile schema and expected fields, read [Normalized User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles). To learn how to update user profiles, read [Update User Profiles Using Your Database](https://auth0.com/docs/manage-users/user-accounts/user-profiles/update-user-profiles-using-your-database).\n    \n*   You can use return errors resulting from your custom database connection for troubleshooting purposes.\n    \n*   The `id` (or alternatively `user_id`) property in the returned user profile will be used by Auth0 to identify the user. If you are using multiple custom database connections, then the **id** value **must be unique across all the custom database connections** to avoid **user ID** collisions. Our recommendation is to prefix the value of **id** with the connection name (omitting any whitespace). To learn more about user IDs, read [Identify Users](https://auth0.com/docs/manage-users/user-accounts/identify-users).\n    \n*   Latency will be greater compared to Auth0-hosted user stores.\n    \n*   The database or service must be reachable from the Auth0 servers. You will need to configure inbound connections if your store is behind a firewall.\n    \n\n## Learn more\n\n*   [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution)\n*   [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices)\n*   [Debugging Best Practices](https://auth0.com/docs/troubleshoot/debugging-best-practices)\n*   [Deployment Best Practices](https://auth0.com/docs/deploy-monitor/deployment-best-practices)\n*   [Custom Database Connection Security Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/connection-security)",
  "title": "Custom Database Action Script Environment Best Practices",
  "description": "Learn about best practices for the custom database action script environment.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-passwordless-flows",
  "markdown": "# Add Bot Detection to Passwordless Flows\n\nIf you use passwordless login and signup flows, you can enable Bot Detection to render a CAPTCHA step in scenarios when a request is determined to be high-risk by Auth0. \n\n## Configure Bot Detection for passwordless flows\n\nYou can use the Auth0 Dashboard to configure the behavior of the CAPTCHA feature.\n\n1.  In the [Auth0 Dashboard](https://manage.auth0.com/dashboard), go to [Security > Attack Protection > Bot Detection](https://manage.auth0.com/dashboard/#/security/attack-protection/bot-detection).\n    \n2.  Locate the **Response** section.\n    \n3.  For the **Enforce CAPTCHA for passwordless flows** setting, select when to require CAPTCHA:\n    \n    *   **Never**: Users are not required to complete a CAPTCHA to log in.\n        \n    *   **When Risky**: Users are required to complete a CAPTCHA if the login is high risk.\n        \n    *   **Always**: Users are always required to complete a CAPTCHA to log in.\n        \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/6usFho8JQOhBL7qUptvzpa/f3aafa7f19baffc4c8fc5779063dbfe5/Bot_Detection_for_Passwordless.png)\n\n## Configure Bot Detection for custom login pages\n\nIf you are using custom login pages and would like to configure Bot Detection, please read [Add Bot Detection to Custom Login Pages](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-custom-login-pages).\n\n## Learn more\n\n*   [Add Bot Detection to Custom Login Pages](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-custom-login-pages)",
  "title": "Add Bot Detection to Passwordless Flows",
  "description": "Learn how to enable and configure bot detection for passwordless flows in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/custom-domains/post-custom-domains",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-custom-login-pages",
  "markdown": "# Add Bot Detection to Custom Login Pages\n\nIf you build a custom login page using the auth0.js library, you can enable Bot Detection to render a CAPTCHA step in scenarios when a request is determined to be high risk by Auth0.\n\nYour custom login form code must handle scenarios where the user is asked to pass a CAPTCHA step. If you don't account for this scenario, your application may cause an error.\n\n## Use custom login page template\n\nAuth0 provides a template for you to use with code to handle high-risk logins.\n\n1.  Go to [Dashboard > Branding > Universal Login](https://manage.auth0.com/#/login_settings) and select **Classic**.\n    \n2.  Click the **Login** tab and enable the **Customize Login Page** switch if it is not already enabled.\n    \n3.  Locate the **Default Templates** drop-down menu and select **Custom Login Form**.\n    \n    ![Dashboard Branding Universal Login Classic Login Tab Custom Login Form](https://images.ctfassets.net/cdy7uua7fh8z/4m3WA0sKMoR0C1KVnVmZ1G/2af0bf233072109bd882a16a6267c7bd/dashboard-branding-universal-login-classic-login-custom-login-form.png)\n4.  Copy the template to use for your custom login page. Use the steps below to customize the form.\n    \n5.  Customize the login form (see below), and replace you new form in the **Login** tab.\n    \n6.  Click **Preview** to see your new form.\n    \n7.  Click **Save Changes**.\n    \n\n## Customize the login form\n\nIf you'd like to support Bot Detection, you must use version `9.24` or higher of the auth0.js library.\n\n`<script src=\"https://cdn.auth0.com/js/auth0/9.24/auth0.min.js\"></script>`\n\n1.  Add an element to render the CAPTCHA below your password input and above your sign-up and login buttons. For example: `<div class=\"captcha-container\"></div>`\n    \n2.  Initialize the CAPTCHA component after the WebAuth constructor.\n    \n    ```\n    var webAuth = new auth0.WebAuth(params);\n    var captcha = webAuth.renderCaptcha(\n      document.querySelector('.captcha-container')\n    );\n    ```\n    \n3.  Append the value of the CAPTCHA with `captcha: captcha.getValue()` to the `login` and `signup` calls as follows:\n    \n    ```\n    webAuth.login({\n      realm: connection,\n      username: username,\n      password: password,\n      captcha: captcha.getValue()\n    }, function(err) {\n      displayError(err);\n      //....\n    });\n    \n    webAuth.redirect.signupAndLogin({\n      connection: databaseConnection,\n      email: email,\n      password: password,\n      captcha: captcha.getValue()\n    }, function(err) {\n      displayError(err);\n      //....\n    });\n    ```\n    \n    To learn more about the `login cb` parameter, read [auth0.js login documentation](https://auth0.github.io/auth0.js/global.html#login).\n    \n4.  Reload the CAPTCHA in your generic error handling logic.\n    \n    ```\n    function displayError(err) {\n      captcha.reload();\n      var errorMessage = document.getElementById('error-message');\n      errorMessage.innerHTML = err.description;\n      errorMessage.style.display = 'block';\n    }\n    ```\n    \n\nThe `render` method supports an optional parameter that allows you to change the default templates. You can find the default values here: [https://github.com/auth0/auth0.js/blob/master/src/web-auth/captcha.js#L11](https://github.com/auth0/auth0.js/blob/master/src/web-auth/captcha.js#L11).\n\n### Support passwordless flows\n\nIf you'd like to support Bot Detection for passwordless flows, you must use version `9.24` or higher of the auth0.js library.\n\n`<script src=\"https://cdn.auth0.com/js/auth0/9.20/auth0.min.js\"></script>`\n\n1.  Add an element to render the CAPTCHA above the submit button. If you also support a username/password login, a separate element should be created for the passwordless CAPTCHA. For example: `<div class=\"passwordless-captcha-container\"></div>`\n    \n2.  Initialize the CAPTCHA component for passwordless flows after the WebAuth constructor.\n    \n    ```\n    var passwordlessCaptcha = webAuth.renderPasswordlessCaptcha(\n      document.querySelector('.passwordless-captcha-container')\n    );\n    ```\n    \n3.  Add the captcha property to the Passwordless call, and reload the CAPTCHA component upon errors.\n    \n    ```\n    webAuth.passwordlessStart({\n      connection: 'email',\n      send: 'code',\n      email: 'foo@bar.com',\n      captcha: passwordlessCaptcha.getValue()\n    }, function (err,res) {\n      if (err) {\n        passwordlessCaptcha.reload();\n        // handle errors\n      }\n      // continue\n    });\n    ```\n    \n\n## Learn more\n\n*   [Add Bot Detection to Native Applications](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-native-apps)",
  "title": "Add Bot Detection to Custom Login Pages",
  "description": "Learn how to enable and configure bot detection when using custom login pages built with the auth0.js library. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/custom-domains/patch-custom-domains-by-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/attack-protection/patch-suspicious-ip-throttling",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/2022-12-21-jsonwebtoken",
  "markdown": "# CVE-2022-23539, CVE-2022-23541, CVE-2022-23540: Security Update for jsonwebtoken\n\n**Published**: Dec 21, 2022\n\n**CVE numbers**: CVE-2022-23539, CVE-2022-23541, CVE-2022-23540\n\n### Overview\n\nAuth0 has released a new major version of the `jsonwebtoken` library to address four vulnerabilities.\n\nWe recommend you review the following security advisories and upgrade to the new major version:\n\n*   Unrestricted key type could lead to legacy keys usage: [CVE-2022-23539](https://github.com/auth0/node-jsonwebtoken/security/advisories/GHSA-8cf7-32gw-wr33)\n    \n*   Insecure implementation of key retrieval function could lead to Forgeable Public/Private Tokens from RSA to HMAC: [CVE-2022-23541](https://github.com/auth0/node-jsonwebtoken/security/advisories/GHSA-hjrf-2m68-5959)\n    \n*   Insecure default algorithm in jwt.verify() could lead to signature validation bypass: [CVE-2022-23540](https://github.com/auth0/node-jsonwebtoken/security/advisories/GHSA-qwph-4952-7xr6)\n    \n\n### Am I affected?\n\nYou could be affected if you are using `jsonwebtoken` in any version <= 8.5.1 depending on the configuration. Please consult the individual security advisories for more details.\n\n### How to fix that?\n\nIf you are using `jsonwebtoken`, upgrade to version 9.0.0 or higher. You may need some additional configuration. Please consult the individual security advisories for more details.\n\n### Will this update impact my users?\n\nUpdating to version 9.0.0 may impact your users depending on your configuration and application needs. Please consult the individual security advisories for more details.",
  "title": "CVE-2022-23539, CVE-2022-23541, CVE-2022-23540: Security Update for jsonwebtoken",
  "description": "Describes CVE-2022-23539, CVE-2022-23541, CVE-2022-23540 security update for JSON web token library.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/2019-01-10-rules",
  "markdown": "# Auth0 Security Bulletin for Rules\n\n**Published**: January 10, 2019\n\n## Overview\n\nThis security bulletin covers several scenarios that customers should avoid in custom rule code, as they may create vulnerabilities in the authentication flow. A description of each issue and, where possible, an alternative way to write the same rule, is provided below.\n\n*   Custom rule code containing conditional logic to enforce multi-factor authentication (MFA) may introduce the ability to bypass MFA altogether, especially when using silent authentication.\n    \n*   Custom rule code implementing authorization controls based on a specific substring without appropriate logic may result in elevated privileges.\n    \n*   Custom rule code sending diagnostic information to third-party services, rather than using Auth0's built-in debugging features, may result in sensitive information disclosure.\n    \n*   Custom rule code triggering paid services may introduce the ability for an adversary to incur unwanted billing charges.\n    \n*   Custom rule code granting authorization based on unverified email addresses may allow adversaries to acquire those privileges through a secondary connection type.\n    \n*   Custom rule code containing hardcoded secrets, such as API keys, rather than using the global configuration object, increases the risk of exposing such secrets.\n    \n\n## Improper MFA rules\n\n### Silent authentication\n\nWithin a single-page application (SPA), silent authentication enables new access tokens to be issued without user interaction as long as the current session is valid against the authorization server.\n\nAuth0 offers silent authentication through a special parameter which is added to the authorization endpoint as follows: `/authorize?prompt=none`\n\nIf MFA is added to the silent authentication process, however, then user interaction becomes necessary.\n\nConditional logic based on silent authentication to bypass MFA should not be used as a workaround. Rules such as this allow complete MFA bypass and should not be utilized:\n\n```\nfunction (user, context, callback) {\n  if (context.request.query && context.request.query.prompt === 'none') {\n  // skip MFA for silent token requests\n  return callback(null, user, context);\n  }\n...\n}\n```\n\n### Silent authentication with redirection to custom MFA provider\n\nRules that determine whether to redirect to custom multi-factor authentication based on silent authentication may allow MFA bypass in some unusual circumstances. For example, avoid the following:\n\n```\nfunction (user, context, callback) {\n  if (context.request.query && context.request.query.prompt === 'none') {\n  //redirect to custom MFA\n  context.redirect = {\n    url: \"https://example.com/\"\n  };\n...\n}\n```\n\n### Improper verification\n\nUtilizing rules to bypass multi-factor authentication given specific conditions may bypass MFA when the checks in place are inadequate for determining the veracity of a desired state.\n\nIn these cases, the root of the issue is that rules can never determine whether MFA was successfully executed, as MFA happens after rule execution. Rules configured in this manner (see examples below) prematurely update the user record under the incorrect assumption that MFA will be successfully executed while relying on the same user record to skip MFA under given conditions.\n\nThe examples below illustrate improper verification checks which can result in full multi-factor authentication bypass.\n\n#### Device fingerprint\n\n```\nfunction (user, context, callback) {\n\n  var crypto = require('crypto');\n\n  var deviceFingerPrint = getDeviceFingerPrint();\n  user.app_metadata = user.app_metadata || {};\n\n  // Inadequate verification check\n  if (user.app_metadata.lastLoginDeviceFingerPrint !== deviceFingerPrint) {\n    user.app_metadata.lastLoginDeviceFingerPrint = deviceFingerPrint;\n    context.multi-factor = {\n      ...\n    };\n    ...\n  }\n  function getDeviceFingerPrint() {\n    var shasum = crypto.createHash('sha1');\n    shasum.update(context.request.userAgent);\n    shasum.update(context.request.ip);\n    return shasum.digest('hex');\n  }\n}\n```\n\n#### Country code\n\n```\nfunction (user, context, callback) {\n  user.app_metadata = user.app_metadata || {};\n\n  // Inadequate verification check\n  if (user.app_metadata.last_location !== context.request.geoip.country_code) {\n    user.app_metadata.last_location = context.request.geoip.country_code;\n    context.multi-factor = {\n    ...\n    };\n  }\n```\n\n### Am I affected?\n\nIf you use any of the previously illustrated rule logic, an adversary who has successfully logged in with the first authentication factor may be able to bypass MFA on your application.\n\n### Mitigation steps\n\n**If you are affected by the silent authentication scenario**, remove the conditional logic based on `prompt === 'none'`. This will trigger multi-factor authentication on each silent authentication call to check session status.\n\n**If you are affected by the silent authentication with redirection scenario**, remove the conditional logic based on `prompt === 'none'` and switch to an Auth0-supported multi-factor authentication provider.\n\nTo avoid prompting the user for MFA too often, you can set the parameter `allowRememberBrowser` to true, which will enable end-users to check a box so they will only be prompted for multi-factor authentication every 30 days. For example:\n\n```\ncontext.multi-factor = {\n    provider: 'guardian',\n    allowRememberBrowser: true\n  };\n```\n\nYou may want to notify your end users about checking the box to avoid being prompted too frequently.\n\n**If you are affected by rules utilizing improper verification for skipping MFA**, ensure to use sound verification checks, discontinue MFA exceptions entirely, or use the `allowRememberBrowser` configuration option described above.\n\n### Will this update impact my users?\n\nDepending on how you adjust your rules or configuration, this update may impact your users by prompting them for MFA more than usual.\n\n## Improper substring verification\n\nIf you have rule logic that requires access control based on an exact match of a particular string, such as an email domain, but you are only checking for a substring instead of an exact string match, your logic may not function as you intend. For example:\n\n`if( _.findIndex(connection.options.domain_aliases,function(d){ return user.email.indexOf(d) >= 0;`\n\nThe above logic would return true given emails such as these:\n\n*   `user.domain.com@not-domain.com`\n    \n*   `\"user@domain.com\"@not-domain.com` (quotes included)\n    \n\n### Am I affected?\n\nOnly customers using conditional logic in rules as described above, are affected.\n\n### Mitigation steps\n\nUtilize logic such as:\n\n`const emailSplit = user.email.split('@'); const userEmailDomain = emailSplit[emailSplit.length - 1].toLowerCase();`\n\nPlease refer to the [Check Domains Against Connection Aliases rule template](https://github.com/auth0/rules/blob/master/src/rules/check-domains-against-connection-aliases.js) for more information. Alternatively, in the **Rules** section of the Auth0 Dashboard, view the rule template named **Check if user email domain matches configured domain**.\n\n### Will this update impact my users?\n\nPossibly. The recommended change to rules with logic based on substring checks may impact end users, though you will be the best judge of the intent of your rules and whether any recommended changes are likely to impact your end users.\n\n## Debugging using external services\n\nIf you have rule logic that sends the Auth0 context object to an external service, you are exposing items such as `id_token` or `access_token` associated with the request. For example:\n\n```\nrequest.post({\n    url: 'http://requestbin.fullcontact.com/YourBinUrl',\n    json: {\n      user: user,\n      context: context,\n    },\n    timeout: 15000\n  }, function(err, response, body){\n    if (err) return callback(err);\n    return callback(null, user, context);\n  });\n```\n\n### Am I affected?\n\nOnly customers with rule logic as described above are affected.\n\n### Mitigation steps\n\nYou should modify your rule so it no longer sends the entire context object to requestbin, as this may expose any `id_token` or `access_token` associated with each request. Instead, you should send a subset of attributes from the context object that are less sensitive.\n\nPlease refer to the [Requestbin rule template](https://github.com/auth0/rules/blob/master/src/rules/requestbin.js) for more information. Alternatively, in the **Rules** section of the Auth0 Dashboard, view the rule template named **Dump rule variables to RequestBin**.\n\nAuth0 also offers built-in methods for debugging rules without sending information to external services.\n\n### Will this update impact my users?\n\nNo. The impacted rule was typically used for debugging purposes. Modification should not impact end users.\n\n## Rules using a paid service\n\nIf you have rule logic that involves a paid service, such as sending SMS messages via Twillio, as part of the authentication process, you may be vulnerable to increased costs because an adversary with a valid username and password may be able to trigger a call to the service and incur costs without having to complete the entire authentication process specified by rules. For example:\n\n```\n//Sends user SMS via Twilio\n  function notifyUser(done) {\n    const request = require('request');\n    const twilioAccount = '{yourTwilioAccount}';\n    const twilioAuthToken = '{yourTwilioAuthToken}';\n\n    request.post({\n      url: 'https://api.twilio.com/2010-04-01/Accounts/' + twilioAccount + '/Messages.json',\n      auth: {\n        'user': twilioAccount,\n        'pass': twilioAuthToken,\n      },\n      form: {\n        body: 'You\\'ve logged in from a different device or location.',\n        to: user.phone,\n        from: '+18668888888'\n      }\n    }, function (error, response, body) {\n      if (error) return done(error);\n      if (response.statusCode !== 201) return done(new Error(response.statusCode));\n      return done(null);\n    });\n  }\n```\n\n### Am I affected?\n\nOnly customers with rule logic as described above, and whose rule logic can be triggered by any untrusted user, are affected.\n\n### Mitigation steps\n\nTo mitigate this risk, consider one or more of the following actions:\n\n*   Disallow public sign-ups, if not needed, to reduce the numbers of users who can sign up and trigger calls to paid services.\n    \n*   Mitigate the risk of credential theft to avoid account takeover by hackers who might use hijacked accounts to trigger calls to paid services.\n    \n*   Ensure your users have strong passwords when using Database connections.\n    \n*   Ensure your users utilize multi-factor authentication.\n    \n*   Ensure that the rule only gets triggered for an authorized subset of users, or under other appropriate conditions. For example, you may wish to add logic that checks if a user has a particular email domain, role/group, or subscription level before triggering the call to the paid service.\n    \n\n### Will this update impact my users?\n\nThe impact to end users depends on which of the options described above you choose to mitigate the issue.\n\nIf you have rule logic that requires access control based on a particular email or email domain, but you are failing to check whether that user has verified their email, an adversary could potentially gain additional privileges by using a second connection type. For example:\n\n```\nvar userHasAccess = allowList.some(function (email) {\n    return email === user.email;\n  });\n```\n\nThe above logic would return `true` if an adversary could create an account using a different connection type (such as social) with an email address present in the allow-list. This happens because the same email can exist in different connection types.\n\n### Am I affected?\n\nOnly customers using conditional logic in rules as described above, and allowing for multiple connection types, are affected.\n\n### Mitigation steps\n\nWhenever granting authorization based on email addresses, always start the rule with the following logic:\n\n```\nfunction (user, context, callback) {\n  // Access should only be granted to verified users.\n  if (!user.email || !user.email_verified) {\n    return callback(new UnauthorizedError('Access denied.'));\n  }\n```\n\nSometimes even a verified email may not be an adequate check for the authorization you want to perform. To find out more about such cases, please read about the Email Verified Usage.\n\n### Will this update impact my users?\n\nThis will only affect existing users if they have not verified their email addresses.\n\n## Plaintext secrets within rule code\n\nIf you specify sensitive information, such as API keys, within rule code, you should configure those values in rule settings instead. For example:\n\n`const myApiKey = 'abcdefghijklmnopqrstuvwxyz';`\n\nSuch sensitive values, being present in the rule code, will remain unencrypted in our systems and suffer the risk of being exposed.\n\n### Am I affected?\n\nIf your rules contain sensitive values within the rule code itself, you are affected.\n\n### Mitigation steps\n\nPlace the sensitive values in the **Settings** area of the main **Rules** section of the Auth0 Dashboard and then access them in your rule via the following:\n\n`const myApiKey = configuration.myApiKey;`\n\nThis will ensure that all sensitive values are encrypted within Auth0's systems, reducing the risk of exposure.\n\n### Will this update impact my users?\n\nThis will not impact your users.",
  "title": "Auth0 Security Bulletin for Rules",
  "description": "Cases where improper custom rule code may create vulnerabilities in the authentication flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2022-23505",
  "markdown": "# CVE-2022-23505: Security Update for passport-wsfed-saml2 Library\n\n**Published**: Dec 12, 2022\n\nCVE number: CVE-2022-23505\n\n### Overview\n\nA remote attacker can bypass WSFed authentication on a website using `passport-wsfed-saml2`. A successful attack requires that the attacker is in possession of an arbitrary IDP signed WSFed assertion. Depending on the IDP used, fully unauthenticated attacks (e.g without access to a valid user) might also be feasible if generation of a signed message can be triggered.\n\n### Am I affected?\n\nYou are affected if you are using WSFed protocol with the `passport-wsfed-saml2` library versions  `<4.6.3`.\n\nSAML2 protocol is not affected.\n\n### How to fix that?\n\nUpgrade to version `>=4.6.3`\n\n### Will this update impact my users?\n\nThe fix provided in the patch will not affect your users.",
  "title": "CVE-2022-23505: Security Update for passport-wsfed-saml2 Library",
  "description": "Describes the security update for the passport-wsfed-saml2 Library.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2021-41246",
  "markdown": "# CVE-2021-41246: Security Update for Express OpenID Connect Library\n\n**Published**: December 08, 2021\n\n**CVE number**: `CVE-2021-41246`\n\n### Overview\n\nVersions `2.3.0` up to and including `2.5.1` do not regenerate the session id and session cookie when user logs in. This behavior opens up the application to various session fixation vulnerabilities.\n\n### Am I affected?\n\nYou are affected by this vulnerability if you are using `express-openid-connect` version `2.3.0` up to and including `2.5.1` and use a custom session store.\n\n### How to fix that?\n\nUpgrade to version `>= 2.5.2`\n\n### Will this update impact my users?\n\nThe fix provided in patch will not affect your users.",
  "title": "CVE-2021-41246: Security Update for Express OpenID Connect Library",
  "description": "CVE-2021-41246: Security Update for Express OpenID Connect Library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2021-43812",
  "markdown": "# CVE-2021-43812: Security Update for Next.js Auth0 Library\n\n**Published**: December 16, 2021\n\n**CVE number**: CVE-2021-43812\n\n### Overview\n\nVersions `<=1.6.1` do not filter out certain `returnTo` parameter values from the login url, which expose the application to an open redirect vulnerability.\n\n### Am I affected?\n\nYou are affected by this vulnerability if you are using `@auth0/nextjs-auth0` version `<=1.6.1`.\n\n### How to fix that?\n\nUpgrade to version `>=1.6.2`\n\n### Will this update impact my users?\n\nThe fix provided in patch will not affect your users.",
  "title": "CVE-2021-43812: Security Update for Next.js Auth0 Library",
  "description": "CVE-2021-43812: Security Update for Next.js Auth0 Library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2022-24794",
  "markdown": "# CVE-2022-24794: Security Update for Express OpenID Connect Library\n\n**Published**: March 30, 2022\n\n**CVE number**: CVE-2022-24794\n\n### Overview\n\nUsers of the `requiresAuth` middleware, either directly or through the default `authRequired` option, are vulnerable to an Open Redirect when the middleware is applied to a catch all route.\n\nIf all routes under `example.com` are protected with the `requiresAuth` middleware, a visit to `http://example.com//google.com` will be redirected to `google.com` after login because the original url reported by the Express framework is not properly sanitised.\n\n### Am I affected?\n\nYou are affected by this vulnerability if you are using the `requiresAuth` middleware on a catch all route or the default `authRequired` option and `express-openid-connect` version `<=2.7.1`.\n\n### How to fix that?\n\nUpgrade to version `>=2.7.2`\n\n### Will this update impact my users?\n\nThe fix provided in the patch will not affect your users.",
  "title": "CVE-2022-24794: Security Update for Express OpenID Connect Library",
  "description": "CVE-2022-24794: Security Update for Express OpenID Connect Library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2021-32702",
  "markdown": "# CVE-2021-32702: Security Update for Auth0 Next.js Library\n\n**Published**: June 23, 2021\n\n**CVE number**: `CVE-2021-32702` \n\n## Overview\n\nVersions before and including `1.4.1` are vulnerable to reflected XSS. An attacker can execute arbitrary code by providing an XSS payload in the `error` query parameter which is then processed by the callback handler as an error message.\n\n## Am I affected?\n\nYou are affected by this vulnerability if you are using `@auth0/nextjs-auth0` version `1.4.1` or lower **unless** you are using custom error handling that does not return the error message in an HTML response.\n\n### How to fix that?\n\nUpgrade to version `1.4.2`.\n\n### Will this update impact my users?\n\nThe fix adds basic HTML escaping to the error message and it should not impact your users.\n\n### Credit\n\n[https://github.com/inian](https://github.com/inian)",
  "title": "CVE-2021-32702: Security Update for Auth0 Next.js Library",
  "description": "CVE-2021-32702: Security Update for Auth0 Next.js Library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15259",
  "markdown": "# CVE 2020-15259: Security Update for ad-ldap-connector\n\n**Published**: 05 November 2020\n\n**CVE number**: CVE-2020-15259\n\n## Overview\n\nThe ad-ldap-connector admin console does not provide CSRF protection, which when exploited may result in remote code execution or confidential data loss. CSRF exploits may occur if the user visits a malicious page containing CSRF payload on the same machine that has access to the ad-ldap-connector admin console via a browser.\n\n## Am I affected?\n\nYou may be affected if you use the admin console included with ad-ldap-connector versions <=5.0.12.\n\nIf you do not have ad-ldap-connector admin console enabled or do not visit any other public URL while on the machine it is installed on, you are **not** affected.\n\n## How to fix that?\n\nUpgrade to the latest version of [ad-ldap-connector](https://github.com/auth0/ad-ldap-connector) and restart your admin console.\n\n## Will this update impact my users?\n\nThe fix provided in this version will not affect your users.",
  "title": "CVE 2020-15259: Security Update for ad-ldap-connector",
  "description": "CVE 2020-15259: Security Update for ad-ldap-connector",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15240",
  "markdown": "# CVE-2020-15240: Security Update for omniauth-auth0 JWT Validation\n\n**Published**: October 21st, 2020\n\n**CVE number**: CVE-2020-15240\n\n## Overview\n\nVersions after and including `2.3.0` are improperly validating the JWT token signature when using the `JWTValidator.verify` method. Improper validation of the JWT token signature when not using the default Authorization Code Flow can allow an attacker to bypass authentication and authorization.\n\n## Am I affected?\n\nYou are affected by this vulnerability if all of the following conditions apply:\n\n*   You are using `omniauth-auth0`\n    \n*   You are using `JWTValidator.verify` method directly OR you are not authenticating using the SDK’s default Authorization Code Flow.\n    \n\n## How to fix that?\n\nUpgrade to version `2.4.1`.\n\n## Will this update impact my users?\n\nThe fix provided in this version will not affect your users.",
  "title": "CVE-2020-15240: Security Update for omniauth-auth0 JWT Validation",
  "description": "CVE-2020-15240: Security update for omniauth-auth0 JWT validation",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2021-32641",
  "markdown": "# CVE-2021-32641: Security Update for Auth0 Lock Library\n\n**Published**: June 4, 2021\n\n**CVE number**: CVE-2021-32641\n\n## Overview\n\nVersions before and including `11.30.0` are vulnerable to a reflected XSS. An attacker can execute arbitrary code when either:\n\n*   The library's `flashMessage` feature is used and user input or data from URL parameters is incorporated into the `flashMessage`.\n    \n\nOr\n\n*   The library's `languageDictionary` feature is used and user input or data from URL parameters is incorporated into the `languageDictionary`.\n    \n\n## Am I affected?\n\nThis vulnerability affects you if your implementation fits either of these descriptions:\n\n### flashMessage vulnerability\n\nIf all of these conditions are true, you're vulnerable:\n\n*   You use `auth0-lock` version `11.30.0` or older.\n    \n*   You use the `flashMessage` feature.\n    \n*   User input or data from URL parameters is incorporated into the `flashMessage`.\n    \n\nThis is an example of a vulnerable snippet where query parameters are used to populate the `text` property of a `flashMessage`:\n\n```\nvar params = new URLSearchParams(location.search);\n\nvar errorMessage = params.get('error__message');\nvar showParams = {};\n\nif (!!errorMessage === true) {\n  showParams.flashMessage = {\n    type: 'error',\n    text: 'We were unable to log you in. ' + errorMessage,\n  };\n}\n\nlock.show(showParams);\n```\n\n### languageDictionary vulnerability\n\nIf all of these conditions are true, you're vulnerable:\n\n*   You use `auth0-lock` version `11.30.0` or older.\n    \n*   You use the `languageDictionary` feature.\n    \n*   User input or data from URL parameters is used in `languageDictionary` properties.\n    \n\nThis is an example of a vulnerable snippet that uses query parameters to populate the `socialLoginInstructions` property of a `languageDictionary`:\n\n```\nvar params = new URLSearchParams(location.search);\nvar instruction = params.get('instruction');\n\nvar options = {\n  languageDictionary: {\n    emailInputPlaceholder: \"something@youremail.com\",\n    title: \"title\",\n    socialLoginInstructions: instruction\n  },\n};\n\nvar lock = new Auth0LockPasswordless(\n    CLIENT_ID,\n    DOMAIN,\n    options\n);\n\nlock.show();\n```\n\n## How to fix that?\n\nUpgrade to `auth0-lock` version `11.30.1`.\n\n## Will this update impact my users?\n\nThe fix uses [DOMPurify](https://github.com/cure53/DOMPurify) to sanitize the `flashMessage` and `languageDictionary` inputs. It removes any JavaScript in these fields, such as `script` tags or `onclick` attributes.",
  "title": "CVE-2021-32641: Security Update for Auth0 Lock Library",
  "description": "CVE-2021-32641: Security Update for Auth0 Lock Library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15119",
  "markdown": "# CVE-2020-15119: Security Update for Auth0 Lock Library\n\n**Published**: August 16, 2020\n\n**CVE number**: CVE-2020-15119\n\n**Credit**: [Muhamad Visat](https://github.com/mvisat)\n\n## Overview\n\nVersions before and including `11.25.1` are using `dangerouslySetInnerHTML` to display an informational message when used with a Passwordless or Enterprise connection.\n\n*   For a Passwordless connection, the value of the input (email or phone number) is displayed back to the user while waiting for verification code input.\n    \n*   For an Enterprise connection, the value of the input (IdP Domain) from the Enterprise connection setup screen (Auth0 Dashboard) is displayed back to the user when the Lock widget opens.\n    \n\nWhen a Passwordless or Enterprise connection is used, the application and its users might be exposed to cross-site scripting (XSS) attacks.\n\n## Am I affected?\n\nYou are affected by this vulnerability if all of the following conditions apply:\n\n*   You are using `auth0-lock`\n    \n*   You are using Passwordless or Enterprise connection mode\n    \n\n## How to fix that?\n\nUpgrade to version `11.26.3`.\n\n### Will this update impact my users?\n\nThe fix provided in the patch will not affect your users.",
  "title": "CVE-2020-15119: Security Update for Auth0 Lock Library",
  "description": "CVE-2020-15119: Security Update for Auth0 Lock Library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15084",
  "markdown": "# CVE-2020-15084: Security Update for express-jwt Library\n\n**Published**: June 30, 2020\n\n**CVE number**: CVE-2020-15084\n\n**Credit**: IST Group\n\n## Overview\n\nVersions before and including 5.3.3, we are not enforcing the **algorithms** entry to be specified in the configuration.\n\nWhen **algorithms** is not specified in the configuration, with the combination of jwks-rsa or potentially other asymmetric crypto libraries, it may lead to authorization bypass.\n\n## Am I affected?\n\nYou are affected by this vulnerability if all of the following conditions apply:\n\n*   You are using express-jwt, AND\n    \n*   You do not have **algorithms** configured in your express-jwt configuration, AND\n    \n*   You are using libraries such as jwks-rsa as the **secret**.\n    \n\n## How to fix that?\n\nSpecify **algorithms** in the express-jwt configuration. The following is an example of a proper configuration:\n\n```\nconst checkJwt = jwt({\n  secret: jwksRsa.expressJwtSecret({\n    rateLimit: true,\n    jwksRequestsPerMinute: 5,\n    jwksUri: `https://{DOMAIN}/.well-known/jwks.json`\n  }),\n  // Validate the audience and the issuer.\n  audience: process.env.AUDIENCE,\n  issuer: `https://{DOMAIN}/`,\n  // restrict allowed algorithms\n  algorithms: ['RS256']\n});\n```\n\n## Will this update impact my users?\n\nThe fix provided in the patch will not affect your users if you specified the algorithms allowed. The patch now makes algorithms a required configuration.",
  "title": "CVE-2020-15084: Security Update for express-jwt Library",
  "description": "CVE-2020-15084: Security update for Express-jwt Library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-5263",
  "markdown": "# CVE-2020-5263: Security Update for auth0.js Library\n\n**Published**: April 09, 2020\n\n**CVE number**: CVE-2020-5263\n\n**Credit**: Bogdan Vitoc (Spatial Systems Inc)\n\n## Overview\n\nBetween versions 8.0.0 and 9.13.1 (inclusive), in the case of an (authentication) error, the error object returned by the library contains the original request of the user, which may include the plaintext password the user entered.\n\nIf the error object is exposed or logged without modification, the application risks password exposure.\n\n## Am I affected?\n\nYou are affected by this vulnerability if all of the following conditions apply:\n\n*   You are using Auth0.js version between 8.0.0 and 9.13.1 (inclusive).\n    \n*   You store or display error objects without filtering.\n    \n\n## How to fix that?\n\nDevelopers should upgrade auth0.js to version 9.13.2 or later where user inputted passwords are masked in errors. If upgrading is not possible, a temporary fix may include not storing the error object or displaying it publicly without modification.\n\n## Will this update impact my users?\n\nThis fix patches the Auth0.js and may require changes in application code due to password no longer available in error object, but it will not impact your users, their current state, or any existing sessions.",
  "title": "CVE-2020-5263: Security Update for auth0.js Library",
  "description": "CVE-2020-5263: Security Update for auth0.js library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/2020-03-31-wpauth0",
  "markdown": "# CVE-2020-5391, CVE-2020-5392, CVE-2020-6753, CVE-2020-7948, CVE-2020-7947: Security Update for WordPress Plugin for Auth0\n\n**Published**: March 31, 2020\n\n**CVE numbers**: CVE-2020-5391, CVE-2020-5392, CVE-2020-6753, CVE-2020-7948, CVE-2020-7947\n\n**Credit**: Muhamad Visat\n\n## Overview\n\nAuth0 has released a new major version of the [WordPress Plugin for Auth0](https://github.com/auth0/wp-auth0) to address several vulnerabilities.\n\nWe recommend you review the following security advisories and upgrade to the new major version:\n\n*   CSRF controls missing for domain field in Auth0 WP plugin: [CVE-2020-5391](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-5391)\n    \n*   Stored XSS in Auth0 WP plugin (Settings page): [CVE-2020-5392](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-5392)\n    \n*   Stored XSS in Auth0 WP plugin (multiple pages): [CVE-2020-6753](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-6753)\n    \n*   CSV injection vulnerabilities in Auth0 WP plugin: [CVE-2020-7947](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-7947)\n    \n*   Insecure direct object reference in Auth0 WP plugin: [CVE-2020-7948](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-7948)\n    \n\n## Am I affected?\n\nCustomers using any version of the WordPress Plugin for Auth0 3.11.3 or earlier can be affected.\n\n## How to fix that?\n\nCustomers using [WordPress Plugin for Auth0](https://github.com/auth0/wp-auth0) need to upgrade to version 4.0.0 or higher.\n\n## Will this update impact my users?\n\nThe [release notes](https://github.com/auth0/wp-auth0/blob/master/CHANGELOG.md) provide more in-depth information about the changes that were made, and the [migration instructions](https://github.com/auth0/wp-auth0/blob/master/MIGRATE-v3-TO-v4.md) provide more in-depth information about the upgrade path.",
  "title": "CVE-2020-5391, CVE-2020-5392, CVE-2020-6753, CVE-2020-7948, CVE-2020-7947: Security Update for WordPress Plugin for Auth0",
  "description": "CVE-2020-5391, CVE-2020-5392, CVE-2020-6753, CVE-2020-7948, CVE-2020-7947: Security Update for WordPress Plugin for Auth0",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-15121",
  "markdown": "# CVE-2018-15121: Security Vulnerability in auth0-aspnet and auth0-aspnet-owin\n\n**Published**: August 6, 2018\n\n**CVE number**: CVE-2018-15121\n\n**Credit**: Kévin Chalet\n\n## Overview\n\nAll versions of the [auth0-aspnet](https://github.com/auth0/auth0-aspnet) and [auth0-aspnet-owin](https://github.com/auth0/auth0-aspnet-owin) packages have a security vulnerability that leave client applications vulnerable to a Cross-Site Request Forgery (CSRF) attack during authorization and authentication operations.\n\nThe root cause of this vulnerability is lack of use and verification of the `state` parameter in OAuth 2.0 and OpenID Connect (OIDC) protocols that allows an attacker to inject their authorization code into victim's session.\n\n## Am I affected?\n\nIf you use any version of `auth0-aspnet` or `auth0-aspnet-owin`, you are affected by this vulnerability.\n\n## How to fix that?\n\nFurther development of the [auth0-aspnet](https://github.com/auth0/auth0-aspnet) and [auth0-aspnet-owin](https://github.com/auth0/auth0-aspnet-owin) packages has been discontinued. We strongly recommend moving to OWIN 4 and the official `Microsoft.Owin.Security.OpenIdConnect` package, which is not vulnerable.\n\nIf your application is not currently making use of OWIN, please refer to Microsoft's [OWIN documentation](https://docs.microsoft.com/en-us/aspnet/aspnet/overview/owin-and-katana/) to enable it in your application.\n\n### Will this update impact my users?\n\nCurrent user states and sessions will be invalidated, as different libraries will handle authentication.",
  "title": "CVE-2018-15121: Security Vulnerability in auth0-aspnet and auth0-aspnet-owin",
  "description": "CVE-2018-15121: Security vulnerability in deprecated Auth0 middleware for ASP.NET",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-13483",
  "markdown": "# CVE-2019-13483: Security Vulnerability in Passport-SharePoint\n\n**Published**: 7/23/2019\n\n**CVE number**: CVE-2019-13483\n\n## Overview\n\nVersions of [Passport-SharePoint](https://github.com/auth0/passport-sharepoint) prior to **0.4.0** do not validate the JWT signature of an Access Token before processing.\n\nThis vulnerability allows attackers to forge tokens and bypass authentication and authorization mechanisms.\n\n## Am I affected?\n\nYou are affected by this vulnerability if you use a [Passport-SharePoint](https://github.com/auth0/passport-sharepoint) version earlier than 0.4.0.\n\n## How do I fix this?\n\nDevelopers using the [Passport-SharePoint](https://github.com/auth0/passport-sharepoint) library must upgrade to version `0.4.0`.\n\nPlease note that Auth0 has deprecated and will no longer maintain this library. Developers should plan to discontinue its use.\n\n### Will this update impact my users?\n\nNo. This fix patches the library that your application runs, but it will not impact your users, their current state, or any existing sessions.",
  "title": "CVE-2019-13483: Security Vulnerability in Passport-SharePoint",
  "description": "CVE-2019-13483: Details about a security vulnerability in Passport-SharePoint",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-20173",
  "markdown": "# CVE-2019-20173: Security Update for WordPress Plugin for Auth0 wp-auth0\n\n**Published**: January 31, 2020\n\n**CVE number**: CVE-2019-20173\n\n**Credit**: Muhamad Visat\n\n## Overview\n\nThe WordPress Plugin for Auth0 versions 3.11.0, 3.11.1, and 3.11.2 do not properly sanitize the `wle` query parameter. This could allow an attacker to run a cross-site scripting (XSS) attack on the login page.\n\n## Am I affected?\n\nYou are affected by this vulnerability if all of the following apply:\n\n*   You are using the WordPress Plugin for Auth0 versions 3.11.0, 3.11.1, or 3.11.2\n    \n*   The “Original Login Form on wp-login.php” setting under Basic settings is set to either of the two options:\n    \n    *   “Via a link under the Auth0 form” (default option)\n        \n    *   “When \"wle\" query parameter is present”\n        \n\n## How to fix that?\n\nDevelopers using WordPress Plugin for Auth0 need to upgrade to version 3.11.3 or later.\n\n## Will this update impact my users?\n\nNo. This fix patches the library that your application runs, but will not impact your users, their current state, or any existing sessions.",
  "title": "CVE-2019-20173: Security Update for WordPress Plugin for Auth0 wp-auth0",
  "description": "CVE-2019-20173: Security Update for WordPress Plugin for Auth0",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-7644",
  "markdown": "# CVE-2019-7644: Security Vulnerability in Auth0-WCF-Service-JWT\n\n**Published**: February 15, 2019\n\n**CVE number**: CVE-2019-7644\n\n**Credit**: Conny Dahlgren, Security Researcher at DevilSec AB\n\n## Overview\n\nAll versions of [Auth0-WCF-Service-JWT](https://www.nuget.org/packages/Auth0-WCF-Service-JWT/) NuGet package lower than 1.0.4 include sensitive information about the expected JWT signature in an error message emitted when JWT signature validation fails:\n\n`Invalid signature. Expected 8Qh5lJ5gSaQylkSdaCIDBoOqKzhoJ0Nutkkap8RgB1Y= got 8Qh5lJ5gSaQylkSdaCIDBoOqKzhoJ0Nutkkap8RgBOo=`\n\nThis vulnerability allows attackers to use this error message to obtain a valid signature for arbitrary JWT tokens. This way attackers can forge tokens to bypass authentication and authorization mechanisms.\n\n## Am I affected?\n\nYou are affected by this vulnerability if the following conditions apply:\n\n*   You use a version of [Auth0-WCF-Service-JWT](https://www.nuget.org/packages/Auth0-WCF-Service-JWT/) NuGet package lower than 1.0.4\n    \n*   You show signature verification exception message in the user interface or make it otherwise available to the attacker (for example through logs or diagnostic messages)\n    \n\n## How to fix that?\n\nDevelopers using the [Auth0-WCF-Service-JWT](https://www.nuget.org/packages/Auth0-WCF-Service-JWT/) library need to upgrade to the latest version 1.0.4.\n\nThe updated package is available on [NuGet](https://www.nuget.org/): `Install-Package Auth0-WCF-Service-JWT -Version 1.0.4`\n\n### Will this update impact my users?\n\nNo. This fix patches the library that your application runs, but will not impact your users, their current state, or any existing sessions.",
  "title": "CVE-2019-7644: Security Vulnerability in Auth0-WCF-Service-JWT",
  "description": "CVE-2019-7644: Security vulnerability in Auth0-WCF-Service-JWT for ASP.NET",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-16929",
  "markdown": "# CVE-2019-16929: Security Vulnerability in auth0.net\n\n**Published**: 10/03/2019\n\n**CVE number**: CVE-2019-16929\n\n**Credit**: Dennis Detering (Spike Reply GmbH)\n\n## Overview\n\nVersions of [auth0.net](https://github.com/auth0/auth0.net) and associated NuGet Package [Auth0.AuthenticationAPI](https://www.nuget.org/packages/Auth0.AuthenticationApi/) from `5.8.0` to `6.5.3` inclusive include a class named `IdentityTokenValidator` with a public `ValidateAsync` method, that performs limited validation suitable only for auth0 issued tokens.\n\n## Am I affected?\n\nYou are affected by this vulnerability if all of the following conditions apply:\n\n*   You are using the `IdentityTokenValidator` to validate untrusted ID tokens\n    \n*   You are using a version of Auth0.AuthenticationAPI between `5.8.0` and `6.5.3` inclusive\n    \n\n## How to fix that?\n\nDevelopers should not use the `IdentityTokenValidator` class to validate untrusted ID tokens. See [Validate ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens) for our recommendations for validating ID tokens. [https://jwt.io/](https://jwt.io/) is a good resource on open source JWT validation libraries and their capabilities. Note that additional logic may be required based upon your use case.\n\nDevelopers using the [auth0.net](https://github.com/auth0/auth0.net) and associated NuGet Package [Auth0.AuthenticationAPI](https://www.nuget.org/packages/Auth0.AuthenticationApi/) between `5.8.0` and `6.5.3` inclusive should upgrade to the latest version `6.5.4` to prevent accidental usage of the `IdentityTokenValidator` class.\n\n### Will this update impact my users?\n\nNo. This fix patches the client library that your application runs, but will not impact your users, their current state, or any existing sessions.",
  "title": "CVE-2019-16929: Security Vulnerability in auth0.net",
  "description": "CVE-2019-16929: Security vulnerability in auth0.net",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-20174",
  "markdown": "# CVE-2019-20174: Security Update for Auth0 Lock Library\n\n**Published**: January 30, 2020\n\n**CVE number**: CVE-2019-20174\n\n**Credit**: Muhamad Visat\n\n## Overview\n\nAuth0 Lock version 11.20.4 and earlier did not properly sanitize the generated HTML code. Customers using the `additionalSignUpFields` customization option to add a checkbox to the sign-up dialog who are passing a `placeholder` property obtained from an untrusted source (e.g., a query parameter) could allow cross-site scripting (XSS) on their sign-up pages.\n\n## Am I affected?\n\nYou are affected by this vulnerability if all of the following conditions apply:\n\n*   You are using Auth0 Lock version 11.20.4 or earlier.\n    \n*   You pass `additionalSignUpFields` as an option when initializing Lock, and it includes a field of type `checkbox` with a `placeholder` value obtained from an untrusted source.\n    \n\nAn example of a vulnerable snippet is the following where the `placeholder` value is partially user-controlled by the `name` query parameter:\n\n```\n<script>\n    var params = new URLSearchParams(window.location.search);\n    var options = {\n        auth: {\n            redirectUrl: 'http://localhost:12345/callback',\n            responseType: 'code',\n            params: {\n                scope: 'openid email',\n            },\n        },\n        additionalSignUpFields: [{\n            name: 'agree',\n            type: 'checkbox',\n            placeholder: \"I agree to Terms & Conditions for \" + params.get('name'),\n        }],\n    };\n    var lock = new Auth0Lock('<CLIENT_ID>', '<TENANT_NAME>.auth0.com', options);\n    lock.show({\n        allowShowPassword: true,\n        initialScreen: 'signUp',\n    });\n</script>\n```\n\n## How to fix that?\n\nDevelopers using Auth0’s Lock sign-in solution need to upgrade to version 11.21.0 or later. Version 11.21.0 introduces two changes:\n\n1.  The existing `placeholder` property is now treated as plain text to mitigate the problem.\n    \n2.  A new `placeholderHTML` property is introduced that indicates the level of control it provides and that its value should be supplied only from trusted sources.\n    \n\n## Will this update impact my users?\n\nThis fix patches the Auth0 Lock widget and may require changes in application code, but it will not impact your users, their current state, or any existing sessions.\n\nDevelopers using the `placeholder` property with HTML content from a trusted source should start using the `placeholderHTML` property to continue providing the same user experience.",
  "title": "CVE-2019-20174: Security Update for Auth0 Lock Library",
  "description": "CVE-2019-20174: Security Update for Auth0 Lock library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-7307",
  "markdown": "# CVE-2018-7307: Security Vulnerability for auth0.js < 9.3\n\n**Published**: February 26, 2018\n\n**CVE number**: CVE-2018-7307\n\n**Credit**: Internal\n\n## Overview\n\nA vulnerability has been identified in the [auth0.js JavaScript library](https://auth0.com/docs/libraries/auth0js), affecting versions < `9.3`.\n\nThis vulnerability allows an attacker to bypass the CSRF check from the [state parameter](https://auth0.com/docs/protocols/oauth2/oauth-state) if it's missing from the authorization response, leaving the client vulnerable to CSRF attacks.\n\nPatching this vulnerability requires a library upgrade.\n\n## Am I affected?\n\nIf you use a version of auth0.js lower than `9.3` then you are affected by this vulnerability.\n\n## How to fix that?\n\nDevelopers using the auth0.js library need to upgrade to the version `9.3` or higher.\n\nUpdated packages are available on npm. To ensure delivery of additional bug fixes moving forward, please make sure your `package.json` file is updated to take patch and minor level updates of our libraries.\n\n```\n{\n  \"dependencies\": {\n    \"auth0-js\": \"^9.3.0\"\n  }\n}\n```\n\n### Will this update impact my users?\n\nNo. This fix patches the library that your application runs, but will not impact your users, their current state, or any existing sessions.",
  "title": "CVE-2018-7307: Security Vulnerability for auth0.js < 9.3",
  "description": "CVE-2018-7307: Details about a security vulnerability identified for auth0.js < 9.3",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-11537",
  "markdown": "# CVE-2018-11537: Security Update for angular-jwt Allow List Bypass\n\n**Published**: June 5, 2018\n\n**CVE number**: CVE-2018-11537\n\n**Credit**: Stephan Hauser\n\n## Overview\n\nThe [domain allowlisting](https://github.com/auth0/angular-jwt#whitelisting-domains) feature can be bypassed. For example, if the setting is initialized with:\n\n`jwtInterceptorProvider.whiteListedDomains = ['whitelisted.Example.com'];`\n\nAn attacker can set up a domain `whitelistedXexample.com` that will pass the allow list filter. The root cause for this is that `angular-jwt` always treats `whiteListedDomains` entries as regular expressions and causes `.` separator to match any character.\n\n## Am I affected?\n\nIf the following apply you are affected by this vulnerability:\n\n*   You use a version of angular-jwt lower than `0.1.10`\n    \n*   You use domain allow listing in your code\n    \n\n## How to fix that?\n\nDevelopers using the angular-jwt library need to upgrade to the latest version: `0.1.10`.\n\nUpdated package is available on [NPM](https://npmjs.com/): `npm install angular-jwt@0.1.10`\n\nTo make it easier to keep up with security updates in the future, please make sure your `package.json` file is updated to take patch and minor level updates of our libraries:\n\n```\n{\n  \"dependencies\": {\n    \"angular-jwt\": \"^0.1.10\"\n  }\n}\n```\n\n### Will this update impact my users?\n\nNo. This fix patches the library that your application runs, but will not impact your users, their current state, or any existing sessions.",
  "title": "CVE-2018-11537: Security Update for angular-jwt Allow List Bypass",
  "description": "CVE-2018-11537: Security Update for angular-jwt Allow List Bypass",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-6874",
  "markdown": "# CVE-2018-6874: Security Vulnerability in the Auth0 Authentication Service\n\n**Published**: April 4, 2018\n\n**CVE number**: CVE-2018-6874\n\n**Credit**: Internal\n\n## Overview\n\nA vulnerability has been identified in the Auth0 authentication service. Tenants of the service with the Legacy Lock API flag enabled in the service’s management dashboard are affected. If the flag is not visible, it is disabled. Disabling the flag may break applications employing the auth0.js library with version `< 9.0.0` or the Lock library with version `< 11.0.0` for crossdomain username/password based authentication - also known as [embedded login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login). Further, any cross-domain use of the `/usernamepassword/login` authentication api endpoint outside of those libraries may also be affected.\n\nAfter the verification of user credentials on `/usernamepassword/login`, an HTML form is rendered into the user’s browser and automatically executed. It POSTs a JSON Web Token (JWT) to the `/login/callback` endpoint. This authenticated token maintains state regarding the identity of the user; this cannot be done directly due to crossdomain session management restrictions maintained by most modern browsers. Due to the lack of session binding, this form post is susceptible to [CSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)). An attacker with valid user credentials at an Auth0 tenant can use them to gain such a form, and then employ techniques such as social engineering or clickjacking to have a victim’s browser execute it. The victim will then have a login session at the Auth0 tenant under the attacker’s account - and therefore be recognized as the attacker by any downstream application in its federation. Should the user undertake any actions while maliciously logged in as such, those actions and any related information will be visible to the attacker.\n\nThe attack does not allow any escalation of privileges on behalf of the attacker, and the victim’s actions visible to the attacker are restricted to whatever permissions have been granted to that attacker within the system. The victim will also be fully recognized as the attacker within the federation, and so may be shown account information or other context clues that reveal they are not operating within the auspices of their own account.\n\n## Am I affected?\n\nYou are affected if you employ username/password authentication (with any database and/or connection) for your Auth0 tenant, and the Legacy Lock API flag in the Auth0 management dashboard is visible and flagged on.\n\n## How to fix that?\n\nTo mitigate the vulnerability, toggle the flag to off. The `/usernamepassword/login` endpoint will still work for logins from the Universal Login page hosted on `/login`, however these - as same-domain logins - will be protected from CSRF. Otherwise, toggling the flag will disable cross-domain authentication on that endpoint.\n\nFor applications employing auth0.js version `< 9.0.0` or Lock version `< 11.0.0`, this may break user logins. Upgrading to auth0.js version `> 9.0.0` or Lock version `> 11.0.0` will restore embedded username/password authentication using cross-origin authentication (note the limitations). Applications are also encouraged to migrate to Universal Login.\n\nPrivate SaaS Appliances running versions `> 14591` with the Legacy Lock API flag set to off are not affected by this vulnerability.\n\n### Will this update impact my users?\n\nIf the Legacy Lock API is disabled without applications having migrated, then all user logins employing the affected functionality will break. Auth0 intends to enforce disablement of the Legacy Lock API for all tenants on July 16th, 2018. The choice of migration may affect the specific user experience of logging into your service, however users, their information, and their sessions will not be otherwise impacted.",
  "title": "CVE-2018-6874: Security Vulnerability in the Auth0 Authentication Service",
  "description": "CVE-2018-6874: Details about a security vulnerability identified in the Auth0 authentication service",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2017-17068",
  "markdown": "# CVE-2017-17068: Security Update for auth0.js Popup Callback Vulnerability\n\n**Published**: December 4, 2017\n\n**CVE number**: CVE-2017-17068\n\n**Credit**: [@AppCheckNG](https://twitter.com/AppCheckNG)\n\n## Overview\n\nA vulnerability has been identified in the [auth0.js JavaScript library](https://auth0.com/docs/libraries/auth0js), affecting versions < `8.12`.\n\nIf your site or application uses a popup callback page with `auth0.popup.callback()` then an attacker can take advantage of unrestricted cross-origin post message requests and gain access to the tokens of logged-in users. A malicious website could then use any acquired Access Tokens to invoke services on behalf of the user.\n\nThis update addresses the vulnerability by implementing origin verification so the message cannot be posted to a page that is not in a specified domain. If no domain is specified, only the domain where the callback page is hosted is allowed. An attacker would receive a cross-origin request error.\n\nPatching this vulnerability requires a library upgrade.\n\n## Am I affected?\n\nIf the following apply you are affected by this vulnerability:\n\n*   You use a version of auth0.js lower than `8.12`\n    \n*   You use a popup callback page with `auth0.popup.callback()` in your code\n    \n\n## How to fix that?\n\nDevelopers using the auth0.js library need to upgrade to the latest version: `8.12`.\n\nUpdated packages are available on npm. To ensure delivery of additional bug fixes moving forward, please make sure your `package.json` file is updated to take patch and minor level updates of our libraries.\n\n```\n{\n  \"dependencies\": {\n    \"auth0-js\": \"^8.12.0\"\n  }\n}\n```\n\n### Will this update impact my users?\n\nNo. This fix patches the library that your application runs, but will not impact your users, their current state, or any existing sessions.",
  "title": "CVE-2017-17068: Security Update for auth0.js Popup Callback Vulnerability",
  "description": "CVE-2017-17068: Security Update for auth0.js Popup Callback Vulnerability",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-6873",
  "markdown": "# CVE-2018-6873: Security Vulnerability in the Auth0 Authentication Service\n\n**Published**: April 4, 2018\n\n**CVE number**: CVE-2018-6873\n\n**Credit**: [Cinta Infinita](http://www.cintainfinita.com/)\n\n## Overview\n\nA vulnerability was identified in the Auth0 authentication service. It affected all Auth0 tenants, and was patched on October 15th, 2017 within four hours of report for all public cloud customers. This notice is informational and is intended to explain the vulnerability and the mitigation taken.\n\nAs part of an user authentication flow employed by the Auth0 service, a JSON Web Token (JWT) is passed to the `/login/callback` endpoint identifying the user. This token contains a reference to which audience - an Auth0 tenant - it is intended for. A flaw in the Auth0 service did not properly validate this audience, and therefore allowed tokens intended for one tenant to be used at another. Further, the custom database functionality available to all Auth0 tenants allows for authenticated tokens to be generated with any desired identifier. Therefore, could an attacker learn the user identifier of an intended victim at a target tenant - which is generally considered public information - they could construct a token with that identifier. Due to the improper audience checking the target tenant would accept it, and establish a login session recognizing the attacker as the victim. This allowed for privilege escalation, among other possible attack vectors.\n\nA specific concern was the potential use of this attack on the Auth0 management service. Auth0 tenants are managed by tenant administrators, who have accounts on an \"authority tenant\" with relevant permissions. If an attacker could learn the user identifier of a tenant administrator on the tenant authority (such as by social engineering), this allowed the attacker to login as the administrator by the described attack method. The attacker could then undertake administration actions and view all information at the tenant.\n\nThe attack was never effective if the user had multifactor authentication enabled, which is recommended.\n\n## Am I affected?\n\nAll Auth0 tenants were affected, but have been patched. Public cloud tenants were patched within four hours of the vulnerability report.\n\nThe attack was never effective if the user had multifactor authentication enabled.\n\n## How to fix that?\n\nThe vulnerability was fixed by Auth0, accomplished by adding proper validation of the audience parameter. No additional actions are required of our customers.\n\n### Will this update impact my users?\n\nThe fix was invisible to all users.",
  "title": "CVE-2018-6873: Security Vulnerability in the Auth0 Authentication Service",
  "description": "CVE-2018-6873: Details about a security vulnerability identified in the Auth0 authentication service",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-right-to-access-correct-and-erase-data",
  "markdown": "# GDPR: Right to Access, Correct, and Erase Data\n\nAs per articles 15, 16, 17, and 19 of GDPR, users have the right to get a copy of their personal data you are processing, ask for rectifications if they are inaccurate, and ask you to delete their personal data.\n\nWith Auth0, you can access, edit, and delete user information manually, using the Dashboard, or programmatically, using the Management API.\n\n## Manual process\n\nYou can view, edit, and delete user information at [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users). Drill down to a user to view their information. The information you can change is:\n\n| **Field** | **How to edit** |\n| --- | --- |\n| **Email** | Click Edit. Set the new email. |\n| **Email verified** | Click **Edit** at the **Εmail** field. Click the **Set email as verified** link. |\n| **Metadata** | Both the `app_metadata` and the `user_metadata` objects are editable from this screen. Edit the JSON at the **Metadata** section and save your changes. |\n| **Blocked** | Not directly editable. Click **Actions > Block User** at the top right of this screen. To unblock click **Actions > Unblock User**. |\n| **Email** | Not directly editable. Click **Actions > Change Email** at the top right of this screen. |\n| **Password** | Not directly editable. Click **Actions > Change Password** at the top right of this screen. |\n\nTo delete a user, click **Actions > Delete User**.\n\n## Programmatic process\n\nYou can retrieve, edit, and delete user information using our API. Choose an endpoint that matches your needs:\n\n*   Retrieve a user using the ID as search criteria\n    \n*   Retrieve a user using the Email as search criteria\n    \n*   Export all users to a file using a long running job\n    \n*   Update a user. Note that not all fields are editable (see the next section). Keep in mind that:\n    \n    *   The properties of the new object will replace the old ones. The `user_metadata` and `app_metadata` fields are an exception to this rule. These properties are merged instead of being replaced, though the merge happens only on the first level.\n        \n    *   If you are updating `email_verified`, `phone_verified`, `username`, or `password`, you must set the `connection` parameter.\n        \n    *   If your are updating `email` or `phone_number`, you must set the `connection` and the `client_id` parameters.\n        \n*   Delete a user based on the ID\n    \n\nIn order to call any of the API endpoints, you will need an valid access token. This token must have the required permissions per endpoint. Each endpoint at the Management API explorer has a scopes section that lists the scope(s) that the access token must contain in order to access it. Once you know which endpoint you want to access, and you have a valid access token, you are ready to send your request.\n\n## Editable data\n\nThe following user information can be updated using the API:\n\n*   blocked\n    \n*   email\\_verified\n    \n*   email\n    \n*   verify\\_email\n    \n*   password\n    \n*   phone\\_number\n    \n*   phone\\_verified\n    \n*   verify\\_password\n    \n*   user\\_metadata\n    \n*   app\\_metadata\n    \n*   username\n    \n\nThe following user information are **not** editable:\n\n*   given\\_name\n    \n*   family\\_name\n    \n*   name\n    \n*   nickname\n    \n*   picture\n    \n\n## Searchable fields\n\nYou can search for users using the following:\n\n*   All the normalized user profile fields\n    \n*   The profile information under the `user_metadata` object:\n    \n    *   name\n        \n    *   nickname\n        \n    *   given\\_name\n        \n    *   family\\_name\n        \n\nYou are responsible for ensuring customer is erased or data is updated in any other databases that Auth0 is not connected to.\n\n## Learn more\n\n*   [GDPR: Conditions for Consent](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-conditions-for-consent)\n*   [GDPR: Data Minimization](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-minimization)\n*   [GDPR: Data Portability](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-portability)\n*   [GDPR: Protect and Secure User Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-protect-and-secure-user-data)",
  "title": "GDPR: Right to Access, Correct, and Erase Data",
  "description": "Describes Auth0 features that help you comply with the GDPR requirements on the user's right to access, correct, and erase their personal data.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-minimization",
  "markdown": "# GDPR: Data Minimization\n\nAccording to Article 5 of GDPR, the personal data you collect must be limited to what is necessary for processing and must be kept only as long as needed. Appropriate security must be ensured during data processing, including protection against unauthorised or unlawful processing and against accidental loss, destruction, or damage.\n\nThere are several Auth0 features than can help you achieve these goals, like account linking, user profile encryption, and more.\n\n## Restrict user profile information\n\nTo limit the amount of personal information in the Auth0 user profile, you can:\n\n*   Minimize (or avoid) saving personal information in the metadata section of the user profile\n    \n*   If you use enterprise directories, configure them to return only the minimum information needed\n    \n*   If you use social providers, configure them to return only the minimum information needed\n    \n*   Denylist the user attributes that you do not want to persist in the Auth0 databases\n    \n\n## Encrypt user profile information\n\nYou can encrypt user information before you save it in the user profile. You can use any encryption mechanism you like prior to storing data in the metadata fields. When a user sets sensitive information, call the Update a User endpoint.\n\n## Use account linking\n\nEvery time a user uses a connection to log in to your application, a user profile is created if it doesn't already exist. Note that this is per connection.\n\nTo better understand this, consider the following scenario. Your application offers three different options for signup:\n\n*   sign up with email/password\n    \n*   login with Google\n    \n*   login with Facebook\n    \n\nIf a user signs up with Google, this will create a user profile in Auth0. If the same user, upon return, does not remember what he signed up with, and chooses to login with Facebook, Auth0 will create another user profile for the user. So now you have two profiles for the same user.\n\nYou can fix this with account linking. You can link multiple accounts under a single user profile, regardless of the connection's type (for example, user/password, social, or SAML).\n\nThere are two ways to implement this:\n\n*   **User-initiated** account linking: your app must provide the UI so an authenticated user can link their accounts manually.\n    \n*   **Suggested** account linking: in this case you still configure a rule that will link accounts with the same verified email address. However, instead of completing the link automatically, your app will first prompt the user to link their identities.\n    \n\n## Export logs\n\nYou can export Auth0 logs and either store them yourself or automatically push them to an external log service in [Auth0 Marketplace](https://marketplace.auth0.com/features/log-streaming). This functionality can help you with data retention requirements, as well as log analysis requirements.\n\n### Export logs with the API\n\nYou can use the Management API to export logs and store them yourself. There are the two available endpoints, each providing slightly different information.\n\n#### Search all logs\n\nThe Search Log Events endpoint retrieves log entries that match the search criteria you provided. If you do not provide any search criteria, you will get a list of all available entries.\n\nYou can provide search criteria using the **q** parameter and retrieve specific fields using the **fields** parameter.\n\nTo access the API, you need a Management APIv2 token.\n\nThis sample request retrieves all logs for successful logins (the event acronym for successful login is `s`). The list of fields we will retrieve per log entry is: **date**, **description**, **client\\_id**, and **log\\_id**.\n\n#### Get a single log entry\n\nThe Get a Log Event by ID endpoint retrieves the log entry associated with the provided ID.\n\nThis sample request retrieves a single log entry with the ID `90020180129170850881585554625888895190928456277777449010`.\n\n### Export to an external service\n\nYou can install and configure one of our [log streaming solutions](https://marketplace.auth0.com/features/log-streaming) in Auth0 Marketplace to export logs automatically to another provider, like Sumo Logic or Loggly. For a list of available providers and detailed steps to configure each, see Export Auth0 logs to an external service.\n\n## Keep sensitive information from logs\n\nYou should minimize any sensitive information contained in URLs that might be captured by Auth0 log files. For example, consider using `health-site` or similar as your domain name instead of `cancer-treatments`.\n\nYou also need to ensure that you do the following:\n\n*   Analyze what you are collecting in sign up and through social media and whether that is necessary for the purpose of your service.\n    \n*   Configure enterprise identity providers to control what data is returned to Auth0.\n    \n*   Specify what data you want to collect from the social provider and negotiate any particular terms around social login with the social provider around use of the data they will get around your users’ login.\n    \n\n## Learn more\n\n*   [GDPR: Conditions for Consent](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-conditions-for-consent)\n*   [GDPR: Data Portability](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-portability)\n*   [GDPR: Protect and Secure User Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-protect-and-secure-user-data)\n*   [GDPR: Right to Access, Correct, and Erase Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-right-to-access-correct-and-erase-data)",
  "title": "GDPR: Data Minimization",
  "description": "Describes how you can minimize the personal data they collect for processing and ensure their security.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15125",
  "markdown": "# CVE-2020-15125: Security Update for node-auth0 Library\n\n**Published**: July 28, 2020\n\n**CVE number**: CVE-2020-15125\n\n**Credit**: Omar Diab (http://github.com/osdiab)\n\n## Overview\n\nVersions before and including 2.27.0 use a block list of specific keys that should be sanitized from the request object contained in the error object. When a request to Auth0 management API fails, the key for `Authorization` header is not sanitized and the `Authorization` header value can be logged exposing a bearer token.\n\n## Am I affected?\n\nYou are affected by this vulnerability if all of the following conditions apply:\n\n*   You are using auth0 npm package.\n    \n*   You are using a Machine to Machine application authorized to use Auth0's management API Client Credentials Flow.\n    \n\n## How to fix that?\n\nUpgrade to version 2.27.1.\n\n## Will this update impact my users?\n\nThe fix provided in patch will not affect your users.",
  "title": "CVE-2020-15125: Security Update for node-auth0 Library",
  "description": "CVE-2020-15125: Security update for node-auth0 library",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-custom-ui",
  "markdown": "# GDPR: Track Consent with Custom UI\n\nIn this tutorial we will see how you can use auth0.js or the Auth0 APIs to ask for consent information and save the input at the user's metadata. To learn more, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata).\n\nIf you would instead like to track consent using Lock, see [GDPR: Track Consent with Lock](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-lock).\n\nThe contents of this document are **not** intended to be legal advice, nor should they be considered a substitute for legal assistance. The final responsibility for understanding and complying with GDPR resides with you, though Auth0 will assist you in meeting GDPR requirements where possible.\n\n## Overview\n\nWe will capture consent information, under various scenarios, and save this in the user's metadata.\n\nAll scenarios will save the following properties in the user's metadata:\n\n*   `consentGiven` (true/false) shows if the user has provided consent (true) or not (false)\n    \n*   `consentTimestamp` (Unix timestamp) indicates when the user-provided consent\n    \n\nFor example:\n\n```\n{\n  \"consentGiven\": \"true\"\n  \"consentTimestamp\": \"1525101183\"\n}\n```\n\nWe will see four different implementations for this:\n\n1.  one that displays a flag, works for database connections, and uses the auth0.js library to create the user (used by Single-Page Applications). To learn more, read [Auth0.js v9 Reference](https://auth0.com/docs/libraries/auth0js).\n    \n2.  one that displays a flag, works for database connections, and uses the Authentication API to create the user (used by Regular Web Apps)\n    \n3.  one that displays a flag, works for social connections, and uses the Management API to update the user's information (used either by SPAs or Regular Web Apps)\n    \n4.  one that redirects to another page where the Terms & Conditions and/or privacy policy information can be reviewed and consent info can be provided (used either by SPAs or Regular Web Apps)\n    \n\n## Option 1: Use auth0.js\n\nIn this section, we will use a simple Single-Page Application and customize the login widget to add a flag which users can use to provide consent information. Instead of building an app from scratch, we will [use Auth0's JavaScript Quickstart sample](https://auth0.com/docs/quickstart/spa/vanillajs). We will also use Auth0's Universal Login pages so we can implement Universal Login, instead of embedding the login in our app. To learn more about Universal Login, read [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). To learn more about the differences between Universal Login and embedded login, read [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\nThis works **only** for database connections (we will use Auth0's infrastructure, instead of setting up our own database).\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and create a new application. Choose `Single Web Page Applications` as type. Go to **Settings** and set the **Allowed Callback URLs** to `http://localhost:3000`.\n    \n    This field holds the set of URLs to which Auth0 is allowed to redirect the users after they authenticate. Our sample app will run at `http://localhost:3000` hence we set this value.\n    \n2.  Copy the **Client Id** and **Domain** values. You will need them in a while.\n    \n3.  Go to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database) and create a new connection. Click **Create DB Connection**, set a name for the new connection, and click **Save**. Go to the connection's **Applications** tab and make sure your newly created application is enabled.\n    \n4.  [Download the JavaScript SPA Sample](https://auth0.com/docs/quickstart/spa/vanillajs).\n    \n5.  [Set the Client ID and Domain values](https://github.com/auth0-samples/auth0-javascript-samples/tree/master/01-Login#set-the-client-id-and-domain).\n    \n6.  Go to [Auth0 Dashboard > Branding > Universal Login](https://manage.auth0.com/#/login_settings). At the **Login** tab enable the toggle.\n    \n7.  At the **Default Templates** dropdown make sure that `Custom Login Form` is picked. The code is pre-populated for you.\n    \n8.  Set the value of the `databaseConnection` variable to the name of the database connection your app is using.\n    \n    ```\n    //code reducted for simplicity\n    \tvar databaseConnection = 'test-db';\n    \t//code reducted for simplicity\n    ```\n    \n9.  To add a field for the `consentGiven` metadata, add a checkbox at the form. For our example, we will configure the checkbox as checked by default and disabled so the user cannot uncheck it. You can adjust this according to your business needs.\n    \n    ```\n    //code reducted for simplicity\n        <div class=\"form-group\">\n          <label for=\"name\">I consent with data processing</label>\n          <input\n            type=\"checkbox\"\n            id=\"userConsent\"\n            checked disabled>\n        </div>\n        //code reducted for simplicity\n    ```\n    \n10.  Edit the signup function to set the metadata. Note that we set the value of the metadata to a string with the value `true` and not to a boolean value, and we are using `toString` to convert the number to a string. This is due to a restriction of the Authentication API [**Signup** endpoint](https://auth0.com/docs/api/authentication#signup) which only accepts strings as values.\n    \n    ```\n    //code reducted for simplicity\n        webAuth.redirect.signupAndLogin({\n          connection: databaseConnection,\n          email: email,\n          password: password,\n          user_metadata: { consentGiven: 'true', consentTimestamp: Date.now().toString() }\n        }, function(err) {\n          if (err) displayError(err);\n        });\n        //code reducted for simplicity\n    ```\n    \n11.  To see what the login widget will look like, click the **Preview** tab.\n    \n\n![Dashboard Branding Universal Login Classic Login Tab Custom Login Form](https://images.ctfassets.net/cdy7uua7fh8z/4m3WA0sKMoR0C1KVnVmZ1G/2af0bf233072109bd882a16a6267c7bd/dashboard-branding-universal-login-classic-login-custom-login-form.png)\n\n1.  To test this configuration run the application and go to `http://localhost:3000`. Sign up with a new user. Then go to [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users) and search for your new user. Go to **User Details** and scroll down to the **Metadata** section. At the **user\\_metadata** text area, you should see the `consentGiven` metadata set to `true`.\n    \n\n## Option 2: Use the API (database)\n\nIf you serve your login page from your own server, then you can call the Authentication API [**Signup** endpoint](https://auth0.com/docs/api/authentication#signup) directly once the user signs up.\n\nFor the same scenario we have been discussing so far, once you sign up a new user, you can use the following snippet to create the user at Auth0 and set the metadata. Remember to replace the value of the `consentTimestamp` request parameter with the timestamp of when the user provided consent.\n\n*   [cURL](#e22544b18fe34e3bb5e0610e9faf0a5d_shell)\n*   [C#](#e22544b18fe34e3bb5e0610e9faf0a5d_csharp)\n*   [Go](#e22544b18fe34e3bb5e0610e9faf0a5d_go)\n*   [Java](#e22544b18fe34e3bb5e0610e9faf0a5d_java)\n*   [Node.JS](#e22544b18fe34e3bb5e0610e9faf0a5d_node)\n*   [Obj-C](#e22544b18fe34e3bb5e0610e9faf0a5d_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/dbconnections/signup' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\",\"email\": \"YOUR_USER_EMAIL\",\"password\": \"YOUR_USER_PASSWORD\",\"user_metadata\": {\"consentGiven\": \"true\", \"consentTimestamp\": \"1525101183\" }}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/dbconnections/signup\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"YOUR_USER_EMAIL\\\",\\\"password\\\": \\\"YOUR_USER_PASSWORD\\\",\\\"user_metadata\\\": {\\\"consentGiven\\\": \\\"true\\\", \\\"consentTimestamp\\\": \\\"1525101183\\\" }}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/dbconnections/signup\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"YOUR_USER_EMAIL\\\",\\\"password\\\": \\\"YOUR_USER_PASSWORD\\\",\\\"user_metadata\\\": {\\\"consentGiven\\\": \\\"true\\\", \\\"consentTimestamp\\\": \\\"1525101183\\\" }}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/dbconnections/signup\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"YOUR_USER_EMAIL\\\",\\\"password\\\": \\\"YOUR_USER_PASSWORD\\\",\\\"user_metadata\\\": {\\\"consentGiven\\\": \\\"true\\\", \\\"consentTimestamp\\\": \\\"1525101183\\\" }}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/dbconnections/signup',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    email: 'YOUR_USER_EMAIL',\n    password: 'YOUR_USER_PASSWORD',\n    user_metadata: {consentGiven: 'true', consentTimestamp: '1525101183'}\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"email\": @\"YOUR_USER_EMAIL\",\n                              @\"password\": @\"YOUR_USER_PASSWORD\",\n                              @\"user_metadata\": @{ @\"consentGiven\": @\"true\", @\"consentTimestamp\": @\"1525101183\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/dbconnections/signup\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/dbconnections/signup\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"YOUR_USER_EMAIL\\\",\\\"password\\\": \\\"YOUR_USER_PASSWORD\\\",\\\"user_metadata\\\": {\\\"consentGiven\\\": \\\"true\\\", \\\"consentTimestamp\\\": \\\"1525101183\\\" }}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"YOUR_USER_EMAIL\\\",\\\"password\\\": \\\"YOUR_USER_PASSWORD\\\",\\\"user_metadata\\\": {\\\"consentGiven\\\": \\\"true\\\", \\\"consentTimestamp\\\": \\\"1525101183\\\" }}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/dbconnections/signup\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/dbconnections/signup\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"YOUR_USER_EMAIL\\\",\\\"password\\\": \\\"YOUR_USER_PASSWORD\\\",\\\"user_metadata\\\": {\\\"consentGiven\\\": \\\"true\\\", \\\"consentTimestamp\\\": \\\"1525101183\\\" }}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"email\": \"YOUR_USER_EMAIL\",\n  \"password\": \"YOUR_USER_PASSWORD\",\n  \"user_metadata\": [\n    \"consentGiven\": \"true\",\n    \"consentTimestamp\": \"1525101183\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/dbconnections/signup\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nNote that we set the value of the metadata to a string with the value `true` and not to a boolean value due to the API restriction that accepts strings as values, not booleans.\n\nIf setting boolean values is a requirement for you, you can use the Management API instead. In this scenario you sign up your user as usual, and then you call the Management API [**Update User** endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) to set the required metadata after the user has been created. For details on how to do that keep reading, the next paragraph uses that endpoint.\n\nIf you use social connections, then you cannot use the Authentication API to create the user at Auth0, since that endpoint works only for database connections.\n\nWhat you have to do instead is let your user sign up with the social provider (which will create a user record at Auth0) and then use the Management API to update the user's information.\n\nBefore you call the Management API you need to get a valid token. To learn more, read [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production).\n\nThe linked article uses the Client Credentials Flow to get a token, which you cannot use from an app running on the browser. What you can use instead is the Implicit Flow. To learn more about the Client Credentials Flow, read [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow). To learn more about the Implicit Flow, read [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).\n\nSet the **audience** request parameter to `https://YOUR_DOMAIN/api/v2/` and the **scope** parameter to the scope `create:current_user_metadata`. You can use the Access Token you will get at the response to call the Management API [**Update User** endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id).\n\nOnce you have a valid token, use the following snippet to update the user's metadata.\n\n*   [cURL](#00a274bf8176488faf6298ee9641f53a_shell)\n*   [C#](#00a274bf8176488faf6298ee9641f53a_csharp)\n*   [Go](#00a274bf8176488faf6298ee9641f53a_go)\n*   [Java](#00a274bf8176488faf6298ee9641f53a_java)\n*   [Node.JS](#00a274bf8176488faf6298ee9641f53a_node)\n*   [Obj-C](#00a274bf8176488faf6298ee9641f53a_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/users/%7BUSER_ID%7D' \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\": {\"consentGiven\":true, \"consentTimestamp\": \"1525101183\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/%7BUSER_ID%7D\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\": {\\\"consentGiven\\\":true, \\\"consentTimestamp\\\": \\\"1525101183\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/%7BUSER_ID%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\": {\\\"consentGiven\\\":true, \\\"consentTimestamp\\\": \\\"1525101183\\\"}}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/users/%7BUSER_ID%7D\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\": {\\\"consentGiven\\\":true, \\\"consentTimestamp\\\": \\\"1525101183\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/users/%7BUSER_ID%7D',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN', 'content-type': 'application/json'},\n  data: {user_metadata: {consentGiven: true, consentTimestamp: '1525101183'}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"user_metadata\": @{ @\"consentGiven\": @YES, @\"consentTimestamp\": @\"1525101183\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/%7BUSER_ID%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/%7BUSER_ID%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\": {\\\"consentGiven\\\":true, \\\"consentTimestamp\\\": \\\"1525101183\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\": {\\\"consentGiven\\\":true, \\\"consentTimestamp\\\": \\\"1525101183\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer YOUR_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/users/%7BUSER_ID%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/%7BUSER_ID%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\": {\\\"consentGiven\\\":true, \\\"consentTimestamp\\\": \\\"1525101183\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer YOUR_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"user_metadata\": [\n    \"consentGiven\": true,\n    \"consentTimestamp\": \"1525101183\"\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/%7BUSER_ID%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nNote that in order to make this call you need to know the unique `user_id`. You can retrieve this from the `sub` claim of the ID Token, if you got one from the response. To learn more, read [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens). Alternatively, if all you have is the email, you can retrieve the Id by calling another endpoint of the Management API. To learn more, read [User Search Best Practices](https://auth0.com/docs/manage-users/user-search/user-search-best-practices).\n\n## Option 4: Redirect to another page\n\nIf you want to display more information to your user, then upon signup you can redirect to another page where you ask for consent and any additional info, and then redirect back to finish the authentication transaction. This can be done with redirect rules. That same rule can be used to save the consent information at the user's metadata so you can track this information and not ask for consent upon next login. To learn more, read [Redirect Users from Within Rules](https://auth0.com/docs/customize/rules/redirect-users).\n\nYou will need to host this form, and the URL for the form must be publicly-accessible. You'll need to provide the URL where the form can be accessed to Auth0 at a later step of this tutorial.\n\n1.  Add the redirect rule. Go to [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules), and click **Create Rule**. At **Rules Templates**, select **empty rule**. Change the default rule's name from `empty rule` to something descriptive (e.g., `Redirect to consent form`).\n    \n2.  Add the following JavaScript code to the script editor, and **Save** your changes.\n    \n    ```\n    exports.onExecutePostLogin = async (event, api) => {\n        const { consentGiven } = event.user.user_metadata || {};\n    \n        // redirect to consent form if user has not yet consented\n        if (!consentGiven && api.redirect.canRedirect()) {\n          const options = {\n            query: {\n              auth0_domain: `${event.tenant.id}.auth0.com`,\n            },\n          };\n          api.redirect.sendUserTo(event.secrets.CONSENT_FORM_URL, options);\n        }\n    };\n    \n    // if user clicks 'I agree' on the consent form, save it to their profile so they don't get prompted again\n    exports.onContinuePostLogin = async (event, api) => {\n      if (event.request.body.confirm === \"yes\") {\n        api.user.setUserMetadata(\"consentGiven\", true);\n        api.user.setUserMetadata(\"consentTimestamp\", Date.now());\n        return;\n      } else {\n        return api.access.deny(\"User did not consent\");\n      }\n    };\n    ```\n    \n3.  Return to [Auth0 Dashboard > Auth0 Pipeline > Rules](https://manage.auth0.com/#/rules) and scroll down to the bottom of the page where the **Settings** section is. Create a key/value pair as follows:\n    \n    1.  **Key**: `CONSENT_FORM_URL`\n        \n    2.  **Value**: `your-consent-form-url.com`\n        \n\nBe sure to provide the publicly-accessible URL where your consent form can be found.\n\nWhen setting up redirection to your consent form for use in a Production environment, be sure to review [Trusted Callback URLs](https://github.com/auth0/rules/tree/master/redirect-rules/simple#trusted-callback-urls) and [Data Integrity](https://github.com/auth0/rules/tree/master/redirect-rules/simple#data-integrity) regarding security concerns.\n\nIf you require a specialized consent prompt, for example a parental consent, you need to build your own custom consent form. Be aware that laws vary according to country.\n\nWe are done with the configuration part, let's test!\n\n## Test the configuration\n\n1.  Run the application and go to `https://localhost:3000`.\n    \n2.  Sign up with a new user. You will be redirected to the consent form.\n    \n3.  Check the **I agree** flag, and click **Submit**.\n    \n4.  Go to [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users), and search for your new user.\n    \n5.  Go to **User Details**, and scroll down to the **Metadata** section.\n    \n6.  At the **user\\_metadata** text area, you should see the `consentGiven` metadata set to `true` and the `consentTimestamp` set to the Unix timestamp of the moment the user consented.\n    \n    ![Application Sign Up Widget Lock Consent Form Agree](https://images.ctfassets.net/cdy7uua7fh8z/dk2NIuhs47m3eU28cgEkI/0d73b6c33d438da1e82454da17ce8e6a/lock-consent-form-agree.png)\n\nThat's it, you are done!",
  "title": "GDPR: Track Consent with Custom UI",
  "description": "Describes how you can use either auth0.js or the Auth0 APIs to capture consent information when you use your own custom UI for logins.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-portability",
  "markdown": "# GDPR: Data Portability\n\nAccording to Article 20 of GDPR, users have the right to receive the personal data concerning them in a structured, commonly used and machine-readable format.\n\nYou can export user data, stored in the Auth0 user store, either manually or programmatically. Raw data from Auth0 can be exported in JSON format (which is machine-readable).\n\n## Export data manually\n\n1.  Go to [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n    \n2.  Search for the user and drill down on their name.\n    \n3.  Click the **Raw JSON** tab. Here you can see the complete user profile in JSON format.\n    \n4.  Click **Copy JSON**. The profile is copied to your clipboard.\n    \n5.  Paste the clipboard contents to an editor and save.\n    \n\n## Export data using the API\n\nYou can export a user's full profile using our Management API. The response will be in JSON format. You can either search for a user using their ID, or export a list of your users.\n\n## Learn more\n\n*   [GDPR: Conditions for Consent](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-conditions-for-consent)\n*   [GDPR: Data Minimization](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-minimization)\n*   [GDPR: Protect and Secure User Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-protect-and-secure-user-data)\n*   [GDPR: Right to Access, Correct, and Erase Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-right-to-access-correct-and-erase-data)",
  "title": "GDPR: Data Portability",
  "description": "Describes how you can export user data in order to comply with data portability GDPR requirements.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-protect-and-secure-user-data",
  "markdown": "# GDPR: Protect and Secure User Data\n\nAs per article 32 of GDPR, you must implement appropriate security measures in order to ensure a level of security appropriate to the risk, including (but not limited to):\n\n*   Τhe encryption of personal data\n    \n*   Τhe ability to ensure the ongoing confidentiality, integrity, availability, and resilience of processing systems and services\n    \n*   Τhe ability to restore the availability and access to personal data in a timely manner in the event of a physical or technical incident\n    \n\nThere are several Auth0 features that can help you achieve that, like user profile encryption, brute-force protection, breached password detection, step-up authentication, and more.\n\n## Encrypt user profile information\n\nYou can encrypt user information before you save it in the user profile. You can use any encryption mechanism you like prior to storing data in the metadata fields. When a user sets sensitive information, call the Update a User endpoint.\n\n## Enable brute-force protection\n\nAuth0's brute-force protection shield is enabled by default to stop malicious attempts to access your application.\n\nThere are two types of triggers for this shield:\n\n*   10 consecutive failed login attempts for the same user and from the same IP address\n    \n*   100 failed login attempts from the same IP address in 24 hours or 50 sign up attempts per minute from the same IP address\n    \n\nFor example, if a user with **user\\_id1** signs in from **IP1** and fails to login consecutively for 10 attempts, their log in attempt from this **IP1** will be blocked. Another user, **user\\_id2**, signing in from **IP1** will not be blocked.\n\nEvery time Auth0 detects 10 failed login attempts into a single account from the same IP, we will:\n\n*   Send a notification email to the user.\n    \n*   Block the suspicious IP address for that user.\n    \n\nEvery time Auth0 detects 100 failed login attempts in 24 hours or 50 sign up attempts from the same IP address, we will:\n\n*   Notify dashboard administrator(s).\n    \n*   Block suspicious addresses for 15 minutes.\n    \n\nYou can enable brute-force protection, configure which actions you want to take, and customize the blocked account email using the Dashboard.\n\n## Enable breached password detection\n\nThe breached password detection shield helps you identity user credentials that might have been compromised in a public data breach.\n\nAuth0 tracks large security breaches that are happening on major third-party sites. If one of your users' credentials were included in a public security breach, you can take action and:\n\n*   Send an email to the affected user\n    \n*   Send an email to dashboard owners immediately, and/or have a daily/weekly/monthly summary\n    \n*   Block login attempts for suspected user accounts using that username and password combination. This block remains in place until the user changes their password\n    \n\nYou can enable breached password detection and configure which actions you want to take using the Dashboard.\n\n## Harden your security with multi-factor authentication\n\nWith multi-factor authentication (MFA), you can add an additional layer of security to your applications. It is a method of verifying a user's identity by asking them to present more than one piece of identifying information.\n\nWe support MFA using push notifications, SMS, one-time password authentication services, and custom providers. You can enable MFA for specific users or specific actions (for example, access screens with sensitive data). You can also define the conditions that will trigger additional authentication challenges, such as changes in geographic location or logins from unrecognized devices.\n\n## Help your users choose better passwords\n\nYou can customize the level of password complexity for new sign ups. For example, you can ask for a password that has at least 10 characters and includes at least one uppercase letter, a number, and a special character.\n\nYou can also forbid the use of previous passwords using our Password History feature and stop users from choosing common passwords using our Password Dictionary. All three features are configurable from the Dashboard.\n\n## Step-up authentication\n\nWith step-up authentication, applications can ask users to authenticate with a stronger authentication mechanism to access sensitive resources. For example, you may have a banking application that does not require Multi-factor Authentication (MFA) to view the account's basic information, but when users try to transfer money between accounts then they must authenticate with one more factor (for example, a code sent via SMS).\n\nYou can check if a user has logged in with MFA by reviewing the contents of their ID Token or Access Token. You can then configure your application to deny access to sensitive resources if the token indicates that the user did not log in with MFA.\n\n## Availability and resilience\n\nAuth0 is designed and built as a scalable, highly available, multi-tenant cloud service. We are highly resilient to the failure of any of our components because we implement redundant components at all levels. We also detect failures rapidly and our failover is very quick.\n\nTo learn more information on Auth0 architecture, read [Availability & Trust](https://auth0.com/availability-trust).\n\n## Learn more\n\n*   [GDPR: Conditions for Consent](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-conditions-for-consent)\n*   [GDPR: Data Minimization](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-minimization)\n*   [GDPR: Data Portability](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-portability)\n*   [GDPR: Right to Access, Correct, and Erase Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-right-to-access-correct-and-erase-data)",
  "title": "GDPR: Protect and Secure User Data",
  "description": "Describes how you can use Auth0 features to protect and secure user's personal data.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/set-root-attributes-during-user-import",
  "markdown": "# Set Root Attributes During User Import\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/jobs/usersimports' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: multipart/form-data ' \\\n  --data '{ \"connection_id\": \"CONNECTION_ID\", \"users\": \"JSON_USER_FILE_PATH\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/usersimports\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"multipart/form-data \");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"multipart/form-data \", \"{ \\\"connection_id\\\": \\\"CONNECTION_ID\\\", \\\"users\\\": \\\"JSON_USER_FILE_PATH\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/usersimports\"\n\n\tpayload := strings.NewReader(\"{ \\\"connection_id\\\": \\\"CONNECTION_ID\\\", \\\"users\\\": \\\"JSON_USER_FILE_PATH\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"multipart/form-data \")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/jobs/usersimports\")\n  .header(\"content-type\", \"multipart/form-data \")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"connection_id\\\": \\\"CONNECTION_ID\\\", \\\"users\\\": \\\"JSON_USER_FILE_PATH\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/jobs/usersimports',\n  headers: {\n    'content-type': 'multipart/form-data ',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'\n  },\n  data: '{ \"connection_id\": \"CONNECTION_ID\", \"users\": \"JSON_USER_FILE_PATH\" }'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"multipart/form-data \",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ \"connection_id\": \"CONNECTION_ID\", \"users\": \"JSON_USER_FILE_PATH\" }\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/usersimports\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/usersimports\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"connection_id\\\": \\\"CONNECTION_ID\\\", \\\"users\\\": \\\"JSON_USER_FILE_PATH\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: multipart/form-data \"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"connection_id\\\": \\\"CONNECTION_ID\\\", \\\"users\\\": \\\"JSON_USER_FILE_PATH\\\" }\"\n\nheaders = {\n    'content-type': \"multipart/form-data \",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/jobs/usersimports\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/usersimports\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'multipart/form-data '\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"connection_id\\\": \\\"CONNECTION_ID\\\", \\\"users\\\": \\\"JSON_USER_FILE_PATH\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"multipart/form-data \",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"\n]\n\nlet postData = NSData(data: \"{ \"connection_id\": \"CONNECTION_ID\", \"users\": \"JSON_USER_FILE_PATH\" }\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/usersimports\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Set Root Attributes During User Import",
  "description": "Learn how to set root attributes for users during import using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-conditions-for-consent",
  "markdown": "# GDPR: Conditions for Consent\n\nAccording to Article 7 of GDPR, you must ask users to consent on the processing of their personal data in a clear and easily accessible form. You must also show that the user has consented, and provide an easy way to withdraw consent at any time.\n\nThis article explains how you can use Auth0 features to implement these requirements.\n\n## Ask for consent\n\nUpon signup you have to ask your users for consent. With Auth0, you can save this information with the user metadata. There are several available options depending on how you use Auth0 to authenticate your users. Before you design your solution using metadata make sure you are aware of the restrictions. Auth0 limits the total size of the `user_metadata` to **16 MB**. To learn more, read [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data).\n\n### Use Lock\n\nYou can customize the Lock UI to display links to your terms and conditions and/or privacy statement pages, and a consent checkbox that the user has to check in order to sign up. This can be done with the `mustAcceptTerm`s Lock option. This property, when set to `true`, displays a checkbox alongside the terms and conditions that must be checked before signing up. The terms and conditions can be specified using the languageDictionary option. To learn more, read [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration).\n\nOnce the user accepts and signs up, save the consent information at the `user_metadata` using a rule that will run upon first login. To learn more about rules, read [Auth0 Rules](https://auth0.com/docs/customize/rules).\n\nIf you want to get more information from the users during signup, and you authenticate users with a database connection, you can add custom fields to the Lock UI. This can be done with the additionalSignUpFields Lock option. Any custom fields are automatically added to the `user_metadata`.\n\nIf you are using social logins, adding custom fields is not an option, but you can redirect the user to another page where you ask for consent and any additional info, and then redirect back to finish the authentication transaction. This can be done with redirect rules. To learn more, read [Redirect Users from Within Rules](https://auth0.com/docs/customize/rules/redirect-users). Once the signup process is complete, save the consent information at the `user_metadata` by calling the Management API [**Update User** endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id).\n\nTo learn how to implement any of these scenarios, read [GDPR: Track Consent with Lock](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-lock).\n\n### Use custom UI\n\nIf you use a custom signup form with a database connection, you have to add an extra field to the signup screen in order to capture the user's consent. Afterward, call the Authentication API [**Signup** endpoint](https://auth0.com/docs/api/authentication#signup) in order to create the user in Auth0. At this point, you can set the consent information as part of the `user_metadata`.\n\nAlternatively, if you use Auth0.js from a SPA, you can [use the `signup` method](https://auth0.com/docs/libraries/auth0js) to create the user in Auth0 and set the consent info as part of the `user_metadata`.\n\nIf you use a custom signup form with social providers, you cannot set the user's consent information upon signup but you can update it as soon as the user is created. Save the consent information at the `user_metadata` by calling the Management API [**Update User** endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id).\n\nTo learn how to implement any of these scenarios, read [GDPR: Track Consent with Custom UI](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-custom-ui).\n\n### Re-consent and user migration\n\nIf you need to ask for consent from existing users and you decide to migrate your users from an existing database to Auth0, you can [use our Automatic User Migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) feature. By activating this, each time a user logs in for the first time (since this was activated), they will be created in Auth0 without having to reset their password. To do this you must:\n\n*   Write up the notification users will see around how users' data is being used, how long data will be used, users' rights, etc. as well as customize the UI sign-up box.\n    \n*   Determine if re-consent is required for your users, depending on your old terms and conditions and previous privacy certifications.\n    \n\nNote that every time your Terms and Conditions change, you **must** ask the users for consent again.\n\n## Track consent\n\nAccording to GDPR, you should be able to show that the user has consented to the processing of their personal data.\n\nWith Auth0 you can save the user's consent information as part of the `user_metadata`. You can either save only a flag, showing if the user has consented or not, or a set of consent information and preferences (including, for example, the day the user provided consent, the terms he consented to, etc). Afterward, you can access and manipulate this information using our Management API.\n\nThe Management API also offers several options when it comes to user search and endpoints to update user metadata or batch export users.\n\nTo access the Management API you will need an access token. To learn how to get an access token for the Management API, read [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n\n### Search for users by email address\n\nTo search for a user using their email address, use the [**Search User by Email** endpoint](https://auth0.com/docs/manage-users/user-search/user-search-best-practices).\n\nSet the **fields** request parameter to `user_metadata` in order to limit the fields returned. This way, only the user\\_metadata will be returned instead of the complete user profile.\n\nSample request:\n\n*   [cURL](#80aa66e859b641c69759383ae64039a5_shell)\n*   [C#](#80aa66e859b641c69759383ae64039a5_csharp)\n*   [Go](#80aa66e859b641c69759383ae64039a5_go)\n*   [Java](#80aa66e859b641c69759383ae64039a5_java)\n*   [Node.JS](#80aa66e859b641c69759383ae64039a5_node)\n*   [Obj-C](#80aa66e859b641c69759383ae64039a5_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata' \\\n  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata\")\n  .header(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users-by-email',\n  params: {email: 'USER_EMAIL_ADDRESS', fields: 'user_metadata'},\n  headers: {authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users-by-email?email=USER_EMAIL_ADDRESS&fields=user_metadata\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nSample response:\n\n```\n[\n  {},\n  {\n    \"user_metadata\": {\n      \"consent\": {\n\t    \"given\": true,\n\t    \"date\": \"01/23/2018\",\n\t    \"text_details\": \"some-url\"\n\t  }\n    }\n  }\n]\n```\n\n### Search for users by ID\n\nTo search for a user using their ID, use the [**Get a User** endpoint](https://auth0.com/docs/manage-users/user-search/user-search-best-practices).\n\nSet the **fields** request parameter to `user_metadata` in order to limit the fields returned. This way, only the `user_metadata` will be returned instead of the complete user profile.\n\nSample request:\n\n*   [cURL](#7daf397b39214e7fb5c8999174d7c20b_shell)\n*   [C#](#7daf397b39214e7fb5c8999174d7c20b_csharp)\n*   [Go](#7daf397b39214e7fb5c8999174d7c20b_go)\n*   [Java](#7daf397b39214e7fb5c8999174d7c20b_java)\n*   [Node.JS](#7daf397b39214e7fb5c8999174d7c20b_node)\n*   [Obj-C](#7daf397b39214e7fb5c8999174d7c20b_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users/%7ByourUserID%7D',\n  params: {fields: 'user_metadata'},\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/%7ByourUserID%7D?fields=user_metadata\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nSample response:\n\n```\n{\n  \"user_metadata\": {\n    \"consent\": {\n\t    \"given\": true,\n\t    \"date\": \"01/23/2018\",\n\t    \"text_details\": \"some-url\"\n  \t}\n  }\n}\n```\n\n### Update consent information\n\nTo update a user's `user_metadata`, use the [**Update a User** endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id).\n\nHow you structure your request depends on how you have structured your metadata: as root or as inner properties.\n\nIf your metadata are stored as root properties:\n\n```\n{\n  \"consentGiven\": true,\n  \"consentDetails\": \"some-url\"\n}\n```\n\nIf your metadata are stored as inner properties:\n\n```\n{\n  \"consent\": {\n    \"given\": true,\n    \"text_details\": \"some-url\"\n  }\n}\n```\n\n#### Update root property\n\nUpdates to root-level properties are merged, so you only need to send the value for the field you want to update. For example, let's say we want to add a consent date and set it to `01/23/2018`.\n\n*   [cURL](#0f4f8a79939e45b49cf99296d87b2848_shell)\n*   [C#](#0f4f8a79939e45b49cf99296d87b2848_csharp)\n*   [Go](#0f4f8a79939e45b49cf99296d87b2848_go)\n*   [Java](#0f4f8a79939e45b49cf99296d87b2848_java)\n*   [Node.JS](#0f4f8a79939e45b49cf99296d87b2848_node)\n*   [Obj-C](#0f4f8a79939e45b49cf99296d87b2848_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID' \\\n  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\":{\"consentDate\":\"01/24/2018\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\":{\\\"consentDate\\\":\\\"01/24/2018\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\":{\\\"consentDate\\\":\\\"01/24/2018\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/USER_ID\")\n  .header(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\":{\\\"consentDate\\\":\\\"01/24/2018\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID',\n  headers: {\n    authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {user_metadata: {consentDate: '01/24/2018'}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"user_metadata\": @{ @\"consentDate\": @\"01/24/2018\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\":{\\\"consentDate\\\":\\\"01/24/2018\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\":{\\\"consentDate\\\":\\\"01/24/2018\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/USER_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\":{\\\"consentDate\\\":\\\"01/24/2018\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"user_metadata\": [\"consentDate\": \"01/24/2018\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis will add a new property to the user profile, the **user\\_metadata.consentDate**, which will hold the date the customer consented. The response will be the full user profile. The updated metadata will look like this:\n\n```\n{\n  \"consentGiven\": true,\n  \"consentDate\": \"01/23/2018\",\n  \"consentDetails\": \"some-url\"\n}\n```\n\n#### Update inner property\n\nTo update an inner property, you must send the whole metadata object, even if you are not updating more than one property. If you do not include the entire object, Auth0 will remove your existing properties.\n\nLet's add an inner property for the consent date and set it to `01/23/2018`.\n\n*   [cURL](#276d731874234d919edce6596c41e34c_shell)\n*   [C#](#276d731874234d919edce6596c41e34c_csharp)\n*   [Go](#276d731874234d919edce6596c41e34c_go)\n*   [Java](#276d731874234d919edce6596c41e34c_java)\n*   [Node.JS](#276d731874234d919edce6596c41e34c_node)\n*   [Obj-C](#276d731874234d919edce6596c41e34c_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID' \\\n  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\":{\"consent\": {\"given\":true, \"date\":\"01/23/2018\", \"text_details\":\"some-url\"}}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\":{\\\"consent\\\": {\\\"given\\\":true, \\\"date\\\":\\\"01/23/2018\\\", \\\"text_details\\\":\\\"some-url\\\"}}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\":{\\\"consent\\\": {\\\"given\\\":true, \\\"date\\\":\\\"01/23/2018\\\", \\\"text_details\\\":\\\"some-url\\\"}}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/USER_ID\")\n  .header(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\":{\\\"consent\\\": {\\\"given\\\":true, \\\"date\\\":\\\"01/23/2018\\\", \\\"text_details\\\":\\\"some-url\\\"}}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID',\n  headers: {\n    authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {\n    user_metadata: {consent: {given: true, date: '01/23/2018', text_details: 'some-url'}}\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"user_metadata\": @{ @\"consent\": @{ @\"given\": @YES, @\"date\": @\"01/23/2018\", @\"text_details\": @\"some-url\" } } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\":{\\\"consent\\\": {\\\"given\\\":true, \\\"date\\\":\\\"01/23/2018\\\", \\\"text_details\\\":\\\"some-url\\\"}}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\":{\\\"consent\\\": {\\\"given\\\":true, \\\"date\\\":\\\"01/23/2018\\\", \\\"text_details\\\":\\\"some-url\\\"}}}\"\n\nheaders = {\n    'authorization': \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/USER_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\":{\\\"consent\\\": {\\\"given\\\":true, \\\"date\\\":\\\"01/23/2018\\\", \\\"text_details\\\":\\\"some-url\\\"}}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"user_metadata\": [\"consent\": [\n      \"given\": true,\n      \"date\": \"01/23/2018\",\n      \"text_details\": \"some-url\"\n    ]]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis will add a new property to the user profile, the **user\\_metadata.consent.date,** which will hold the date the customer consented. The response will be the full user profile. The updated metadata will look like this:\n\n```\n{\n  \"consent\": {\n    \"given\": true,\n    \"date\": \"01/23/2018\",\n    \"text_details\": \"some-url\"\n  }\n}\n```\n\n### Export consent information\n\nTo export a list of your users using the Management API, use the [**User Export** endpoint](https://auth0.com/docs/manage-users/user-search/user-search-best-practices).\n\nThis endpoint creates a job that exports all users associated with a connection. You will need the ID of the connection. To find this ID, use the [**Get Connections** endpoint](https://auth0.com/docs/api/management/v2#!/Connections/get_connections) (you can set the **name** parameter to the name of the connection to retrieve only this one).\n\nOnce you have the connection ID and an access token for the Management API, you are ready to start exporting users. To see a sample request and response, read [Import and Export Users](https://auth0.com/docs/manage-users/user-migration). To learn how to get an access token for the Management API, read [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n\nYou also must:\n\n*   Determine how you want to track consent. We recommend including information on not just the date the user consented, but the version of terms and conditions to which the user agreed. We also recommend including an array to hold information about users that withdraw their permission (remember that the user can consent and withdraw multiple times).\n    \n*   Choose where you want to store consent: in Auth0's database or elsewhere.\n    \n\n## Withdraw consent\n\nThe user should have the option to withdraw consent using your app. This option should be easily accessible, and clearly distinguishable. Once the user decides to withdraw their consent, you should take action.\n\nFirst, you have to decide how you will handle the withdrawal of consent: will you delete the users or flag them as deleted?\n\n### Delete user\n\nTo delete a user, use the [**Delete a User** endpoint](https://auth0.com/docs/api/management/v2#!/Users/delete_users_by_id).\n\n*   [cURL](#eacaf70a052743ac9a8b3b39b7571144_shell)\n*   [C#](#eacaf70a052743ac9a8b3b39b7571144_csharp)\n*   [Go](#eacaf70a052743ac9a8b3b39b7571144_go)\n*   [Java](#eacaf70a052743ac9a8b3b39b7571144_java)\n*   [Node.JS](#eacaf70a052743ac9a8b3b39b7571144_node)\n*   [Obj-C](#eacaf70a052743ac9a8b3b39b7571144_objc)\n*   [...](#)\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID' \\\n  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/users/USER_ID\")\n  .header(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID',\n  headers: {authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/users/USER_ID\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe response body for this endpoint is empty, so if you want to confirm that the user was successfully deleted try to retrieve the user using their email. If the endpoint returns an error, then your call to delete the user was successful.\n\n### Flag user as deleted\n\nIf you don't want to delete the user, flag their profile as deleted using the [**app\\_metadata** endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id). Then, add some code that will make the authentication process to fail for any user with their profile flagged as such.\n\nThis allows you to keep a record of deleted users for future use.\n\n#### Flag the profile\n\nTo flag a user as deleted, use the app\\_metadata. In the following example, we will show you how to add a property called **deleted** to the **app\\_metadata** field. This allows you to configure the authentication process to treat all uses with this property set to true as deleted.\n\nTo update a user's metadata, use the [**Update a User** endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id).\n\n*   [cURL](#e5ffb244cd294be5b7e1164b3ae2cab0_shell)\n*   [C#](#e5ffb244cd294be5b7e1164b3ae2cab0_csharp)\n*   [Go](#e5ffb244cd294be5b7e1164b3ae2cab0_go)\n*   [Java](#e5ffb244cd294be5b7e1164b3ae2cab0_java)\n*   [Node.JS](#e5ffb244cd294be5b7e1164b3ae2cab0_node)\n*   [Obj-C](#e5ffb244cd294be5b7e1164b3ae2cab0_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID' \\\n  --header 'authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"app_metadata\":{\"deleted\":true}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"app_metadata\\\":{\\\"deleted\\\":true}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID\"\n\n\tpayload := strings.NewReader(\"{\\\"app_metadata\\\":{\\\"deleted\\\":true}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/USER_ID\")\n  .header(\"authorization\", \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"app_metadata\\\":{\\\"deleted\\\":true}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID',\n  headers: {\n    authorization: 'Bearer YOUR_MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {app_metadata: {deleted: true}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"app_metadata\": @{ @\"deleted\": @YES } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"app_metadata\\\":{\\\"deleted\\\":true}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"app_metadata\\\":{\\\"deleted\\\":true}}\"\n\nheaders = {\n    'authorization': \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/USER_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"app_metadata\\\":{\\\"deleted\\\":true}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer YOUR_MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"app_metadata\": [\"deleted\": true]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Disable login for flagged users\n\nNext, you must disable login for users flagged as deleted. To do so, you will add a rule (a JavaScript snippet that runs as part of the authentication pipeline).\n\n1.  Go to [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules) and create a rule.\n    \n2.  Copy the script below:\n    \n    ```\n    function (user, context, callback) {\n      user.app_metadata = user.app_metadata || {};\n      if (user.app_metadata.deleted){\n      \treturn callback(new UnauthorizedError('Access denied (deleted user)'));\n      }\n      callback(null, user, context);\n    }\n    ```\n    \n    The script does the following:\n    1.  Checks the value of the **deleted** metadata property (`user.app_metadata.deleted`).\n        \n    2.  Returns an `Access denied (deleted user)` error to your app if `user.app_metadata.deleted = true`\n        \n3.  Give a name to your rule and save your changes.\n    \n\nYou also must:\n\n*   Ensure the consent withdrawal piece is granular enough.\n    \n*   Configure into the app, the area where customers will withdraw consent.\n    \n\n## Learn more\n\n*   [GDPR: Data Minimization](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-minimization)\n*   [GDPR: Data Portability](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-portability)\n*   [GDPR: Protect and Secure User Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-protect-and-secure-user-data)\n*   [GDPR: Right to Access, Correct, and Erase Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-right-to-access-correct-and-erase-data)",
  "title": "GDPR: Conditions for Consent",
  "description": "Describes which Auth0 features can help you comply with the Conditions for Consent GDPR requirements.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/set-root-attributes-during-user-sign-up",
  "markdown": "# Set Root Attributes During User Signup\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/users' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"connection\": CONNECTION_NAME, \"email\": EMAIL_VALUE, \"password\": PASSWORD_VALUE, \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"connection\\\": CONNECTION_NAME, \\\"email\\\": EMAIL_VALUE, \\\"password\\\": PASSWORD_VALUE, \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users\"\n\n\tpayload := strings.NewReader(\"{ \\\"connection\\\": CONNECTION_NAME, \\\"email\\\": EMAIL_VALUE, \\\"password\\\": PASSWORD_VALUE, \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/users\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"connection\\\": CONNECTION_NAME, \\\"email\\\": EMAIL_VALUE, \\\"password\\\": PASSWORD_VALUE, \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/users',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: '{ \"connection\": CONNECTION_NAME, \"email\": EMAIL_VALUE, \"password\": PASSWORD_VALUE, \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ \"connection\": CONNECTION_NAME, \"email\": EMAIL_VALUE, \"password\": PASSWORD_VALUE, \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"connection\\\": CONNECTION_NAME, \\\"email\\\": EMAIL_VALUE, \\\"password\\\": PASSWORD_VALUE, \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"connection\\\": CONNECTION_NAME, \\\"email\\\": EMAIL_VALUE, \\\"password\\\": PASSWORD_VALUE, \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/users\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"connection\\\": CONNECTION_NAME, \\\"email\\\": EMAIL_VALUE, \\\"password\\\": PASSWORD_VALUE, \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\n\nlet postData = NSData(data: \"{ \"connection\": CONNECTION_NAME, \"email\": EMAIL_VALUE, \"password\": PASSWORD_VALUE, \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Set Root Attributes During User Signup",
  "description": "Learn how to set root attributes for users during signup using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tokens/guides/locate-jwks",
  "markdown": "# Locate JSON Web Key Sets\n\nUse this Discovery endpoint to configure your application or API to automatically locate the [JSON Web Key Set (JWKS)](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets) endpoint (`jwks_uri`), which contains the JWKS used to sign all Auth0-issued JSON Web Tokens (JWTs) signed with the RS256 signing algorithm. The endpoint exists at:\n\n`https://{yourDomain}/.well-known/openid-configuration`.\n\nWhen [validating a JWT](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens) using a JWKS, you will need to:\n\n1.  Retrieve the JWKS from the Auth0 Discovery endpoint, and filter for potential signing keys (e.g., any keys missing a public key or with a `kid` property).\n    \n2.  Grab the `kid` property from the Header of the decoded JWT.\n    \n3.  Search your filtered JWKS for the key with the matching `kid` property.\n    \n4.  Build a certificate using the corresponding `x5c` property in your JWKS.\n    \n5.  Use the certificate to verify the JWT's signature.\n    \n\nFor an example that uses JWKS to verify a JWT's signature, see [Navigating RS256 and JWKS](https://auth0.com/blog/navigating-rs256-and-jwks/) (uses Node.js), or check out our [Backend/API Quickstarts](https://auth0.com/docs/quickstart/backend).\n\nFor more info about the structure of a JWT, see [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure).\n\nIt's good practice to assume that multiple signing keys could be present in your JWKS. This may seem unnecessary since the Auth0 JWKS endpoint typically contains a single signing key; however, multiple keys can be found in the JWKS when rotating signing certificates.\n\nWe recommend that you cache your signing keys to improve application performance and avoid running into [rate limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy), but you will want to make sure that if decoding a token fails, you invalidate the cache and retrieve new signing keys before trying **only one** more time.\n\n## Learn more\n\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [JSON Web Key Set Properties](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties)\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure)\n*   [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Locate JSON Web Key Sets",
  "description": "Describes how to use the JSON Web Keys (JWKs) discovered using the JSON Web Key Set (JWKS) endpoint to verify a JWT signature.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/use-dynamic-variables-to-internationalize-custom-form-elements",
  "markdown": "# Use Dynamic Variables to Internationalize Custom Form Elements\n\nYou can render [Sign-Up Prompt Customizations](https://auth0.com/docs/customize/login-pages/universal-login/customize-signup-and-login-prompts) differently depending on contextual data. It uses the `locale` variable to conditionally render form inputs and define validation behavior.\n\nThe following use case works with the `locale` variable to render a Terms of Service message and checkbox. Any variable exposed to [Page Templates](https://auth0.com/docs/customize/universal-login-pages/universal-login-page-templates#available-variables) can be substituted.\n\n### Prerequisites\n\n*   Tenant has a verified [Custom Domain](https://auth0.com/docs/customize/custom-domains)\n    \n*   Tenant has a Page Template set\n    \n\n### Enable fr and es locales\n\nGo to your Auth0 Dashboard, then navigate to Settings > General and enable the locales:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/4yCGYTZ3RDyeULWIFcyHSv/739c4939dca83f5553d93bc8dc4842e9/2024-01-31_16-15-07.png)\n\n### Conditionally render Custom Fields\n\nUse Management API to add a template partial to the `form-content-end` signup prompt Universal Login Prompt container. In the case where the locale is `es` or `fr`, you may want to render a Terms of Service message and a checkbox.\n\n```\n{% if locale == 'fr' %}\n  <div class=\"ulp-field\">\n    <input\n      type=\"checkbox\"\n      name=\"ulp-terms-of-service\"\n      id=\"terms-of-service\">\n    <label for=\"terms-of-service\">\n      J'accepte les\n      <a href=\"https://fr.example.com/tos\">termes et conditions</a>\n    </label>\n  </div>\n{% endif %}\n{% if locale == 'es' %}\n  <div class=\"ulp-field\">\n    <input\n      type=\"checkbox\"\n      name=\"ulp-terms-of-service\"\n      id=\"terms-of-service\">\n    <label for=\"terms-of-service\">\n      Estoy de acuerdo con los\n      <a href=\"https://es.example.com/tos\">términos y condiciones</a>\n    </label>\n  </div>\n{% endif %}\n```\n\nThe following request is sent to the **Set custom text for a specific prompt** endpoint in the [Management API](https://auth0.com/docs/api/management/v2/prompts/put-custom-text-by-language):\n\n```\n// PUT prompts/signup/partials\n\n{\n  \"signup\": {\n    \"form-content-end\": \"{% if locale...\"\n  }\n}\n```\n\nYour signup prompt now displays a ToS message and checkbox only when the locale is set to `fr` or `es`:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3zBadIHnkl9bIWP9BH1lLj/b2a6d9932be3bbb150b4dbbf76bc6599/2024-01-31_16-17-04.png)![](https://images.ctfassets.net/cdy7uua7fh8z/3rwVd1h1Av7QzOEEWoCHhF/519a2eb5ac99c3801861c3372b81c0b9/2024-01-31_16-17-16.png)![](https://images.ctfassets.net/cdy7uua7fh8z/2qYzAI6QVBLmqCW2FTAiGj/f19c59d79c67c63782b70995dbd223c3/2024-01-31_16-17-24.png)\n\nTo test your output, go to **Manage Dashboard** and navigate to [Branding > Universal Login > Customization Options](https://manage.auth0.com/dashboard/us/dev-6endizjt/universal-login/customizations/colors), then right-click the **Try button** and copy the link address. Append the following query parameters to the copied url and navigate to the new url: `&screen_hint=signup&ui_locales=fr` (or `es`).\n\n### Add validation\n\nWhen the locale is `fr,` you can validate that the checkbox is checked before continuing. Update the template partial using the following validation code:\n\n```\n{% if locale == 'fr' %}\n  <div class=\"ulp-field\">\n    <input\n      type=\"checkbox\"\n      name=\"ulp-terms-of-service\"\n      id=\"terms-of-service\">\n    <label for=\"terms-of-service\">\n      J'accepte les\n      <a href=\"https://fr.example.com/tos\">termes et conditions</a>\n    </label>\n\n    <!-- NEW -->\n    <div\n      class=\"ulp-error-info\"\n      data-ulp-validation-function=\"requiredFunction\"\n      data-ulp-validation-event-listeners=\"change\">\n      Vous devez accepter les termes et conditions pour continuer\n    </div>\n    <!-- END NEW -->\n  </div>\n{% endif %}\n{% if locale == 'es' %}\n  <div class=\"ulp-field\">\n    <input\n      type=\"checkbox\"\n      name=\"ulp-terms-of-service\"\n      id=\"terms-of-service\">\n    <label for=\"terms-of-service\">\n      Estoy de acuerdo con los\n      <a href=\"https://es.example.com/tos\">términos y condiciones</a>\n    </label>\n  </div>\n{% endif %}\n\n<!-- NEW -->\n<script>\n  function requiredFunction(element, formSubmitted) {\n    if (! formSubmitted) {\n      return true;\n    }\n    return element.checked;\n  }\n</script>\n<!-- END NEW -->\n```\n\nWith this validation in place, only users with the `fr` locale are required to consent to the ToS.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7jBPuIe62PDNiIPUYzVVix/74de519659de4a8b4329165e799b1815/2024-01-31_16-20-54.png)",
  "title": "Use Dynamic Variables to Internationalize Custom Form Elements",
  "description": "Learn how dynamic variables can create multi-language login prompts.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/prompts/put-custom-text-by-language",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/prompts/put-partials",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/prompts/get-custom-text-by-language",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/validate-and-store-user-data-with-actions",
  "markdown": "# Use Actions to Validate and Store End-user Data Gathered By Signup Prompt Customizations\n\nYou can use [Signup Prompt Customization](https://auth0.com/docs/customize/login-pages/universal-login/customize-signup-and-login-prompts) along with the `pre-user-registration` trigger to add end-user supplied data (like a user's phone number or location) from the signup prompt to `user_metadata`. Optionally, you can validate this data and show a validation error in the prompt.\n\n### Prerequisites\n\n*   Tenant has a [Custom Domain](https://auth0.com/docs/customize/custom-domains) verified\n    \n*   Tenant has a [Page Template](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates) set\n    \n\n### Add A Field To The Signup Prompt\n\nUse the [Management API](https://auth0.com/docs/api/management/v2/prompts/put-custom-text-by-language) to insert a custom field into a prompt using one of the [Entry Points](https://auth0.com/docs/sign-up-prompt-customizations#-signup-prompt-entry-points). This example adds the following content to the `ulp-container-form-content-start` insertion point:\n\n```\n<div class=\"ulp-field\">\n  <label for=\"first-name\">First Name</label>\n  <input type=\"text\" name=\"ulp-first-name\" id=\"first-name\">\n</div>\n```\n\nThe result is a First Name section in the signup prompt:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/580LNGMxSkRlazJEdcVNpn/5fa98d4b414ac2133d1d6f4e327cea5a/Screenshot_2023-10-05_at_4.07.38_PM.png)\n\n### Create An Action In The Pre-User Registration Trigger\n\nYou can build a custom pre-user registration action by going to [**Actions > Library > Build Custom**](https://manage.auth0.com/dashboard/us/dev-6endizjt/actions/library)**.**\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/52VSznphe2TyoJQnAn4nQg/10a93faf1d5aa2bbf30a785fd032c128/2024-01-31_16-07-50.png)\n\nInside the code editor, update the `onExecutePreUserRegistration` handler:\n\n```\nexports.onExecutePreUserRegistration = async (event, api) => {\n  const firstName = event.request.body['ulp-first-name'];\n  api.user.setUserMetadata(\"firstName\", firstName);\n};\n```\n\nOptionally, you can validate the user input and send a validation error by calling the `api.validation.error` method, then deploy the action:\n\n```\nexports.onExecutePreUserRegistration = async (event, api) => {\n  const firstName = event.request.body['ulp-first-name'];\n  if(!firstName) {\n    api.validation.error(\"invalid_payload\", \"Missing first name\");\n    return;\n  }\n\n  api.user.setUserMetadata(\"firstName\", firstName);\n};\n```\n\n### Add The Action To The Flow\n\nNavigate to [**Actions > Flows > Pre User Registration > Add Action > Custom**](https://manage.auth0.com/dashboard/us/dev-6endizjt/actions/flows/pre-user-signup/), then drag and drop your new action into the registration flow and select **Apply**.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5JmjwcdZCX7pDukNa90cgD/dae853b10cf4c41d2d3543a8e167aae7/3333.png)\n\n### Test The Action\n\nSign up for an account in your test flow and leave the **First Name** field blank. You will see an error on submit:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7qIWCsP8doFWPJGvMTNXJY/1225f9b3ff7ac01a7e9b59f03ca5e139/2024-01-31_16-10-10.png)\n\nAfter you enter a name in the **First Name** field, you are able to submit successfully:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/6TaK1VQyKGELMGmhuRIbVA/b453fe2eb97c95d92e4fbd68ce3cbd6a/2024-01-31_16-12-01.png)\n\n### Verify That The Data Was Saved On user\\_metadata\n\nNavigate to [**User Management > Users**](https://manage.auth0.com/dashboard/us/dev-6endizjt/users), then confirm the data has been saved by viewing the Details tab:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3x5lyrSJJgJQhbjsxoTmG6/033820476be7f67dc688da993fee7924/2024-01-31_16-13-35.png)",
  "title": "Use Actions to Validate and Store End-user Data Gathered By Signup Prompt Customizations",
  "description": "Learn how to use Auth0 Actions to validate and store end-user data. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/branding/post-branding-theme",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/branding/get-default-branding-theme",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/branding/get-branding-theme",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/branding/delete-branding-theme",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/introduction",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/users/get-authentication-methods",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/users/post-authentication-methods",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/branding/patch-branding-theme",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset/event-object",
  "markdown": "# Actions Triggers: post-challenge - Event Object\n\nThe `event` object for the `post-challenge` Actions trigger provides contextual information for a user resetting their password when logging in with Auth0.\n\n**Note:** The `event.user` object does not include any top-level attributes added by an external identity provider.\n\n| Property | Description |\n| --- | --- |\n| `event.authentication` | Details about authentication obtained during the password reset flow.<br><br>Includes the following properties:<br><br>*   `methods` _Array of objects_.<br>    <br>    Contains the authentication methods a user completed during their session.<br>    <br>    Returns one of the following objects:<br>    <br>    *   _Object_.<br>        <br>        Includes the following properties:<br>        <br>        *   `name` _String_.<br>            <br>            The name of the first factor completed during the session. Possible values include:<br>            <br>            *   `federated` A social or enterprise connection was used to authenticate the user as the first factor.<br>            *   `pwd` A database connection was used to authenticate the user as the first factor.<br>            *   `sms` A Passwordless SMS connection was used to authenticate the user as the first factor.<br>            *   `email` A Passwordless Email connection was used to authenticate the user as the first factor or verify email for password reset.<br>            *   `mock` Used for internal testing.<br>            *   `string` A custom authentication method denoted by a URL (as second or later factor).<br>        *   `timestamp` _String_.<br>    *   _Object_.<br>        <br>        Includes the following properties:<br>        <br>        *   `name` _The value `mfa`_. The user completed multi-factor authentication (second or later factors).<br>        *   `timestamp` _String_.<br>        *   `type` _Optional string_.<br>            <br>            The type of the second (or later) factor that was used for multi-factor authentication (MFA), if available. Possible values include:<br>            <br>            *   `email` MFA with email factor.<br>            *   `otp` MFA with OTP factor.<br>            *   `push-notification` MFA with push notification factor.<br>            *   `recovery-code` MFA with recovery code factor.<br>            *   `phone` MFA with SMS or voice factor.<br>            *   `webauthn-roaming` MFA with WebAuthn factor.<br>            *   `webauthn-platform` MFA with WebAuthn factor. |\n| `event.authorization` | An object containing information that describes the authorization granted to the user logging in.<br><br>Includes the following properties:<br><br>*   `roles` _Array of strings_. An array containing the names of the user's assigned roles. |\n| `event.client` | Information about the Client with which the password reset transaction was initiated.<br><br>Includes the following properties:<br><br>*   `client_id` _String_. The client id of the application the user is logging in to.<br>*   `metadata` _Dictionary_. An object for holding other application properties.<br>*   `name` _String_. The name of the application (as defined in the Dashboard). |\n| `event.connection` | Details about the connection used to authenticate the user.<br><br>Includes the following properties:<br><br>*   `id` _String_. The connection's unique identifier.<br>*   `metadata` _Optional dictionary_. Metadata associated with the connection.<br>*   `name` _String_. The name of the connection used to authenticate the user (such as `twitter` or `example-g-suite-domain`).<br>*   `strategy` _String_. The type of connection.<br>    <br>    *   For social connections, `event.connection.strategy === event.connection.name`.<br>    *   For enterprise connections, the strategy is `waad` (Windows Azure AD), `ad` (Active Directory/LDAP), `auth0` (database connections), and so on. |\n| `event.organization`<br><br>_(Optional)_ | Details about the Organization associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `display_name` _String_. The friendly name of the Organization.<br>*   `id` _String_. The Organization identifier.<br>*   `metadata` _Dictionary_. Metadata associated with the Organization.<br>*   `name` _String_. The name of the Organization. |\n| `event.request` | Details about the request that initiated the transaction.<br><br>Includes the following properties:<br><br>*   `body` _Dictionary_. The body of the POST request. This data is only available during refresh token and Client Credential Exchange flows.<br>*   `geoip` _Object_.<br>    <br>    Includes the following properties:<br>    <br>    *   `cityName` _Optional string_.<br>    *   `continentCode` _Optional string_.<br>    *   `countryCode` _Optional string_.<br>    *   `countryCode3` _Optional string_.<br>    *   `countryName` _Optional string_.<br>    *   `latitude` _Optional number_.<br>    *   `longitude` _Optional number_.<br>    *   `subdivisionCode` _Optional string_.<br>    *   `subdivisionName` _Optional string_.<br>    *   `timeZone` _Optional string_.<br>*   `hostname` _Optional string_. The hostname used for the authentication flow.<br>*   `ip` _String_. The originating IP address of the request.<br>*   `language` _Optional string_. The language requested by the browser.<br>*   `method` _String_. The HTTP method used for the request.<br>*   `query` _Dictionary_. The query string parameters sent to the authorization request.<br>*   `user_agent` _Optional string_. The value of the `User-Agent` header received when initiating the transaction. |\n| `event.stats` | Login statistics for the current user.<br><br>Includes the following properties:<br><br>*   `logins_count` _Number_. The number of times the user has logged in. |\n| `event.tenant` | Details about the tenant associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `id` _String_. The name of the tenant. |\n| `event.transaction` | Details about the current transaction.<br><br>Includes the following properties:<br><br>*   `locale` _String_. The locale to use for this transaction as determined by comparing the browser's requested languages to the tenant's language settings.<br>*   `login_hint` _Optional string_. Hint to the Authorization Server about the login identifier the end-user might use when logging in, if necessary.<br>*   `state` _Optional string_. An opaque, arbitrary alphanumeric string your app adds to the initial request that Auth0 includes when redirecting back to your application.<br>*   `ui_locales` _Array of strings_. The ui\\_locales provided in the original authentication request. |\n| `event.user` | An object describing the user associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `app_metadata` _Dictionary_. Custom fields that store info about a user that influences the user's access, such as support plan, security roles, or access control groups.<br>*   `created_at` _String_. Timestamp indicating when the user profile was first created.<br>*   `email` _Optional string_. (unique) User's email address.<br>*   `email_verified` _Boolean_. Indicates whether the user has verified their email address.<br>*   `enrolledFactors` _Optional array of objects_.<br>    <br>    An array of authentication factors that the user has enrolled. An empty array indicates the user has not enrolled any factors. If `enrolledFactors` is undefined, the system could not fetch the information, and the user may or may not have enrolled any factors.<br>    <br>    Includes the following properties:<br>    <br>    *   `options` _Optional object_.<br>        <br>        Additional options describing this instance of the enrolled factor.<br>        <br>    *   `type` _String_. The type of authentication factor such as `push-notification`, `phone`, `email`, `otp`, `webauthn-roaming` and `webauthn-platform`.<br>*   `family_name` _Optional string_. User's family name.<br>*   `given_name` _Optional string_. User's given name.<br>*   `identities` _Array of objects_.<br>    <br>    Contains info retrieved from the identity provider originially used to authenticate the user. If a user has linked their profile to multiple identity providers, this array also contains those identities. The contents of an identity provider object vary by provider.<br>    <br>    Includes the following properties:<br>    <br>    *   `connection` _Optional string_. Name of the Auth0 connection used to authenticate the user.<br>    *   `isSocial` _Optional boolean_. Indicates whether a social connection was used.<br>    *   `profileData` _Optional dictionary_. User information associated with the connection. If user profiles have been linked, `profileData` contains associated user data for secondary accounts.<br>    *   `provider` _Optional string_. Name of the entity authenticating the user, such as Facebook, Google, SAML, or your own provider.<br>    *   `user_id` _Optional string_. User's unique identifier for this connection or provider.<br>*   `last_password_reset` _Optional string_. Timestamp indicating the last time the user's password was updated. This field does not exist at user creation. This property is only available for Database connections.<br>*   `name` _Optional string_. User's full name.<br>*   `nickname` _Optional string_. User's nickname.<br>*   `phone_number` _Optional string_. User's phone number. Only valid for users with SMS connections.<br>*   `phone_verified` _Optional boolean_. Indicates whether the user has verified their phone number. Only valid for users with SMS connections.<br>*   `picture` _Optional string_. URL pointing to the [user's profile picture](https://auth0.com/docs/users/change-user-picture).<br>*   `updated_at` _String_. Timestamp indicating when the user's profile was last updated.<br>*   `user_id` _String_. (unique) User's unique identifier.<br>*   `user_metadata` _Dictionary_. Custom fields that store user information that does not impact their level of access, such as work address, home address, or user preferences.<br>*   `username` _Optional string_. (unique) User's username. |",
  "title": "Actions Triggers: post-challenge - Event Object",
  "description": "Learn about the password reset post-challenge Action trigger's event object.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset/api-object",
  "markdown": "# Actions Triggers: post-challenge - API Object\n\nThe API object for the `post-challenge` Actions trigger includes:\n\n## `api.access`\n\nModify the user's login access, such as by rejecting the login attempt.\n\n### `api.access.deny(reason)`\n\nMark the current login attempt as denied. This prevents the end-user from completing the login flow. This does **not** cancel other user-related side effects requested by this Action, such as metadata changes. The login flow immediately stops following the completion of this action and no further Actions will be executed.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `reason` | _String_. A human-readable explanation for rejecting the login. This may be presented directly in end-user interfaces. |\n\n## `api.authentication`\n\nRequest changes to the authentication state of the current user's session.\n\n### `api.authentication.challengeWith(factor, [options])`\n\nRequest a challenge for multifactor authentication using the supplied factor and optional additional factors.\n\nWhen a multifactor challenge is requested, subsequent Actions will not run until that challenge is fulfilled by the user. A user can satisfy this challenge by:\n\n*   Having already completed a challenge for a matching factor in this transaction.\n*   Successfully completing the challenge for the default factor.\n*   Successfully completing the challenge for any of the optional factors described in `additionalFactors`.\n\n**Note:** If the user has not already satisfied the requirements of the challenge, they are presented with a factor challenge screen. If `additionalFactors` are supplied, the user can choose to authenticate with a different factor than the default challenge.\n\n| Parameter | Description |\n| --- | --- |\n| `factor` | _FactorSelector_. An object describing the type of factor (and its options) that should be used for the initial challenge. |\n| `options` | Optional Object. Additional options that can also specify `additionalFactors` as a property. |\n\n### `api.authentication.challengeWithAny([factors])`\n\nRequest a challenge for multifactor authentication using any of the supplied factors or optional additional factors.\n\nWhen a multifactor challenge is requested, subsequent Actions will not run until that challenge is fulfilled by the user. A user can satisfy this challenge by:\n\n*   Having already completed a challenge for a matching factor in this transaction.\n*   Successfully completing the challenge for the default factor.\n\n**Note:** If the user has not already satisfied the requirements of the challenge, they are presented with a factor challenge screen. If there is a specific preferred factor, the `api.authentication.challengeWith()` method is preferred.\n\n| Parameter | Description |\n| --- | --- |\n| `factor` | _FactorSelector\\[\\]_. An array of factors. |\n\n## `api.cache`\n\nStore and retrieve data that persists across executions.\n\n### `api.cache.delete(key)`\n\nDelete a record describing a cached value at the supplied key if it exists.\n\nReturns a `CacheWriteResult` object with `type: \"success\"` if a value was removed from the cache. A failed operation returns `type: \"error\"`.\n\nFor errors, the returned object includes a `code` property that indicates the nature of the failure.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.get(key)`\n\nRetrieve a record describing a cached value at the supplied `key`, if it exists. If a record is found, the cached value can be found at the `value` property of the returned object.\n\nReturns a cache record if an item is found in the cache for the supplied `key`. Cache records are objects containing the following properties:\n\n*   `value` The cached value\n*   `expires_at` The maximum expiry of the record in milliseconds since the Unix epoch\n\n**Important:** This cache is designed for short-lived, ephemeral data. Items may not be available in later transactions even if they are within their supplied their lifetime.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.set(key, value, [options])`\n\nStore or update a string value in the cache at the specified key.\n\nValues stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\nValues stored in this way can have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default of lifetime of 15 minutes is used. Lifetimes cannot exceed the maximum duration listed in the [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n| `value` | _String_. The value of the record to be stored. |\n| `options` | _Optional object_. Options for adjusting cache behavior. |\n| `options.expires_at` | _Optional number_. The absolute expiry time in milliseconds since the Unix epoch. While cached records may be evicted earlier, they will never remain beyond the the supplied `expires_at`.<br><br>**Note:** This value should not be supplied if `ttl` value is provided. If values are supplied for both options, the earlier expiry of the two is used. |\n| `options.ttl` | _Optional number_. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the the supplied `ttl`.<br><br>**Note:** This value should not be supplied if a `expires_at` value is provided. If values are supplied for both options, the earlier expiry of the two is used. |\n\n## `api.redirect`\n\n### `api.redirect.encodeToken(options)`\n\nCreate a session token that is suitable for use as a query string parameter redirect target (via `sendUserTo`) and contains data whose authenticity must be provable by the target endpoint. The target endpoint can verify the authenticity and integrity of the data by checking the JWT's signature using a shared secret.\n\nReturns a JWT string.\n\n| Parameter | Description |\n| --- | --- |\n| `options` | _Options_. Configure how sensitive data is encoded into the query parameters of the resulting url. |\n| `options.expiresInSeconds` | _Number_. Number of seconds before the token expires. Default is 900. |\n| `options.payload` | _Options_. The data intended to be passed to the target of the redirect and whose authenticity and integrity must be provable. |\n| `options.secret` | _String_. A secret that will be used to sign a JWT shared with the redirect target. This value should be stored as a secret and retrieved using `event.secrets['SECRET_NAME']`. |\n\n### `api.redirect.sendUserTo(url, options)`\n\nTrigger a browser redirect to the target \\`url\\` immediately after the action completes.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `url` | _String_. The target URL of the redirect. |\n| `options` | _Options_. An object representing any additional query string parameters appended to the redirect URL. |\n| `options.query` | _Options_. Additional query string parameters to append to the redirect URL. |\n\n### `api.redirect.validateToken(options)`\n\nRetrieve the data encoded in a JWT token passed to the `/continue` endpoint while simultaneously verifying the authenticity and integrity of that data.\n\nReturns payload of the JWT token.\n\n| Parameter | Description |\n| --- | --- |\n| `options` | _Options_. Options for retrieving the data encoded in a JWT token passed to the `/continue` endpoint following a redirect. |\n| `options.secret` | _String_. Secret used to encode the token. |\n| `options.tokenParameterName` | _String_. The name of the query or body parameter that was sent to the `/continue` endpoint. Defaults to `session_token`. |",
  "title": "Actions Triggers: post-challenge - API Object",
  "description": "Learn about the password reset post-challenge Action trigger's API object.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/get-name-by-name",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/post-organizations",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/get-members",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/post-members",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/get-invitations-by-invitation-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/get-organization-member-roles",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/post-organization-member-roles",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/get-enabled-connections",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/post-enabled-connections",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/custom-domains/post-verify",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/keys/post-signing-keys",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/prompts/get-partials",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/connections/get-status",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/sessions/get-session",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/users/get-sessions-for-user",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/users/delete-sessions-for-user",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/refresh-tokens/get-refresh-token",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/users/get-refresh-tokens-for-user",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/sessions/delete-session",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/users/delete-refresh-tokens-for-user",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/get-organizations",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/refresh-tokens/delete-refresh-token",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/logs/get-logs",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/users/delete-users-by-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/connections/get-connections",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/device-credentials/post-device-credentials",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/organizations/get-organizations-by-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow/api-object",
  "markdown": "# Actions Triggers: post-change-password - API Object\n\nThe API object for the `post-change-password` Actions trigger includes:\n\n## `api.cache`\n\nStore and retrieve data that persists across executions.\n\n### `api.cache.delete(key)`\n\nDelete a record describing a cached value at the supplied key if it exists.\n\nReturns a `CacheWriteResult` object with `type: \"success\"` if a value was removed from the cache. A failed operation returns `type: \"error\"`. For errors, the returned object will have a `code` property that indicates the nature of the failure.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.get(key)`\n\nRetrieve a record describing a cached value at the supplied `key`, if it exists. If a record is found, the cached value can be found at the `value` property of the returned object.\n\nReturns a cache record if an item is found in the cache for the supplied `key`. Cache records are objects with a `value` property holding the cached value as well as an `expires_at` property indicating the maximum expiry of the record in milliseconds since the Unix epoch.\n\n**Important:** This cache is designed for short-lived, ephemeral data. Items may not be available in later transactions even if they are within their supplied their lifetime.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.set(key, value, [options])`\n\nStore or update a string value in the cache at the specified key.\n\nValues stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\nValues stored in this way will have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default of lifetime of 15 minutes will be used. Lifetimes may not exceed the maximum duration listed at [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n| `value` | _String_. The value of the record to be stored. |\n| `options` | _Optional object_. Options for adjusting cache behavior. |\n| `options.expires_at` | _Optional number_. The absolute expiry time in milliseconds since the unix epoch. While cached records may be evicted earlier, they will never remain beyond the the supplied `expires_at`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `ttl`. If both options are supplied, the earlier expiry of the two will be used. |\n| `options.ttl` | _Optional number_. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the the supplied `ttl`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `expires_at`. If both options are supplied, the earlier expiry of the two will be used. |",
  "title": "Actions Triggers: post-change-password - API Object",
  "description": "Learn about the post-change-password Action trigger's API object.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/remove-permissions-from-users",
  "markdown": "# Remove Permissions from Users\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID/permissions' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"permissions\": [ { \"resource_server_identifier\": \"API_ID\", \"permission_name\": \"PERMISSION_NAME\" }, { \"resource_server_identifier\": \"API_ID\", \"permission_name\": \"PERMISSION_NAME\" } ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID/permissions\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID/permissions\"\n\n\tpayload := strings.NewReader(\"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\")\n\n\treq, _ := http.NewRequest(\"DELETE\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/users/USER_ID/permissions\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID/permissions',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    permissions: [\n      {resource_server_identifier: 'API_ID', permission_name: 'PERMISSION_NAME'},\n      {resource_server_identifier: 'API_ID', permission_name: 'PERMISSION_NAME'}\n    ]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"permissions\": @[ @{ @\"resource_server_identifier\": @\"API_ID\", @\"permission_name\": @\"PERMISSION_NAME\" }, @{ @\"resource_server_identifier\": @\"API_ID\", @\"permission_name\": @\"PERMISSION_NAME\" } ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID/permissions\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID/permissions\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_POSTFIELDS => \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/users/USER_ID/permissions\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID/permissions\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"permissions\": [\n    [\n      \"resource_server_identifier\": \"API_ID\",\n      \"permission_name\": \"PERMISSION_NAME\"\n    ],\n    [\n      \"resource_server_identifier\": \"API_ID\",\n      \"permission_name\": \"PERMISSION_NAME\"\n    ]\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID/permissions\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Remove Permissions from Users",
  "description": "Learn how to remove permissions directly assigned to a user using the Auth0 Dashboard or the Management API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/enterprise/saml",
  "markdown": "# Connect Your App to SAML Identity Providers\n\nAuth0 lets you create SAML Identity Provider (IdP) connections.\n\n## Prerequisites\n\nBefore beginning:\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of **`{https://yourApp/callback}`**.\n        \n    *   Make sure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n*   Decide on the name of this enterprise connection\n    \n    *   The Post-back URL (also called Assertion Consumer Service URL) becomes: `https://{yourDomain}/login/callback?connection={yourConnectionName}`\n        \n    *   The Entity ID becomes: `urn:auth0:{yourTenant}:{yourConnectionName}`\n        \n\n## Steps\n\nTo connect your application to a SAML Identity Provider, you must:\n\n1.  Enter the Post-back URL and Entity ID at the IdP (to learn how, read about [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)).\n    \n2.  [Get the signing certificate from the IdP](#get-the-signing-certificate-from-the-idp) and [convert it to Base64](#convert-signing-certificate-to-base64).\n    \n3.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0).\n    \n4.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application).\n    \n5.  [Set up mappings](#set-up-mappings) (unnecessary for most cases).\n    \n6.  [Test the connection](#test-the-connection).\n    \n\n## Get the signing certificate from the IdP\n\nWith SAML Login, Auth0 acts as the service provider, so you will need to retrieve an X.509 signing certificate from the SAML IdP (in PEM or CER format); later, you will upload this to Auth0. The methods for retrieving this certificate vary, so please see your IdP's documentation if you need additional assistance.\n\n### Convert signing certificate to Base64\n\nYou can use the Management API or the Auth0 Dashboard to upload the X.509 signing certificate. If you use the Management API, you must convert the file to Base64. To do this, either use a [simple online tool](https://www.base64decode.org/) or run the following command in Bash: `cat signing-cert.crt | base64`.\n\n## Create an enterprise connection in Auth0\n\nNext, you will need to create and configure a SAML Enterprise Connection in Auth0 and upload your X.509 signing certificate. This task can be performed using either Auth0's Dashboard or Management API.\n\n### Create an enterprise connection using the Dashboard\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **SAML**, and select its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create:**\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant and the same name used when setting the Post-back URL and Entity ID at the IdP. Once set, this name can't be changed. |\n    | **Sign In URL** | SAML single login URL. |\n    | **X.509 Signing Certificate** | Signing certificate (encoded in PEM or CER) you retrieved from the IdP earlier in this process. |\n    | **Enable Sign Out** | When enabled, a specific Sign Out URL can be set. Otherwise, the Sign In URL is used by default. |\n    | **Sign Out URL** (optional) | SAML single logout URL. |\n    | **User ID Attribute** (optional) | Attribute in the SAML token that will be mapped to the `user_id` property in Auth0. |\n    | **Debug Mode** | When enabled, more verbose logging will be performed during the authentication process. |\n    | **Sign Request** | When enabled, the SAML authentication request will be signed. (Be sure to download and provide the accompanying certificate so the SAML IdP can validate the assertions' signature.) |\n    | **Sign Request Algorithm** | Algorithm Auth0 will use to sign the SAML assertions. |\n    | **Sign Request Digest Algorithm** | Algorithm Auth0 will use for the sign request digest. |\n    | **Protocol Binding** | HTTP binding supported by the IdP. |\n    | **Request Template** (optional) | Template that formats the SAML request. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    ![Configure SAML Settings](https://images.ctfassets.net/cdy7uua7fh8z/7hvlp8kjva9uFzm5nwsBTQ/4c9f4d01438a3dab6cfb19a5d61d3f13/SAML_Connection_2.png)\n3.  In the **Login Experience** view, configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n4.  If you have appropriate administrative permissions to complete the integration, click **Continue** to learn about the custom parameters needed to configure your IdP. Otherwise, provide the given URL to your administrator so that they can adjust the required settings.\n    \n\n### Create an enterprise connection using the Management API\n\nYou can also use the [Management API](https://auth0.com/docs/api/management/v2) to create your SAML Connection. When doing so, you may choose to specify each SAML configuration field manually or else specify a SAML metadata document that contains the configuration values.\n\n#### Create a connection using specified values\n\nMake a `POST` call to the [Create a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). Be sure to replace `MGMT_API_ACCESS_TOKEN`, `CONNECTION_NAME`, `SIGN_IN_ENDPOINT_URL`, `SIGN_OUT_ENDPOINT_URL`, and `BASE64_SIGNING_CERT` placeholder values with your Management API Access Token, connection name, sign in URL, sign out URL, and Base64-encoded signing certificate (in PEM or CER format), respectively.\n\n*   [cURL](#966e23590b344805bf7d12b75151b008_shell)\n*   [C#](#966e23590b344805bf7d12b75151b008_csharp)\n*   [Go](#966e23590b344805bf7d12b75151b008_go)\n*   [Java](#966e23590b344805bf7d12b75151b008_java)\n*   [Node.JS](#966e23590b344805bf7d12b75151b008_node)\n*   [Obj-C](#966e23590b344805bf7d12b75151b008_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\", \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\", \"signatureAlgorithm\": \"rsa-sha256\", \"digestAlgorithm\": \"sha256\", \"fieldsMap\": {}, \"signingCert\": \"BASE64_SIGNING_CERT\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    strategy: 'samlp',\n    name: 'CONNECTION_NAME',\n    options: {\n      signInEndpoint: 'SIGN_IN_ENDPOINT_URL',\n      signOutEndpoint: 'SIGN_OUT_ENDPOINT_URL',\n      signatureAlgorithm: 'rsa-sha256',\n      digestAlgorithm: 'sha256',\n      fieldsMap: {},\n      signingCert: 'BASE64_SIGNING_CERT'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"samlp\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"signInEndpoint\": @\"SIGN_IN_ENDPOINT_URL\", @\"signOutEndpoint\": @\"SIGN_OUT_ENDPOINT_URL\", @\"signatureAlgorithm\": @\"rsa-sha256\", @\"digestAlgorithm\": @\"sha256\", @\"fieldsMap\": @{  }, @\"signingCert\": @\"BASE64_SIGNING_CERT\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"strategy\": \"samlp\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\",\n    \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\",\n    \"signatureAlgorithm\": \"rsa-sha256\",\n    \"digestAlgorithm\": \"sha256\",\n    \"fieldsMap\": [],\n    \"signingCert\": \"BASE64_SIGNING_CERT\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/api/management/v2/tokens) with the scope `create:connections`. |\n| `CONNECTION_NAME` | Τhe name of the connection to be created. |\n| `SIGN_IN_ENDPONT_URL` | SAML single login URL for the connection to be created. |\n| `SIGN_OUT_ENDPOINT_URL` | SAML single logout URL for the connection to be created. |\n| `BASE64_SIGNING_CERT` | X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP. |\n\nOr, in JSON:\n\n```\n{\n\t\"strategy\": \"samlp\",\n  \t\"name\": \"CONNECTION_NAME\",\n  \t\"options\": {\n    \t\"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\",\n    \t\"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\",\n    \t\"signatureAlgorithm\": \"rsa-sha256\",\n    \t\"digestAlgorithm\": \"sha256\",\n    \t\"fieldsMap\": {\n     \t\t...\n    \t},\n    \t\"signingCert\": \"BASE64_SIGNING_CERT\"\n  \t}\n}\n```\n\n#### Create a connection using SAML metadata\n\nRather than specifying each SAML configuration field, you can specify a SAML metadata document that contains the configuration values. When specifying a SAML metadata document, you may provide either the XML content of the document (`metadataXml`) or the URL of the document (`metadataUrl`). When providing the URL, content is downloaded only once; the connection will not automatically reconfigure if the content of the URL changes in the future.\n\n##### Provide metadata document content\n\nUse the `metadataXml` option to provide content of the document:\n\n*   [cURL](#bf808167d002424ea040de52b4cb0fb8_shell)\n*   [C#](#bf808167d002424ea040de52b4cb0fb8_csharp)\n*   [Go](#bf808167d002424ea040de52b4cb0fb8_go)\n*   [Java](#bf808167d002424ea040de52b4cb0fb8_java)\n*   [Node.JS](#bf808167d002424ea040de52b4cb0fb8_node)\n*   [Obj-C](#bf808167d002424ea040de52b4cb0fb8_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataXml\": \"<EntityDescriptor entityID='\\''urn:saml-idp'\\'' xmlns='\\''urn:oasis:names:tc:SAML:2.0:metadata'\\''>...</EntityDescriptor>\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    strategy: 'samlp',\n    name: 'CONNECTION_NAME',\n    options: {\n      metadataXml: '<EntityDescriptor entityID=\\'urn:saml-idp\\' xmlns=\\'urn:oasis:names:tc:SAML:2.0:metadata\\'>...</EntityDescriptor>'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"samlp\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"metadataXml\": @\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"strategy\": \"samlp\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\"metadataXml\": \"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Provide a metadata document URL\n\nUse the `metadataUrl` option to provide the URL of the document:\n\n*   [cURL](#ce208c9625a740f1add1aa50bcb5e8f3_shell)\n*   [C#](#ce208c9625a740f1add1aa50bcb5e8f3_csharp)\n*   [Go](#ce208c9625a740f1add1aa50bcb5e8f3_go)\n*   [Java](#ce208c9625a740f1add1aa50bcb5e8f3_java)\n*   [Node.JS](#ce208c9625a740f1add1aa50bcb5e8f3_node)\n*   [Obj-C](#ce208c9625a740f1add1aa50bcb5e8f3_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    strategy: 'samlp',\n    name: 'CONNECTION_NAME',\n    options: {\n      metadataUrl: 'https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"samlp\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"metadataUrl\": @\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"strategy\": \"samlp\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nWhen providing the URL, content is downloaded only once; the connection will not automatically reconfigure if the content of the URL changes in the future.\n\n##### Refresh existing connection information with metadata URL\n\nIf you have a B2B implementation and federate to Auth0 with your own SAML identity provider, you may need to refresh connection information stored in Auth0, such as signing certificate changes, endpoint URL changes, or new assertion fields. Auth0 does this automatically for ADFS connections, but not for SAML connections.\n\nYou can create a batch process (cron job) to do a periodic refresh. The process can run every few weeks and perform a PATCH call to `/api/v2/connections/CONNECTION_ID` endpoint, passing a body containing `{options: {metadataUrl: '$URL'}}` where `$URL` is the same metadata URL with which you created the connection. You use the metadata URL to create a new temporary connection, then compare the properties of the old and new connections. If anything is different, update the new connection and then delete the temporary connection.\n\n1.  Create SAML connection with `options.metadataUrl`. The connection object will be populated with information from the metadata.\n    \n2.  Update metadata content in the URL.\n    \n3.  Send a PATCH to the `/api/v2/connections/CONNECTION_ID` endpoint with `{options: {metadataUrl: '$URL'}}`. Now the connection object is updated with the new metadata content.\n    \n\n## Specify a custom Entity ID\n\nTo specify a custom Entity ID, use the Management API to override the default `urn:auth0:YOUR_TENANT:YOUR_CONNECTION_NAME`. Set the `connection.options.entityID` property when the connection is first created or by updating an existing connection.\n\nThe JSON example below can be used to create a new SAML connection using the SAML IdP’s metadata URL while also specifying a custom Entity ID. The Entity ID is still unique since it is created using the name of the connection.\n\n```\n{\n  \"strategy\": \"samlp\", \n  \"name\": \"{yourConnectionName}\", \n  \"options\": { \n    \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\",\n    \"entityId\": \"urn:your-custom-sp-name:{yourConnectionName}\"\n  }\n}\n```\n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new SAML enterprise connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Set up mappings\n\nSelect the **Mappings** view, enter mappings between the `{}`, and select **Save**.\n\n![Configure SAML Mappings](https://images.ctfassets.net/cdy7uua7fh8z/3matGqveShEDX89p8Bcmwr/6e8a1924c2d2ebde8fd980ed47f78d13/dashboard-connections-enterprise-edit_view-mappings_saml.png)\n\n**Mappings for non-standard PingFederate Servers:**\n\n```\n{\n    \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n    \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"\n}\n```\n\n**Mappings for SSO Circle**\n\n```\n{\n  \"email\": \"EmailAddress\",\n  \"given_name\": \"FirstName\",\n  \"family_name\": \"LastName\"\n}\n```\n\n**Map either of two claims to one user attribute**\n\n```\n{\n  \"given_name\": [\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n  ]\n}\n```\n\n**How to map name identifier to a user attribute**\n\n```\n{\n  \"user_id\": [\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn\",\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n  ]\n}\n```\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).",
  "title": "Connect Your App to SAML Identity Providers",
  "description": "Learn how to connect to SAML Identity Providers using an enterprise connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data",
  "markdown": "# Metadata Field Names and Data Types\n\nAuth0 distinguishes between three types of metadata used to store specific kinds of information.\n\n| **Metadata Type** | **Field Name** | **Description** |\n| --- | --- | --- |\n| **User Information** | `user_metadata` | Stores user attributes such as preferences that do not impact a user's core functionality. This data **can** be edited by logged in users if you build a form using the Management API and should **not** be used as a secure data store. |\n| **Access Information** | `app_metadata` | Stores information such as permissions, Auth0 plan, and external IDs that can impact user access to features. This data **cannot** be edited by users and there are restrictions for what can be stored in this field. |\n| **Application Information** | `client_metadata` in the `Client` object, `context.clientMetadata` in Rules, and `event.client.metadata` in post-login Actions. | Stores information about an application (or _client_ in OIDC OAuth2 terminology). For example, the URL for the application home page (any value that Auth0 doesn’t set in the application settings). |\n\n## Metadata field names\n\n### Accepted characters\n\nField names must not contain the `.` (dot) or `$` (dollar sign) characters.\n\nFor example, this is not allowed:\n\n```\n{\n  \"preference.color\": \"pink\"\n}\n```\n\nBut you can expand it like this:\n\n```\n{\n    \"preference\": { \n        \"color\": \"pink\" \n    }\n}\n```\n\n### Dynamic field names\n\nField names should be static. Dynamic field names reduce indexing efficiency and cause degradation in search queries. A static schema is easier to search, manipulate, and work with.\n\nInstead of doing this:\n\n```\n{\n    \"participants\": [\n        \"Alice\": {\n            \"role\": \"sender\"\n         },\n        \"Bob\": {\n            \"role\": \"receiver\"\n        }\n    ]\n}\n```\n\nDo this:\n\n```\n{\n    \"participants\": [\n        {\n            \"name\": \"Alice\",\n            \"role\": \"sender\"\n        },\n        {\n            \"name\" : \"Bob\",\n            \"role\": \"receiver\"\n        }\n    ]\n}\n```\n\n### Name collision\n\nAvoid using the same name for `app_metadata` fields and root profile fields. The `app_metadata` field is merged onto the root profile in both Rules and Actions, which may override root profile fields.\n\nFor example, if a user has a `groups` field present on their root profile (returned from a SAML identity provider) and a `groups` field within `app_metadata`, their profile might look like this:\n\n```\n{\n    \"user_id\": \"samlp|example-samlp-connection|username@domain.com\",\n    \"groups\": [\n        \"external-group-1\",\n        \"external-group-2\"\n    ],\n    \"app_metadata\": {\n        \"groups\": [\n            \"internal-group-1\",\n            \"internal-group-2\"\n        ]\n    }\n}\n```\n\nWhen you read the `groups` field on the [User object](https://auth0.com/docs/customize/rules/user-object-in-rules) from a [Rule](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules), it will return: `[\"internal-group-1\", \"internal-group-2\"]`.\n\n## Metadata data types\n\nMetadata fields support all [JSON-compatible data types](https://datatracker.ietf.org/doc/html/rfc7159):\n\n*   String\n    \n*   Number\n    \n*   Array\n    \n*   Object\n    \n\nMake sure to keep data types consistent between users. For example, if you store a value as a string for one user (`user.user_metadata.age = \"23\"`) and as a number for another user (`user.user_metadata.age = 23`), you may encounter issues when retrieving the data.\n\n## Limitations and restrictions\n\n### Rate limits\n\nWhen you update metadata during login with [Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules) or [Actions](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata), you are subject to your tenant’s rate limits. To learn more, read [Management API Endpoint Rate Limits](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits).\n\n### Size limits and storage\n\n*   There is a 1 MB per-user limit on user data that can be indexed, queried, and returned by the [user search endpoint](https://auth0.com/docs/api/management/v2/users/get-users). If a user profile is larger than 1 MB, any attribute values larger than 256 characters within `app_metadata` and `user_metadata` will not be searchable or returned in a search result. If the user profile is still over 1 MB after omitting these large values, then none of the `app_metadata` and `user_metadata` attributes will be searchable or returnable for that user. Auth0 captures and logs instances where a user profile is still over 1MB after omittances under the `wum` [event code](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes). The [get user endpoint](https://auth0.com/docs/api/management/v2/users/get-users-by-id) must be used to retrieve all metadata attributes for oversized user profiles.\n    \n*   When you set the `user_metadata` field using the Auth0 Authentication API [Signup endpoint](https://auth0.com/docs/api/authentication?javascript#signup), you can include a maximum of 10 string fields whose values do not exceed 500 characters each. For an example of working with metadata during a custom signup process, read [Custom Signup](https://auth0.com/docs/libraries/custom-signup).\n    \n*   The `client_metadata` field can have a maximum of 10 keys. Its keys and values have a maximum length of 255 characters each and cannot contain UTF-8 special characters.\n    \n\n### Restrictions\n\nThe `app_metadata` field must not contain any of these properties:\n\n*   `__tenant`\n    \n*   `_id`\n    \n*   `blocked`\n    \n*   `clientID`\n    \n*   `created_at`\n    \n*   `email_verified`\n    \n*   `email`\n    \n*   `globalClientID`\n    \n*   `global_client_id`\n    \n*   `identities`\n    \n*   `lastIP`\n    \n*   `lastLogin`\n    \n*   `loginsCount`\n    \n*   `metadata`\n    \n*   `multifactor_last_modified`\n    \n*   `multifactor`\n    \n*   `updated_at`\n    \n*   `user_id`\n    \n\n## Learn more\n\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata)\n*   [User Data Storage](https://auth0.com/docs/secure/security-guidance/data-security/user-data-storage)",
  "title": "Metadata Field Names and Data Types",
  "description": "Describes user metadata, app metadata, and application (client) metadata field names, data types, and limitations and restrictions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-lock",
  "markdown": "# Manage Metadata with Lock\n\nYou can use the [Lock library](https://auth0.com/docs/libraries/lock) to define, add, read, and update the `user_metadata.` You can read the user's `user_metadata` properties the same way you would read any other user profile property. For example, the following code snippet retrieves the value associated with `user_metadata.hobby` and assigns it to an element on the page:\n\n```\n// Use the accessToken acquired upon authentication to call getUserInfo\nlock.getUserInfo(accessToken, function(error, profile) {\n  if (!error) {\n    document.getElementById('hobby').textContent = profile.user_metadata.hobby;\n  }\n});\n```\n\nYou can use `additionalSignUpFields` to add custom fields to user sign-up forms. When a user adds data in a custom field, Auth0 stores entered values in that user's `user_metadata`. To learn more about adding `user_metadata` on signup, read [Additional Signup Fields](https://auth0.com/docs/libraries/lock/v10/customization#additionalsignupfields-array-).\n\n## Learn more\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)\n*   [Lock API Reference](https://auth0.com/docs/libraries/lock/lock-api-reference)\n*   [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors)",
  "title": "Manage Metadata with Lock",
  "description": "Learn how to manage user and app metadata with the Auth0 Lock library.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/confidential-and-public-applications/update-application-ownership",
  "markdown": "# Update Application Ownership\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"is_first_party\": \"{ownershipBoolean}\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"is_first_party\\\": \\\"{ownershipBoolean}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\"\n\n\tpayload := strings.NewReader(\"{ \\\"is_first_party\\\": \\\"{ownershipBoolean}\\\" }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"is_first_party\\\": \\\"{ownershipBoolean}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'cache-control': 'no-cache'\n  },\n  data: {is_first_party: '{ownershipBoolean}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"is_first_party\": @\"{ownershipBoolean}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"is_first_party\\\": \\\"{ownershipBoolean}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"is_first_party\\\": \\\"{ownershipBoolean}\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/clients/%7ByourClientId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"is_first_party\\\": \\\"{ownershipBoolean}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"is_first_party\": \"{ownershipBoolean}\"] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Update Application Ownership",
  "description": "Learn how to update application ownership using the Auth0 Management API. This will let you specify whether an application is registered with Auth0 as a first-party or third-party application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow/api-object",
  "markdown": "# Actions Triggers: post-user-registration - API Object\n\nThe API object for the `post-user-registration` Actions trigger includes:\n\n## `api.cache`\n\nStore and retrieve data that persists across executions.\n\n### `api.cache.delete(key)`\n\nDelete a record describing a cached value at the supplied key if it exists.\n\nReturns a `CacheWriteResult` object with `type: \"success\"` if a value was removed from the cache. A failed operation returns `type: \"error\"`. For errors, the returned object will have a `code` property that indicates the nature of the failure.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.get(key)`\n\nRetrieve a record describing a cached value at the supplied `key`, if it exists. If a record is found, the cached value can be found at the `value` property of the returned object.\n\nReturns a cache record if an item is found in the cache for the supplied `key`. Cache records are objects with a `value` property holding the cached value as well as an `expires_at` property indicating the maximum expiry of the record in milliseconds since the Unix epoch.\n\n**Important:** This cache is designed for short-lived, ephemeral data. Items may not be available in later transactions even if they are within their supplied their lifetime.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.set(key, value, [options])`\n\nStore or update a string value in the cache at the specified key.\n\nValues stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\nValues stored in this way will have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default of lifetime of 15 minutes will be used. Lifetimes may not exceed the maximum duration listed at [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n| `value` | _String_. The value of the record to be stored. |\n| `options` | _Optional object_. Options for adjusting cache behavior. |\n| `options.expires_at` | _Optional number_. The absolute expiry time in milliseconds since the unix epoch. While cached records may be evicted earlier, they will never remain beyond the the supplied `expires_at`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `ttl`. If both options are supplied, the earlier expiry of the two will be used. |\n| `options.ttl` | _Optional number_. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the the supplied `ttl`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `expires_at`. If both options are supplied, the earlier expiry of the two will be used. |",
  "title": "Actions Triggers: post-user-registration - API Object",
  "description": "Learn about the post-user-registration Action trigger's API object.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/guardian/put-policies",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api",
  "markdown": "# Manage Metadata Using the Management API\n\n## User metadata\n\n### Create user metadata\n\nTo create a user with the following profile details:\n\n```\n{\n    \"email\": \"jane.doe@example.com\",\n    \"user_metadata\": {\n        \"hobby\": \"surfing\"\n    },\n    \"app_metadata\": {\n        \"plan\": \"full\"\n    }\n}\n```\n\nMake the following `POST` call to the Management API [`/post_users`](https://auth0.com/docs/api/management/v2#!/Users/post_users) endpoint to create the user and set the property values:\n\n*   [cURL](#74458d6fe1e7405faba6aa748168fffd_shell)\n*   [C#](#74458d6fe1e7405faba6aa748168fffd_csharp)\n*   [Go](#74458d6fe1e7405faba6aa748168fffd_go)\n*   [Java](#74458d6fe1e7405faba6aa748168fffd_java)\n*   [Node.JS](#74458d6fe1e7405faba6aa748168fffd_node)\n*   [Obj-C](#74458d6fe1e7405faba6aa748168fffd_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/users' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"email\": \"jane.doe@example.com\", \"user_metadata\": {\"hobby\": \"surfing\"}, \"app_metadata\": {\"plan\": \"full\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users\"\n\n\tpayload := strings.NewReader(\"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/users\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/users',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {\n    email: 'jane.doe@example.com',\n    user_metadata: {hobby: 'surfing'},\n    app_metadata: {plan: 'full'}\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"email\": @\"jane.doe@example.com\",\n                              @\"user_metadata\": @{ @\"hobby\": @\"surfing\" },\n                              @\"app_metadata\": @{ @\"plan\": @\"full\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/users\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"email\": \"jane.doe@example.com\",\n  \"user_metadata\": [\"hobby\": \"surfing\"],\n  \"app_metadata\": [\"plan\": \"full\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Update user metadata\n\nYou can update a user's metadata by making a `PATCH` call to the Management API [`/patch_users_by_id`](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) endpoint.\n\nAssuming you created a user with the following metadata values:\n\n```\n{\n    \"email\": \"jane.doe@example.com\",\n    \"user_metadata\": {\n        \"hobby\": \"surfing\"\n    },\n    \"app_metadata\": {\n        \"plan\": \"full\"\n    }\n}\n```\n\nTo update `user_metadata` and add the user's home address as a second-level property:\n\n```\n{\n    \"addresses\": {\n        \"home\": \"123 Main Street, Anytown, ST 12345\"\n    }\n}\n```\n\nYou would make the following `PATCH` call:\n\n*   [cURL](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_shell)\n*   [C#](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_csharp)\n*   [Go](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_go)\n*   [Java](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_java)\n*   [Node.JS](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_node)\n*   [Obj-C](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/user_id' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\": {\"addresses\": {\"home\": \"123 Main Street, Anytown, ST 12345\"}}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/user_id\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/user_id\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/user_id\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/user_id',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {user_metadata: {addresses: {home: '123 Main Street, Anytown, ST 12345'}}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"user_metadata\": @{ @\"addresses\": @{ @\"home\": @\"123 Main Street, Anytown, ST 12345\" } } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/user_id\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/user_id\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/user_id\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/user_id\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"user_metadata\": [\"addresses\": [\"home\": \"123 Main Street, Anytown, ST 12345\"]]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/user_id\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe user's profile will now appear as follows:\n\n```\n{\n    \"email\": \"jane.doe@example.com\",\n    \"user_metadata\": {\n        \"hobby\": \"surfing\",\n        \"addresses\": {\n            \"home\": \"123 Main Street, Anytown, ST 12345\"\n        }\n    },\n    \"app_metadata\": {\n        \"plan\": \"full\"\n    }\n}\n```\n\n### Merge user metadata\n\nOnly properties at the root level are merged into the object. All lower-level properties will be replaced.\n\nFor example, to add a user's work address as an additional inner property, you would have to include the complete contents of the `addresses` property. Since the `addresses` object is a root-level property, it will be merged into the final JSON object representing the user, but its sub-properties will not.\n\n```\n{\n  \"user_metadata\": {\n    \"addresses\": {\n      \"home\": \"123 Main Street, Anytown, ST 12345\",\n      \"work\": \"100 Industrial Way, Anytown, ST 12345\"\n    }\n  }\n}\n```\n\nTherefore, the corresponding `PATCH` call to the API would be:\n\n*   [cURL](#4b2020974c664c04bf1e1e20837bb7bb_shell)\n*   [C#](#4b2020974c664c04bf1e1e20837bb7bb_csharp)\n*   [Go](#4b2020974c664c04bf1e1e20837bb7bb_go)\n*   [Java](#4b2020974c664c04bf1e1e20837bb7bb_java)\n*   [Node.JS](#4b2020974c664c04bf1e1e20837bb7bb_node)\n*   [Obj-C](#4b2020974c664c04bf1e1e20837bb7bb_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/user_id' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\": {\"addresses\": {\"home\": \"123 Main Street, Anytown, ST 12345\", \"work\": \"100 Industrial Way, Anytown, ST 12345\"}}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/user_id\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/user_id\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/user_id\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/user_id',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {\n    user_metadata: {\n      addresses: {\n        home: '123 Main Street, Anytown, ST 12345',\n        work: '100 Industrial Way, Anytown, ST 12345'\n      }\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"user_metadata\": @{ @\"addresses\": @{ @\"home\": @\"123 Main Street, Anytown, ST 12345\", @\"work\": @\"100 Industrial Way, Anytown, ST 12345\" } } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/user_id\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/user_id\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/user_id\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/user_id\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"user_metadata\": [\"addresses\": [\n      \"home\": \"123 Main Street, Anytown, ST 12345\",\n      \"work\": \"100 Industrial Way, Anytown, ST 12345\"\n    ]]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/user_id\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Delete user metadata\n\nYou can delete `user_metadata`:\n\n## App metadata\n\nPatching the metadata with an empty object removes the metadata completely. For example, sending this body removes everything in `app_metadata`:\n\n## Client metadata\n\n### Create applications with client metadata\n\nA `clientMetadata` object can be included when creating a new application via the `POST /api/v2/` applications endpoint.\n\n### Read client metadata\n\nClient metadata is included in the response to the `GET /api/v2/clients` and `GET /api/v2/client/{id}` endpoints.\n\n### Update client metadata\n\nClient metadata can be updated using the [`PATCH /api/v2/clients/{id}`](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) endpoint, supplying an application object with the `clientMetadata property`, which has a value that consists of an object containing the metadata you'd like to change.\n\n**Application before:**\n\n```\n{\n  ...\n  \"name\": \"myclient\",\n  \"client_metadata\": {\n    \"mycolor\": \"red\",\n    \"myflavor\": \"grape\"\n  }\n  ...\n}\n```\n\nRequest: `PATCH /api/v2/client/myclientid123` with body:\n\n```\n{ \"client_metadata\": { \"mycolor\": \"blue\" } }\n```\n\n**Application after:**\n\n```\n{\n  \"name\": \"myclient\",\n  \"client_metadata\": {\n    \"mycolor\": \"blue\",\n    \"myflavor\": \"grape\"\n  }\n  ...\n}\n```\n\n### Delete client metadata properties and values\n\nClient metadata keys can be removed by issuing a PATCH, as described in \"Update app\\_metadata\" above, but supplying `null` for the key value. This behavior matches that of the `user_metadata` and `app_metadata` properties in the `PATCH` [/api/v2/users/{id}](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) endpoint.\n\n## Learn more\n\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)\n*   [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata)",
  "title": "Manage Metadata Using the Management API",
  "description": "Learn how to create, update, merge, and delete metadata with the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow/api-object",
  "markdown": "# Actions Triggers: send-phone-message - API Object\n\nThe API object for the `send-phone-message` Actions trigger includes:\n\n## `api.cache`\n\nStore and retrieve data that persists across executions.\n\n### `api.cache.delete(key)`\n\nDelete a record describing a cached value at the supplied key if it exists.\n\nReturns a `CacheWriteResult` object with `type: \"success\"` if a value was removed from the cache. A failed operation returns `type: \"error\"`. For errors, the returned object will have a `code` property that indicates the nature of the failure.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.get(key)`\n\nRetrieve a record describing a cached value at the supplied `key`, if it exists. If a record is found, the cached value can be found at the `value` property of the returned object.\n\nReturns a cache record if an item is found in the cache for the supplied `key`. Cache records are objects with a `value` property holding the cached value as well as an `expires_at` property indicating the maximum expiry of the record in milliseconds since the Unix epoch.\n\n**Important:** This cache is designed for short-lived, ephemeral data. Items may not be available in later transactions even if they are within their supplied their lifetime.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.set(key, value, [options])`\n\nStore or update a string value in the cache at the specified key.\n\nValues stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\nValues stored in this way will have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default of lifetime of 15 minutes will be used. Lifetimes may not exceed the maximum duration listed at [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n| `value` | _String_. The value of the record to be stored. |\n| `options` | _Optional object_. Options for adjusting cache behavior. |\n| `options.expires_at` | _Optional number_. The absolute expiry time in milliseconds since the unix epoch. While cached records may be evicted earlier, they will never remain beyond the the supplied `expires_at`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `ttl`. If both options are supplied, the earlier expiry of the two will be used. |\n| `options.ttl` | _Optional number_. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the the supplied `ttl`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `expires_at`. If both options are supplied, the earlier expiry of the two will be used. |",
  "title": "Actions Triggers: send-phone-message - API Object",
  "description": "Learn about the send-phone-message Action trigger's API object.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/best-practices/user-data-storage-best-practices",
  "markdown": "# User Data Storage\n\nAuth0 stores user information for your tenant in a hosted cloud database, or you can choose to store user data in your own custom external database.\n\nTo store user data beyond the basic information Auth0 uses for authentication, you can use the Auth0 data store or a custom database. However, if you use the additional data for authentication purposes, we recommend that you use the Auth0 data store, as this allows you to manage your user data through the [Auth0 Management Dashboard](https://manage.auth0.com/#).\n\n## External database vs. Auth0 data store\n\nThe Auth0 data store is customized for authentication data. Storing anything beyond the default user information should be done only in limited cases. Here's why:\n\n*   **Scalability**: The Auth0 data store is limited in scalability, and your Application's data may exceed the appropriate limits. By using an external database, you keep your Auth0 data store simple, while the more efficient external database contains the extra data;\n    \n*   **Performance**: Your authentication data is likely accessed at lower frequencies than your other data. The Auth0 data store isn't optimized for high-frequency use, so you should store data that needs to be retrieved more often elsewhere;\n    \n*   **Flexibility**: Because the Auth0 data store was built to accommodate only user profiles and their associated metadata, you are limited in terms of the actions you can perform on the database. By using separate databases for your other data, you can manage your data as appropriate.\n    \n\nWhen outsourcing user authentication, there is usually no need to maintain your own users/passwords table. Even so, you may still want to associate application data with authenticated users.\n\n*   For example, you could have a Users table that lists each user authenticated by Auth0. Every time a user logs in, you could search the table for that user. If the user does not exist, you would create a new record. If they do exist, you would update all fields, essentially keeping a local copy of all user data.\n    \n*   Alternatively, you could store the user identifier in each table/collection that has user-associated data. This is a simpler implementation suited to smaller applications.\n    \n\n## User data storage example scenario\n\nAuth0 provides a sample app, a mobile music application, that reflects the end-to-end user experience when using Auth0 with a custom external database. The sample app is an iOS app created using the [Auth0 iOS seed project](https://auth0.com/docs/quickstart/native/ios-swift). The backend uses the [Node.js API](https://auth0.com/docs/quickstart/backend/nodejs).\n\nFor a visualization of the application's overall structure, see the [Mobile + API architecture scenario](https://auth0.com/docs/architecture-scenarios/application/mobile-api).\n\n### Metadata\n\n#### App metadata\n\nThe following data points from our mobile music application are appropriate to store in `app_metadata`:\n\n*   User's subscription plan\n    \n*   User's right (or lack thereof) to edit featured playlists\n    \n\nThese two data points should be stored in `app_metadata` instead of `user_metadata` because they should not be directly changeable by the user.\n\n#### User metadata\n\nThe following data points from our mobile music application are appropriate to store in `user_metadata`:\n\n*   Application preferences\n    \n*   Details chosen by the user to alter their experience of the app upon login.\n    \n\nNote that, unlike the data points for `app_metadata`, the user can easily and readily change those stored in `user_metadata`.\n\nWe can let the user change their `displayName`, which is the name the user sees upon logging in and is displayed to other users of the app.\n\nTo display the user's chosen identifier whenever they log in, we use a rule to get the `user.user_metadata` value.\n\n```\nfunction(user, context, callback){\n  user.user_metadata = user.user_metadata || {};\n  user.user_metadata.displayName = user.user_metadata.displayName || \"user\";\n\n  auth0.users.updateUserMetadata(user.user_id, user.user_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nHere's a look at the screen the user would use to change their `displayName`:\n\n![iOS app settings screen with option to update display name.](https://images.ctfassets.net/cdy7uua7fh8z/33YxGQKYztHY3OM6mxJ4jN/0a06103e6b6455c2e1962a1f738b663a/4-settings.png)\n\nTo save the changes to the database, the application makes a call to the [Get a User](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) endpoint of the Management API to identify the appropriate user:\n\n*   [cURL](#bb915eba4e70433faf76ce8aa6ad8836_shell)\n*   [C#](#bb915eba4e70433faf76ce8aa6ad8836_csharp)\n*   [Go](#bb915eba4e70433faf76ce8aa6ad8836_go)\n*   [Java](#bb915eba4e70433faf76ce8aa6ad8836_java)\n*   [Node.JS](#bb915eba4e70433faf76ce8aa6ad8836_node)\n*   [Obj-C](#bb915eba4e70433faf76ce8aa6ad8836_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id \\\n  --header 'authorization: Bearer {yourIdToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourIdToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourIdToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\")\n  .header(\"authorization\", \"Bearer {yourIdToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id',\n  headers: {authorization: 'Bearer {yourIdToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourIdToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourIdToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourIdToken}\" }\n\nconn.request(\"GET\", \"%7ByourAccount%7D.auth0.com/api/v2/users/user_id\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourIdToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourIdToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis is followed by a call to the [Update a User](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) endpoint to update the `user_metadata` field:\n\n*   [cURL](#116a53b25cee4458bf8845747b966675_shell)\n*   [C#](#116a53b25cee4458bf8845747b966675_csharp)\n*   [Go](#116a53b25cee4458bf8845747b966675_go)\n*   [Java](#116a53b25cee4458bf8845747b966675_java)\n*   [Node.JS](#116a53b25cee4458bf8845747b966675_node)\n*   [Obj-C](#116a53b25cee4458bf8845747b966675_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/user_id' \\\n  --header 'authorization: Bearer {yourAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\": {\"displayName\": \"J-vald3z\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/user_id\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer {yourAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/user_id\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/user_id\")\n  .header(\"authorization\", \"Bearer {yourAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/user_id',\n  headers: {authorization: 'Bearer {yourAccessToken}', 'content-type': 'application/json'},\n  data: '{\"user_metadata\": {\"displayName\": \"J-vald3z\"}'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{\"user_metadata\": {\"displayName\": \"J-vald3z\"}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/user_id\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/user_id\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\"\n\nheaders = {\n    'authorization': \"Bearer {yourAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/user_id\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/user_id\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {yourAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourAccessToken}\",\n  \"content-type\": \"application/json\"\n]\n\nlet postData = NSData(data: \"{\"user_metadata\": {\"displayName\": \"J-vald3z\"}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/user_id\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou must replace `{yourAccessToken}` with a [Management API Access Token](https://auth0.com/docs/api/management/v2/concepts/tokens).\n\n### User data permission rules\n\nUse [rules](https://auth0.com/docs/customize/rules) to implement permissions on whether a user can edit featured playlists or not.\n\n#### Assign Playlist Editor role\n\nThe first rule sends a request to our Node API, which then queries the database connected to Heroku to check how many plays the user’s playlist has. If the number is 100 or greater, we assign `playlist_editor` as a value in the `roles` array in `app_metadata`.\n\n```\nfunction (user, context, callback) {\n\n  var request = require('request');\n\n  user.app_metadata = user.app_metadata || {};\n  user.app_metadata.roles = user.roles || [];\n\n  var CLIENT_SECRET = configuration.AUTH0_CLIENT_SECRET;\n  var CLIENT_ID = configuration.AUTH0_CLIENT_ID;\n\n  var scope = {\n    user_id: user.user_id,\n    email: user.email,\n    name: user.name\n  };\n\n  var options = {\n    subject: user.user_id,\n    expiresInMinutes: 600,\n    audience: CLIENT_ID,\n    issuer: 'https://example.auth0.com'\n  };\n\n  var id_token = jwt.sign(scope, CLIENT_SECRET, options);\n\n  var auth = 'Bearer ' + id_token;\n\n  request.get({\n    url: 'https://example.com/playlists/getPlays',\n    headers: {\n       'Authorization': auth,\n      'Content-Type': 'text/html'\n    },\n    timeout: 15000\n  }, function(err, response, body){\n    if (err)\n      return callback(new Error(err));\n    var plays = parseInt(body, 10);\n\n    if (plays >= 100 && user.roles.indexOf('playlist_editor') < 0){\n      user.app_metadata.roles.push('playlist_editor');\n      auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n        .then(function(){\n          callback(null, user, context);\n        })\n        .catch(callback);\n    }\n\n    else if (plays < 100 && user.roles.indexOf('playlist_editor') >= 0){\n      user.app_metadata.roles = [];\n      auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n        .then(function(){\n          callback(null, user, context);\n        })\n        .catch(callback);\n    }\n    else{\n      callback(null, user, context);\n    }\n\n  });\n\n}\n```\n\n#### Scope parameter specifies role\n\nThe second rule gets the `app_metadata` field and assigns the `roles` array to a field in the user object so it can be accessed without calling `app_metadata` on the application. The `scope` parameter can then specify `roles` upon the user logging in without including everything in `app_metadata` in the user object:\n\n```\nfunction(user, context, callback) {\n   if (user.app_metadata) {\n      user.roles = user.app_metadata.roles;\n   }\n   user.roles = user.roles || [];\n   callback(null, user, context);\n}\n```\n\nAfter we've implemented these two rules, the app recognizes whether the user is a playlist editor or not and changes the welcome screen accordingly. If `playlist_editor` is in the `roles` array stored in the user's `app_metadata`, the user will be welcomed as an **EDITOR** after signing in:\n\n![Example of user profile page with editor role.](https://images.ctfassets.net/cdy7uua7fh8z/1WEKC4eWvm8GPK2BlodGFk/3eb36843f22518ace800fc1507bd5816/3-home.png)\n\n#### Associate a user's music with the user\n\nWe need to associate a user's music with that user, but this information is not required for authentication. Here's how to store this information in a separate database that is integrated with the backend of the application.\n\nThe user's unique identifier is the `user_id`. Here is a sample row from the `songs` table in our database:\n\n| song\\_id | songname | user\\_id |\n| --- | --- | --- |\n| 1   | Number One Hit | google-oauth2 |\n\nThe Node.js backend authenticates requests to the URI associated with getting the user’s personal data from the database by validating a JSON Web Token.\n\n[Learn about token-based authentication and how to implement JWT in your Applications.](https://auth0.com/docs/tokens/concepts/jwts)\n\nHere is the code implementing JWT validation from the Node.js seed project:\n\n```\nvar genres = require('./routes/genres');\nvar songs = require('./routes/songs');\nvar playlists = require('./routes/playlists');\nvar displayName = require('./routes/displayName');\n\nvar authenticate = jwt({\n  secret: process.env.AUTH0_CLIENT_SECRET,\n  audience: process.env.AUTH0_CLIENT_ID\n});\n\napp.use('/genres', authenticate, genres);\napp.use('/songs', authenticate, songs);\napp.use('/playlists', authenticate, playlists);\napp.use('/displayName', authenticate, displayName);\n```\n\nWe can add functionality to handle different data requests from our Application. For example, if we receive a `GET` request to `/secured/getFavGenre`, the API calls the `queryGenre()` function, which queries the database for and responds with the user’s favorite genre.\n\n```\n@IBAction func getGenre(sender: AnyObject) {\n        let request = buildAPIRequest(\"/genres/getFav\", type:\"GET\")\n        let task = NSURLSession.sharedSession().dataTaskWithRequest(request) {[unowned self](data, response, error) in\n            let genre = NSString(data: data!, encoding: NSUTF8StringEncoding)\n            dispatch_async(dispatch_get_main_queue(), {\n                self.favGenre.text = \"Favorite Genre:  \\(genre!)\"\n            })\n        }\n        task.resume()\n    }\n```\n\nThe function `buildAPIRequest()` takes the path and HTTP method of the request as parameters and builds a request using the base URL of our Node.js API that's hosted on Heroku.\n\nIn the Application, the `getGenre()` function makes a request to the API and changes the app's interface to display the request response to `/genres/getFav`. The backend retrieves the required data for this action using the `queryGenre()` function and returns the results to the Application:\n\n```\nfunction queryGenre(user_id, res){\n\n  db.connect(process.env.DATABASE_URL, function(err, client) {\n  if (err) throw err;\n\n  client\n    .query('SELECT fav_genre as value FROM user_data WHERE user_id = $1', [user_id], function(err, result) {\n\n      if(err) {\n        return console.error('error running query', err);\n      }\n      res.send(result.rows[0].value);\n    });\n  });\n\n};\n```\n\n## Learn more\n\n*   [Normalized User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles)\n*   [Normalized User Profile Schema](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema)\n*   [Sample User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles/sample-user-profiles)",
  "title": "User Data Storage",
  "description": "Learn the differences between using the Auth0 data store and an external database to store user data.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/view-role-permissions",
  "markdown": "# View Role Permissions\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/roles/ROLE_ID/permissions' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/roles/ROLE_ID/permissions',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/roles/ROLE_ID/permissions\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "View Role Permissions",
  "description": "Learn how to view permissions added to a role using the Auth0 Dashboard or the Management API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/view-user-permissions",
  "markdown": "# View User Permissions\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID/permissions' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID/permissions\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID/permissions\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users/USER_ID/permissions\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID/permissions',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID/permissions\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID/permissions\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users/USER_ID/permissions\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID/permissions\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID/permissions\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "View User Permissions",
  "description": "Learn how to view permissions assigned to a user using the Auth0 Dashboard and Management API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/remove-permissions-from-roles",
  "markdown": "# Remove Permissions from Roles\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/roles/ROLE_ID/permissions' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"permissions\": [ { \"resource_server_identifier\": \"API_ID\", \"permission_name\": \"PERMISSION_NAME\" }, { \"resource_server_identifier\": \"API_ID\", \"permission_name\": \"PERMISSION_NAME\" } ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\"\n\n\tpayload := strings.NewReader(\"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\")\n\n\treq, _ := http.NewRequest(\"DELETE\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/roles/ROLE_ID/permissions',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    permissions: [\n      {resource_server_identifier: 'API_ID', permission_name: 'PERMISSION_NAME'},\n      {resource_server_identifier: 'API_ID', permission_name: 'PERMISSION_NAME'}\n    ]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"permissions\": @[ @{ @\"resource_server_identifier\": @\"API_ID\", @\"permission_name\": @\"PERMISSION_NAME\" }, @{ @\"resource_server_identifier\": @\"API_ID\", @\"permission_name\": @\"PERMISSION_NAME\" } ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_POSTFIELDS => \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_ID\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/roles/ROLE_ID/permissions\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/roles/ROLE_ID/permissions\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-c