[
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html",
    "markdown": "# TypeScript: Documentation - TypeScript 5.5\n\n## [](#inferred-type-predicates)Inferred Type Predicates\n\n_This section was written by [Dan Vanderkam](https://github.com/danvk), who [implemented this feature in TypeScript 5.5](https://github.com/microsoft/TypeScript/pull/57465). Thanks Dan!_\n\nTypeScript’s control flow analysis does a great job of tracking how the type of a variable changes as it moves through your code:\n\ntsx\n\n`interface Bird {`\n\n    `commonName: string;`\n\n    `scientificName: string;`\n\n    `sing(): void;`\n\n`}`\n\n`// Maps country names -> national bird.`\n\n`// Not all nations have official birds (looking at you, Canada!)`\n\n`declare const nationalBirds: Map<string, Bird>;`\n\n`function makeNationalBirdCall(country: string) {`\n\n  `const bird = nationalBirds.get(country);  // bird has a declared type of Bird | undefined`\n\n  `if (bird) {`\n\n    `bird.sing();  // bird has type Bird inside the if statement`\n\n  `} else {`\n\n    `// bird has type undefined here.`\n\n  `}`\n\n`}`\n\nBy making you handle the `undefined` case, TypeScript pushes you to write more robust code.\n\nIn the past, this sort of type refinement was more difficult to apply to arrays. This would have been an error in all previous versions of TypeScript:\n\ntsx\n\n`function makeBirdCalls(countries: string[]) {`\n\n  `// birds: (Bird | undefined)[]`\n\n  `const birds = countries`\n\n    `.map(country => nationalBirds.get(country))`\n\n    `.filter(bird => bird !== undefined);`\n\n  `for (const bird of birds) {`\n\n    `bird.sing();  // error: 'bird' is possibly 'undefined'.`\n\n  `}`\n\n`}`\n\nThis code is perfectly fine: we’ve filtered all the `undefined` values out of the list. But TypeScript hasn’t been able to follow along.\n\nWith TypeScript 5.5, the type checker is fine with this code:\n\ntsx\n\n`function makeBirdCalls(countries: string[]) {`\n\n  `// birds: Bird[]`\n\n  `const birds = countries`\n\n    `.map(country => nationalBirds.get(country))`\n\n    `.filter(bird => bird !== undefined);`\n\n  `for (const bird of birds) {`\n\n    `bird.sing();  // ok!`\n\n  `}`\n\n`}`\n\nNote the more precise type for `birds`.\n\nThis works because TypeScript now infers a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) for the `filter` function. You can see what’s going on more clearly by pulling it out into a standalone function:\n\ntsx\n\n`// function isBirdReal(bird: Bird | undefined): bird is Bird`\n\n`function isBirdReal(bird: Bird | undefined) {`\n\n  `return bird !== undefined;`\n\n`}`\n\n`bird is Bird` is the type predicate. It means that, if the function returns `true`, then it’s a `Bird` (if the function returns `false` then it’s `undefined`). The type declarations for `Array.prototype.filter` know about type predicates, so the net result is that you get a more precise type and the code passes the type checker.\n\nTypeScript will infer that a function returns a type predicate if these conditions hold:\n\n1.  The function does not have an explicit return type or type predicate annotation.\n2.  The function has a single `return` statement and no implicit returns.\n3.  The function does not mutate its parameter.\n4.  The function returns a `boolean` expression that’s tied to a refinement on the parameter.\n\nGenerally this works how you’d expect. Here’s a few more examples of inferred type predicates:\n\ntsx\n\n`// const isNumber: (x: unknown) => x is number`\n\n`const isNumber = (x: unknown) => typeof x === 'number';`\n\n`// const isNonNullish: <T>(x: T) => x is NonNullable<T>`\n\n`const isNonNullish = <T,>(x: T) => x != null;`\n\nPreviously, TypeScript would have just inferred that these functions return `boolean`. It now infers signatures with type predicates like `x is number` or `x is NonNullable<T>`.\n\nType predicates have “if and only if” semantics. If a function returns `x is T`, then it means that:\n\n1.  If the function returns `true` then `x` has the type `T`.\n2.  If the function returns `false` then `x` does _not_ have type `T`.\n\nIf you’re expecting a type predicate to be inferred but it’s not, then you may be running afoul of the second rule. This often comes up with “truthiness” checks:\n\ntsx\n\n`function getClassroomAverage(students: string[], allScores: Map<string, number>) {`\n\n  `const studentScores = students`\n\n    `.map(student => allScores.get(student))`\n\n    `.filter(score => !!score);`\n\n  `return studentScores.reduce((a, b) => a + b) / studentScores.length;`\n\n  `//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`\n\n  `// error: Object is possibly 'undefined'.`\n\n`}`\n\nTypeScript did not infer a type predicate for `score => !!score`, and rightly so: if this returns `true` then `score` is a `number`. But if it returns `false`, then `score` could be either `undefined` or a `number` (specifically, `0`). This is a real bug: if any student got a zero on the test, then filtering out their score will skew the average upwards. Fewer will be above average and more will be sad!\n\nAs with the first example, it’s better to explicitly filter out `undefined` values:\n\ntsx\n\n`function getClassroomAverage(students: string[], allScores: Map<string, number>) {`\n\n  `const studentScores = students`\n\n    `.map(student => allScores.get(student))`\n\n    `.filter(score => score !== undefined);`\n\n  `return studentScores.reduce((a, b) => a + b) / studentScores.length;  // ok!`\n\n`}`\n\nA truthiness check _will_ infer a type predicate for object types, where there’s no ambiguity. Remember that functions must return a `boolean` to be a candidate for an inferred type predicate: `x => !!x` might infer a type predicate, but `x => x` definitely won’t.\n\nExplicit type predicates continue to work exactly as before. TypeScript will not check whether it would infer the same type predicate. Explicit type predicates (“is”) are no safer than a type assertion (“as”).\n\nIt’s possible that this feature will break existing code if TypeScript now infers a more precise type than you want. For example:\n\ntsx\n\n`// Previously, nums: (number | null)[]`\n\n`// Now, nums: number[]`\n\n`const nums = [1, 2, 3, null, 5].filter(x => x !== null);`\n\n`nums.push(null);  // ok in TS 5.4, error in TS 5.5`\n\nThe fix is to tell TypeScript the type that you want using an explicit type annotation:\n\ntsx\n\n`const nums: (number | null)[] = [1, 2, 3, null, 5].filter(x => x !== null);`\n\n`nums.push(null);  // ok in all versions`\n\nFor more information, check out the [implementing pull request](https://github.com/microsoft/TypeScript/pull/57465) and [Dan’s blog post about implementing this feature](https://effectivetypescript.com/2024/04/16/inferring-a-type-predicate/).\n\n## [](#control-flow-narrowing-for-constant-indexed-accesses)Control Flow Narrowing for Constant Indexed Accesses\n\nTypeScript is now able to narrow expressions of the form `obj[key]` when both `obj` and `key` are effectively constant.\n\nts\n\n`function f1(obj: Record<string, unknown>, key: string) {`\n\n    `if (typeof obj[key] === \"string\") {`\n\n        `// Now okay, previously was error`\n\n        `obj[key].toUpperCase();`\n\n    `}`\n\n`}`\n\nIn the above, neither `obj` nor `key` are ever mutated, so TypeScript can narrow the type of `obj[key]` to `string` after the `typeof` check. For more information, [see the implementing pull request here](https://github.com/microsoft/TypeScript/pull/57847).\n\n## [](#the-jsdoc-import-tag)The JSDoc `@import` Tag\n\nToday, if you want to import something only for type-checking in a JavaScript file, it is cumbersome. JavaScript developers can’t simply import a type named `SomeType` if it’s not there at runtime.\n\njs\n\n`// ./some-module.d.ts`\n\n`export interface SomeType {`\n\n    `// ...`\n\n`}`\n\n`// ./index.js`\n\n`import { SomeType } from \"./some-module\"; // ❌ runtime error!`\n\n`/**`\n\n `* @param {SomeType} myValue`\n\n `*/`\n\n`function doSomething(myValue) {`\n\n    `// ...`\n\n`}`\n\n`SomeType` won’t exist at runtime, so the import will fail. Developers can instead use a namespace import instead.\n\njs\n\n`import * as someModule from \"./some-module\";`\n\n`/**`\n\n `* @param {someModule.SomeType} myValue`\n\n `*/`\n\n`function doSomething(myValue) {`\n\n    `// ...`\n\n`}`\n\nBut `./some-module` is still imported at runtime - which might also not be desirable.\n\nTo avoid this, developers typically had to use `import(...)` types in JSDoc comments.\n\njs\n\n`/**`\n\n `* @param {import(\"./some-module\").SomeType} myValue`\n\n `*/`\n\n`function doSomething(myValue) {`\n\n    `// ...`\n\n`}`\n\nIf you wanted to reuse the same type in multiple places, you could use a `typedef` to avoid repeating the import.\n\njs\n\n`/**`\n\n `* @typedef {import(\"./some-module\").SomeType} SomeType`\n\n `*/`\n\n`/**`\n\n `* @param {SomeType} myValue`\n\n `*/`\n\n`function doSomething(myValue) {`\n\n    `// ...`\n\n`}`\n\nThis helps with local uses of `SomeType`, but it gets repetitive for many imports and can be a bit verbose.\n\nThat’s why TypeScript now supports a new `@import` comment tag that has the same syntax as ECMAScript imports.\n\njs\n\n`/** @import { SomeType } from \"some-module\" */`\n\n`/**`\n\n `* @param {SomeType} myValue`\n\n `*/`\n\n`function doSomething(myValue) {`\n\n    `// ...`\n\n`}`\n\nHere, we used named imports. We could also have written our import as a namespace import.\n\njs\n\n`/** @import * as someModule from \"some-module\" */`\n\n`/**`\n\n `* @param {someModule.SomeType} myValue`\n\n `*/`\n\n`function doSomething(myValue) {`\n\n    `// ...`\n\n`}`\n\nBecause these are just JSDoc comments, they don’t affect runtime behavior at all.\n\nWe would like to extend a big thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk) who contributed [this change](https://github.com/microsoft/TypeScript/pull/57207)!\n\n## [](#regular-expression-syntax-checking)Regular Expression Syntax Checking\n\nUntil now, TypeScript has typically skipped over most regular expressions in code. This is because regular expressions technically have an extensible grammar and TypeScript never made any effort to compile regular expressions to earlier versions of JavaScript. Still, this meant that lots of common problems would go undiscovered in regular expressions, and they would either turn into errors at runtime, or silently fail.\n\nBut TypeScript now does basic syntax checking on regular expressions!\n\nts\n\n`let myRegex = /@robot(\\s+(please|immediately)))? do some task/;`\n\n`//                                            ~`\n\n`// error!`\n\n`// Unexpected ')'. Did you mean to escape it with backslash?`\n\nThis is a simple example, but this checking can catch a lot of common mistakes. In fact, TypeScript’s checking goes slightly beyond syntactic checks. For instance, TypeScript can now catch issues around backreferences that don’t exist.\n\nts\n\n`let myRegex = /@typedef \\{import\\((.+)\\)\\.([a-zA-Z_]+)\\} \\3/u;`\n\n`//                                                        ~`\n\n`// error!`\n\n`// This backreference refers to a group that does not exist.`\n\n`// There are only 2 capturing groups in this regular expression.`\n\nThe same applies to named capturing groups.\n\nts\n\n`let myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<namedImport>/;`\n\n`//                                                                                        ~~~~~~~~~~~`\n\n`// error!`\n\n`// There is no capturing group named 'namedImport' in this regular expression.`\n\nTypeScript’s checking is now also aware of when certain RegExp features are used when newer than your target version of ECMAScript. For example, if we use named capturing groups like the above in an ES5 target, we’ll get an error.\n\nts\n\n`let myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<importedEntity>/;`\n\n`//                                  ~~~~~~~~~~~~         ~~~~~~~~~~~~~~~~`\n\n`// error!`\n\n`// Named capturing groups are only available when targeting 'ES2018' or later.`\n\nThe same is true for certain regular expression flags as well.\n\nNote that TypeScript’s regular expression support is limited to regular expression _literals_. If you try calling `new RegExp` with a string literal, TypeScript will not check the provided string.\n\nWe would like to thank [GitHub user graphemecluster](https://github.com/graphemecluster/) who iterated a ton with us [to get this feature into TypeScript](https://github.com/microsoft/TypeScript/pull/55600).\n\n## [](#support-for-new-ecmascript-set-methods)Support for New ECMAScript `Set` Methods\n\nTypeScript 5.5 declares [new proposed methods for the ECMAScript `Set` type](https://github.com/tc39/proposal-set-methods).\n\nSome of these methods, like `union`, `intersection`, `difference`, and `symmetricDifference`, take another `Set` and return a new `Set` as the result. The other methods, `isSubsetOf`, `isSupersetOf`, and `isDisjointFrom`, take another `Set` and return a `boolean`. None of these methods mutate the original `Set`s.\n\nHere’s a quick example of how you might use these methods and how they behave:\n\nts\n\n`let fruits = new Set([\"apples\", \"bananas\", \"pears\", \"oranges\"]);`\n\n`let applesAndBananas = new Set([\"apples\", \"bananas\"]);`\n\n`let applesAndOranges = new Set([\"apples\", \"oranges\"]);`\n\n`let oranges = new Set([\"oranges\"]);`\n\n`let emptySet = new Set();`\n\n`////`\n\n`// union`\n\n`////`\n\n`// Set(4) {'apples', 'bananas', 'pears', 'oranges'}`\n\n`console.log(fruits.union(oranges));`\n\n`// Set(3) {'apples', 'bananas', 'oranges'}`\n\n`console.log(applesAndBananas.union(oranges));`\n\n`////`\n\n`// intersection`\n\n`////`\n\n`// Set(2) {'apples', 'bananas'}`\n\n`console.log(fruits.intersection(applesAndBananas));`\n\n`// Set(0) {}`\n\n`console.log(applesAndBananas.intersection(oranges));`\n\n`// Set(1) {'apples'}`\n\n`console.log(applesAndBananas.intersection(applesAndOranges));`\n\n`////`\n\n`// difference`\n\n`////`\n\n`// Set(3) {'apples', 'bananas', 'pears'}`\n\n`console.log(fruits.difference(oranges));`\n\n`// Set(2) {'pears', 'oranges'}`\n\n`console.log(fruits.difference(applesAndBananas));`\n\n`// Set(1) {'bananas'}`\n\n`console.log(applesAndBananas.difference(applesAndOranges));`\n\n`////`\n\n`// symmetricDifference`\n\n`////`\n\n`// Set(2) {'bananas', 'oranges'}`\n\n`console.log(applesAndBananas.symmetricDifference(applesAndOranges)); // no apples`\n\n`////`\n\n`// isDisjointFrom`\n\n`////`\n\n`// true`\n\n`console.log(applesAndBananas.isDisjointFrom(oranges));`\n\n`// false`\n\n`console.log(applesAndBananas.isDisjointFrom(applesAndOranges));`\n\n`// true`\n\n`console.log(fruits.isDisjointFrom(emptySet));`\n\n`// true`\n\n`console.log(emptySet.isDisjointFrom(emptySet));`\n\n`////`\n\n`// isSubsetOf`\n\n`////`\n\n`// true`\n\n`console.log(applesAndBananas.isSubsetOf(fruits));`\n\n`// false`\n\n`console.log(fruits.isSubsetOf(applesAndBananas));`\n\n`// false`\n\n`console.log(applesAndBananas.isSubsetOf(oranges));`\n\n`// true`\n\n`console.log(fruits.isSubsetOf(fruits));`\n\n`// true`\n\n`console.log(emptySet.isSubsetOf(fruits));`\n\n`////`\n\n`// isSupersetOf`\n\n`////`\n\n`// true`\n\n`console.log(fruits.isSupersetOf(applesAndBananas));`\n\n`// false`\n\n`console.log(applesAndBananas.isSupersetOf(fruits));`\n\n`// false`\n\n`console.log(applesAndBananas.isSupersetOf(oranges));`\n\n`// true`\n\n`console.log(fruits.isSupersetOf(fruits));`\n\n`// false`\n\n`console.log(emptySet.isSupersetOf(fruits));`\n\nWe’d like to thank [Kevin Gibbons](https://github.com/bakkot) who not only co-championed the feature in ECMAScript, but [also provided the declarations for `Set`, `ReadonlySet`, and `ReadonlySetLike` in TypeScript](https://github.com/microsoft/TypeScript/pull/57230)!\n\n## [](#isolated-declarations)Isolated Declarations\n\n_This section was co-authored by [Rob Palmer](https://github.com/robpalme) who supported the design of isolated declarations._\n\nDeclaration files (a.k.a. `.d.ts` files) describe the shape of existing libraries and modules to TypeScript. This lightweight description includes the library’s type signatures and excludes implementation details such as the function bodies. They are published so that TypeScript can efficiently check your usage of a library without needing to analyse the library itself. Whilst it is possible to handwrite declaration files, if you are authoring typed code, it’s much safer and simpler to let TypeScript generate them automatically from source files using `--declaration`.\n\nThe TypeScript compiler and its APIs have always had the job of generating declaration files; however, there are some use-cases where you might want to use other tools, or where the traditional build process doesn’t scale.\n\n### [](#use-case-faster-declaration-emit-tools)Use-case: Faster Declaration Emit Tools\n\nImagine if you wanted to create a faster tool to generate declaration files, perhaps as part of a publishing service or a new bundler. Whilst there is a thriving ecosystem of blazing fast tools that can turn TypeScript into JavaScript, the same is not true for turning TypeScript into declaration files. The reason is that TypeScript’s inference allows us to write code without explicitly declaring types, meaning declaration emit can be complex.\n\nLet’s consider a simple example of a function that adds two imported variables.\n\nts\n\n`// util.ts`\n\n`export let one = \"1\";`\n\n`export let two = \"2\";`\n\n`// add.ts`\n\n`import { one, two } from \"./util\";`\n\n`export function add() { return one + two; }`\n\nEven if the only thing we want to do is generate `add.d.ts`, TypeScript needs to crawl into another imported file (`util.ts`), infer that the type of `one` and `two` are strings, and then calculate that the `+` operator on two strings will lead to a `string` return type.\n\nts\n\n`// add.d.ts`\n\n`export declare function add(): string;`\n\nWhile this inference is important for the developer experience, it means that tools that want to generate declaration files would need to replicate parts of the type-checker including inference and the ability to resolve module specifiers to follow the imports.\n\n### [](#use-case-parallel-declaration-emit-and-parallel-checking)Use-case: Parallel Declaration Emit and Parallel Checking\n\nImagine if you had a monorepo containing many projects and a multi-core CPU that just wished it could help you check your code faster. Wouldn’t it be great if we could check all those projects at the same time by running each project on a different core?\n\nUnfortunately we don’t have the freedom to do all the work in parallel. The reason is that we have to build those projects in dependency order, because each project is checking against the declaration files of their dependencies. So we must build the dependency first to generate the declaration files. TypeScript’s project references feature works the same way, building the set of projects in “topological” dependency order.\n\nAs an example, if we have two projects called `backend` and `frontend`, and they both depend on a project called `core`, TypeScript can’t start type-checking either `frontend` or `backend` until `core` has been built and its declaration files have been generated.\n\n![frontend and backend point to core, other stuff might point to each of those](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2024/04/5-5-beta-isolated-declarations-deps.png)\n\nIn the above graph, you can see that we have a bottleneck. Whilst we can build `frontend` and `backend` in parallel, we need to first wait for `core` to finish building before either can start.\n\nHow could we improve upon this? Well, if a fast tool could generate all those declaration files for `core` _in parallel_, TypeScript then could immediately follow that by type-checking `core`, `frontend`, and `backend` also _in parallel_.\n\n### [](#solution-explicit-types)Solution: Explicit Types!\n\nThe common requirement in both use-cases is that we need a cross-file type-checker to generate declaration files. Which is a lot to ask from the tooling community.\n\nAs a more complex example, if we want a declaration file for the following code…\n\nts\n\n`import { add } from \"./add\";`\n\n`const x = add();`\n\n`export function foo() {`\n\n    `return x;`\n\n`}`\n\n…we would need to generate a signature for `foo`. Well that requires looking at the implementation of `foo`. `foo` just returns `x`, so getting the type of `x` requires looking at the implementation of `add`. But that might require looking at the implementation of `add`’s dependencies, and so on. What we’re seeing here is that generating declaration files requires a whole lot of logic to figure out the types of different places that might not even be local to the current file.\n\nStill, for developers looking for fast iteration time and fully parallel builds, there is another way of thinking about this problem. A declaration file only requires the types of the public API of a module - in other words, the types of the things that are exported. If, controversially, developers are willing to explicitly write out the types of the things they export, tools could generate declaration files without needing to look at the implementation of the module - and without reimplementing a full type-checker.\n\nThis is where the new `--isolatedDeclarations` option comes in. `--isolatedDeclarations` reports errors when a module can’t be reliably transformed without a type-checker. More plainly, it makes TypeScript report errors if you have a file that isn’t sufficiently annotated on its exports.\n\nThat means in the above example, we would see an error like the following:\n\nts\n\n`export function foo() {`\n\n`//              ~~~`\n\n`// error! Function must have an explicit`\n\n`// return type annotation with --isolatedDeclarations.`\n\n    `return x;`\n\n`}`\n\n### [](#why-are-errors-desirable)Why are errors desirable?\n\nBecause it means that TypeScript can\n\n1.  Tell us up-front whether other tools will have issues with generating declaration files\n2.  Provide a quick fix to help add these missing annotations.\n\nThis mode doesn’t require annotations _everywhere_ though. For locals, these can be ignored, since they don’t affect the public API. For example, the following code would **not** produce an error:\n\nts\n\n`import { add } from \"./add\";`\n\n`const x = add(\"1\", \"2\"); // no error on 'x', it's not exported.`\n\n`export function foo(): string {`\n\n    `return x;`\n\n`}`\n\nThere are also certain expressions where the type is “trivial” to calculate.\n\nts\n\n`// No error on 'x'.`\n\n`// It's trivial to calculate the type is 'number'`\n\n`export let x = 10;`\n\n`// No error on 'y'.`\n\n`// We can get the type from the return expression.`\n\n`export function y() {`\n\n    `return 20;`\n\n`}`\n\n`// No error on 'z'.`\n\n`// The type assertion makes it clear what the type is.`\n\n`export function z() {`\n\n    `return Math.max(x, y()) as number;`\n\n`}`\n\n### [](#using-isolateddeclarations)Using `isolatedDeclarations`\n\n`isolatedDeclarations` requires that either the `declaration` or `composite` flags are also set.\n\nNote that `isolatedDeclarations` does not change how TypeScript performs emit - just how it reports errors. Importantly, and similar to `isolatedModules`, enabling the feature in TypeScript won’t immediately bring about the potential benefits discussed here. So please be patient and look forward to future developments in this space. Keeping tool authors in mind, we should also recognize that today, not all of TypeScript’s declaration emit can be easily replicated by other tools wanting to use it as a guide. That’s something we’re actively working on improving.\n\nOn top of this, isolated declarations are still a new feature, and we’re actively working on improving the experience. Some scenarios, like using computed property declarations in classes and object literals, are not _yet_ supported under `isolatedDeclarations`. Keep an eye on this space, and feel free to provide us with feedback.\n\nWe also feel it is worth calling out that `isolatedDeclarations` should be adopted on a case-by-case basis. There are some developer ergonomics that are lost when using `isolatedDeclarations`, and thus it may not be the right choice if your setup is not leveraging the two scenarios mentioned earlier. For others, the work on `isolatedDeclarations` has already uncovered many optimizations and opportunities to unlock different parallel build strategies. In the meantime, if you’re willing to make the trade-offs, we believe `isolatedDeclarations` can be a powerful tool to speed up your build process as external tooling becomes more widely available.\n\nFor more information, read up on the [Isolated Declarations: State of the Feature](https://github.com/microsoft/TypeScript/issues/58944) discussion on the TypeScript issue tracker.\n\n### [](#credit)Credit\n\nWork on `isolatedDeclarations` has been a long-time collaborative effort between the TypeScript team and the infrastructure and tooling teams within Bloomberg and Google. Individuals like Hana Joo from Google who implemented [the quick fix for isolated declaration errors](https://github.com/microsoft/TypeScript/pull/58260) (more on that soon), as well as Ashley Claymore, Jan Kühle, Lisa Velden, Rob Palmer, and Thomas Chetwin have been involved in discussion, specification, and implementation for many months. But we feel it is specifically worth calling out the tremendous amount of work provided by [Titian Cernicova-Dragomir](https://github.com/dragomirtitian) from Bloomberg. Titian has been instrumental in driving the implementation of `isolatedDeclarations` and has been a contributor to the TypeScript project for years prior.\n\nWhile the feature involved many changes, you can see [the core work for Isolated Declarations here](https://github.com/microsoft/TypeScript/pull/58201).\n\n## [](#the-configdir-template-variable-for-configuration-files)The `${configDir}` Template Variable for Configuration Files\n\nIt’s common in many codebases to reuse a shared `tsconfig.json` file that acts as a “base” for other configuration files. This is done by using the `extends` field in a `tsconfig.json` file.\n\njson\n\n`{`\n\n    `\"extends\": \"../../tsconfig.base.json\",`\n\n    `\"compilerOptions\": {`\n\n        `\"outDir\": \"./dist\"`\n\n    `}`\n\n`}`\n\nOne of the issues with this is that all paths in the `tsconfig.json` file are relative to the location of the file itself. This means that if you have a shared `tsconfig.base.json` file that is used by multiple projects, relative paths often won’t be useful in the derived projects. For example, imagine the following `tsconfig.base.json`:\n\njson\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"typeRoots\": [`\n\n            `\"./node_modules/@types\"`\n\n            `\"./custom-types\"`\n\n        `],`\n\n        `\"outDir\": \"dist\"`\n\n    `}`\n\n`}`\n\nIf author’s intent was that every `tsconfig.json` that extends this file should\n\n1.  output to a `dist` directory relative to the derived `tsconfig.json` , and\n2.  have a `custom-types` directory relative to the derived `tsconfig.json`,\n\nthen this would not work. The `typeRoots` paths would be relative to the location of the shared `tsconfig.base.json` file, not the project that extends it. Each project that extends this shared file would need to declare its own `outDir` and `typeRoots` with identical contents. This could be frustrating and hard to keep in sync between projects, and while the example above is using `typeRoots`, this is a common problem for `paths` and other options.\n\nTo solve this, TypeScript 5.5 introduces a new template variable `${configDir}`. When `${configDir}` is written in certain path fields of a `tsconfig.json` or `jsconfig.json` files, this variable is substituted with the containing directory of the configuration file in a given compilation. This means that the above `tsconfig.base.json` could be rewritten as:\n\njson\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"typeRoots\": [`\n\n            `\"${configDir}/node_modules/@types\"`\n\n            `\"${configDir}/custom-types\"`\n\n        `],`\n\n        `\"outDir\": \"${configDir}/dist\"`\n\n    `}`\n\n`}`\n\nNow, when a project extends this file, the paths will be relative to the derived `tsconfig.json`, not the shared `tsconfig.base.json` file. This makes it easier to share configuration files across projects and ensures that the configuration files are more portable.\n\nIf you intend to make a `tsconfig.json` file extendable, consider if a `./` should instead be written with `${configDir}`.\n\nFor more information, see [the proposal issue](https://github.com/microsoft/TypeScript/issues/57485) and [the implementing pull request](https://github.com/microsoft/TypeScript/pull/58042).\n\n## [](#consulting-packagejson-dependencies-for-declaration-file-generation)Consulting `package.json` Dependencies for Declaration File Generation\n\nPreviously, TypeScript would often issue an error message like\n\n`The inferred type of \"X\" cannot be named without a reference to \"Y\". This is likely not portable. A type annotation is necessary.`\n\nThis was often due to TypeScript’s declaration file generation finding itself in the contents of files that were never explicitly imported in a program. Generating an import to such a file could be risky if the path ended up being relative. Still, for codebases with explicit dependencies in the `dependencies` (or `peerDependencies` and `optionalDependencies`) of a `package.json`, generating such an import should be safe under certain resolution modes. So in TypeScript 5.5, we’re more lenient when that’s the case, and many occurrences of this error should disappear.\n\n[See this pull request](https://github.com/microsoft/TypeScript/issues/42873) for more details on the change.\n\n## [](#editor-and-watch-mode-reliability-improvements)Editor and Watch-Mode Reliability Improvements\n\nTypeScript has either added some new functionality or fixed existing logic that makes `--watch` mode and TypeScript’s editor integration feel more reliable. That should hopefully translate to fewer TSServer/editor restarts.\n\n### [](#correctly-refresh-editor-errors-in-configuration-files)Correctly Refresh Editor Errors in Configuration Files\n\nTypeScript can generate errors for `tsconfig.json` files; however, those errors are actually generated from loading a project, and editors typically don’t directly request those errors for `tsconfig.json` files. While this sounds like a technical detail, it means that when all errors issued in a `tsconfig.json` are fixed, TypeScript doesn’t issue a new fresh empty set of errors, and users are left with stale errors unless they reload their editor.\n\nTypeScript 5.5 now intentionally issues an event to clear these out. [See more here](https://github.com/microsoft/TypeScript/pull/58120).\n\n### [](#better-handling-for-deletes-followed-by-immediate-writes)Better Handling for Deletes Followed by Immediate Writes\n\nInstead of overwriting files, some tools will opt to delete them and then create new files from scratch. This is the case when running `npm ci`, for instance.\n\nWhile this can be efficient for those tools, it can be problematic for TypeScript’s editor scenarios where deleting a watched might dispose of it and all of its transitive dependencies. Deleting and creating a file in quick succession could lead to TypeScript tearing down an entire project and then rebuilding it from scratch.\n\nTypeScript 5.5 now has a more nuanced approach by keeping parts of a deleted project around until it picks up on a new creation event. This should make operations like `npm ci` work a lot better with TypeScript. See [more information on the approach here](https://github.com/microsoft/TypeScript/pull/57492).\n\n### [](#symlinks-are-tracked-in-failed-resolutions)Symlinks are Tracked in Failed Resolutions\n\nWhen TypeScript fails to resolve a module, it will still need to watch for any failed lookup paths in case the module is added later. Previously this was not done for symlinked directories, which could cause reliability issues in monorepo-like scenarios when a build occurred in one project but was not witnessed in the other. This should be fixed in TypeScript 5.5, and means you won’t need to restart your editor as often.\n\n[See more information here](https://github.com/microsoft/TypeScript/pull/58139).\n\n### [](#project-references-contribute-to-auto-imports)Project References Contribute to Auto-Imports\n\nAuto-imports no longer requires at least one explicit import to dependent projects in a project reference setup. Instead, auto-import completions should just work across anything you’ve listed in the `references` field of your `tsconfig.json`.\n\n[See more on the implementing pull request](https://github.com/microsoft/TypeScript/pull/55955).\n\n## [](#performance-and-size-optimizations)Performance and Size Optimizations\n\n### [](#monomorphized-objects-in-language-service-and-public-api)Monomorphized Objects in Language Service and Public API\n\nIn TypeScript 5.0, we ensured that our [`Node`](https://github.com/microsoft/TypeScript/pull/51682) and [`Symbol`](https://github.com/microsoft/TypeScript/pull/51880) objects had a consistent set of properties with a consistent initialization order. Doing so helps reduce polymorphism in different operations, which allows runtimes to fetch properties more quickly.\n\nBy making this change, we witnessed impressive speed wins in the compiler; however, most of these changes were performed on internal allocators for our data structures. The language service, along with TypeScript’s public API, uses a different set of allocators for certain objects. This allowed the TypeScript compiler to be a bit leaner, as data used only for the language service would never be used in the compiler.\n\nIn TypeScript 5.5, the same monomorphization work has been done for the language service and public API. What this means is that your editor experience, and any build tools that use the TypeScript API, will get a decent amount faster. In fact, in our benchmarks, we’ve seen a **5-8% speedup in build times** when using the public TypeScript API’s allocators, and **language service operations getting 10-20% faster**. While this does imply an increase in memory, we believe that tradeoff is worth it and hope to find ways to reduce that memory overhead. Things should feel a lot snappier now.\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/58045).\n\n### [](#monomorphized-control-flow-nodes)Monomorphized Control Flow Nodes\n\nIn TypeScript 5.5, nodes of the control flow graph have been monomorphized so that they always hold a consistent shape. By doing so, check times will often be reduced by about 1%.\n\n[See this change here](https://github.com/microsoft/TypeScript/pull/57977).\n\n### [](#optimizations-on-our-control-flow-graph)Optimizations on our Control Flow Graph\n\nIn many cases, control flow analysis will traverse nodes that don’t provide any new information. We observed that in the absence of any early termination or effects in the antecedents (or “dominators”) of certain nodes meant that those nodes could always be skipped over. As such, TypeScript now constructs its control flow graphs to take advantage of this by linking to an earlier node that _does_ provide interesting information for control flow analysis. This yields a flatter control flow graph, which can be more efficient to traverse. This optimization has yielded modest gains, but with up to 2% reductions in build time on certain codebases.\n\nYou can [read more here](https://github.com/microsoft/TypeScript/pull/58013).\n\n### [](#skipped-checking-in-transpilemodule-and-transpiledeclaration)Skipped Checking in `transpileModule` and `transpileDeclaration`\n\nTypeScript’s `transpileModule` API can be used for compiling a single TypeScript file’s contents into JavaScript. Similarly, the `transpileDeclaration` API (see below) can be used to generate a declaration file for a single TypeScript file. One of the issues with these APIs is that TypeScript internally would perform a full type-checking pass over the entire contents of the file before emitting the output. This was necessary to collect certain information which would later be used for the emit phase.\n\nIn TypeScript 5.5, we’ve found a way to avoid performing a full check, only lazily collecting this information as necessary, and `transpileModule` and `transpileDeclaration` both enable this functionality by default. As a result, tools that integrate with these APIs, like [ts-loader](https://www.npmjs.com/package/ts-loader) with `transpileOnly` and [ts-jest](https://www.npmjs.com/package/ts-jest), should see a noticeable speedup. In our testing, [we generally witness around a 2x speed-up in build time using `transpileModule`](https://github.com/microsoft/TypeScript/pull/58364#issuecomment-2138580690).\n\n### [](#typescript-package-size-reduction)TypeScript Package Size Reduction\n\nFurther leveraging [our transition to modules in 5.0](https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/), we’ve significantly reduced TypeScript’s overall package size [by making `tsserver.js` and `typingsInstaller.js` import from a common API library instead of having each of them produce standalone bundles](https://github.com/microsoft/TypeScript/pull/55326).\n\nThis reduces TypeScript’s size on disk from 30.2 MB to 20.4 MB, and reduces its packed size from 5.5 MB to 3.7 MB!\n\n### [](#node-reuse-in-declaration-emit)Node Reuse in Declaration Emit\n\nAs part of the work to enable `isolatedDeclarations`, we’ve substantially improved how often TypeScript can directly copy your input source code when producing declaration files.\n\nFor example, let’s say you wrote\n\nts\n\n`export const strBool: string | boolean = \"hello\";`\n\n`export const boolStr: boolean | string = \"world\";`\n\nNote that the union types are equivalent, but the order of the union is different. When emitting the declaration file, TypeScript has two equivalent output possibilities.\n\nThe first is to use a consistent canonical representation for each type:\n\nts\n\n`export const strBool: string | boolean;`\n\n`export const boolStr: string | boolean;`\n\nThe second is to re-use the type annotations exactly as written:\n\nts\n\n`export const strBool: string | boolean;`\n\n`export const boolStr: boolean | string;`\n\nThe second approach is generally preferable for a few reasons:\n\n*   Many equivalent representations still encode some level of intent that is better to preserve in the declaration file\n*   Producing a fresh representation of a type can be somewhat expensive, so avoiding is better\n*   User-written types are usually shorter than generated type representations\n\nIn 5.5, we’ve greatly improved the number of places where TypeScript can correctly identify places where it’s safe and correct to print back types exactly as they were written in the input file. Many of these cases are invisible performance improvements - TypeScript would generate fresh sets of syntax nodes and serialize them into a string. Instead, TypeScript can now operate over the original syntax nodes directly, which is much cheaper and faster.\n\n### [](#caching-contextual-types-from-discriminated-unions)Caching Contextual Types from Discriminated Unions\n\nWhen TypeScript asks for the contextual type of an expression like an object literal, it will often encounter a union type. In those cases, TypeScript tries to filter out members of the union based on known properties with well known values (i.e. discriminant properties). This work can be fairly expensive, especially if you end up with an object consisting of many many properties. In TypeScript 5.5, [much of the computation is cached once so that TypeScript doesn’t need to recompute it for every property in the object literal](https://github.com/microsoft/TypeScript/pull/58372). Performing this optimization shaved 250ms off of compiling the TypeScript compiler itself.\n\n## [](#easier-api-consumption-from-ecmascript-modules)Easier API Consumption from ECMAScript Modules\n\nPreviously, if you were writing an ECMAScript module in Node.js, named imports were not available from the `typescript` package.\n\nts\n\n`import { createSourceFile } from \"typescript\"; // ❌ error`\n\n`import * as ts from \"typescript\";`\n\n`ts.createSourceFile // ❌ undefined???`\n\n`ts.default.createSourceFile // ✅ works - but ugh!`\n\nThis is because [cjs-module-lexer](https://github.com/nodejs/cjs-module-lexer) did not recognize the pattern of TypeScript’s generated CommonJS code. This has been fixed, and users can now use named imports from the TypeScript npm package with ECMAScript modules in Node.js.\n\nts\n\n`import { createSourceFile } from \"typescript\"; // ✅ works now!`\n\n`import * as ts from \"typescript\";`\n\n`ts.createSourceFile // ✅ works now!`\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/57133).\n\n## [](#the-transpiledeclaration-api)The `transpileDeclaration` API\n\nTypeScript’s API exposes a function called `transpileModule`. It’s intended to make it easy to compile a single file of TypeScript code. Because it doesn’t have access to an entire _program_, the caveat is that it may not produce the right output if the code violates any errors under the `isolatedModules` option.\n\nIn TypeScript 5.5, we’ve added a new similar API called `transpileDeclaration`. This API is similar to `transpileModule`, but it’s specifically designed to generate a single _declaration file_ based on some input source text. Just like `transpileModule`, it doesn’t have access to a full program, and a similar caveat applies: it only generates an accurate declaration file if the input code is free of errors under the new `isolatedDeclarations` option.\n\nIf desired, this function can be used to parallelize declaration emit across all files under `isolatedDeclarations` mode.\n\nFor more information, [see the implementation here](https://github.com/microsoft/TypeScript/pull/58261).\n\n## [](#notable-behavioral-changes)Notable Behavioral Changes\n\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\n\n### [](#disabling-features-deprecated-in-typescript-50)Disabling Features Deprecated in TypeScript 5.0\n\nTypeScript 5.0 deprecated the following options and behaviors:\n\n*   `charset`\n*   `target: ES3`\n*   `importsNotUsedAsValues`\n*   `noImplicitUseStrict`\n*   `noStrictGenericChecks`\n*   `keyofStringsOnly`\n*   `suppressExcessPropertyErrors`\n*   `suppressImplicitAnyIndexErrors`\n*   `out`\n*   `preserveValueImports`\n*   `prepend` in project references\n*   implicitly OS-specific `newLine`\n\nTo continue using the deprecated options above, developers using TypeScript 5.0 and other more recent versions have had to specify a new option called `ignoreDeprecations` with the value `\"5.0\"`.\n\nIn TypeScript 5.5, these options no longer have any effect. To help with a smooth upgrade path, you may still specify them in your tsconfig, but these will be an error to specify in TypeScript 6.0. See also the [Flag Deprecation Plan](https://github.com/microsoft/TypeScript/issues/51000) which outlines our deprecation strategy.\n\n[More information around these deprecation plans is available on GitHub](https://github.com/microsoft/TypeScript/issues/51909), which contains suggestions in how to best adapt your codebase.\n\n### [](#libdts-changes)`lib.d.ts` Changes\n\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, [see the DOM updates for TypeScript 5.5](https://github.com/microsoft/TypeScript/pull/58211).\n\n### [](#stricter-parsing-for-decorators)Stricter Parsing for Decorators\n\nSince TypeScript originally introduced support for decorators, the specified grammar for the proposal has been tightened up. TypeScript is now stricter about what forms it allows. While rare, existing decorators may need to be parenthesized to avoid errors.\n\nts\n\n`class DecoratorProvider {`\n\n    `decorate(...args: any[]) { }`\n\n`}`\n\n`class D extends DecoratorProvider {`\n\n    `m() {`\n\n        `class C {`\n\n            `@super.decorate // ❌ error`\n\n            `method1() { }`\n\n            `@(super.decorate) // ✅ okay`\n\n            `method2() { }`\n\n        `}`\n\n    `}`\n\n`}`\n\nSee [more information on the change here](https://github.com/microsoft/TypeScript/pull/57749).\n\n### [](#undefined-is-no-longer-a-definable-type-name)`undefined` is No Longer a Definable Type Name\n\nTypeScript has always disallowed type alias names that conflict with built-in types:\n\nts\n\n`// Illegal`\n\n`type null = any;`\n\n`// Illegal`\n\n`type number = any;`\n\n`// Illegal`\n\n`type object = any;`\n\n`// Illegal`\n\n`type any = any;`\n\nDue to a bug, this logic didn’t also apply to the built-in type `undefined`. In 5.5, this is now correctly identified as an error:\n\nts\n\n`// Now also illegal`\n\n`type undefined = any;`\n\nBare references to type aliases named `undefined` never actually worked in the first place. You could define them, but you couldn’t use them as an unqualified type name.\n\nts\n\n`export type undefined = string;`\n\n`export const m: undefined = \"\";`\n\n`//           ^`\n\n`// Errors in 5.4 and earlier - the local definition of 'undefined' was not even consulted.`\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/57575).\n\n### [](#simplified-reference-directive-declaration-emit)Simplified Reference Directive Declaration Emit\n\nWhen producing a declaration file, TypeScript would synthesize a reference directive when it believed one was required. For example, all Node.js modules are declared ambiently, so cannot be loaded by module resolution alone. A file like:\n\ntsx\n\n`import path from \"path\";`\n\n`export const myPath = path.parse(__filename);`\n\nWould emit a declaration file like:\n\ntsx\n\n`/// <reference types=\"node\" />`\n\n`import path from \"path\";`\n\n`export declare const myPath: path.ParsedPath;`\n\nEven though the reference directive never appeared in the original source.\n\nSimilarly, TypeScript also _removed_ reference directives that it did not believe needed to be a part of the output. For example, let’s imagine we had a reference directive to `jest`; however, imagine the reference directive isn’t necessary to generate the declaration file. TypeScript would simply drop it. So in the following example:\n\ntsx\n\n`/// <reference types=\"jest\" />`\n\n`import path from \"path\";`\n\n`export const myPath = path.parse(__filename);`\n\nTypeScript would still emit:\n\ntsx\n\n`/// <reference types=\"node\" />`\n\n`import path from \"path\";`\n\n`export declare const myPath: path.ParsedPath;`\n\nIn the course of working on `isolatedDeclarations`, we realized that this logic was untenable for anyone attempting to implement a declaration emitter without type checking or using more than a single file’s context. This behavior is also hard to understand from a user’s perspective; whether or not a reference directive appeared in the emitted file seems inconsistent and difficult to predict unless you understand exactly what’s going on during typechecking. To prevent declaration emit from being different when `isolatedDeclarations` was enabled, we knew that our emit needed to change.\n\nThrough [experimentation](https://github.com/microsoft/TypeScript/pull/57569), we found that nearly all cases where TypeScript synthesized reference directives were just to pull in `node` or `react`. These are cases where the expectation is that a downstream user already references those types through tsconfig.json `\"types\"` or library imports, so no longer synthesizing these reference directives would be unlikely to break anyone. It’s worth noting that this is already how it works for `lib.d.ts`; TypeScript doesn’t synthesize a reference to `lib=\"es2015\"` when a module exports a `WeakMap`, instead assuming that a downstream user will have included that as part of their environment.\n\nFor reference directives that had been written by library authors (not synthesized), [further experimentation](https://github.com/microsoft/TypeScript/pull/57656) showed that nearly all were removed, never showing up in the output. Most reference directives that were preserved were broken and likely not intended to be preserved.\n\nGiven those results, we decided to greatly simplfy reference directives in declaration emit in TypeScript 5.5. A more consistent strategy will help library authors and consumers have better control of their declaration files.\n\nReference directives are no longer synthesized. User-written reference directives are no longer preserved, unless annotated with a new `preserve=\"true\"` attribute. Concretely, an input file like:\n\ntsx\n\n`/// <reference types=\"some-lib\" preserve=\"true\" />`\n\n`/// <reference types=\"jest\" />`\n\n`import path from \"path\";`\n\n`export const myPath = path.parse(__filename);`\n\nwill emit:\n\ntsx\n\n`/// <reference types=\"some-lib\" preserve=\"true\" />`\n\n`import path from \"path\";`\n\n`export declare const myPath: path.ParsedPath;`\n\nAdding `preserve=\"true\"` is backwards compatible with older versions of TypeScript as unknown attributes are ignored.\n\nThis change also improved performance; in our benchmarks, the emit stage saw a 1-4% improvement in projects with declaration emit enabled.",
    "title": "TypeScript: Documentation - TypeScript 5.5",
    "description": "TypeScript 5.5 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html",
    "markdown": "# TypeScript: Documentation - TypeScript 5.4\n\n## [](#preserved-narrowing-in-closures-following-last-assignments)Preserved Narrowing in Closures Following Last Assignments\n\nTypeScript can usually figure out a more specific type for a variable based on checks that you might perform. This process is called narrowing.\n\nts\n\n`function uppercaseStrings(x: string | number) {`\n\n    `if (typeof x === \"string\") {`\n\n        `// TypeScript knows 'x' is a 'string' here.`\n\n        `return x.toUpperCase();`\n\n    `}`\n\n`}`\n\nOne common pain point was that these narrowed types weren’t always preserved within function closures.\n\nts\n\n`function getUrls(url: string | URL, names: string[]) {`\n\n    `if (typeof url === \"string\") {`\n\n        `url = new URL(url);`\n\n    `}`\n\n    `return names.map(name => {`\n\n        `url.searchParams.set(\"name\", name)`\n\n        `//  ~~~~~~~~~~~~`\n\n        `// error!`\n\n        `// Property 'searchParams' does not exist on type 'string | URL'.`\n\n        `return url.toString();`\n\n    `});`\n\n`}`\n\nHere, TypeScript decided that it wasn’t “safe” to assume that `url` was _actually_ a `URL` object in our callback function because it was mutated elsewhere; however, in this instance, that arrow function is _always_ created after that assignment to `url`, and it’s also the _last_ assignment to `url`.\n\nTypeScript 5.4 takes advantage of this to make narrowing a little smarter. When parameters and `let` variables are used in non-[hoisted](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting) functions, the type-checker will look for a last assignment point. If one is found, TypeScript can safely narrow from outside the containing function. What that means is the above example just works now.\n\nNote that narrowing analysis doesn’t kick in if the variable is assigned anywhere in a nested function. This is because there’s no way to know for sure whether the function will be called later.\n\nts\n\n`function printValueLater(value: string | undefined) {`\n\n    `if (value === undefined) {`\n\n        `value = \"missing!\";`\n\n    `}`\n\n    `setTimeout(() => {`\n\n        `// Modifying 'value', even in a way that shouldn't affect`\n\n        `// its type, will invalidate type refinements in closures.`\n\n        `value = value;`\n\n    `}, 500);`\n\n    `setTimeout(() => {`\n\n        `console.log(value.toUpperCase());`\n\n        `//          ~~~~~`\n\n        `// error! 'value' is possibly 'undefined'.`\n\n    `}, 1000);`\n\n`}`\n\nThis should make lots of typical JavaScript code easier to express. You can [read more about the change on GitHub](https://github.com/microsoft/TypeScript/pull/56908).\n\n## [](#the-noinfer-utility-type)The `NoInfer` Utility Type\n\nWhen calling generic functions, TypeScript is able to infer type arguments from whatever you pass in.\n\nts\n\n`function doSomething<T>(arg: T) {`\n\n    `// ...`\n\n`}`\n\n`// We can explicitly say that 'T' should be 'string'.`\n\n`doSomething<string>(\"hello!\");`\n\n`// We can also just let the type of 'T' get inferred.`\n\n`doSomething(\"hello!\");`\n\nOne challenge, however, is that it is not always clear what the “best” type is to infer. This might lead to TypeScript rejecting valid calls, accepting questionable calls, or just reporting worse error messages when it catches a bug.\n\nFor example, let’s imagine a `createStreetLight` function that takes a list of color names, along with an optional default color.\n\nts\n\n`function createStreetLight<C extends string>(colors: C[], defaultColor?: C) {`\n\n    `// ...`\n\n`}`\n\n`createStreetLight([\"red\", \"yellow\", \"green\"], \"red\");`\n\nWhat happens when we pass in a `defaultColor` that wasn’t in the original `colors` array? In this function, `colors` is supposed to be the “source of truth” and describe what can be passed to `defaultColor`.\n\nts\n\n`// Oops! This is undesirable, but is allowed!`\n\n`createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");`\n\nIn this call, type inference decided that `\"blue\"` was just as valid of a type as `\"red\"` or `\"yellow\"` or `\"green\"`. So instead of rejecting the call, TypeScript infers the type of `C` as `\"red\" | \"yellow\" | \"green\" | \"blue\"`. You might say that inference just blue up in our faces!\n\nOne way people currently deal with this is to add a separate type parameter that’s bounded by the existing type parameter.\n\nts\n\n`function createStreetLight<C extends string, D extends C>(colors: C[], defaultColor?: D) {`\n\n`}`\n\n`createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");`\n\n`//                                            ~~~~~~`\n\n`// error!`\n\n`// Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'.`\n\nThis works, but is a little bit awkward because `D` probably won’t be used anywhere else in the signature for `createStreetLight`. While not bad _in this case_, using a type parameter only once in a signature is often a code smell.\n\nThat’s why TypeScript 5.4 introduces a new `NoInfer<T>` utility type. Surrounding a type in `NoInfer<...>` gives a signal to TypeScript not to dig in and match against the inner types to find candidates for type inference.\n\nUsing `NoInfer`, we can rewrite `createStreetLight` as something like this:\n\nts\n\n`function createStreetLight<C extends string>(colors: C[], defaultColor?: NoInfer<C>) {`\n\n    `// ...`\n\n`}`\n\n`createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");`\n\n`//                                            ~~~~~~`\n\n`// error!`\n\n`// Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'.`\n\nExcluding the type of `defaultColor` from being explored for inference means that `\"blue\"` never ends up as an inference candidate, and the type-checker can reject it.\n\nYou can see the specific changes in [the implementing pull request](https://github.com/microsoft/TypeScript/pull/56794), along with [the initial implementation](https://github.com/microsoft/TypeScript/pull/52968) provided thanks to [Mateusz Burzyński](https://github.com/Andarist)!\n\n## [](#objectgroupby-and-mapgroupby)`Object.groupBy` and `Map.groupBy`\n\nTypeScript 5.4 adds declarations for JavaScript’s new `Object.groupBy` and `Map.groupBy` static methods.\n\n`Object.groupBy` takes an iterable, and a function that decides which “group” each element should be placed in. The function needs to make a “key” for each distinct group, and `Object.groupBy` uses that key to make an object where every key maps to an array with the original element in it.\n\nSo the following JavaScript:\n\njs\n\n`const array = [0, 1, 2, 3, 4, 5];`\n\n`const myObj = Object.groupBy(array, (num, index) => {`\n\n    `return num % 2 === 0 ? \"even\": \"odd\";`\n\n`});`\n\nis basically equivalent to writing this:\n\njs\n\n`const myObj = {`\n\n    `even: [0, 2, 4],`\n\n    `odd: [1, 3, 5],`\n\n`};`\n\n`Map.groupBy` is similar, but produces a `Map` instead of a plain object. This might be more desirable if you need the guarantees of `Map`s, you’re dealing with APIs that expect `Map`s, or you need to use any kind of key for grouping - not just keys that can be used as property names in JavaScript.\n\njs\n\n`const myObj = Map.groupBy(array, (num, index) => {`\n\n    `return num % 2 === 0 ? \"even\" : \"odd\";`\n\n`});`\n\nand just as before, you could have created `myObj` in an equivalent way:\n\njs\n\n`const myObj = new Map();`\n\n`myObj.set(\"even\", [0, 2, 4]);`\n\n`myObj.set(\"odd\", [1, 3, 5]);`\n\nNote that in the above example of `Object.groupBy`, the object produced uses all optional properties.\n\nts\n\n`interface EvenOdds {`\n\n    `even?: number[];`\n\n    `odd?: number[];`\n\n`}`\n\n`const myObj: EvenOdds = Object.groupBy(...);`\n\n`myObj.even;`\n\n`//    ~~~~`\n\n`// Error to access this under 'strictNullChecks'.`\n\nThis is because there’s no way to guarantee in a general way that _all_ the keys were produced by `groupBy`.\n\nNote also that these methods are only accessible by configuring your `target` to `esnext` or adjusting your `lib` settings. We expect they will eventually be available under a stable `es2024` target.\n\nWe’d like to extend a thanks to [Kevin Gibbons](https://github.com/bakkot) for [adding the declarations to these `groupBy` methods](https://github.com/microsoft/TypeScript/pull/56805).\n\n## [](#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve)Support for `require()` calls in `--moduleResolution bundler` and `--module preserve`\n\nTypeScript has a `moduleResolution` option called `bundler` that is meant to model the way modern bundlers figure out which file an import path refers to. One of the limitations of the option is that it had to be paired with `--module esnext`, making it impossible to use the `import ... = require(...)` syntax.\n\nts\n\n`// previously errored`\n\n`import myModule = require(\"module/path\");`\n\nThat might not seem like a big deal if you’re planning on just writing standard ECMAScript `import`s, but there’s a difference when using a package with [conditional exports](https://nodejs.org/api/packages.html#conditional-exports).\n\nIn TypeScript 5.4, `require()` can now be used when setting the `module` setting to a new option called `preserve`.\n\nBetween `--module preserve` and `--moduleResolution bundler`, the two more accurately model what bundlers and runtimes like Bun will allow, and how they’ll perform module lookups. In fact, when using `--module preserve`, the `bundler` option will be implicitly set for `--moduleResolution` (along with `--esModuleInterop` and `--resolveJsonModule`)\n\njson\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"module\": \"preserve\",`\n\n        `// ^ also implies:`\n\n        `// \"moduleResolution\": \"bundler\",`\n\n        `// \"esModuleInterop\": true,`\n\n        `// \"resolveJsonModule\": true,`\n\n        `// ...`\n\n    `}`\n\n`}`\n\nUnder `--module preserve`, an ECMAScript `import` will always be emitted as-is, and `import ... = require(...)` will be emitted as a `require()` call (though in practice you may not even use TypeScript for emit, since it’s likely you’ll be using a bundler for your code). This holds true regardless of the file extension of the containing file. So the output of this code:\n\nts\n\n`import * as foo from \"some-package/foo\";`\n\n`import bar = require(\"some-package/bar\");`\n\nshould look something like this:\n\njs\n\n`import * as foo from \"some-package/foo\";`\n\n`var bar = require(\"some-package/bar\");`\n\nWhat this also means is that the syntax you choose directs how [conditional exports](https://nodejs.org/api/packages.html#conditional-exports) are matched. So in the above example, if the `package.json` of `some-package` looks like this:\n\njson\n\n`{`\n\n  `\"name\": \"some-package\",`\n\n  `\"version\": \"0.0.1\",`\n\n  `\"exports\": {`\n\n    `\"./foo\": {`\n\n        `\"import\": \"./esm/foo-from-import.mjs\",`\n\n        `\"require\": \"./cjs/foo-from-require.cjs\"`\n\n    `},`\n\n    `\"./bar\": {`\n\n        `\"import\": \"./esm/bar-from-import.mjs\",`\n\n        `\"require\": \"./cjs/bar-from-require.cjs\"`\n\n    `}`\n\n  `}`\n\n`}`\n\nTypeScript will resolve these paths to `[...]/some-package/esm/foo-from-import.mjs` and `[...]/some-package/cjs/bar-from-require.cjs`.\n\nFor more information, you can [read up on these new settings here](https://github.com/microsoft/TypeScript/pull/56785).\n\n## [](#checked-import-attributes-and-assertions)Checked Import Attributes and Assertions\n\nImport attributes and assertions are now checked against the global `ImportAttributes` type. This means that runtimes can now more accurately describe the import attributes\n\nts\n\n`// In some global file.`\n\n`interface ImportAttributes {`\n\n    `type: \"json\";`\n\n`}`\n\n`// In some other module`\n\n`import * as ns from \"foo\" with { type: \"not-json\" };`\n\n`//                                     ~~~~~~~~~~`\n\n`// error!`\n\n`//`\n\n`// Type '{ type: \"not-json\"; }' is not assignable to type 'ImportAttributes'.`\n\n`//  Types of property 'type' are incompatible.`\n\n`//    Type '\"not-json\"' is not assignable to type '\"json\"'.`\n\n[This change](https://github.com/microsoft/TypeScript/pull/56034) was provided thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk).\n\n## [](#quick-fix-for-adding-missing-parameters)Quick Fix for Adding Missing Parameters\n\nTypeScript now has a quick fix to add a new parameter to functions that are called with too many arguments.\n\n![A quick fix being offered when someFunction calls someHelperFunction with 2 more arguments than are expected.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2024/01/add-missing-params-5-4-beta-before.png)\n\n![The missing arguments have been added to someHelperFunction after the quick fix was applied.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2024/01/add-missing-params-5-4-beta-after.png)\n\nThis can be useful when threading a new argument through several existing functions, which can be cumbersome today.\n\n[This quick fix](https://github.com/microsoft/TypeScript/pull/56411) was provided courtsey of [Oleksandr Tarasiuk](https://github.com/a-tarasyuk).\n\n## [](#upcoming-changes-from-typescript-50-deprecations)Upcoming Changes from TypeScript 5.0 Deprecations\n\nTypeScript 5.0 deprecated the following options and behaviors:\n\n*   `charset`\n*   `target: ES3`\n*   `importsNotUsedAsValues`\n*   `noImplicitUseStrict`\n*   `noStrictGenericChecks`\n*   `keyofStringsOnly`\n*   `suppressExcessPropertyErrors`\n*   `suppressImplicitAnyIndexErrors`\n*   `out`\n*   `preserveValueImports`\n*   `prepend` in project references\n*   implicitly OS-specific `newLine`\n\nTo continue using them, developers using TypeScript 5.0 and other more recent versions have had to specify a new option called `ignoreDeprecations` with the value `\"5.0\"`.\n\nHowever, TypScript 5.4 will be the last version in which these will continue to function as normal. By TypeScript 5.5 (likely June 2024), these will become hard errors, and code using them will need to be migrated away.\n\nFor more information, you can [read up on this plan on GitHub](https://github.com/microsoft/TypeScript/issues/51909), which contains suggestions in how to best adapt your codebase.\n\n## [](#notable-behavioral-changes)Notable Behavioral Changes\n\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\n\n### [](#libdts-changes)`lib.d.ts` Changes\n\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, [see the DOM updates for TypeScript 5.4](https://github.com/microsoft/TypeScript/pull/57027).\n\n### [](#more-accurate-conditional-type-constraints)More Accurate Conditional Type Constraints\n\nThe following code no longer allows the second variable declaration in the function `foo`.\n\nts\n\n`type IsArray<T> = T extends any[] ? true : false;`\n\n`function foo<U extends object>(x: IsArray<U>) {`\n\n    `let first: true = x;    // Error`\n\n    `let second: false = x;  // Error, but previously wasn't`\n\n`}`\n\nPreviously, when TypeScript checked the initializer for `second`, it needed to determine whether `IsArray<U>` was assignable to the unit type `false`. While `IsArray<U>` isn’t compatible any obvious way, TypeScript looks at the _constraint_ of that type as well. In a conditional type like `T extends Foo ? TrueBranch : FalseBranch`, where `T` is generic, the type system would look at the constraint of `T`, substitute it in for `T` itself, and decide on either the true or false branch.\n\nBut this behavior was inaccurate because it was overly eager. Even if the constraint of `T` isn’t assignable to `Foo`, that doesn’t mean that it won’t be instantiated with something that is. And so the more correct behavior is to produce a union type for the constraint of the conditional type in cases where it can’t be proven that `T` _never_ or _always_ extends `Foo.`\n\nTypeScript 5.4 adopts this more accurate behavior. What this means in practice is that you may begin to find that some conditional type instances are no longer compatible with their branches.\n\n[You can read about the specific changes here](https://github.com/microsoft/TypeScript/pull/56004).\n\n### [](#more-aggressive-reduction-of-intersections-between-type-variables-and-primitive-types)More Aggressive Reduction of Intersections Between Type Variables and Primitive Types\n\nTypeScript now reduces intersections with type variables and primitives more aggressively, depending on how the type variable’s constraint overlaps with those primitives.\n\nts\n\n`declare function intersect<T, U>(x: T, y: U): T & U;`\n\n`function foo<T extends \"abc\" | \"def\">(x: T, str: string, num: number) {`\n\n    `// Was 'T & string', now is just 'T'`\n\n    `let a = intersect(x, str);`\n\n    `// Was 'T & number', now is just 'never'`\n\n    `let b = intersect(x, num)`\n\n    `// Was '(T & \"abc\") | (T & \"def\")', now is just 'T'`\n\n    `let c = Math.random() < 0.5 ?`\n\n        `intersect(x, \"abc\") :`\n\n        `intersect(x, \"def\");`\n\n`}`\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/56515).\n\n### [](#improved-checking-against-template-strings-with-interpolations)Improved Checking Against Template Strings with Interpolations\n\nTypeScript now more accurately checks whether or not strings are assignable to the placeholder slots of a template string type.\n\nts\n\n`function a<T extends {id: string}>() {`\n\n    ``let x: `-${keyof T & string}`;``\n\n    `// Used to error, now doesn't.`\n\n    `x = \"-id\";`\n\n`}`\n\nThis behavior is more desirable, but may cause breaks in code using constructs like conditional types, where these rule changes are easy to witness.\n\n[See this change](https://github.com/microsoft/TypeScript/pull/56598) for more details.\n\n### [](#errors-when-type-only-imports-conflict-with-local-values)Errors When Type-Only Imports Conflict with Local Values\n\nPreviously, TypeScript would permit the following code under `isolatedModules` if the import to `Something` only referred to a type.\n\nts\n\n`import { Something } from \"./some/path\";`\n\n`let Something = 123;`\n\nHowever, it’s not safe for single-file compilers to assume whether it’s “safe” to drop the `import`, even if the code is guaranteed to fail at runtime. In TypeScript 5.4, this code will trigger an error like the following:\n\n`Import 'Something' conflicts with local value, so must be declared with a type-only import when 'isolatedModules' is enabled.`\n\nThe fix should be to either make a local rename, or, as the error states, add the `type` modifier to the import:\n\nts\n\n`import type { Something } from \"./some/path\";`\n\n`// or`\n\n`import { type Something } from \"./some/path\";`\n\n[See more information on the change itself](https://github.com/microsoft/TypeScript/pull/56354).\n\n### [](#new-enum-assignability-restrictions)New Enum Assignability Restrictions\n\nWhen two enums have the same declared names and enum member names, they were previously always considered compatible; however, when the values were known, TypeScript would silently allow them to have differing values.\n\nTypeScript 5.4 tightens this restriction by requiring the values to be identical when they are known.\n\nts\n\n`namespace First {`\n\n    `export enum SomeEnum {`\n\n        `A = 0,`\n\n        `B = 1,`\n\n    `}`\n\n`}`\n\n`namespace Second {`\n\n    `export enum SomeEnum {`\n\n        `A = 0,`\n\n        `B = 2,`\n\n    `}`\n\n`}`\n\n`function foo(x: First.SomeEnum, y: Second.SomeEnum) {`\n\n    `// Both used to be compatible - no longer the case,`\n\n    `// TypeScript errors with something like:`\n\n    `//`\n\n    `//  Each declaration of 'SomeEnum.B' differs in its value, where '1' was expected but '2' was given.`\n\n    `x = y;`\n\n    `y = x;`\n\n`}`\n\nAdditionally, there are new restrictions for when one of the enum members does not have a statically known value. In these cases, the other enum must at least be implicitly numeric (e.g. it has no statically resolved initializer), or it is explicitly numeric (meaning TypeScript could resolve the value to something numeric). Practically speaking, what this means is that string enum members are only ever compatible with other string enums of the same value.\n\nts\n\n`namespace First {`\n\n    `export declare enum SomeEnum {`\n\n        `A,`\n\n        `B,`\n\n    `}`\n\n`}`\n\n`namespace Second {`\n\n    `export declare enum SomeEnum {`\n\n        `A,`\n\n        `B = \"some known string\",`\n\n    `}`\n\n`}`\n\n`function foo(x: First.SomeEnum, y: Second.SomeEnum) {`\n\n    `// Both used to be compatible - no longer the case,`\n\n    `// TypeScript errors with something like:`\n\n    `//`\n\n    `//  One value of 'SomeEnum.B' is the string '\"some known string\"', and the other is assumed to be an unknown numeric value.`\n\n    `x = y;`\n\n    `y = x;`\n\n`}`\n\nFor more information, [see the pull request that introduced this change](https://github.com/microsoft/TypeScript/pull/55924).\n\n### [](#name-restrictions-on-enum-members)Name Restrictions on Enum Members\n\nTypeScript no longer allows enum members to use the names `Infinity`, `-Infinity`, or `NaN`.\n\nts\n\n`// Errors on all of these:`\n\n`//`\n\n`//  An enum member cannot have a numeric name.`\n\n`enum E {`\n\n    `Infinity = 0,`\n\n    `\"-Infinity\" = 1,`\n\n    `NaN = 2,`\n\n`}`\n\n[See more details here](https://github.com/microsoft/TypeScript/pull/56161).\n\n### [](#better-mapped-type-preservation-over-tuples-with-any-rest-elements)Better Mapped Type Preservation Over Tuples with `any` Rest Elements\n\nPreviously, applying a mapped type with `any` into a tuple would create an `any` element type. This is undesirable and is now fixed.\n\nts\n\n`Promise.all([\"\", ...([] as any)])`\n\n    `.then((result) => {`\n\n        `const head = result[0];       // 5.3: any, 5.4: string`\n\n        `const tail = result.slice(1); // 5.3 any, 5.4: any[]`\n\n    `});`\n\nFor more information, see [the fix](https://github.com/microsoft/TypeScript/pull/57031) along with [the follow-on discussion around behavioral changes](https://github.com/microsoft/TypeScript/issues/57389) and [further tweaks](https://github.com/microsoft/TypeScript/issues/57389).\n\n### [](#emit-changes)Emit Changes\n\nWhile not a breaking change per se, developers may have implicitly taken dependencies on TypeScript’s JavaScript or declaration emit outputs. The following are notable changes.\n\n*   [Preserve type parameter names more often when shadowed](https://github.com/microsoft/TypeScript/pull/55820)\n*   [Move complex parameter lists of async function into downlevel generator body](https://github.com/microsoft/TypeScript/pull/56296)\n*   [Do not remove binding alias in function declarations](https://github.com/microsoft/TypeScript/pull/57020)\n*   [ImportAttributes should go through the same emit phases when in an ImportTypeNode](https://github.com/microsoft/TypeScript/pull/56395)",
    "title": "TypeScript: Documentation - TypeScript 5.4",
    "description": "TypeScript 5.4 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html",
    "markdown": "# TypeScript: Documentation - Module: Function\n\nFor example, when you want to work with JavaScript code which looks like:\n\nts\n\n`import greeter from \"super-greeter\";`\n\n`greeter(2);`\n\n`greeter(\"Hello world\");`\n\nTo handle both importing via UMD and modules:\n\nts\n\n`// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]`\n\n`// Project: [~THE PROJECT NAME~]`\n\n`// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>`\n\n`/*~ This is the module template file for function modules.`\n\n `*~ You should rename it to index.d.ts and place it in a folder with the same name as the module.`\n\n `*~ For example, if you were writing a file for \"super-greeter\", this`\n\n `*~ file should be 'super-greeter/index.d.ts'`\n\n `*/`\n\n`// Note that ES6 modules cannot directly export class objects.`\n\n`// This file should be imported using the CommonJS-style:`\n\n`//   import x = require('[~THE MODULE~]');`\n\n`//`\n\n`// Alternatively, if --allowSyntheticDefaultImports or`\n\n`// --esModuleInterop is turned on, this file can also be`\n\n`// imported as a default import:`\n\n`//   import x from '[~THE MODULE~]';`\n\n`//`\n\n`// Refer to the TypeScript documentation at`\n\n`// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require`\n\n`// to understand common workarounds for this limitation of ES6 modules.`\n\n`/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when`\n\n `*~ loaded outside a module loader environment, declare that global here.`\n\n `*~ Otherwise, delete this declaration.`\n\n `*/`\n\n`export as namespace myFuncLib;`\n\n`/*~ This declaration specifies that the function`\n\n `*~ is the exported object from the file`\n\n `*/`\n\n`export = Greeter;`\n\n`/*~ This example shows how to have multiple overloads for your function */`\n\n`declare function Greeter(name: string): Greeter.NamedReturnType;`\n\n`declare function Greeter(length: number): Greeter.LengthReturnType;`\n\n`/*~ If you want to expose types from your module as well, you can`\n\n `*~ place them in this block. Often you will want to describe the`\n\n `*~ shape of the return type of the function; that type should`\n\n `*~ be declared in here, as this example shows.`\n\n `*~`\n\n `*~ Note that if you decide to include this namespace, the module can be`\n\n `*~ incorrectly imported as a namespace object, unless`\n\n `*~ --esModuleInterop is turned on:`\n\n `*~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!`\n\n `*/`\n\n`declare namespace Greeter {`\n\n  `export interface LengthReturnType {`\n\n    `width: number;`\n\n    `height: number;`\n\n  `}`\n\n  `export interface NamedReturnType {`\n\n    `firstName: string;`\n\n    `lastName: string;`\n\n  `}`\n\n  `/*~ If the module also has properties, declare them here. For example,`\n\n   `*~ this declaration says that this code is legal:`\n\n   `*~   import f = require('super-greeter');`\n\n   `*~   console.log(f.defaultName);`\n\n   `*/`\n\n  `export const defaultName: string;`\n\n  `export let defaultLength: number;`\n\n`}`",
    "title": "TypeScript: Documentation - Module: Function",
    "description": "",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html",
    "markdown": "# TypeScript: Documentation - Module: Class\n\nFor example, when you want to work with JavaScript code which looks like:\n\nts\n\n`const Greeter = require(\"super-greeter\");`\n\n`const greeter = new Greeter();`\n\n`greeter.greet();`\n\nTo handle both importing via UMD and modules:\n\nts\n\n`// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]`\n\n`// Project: [~THE PROJECT NAME~]`\n\n`// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>`\n\n`/*~ This is the module template file for class modules.`\n\n `*~ You should rename it to index.d.ts and place it in a folder with the same name as the module.`\n\n `*~ For example, if you were writing a file for \"super-greeter\", this`\n\n `*~ file should be 'super-greeter/index.d.ts'`\n\n `*/`\n\n`// Note that ES6 modules cannot directly export class objects.`\n\n`// This file should be imported using the CommonJS-style:`\n\n`//   import x = require('[~THE MODULE~]');`\n\n`//`\n\n`// Alternatively, if --allowSyntheticDefaultImports or`\n\n`// --esModuleInterop is turned on, this file can also be`\n\n`// imported as a default import:`\n\n`//   import x from '[~THE MODULE~]';`\n\n`//`\n\n`// Refer to the TypeScript documentation at`\n\n`// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require`\n\n`// to understand common workarounds for this limitation of ES6 modules.`\n\n`/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when`\n\n `*~ loaded outside a module loader environment, declare that global here.`\n\n `*~ Otherwise, delete this declaration.`\n\n `*/`\n\n`export as namespace \"super-greeter\";`\n\n`/*~ This declaration specifies that the class constructor function`\n\n `*~ is the exported object from the file`\n\n `*/`\n\n`export = Greeter;`\n\n`/*~ Write your module's methods and properties in this class */`\n\n`declare class Greeter {`\n\n  `constructor(customGreeting?: string);`\n\n  `greet: void;`\n\n  `myMethod(opts: MyClass.MyClassMethodOptions): number;`\n\n`}`\n\n`/*~ If you want to expose types from your module as well, you can`\n\n `*~ place them in this block.`\n\n `*~`\n\n `*~ Note that if you decide to include this namespace, the module can be`\n\n `*~ incorrectly imported as a namespace object, unless`\n\n `*~ --esModuleInterop is turned on:`\n\n `*~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!`\n\n `*/`\n\n`declare namespace MyClass {`\n\n  `export interface MyClassMethodOptions {`\n\n    `width?: number;`\n\n    `height?: number;`\n\n  `}`\n\n`}`",
    "title": "TypeScript: Documentation - Module: Class",
    "description": "",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html",
    "markdown": "# TypeScript: Documentation - TypeScript 5.3\n\n## [](#import-attributes)Import Attributes\n\nTypeScript 5.3 supports the latest updates to the [import attributes](https://github.com/tc39/proposal-import-attributes) proposal.\n\nOne use-case of import attributes is to provide information about the expected format of a module to the runtime.\n\nts\n\n`// We only want this to be interpreted as JSON,`\n\n``// not a runnable/malicious JavaScript file with a `.json` extension.``\n\n`import obj from \"./something.json\" with { type: \"json\" };`\n\nThe contents of these attributes are not checked by TypeScript since they’re host-specific, and are simply left alone so that browsers and runtimes can handle them (and possibly error).\n\nts\n\n`// TypeScript is fine with this.`\n\n`// But your browser? Probably not.`\n\n`import * as foo from \"./foo.js\" with { type: \"fluffy bunny\" };`\n\nDynamic `import()` calls can also use import attributes through a second argument.\n\nts\n\n`const obj = await import(\"./something.json\", {`\n\n    `with: { type: \"json\" }`\n\n`});`\n\nThe expected type of that second argument is defined by a type called `ImportCallOptions`, which by default just expects a property called `with`.\n\nNote that import attributes are an evolution of an earlier proposal called [“import assertions”, which were implemented in TypeScript 4.5](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#import-assertions). The most obvious difference is the use of the `with` keyword over the `assert` keyword. But the less-visible difference is that runtimes are now free to use attributes to guide the resolution and interpretation of import paths, whereas import assertions could only assert some characteristics after loading a module.\n\nOver time, TypeScript will be deprecating the old syntax for import assertions in favor of the proposed syntax for import attributes. Existing code using `assert` should migrate towards the `with` keyword. New code that needs an import attribute should use `with` exclusively.\n\nWe’d like to thank [Oleksandr Tarasiuk](https://github.com/a-tarasyuk) for [implementing this proposal](https://github.com/microsoft/TypeScript/pull/54242)! And we’d also like to call out [Wenlu Wang](https://github.com/Kingwl) for their implementation of [import assertions](https://github.com/microsoft/TypeScript/pull/40698)!\n\n## [](#stable-support-resolution-mode-in-import-types)Stable Support `resolution-mode` in Import Types\n\nIn TypeScript 4.7, TypeScript added support for a `resolution-mode` attribute in `/// <reference types=\"...\" />` to control whether a specifier should be resolved via `import` or `require` semantics.\n\nts\n\n`/// <reference types=\"pkg\" resolution-mode=\"require\" />`\n\n`// or`\n\n`/// <reference types=\"pkg\" resolution-mode=\"import\" />`\n\nA corresponding field was added to import assertions on type-only imports as well; however, it was only supported in nightly versions of TypeScript. The rationale was that in spirit, import _assertions_ were not intended to guide module resolution. So this feature was shipped experimentally in a nightly-only mode to get more feedback.\n\nBut given that _[import attributes](#import-attributes)_ can guide resolution, and that we’ve seen reasonable use-cases, TypeScript 5.3 now supports the `resolution-mode` attribute for `import type`.\n\nts\n\n`` // Resolve `pkg` as if we were importing with a `require()` ``\n\n`import type { TypeFromRequire } from \"pkg\" with {`\n\n    `\"resolution-mode\": \"require\"`\n\n`};`\n\n`` // Resolve `pkg` as if we were importing with an `import` ``\n\n`import type { TypeFromImport } from \"pkg\" with {`\n\n    `\"resolution-mode\": \"import\"`\n\n`};`\n\n`export interface MergedType extends TypeFromRequire, TypeFromImport {}`\n\nThese import attributes can also be used on `import()` types.\n\nts\n\n`export type TypeFromRequire =`\n\n    `import(\"pkg\", { with: { \"resolution-mode\": \"require\" } }).TypeFromRequire;`\n\n`export type TypeFromImport =`\n\n    `import(\"pkg\", { with: { \"resolution-mode\": \"import\" } }).TypeFromImport;`\n\n`export interface MergedType extends TypeFromRequire, TypeFromImport {}`\n\nFor more information, [check out the change here](https://github.com/microsoft/TypeScript/pull/55725)\n\n## [](#resolution-mode-supported-in-all-module-modes)`resolution-mode` Supported in All Module Modes\n\nPreviously, using `resolution-mode` was only allowed under the `moduleResolution` options `node16` and `nodenext`. To make it easier to look up modules specifically for type purposes, `resolution-mode` now works appropriately in all other `moduleResolution` options like `bundler`, `node10`, and simply doesn’t error under `classic`.\n\nFor more information, [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/55725).\n\n## [](#switch-true-narrowing)`switch (true)` Narrowing\n\nTypeScript 5.3 now can perform narrowing based on conditions in each `case` clause within a `switch (true)`.\n\nts\n\n`function f(x: unknown) {`\n\n    `switch (true) {`\n\n        `case typeof x === \"string\":`\n\n            `// 'x' is a 'string' here`\n\n            `console.log(x.toUpperCase());`\n\n            `// falls through...`\n\n        `case Array.isArray(x):`\n\n            `// 'x' is a 'string | any[]' here.`\n\n            `console.log(x.length);`\n\n            `// falls through...`\n\n        `default:`\n\n          `// 'x' is 'unknown' here.`\n\n          `// ...`\n\n    `}`\n\n`}`\n\n[This feature](https://github.com/microsoft/TypeScript/pull/55991) was spearheaded [initial work](https://github.com/microsoft/TypeScript/pull/53681) by [Mateusz Burzyński](https://github.com/Andarist) We’d like to extend a “thank you!” for this contribution.\n\n## [](#narrowing-on-comparisons-to-booleans)Narrowing On Comparisons to Booleans\n\nOccasionally you may find yourself performing a direct comparison with `true` or `false` in a condition. Usually these are unnecessary comparisons, but you might prefer it as a point of style, or to avoid certain issues around JavaScript truthiness. Regardless, previously TypeScript just didn’t recognize such forms when performing narrowing.\n\nTypeScript 5.3 now keeps up and understands these expressions when narrowing variables.\n\nts\n\n`interface A {`\n\n    `a: string;`\n\n`}`\n\n`interface B {`\n\n    `b: string;`\n\n`}`\n\n`type MyType = A | B;`\n\n`function isA(x: MyType): x is A {`\n\n    `return \"a\" in x;`\n\n`}`\n\n`function someFn(x: MyType) {`\n\n    `if (isA(x) === true) {`\n\n        `console.log(x.a); // works!`\n\n    `}`\n\n`}`\n\nWe’d like to thank [Mateusz Burzyński](https://github.com/Andarist) for [the pull request](https://github.com/microsoft/TypeScript/pull/53681) that implemented this.\n\n## [](#instanceof-narrowing-through-symbolhasinstance)`instanceof` Narrowing Through `Symbol.hasInstance`\n\nA slightly esoteric feature of JavaScript is that it is possible to override the behavior of the `instanceof` operator. To do so, the value on the right side of the `instanceof` operator needs to have a specific method named by `Symbol.hasInstance`.\n\njs\n\n`class Weirdo {`\n\n    `static [Symbol.hasInstance](testedValue) {`\n\n        `// wait, what?`\n\n        `return testedValue === undefined;`\n\n    `}`\n\n`}`\n\n`// false`\n\n`console.log(new Thing() instanceof Weirdo);`\n\n`// true`\n\n`console.log(undefined instanceof Weirdo);`\n\nTo better model this behavior in `instanceof`, TypeScript now checks if such a `[Symbol.hasInstance]` method exists and is declared as a type predicate function. If it does, the tested value on the left side of the `instanceof` operator will be narrowed appropriately by that type predicate.\n\nts\n\n`interface PointLike {`\n\n    `x: number;`\n\n    `y: number;`\n\n`}`\n\n`class Point implements PointLike {`\n\n    `x: number;`\n\n    `y: number;`\n\n    `constructor(x: number, y: number) {`\n\n        `this.x = x;`\n\n        `this.y = y;`\n\n    `}`\n\n    `distanceFromOrigin() {`\n\n        `return Math.sqrt(this.x ** 2 + this.y ** 2);`\n\n    `}`\n\n    `static [Symbol.hasInstance](val: unknown): val is PointLike {`\n\n        `return !!val && typeof val === \"object\" &&`\n\n            `\"x\" in val && \"y\" in val &&`\n\n            `typeof val.x === \"number\" &&`\n\n            `typeof val.y === \"number\";`\n\n    `}`\n\n`}`\n\n`function f(value: unknown) {`\n\n    `if (value instanceof Point) {`\n\n        `// Can access both of these - correct!`\n\n        `value.x;`\n\n        `value.y;`\n\n        `// Can't access this - we have a 'PointLike',`\n\n        `// but we don't *actually* have a 'Point'.`\n\n        `value.distanceFromOrigin();`\n\n    `}`\n\n`}`\n\nAs you can see in this example, `Point` defines its own `[Symbol.hasInstance]` method. It actually acts as a custom type guard over a separate type called `PointLike`. In the function `f`, we were able to narrow `value` down to a `PointLike` with `instanceof`, but _not_ a `Point`. That means that we can access the properties `x` and `y`, but not the method `distanceFromOrigin`.\n\nFor more information, you can [read up on this change here](https://github.com/microsoft/TypeScript/pull/55052).\n\n## [](#checks-for-super-property-accesses-on-instance-fields)Checks for `super` Property Accesses on Instance Fields\n\nIn JavaScript, it’s possible to access a declaration in a base class through the `super` keyword.\n\njs\n\n`class Base {`\n\n    `someMethod() {`\n\n        `console.log(\"Base method called!\");`\n\n    `}`\n\n`}`\n\n`class Derived extends Base {`\n\n    `someMethod() {`\n\n        `console.log(\"Derived method called!\");`\n\n        `super.someMethod();`\n\n    `}`\n\n`}`\n\n`new Derived().someMethod();`\n\n`// Prints:`\n\n`//   Derived method called!`\n\n`//   Base method called!`\n\nThis is different from writing something like `this.someMethod()`, since that could invoke an overridden method. This is a subtle distinction, made more subtle by the fact that often the two can be interchangeable if a declaration is never overridden at all.\n\njs\n\n`class Base {`\n\n    `someMethod() {`\n\n        `console.log(\"someMethod called!\");`\n\n    `}`\n\n`}`\n\n`class Derived extends Base {`\n\n    `someOtherMethod() {`\n\n        `// These act identically.`\n\n        `this.someMethod();`\n\n        `super.someMethod();`\n\n    `}`\n\n`}`\n\n`new Derived().someOtherMethod();`\n\n`// Prints:`\n\n`//   someMethod called!`\n\n`//   someMethod called!`\n\nThe problem is using them interchangeably is that `super` only works on members declared on the prototype — _not_ instance properties. That means that if you wrote `super.someMethod()`, but `someMethod` was defined as a field, you’d get a runtime error!\n\nts\n\n`class Base {`\n\n    `someMethod = () => {`\n\n        `console.log(\"someMethod called!\");`\n\n    `}`\n\n`}`\n\n`class Derived extends Base {`\n\n    `someOtherMethod() {`\n\n        `super.someMethod();`\n\n    `}`\n\n`}`\n\n`new Derived().someOtherMethod();`\n\n`// 💥`\n\n`// Doesn't work because 'super.someMethod' is 'undefined'.`\n\nTypeScript 5.3 now more-closely inspects `super` property accesses/method calls to see if they correspond to class fields. If they do, we’ll now get a type-checking error.\n\n[This check](https://github.com/microsoft/TypeScript/pull/54056) was contributed thanks to [Jack Works](https://github.com/Jack-Works)!\n\n## [](#interactive-inlay-hints-for-types)Interactive Inlay Hints for Types\n\nTypeScript’s inlay hints now support jumping to the definition of types! This makes it easier to casually navigate your code.\n\n![Ctrl-clicking an inlay hint to jump to the definition of a parameter type.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/10/clickable-inlay-hints-for-types-5-3-beta.gif)\n\nSee more at [the implementation here](https://github.com/microsoft/TypeScript/pull/55141).\n\n## [](#settings-to-prefer-type-auto-imports)Settings to Prefer `type` Auto-Imports\n\nPreviously when TypeScript generated auto-imports for something in a type position, it would add a `type` modifier based on your settings. For example, when getting an auto-import on `Person` in the following:\n\nts\n\n`export let p: Person`\n\nTypeScript’s editing experience would usually add an import for `Person` as:\n\nts\n\n`import { Person } from \"./types\";`\n\n`export let p: Person`\n\nand under certain settings like `verbatimModuleSyntax`, it would add the `type` modifier:\n\nts\n\n`import { type Person } from \"./types\";`\n\n`export let p: Person`\n\nHowever, maybe your codebase isn’t able to use some of these options; or you just have a preference for explicit `type` imports when possible.\n\n[With a recent change](https://github.com/microsoft/TypeScript/pull/56090), TypeScript now enables this to be an editor-specific option. In Visual Studio Code, you can enable it in the UI under “TypeScript › Preferences: Prefer Type Only Auto Imports”, or as the JSON configuration option `typescript.preferences.preferTypeOnlyAutoImports`\n\n## [](#optimizations-by-skipping-jsdoc-parsing)Optimizations by Skipping JSDoc Parsing\n\nWhen running TypeScript via `tsc`, the compiler will now avoid parsing JSDoc. This drops parsing time on its own, but also reduces memory usage to store comments along with time spent in garbage collection. All-in-all, you should see slightly faster compiles and quicker feedback in `--watch` mode.\n\n[The specific changes can be viewed here](https://github.com/microsoft/TypeScript/pull/52921).\n\nBecause not every tool using TypeScript will need to store JSDoc (e.g. typescript-eslint and Prettier), this parsing strategy has been surfaced as part of the API itself. This can enable these tools to gain the same memory and speed improvements we’ve brought to the TypeScript compiler. The new options for comment parsing strategy are described in `JSDocParsingMode`. More information is available [on this pull request](https://github.com/microsoft/TypeScript/pull/55739).\n\n## [](#optimizations-by-comparing-non-normalized-intersections)Optimizations by Comparing Non-Normalized Intersections\n\nIn TypeScript, unions and intersections always follow a specific form, where intersections can’t contain union types. That means that when we create an intersection over a union like `A & (B | C)`, that intersection will be normalized into `(A & B) | (A & C)`. Still, in some cases the type system will maintain the original form for display purposes.\n\nIt turns out that the original form can be used for some clever fast-path comparisons between types.\n\nFor example, let’s say we have `SomeType & (Type1 | Type2 | ... | Type99999NINE)` and we want to see if that’s assignable to `SomeType`. Recall that we don’t really have an intersection as our source type — we have a union that looks like `(SomeType & Type1) | (SomeType & Type2) | ... |(SomeType & Type99999NINE)`. When checking if a union is assignable to some target type, we have to check if _every_ member of the union is assignable to the target type, and that can be very slow.\n\nIn TypeScript 5.3, we peek at the original intersection form that we were able to tuck away. When we compare the types, we do a quick check to see if the target exists in any constituent of the source intersection.\n\nFor more information, [see this pull request](https://github.com/microsoft/TypeScript/pull/55851).\n\n## [](#consolidation-between-tsserverlibraryjs-and-typescriptjs)Consolidation Between `tsserverlibrary.js` and `typescript.js`\n\nTypeScript itself ships two library files: `tsserverlibrary.js` and `typescript.js`. There are certain APIs available only in `tsserverlibrary.js` (like the `ProjectService` API), which may be useful to some importers. Still, the two are distinct bundles with a lot of overlap, duplicating code in the package. What’s more, it can be challenging to consistently use one over the other due to auto-imports or muscle memory. Accidentally loading both modules is far too easy, and code may not work properly on a different instance of the API. Even if it does work, loading a second bundle increases resource usage.\n\nGiven this, we’ve decided to consolidate the two. `typescript.js` now contains what `tsserverlibrary.js` used to contain, and `tsserverlibrary.js` now simply re-exports `typescript.js`. Comparing the before/after of this consolidation, we saw the following reduction in package size:\n\n|     | Before | After | Diff | Diff (percent) |\n| --- | --- | --- | --- | --- |\n| Packed | 6.90 MiB | 5.48 MiB | \\-1.42 MiB | \\-20.61% |\n| Unpacked | 38.74 MiB | 30.41 MiB | \\-8.33 MiB | \\-21.50% |\n\n|     | Before | After | Diff | Diff (percent) |\n| --- | --- | --- | --- | --- |\n| `lib/tsserverlibrary.d.ts` | 570.95 KiB | 865.00 B | \\-570.10 KiB | \\-99.85% |\n| `lib/tsserverlibrary.js` | 8.57 MiB | 1012.00 B | \\-8.57 MiB | \\-99.99% |\n| `lib/typescript.d.ts` | 396.27 KiB | 570.95 KiB | +174.68 KiB | +44.08% |\n| `lib/typescript.js` | 7.95 MiB | 8.57 MiB | +637.53 KiB | +7.84% |\n\nIn other words, this is over a 20.5% reduction in package size.\n\nFor more information, you can [see the work involved here](https://github.com/microsoft/TypeScript/pull/55273).\n\n## [](#breaking-changes-and-correctness-improvements)Breaking Changes and Correctness Improvements\n\n### [](#libdts-changes)`lib.d.ts` Changes\n\nTypes generated for the DOM may have an impact on your codebase. For more information, [see the DOM updates for TypeScript 5.3](https://github.com/microsoft/TypeScript/pull/55798).\n\n### [](#checks-for-super-accesses-on-instance-properties)Checks for `super` Accesses on Instance Properties\n\nTypeScript 5.3 now detects when the declaration referenced by a `super.` property access is a class field and issues an error. This prevents errors that might occur at runtime.\n\n[See more on this change here](https://github.com/microsoft/TypeScript/pull/54056).",
    "title": "TypeScript: Documentation - TypeScript 5.3",
    "description": "TypeScript 5.3 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html",
    "markdown": "# TypeScript: Documentation - Global .d.ts\n\n## [](#global-libraries)Global Libraries\n\nA _global_ library is one that can be accessed from the global scope (i.e. without using any form of `import`). Many libraries simply expose one or more global variables for use. For example, if you were using [jQuery](https://jquery.com/), the `$` variable can be used by simply referring to it:\n\nts\n\n`$(() => {`\n\n  `console.log(\"hello!\");`\n\n`});`\n\nYou’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:\n\nhtml\n\n`<script src=\"http://a.great.cdn.for/someLib.js\"></script>`\n\nToday, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.\n\n## [](#identifying-a-global-library-from-code)Identifying a Global Library from Code\n\nGlobal library code is usually extremely simple. A global “Hello, world” library might look like this:\n\njs\n\n`function createGreeting(s) {`\n\n  `return \"Hello, \" + s;`\n\n`}`\n\nor like this:\n\njs\n\n`window.createGreeting = function (s) {`\n\n  `return \"Hello, \" + s;`\n\n`};`\n\nWhen looking at the code of a global library, you’ll usually see:\n\n*   Top-level `var` statements or `function` declarations\n*   One or more assignments to `window.someName`\n*   Assumptions that DOM primitives like `document` or `window` exist\n\nYou _won’t_ see:\n\n*   Checks for, or usage of, module loaders like `require` or `define`\n*   CommonJS/Node.js-style imports of the form `var fs = require(\"fs\");`\n*   Calls to `define(...)`\n*   Documentation describing how to `require` or import the library\n\n## [](#examples-of-global-libraries)Examples of Global Libraries\n\nBecause it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have _no_ dependencies) may still be global.\n\n## [](#global-library-template)Global Library Template\n\nYou can see an example DTS below:\n\nts\n\n`// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]`\n\n`// Project: [~THE PROJECT NAME~]`\n\n`// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>`\n\n`/*~ If this library is callable (e.g. can be invoked as myLib(3)),`\n\n `*~ include those call signatures here.`\n\n `*~ Otherwise, delete this section.`\n\n `*/`\n\n`declare function myLib(a: string): string;`\n\n`declare function myLib(a: number): number;`\n\n`/*~ If you want the name of this library to be a valid type name,`\n\n `*~ you can do so here.`\n\n `*~`\n\n `*~ For example, this allows us to write 'var x: myLib';`\n\n `*~ Be sure this actually makes sense! If it doesn't, just`\n\n `*~ delete this declaration and add types inside the namespace below.`\n\n `*/`\n\n`interface myLib {`\n\n  `name: string;`\n\n  `length: number;`\n\n  `extras?: string[];`\n\n`}`\n\n`/*~ If your library has properties exposed on a global variable,`\n\n `*~ place them here.`\n\n `*~ You should also place types (interfaces and type alias) here.`\n\n `*/`\n\n`declare namespace myLib {`\n\n  `//~ We can write 'myLib.timeout = 50;'`\n\n  `let timeout: number;`\n\n  `//~ We can access 'myLib.version', but not change it`\n\n  `const version: string;`\n\n  `//~ There's some class we can create via 'let c = new myLib.Cat(42)'`\n\n  `//~ Or reference e.g. 'function f(c: myLib.Cat) { ... }`\n\n  `class Cat {`\n\n    `constructor(n: number);`\n\n    `//~ We can read 'c.age' from a 'Cat' instance`\n\n    `readonly age: number;`\n\n    `//~ We can invoke 'c.purr()' from a 'Cat' instance`\n\n    `purr(): void;`\n\n  `}`\n\n  `//~ We can declare a variable as`\n\n  `//~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'`\n\n  `interface CatSettings {`\n\n    `weight: number;`\n\n    `name: string;`\n\n    `tailLength?: number;`\n\n  `}`\n\n  `//~ We can write 'const v: myLib.VetID = 42;'`\n\n  `//~  or 'const v: myLib.VetID = \"bob\";'`\n\n  `type VetID = string | number;`\n\n  `//~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'`\n\n  `function checkCat(c: Cat, s?: VetID);`\n\n`}`",
    "title": "TypeScript: Documentation - Global .d.ts",
    "description": "",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html",
    "markdown": "# TypeScript: Documentation - Global: Modifying Module\n\n## [](#global-modifying-modules)_Global-modifying Modules_\n\nA _global-modifying module_ alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to `String.prototype` when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.\n\n## [](#identifying-global-modifying-modules)Identifying global-modifying modules\n\nGlobal-modifying modules are generally easy to identify from their documentation. In general, they’re similar to global plugins, but need a `require` call to activate their effects.\n\nYou might see documentation like this:\n\njs\n\n`// 'require' call that doesn't use its return value`\n\n`var unused = require(\"magic-string-time\");`\n\n`/* or */`\n\n`require(\"magic-string-time\");`\n\n`var x = \"hello, world\";`\n\n`// Creates new methods on built-in types`\n\n`console.log(x.startsWithHello());`\n\n`var y = [1, 2, 3];`\n\n`// Creates new methods on built-in types`\n\n`console.log(y.reverseAndSort());`\n\nHere is an example\n\nts\n\n`// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]`\n\n`// Project: [~THE PROJECT NAME~]`\n\n`// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>`\n\n`/*~ This is the global-modifying module template file. You should rename it to index.d.ts`\n\n `*~ and place it in a folder with the same name as the module.`\n\n `*~ For example, if you were writing a file for \"super-greeter\", this`\n\n `*~ file should be 'super-greeter/index.d.ts'`\n\n `*/`\n\n`/*~ Note: If your global-modifying module is callable or constructable, you'll`\n\n `*~ need to combine the patterns here with those in the module-class or module-function`\n\n `*~ template files`\n\n `*/`\n\n`declare global {`\n\n  `/*~ Here, declare things that go in the global namespace, or augment`\n\n   `*~ existing declarations in the global namespace`\n\n   `*/`\n\n  `interface String {`\n\n    `fancyFormat(opts: StringFormatOptions): string;`\n\n  `}`\n\n`}`\n\n`/*~ If your module exports types or values, write them as usual */`\n\n`export interface StringFormatOptions {`\n\n  `fancinessLevel: number;`\n\n`}`\n\n`/*~ For example, declaring a method on the module (in addition to its global side effects) */`\n\n`export function doSomething(): void;`\n\n`/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */`\n\n`export {};`",
    "title": "TypeScript: Documentation - Global: Modifying Module",
    "description": "",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html",
    "markdown": "# TypeScript: Documentation - TypeScript 5.2\n\n## [](#using-declarations-and-explicit-resource-management)`using` Declarations and Explicit Resource Management\n\nTypeScript 5.2 adds support for the upcoming [Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management) feature in ECMAScript. Let’s explore some of the motivations and understand what the feature brings us.\n\nIt’s common to need to do some sort of “clean-up” after creating an object. For example, you might need to close network connections, delete temporary files, or just free up some memory.\n\nLet’s imagine a function that creates a temporary file, reads and writes to it for various operations, and then closes and deletes it.\n\nts\n\n`import * as fs from \"fs\";`\n\n`export function doSomeWork() {`\n\n    `const path = \".some_temp_file\";`\n\n    `const file = fs.openSync(path, \"w+\");`\n\n    `// use file...`\n\n    `// Close the file and delete it.`\n\n    `fs.closeSync(file);`\n\n    `fs.unlinkSync(path);`\n\n`}`\n\nThis is fine, but what happens if we need to perform an early exit?\n\nts\n\n`export function doSomeWork() {`\n\n    `const path = \".some_temp_file\";`\n\n    `const file = fs.openSync(path, \"w+\");`\n\n    `// use file...`\n\n    `if (someCondition()) {`\n\n        `// do some more work...`\n\n        `// Close the file and delete it.`\n\n        `fs.closeSync(file);`\n\n        `fs.unlinkSync(path);`\n\n        `return;`\n\n    `}`\n\n    `// Close the file and delete it.`\n\n    `fs.closeSync(file);`\n\n    `fs.unlinkSync(path);`\n\n`}`\n\nWe’re starting to see some duplication of clean-up which can be easy to forget. We’re also not guaranteed to close and delete the file if an error gets thrown. This could be solved by wrapping this all in a `try`/`finally` block.\n\nts\n\n`export function doSomeWork() {`\n\n    `const path = \".some_temp_file\";`\n\n    `const file = fs.openSync(path, \"w+\");`\n\n    `try {`\n\n        `// use file...`\n\n        `if (someCondition()) {`\n\n            `// do some more work...`\n\n            `return;`\n\n        `}`\n\n    `}`\n\n    `finally {`\n\n        `// Close the file and delete it.`\n\n        `fs.closeSync(file);`\n\n        `fs.unlinkSync(path);`\n\n    `}`\n\n`}`\n\nWhile this is more robust, it’s added quite a bit of “noise” to our code. There are also other foot-guns we can run into if we start adding more clean-up logic to our `finally` block — for example, exceptions preventing other resources from being disposed. This is what the [explicit resource management](https://github.com/tc39/proposal-explicit-resource-management) proposal aims to solve. The key idea of the proposal is to support resource disposal — this clean-up work we’re trying to deal with — as a first class idea in JavaScript.\n\nThis starts by adding a new built-in `symbol` called `Symbol.dispose`, and we can create objects with methods named by `Symbol.dispose`. For convenience, TypeScript defines a new global type called `Disposable` which describes these.\n\nts\n\n`class TempFile implements Disposable {`\n\n    `#path: string;`\n\n    `#handle: number;`\n\n    `constructor(path: string) {`\n\n        `this.#path = path;`\n\n        `this.#handle = fs.openSync(path, \"w+\");`\n\n    `}`\n\n    `// other methods`\n\n    `[Symbol.dispose]() {`\n\n        `// Close the file and delete it.`\n\n        `fs.closeSync(this.#handle);`\n\n        `fs.unlinkSync(this.#path);`\n\n    `}`\n\n`}`\n\nLater on we can call those methods.\n\nts\n\n`export function doSomeWork() {`\n\n    `const file = new TempFile(\".some_temp_file\");`\n\n    `try {`\n\n        `// ...`\n\n    `}`\n\n    `finally {`\n\n        `file[Symbol.dispose]();`\n\n    `}`\n\n`}`\n\nMoving the clean-up logic to `TempFile` itself doesn’t buy us much; we’ve basically just moved all the clean-up work from the `finally` block into a method, and that’s always been possible. But having a well-known “name” for this method means that JavaScript can build other features on top of it.\n\nThat brings us to the first star of the feature: `using` declarations! `using` is a new keyword that lets us declare new fixed bindings, kind of like `const`. The key difference is that variables declared with `using` get their `Symbol.dispose` method called at the end of the scope!\n\nSo we could simply have written our code like this:\n\nts\n\n`export function doSomeWork() {`\n\n    `using file = new TempFile(\".some_temp_file\");`\n\n    `// use file...`\n\n    `if (someCondition()) {`\n\n        `// do some more work...`\n\n        `return;`\n\n    `}`\n\n`}`\n\nCheck it out — no `try`/`finally` blocks! At least, none that we see. Functionally, that’s exactly what `using` declarations will do for us, but we don’t have to deal with that.\n\nYou might be familiar with [`using` declarations in C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/using), [`with` statements in Python](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement), or [`try`\\-with-resource declarations in Java](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html). These are all similar to JavaScript’s new `using` keyword, and provide a similar explicit way to perform a “tear-down” of an object at the end of a scope.\n\n`using` declarations do this clean-up at the very end of their containing scope or right before an “early return” like a `return` or a `throw`n error. They also dispose in a first-in-last-out order like a stack.\n\nts\n\n`function loggy(id: string): Disposable {`\n\n    ``console.log(`Creating ${id}`);``\n\n    `return {`\n\n        `[Symbol.dispose]() {`\n\n            ``console.log(`Disposing ${id}`);``\n\n        `}`\n\n    `}`\n\n`}`\n\n`function func() {`\n\n    `using a = loggy(\"a\");`\n\n    `using b = loggy(\"b\");`\n\n    `{`\n\n        `using c = loggy(\"c\");`\n\n        `using d = loggy(\"d\");`\n\n    `}`\n\n    `using e = loggy(\"e\");`\n\n    `return;`\n\n    `// Unreachable.`\n\n    `// Never created, never disposed.`\n\n    `using f = loggy(\"f\");`\n\n`}`\n\n`func();`\n\n`// Creating a`\n\n`// Creating b`\n\n`// Creating c`\n\n`// Creating d`\n\n`// Disposing d`\n\n`// Disposing c`\n\n`// Creating e`\n\n`// Disposing e`\n\n`// Disposing b`\n\n`// Disposing a`\n\n`using` declarations are supposed to be resilient to exceptions; if an error is thrown, it’s rethrown after disposal. On the other hand, the body of your function might execute as expected, but the `Symbol.dispose` might throw. In that case, that exception is rethrown as well.\n\nBut what happens if both the logic before and during disposal throws an error? For those cases, `SuppressedError` has been introduced as a new subtype of `Error`. It features a `suppressed` property that holds the last-thrown error, and an `error` property for the most-recently thrown error.\n\nts\n\n`class ErrorA extends Error {`\n\n    `name = \"ErrorA\";`\n\n`}`\n\n`class ErrorB extends Error {`\n\n    `name = \"ErrorB\";`\n\n`}`\n\n`function throwy(id: string) {`\n\n    `return {`\n\n        `[Symbol.dispose]() {`\n\n            ``throw new ErrorA(`Error from ${id}`);``\n\n        `}`\n\n    `};`\n\n`}`\n\n`function func() {`\n\n    `using a = throwy(\"a\");`\n\n    `throw new ErrorB(\"oops!\")`\n\n`}`\n\n`try {`\n\n    `func();`\n\n`}`\n\n`catch (e: any) {`\n\n    `console.log(e.name); // SuppressedError`\n\n    `console.log(e.message); // An error was suppressed during disposal.`\n\n    `console.log(e.error.name); // ErrorA`\n\n    `console.log(e.error.message); // Error from a`\n\n    `console.log(e.suppressed.name); // ErrorB`\n\n    `console.log(e.suppressed.message); // oops!`\n\n`}`\n\nYou might have noticed that we’re using synchronous methods in these examples. However, lots of resource disposal involves _asynchronous_ operations, and we need to wait for those to complete before we continue running any other code.\n\nThat’s why there is also a new `Symbol.asyncDispose`, and it brings us to the next star of the show — `await using` declarations. These are similar to `using` declarations, but the key is that they look up whose disposal must be `await`ed. They use a different method named by `Symbol.asyncDispose`, though they can operate on anything with a `Symbol.dispose` as well. For convenience, TypeScript also introduces a global type called `AsyncDisposable` that describes any object with an asynchronous dispose method.\n\nts\n\n`async function doWork() {`\n\n    `// Do fake work for half a second.`\n\n    `await new Promise(resolve => setTimeout(resolve, 500));`\n\n`}`\n\n`function loggy(id: string): AsyncDisposable {`\n\n    ``console.log(`Constructing ${id}`);``\n\n    `return {`\n\n        `async [Symbol.asyncDispose]() {`\n\n            ``console.log(`Disposing (async) ${id}`);``\n\n            `await doWork();`\n\n        `},`\n\n    `}`\n\n`}`\n\n`async function func() {`\n\n    `await using a = loggy(\"a\");`\n\n    `await using b = loggy(\"b\");`\n\n    `{`\n\n        `await using c = loggy(\"c\");`\n\n        `await using d = loggy(\"d\");`\n\n    `}`\n\n    `await using e = loggy(\"e\");`\n\n    `return;`\n\n    `// Unreachable.`\n\n    `// Never created, never disposed.`\n\n    `await using f = loggy(\"f\");`\n\n`}`\n\n`func();`\n\n`// Constructing a`\n\n`// Constructing b`\n\n`// Constructing c`\n\n`// Constructing d`\n\n`// Disposing (async) d`\n\n`// Disposing (async) c`\n\n`// Constructing e`\n\n`// Disposing (async) e`\n\n`// Disposing (async) b`\n\n`// Disposing (async) a`\n\nDefining types in terms of `Disposable` and `AsyncDisposable` can make your code much easier to work with if you expect others to do tear-down logic consistently. In fact, lots of existing types exist in the wild which have a `dispose()` or `close()` method. For example, the Visual Studio Code APIs even define [their own `Disposable` interface](https://code.visualstudio.com/api/references/vscode-api#Disposable). APIs in the browser and in runtimes like Node.js, Deno, and Bun might also choose to use `Symbol.dispose` and `Symbol.asyncDispose` for objects which already have clean-up methods, like file handles, connections, and more.\n\nNow maybe this all sounds great for libraries, but a little bit heavy-weight for your scenarios. If you’re doing a lot of ad-hoc clean-up, creating a new type might introduce a lot of over-abstraction and questions about best-practices. For example, take our `TempFile` example again.\n\nts\n\n`class TempFile implements Disposable {`\n\n    `#path: string;`\n\n    `#handle: number;`\n\n    `constructor(path: string) {`\n\n        `this.#path = path;`\n\n        `this.#handle = fs.openSync(path, \"w+\");`\n\n    `}`\n\n    `// other methods`\n\n    `[Symbol.dispose]() {`\n\n        `// Close the file and delete it.`\n\n        `fs.closeSync(this.#handle);`\n\n        `fs.unlinkSync(this.#path);`\n\n    `}`\n\n`}`\n\n`export function doSomeWork() {`\n\n    `using file = new TempFile(\".some_temp_file\");`\n\n    `// use file...`\n\n    `if (someCondition()) {`\n\n        `// do some more work...`\n\n        `return;`\n\n    `}`\n\n`}`\n\nAll we wanted was to remember to call two functions — but was this the best way to write it? Should we be calling `openSync` in the constructor, create an `open()` method, or pass in the handle ourselves? Should we expose a method for every possible operation we need to perform, or should we just make the properties public?\n\nThat brings us to the final stars of the feature: `DisposableStack` and `AsyncDisposableStack`. These objects are useful for doing both one-off clean-up, along with arbitrary amounts of cleanup. A `DisposableStack` is an object that has several methods for keeping track of `Disposable` objects, and can be given functions for doing arbitrary clean-up work. We can also assign them to `using` variables because — get this — _they’re also `Disposable`_! So here’s how we could’ve written the original example.\n\nts\n\n`function doSomeWork() {`\n\n    `const path = \".some_temp_file\";`\n\n    `const file = fs.openSync(path, \"w+\");`\n\n    `using cleanup = new DisposableStack();`\n\n    `cleanup.defer(() => {`\n\n        `fs.closeSync(file);`\n\n        `fs.unlinkSync(path);`\n\n    `});`\n\n    `// use file...`\n\n    `if (someCondition()) {`\n\n        `// do some more work...`\n\n        `return;`\n\n    `}`\n\n    `// ...`\n\n`}`\n\nHere, the `defer()` method just takes a callback, and that callback will be run once `cleanup` is disposed of. Typically, `defer` (and other `DisposableStack` methods like `use` and `adopt`) should be called immediately after creating a resource. As the name suggests, `DisposableStack` disposes of everything it keeps track of like a stack, in a first-in-last-out order, so `defer`ing immediately after creating a value helps avoid odd dependency issues. `AsyncDisposableStack` works similarly, but can keep track of `async` functions and `AsyncDisposable`s, and is itself an `AsyncDisposable.`\n\nThe `defer` method is similar in many ways to the `defer` keyword in [Go](https://go.dev/tour/flowcontrol/12), [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/statements/#Defer-Statement), [Zig](https://ziglang.org/documentation/master/#defer), [Odin](https://odin-lang.org/docs/overview/#defer-statement), and others, where the conventions should be similar.\n\nBecause this feature is so recent, most runtimes will not support it natively. To use it, you will need runtime polyfills for the following:\n\n*   `Symbol.dispose`\n*   `Symbol.asyncDispose`\n*   `DisposableStack`\n*   `AsyncDisposableStack`\n*   `SuppressedError`\n\nHowever, if all you’re interested in is `using` and `await using`, you should be able to get away with only polyfilling the built-in `symbol`s. Something as simple as the following should work for most cases:\n\nts\n\n`Symbol.dispose ??= Symbol(\"Symbol.dispose\");`\n\n`Symbol.asyncDispose ??= Symbol(\"Symbol.asyncDispose\");`\n\nYou will also need to set your compilation `target` to `es2022` or below, and configure your `lib` setting to either include `\"esnext\"` or `\"esnext.disposable\"`.\n\njson\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"target\": \"es2022\",`\n\n        `\"lib\": [\"es2022\", \"esnext.disposable\", \"dom\"]`\n\n    `}`\n\n`}`\n\nFor more information on this feature, [take a look at the work on GitHub](https://github.com/microsoft/TypeScript/pull/54505)!\n\nTypeScript 5.2 implements [an upcoming ECMAScript feature called decorator metadata](https://github.com/tc39/proposal-decorator-metadata).\n\nThe key idea of this feature is to make it easy for decorators to create and consume metadata on any class they’re used on or within.\n\nWhenever decorator functions are used, they now have access to a new `metadata` property on their context object. The `metadata` property just holds a simple object. Since JavaScript lets us add properties arbitrarily, it can be used as a dictionary that is updated by each decorator. Alternatively, since every `metadata` object will be identical for each decorated portion of a class, it can be used as a key into a `Map`. After all decorators on or in a class get run, that object can be accessed on the class via `Symbol.metadata`.\n\nts\n\n`interface Context {`\n\n    `name: string;`\n\n    `metadata: Record<PropertyKey, unknown>;`\n\n`}`\n\n`function setMetadata(_target: any, context: Context) {`\n\n    `context.metadata[context.name] = true;`\n\n`}`\n\n`class SomeClass {`\n\n    `@setMetadata`\n\n    `foo = 123;`\n\n    `@setMetadata`\n\n    `accessor bar = \"hello!\";`\n\n    `@setMetadata`\n\n    `baz() { }`\n\n`}`\n\n`const ourMetadata = SomeClass[Symbol.metadata];`\n\n`console.log(JSON.stringify(ourMetadata));`\n\n`// { \"bar\": true, \"baz\": true, \"foo\": true }`\n\nThis can be useful in a number of different scenarios. Metadata could possibly be attached for lots of uses like debugging, serialization, or performing dependency injection with decorators. Since metadata objects are created per decorated class, frameworks can either privately use them as keys into a `Map` or `WeakMap`, or tack properties on as necessary.\n\nFor example, let’s say we wanted to use decorators to keep track of which properties and accessors are serializable when using `JSON.stringify` like so:\n\nts\n\n`import { serialize, jsonify } from \"./serializer\";`\n\n`class Person {`\n\n    `firstName: string;`\n\n    `lastName: string;`\n\n    `@serialize`\n\n    `age: number`\n\n    `@serialize`\n\n    `get fullName() {`\n\n        ``return `${this.firstName} ${this.lastName}`;``\n\n    `}`\n\n    `toJSON() {`\n\n        `return jsonify(this)`\n\n    `}`\n\n    `constructor(firstName: string, lastName: string, age: number) {`\n\n        `// ...`\n\n    `}`\n\n`}`\n\nHere, the intent is that only `age` and `fullName` should be serialized because they are marked with the `@serialize` decorator. We define a `toJSON` method for this purpose, but it just calls out to `jsonify` which uses the metadata that `@serialize` created.\n\nHere’s an example of how the module `./serialize.ts` might be defined:\n\nts\n\n`const serializables = Symbol();`\n\n`type Context =`\n\n    `| ClassAccessorDecoratorContext`\n\n    `| ClassGetterDecoratorContext`\n\n    `| ClassFieldDecoratorContext`\n\n    `;`\n\n`export function serialize(_target: any, context: Context): void {`\n\n    `if (context.static || context.private) {`\n\n        `throw new Error(\"Can only serialize public instance members.\")`\n\n    `}`\n\n    `if (typeof context.name === \"symbol\") {`\n\n        `throw new Error(\"Cannot serialize symbol-named properties.\");`\n\n    `}`\n\n    `const propNames =`\n\n        `(context.metadata[serializables] as string[] | undefined) ??= [];`\n\n    `propNames.push(context.name);`\n\n`}`\n\n`export function jsonify(instance: object): string {`\n\n    `const metadata = instance.constructor[Symbol.metadata];`\n\n    `const propNames = metadata?.[serializables] as string[] | undefined;`\n\n    `if (!propNames) {`\n\n        `throw new Error(\"No members marked with @serialize.\");`\n\n    `}`\n\n    `const pairStrings = propNames.map(key => {`\n\n        `const strKey = JSON.stringify(key);`\n\n        `const strValue = JSON.stringify((instance as any)[key]);`\n\n        ``return `${strKey}: ${strValue}`;``\n\n    `});`\n\n    ``return `{ ${pairStrings.join(\", \")} }`;``\n\n`}`\n\nThis module has a local `symbol` called `serializables` to store and retrieve the names of properties marked `@serializable`. It stores a list of these property names on the metadata on each invocation of `@serializable`. When `jsonify` is called, the list of properties is fetched off of the metadata and used to retrieve the actual values from the instance, eventually serializing those names and values.\n\nUsing a `symbol` technically makes this data accessible to others. An alternative might be to use a `WeakMap` using the metadata object as a key. This keeps data private and happens to use fewer type assertions in this case, but is otherwise similar.\n\nts\n\n`const serializables = new WeakMap<object, string[]>();`\n\n`type Context =`\n\n    `| ClassAccessorDecoratorContext`\n\n    `| ClassGetterDecoratorContext`\n\n    `| ClassFieldDecoratorContext`\n\n    `;`\n\n`export function serialize(_target: any, context: Context): void {`\n\n    `if (context.static || context.private) {`\n\n        `throw new Error(\"Can only serialize public instance members.\")`\n\n    `}`\n\n    `if (typeof context.name !== \"string\") {`\n\n        `throw new Error(\"Can only serialize string properties.\");`\n\n    `}`\n\n    `let propNames = serializables.get(context.metadata);`\n\n    `if (propNames === undefined) {`\n\n        `serializables.set(context.metadata, propNames = []);`\n\n    `}`\n\n    `propNames.push(context.name);`\n\n`}`\n\n`export function jsonify(instance: object): string {`\n\n    `const metadata = instance.constructor[Symbol.metadata];`\n\n    `const propNames = metadata && serializables.get(metadata);`\n\n    `if (!propNames) {`\n\n        `throw new Error(\"No members marked with @serialize.\");`\n\n    `}`\n\n    `const pairStrings = propNames.map(key => {`\n\n        `const strKey = JSON.stringify(key);`\n\n        `const strValue = JSON.stringify((instance as any)[key]);`\n\n        ``return `${strKey}: ${strValue}`;``\n\n    `});`\n\n    ``return `{ ${pairStrings.join(\", \")} }`;``\n\n`}`\n\nAs a note, these implementations don’t handle subclassing and inheritance. That’s left as an exercise to you (and you might find that it is easier in one version of the file than the other!).\n\nBecause this feature is still fresh, most runtimes will not support it natively. To use it, you will need a polyfill for `Symbol.metadata`. Something as simple as the following should work for most cases:\n\nts\n\n`Symbol.metadata ??= Symbol(\"Symbol.metadata\");`\n\nYou will also need to set your compilation `target` to `es2022` or below, and configure your `lib` setting to either include `\"esnext\"` or `\"esnext.decorators\"`.\n\njson\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"target\": \"es2022\",`\n\n        `\"lib\": [\"es2022\", \"esnext.decorators\", \"dom\"]`\n\n    `}`\n\n`}`\n\nWe’d like to thank [Oleksandr Tarasiuk](https://github.com/a-tarasyuk) for contributing [the implementation of decorator metadata](https://github.com/microsoft/TypeScript/pull/54657) for TypeScript 5.2!\n\n## [](#named-and-anonymous-tuple-elements)Named and Anonymous Tuple Elements\n\nTuple types have supported optional labels or names for each element.\n\nts\n\n`type Pair<T> = [first: T, second: T];`\n\nThese labels don’t change what you’re allowed to do with them — they’re solely to help with readability and tooling.\n\nHowever, TypeScript previously had a rule that tuples could not mix and match between labeled and unlabeled elements. In other words, either no element could have a label in a tuple, or all elements needed one.\n\nts\n\n`// ✅ fine - no labels`\n\n`type Pair1<T> = [T, T];`\n\n`// ✅ fine - all fully labeled`\n\n`type Pair2<T> = [first: T, second: T];`\n\n`// ❌ previously an error`\n\n`type Pair3<T> = [first: T, T];`\n\n`//                         ~`\n\n`// Tuple members must all have names`\n\n`// or all not have names.`\n\nThis could be annoying for rest elements where we’d be forced to just add a label like `rest` or `tail`.\n\nts\n\n`// ❌ previously an error`\n\n`type TwoOrMore_A<T> = [first: T, second: T, ...T[]];`\n\n`//                                          ~~~~~~`\n\n`// Tuple members must all have names`\n\n`// or all not have names.`\n\n`// ✅`\n\n`type TwoOrMore_B<T> = [first: T, second: T, rest: ...T[]];`\n\nIt also meant that this restriction had to be enforced internally in the type system, meaning TypeScript would lose labels.\n\nts\n\n`type HasLabels = [a: string, b: string];`\n\n`type HasNoLabels = [number, number];`\n\n`type Merged = [...HasNoLabels, ...HasLabels];`\n\n`//   ^ [number, number, string, string]`\n\n`//`\n\n`//     'a' and 'b' were lost in 'Merged'`\n\nIn TypeScript 5.2, the all-or-nothing restriction on tuple labels has been lifted. The language can now also preserve labels when spreading into an unlabeled tuple.\n\nWe’d like to extend our thanks to [Josh Goldberg](https://github.com/JoshuaKGoldberg) and [Mateusz Burzyński](https://github.com/Andarist) who [collaborated to lift this restriction](https://github.com/microsoft/TypeScript/pull/53356).\n\n## [](#easier-method-usage-for-unions-of-arrays)Easier Method Usage for Unions of Arrays\n\nIn previous versions on TypeScript, calling a method on a union of arrays could end in pain.\n\nts\n\n`declare let array: string[] | number[];`\n\n`array.filter(x => !!x);`\n\n`//    ~~~~~~ error!`\n\n`// This expression is not callable.`\n\n`//   Each member of the union type '...' has signatures,`\n\n`//   but none of those signatures are compatible`\n\n`//   with each other.`\n\nIn this example, TypeScript would try to see if each version of `filter` is compatible across `string[]` and `number[]`. Without a coherent strategy, TypeScript threw its hands in the air and said “I can’t make it work”.\n\nIn TypeScript 5.2, before giving up in these cases, unions of arrays are treated as a special case. A new array type is constructed out of each member’s element type, and then the method is invoked on that.\n\nTaking the above example, `string[] | number[]` is transformed into `(string | number)[]` (or `Array<string | number>`), and `filter` is invoked on that type. There is a slight caveat which is that `filter` will produce an `Array<string | number>` instead of a `string[] | number[]`; but for a freshly produced value there is less risk of something “going wrong”.\n\nThis means lots of methods like `filter`, `find`, `some`, `every`, and `reduce` should all be invokable on unions of arrays in cases where they were not previously.\n\nYou can [read up more details on the implementing pull request](https://github.com/microsoft/TypeScript/pull/53489).\n\n## [](#type-only-import-paths-with-typescript-implementation-file-extensions)Type-Only Import Paths with TypeScript Implementation File Extensions\n\nTypeScript now allows both declaration _and_ implementation file extensions to be included in type-only import paths, regardless of whether `allowImportingTsExtensions` is enabled.\n\nThis means that you can now write `import type` statements that use `.ts`, `.mts`, `.cts`, and `.tsx` file extensions.\n\nts\n\n`import type { JustAType } from \"./justTypes.ts\";`\n\n`export function f(param: JustAType) {`\n\n    `// ...`\n\n`}`\n\nIt also means that `import()` types, which can be used in both TypeScript and JavaScript with JSDoc, can use those file extensions.\n\njs\n\n`/**`\n\n `* @param {import(\"./justTypes.ts\").JustAType} param`\n\n `*/`\n\n`export function f(param) {`\n\n    `// ...`\n\n`}`\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/54746).\n\n## [](#comma-completions-for-object-members)Comma Completions for Object Members\n\nIt can be easy to forget to add a comma when adding a new property to an object. Previously, if you forgot a comma and requested auto-completion, TypeScript would confusingly give poor unrelated completion results.\n\nTypeScript 5.2 now gracefully provides object member completions when you’re missing a comma. But to just skip past hitting you with a syntax error, it will _also_ auto-insert the missing comma.\n\n![Properties in an object literal are completed despite missing a comma after a prior property. When the property name is completed, the missing comma is automatically inserted.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/06/comma-completions-5-2-beta.gif)\n\nFor more information, [see the implementation here](https://github.com/microsoft/TypeScript/pull/52899).\n\n## [](#inline-variable-refactoring)Inline Variable Refactoring\n\nTypeScript 5.2 now has a refactoring to inline the contents of a variable to all usage sites.\n\n![A variable called 'path' initialized to a string, having both of its usages replaced](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/06/inline-variable-5-2-beta.gif).\n\nUsing the “inline variable” refactoring will eliminate the variable and replace all the variable’s usages with its initializer. Note that this may cause that initializer’s side-effects to run at a different time, and as many times as the variable has been used.\n\nFor more details, [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/54281).\n\n## [](#optimized-checks-for-ongoing-type-compatibility)Optimized Checks for Ongoing Type Compatibility\n\nBecause TypeScript is a structural type system, types occasionally need to be compared in a member-wise fashion; however, recursive types add some issues here. For example:\n\nts\n\n`interface A {`\n\n    `value: A;`\n\n    `other: string;`\n\n`}`\n\n`interface B {`\n\n    `value: B;`\n\n    `other: number;`\n\n`}`\n\nWhen checking whether the type `A` is compatible with the type `B`, TypeScript will end up checking whether the types of `value` in `A` and `B` are respectively compatible. At this point, the type system needs to stop checking any further and proceed to check other members. To do this, the type system has to track when any two types are already being related.\n\nPreviously TypeScript already kept a stack of type pairs, and iterated through that to determine whether those types are being related. When this stack is shallow that’s not a problem; but when the stack isn’t shallow, that, uh, [is a problem](https://accidentallyquadratic.tumblr.com/).\n\nIn TypeScript 5.3, a simple `Set` helps tracks this information. This reduced the time spent on a reported test case that used the [drizzle](https://github.com/drizzle-team/drizzle-orm) library by over 33%!\n\n`Benchmark 1: old`\n\n  `Time (mean ± σ):      3.115 s ±  0.067 s    [User: 4.403 s, System: 0.124 s]`\n\n  `Range (min … max):    3.018 s …  3.196 s    10 runs`\n\n`Benchmark 2: new`\n\n  `Time (mean ± σ):      2.072 s ±  0.050 s    [User: 3.355 s, System: 0.135 s]`\n\n  `Range (min … max):    1.985 s …  2.150 s    10 runs`\n\n`Summary`\n\n  `'new' ran`\n\n    `1.50 ± 0.05 times faster than 'old'`\n\n[Read more on the change here](https://github.com/microsoft/TypeScript/pull/55224).\n\n## [](#breaking-changes-and-correctness-fixes)Breaking Changes and Correctness Fixes\n\nTypeScript strives not to unnecessarily introduce breaks; however, occasionally we must make corrections and improvements so that code can be better-analyzed.\n\n### [](#libdts-changes)`lib.d.ts` Changes\n\nTypes generated for the DOM may have an impact on your codebase. For more information, [see the DOM updates for TypeScript 5.2](https://github.com/microsoft/TypeScript/pull/54725).\n\n### [](#labeledelementdeclarations-may-hold-undefined-elements)`labeledElementDeclarations` May Hold `undefined` Elements\n\nIn order [to support a mixture of labeled and unlabeled elements](https://github.com/microsoft/TypeScript/pull/53356), TypeScript’s API has changed slightly. The `labeledElementDeclarations` property of `TupleType` may hold `undefined` for at each position where an element is unlabeled.\n\ndiff\n\n  `interface TupleType {`\n\n`-     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];`\n\n`+     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[];`\n\n  `}`\n\n### [](#module-and-moduleresolution-must-match-under-recent-nodejs-settings)`module` and `moduleResolution` Must Match Under Recent Node.js settings\n\nThe `--module` and `--moduleResolution` options each support a `node16` and `nodenext` setting. These are effectively “modern Node.js” settings that should be used on any recent Node.js project. What we’ve found is that when these two options don’t agree on whether they are using Node.js-related settings, projects are effectively misconfigured.\n\nIn TypeScript 5.2, when using `node16` or `nodenext` for either of the `--module` and `--moduleResolution` options, TypeScript now requires the other to have a similar Node.js-related setting. In cases where the settings diverge, you’ll likely get an error message like either\n\n`Option 'moduleResolution' must be set to 'NodeNext' (or left unspecified) when option 'module' is set to 'NodeNext'.`\n\nor\n\n`Option 'module' must be set to 'Node16' when option 'moduleResolution' is set to 'Node16'.`\n\nSo for example `--module esnext --moduleResolution node16` will be rejected — but you may be better off just using `--module nodenext` alone, or `--module esnext --moduleResolution bundler`.\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/54567).\n\n### [](#consistent-export-checking-for-merged-symbols)Consistent Export Checking for Merged Symbols\n\nWhen two declarations merge, they must agree in whether they are both exported. Due to a bug, TypeScript missed specific cases in ambient contexts, like in declaration files or `declare module` blocks. For example, it would not issue an error on a case like the following, where `replaceInFile` is declared once as an exported function, and one as an un-exported namespace.\n\nts\n\n`declare module 'replace-in-file' {`\n\n    `export function replaceInFile(config: unknown): Promise<unknown[]>;`\n\n    `export {};`\n\n    `namespace replaceInFile {`\n\n        `export function sync(config: unknown): unknown[];`\n\n  `}`\n\n`}`\n\nIn an ambient module, adding an `export { ... }` or a similar construct like `export default ...` implicitly changes whether all declarations are automatically exported. TypeScript now recognizes these unfortunately confusing semantics more consistently, and issues an error on the fact that all declarations of `replaceInFile` need to agree in their modifiers, and will issue the following error:\n\n`Individual declarations in merged declaration 'replaceInFile' must be all exported or all local.`\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/54659).",
    "title": "TypeScript: Documentation - TypeScript 5.2",
    "description": "TypeScript 5.2 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.9\n\n## [](#improvements-in-inference-and-promiseall)Improvements in Inference and `Promise.all`\n\nRecent versions of TypeScript (around 3.7) have had updates to the declarations of functions like `Promise.all` and `Promise.race`. Unfortunately, that introduced a few regressions, especially when mixing in values with `null` or `undefined`.\n\nts\n\n`interface Lion {`\n\n  `roar(): void;`\n\n`}`\n\n`interface Seal {`\n\n  `singKissFromARose(): void;`\n\n`}`\n\n`async function visitZoo(`\n\n  `lionExhibit: Promise<Lion>,`\n\n  `sealExhibit: Promise<Seal | undefined>`\n\n`) {`\n\n  `let [lion, seal] = await Promise.all([lionExhibit, sealExhibit]);`\n\n  `lion.roar(); // uh oh`\n\n  `//  ~~~~`\n\n  `// Object is possibly 'undefined'.`\n\n`}`\n\nThis is strange behavior! The fact that `sealExhibit` contained an `undefined` somehow poisoned type of `lion` to include `undefined`.\n\nThanks to [a pull request](https://github.com/microsoft/TypeScript/pull/34501) from [Jack Bates](https://github.com/jablko), this has been fixed with improvements in our inference process in TypeScript 3.9. The above no longer errors. If you’ve been stuck on older versions of TypeScript due to issues around `Promise`s, we encourage you to give 3.9 a shot!\n\n### [](#what-about-the-awaited-type)What About the `awaited` Type?\n\nIf you’ve been following our issue tracker and design meeting notes, you might be aware of some work around [a new type operator called `awaited`](https://github.com/microsoft/TypeScript/pull/35998). This goal of this type operator is to accurately model the way that `Promise` unwrapping works in JavaScript.\n\nWe initially anticipated shipping `awaited` in TypeScript 3.9, but as we’ve run early TypeScript builds with existing codebases, we’ve realized that the feature needs more design work before we can roll it out to everyone smoothly. As a result, we’ve decided to pull the feature out of our main branch until we feel more confident. We’ll be experimenting more with the feature, but we won’t be shipping it as part of this release.\n\n## [](#speed-improvements)Speed Improvements\n\nTypeScript 3.9 ships with many new speed improvements. Our team has been focusing on performance after observing extremely poor editing/compilation speed with packages like material-ui and styled-components. We’ve dived deep here, with a series of different pull requests that optimize certain pathological cases involving large unions, intersections, conditional types, and mapped types.\n\n*   [https://github.com/microsoft/TypeScript/pull/36576](https://github.com/microsoft/TypeScript/pull/36576)\n*   [https://github.com/microsoft/TypeScript/pull/36590](https://github.com/microsoft/TypeScript/pull/36590)\n*   [https://github.com/microsoft/TypeScript/pull/36607](https://github.com/microsoft/TypeScript/pull/36607)\n*   [https://github.com/microsoft/TypeScript/pull/36622](https://github.com/microsoft/TypeScript/pull/36622)\n*   [https://github.com/microsoft/TypeScript/pull/36754](https://github.com/microsoft/TypeScript/pull/36754)\n*   [https://github.com/microsoft/TypeScript/pull/36696](https://github.com/microsoft/TypeScript/pull/36696)\n\nEach of these pull requests gains about a 5-10% reduction in compile times on certain codebases. In total, we believe we’ve achieved around a 40% reduction in material-ui’s compile time!\n\nWe also have some changes to file renaming functionality in editor scenarios. We heard from the Visual Studio Code team that when renaming a file, just figuring out which import statements needed to be updated could take between 5 to 10 seconds. TypeScript 3.9 addresses this issue by [changing the internals of how the compiler and language service caches file lookups](https://github.com/microsoft/TypeScript/pull/37055).\n\nWhile there’s still room for improvement, we hope this work translates to a snappier experience for everyone!\n\nImagine that we’re writing a library in TypeScript and we’re exporting some function called `doStuff` as part of our public API. The function’s types declare that it takes two `string`s so that other TypeScript users can get type-checking errors, but it also does a runtime check (maybe only in development builds) to give JavaScript users a helpful error.\n\nts\n\n`function doStuff(abc: string, xyz: string) {`\n\n  `assert(typeof abc === \"string\");`\n\n  `assert(typeof xyz === \"string\");`\n\n  `// do some stuff`\n\n`}`\n\nSo TypeScript users will get a helpful red squiggle and an error message when they misuse this function, and JavaScript users will get an assertion error. We’d like to test this behavior, so we’ll write a unit test.\n\nts\n\n`expect(() => {`\n\n  `doStuff(123, 456);`\n\n`}).toThrow();`\n\nUnfortunately if our tests are written in TypeScript, TypeScript will give us an error!\n\nts\n\n`doStuff(123, 456);`\n\n`//          ~~~`\n\n`// error: Type 'number' is not assignable to type 'string'.`\n\nThat’s why TypeScript 3.9 brings a new feature: `// @ts-expect-error` comments. When a line is preceded by a `// @ts-expect-error` comment, TypeScript will suppress that error from being reported; but if there’s no error, TypeScript will report that `// @ts-expect-error` wasn’t necessary.\n\nAs a quick example, the following code is okay\n\nts\n\n`// @ts-expect-error`\n\n`console.log(47 * \"octopus\");`\n\nwhile the following code\n\nts\n\n`// @ts-expect-error`\n\n`console.log(1 + 1);`\n\nresults in the error\n\n`Unused '@ts-expect-error' directive.`\n\nWe’d like to extend a big thanks to [Josh Goldberg](https://github.com/JoshuaKGoldberg), the contributor who implemented this feature. For more information, you can take a look at [the `ts-expect-error` pull request](https://github.com/microsoft/TypeScript/pull/36014).\n\n### [](#ts-ignore-or-ts-expect-error)`ts-ignore` or `ts-expect-error`?\n\nIn some ways `// @ts-expect-error` can act as a suppression comment, similar to `// @ts-ignore`. The difference is that `// @ts-ignore` will do nothing if the following line is error-free.\n\nYou might be tempted to switch existing `// @ts-ignore` comments over to `// @ts-expect-error`, and you might be wondering which is appropriate for future code. While it’s entirely up to you and your team, we have some ideas of which to pick in certain situations.\n\nPick `ts-expect-error` if:\n\n*   you’re writing test code where you actually want the type system to error on an operation\n*   you expect a fix to be coming in fairly quickly and you just need a quick workaround\n*   you’re in a reasonably-sized project with a proactive team that wants to remove suppression comments as soon affected code is valid again\n\nPick `ts-ignore` if:\n\n*   you have a larger project and new errors have appeared in code with no clear owner\n*   you are in the middle of an upgrade between two different versions of TypeScript, and a line of code errors in one version but not another.\n*   you honestly don’t have the time to decide which of these options is better.\n\n## [](#uncalled-function-checks-in-conditional-expressions)Uncalled Function Checks in Conditional Expressions\n\nIn TypeScript 3.7 we introduced _uncalled function checks_ to report an error when you’ve forgotten to call a function.\n\nts\n\n`function hasImportantPermissions(): boolean {`\n\n  `// ...`\n\n`}`\n\n`// Oops!`\n\n`if (hasImportantPermissions) {`\n\n  `//  ~~~~~~~~~~~~~~~~~~~~~~~`\n\n  `// This condition will always return true since the function is always defined.`\n\n  `// Did you mean to call it instead?`\n\n  `deleteAllTheImportantFiles();`\n\n`}`\n\nHowever, this error only applied to conditions in `if` statements. Thanks to [a pull request](https://github.com/microsoft/TypeScript/pull/36402) from [Alexander Tarasyuk](https://github.com/a-tarasyuk), this feature is also now supported in ternary conditionals (i.e. the `cond ? trueExpr : falseExpr` syntax).\n\nts\n\n`declare function listFilesOfDirectory(dirPath: string): string[];`\n\n`declare function isDirectory(): boolean;`\n\n`function getAllFiles(startFileName: string) {`\n\n  `const result: string[] = [];`\n\n  `traverse(startFileName);`\n\n  `return result;`\n\n  `function traverse(currentPath: string) {`\n\n    `return isDirectory`\n\n      `? //     ~~~~~~~~~~~`\n\n        `// This condition will always return true`\n\n        `// since the function is always defined.`\n\n        `// Did you mean to call it instead?`\n\n        `listFilesOfDirectory(currentPath).forEach(traverse)`\n\n      `: result.push(currentPath);`\n\n  `}`\n\n`}`\n\n[https://github.com/microsoft/TypeScript/issues/36048](https://github.com/microsoft/TypeScript/issues/36048)\n\n## [](#editor-improvements)Editor Improvements\n\nThe TypeScript compiler not only powers the TypeScript editing experience in most major editors, it also powers the JavaScript experience in the Visual Studio family of editors and more. Using new TypeScript/JavaScript functionality in your editor will differ depending on your editor, but\n\n*   Visual Studio Code supports [selecting different versions of TypeScript](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript). Alternatively, there’s the [JavaScript/TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next) to stay on the bleeding edge (which is typically very stable).\n*   Visual Studio 2017/2019 have \\[the SDK installers above\\] and [MSBuild installs](https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild).\n*   Sublime Text 3 supports [selecting different versions of TypeScript](https://github.com/microsoft/TypeScript-Sublime-Plugin#note-using-different-versions-of-typescript)\n\n### [](#commonjs-auto-imports-in-javascript)CommonJS Auto-Imports in JavaScript\n\nOne great new improvement is in auto-imports in JavaScript files using CommonJS modules.\n\nIn older versions, TypeScript always assumed that regardless of your file, you wanted an ECMAScript-style import like\n\njs\n\n`import * as fs from \"fs\";`\n\nHowever, not everyone is targeting ECMAScript-style modules when writing JavaScript files. Plenty of users still use CommonJS-style `require(...)` imports like so\n\njs\n\n`const fs = require(\"fs\");`\n\nTypeScript now automatically detects the types of imports you’re using to keep your file’s style clean and consistent.\n\nFor more details on the change, see [the corresponding pull request](https://github.com/microsoft/TypeScript/pull/37027).\n\n### [](#code-actions-preserve-newlines)Code Actions Preserve Newlines\n\nTypeScript’s refactorings and quick fixes often didn’t do a great job of preserving newlines. As a really basic example, take the following code.\n\nts\n\n`const maxValue = 100;`\n\n`/*start*/`\n\n`for (let i = 0; i <= maxValue; i++) {`\n\n  `// First get the squared value.`\n\n  `let square = i ** 2;`\n\n  `// Now print the squared value.`\n\n  `console.log(square);`\n\n`}`\n\n`/*end*/`\n\nIf we highlighted the range from `/*start*/` to `/*end*/` in our editor to extract to a new function, we’d end up with code like the following.\n\nts\n\n`const maxValue = 100;`\n\n`printSquares();`\n\n`function printSquares() {`\n\n  `for (let i = 0; i <= maxValue; i++) {`\n\n    `// First get the squared value.`\n\n    `let square = i ** 2;`\n\n    `// Now print the squared value.`\n\n    `console.log(square);`\n\n  `}`\n\n`}`\n\n![Extracting the for loop to a function in older versions of TypeScript. A newline is not preserved.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/03/printSquaresWithoutNewlines-3.9.gif.gif)\n\nThat’s not ideal - we had a blank line between each statement in our `for` loop, but the refactoring got rid of it! TypeScript 3.9 does a little more work to preserve what we write.\n\nts\n\n`const maxValue = 100;`\n\n`printSquares();`\n\n`function printSquares() {`\n\n  `for (let i = 0; i <= maxValue; i++) {`\n\n    `// First get the squared value.`\n\n    `let square = i ** 2;`\n\n    `// Now print the squared value.`\n\n    `console.log(square);`\n\n  `}`\n\n`}`\n\n![Extracting the for loop to a function in TypeScript 3.9. A newline is preserved.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/03/printSquaresWithNewlines-3.9.gif.gif)\n\nYou can see more about the implementation [in this pull request](https://github.com/microsoft/TypeScript/pull/36688)\n\n### [](#quick-fixes-for-missing-return-expressions)Quick Fixes for Missing Return Expressions\n\nThere are occasions where we might forget to return the value of the last statement in a function, especially when adding curly braces to arrow functions.\n\nts\n\n`// before`\n\n`let f1 = () => 42;`\n\n`// oops - not the same!`\n\n`let f2 = () => {`\n\n  `42;`\n\n`};`\n\nThanks to [a pull request](https://github.com/microsoft/TypeScript/pull/26434) from community member [Wenlu Wang](https://github.com/Kingwl), TypeScript can provide a quick-fix to add missing `return` statements, remove curly braces, or add parentheses to arrow function bodies that look suspiciously like object literals.\n\n![TypeScript fixing an error where no expression is returned by adding a return statement or removing curly braces.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/04/missingReturnValue-3-9.gif)\n\n### [](#support-for-solution-style-tsconfigjson-files)Support for “Solution Style” `tsconfig.json` Files\n\nEditors need to figure out which configuration file a file belongs to so that it can apply the appropriate options and figure out which other files are included in the current “project”. By default, editors powered by TypeScript’s language server do this by walking up each parent directory to find a `tsconfig.json`.\n\nOne case where this slightly fell over is when a `tsconfig.json` simply existed to reference other `tsconfig.json` files.\n\n`// tsconfig.json`\n\n`{`\n\n  `\"\": [],`\n\n  `\"\": [`\n\n    `{ \"path\": \"./tsconfig.shared.json\" },`\n\n    `{ \"path\": \"./tsconfig.frontend.json\" },`\n\n    `{ \"path\": \"./tsconfig.backend.json\" }`\n\n  `]`\n\n`}`\n\nThis file that really does nothing but manage other project files is often called a “solution” in some environments. Here, none of these `tsconfig.*.json` files get picked up by the server, but we’d really like the language server to understand that the current `.ts` file probably belongs to one of the mentioned projects in this root `tsconfig.json`.\n\nTypeScript 3.9 adds support to editing scenarios for this configuration. For more details, take a look at [the pull request that added this functionality](https://github.com/microsoft/TypeScript/pull/37239).\n\n## [](#breaking-changes)Breaking Changes\n\n### [](#parsing-differences-in-optional-chaining-and-non-null-assertions)Parsing Differences in Optional Chaining and Non-Null Assertions\n\nTypeScript recently implemented the optional chaining operator, but we’ve received user feedback that the behavior of optional chaining (`?.`) with the non-null assertion operator (`!`) is extremely counter-intuitive.\n\nSpecifically, in previous versions, the code\n\nts\n\n`foo?.bar!.baz;`\n\nwas interpreted to be equivalent to the following JavaScript.\n\njs\n\n`(foo?.bar).baz;`\n\nIn the above code the parentheses stop the “short-circuiting” behavior of optional chaining, so if `foo` is `undefined`, accessing `baz` will cause a runtime error.\n\nThe Babel team who pointed this behavior out, and most users who provided feedback to us, believe that this behavior is wrong. We do too! The thing we heard the most was that the `!` operator should just “disappear” since the intent was to remove `null` and `undefined` from the type of `bar`.\n\nIn other words, most people felt that the original snippet should be interpreted as\n\njs\n\n`foo?.bar.baz;`\n\nwhich just evaluates to `undefined` when `foo` is `undefined`.\n\nThis is a breaking change, but we believe most code was written with the new interpretation in mind. Users who want to revert to the old behavior can add explicit parentheses around the left side of the `!` operator.\n\nts\n\n`foo?.bar!.baz;`\n\n### [](#-and--are-now-invalid-jsx-text-characters)`}` and `>` are Now Invalid JSX Text Characters\n\nThe JSX Specification forbids the use of the `}` and `>` characters in text positions. TypeScript and Babel have both decided to enforce this rule to be more conformant. The new way to insert these characters is to use an HTML escape code (e.g. `<span> 2 &gt 1 </span>`) or insert an expression with a string literal (e.g. `<span> 2 {\">\"} 1 </span>`).\n\nLuckily, thanks to the [pull request](https://github.com/microsoft/TypeScript/pull/36636) enforcing this from [Brad Zacher](https://github.com/bradzacher), you’ll get an error message along the lines of\n\n``Unexpected token. Did you mean `{'>'}` or `>`?``\n\n``Unexpected token. Did you mean `{'}'}` or `}`?``\n\nFor example:\n\ntsx\n\n`let directions = <span>Navigate to: Menu Bar > Tools > Options</span>;`\n\n`//                                           ~       ~`\n\n``// Unexpected token. Did you mean `{'>'}` or `>`?``\n\nThat error message came with a handy quick fix, and thanks to [Alexander Tarasyuk](https://github.com/a-tarasyuk), [you can apply these changes in bulk](https://github.com/microsoft/TypeScript/pull/37436) if you have a lot of errors.\n\n### [](#stricter-checks-on-intersections-and-optional-properties)Stricter Checks on Intersections and Optional Properties\n\nGenerally, an intersection type like `A & B` is assignable to `C` if either `A` or `B` is assignable to `C`; however, sometimes that has problems with optional properties. For example, take the following:\n\nts\n\n`interface A {`\n\n  `a: number; // notice this is 'number'`\n\n`}`\n\n`interface B {`\n\n  `b: string;`\n\n`}`\n\n`interface C {`\n\n  `a?: boolean; // notice this is 'boolean'`\n\n  `b: string;`\n\n`}`\n\n`declare let x: A & B;`\n\n`declare let y: C;`\n\n`y = x;`\n\nIn previous versions of TypeScript, this was allowed because while `A` was totally incompatible with `C`, `B` _was_ compatible with `C`.\n\nIn TypeScript 3.9, so long as every type in an intersection is a concrete object type, the type system will consider all of the properties at once. As a result, TypeScript will see that the `a` property of `A & B` is incompatible with that of `C`:\n\n`Type 'A & B' is not assignable to type 'C'.`\n\n  `Types of property 'a' are incompatible.`\n\n    `Type 'number' is not assignable to type 'boolean | undefined'.`\n\nFor more information on this change, [see the corresponding pull request](https://github.com/microsoft/TypeScript/pull/37195).\n\n### [](#intersections-reduced-by-discriminant-properties)Intersections Reduced By Discriminant Properties\n\nThere are a few cases where you might end up with types that describe values that just don’t exist. For example\n\nts\n\n`declare function smushObjects<T, U>(x: T, y: U): T & U;`\n\n`interface Circle {`\n\n  `kind: \"circle\";`\n\n  `radius: number;`\n\n`}`\n\n`interface Square {`\n\n  `kind: \"square\";`\n\n  `sideLength: number;`\n\n`}`\n\n`declare let x: Circle;`\n\n`declare let y: Square;`\n\n`let z = smushObjects(x, y);`\n\n`console.log(z.kind);`\n\nThis code is slightly weird because there’s really no way to create an intersection of a `Circle` and a `Square` - they have two incompatible `kind` fields. In previous versions of TypeScript, this code was allowed and the type of `kind` itself was `never` because `\"circle\" & \"square\"` described a set of values that could `never` exist.\n\nIn TypeScript 3.9, the type system is more aggressive here - it notices that it’s impossible to intersect `Circle` and `Square` because of their `kind` properties. So instead of collapsing the type of `z.kind` to `never`, it collapses the type of `z` itself (`Circle & Square`) to `never`. That means the above code now errors with:\n\n`Property 'kind' does not exist on type 'never'.`\n\nMost of the breaks we observed seem to correspond with slightly incorrect type declarations. For more details, [see the original pull request](https://github.com/microsoft/TypeScript/pull/36696).\n\nIn older versions of TypeScript, `get` and `set` accessors in classes were emitted in a way that made them enumerable; however, this wasn’t compliant with the ECMAScript specification which states that they must be non-enumerable. As a result, TypeScript code that targeted ES5 and ES2015 could differ in behavior.\n\nThanks to [a pull request](https://github.com/microsoft/TypeScript/pull/32264) from GitHub user [pathurs](https://github.com/pathurs), TypeScript 3.9 now conforms more closely with ECMAScript in this regard.\n\n### [](#type-parameters-that-extend-any-no-longer-act-as-any)Type Parameters That Extend `any` No Longer Act as `any`\n\nIn previous versions of TypeScript, a type parameter constrained to `any` could be treated as `any`.\n\nts\n\n`function foo<T extends any>(arg: T) {`\n\n  `arg.spfjgerijghoied; // no error!`\n\n`}`\n\nThis was an oversight, so TypeScript 3.9 takes a more conservative approach and issues an error on these questionable operations.\n\nts\n\n`function foo<T extends any>(arg: T) {`\n\n  `arg.spfjgerijghoied;`\n\n  `//  ~~~~~~~~~~~~~~~`\n\n  `// Property 'spfjgerijghoied' does not exist on type 'T'.`\n\n`}`\n\n### [](#export--is-always-retained)`export *` is Always Retained\n\nIn previous TypeScript versions, declarations like `export * from \"foo\"` would be dropped in our JavaScript output if `foo` didn’t export any values. This sort of emit is problematic because it’s type-directed and can’t be emulated by Babel. TypeScript 3.9 will always emit these `export *` declarations. In practice, we don’t expect this to break much existing code.\n\n### [](#more-libdomdts-refinements)More libdom.d.ts refinements\n\nWe are continuing to move more of TypeScript’s built-in .d.ts library (lib.d.ts and family) to be generated from Web IDL files directly from the DOM specification. As a result some vendor-specific types related to media access have been removed.\n\nAdding this file to an ambient `*.d.ts` to your project will bring them back:\n\nts\n\n`interface AudioTrackList {`\n\n     `[Symbol.iterator](): IterableIterator<AudioTrack>;`\n\n `}`\n\n`interface HTMLVideoElement {`\n\n  `readonly audioTracks: AudioTrackList`\n\n  `msFrameStep(forward: boolean): void;`\n\n  `msInsertVideoEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;`\n\n  `msSetVideoRectangle(left: number, top: number, right: number, bottom: number): void;`\n\n  `webkitEnterFullScreen(): void;`\n\n  `webkitEnterFullscreen(): void;`\n\n  `webkitExitFullScreen(): void;`\n\n  `webkitExitFullscreen(): void;`\n\n  `msHorizontalMirror: boolean;`\n\n  `readonly msIsLayoutOptimalForPlayback: boolean;`\n\n  `readonly msIsStereo3D: boolean;`\n\n  `msStereo3DPackingMode: string;`\n\n  `msStereo3DRenderMode: string;`\n\n  `msZoom: boolean;`\n\n  `onMSVideoFormatChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;`\n\n  `onMSVideoFrameStepCompleted: ((this: HTMLVideoElement, ev: Event) => any) | null;`\n\n  `onMSVideoOptimalLayoutChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;`\n\n  `webkitDisplayingFullscreen: boolean;`\n\n  `webkitSupportsFullscreen: boolean;`\n\n`}`\n\n`interface MediaError {`\n\n  `readonly msExtendedCode: number;`\n\n  `readonly MS_MEDIA_ERR_ENCRYPTED: number;`\n\n`}`",
    "title": "TypeScript: Documentation - TypeScript 3.9",
    "description": "TypeScript 3.9 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html",
    "markdown": "# TypeScript: Documentation - TypeScript 5.1\n\n## [](#easier-implicit-returns-for-undefined-returning-functions)Easier Implicit Returns for `undefined`\\-Returning Functions\n\nIn JavaScript, if a function finishes running without hitting a `return`, it returns the value `undefined`.\n\nts\n\n`function foo() {`\n\n    `// no return`\n\n`}`\n\n`// x = undefined`\n\n`let x = foo();`\n\nHowever, in previous versions of TypeScript, the _only_ functions that could have absolutely no return statements were `void`\\- and `any`\\-returning functions. That meant that even if you explicitly said “this function returns `undefined`” you were forced to have at least one return statement.\n\nts\n\n`// ✅ fine - we inferred that 'f1' returns 'void'`\n\n`function f1() {`\n\n    `// no returns`\n\n`}`\n\n`// ✅ fine - 'void' doesn't need a return statement`\n\n`function f2(): void {`\n\n    `// no returns`\n\n`}`\n\n`// ✅ fine - 'any' doesn't need a return statement`\n\n`function f3(): any {`\n\n    `// no returns`\n\n`}`\n\n`// ❌ error!`\n\n`// A function whose declared type is neither 'void' nor 'any' must return a value.`\n\n`function f4(): undefined {`\n\n    `// no returns`\n\n`}`\n\nThis could be a pain if some API expected a function returning `undefined` - you would need to have either at least one explicit return of `undefined` or a `return` statement _and_ an explicit annotation.\n\nts\n\n`declare function takesFunction(f: () => undefined): undefined;`\n\n`// ❌ error!`\n\n`// Argument of type '() => void' is not assignable to parameter of type '() => undefined'.`\n\n`takesFunction(() => {`\n\n    `// no returns`\n\n`});`\n\n`// ❌ error!`\n\n`// A function whose declared type is neither 'void' nor 'any' must return a value.`\n\n`takesFunction((): undefined => {`\n\n    `// no returns`\n\n`});`\n\n`// ❌ error!`\n\n`// Argument of type '() => void' is not assignable to parameter of type '() => undefined'.`\n\n`takesFunction(() => {`\n\n    `return;`\n\n`});`\n\n`// ✅ works`\n\n`takesFunction(() => {`\n\n    `return undefined;`\n\n`});`\n\n`// ✅ works`\n\n`takesFunction((): undefined => {`\n\n    `return;`\n\n`});`\n\nThis behavior was frustrating and confusing, especially when calling functions outside of one’s control. Understanding the interplay between inferring `void` over `undefined`, whether an `undefined`\\-returning function needs a `return` statement, etc. seems like a distraction.\n\nFirst, TypeScript 5.1 now allows `undefined`\\-returning functions to have no return statement.\n\nts\n\n`// ✅ Works in TypeScript 5.1!`\n\n`function f4(): undefined {`\n\n    `// no returns`\n\n`}`\n\n`// ✅ Works in TypeScript 5.1!`\n\n`takesFunction((): undefined => {`\n\n    `// no returns`\n\n`});`\n\nSecond, if a function has no return expressions and is being passed to something expecting a function that returns `undefined`, TypeScript infers `undefined` for that function’s return type.\n\nts\n\n`// ✅ Works in TypeScript 5.1!`\n\n`takesFunction(function f() {`\n\n    `//                 ^ return type is undefined`\n\n    `// no returns`\n\n`});`\n\n`// ✅ Works in TypeScript 5.1!`\n\n`takesFunction(function f() {`\n\n    `//                 ^ return type is undefined`\n\n    `return;`\n\n`});`\n\nTo address another similar pain-point, under TypeScript’s `--noImplicitReturns` option, functions returning _only_ `undefined` now have a similar exception to `void`, in that not every single code path must end in an explicit `return`.\n\nts\n\n`// ✅ Works in TypeScript 5.1 under '--noImplicitReturns'!`\n\n`function f(): undefined {`\n\n    `if (Math.random()) {`\n\n        `// do some stuff...`\n\n        `return;`\n\n    `}`\n\n`}`\n\nFor more information, you can read up on [the original issue](https://github.com/microsoft/TypeScript/issues/36288) and [the implementing pull request](https://github.com/microsoft/TypeScript/pull/53607).\n\nTypeScript 4.3 made it possible to say that a `get` and `set` accessor pair might specify two different types.\n\nts\n\n`interface Serializer {`\n\n    `set value(v: string | number | boolean);`\n\n    `get value(): string;`\n\n`}`\n\n`declare let box: Serializer;`\n\n`// Allows writing a 'boolean'`\n\n`box.value = true;`\n\n`// Comes out as a 'string'`\n\n`console.log(box.value.toUpperCase());`\n\nInitially we required that the `get` type had to be a subtype of the `set` type. This meant that writing\n\nts\n\n`box.value = box.value;`\n\nwould always be valid.\n\nHowever, there are plenty of existing and proposed APIs that have completely unrelated types between their getters and setters. For example, consider one of the most common examples - the `style` property in the DOM and [`CSSStyleRule`](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleRule) API. Every style rule has [a `style` property](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleRule/style) that is a [`CSSStyleDeclaration`](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration); however, if you try to write to that property, it will only work correctly with a string!\n\nTypeScript 5.1 now allows completely unrelated types for `get` and `set` accessor properties, provided that they have explicit type annotations. And while this version of TypeScript does not yet change the types for these built-in interfaces, `CSSStyleRule` can now be defined in the following way:\n\nts\n\n`interface CSSStyleRule {`\n\n    `// ...`\n\n    ``/** Always reads as a `CSSStyleDeclaration` */``\n\n    `get style(): CSSStyleDeclaration;`\n\n    ``/** Can only write a `string` here. */``\n\n    `set style(newValue: string);`\n\n    `// ...`\n\n`}`\n\nThis also allows other patterns like requiring `set` accessors to accept only “valid” data, but specifying that `get` accessors may return `undefined` if some underlying state hasn’t been initialized yet.\n\nts\n\n`class SafeBox {`\n\n    `#value: string | undefined;`\n\n    `// Only accepts strings!`\n\n    `set value(newValue: string) {`\n\n    `}`\n\n    `// Must check for 'undefined'!`\n\n    `get value(): string | undefined {`\n\n        `return this.#value;`\n\n    `}`\n\n`}`\n\nIn fact, this is similar to how optional properties are checked under `--exactOptionalProperties`.\n\nYou can read up more on [the implementing pull request](https://github.com/microsoft/TypeScript/pull/53417).\n\n## [](#decoupled-type-checking-between-jsx-elements-and-jsx-tag-types)Decoupled Type-Checking Between JSX Elements and JSX Tag Types\n\nOne pain point TypeScript had with JSX was its requirements on the type of every JSX element’s tag.\n\nFor context, a JSX element is either of the following:\n\ntsx\n\n`// A self-closing JSX tag`\n\n`<Foo />`\n\n`// A regular element with an opening/closing tag`\n\n`<Bar></Bar>`\n\nWhen type-checking `<Foo />` or `<Bar></Bar>`, TypeScript always looks up a namespace called `JSX` and fetches a type out of it called `Element` - or more directly, it looks up `JSX.Element`.\n\nBut to check whether `Foo` or `Bar` themselves were valid to use as tag names, TypeScript would roughly just grab the types returned or constructed by `Foo` or `Bar` and check for compatibility with `JSX.Element` (or another type called `JSX.ElementClass` if the type is constructable).\n\nThe limitations here meant that components could not be used if they returned or “rendered” a more broad type than just `JSX.Element`. For example, a JSX library might be fine with a component returning `string`s or `Promise`s.\n\nAs a more concrete example, [React is considering adding limited support for components that return `Promise`s](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md), but existing versions of TypeScript cannot express that without someone drastically loosening the type of `JSX.Element`.\n\ntsx\n\n`import * as React from \"react\";`\n\n`async function Foo() {`\n\n    `return <div></div>;`\n\n`}`\n\n`let element = <Foo />;`\n\n`//             ~~~`\n\n`// 'Foo' cannot be used as a JSX component.`\n\n`//   Its return type 'Promise<Element>' is not a valid JSX element.`\n\nTo provide libraries with a way to express this, TypeScript 5.1 now looks up a type called `JSX.ElementType`. `ElementType` specifies precisely what is valid to use as a tag in a JSX element. So it might be typed today as something like\n\ntsx\n\n`namespace JSX {`\n\n    `export type ElementType =`\n\n        `// All the valid lowercase tags`\n\n        `keyof IntrinsicAttributes`\n\n        `// Function components`\n\n        `(props: any) => Element`\n\n        `// Class components`\n\n        `new (props: any) => ElementClass;`\n\n    `export interface IntrinsicAttributes extends /*...*/ {}`\n\n    `export type Element = /*...*/;`\n\n    `export type ElementClass = /*...*/;`\n\n`}`\n\nWe’d like to extend our thanks to [Sebastian Silbermann](https://github.com/eps1lon) who contributed [this change](https://github.com/microsoft/TypeScript/pull/51328)!\n\n## [](#namespaced-jsx-attributes)Namespaced JSX Attributes\n\nTypeScript now supports namespaced attribute names when using JSX.\n\ntsx\n\n`import * as React from \"react\";`\n\n`// Both of these are equivalent:`\n\n`const x = <Foo a:b=\"hello\" />;`\n\n`const y = <Foo a : b=\"hello\" />;`\n\n`interface FooProps {`\n\n    `\"a:b\": string;`\n\n`}`\n\n`function Foo(props: FooProps) {`\n\n    `return <div>{props[\"a:b\"]}</div>;`\n\n`}`\n\nNamespaced tag names are looked up in a similar way on `JSX.IntrinsicAttributes` when the first segment of the name is a lowercase name.\n\ntsx\n\n`// In some library's code or in an augmentation of that library:`\n\n`namespace JSX {`\n\n    `interface IntrinsicElements {`\n\n        `[\"a:b\"]: { prop: string };`\n\n    `}`\n\n`}`\n\n`// In our code:`\n\n`let x = <a:b prop=\"hello!\" />;`\n\n[This contribution](https://github.com/microsoft/TypeScript/pull/53799) was provided thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk).\n\n## [](#typeroots-are-consulted-in-module-resolution)`typeRoots` Are Consulted In Module Resolution\n\nWhen TypeScript’s specified module lookup strategy is unable to resolve a path, it will now resolve packages relative to the specified `typeRoots`.\n\nSee [this pull request](https://github.com/microsoft/TypeScript/pull/51715) for more details.\n\n## [](#move-declarations-to-existing-files)Move Declarations to Existing Files\n\nIn addition to moving declarations to new files, TypeScript now ships a preview feature for moving declarations to existing files as well. You can try this functionality out in a recent version of Visual Studio Code.\n\n![Moving a function 'getThanks' to an existing file in the workspace.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/moveToFile-5.1-preview.gif)\n\nKeep in mind that this feature is currently in preview, and we are seeking further feedback on it.\n\n[https://github.com/microsoft/TypeScript/pull/53542](https://github.com/microsoft/TypeScript/pull/53542)\n\nTypeScript now supports _linked editing_ for JSX tag names. Linked editing (occasionally called “mirrored cursors”) allows an editor to edit multiple locations at the same time automatically.\n\n![An example of JSX tags with linked editing modifying a JSX fragment and a div element.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/04/linkedEditingJsx-5.1-1.gif)\n\nThis new feature should work in both TypeScript and JavaScript files, and can be enabled in Visual Studio Code Insiders. In Visual Studio Code, you can either edit the `Editor: Linked Editing` option in the Settings UI:\n\n![Visual Studio Code's Editor: Linked Editing` option](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/04/linkedEditing-5.1-vscode-ui-1.png)\n\nor configure `editor.linkedEditing` in your JSON settings file:\n\njsonc\n\n`{`\n\n    `// ...`\n\n    `\"editor.linkedEditing\": true,`\n\n`}`\n\nThis feature will also be supported by Visual Studio 17.7 Preview 1.\n\nYou can take a look at [our implementation of linked editing](https://github.com/microsoft/TypeScript/pull/53284) here!\n\nTypeScript now provides snippet completions when typing out a `@param` tag in both TypeScript and JavaScript files. This can help cut down on some typing and jumping around text as you document your code or add JSDoc types in JavaScript.\n\n![An example of completing JSDoc param comments on an 'add' function.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/04/paramTagSnippets-5-1-1.gif)\n\nYou can [check out how this new feature was implemented on GitHub](https://github.com/microsoft/TypeScript/pull/53260).\n\n## [](#optimizations)Optimizations\n\n### [](#avoiding-unnecessary-type-instantiation)Avoiding Unnecessary Type Instantiation\n\nTypeScript 5.1 now avoids performing type instantiation within object types that are known not to contain references to outer type parameters. This has the potential to cut down on many unnecessary computations, and reduced the type-checking time of [material-ui’s docs directory](https://github.com/mui/material-ui/tree/b0351248fb396001a30330daac86d0e0794a0c1d/docs) by over 50%.\n\nYou can [see the changes involved for this change on GitHub](https://github.com/microsoft/TypeScript/pull/53246).\n\n### [](#negative-case-checks-for-union-literals)Negative Case Checks for Union Literals\n\nWhen checking if a source type is part of a union type, TypeScript will first do a fast look-up using an internal type identifier for that source. If that look-up fails, then TypeScript checks for compatibility against every type within the union.\n\nWhen relating a literal type to a union of purely literal types, TypeScript can now avoid that full walk against every other type in the union. This assumption is safe because TypeScript always interns/caches literal types - though there are some edge cases to handle relating to “fresh” literal types.\n\n[This optimization](https://github.com/microsoft/TypeScript/pull/53192) was able to reduce the type-checking time of [the code in this issue](https://github.com/microsoft/TypeScript/issues/53191) from about 45 seconds to about 0.4 seconds.\n\n### [](#reduced-calls-into-scanner-for-jsdoc-parsing)Reduced Calls into Scanner for JSDoc Parsing\n\nWhen older versions of TypeScript parsed out a JSDoc comment, they would use the scanner/tokenizer to break the comment into fine-grained tokens and piece the contents back together. This could be helpful for normalizing comment text, so that multiple spaces would just collapse into one; but it was extremely “chatty” and meant the parser and scanner would jump back and forth very often, adding overhead to JSDoc parsing.\n\nTypeScript 5.1 has moved more logic around breaking down JSDoc comments into the scanner/tokenizer. The scanner now returns larger chunks of content directly to the parser to do as it needs.\n\n[These changes](https://github.com/microsoft/TypeScript/pull/53081) have brought down the parse time of several 10Mb mostly-prose-comment JavaScript files by about half. For a more realistic example, our performance suite’s snapshot of [xstate](https://github.com/statelyai/xstate) dropped about 300ms of parse time, making it faster to load and analyze.\n\n## [](#breaking-changes)Breaking Changes\n\n### [](#es2020-and-nodejs-1417-as-minimum-runtime-requirements)ES2020 and Node.js 14.17 as Minimum Runtime Requirements\n\nTypeScript 5.1 now ships JavaScript functionality that was introduced in ECMAScript 2020. As a result, at minimum TypeScript must be run in a reasonably modern runtime. For most users, this means TypeScript now only runs on Node.js 14.17 and later.\n\nIf you try running TypeScript 5.1 under an older version of Node.js such as Node 10 or 12, you may see an error like the following from running either `tsc.js` or `tsserver.js`:\n\n`node_modules/typescript/lib/tsserver.js:2406`\n\n  `for (let i = startIndex ?? 0; i < array.length; i++) {`\n\n                           `^`\n\n`SyntaxError: Unexpected token '?'`\n\n    `at wrapSafe (internal/modules/cjs/loader.js:915:16)`\n\n    `at Module._compile (internal/modules/cjs/loader.js:963:27)`\n\n    `at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10)`\n\n    `at Module.load (internal/modules/cjs/loader.js:863:32)`\n\n    `at Function.Module._load (internal/modules/cjs/loader.js:708:14)`\n\n    `at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)`\n\n    `at internal/main/run_main_module.js:17:47`\n\nAdditionally, if you try installing TypeScript you’ll get something like the following error messages from npm:\n\n`npm WARN EBADENGINE Unsupported engine {`\n\n`npm WARN EBADENGINE   package: 'typescript@5.1.1-rc',`\n\n`npm WARN EBADENGINE   required: { node: '>=14.17' },`\n\n`npm WARN EBADENGINE   current: { node: 'v12.22.12', npm: '8.19.2' }`\n\n`npm WARN EBADENGINE }`\n\nfrom Yarn:\n\n`error typescript@5.1.1-rc: The engine \"node\" is incompatible with this module. Expected version \">=14.17\". Got \"12.22.12\"`\n\n`error Found incompatible module.`\n\n[See more information around this change here](https://github.com/microsoft/TypeScript/pull/53291).\n\n### [](#explicit-typeroots-disables-upward-walks-for-node_modulestypes)Explicit `typeRoots` Disables Upward Walks for `node_modules/@types`\n\nPreviously, when the `typeRoots` option was specified in a `tsconfig.json` but resolution to any `typeRoots` directories had failed, TypeScript would still continue walking up parent directories, trying to resolve packages within each parent’s `node_modules/@types` folder.\n\nThis behavior could prompt excessive look-ups and has been disabled in TypeScript 5.1. As a result, you may begin to see errors like the following based on entries in your `tsconfig.json`’s `types` option or `/// <reference >` directives\n\n`error TS2688: Cannot find type definition file for 'node'.`\n\n`error TS2688: Cannot find type definition file for 'mocha'.`\n\n`error TS2688: Cannot find type definition file for 'jasmine'.`\n\n`error TS2688: Cannot find type definition file for 'chai-http'.`\n\n`error TS2688: Cannot find type definition file for 'webpack-env\"'.`\n\nThe solution is typically to add specific entries for `node_modules/@types` to your `typeRoots`:\n\njsonc\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"types\": [`\n\n            `\"node\",`\n\n            `\"mocha\"`\n\n        `],`\n\n        `\"typeRoots\": [`\n\n            `// Keep whatever you had around before.`\n\n            `\"./some-custom-types/\",`\n\n            `// You might need your local 'node_modules/@types'.`\n\n            `\"./node_modules/@types\",`\n\n            `// You might also need to specify a shared 'node_modules/@types'`\n\n            `// if you're using a \"monorepo\" layout.`\n\n            `\"../../node_modules/@types\",`\n\n        `]`\n\n    `}`\n\n`}`\n\nMore information is available [on the original change on our issue tracker](https://github.com/microsoft/TypeScript/pull/51715).",
    "title": "TypeScript: Documentation - TypeScript 5.1",
    "description": "TypeScript 5.1 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.8\n\n## [](#type-only-imports-and-export)Type-Only Imports and Export\n\nThis feature is something most users may never have to think about; however, if you’ve hit issues under [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules), TypeScript’s `transpileModule` API, or Babel, this feature might be relevant.\n\nTypeScript 3.8 adds a new syntax for type-only imports and exports.\n\nts\n\n`import type { SomeThing } from \"./some-module.js\";`\n\n`export type { SomeThing };`\n\n`import type` only imports declarations to be used for type annotations and declarations. It _always_ gets fully erased, so there’s no remnant of it at runtime. Similarly, `export type` only provides an export that can be used for type contexts, and is also erased from TypeScript’s output.\n\nIt’s important to note that classes have a value at runtime and a type at design-time, and the use is context-sensitive. When using `import type` to import a class, you can’t do things like extend from it.\n\nts\n\n`import type { Component } from \"react\";`\n\n`interface ButtonProps {`\n\n  `// ...`\n\n`}`\n\n`class Button extends Component<ButtonProps> {`\n\n  `//               ~~~~~~~~~`\n\n  `// error! 'Component' only refers to a type, but is being used as a value here.`\n\n  `// ...`\n\n`}`\n\nIf you’ve used Flow before, the syntax is fairly similar. One difference is that we’ve added a few restrictions to avoid code that might appear ambiguous.\n\nts\n\n`// Is only 'Foo' a type? Or every declaration in the import?`\n\n`// We just give an error because it's not clear.`\n\n`import type Foo, { Bar, Baz } from \"some-module\";`\n\n`//     ~~~~~~~~~~~~~~~~~~~~~~`\n\n`// error! A type-only import can specify a default import or named bindings, but not both.`\n\nIn conjunction with `import type`, TypeScript 3.8 also adds a new compiler flag to control what happens with imports that won’t be utilized at runtime: [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues). This flag takes 3 different values:\n\n*   `remove`: this is today’s behavior of dropping these imports. It’s going to continue to be the default, and is a non-breaking change.\n*   `preserve`: this _preserves_ all imports whose values are never used. This can cause imports/side-effects to be preserved.\n*   `error`: this preserves all imports (the same as the `preserve` option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.\n\nFor more information about the feature, you can [take a look at the pull request](https://github.com/microsoft/TypeScript/pull/35200), and [relevant changes](https://github.com/microsoft/TypeScript/pull/36092/) around broadening where imports from an `import type` declaration can be used.\n\n## [](#ecmascript-private-fields)ECMAScript Private Fields\n\nTypeScript 3.8 brings support for ECMAScript’s private fields, part of the [stage-3 class fields proposal](https://github.com/tc39/proposal-class-fields/).\n\nts\n\n`class Person {`\n\n  `#name: string;`\n\n  `constructor(name: string) {`\n\n    `this.#name = name;`\n\n  `}`\n\n  `greet() {`\n\n    ``console.log(`Hello, my name is ${this.#name}!`);``\n\n  `}`\n\n`}`\n\n`let jeremy = new Person(\"Jeremy Bearimy\");`\n\n`jeremy.#name;`\n\n`//     ~~~~~`\n\n`// Property '#name' is not accessible outside class 'Person'`\n\n`// because it has a private identifier.`\n\nUnlike regular properties (even ones declared with the `private` modifier), private fields have a few rules to keep in mind. Some of them are:\n\n*   Private fields start with a `#` character. Sometimes we call these _private names_.\n*   Every private field name is uniquely scoped to its containing class.\n*   TypeScript accessibility modifiers like `public` or `private` can’t be used on private fields.\n*   Private fields can’t be accessed or even detected outside of the containing class - even by JS users! Sometimes we call this _hard privacy_.\n\nApart from “hard” privacy, another benefit of private fields is that uniqueness we just mentioned. For example, regular property declarations are prone to being overwritten in subclasses.\n\nts\n\n`class C {`\n\n  `foo = 10;`\n\n  `cHelper() {`\n\n    `return this.foo;`\n\n  `}`\n\n`}`\n\n`class D extends C {`\n\n  `foo = 20;`\n\n  `dHelper() {`\n\n    `return this.foo;`\n\n  `}`\n\n`}`\n\n`let instance = new D();`\n\n`// 'this.foo' refers to the same property on each instance.`\n\n`console.log(instance.cHelper()); // prints '20'`\n\n`console.log(instance.dHelper()); // prints '20'`\n\nWith private fields, you’ll never have to worry about this, since each field name is unique to the containing class.\n\nts\n\n`class C {`\n\n  `#foo = 10;`\n\n  `cHelper() {`\n\n    `return this.#foo;`\n\n  `}`\n\n`}`\n\n`class D extends C {`\n\n  `#foo = 20;`\n\n  `dHelper() {`\n\n    `return this.#foo;`\n\n  `}`\n\n`}`\n\n`let instance = new D();`\n\n`// 'this.#foo' refers to a different field within each class.`\n\n`console.log(instance.cHelper()); // prints '10'`\n\n`console.log(instance.dHelper()); // prints '20'`\n\nAnother thing worth noting is that accessing a private field on any other type will result in a `TypeError`!\n\nts\n\n`class Square {`\n\n  `#sideLength: number;`\n\n  `constructor(sideLength: number) {`\n\n    `this.#sideLength = sideLength;`\n\n  `}`\n\n  `equals(other: any) {`\n\n    `return this.#sideLength === other.#sideLength;`\n\n  `}`\n\n`}`\n\n`const a = new Square(100);`\n\n`const b = { sideLength: 100 };`\n\n`// Boom!`\n\n`// TypeError: attempted to get private field on non-instance`\n\n`// This fails because 'b' is not an instance of 'Square'.`\n\n`console.log(a.equals(b));`\n\nFinally, for any plain `.js` file users, private fields _always_ have to be declared before they’re assigned to.\n\njs\n\n`class C {`\n\n  `// No declaration for '#foo'`\n\n  `// :(`\n\n  `constructor(foo: number) {`\n\n    `// SyntaxError!`\n\n    `// '#foo' needs to be declared before writing to it.`\n\n    `this.#foo = foo;`\n\n  `}`\n\n`}`\n\nJavaScript has always allowed users to access undeclared properties, whereas TypeScript has always required declarations for class properties. With private fields, declarations are always needed regardless of whether we’re working in `.js` or `.ts` files.\n\njs\n\n`class C {`\n\n  `/** @type {number} */`\n\n  `#foo;`\n\n  `constructor(foo: number) {`\n\n    `// This works.`\n\n    `this.#foo = foo;`\n\n  `}`\n\n`}`\n\nFor more information about the implementation, you can [check out the original pull request](https://github.com/Microsoft/TypeScript/pull/30829)\n\n### [](#which-should-i-use)Which should I use?\n\nWe’ve already received many questions on which type of privates you should use as a TypeScript user: most commonly, “should I use the `private` keyword, or ECMAScript’s hash/pound (`#`) private fields?” It depends!\n\nWhen it comes to properties, TypeScript’s `private` modifiers are fully erased - that means that at runtime, it acts entirely like a normal property and there’s no way to tell that it was declared with a `private` modifier. When using the `private` keyword, privacy is only enforced at compile-time/design-time, and for JavaScript consumers it’s entirely intent-based.\n\nts\n\n`class C {`\n\n  `private foo = 10;`\n\n`}`\n\n`// This is an error at compile time,`\n\n`// but when TypeScript outputs .js files,`\n\n`// it'll run fine and print '10'.`\n\n`console.log(new C().foo); // prints '10'`\n\n`//                  ~~~`\n\n`// error! Property 'foo' is private and only accessible within class 'C'.`\n\n`// TypeScript allows this at compile-time`\n\n`// as a \"work-around\" to avoid the error.`\n\n`console.log(new C()[\"foo\"]); // prints '10'`\n\nThe upside is that this sort of “soft privacy” can help your consumers temporarily work around not having access to some API, and also works in any runtime.\n\nOn the other hand, ECMAScript’s `#` privates are completely inaccessible outside of the class.\n\nts\n\n`class C {`\n\n  `#foo = 10;`\n\n`}`\n\n`console.log(new C().#foo); // SyntaxError`\n\n`//                  ~~~~`\n\n`// TypeScript reports an error *and*`\n\n`// this won't work at runtime!`\n\n`console.log(new C()[\"#foo\"]); // prints undefined`\n\n`//          ~~~~~~~~~~~~~~~`\n\n`// TypeScript reports an error under 'noImplicitAny',`\n\n`// and this prints 'undefined'.`\n\nThis hard privacy is really useful for strictly ensuring that nobody can take use of any of your internals. If you’re a library author, removing or renaming a private field should never cause a breaking change.\n\nAs we mentioned, another benefit is that subclassing can be easier with ECMAScript’s `#` privates because they _really_ are private. When using ECMAScript `#` private fields, no subclass ever has to worry about collisions in field naming. When it comes to TypeScript’s `private` property declarations, users still have to be careful not to trample over properties declared in superclasses.\n\nOne more thing to think about is where you intend for your code to run. TypeScript currently can’t support this feature unless targeting ECMAScript 2015 (ES6) targets or higher. This is because our downleveled implementation uses `WeakMap`s to enforce privacy, and `WeakMap`s can’t be polyfilled in a way that doesn’t cause memory leaks. In contrast, TypeScript’s `private`\\-declared properties work with all targets - even ECMAScript 3!\n\nA final consideration might be speed: `private` properties are no different from any other property, so accessing them is as fast as any other property access no matter which runtime you target. In contrast, because `#` private fields are downleveled using `WeakMap`s, they may be slower to use. While some runtimes might optimize their actual implementations of `#` private fields, and even have speedy `WeakMap` implementations, that might not be the case in all runtimes.\n\n## [](#export--as-ns-syntax)`export * as ns` Syntax\n\nIt’s often common to have a single entry-point that exposes all the members of another module as a single member.\n\nts\n\n`import * as utilities from \"./utilities.js\";`\n\n`export { utilities };`\n\nThis is so common that ECMAScript 2020 recently added a new syntax to support this pattern!\n\nts\n\n`export * as utilities from \"./utilities.js\";`\n\nThis is a nice quality-of-life improvement to JavaScript, and TypeScript 3.8 implements this syntax. When your module target is earlier than `es2020`, TypeScript will output something along the lines of the first code snippet.\n\n## [](#top-level-await)Top-Level `await`\n\nTypeScript 3.8 provides support for a handy upcoming ECMAScript feature called “top-level `await`“.\n\nJavaScript users often introduce an `async` function in order to use `await`, and then immediately called the function after defining it.\n\njs\n\n`async function main() {`\n\n  `const response = await fetch(\"...\");`\n\n  `const greeting = await response.text();`\n\n  `console.log(greeting);`\n\n`}`\n\n`main().catch((e) => console.error(e));`\n\nThis is because previously in JavaScript (along with most other languages with a similar feature), `await` was only allowed within the body of an `async` function. However, with top-level `await`, we can use `await` at the top level of a module.\n\nts\n\n`const response = await fetch(\"...\");`\n\n`const greeting = await response.text();`\n\n`console.log(greeting);`\n\n`// Make sure we're a module`\n\n`export {};`\n\nNote there’s a subtlety: top-level `await` only works at the top level of a _module_, and files are only considered modules when TypeScript finds an `import` or an `export`. In some basic cases, you might need to write out `export {}` as some boilerplate to make sure of this.\n\nTop level `await` may not work in all environments where you might expect at this point. Currently, you can only use top level `await` when the [`target`](https://www.typescriptlang.org/tsconfig#target) compiler option is `es2017` or above, and `module` is `esnext` or `system`. Support within several environments and bundlers may be limited or may require enabling experimental support.\n\nFor more information on our implementation, you can [check out the original pull request](https://github.com/microsoft/TypeScript/pull/35813).\n\n## [](#es2020-for-target-and-module)`es2020` for `target` and `module`\n\nTypeScript 3.8 supports `es2020` as an option for `module` and [`target`](https://www.typescriptlang.org/tsconfig#target). This will preserve newer ECMAScript 2020 features like optional chaining, nullish coalescing, `export * as ns`, and dynamic `import(...)` syntax. It also means `bigint` literals now have a stable [`target`](https://www.typescriptlang.org/tsconfig#target) below `esnext`.\n\n## [](#jsdoc-property-modifiers)JSDoc Property Modifiers\n\nTypeScript 3.8 supports JavaScript files by turning on the [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs) flag, and also supports _type-checking_ those JavaScript files via the [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs) option or by adding a `// @ts-check` comment to the top of your `.js` files.\n\nBecause JavaScript files don’t have dedicated syntax for type-checking, TypeScript leverages JSDoc. TypeScript 3.8 understands a few new JSDoc tags for properties.\n\nFirst are the accessibility modifiers: `@public`, `@private`, and `@protected`. These tags work exactly like `public`, `private`, and `protected` respectively work in TypeScript.\n\njs\n\n`// @ts-check`\n\n`class Foo {`\n\n  `constructor() {`\n\n    `/** @private */`\n\n    `this.stuff = 100;`\n\n  `}`\n\n  `printStuff() {`\n\n    `console.log(this.stuff);`\n\n  `}`\n\n`}`\n\n`new Foo().stuff;`\n\n`//        ~~~~~`\n\n`// error! Property 'stuff' is private and only accessible within class 'Foo'.`\n\n*   `@public` is always implied and can be left off, but means that a property can be reached from anywhere.\n*   `@private` means that a property can only be used within the containing class.\n*   `@protected` means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.\n\nNext, we’ve also added the `@readonly` modifier to ensure that a property is only ever written to during initialization.\n\njs\n\n`// @ts-check`\n\n`class Foo {`\n\n  `constructor() {`\n\n    `/** @readonly */`\n\n    `this.stuff = 100;`\n\n  `}`\n\n  `writeToStuff() {`\n\n    `this.stuff = 200;`\n\n    `//   ~~~~~`\n\n    `// Cannot assign to 'stuff' because it is a read-only property.`\n\n  `}`\n\n`}`\n\n`new Foo().stuff++;`\n\n`//        ~~~~~`\n\n`// Cannot assign to 'stuff' because it is a read-only property.`\n\n## [](#better-directory-watching-on-linux-and-watchoptions)Better Directory Watching on Linux and `watchOptions`\n\nTypeScript 3.8 ships a new strategy for watching directories, which is crucial for efficiently picking up changes to `node_modules`.\n\nFor some context, on operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on `node_modules` and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the number of files in `node_modules`, whereas there are way fewer directories to track.\n\nOlder versions of TypeScript would _immediately_ install directory watchers on folders, and at startup that would be fine; however, during an npm install, a lot of activity will take place within `node_modules` and that can overwhelm TypeScript, often slowing editor sessions to a crawl. To prevent this, TypeScript 3.8 waits slightly before installing directory watchers to give these highly volatile directories some time to stabilize.\n\nBecause every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new `watchOptions` field in `tsconfig.json` and `jsconfig.json` which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.\n\n`{`\n\n  `// Some typical compiler options`\n\n  `\"\": {`\n\n    `\"\": \"es2020\",`\n\n    `\"\": \"node\"`\n\n    `// ...`\n\n  `},`\n\n  `// NEW: Options for file/directory watching`\n\n  `\"watchOptions\": {`\n\n    `// Use native file system events for files and directories`\n\n    `\"\": \"useFsEvents\",`\n\n    `\"\": \"useFsEvents\",`\n\n    `// Poll files for updates more frequently`\n\n    `// when they're updated a lot.`\n\n    `\"\": \"dynamicPriority\"`\n\n  `}`\n\n`}`\n\n`watchOptions` contains 4 new options that can be configured:\n\n*   [`watchFile`](https://www.typescriptlang.org/tsconfig#watchFile): the strategy for how individual files are watched. This can be set to\n    \n    *   `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.\n    *   `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.\n    *   `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.\n    *   `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for file changes.\n    *   `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system’s native events to listen for changes on a file’s containing directories. This can use fewer file watchers, but might be less accurate.\n*   [`watchDirectory`](https://www.typescriptlang.org/tsconfig#watchDirectory): the strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality. This can be set to:\n    \n    *   `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.\n    *   `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.\n    *   `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for directory changes.\n*   [`fallbackPolling`](https://www.typescriptlang.org/tsconfig#fallbackPolling): when using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers. This can be set to\n    \n    *   `fixedPollingInterval`: _(See above.)_\n    *   `priorityPollingInterval`: _(See above.)_\n    *   `dynamicPriorityPolling`: _(See above.)_\n    *   `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.\n\nFor more information on these changes, [head over to GitHub to see the pull request](https://github.com/microsoft/TypeScript/pull/35615) to read more.\n\n## [](#fast-and-loose-incremental-checking)“Fast and Loose” Incremental Checking\n\nTypeScript 3.8 introduces a new compiler option called [`assumeChangesOnlyAffectDirectDependencies`](https://www.typescriptlang.org/tsconfig#assumeChangesOnlyAffectDirectDependencies). When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.\n\nFor example, consider a file `fileD.ts` that imports `fileC.ts` that imports `fileB.ts` that imports `fileA.ts` as follows:\n\n`fileA.ts <- fileB.ts <- fileC.ts <- fileD.ts`\n\nIn `--watch` mode, a change in `fileA.ts` would typically mean that TypeScript would need to at least re-check `fileB.ts`, `fileC.ts`, and `fileD.ts`. Under [`assumeChangesOnlyAffectDirectDependencies`](https://www.typescriptlang.org/tsconfig#assumeChangesOnlyAffectDirectDependencies), a change in `fileA.ts` means that only `fileA.ts` and `fileB.ts` need to be re-checked.\n\nIn a codebase like Visual Studio Code, this reduced rebuild times for changes in certain files from about 14 seconds to about 1 second. While we don’t necessarily recommend this option for all codebases, you might be interested if you have an extremely large codebase and are willing to defer full project errors until later (e.g. a dedicated build via a `tsconfig.fullbuild.json` or in CI).\n\nFor more details, you can [see the original pull request](https://github.com/microsoft/TypeScript/pull/35711).",
    "title": "TypeScript: Documentation - TypeScript 3.8",
    "description": "TypeScript 3.8 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.7\n\n## [](#optional-chaining)Optional Chaining\n\n[Playground](https://www.typescriptlang.org/play/#example/optional-chaining)\n\nOptional chaining is [issue #16](https://github.com/microsoft/TypeScript/issues/16) on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.\n\nAt its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a `null` or `undefined`. The star of the show in optional chaining is the new `?.` operator for _optional property accesses_. When we write code like\n\nts\n\n`let x = foo?.bar.baz();`\n\nthis is a way of saying that when `foo` is defined, `foo.bar.baz()` will be computed; but when `foo` is `null` or `undefined`, stop what we’re doing and just return `undefined`.”\n\nMore plainly, that code snippet is the same as writing the following.\n\nts\n\n`let x = foo === null || foo === undefined ? undefined : foo.bar.baz();`\n\nNote that if `bar` is `null` or `undefined`, our code will still hit an error accessing `baz`. Likewise, if `baz` is `null` or `undefined`, we’ll hit an error at the call site. `?.` only checks for whether the value on the _left_ of it is `null` or `undefined` - not any of the subsequent properties.\n\nYou might find yourself using `?.` to replace a lot of code that performs repetitive nullish checks using the `&&` operator.\n\nts\n\n`// Before`\n\n`if (foo && foo.bar && foo.bar.baz) {`\n\n  `// ...`\n\n`}`\n\n`// After-ish`\n\n`if (foo?.bar?.baz) {`\n\n  `// ...`\n\n`}`\n\nKeep in mind that `?.` acts differently than those `&&` operations since `&&` will act specially on “falsy” values (e.g. the empty string, `0`, `NaN`, and, well, `false`), but this is an intentional feature of the construct. It doesn’t short-circuit on valid data like `0` or empty strings.\n\nOptional chaining also includes two other operations. First there’s the _optional element access_ which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):\n\nts\n\n`/**`\n\n `* Get the first element of the array if we have an array.`\n\n `* Otherwise return undefined.`\n\n `*/`\n\n`function tryGetFirstElement<T>(arr?: T[]) {`\n\n  `return arr?.[0];`\n\n  `// equivalent to`\n\n  `//   return (arr === null || arr === undefined) ?`\n\n  `//       undefined :`\n\n  `//       arr[0];`\n\n`}`\n\nThere’s also _optional call_, which allows us to conditionally call expressions if they’re not `null` or `undefined`.\n\nts\n\n`async function makeRequest(url: string, log?: (msg: string) => void) {`\n\n  ``log?.(`Request started at ${new Date().toISOString()}`);``\n\n  `// roughly equivalent to`\n\n  `//   if (log != null) {`\n\n  ``//       log(`Request started at ${new Date().toISOString()}`);``\n\n  `//   }`\n\n  `const result = (await fetch(url)).json();`\n\n  ``log?.(`Request finished at ${new Date().toISOString()}`);``\n\n  `return result;`\n\n`}`\n\nThe “short-circuiting” behavior that optional chains have is limited property accesses, calls, element accesses - it doesn’t expand any further out from these expressions. In other words,\n\nts\n\n`let result = foo?.bar / someComputation();`\n\ndoesn’t stop the division or `someComputation()` call from occurring. It’s equivalent to\n\nts\n\n`let temp = foo === null || foo === undefined ? undefined : foo.bar;`\n\n`let result = temp / someComputation();`\n\nThat might result in dividing `undefined`, which is why in [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), the following is an error.\n\nts\n\n`function barPercentage(foo?: { bar: number }) {`\n\n  `return foo?.bar / 100;`\n\n  `//     ~~~~~~~~`\n\n  `// Error: Object is possibly undefined.`\n\n`}`\n\nMore more details, you can [read up on the proposal](https://github.com/tc39/proposal-optional-chaining/) and [view the original pull request](https://github.com/microsoft/TypeScript/pull/33294).\n\n## [](#nullish-coalescing)Nullish Coalescing\n\n[Playground](https://www.typescriptlang.org/play/#example/nullish-coalescing)\n\nThe _nullish coalescing operator_ is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.\n\nYou can think of this feature - the `??` operator - as a way to “fall back” to a default value when dealing with `null` or `undefined`. When we write code like\n\nts\n\n`let x = foo ?? bar();`\n\nthis is a new way to say that the value `foo` will be used when it’s “present”; but when it’s `null` or `undefined`, calculate `bar()` in its place.\n\nAgain, the above code is equivalent to the following.\n\nts\n\n`let x = foo !== null && foo !== undefined ? foo : bar();`\n\nThe `??` operator can replace uses of `||` when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in [`localStorage`](https://developer.mozilla.org/docs/Web/API/Window/localStorage) (if it ever was); however, it has a bug because it uses `||`.\n\nts\n\n`function initializeAudio() {`\n\n  `let volume = localStorage.volume || 0.5;`\n\n  `// ...`\n\n`}`\n\nWhen `localStorage.volume` is set to `0`, the page will set the volume to `0.5` which is unintended. `??` avoids some unintended behavior from `0`, `NaN` and `\"\"` being treated as falsy values.\n\nWe owe a large thanks to community members [Wenlu Wang](https://github.com/Kingwl) and [Titian Cernicova Dragomir](https://github.com/dragomirtitian) for implementing this feature! For more details, [check out their pull request](https://github.com/microsoft/TypeScript/pull/32883) and [the nullish coalescing proposal repository](https://github.com/tc39/proposal-nullish-coalescing/).\n\n## [](#assertion-functions)Assertion Functions\n\n[Playground](https://www.typescriptlang.org/play/#example/assertion-functions)\n\nThere’s a specific set of functions that `throw` an error if something unexpected happened. They’re called “assertion” functions. As an example, Node.js has a dedicated function for this called `assert`.\n\njs\n\n`assert(someValue === 42);`\n\nIn this example if `someValue` isn’t equal to `42`, then `assert` will throw an `AssertionError`.\n\nAssertions in JavaScript are often used to guard against improper types being passed in. For example,\n\njs\n\n`function multiply(x, y) {`\n\n  `assert(typeof x === \"number\");`\n\n  `assert(typeof y === \"number\");`\n\n  `return x * y;`\n\n`}`\n\nUnfortunately in TypeScript these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.\n\nts\n\n`function yell(str) {`\n\n  `assert(typeof str === \"string\");`\n\n  `return str.toUppercase();`\n\n  `// Oops! We misspelled 'toUpperCase'.`\n\n  `// Would be great if TypeScript still caught this!`\n\n`}`\n\nThe alternative was to instead rewrite the code so that the language could analyze it, but this isn’t convenient.\n\nts\n\n`function yell(str) {`\n\n  `if (typeof str !== \"string\") {`\n\n    `throw new TypeError(\"str should have been a string.\");`\n\n  `}`\n\n  `// Error caught!`\n\n  `return str.toUppercase();`\n\n`}`\n\nUltimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way. For that reason, TypeScript 3.7 introduces a new concept called “assertion signatures” which model these assertion functions.\n\nThe first type of assertion signature models the way that Node’s `assert` function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.\n\nts\n\n`function assert(condition: any, msg?: string): asserts condition {`\n\n  `if (!condition) {`\n\n    `throw new AssertionError(msg);`\n\n  `}`\n\n`}`\n\n`asserts condition` says that whatever gets passed into the `condition` parameter must be true if the `assert` returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we _do_ catch our original `yell` example.\n\nts\n\n`function yell(str) {`\n\n  `assert(typeof str === \"string\");`\n\n  `return str.toUppercase();`\n\n  `//         ~~~~~~~~~~~`\n\n  `// error: Property 'toUppercase' does not exist on type 'string'.`\n\n  `//        Did you mean 'toUpperCase'?`\n\n`}`\n\n`function assert(condition: any, msg?: string): asserts condition {`\n\n  `if (!condition) {`\n\n    `throw new AssertionError(msg);`\n\n  `}`\n\n`}`\n\nThe other type of assertion signature doesn’t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.\n\nts\n\n`function assertIsString(val: any): asserts val is string {`\n\n  `if (typeof val !== \"string\") {`\n\n    `throw new AssertionError(\"Not a string!\");`\n\n  `}`\n\n`}`\n\nHere `asserts val is string` ensures that after any call to `assertIsString`, any variable passed in will be known to be a `string`.\n\nts\n\n`function yell(str: any) {`\n\n  `assertIsString(str);`\n\n  `// Now TypeScript knows that 'str' is a 'string'.`\n\n  `return str.toUppercase();`\n\n  `//         ~~~~~~~~~~~`\n\n  `// error: Property 'toUppercase' does not exist on type 'string'.`\n\n  `//        Did you mean 'toUpperCase'?`\n\n`}`\n\nThese assertion signatures are very similar to writing type predicate signatures:\n\nts\n\n`function isString(val: any): val is string {`\n\n  `return typeof val === \"string\";`\n\n`}`\n\n`function yell(str: any) {`\n\n  `if (isString(str)) {`\n\n    `return str.toUppercase();`\n\n  `}`\n\n  `throw \"Oops!\";`\n\n`}`\n\nAnd just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.\n\nts\n\n`function assertIsDefined<T>(val: T): asserts val is NonNullable<T> {`\n\n  `if (val === undefined || val === null) {`\n\n    `throw new AssertionError(`\n\n      `` `Expected 'val' to be defined, but received ${val}` ``\n\n    `);`\n\n  `}`\n\n`}`\n\nTo read up more about assertion signatures, [check out the original pull request](https://github.com/microsoft/TypeScript/pull/32695).\n\n## [](#better-support-for-never-returning-functions)Better Support for `never`\\-Returning Functions\n\nAs part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return `never`.\n\nThe intent of any function that returns `never` is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, [`process.exit(...)` in `@types/node`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874) is specified to return `never`.\n\nIn order to ensure that a function never potentially returned `undefined` or effectively returned from all code paths, TypeScript needed some syntactic signal - either a `return` or `throw` at the end of a function. So users found themselves `return`\\-ing their failure functions.\n\nts\n\n`function dispatch(x: string | number): SomeType {`\n\n  `if (typeof x === \"string\") {`\n\n    `return doThingWithString(x);`\n\n  `} else if (typeof x === \"number\") {`\n\n    `return doThingWithNumber(x);`\n\n  `}`\n\n  `return process.exit(1);`\n\n`}`\n\nNow when these `never`\\-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.\n\nts\n\n`function dispatch(x: string | number): SomeType {`\n\n  `if (typeof x === \"string\") {`\n\n    `return doThingWithString(x);`\n\n  `} else if (typeof x === \"number\") {`\n\n    `return doThingWithNumber(x);`\n\n  `}`\n\n  `process.exit(1);`\n\n`}`\n\nAs with assertion functions, you can [read up more at the same pull request](https://github.com/microsoft/TypeScript/pull/32695).\n\n## [](#more-recursive-type-aliases)(More) Recursive Type Aliases\n\n[Playground](https://www.typescriptlang.org/play/#example/recursive-type-references)\n\nType aliases have always had a limitation in how they could be “recursively” referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that’s not possible, so the compiler rejects certain recursive aliases like the following:\n\nts\n\n`type Foo = Foo;`\n\nThis is a reasonable restriction because any use of `Foo` would need to be replaced with `Foo` which would need to be replaced with `Foo` which would need to be replaced with `Foo` which… well, hopefully you get the idea! In the end, there isn’t a type that makes sense in place of `Foo`.\n\nThis is fairly [consistent with how other languages treat type aliases](https://wikipedia.org/w/index.php?title=Recursive_data_type&oldid=913091335#in_type_synonyms), but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.\n\nts\n\n`type ValueOrArray<T> = T | Array<ValueOrArray<T>>;`\n\n`//   ~~~~~~~~~~~~`\n\n`// error: Type alias 'ValueOrArray' circularly references itself.`\n\nThis is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.\n\nts\n\n`type ValueOrArray<T> = T | ArrayOfValueOrArray<T>;`\n\n`interface ArrayOfValueOrArray<T> extends Array<ValueOrArray<T>> {}`\n\nBecause interfaces (and other object types) introduce a level of indirection and their full structure doesn’t need to be eagerly built out, TypeScript has no problem working with this structure.\n\nBut workaround of introducing the interface wasn’t intuitive for users. And in principle there really wasn’t anything wrong with the original version of `ValueOrArray` that used `Array` directly. If the compiler was a little bit “lazier” and only calculated the type arguments to `Array` when necessary, then TypeScript could express these correctly.\n\nThat’s exactly what TypeScript 3.7 introduces. At the “top level” of a type alias, TypeScript will defer resolving type arguments to permit these patterns.\n\nThis means that code like the following that was trying to represent JSON…\n\nts\n\n`type Json = string | number | boolean | null | JsonObject | JsonArray;`\n\n`interface JsonObject {`\n\n  `[property: string]: Json;`\n\n`}`\n\n`interface JsonArray extends Array<Json> {}`\n\ncan finally be rewritten without helper interfaces.\n\nts\n\n`type Json =`\n\n  `| string`\n\n  `| number`\n\n  `| boolean`\n\n  `| null`\n\n  `| { [property: string]: Json }`\n\n  `| Json[];`\n\nThis new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.\n\nts\n\n`type VirtualNode = string | [string, { [key: string]: any }, ...VirtualNode[]];`\n\n`const myNode: VirtualNode = [`\n\n  `\"div\",`\n\n  `{ id: \"parent\" },`\n\n  `[\"div\", { id: \"first-child\" }, \"I'm the first child\"],`\n\n  `[\"div\", { id: \"second-child\" }, \"I'm the second child\"],`\n\n`];`\n\nFor more information, you can [read up on the original pull request](https://github.com/microsoft/TypeScript/pull/33050).\n\n## [](#--declaration-and---allowjs)`--declaration` and `--allowJs`\n\nThe [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) flag in TypeScript allows us to generate `.d.ts` files (declaration files) from TypeScript source files (i.e. `.ts` and `.tsx` files). These `.d.ts` files are important for a couple of reasons.\n\nFirst of all, they’re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They’re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren’t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript _and_ JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.\n\nUnfortunately, [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) didn’t work with the [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs) flag which allows mixing TypeScript and JavaScript input files. This was a frustrating limitation because it meant users couldn’t use the [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) flag when migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes that, and allows the two options to be used together!\n\nThe most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.\n\nThe way that this works is that when using [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs), TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don’t necessarily look like their equivalents in TypeScript. When [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output `.d.ts` files.\n\nAs an example, the following code snippet\n\njs\n\n`const assert = require(\"assert\");`\n\n`module.exports.blurImage = blurImage;`\n\n`/**`\n\n `* Produces a blurred image from an input buffer.`\n\n `*`\n\n `* @param input {Uint8Array}`\n\n `* @param width {number}`\n\n `* @param height {number}`\n\n `*/`\n\n`function blurImage(input, width, height) {`\n\n  `const numPixels = width * height * 4;`\n\n  `assert(input.length === numPixels);`\n\n  `const result = new Uint8Array(numPixels);`\n\n  `// TODO`\n\n  `return result;`\n\n`}`\n\nWill produce a `.d.ts` file like\n\nts\n\n`/**`\n\n `* Produces a blurred image from an input buffer.`\n\n `*`\n\n `* @param input {Uint8Array}`\n\n `* @param width {number}`\n\n `* @param height {number}`\n\n `*/`\n\n`export function blurImage(`\n\n  `input: Uint8Array,`\n\n  `width: number,`\n\n  `height: number`\n\n`): Uint8Array;`\n\nThis can go beyond basic functions with `@param` tags too, where the following example:\n\njs\n\n`/**`\n\n `* @callback Job`\n\n `* @returns {void}`\n\n `*/`\n\n`/** Queues work */`\n\n`export class Worker {`\n\n  `constructor(maxDepth = 10) {`\n\n    `this.started = false;`\n\n    `this.depthLimit = maxDepth;`\n\n    `/**`\n\n     `* NOTE: queued jobs may add more items to queue`\n\n     `* @type {Job[]}`\n\n     `*/`\n\n    `this.queue = [];`\n\n  `}`\n\n  `/**`\n\n   `* Adds a work item to the queue`\n\n   `* @param {Job} work`\n\n   `*/`\n\n  `push(work) {`\n\n    `if (this.queue.length + 1 > this.depthLimit) throw new Error(\"Queue full!\");`\n\n    `this.queue.push(work);`\n\n  `}`\n\n  `/**`\n\n   `* Starts the queue if it has not yet started`\n\n   `*/`\n\n  `start() {`\n\n    `if (this.started) return false;`\n\n    `this.started = true;`\n\n    `while (this.queue.length) {`\n\n      `/** @type {Job} */ (this.queue.shift())();`\n\n    `}`\n\n    `return true;`\n\n  `}`\n\n`}`\n\nwill be transformed into the following `.d.ts` file:\n\nts\n\n`/**`\n\n `* @callback Job`\n\n `* @returns {void}`\n\n `*/`\n\n`/** Queues work */`\n\n`export class Worker {`\n\n  `constructor(maxDepth?: number);`\n\n  `started: boolean;`\n\n  `depthLimit: number;`\n\n  `/**`\n\n   `* NOTE: queued jobs may add more items to queue`\n\n   `* @type {Job[]}`\n\n   `*/`\n\n  `queue: Job[];`\n\n  `/**`\n\n   `* Adds a work item to the queue`\n\n   `* @param {Job} work`\n\n   `*/`\n\n  `push(work: Job): void;`\n\n  `/**`\n\n   `* Starts the queue if it has not yet started`\n\n   `*/`\n\n  `start(): boolean;`\n\n`}`\n\n`export type Job = () => void;`\n\nNote that when using these flags together, TypeScript doesn’t necessarily have to downlevel `.js` files. If you simply want TypeScript to create `.d.ts` files, you can use the [`emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly) compiler option.\n\nFor more details, you can [check out the original pull request](https://github.com/microsoft/TypeScript/pull/32372).\n\n## [](#the-usedefineforclassfields-flag-and-the-declare-property-modifier)The `useDefineForClassFields` Flag and The `declare` Property Modifier\n\nBack when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code\n\nts\n\n`class C {`\n\n  `foo = 100;`\n\n  `bar: string;`\n\n`}`\n\nwould be equivalent to a similar assignment within a constructor body.\n\nts\n\n`class C {`\n\n  `constructor() {`\n\n    `this.foo = 100;`\n\n  `}`\n\n`}`\n\nUnfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently. Instead, the original code sample might need to de-sugar to something closer to the following:\n\nts\n\n`class C {`\n\n  `constructor() {`\n\n    `Object.defineProperty(this, \"foo\", {`\n\n      `enumerable: true,`\n\n      `configurable: true,`\n\n      `writable: true,`\n\n      `value: 100,`\n\n    `});`\n\n    `Object.defineProperty(this, \"bar\", {`\n\n      `enumerable: true,`\n\n      `configurable: true,`\n\n      `writable: true,`\n\n      `value: void 0,`\n\n    `});`\n\n  `}`\n\n`}`\n\nWhile TypeScript 3.7 isn’t changing any existing emit by default, we’ve been rolling out changes incrementally to help users mitigate potential future breakage. We’ve provided a new flag called [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) to enable this emit mode with some new checking logic.\n\nThe two biggest changes are the following:\n\n*   Declarations are initialized with `Object.defineProperty`.\n*   Declarations are _always_ initialized to `undefined`, even if they have no initializer.\n\nThis can cause quite a bit of fallout for existing code that use inheritance. First of all, `set` accessors from base classes won’t get triggered - they’ll be completely overwritten.\n\nts\n\n`class Base {`\n\n  `set data(value: string) {`\n\n    `console.log(\"data changed to \" + value);`\n\n  `}`\n\n`}`\n\n`class Derived extends Base {`\n\n  `// No longer triggers a 'console.log'`\n\n  `// when using 'useDefineForClassFields'.`\n\n  `data = 10;`\n\n`}`\n\nSecondly, using class fields to specialize properties from base classes also won’t work.\n\nts\n\n`interface Animal {`\n\n  `animalStuff: any;`\n\n`}`\n\n`interface Dog extends Animal {`\n\n  `dogStuff: any;`\n\n`}`\n\n`class AnimalHouse {`\n\n  `resident: Animal;`\n\n  `constructor(animal: Animal) {`\n\n    `this.resident = animal;`\n\n  `}`\n\n`}`\n\n`class DogHouse extends AnimalHouse {`\n\n  `// Initializes 'resident' to 'undefined'`\n\n  `// after the call to 'super()' when`\n\n  `// using 'useDefineForClassFields'!`\n\n  `resident: Dog;`\n\n  `constructor(dog: Dog) {`\n\n    `super(dog);`\n\n  `}`\n\n`}`\n\nWhat these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.\n\nTo detect the issue around accessors, TypeScript 3.7 will now emit `get`/`set` accessors in `.d.ts` files so that in TypeScript can check for overridden accessors.\n\nCode that’s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.\n\nts\n\n`class Base {`\n\n  `set data(value: string) {`\n\n    `console.log(\"data changed to \" + value);`\n\n  `}`\n\n`}`\n\n`class Derived extends Base {`\n\n  `constructor() {`\n\n    `this.data = 10;`\n\n  `}`\n\n`}`\n\nTo help mitigate the second issue, you can either add an explicit initializer or add a `declare` modifier to indicate that a property should have no emit.\n\nts\n\n`interface Animal {`\n\n  `animalStuff: any;`\n\n`}`\n\n`interface Dog extends Animal {`\n\n  `dogStuff: any;`\n\n`}`\n\n`class AnimalHouse {`\n\n  `resident: Animal;`\n\n  `constructor(animal: Animal) {`\n\n    `this.resident = animal;`\n\n  `}`\n\n`}`\n\n`class DogHouse extends AnimalHouse {`\n\n  `declare resident: Dog;`\n\n  `//  ^^^^^^^`\n\n  `// 'resident' now has a 'declare' modifier,`\n\n  `// and won't produce any output code.`\n\n  `constructor(dog: Dog) {`\n\n    `super(dog);`\n\n  `}`\n\n`}`\n\nCurrently [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) is only available when targeting ES5 and upwards, since `Object.defineProperty` doesn’t exist in ES3. To achieve similar checking for issues, you can create a separate project that targets ES5 and uses [`noEmit`](https://www.typescriptlang.org/tsconfig#noEmit) to avoid a full build.\n\nFor more information, you can [take a look at the original pull request for these changes](https://github.com/microsoft/TypeScript/pull/33509).\n\nWe strongly encourage users to try the [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) flag and report back on our issue tracker or in the comments below. This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.\n\n## [](#build-free-editing-with-project-references)Build-Free Editing with Project References\n\nTypeScript’s project references provide us with an easy way to break codebases up to give us faster compiles. Unfortunately, editing a project whose dependencies hadn’t been built (or whose output was out of date) meant that the editing experience wouldn’t work well.\n\nIn TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source `.ts`/`.tsx` files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and “just work”. You can disable this behavior with the compiler option [`disableSourceOfProjectReferenceRedirect`](https://www.typescriptlang.org/tsconfig#disableSourceOfProjectReferenceRedirect) which may be appropriate when working in very large projects where this change may impact editing performance.\n\nYou can [read up more about this change by reading up on its pull request](https://github.com/microsoft/TypeScript/pull/32028).\n\n## [](#uncalled-function-checks)Uncalled Function Checks\n\nA common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.\n\nts\n\n`interface User {`\n\n  `isAdministrator(): boolean;`\n\n  `notify(): void;`\n\n  `doNotDisturb?(): boolean;`\n\n`}`\n\n`// later...`\n\n`// Broken code, do not use!`\n\n`function doAdminThing(user: User) {`\n\n  `// oops!`\n\n  `if (user.isAdministrator) {`\n\n    `sudo();`\n\n    `editTheConfiguration();`\n\n  `} else {`\n\n    `throw new AccessDeniedError(\"User is not an admin\");`\n\n  `}`\n\n`}`\n\nHere, we forgot to call `isAdministrator`, and the code incorrectly allows non-administrator users to edit the configuration!\n\nIn TypeScript 3.7, this is identified as a likely error:\n\nts\n\n`function doAdminThing(user: User) {`\n\n    `if (user.isAdministrator) {`\n\n    `//  ~~~~~~~~~~~~~~~~~~~~`\n\n    `// error! This condition will always return true since the function is always defined.`\n\n    `//        Did you mean to call it instead?`\n\nThis check is a breaking change, but for that reason the checks are very conservative. This error is only issued in `if` conditions, and it is not issued on optional properties, if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off, or if the function is later called within the body of the `if`:\n\nts\n\n`interface User {`\n\n  `isAdministrator(): boolean;`\n\n  `notify(): void;`\n\n  `doNotDisturb?(): boolean;`\n\n`}`\n\n`function issueNotification(user: User) {`\n\n  `if (user.doNotDisturb) {`\n\n    `// OK, property is optional`\n\n  `}`\n\n  `if (user.notify) {`\n\n    `// OK, called the function`\n\n    `user.notify();`\n\n  `}`\n\n`}`\n\nIf you intended to test the function without calling it, you can correct the definition of it to include `undefined`/`null`, or use `!!` to write something like `if (!!user.isAdministrator)` to indicate that the coercion is intentional.\n\nWe owe a big thanks to GitHub user [@jwbay](https://github.com/jwbay) who took the initiative to create a [proof-of-concept](https://github.com/microsoft/TypeScript/pull/32802) and iterated to provide us with [the current version](https://github.com/microsoft/TypeScript/pull/33178).\n\n## [](#-ts-nocheck-in-typescript-files)`// @ts-nocheck` in TypeScript Files\n\nTypeScript 3.7 allows us to add `// @ts-nocheck` comments to the top of TypeScript files to disable semantic checks. Historically this comment was only respected in JavaScript source files in the presence of [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs), but we’ve expanded support to TypeScript files to make migrations easier for all users.\n\n## [](#semicolon-formatter-option)Semicolon Formatter Option\n\nTypeScript’s built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript’s automatic semicolon insertion (ASI) rules. The setting is available now in [Visual Studio Code Insiders](https://code.visualstudio.com/insiders/), and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.\n\n![New semicolon formatter option in VS Code](https://user-images.githubusercontent.com/3277153/65913194-10066e80-e395-11e9-8a3a-4f7305c397d5.png)\n\nChoosing a value of “insert” or “remove” also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of “ignore” makes generated code match the semicolon preference detected in the current file.\n\n## [](#37-breaking-changes)3.7 Breaking Changes\n\n### [](#dom-changes)DOM Changes\n\n[Types in `lib.dom.d.ts` have been updated](https://github.com/microsoft/TypeScript/pull/33627). These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.\n\n### [](#class-field-mitigations)Class Field Mitigations\n\n[As mentioned above](#the-usedefineforclassfields-flag-and-the-declare-property-modifier), TypeScript 3.7 emits `get`/`set` accessors in `.d.ts` files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.\n\nWhile not a breakage per se, opting in to the [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) flag can cause breakage when:\n\n*   overriding an accessor in a derived class with a property declaration\n*   re-declaring a property declaration with no initializer\n\nTo understand the full impact, read [the section above on the `useDefineForClassFields` flag](#the-usedefineforclassfields-flag-and-the-declare-property-modifier).\n\n### [](#function-truthy-checks)Function Truthy Checks\n\nAs mentioned above, TypeScript now errors when functions appear to be uncalled within `if` statement conditions. An error is issued when a function type is checked in `if` conditions unless any of the following apply:\n\n*   the checked value comes from an optional property\n*   [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is disabled\n*   the function is later called within the body of the `if`\n\n### [](#local-and-imported-type-declarations-now-conflict)Local and Imported Type Declarations Now Conflict\n\nDue to a bug, the following construct was previously allowed in TypeScript:\n\nts\n\n`// ./someOtherModule.ts`\n\n`interface SomeType {`\n\n  `y: string;`\n\n`}`\n\n`// ./myModule.ts`\n\n`import { SomeType } from \"./someOtherModule\";`\n\n`export interface SomeType {`\n\n  `x: number;`\n\n`}`\n\n`function fn(arg: SomeType) {`\n\n  `console.log(arg.x); // Error! 'x' doesn't exist on 'SomeType'`\n\n`}`\n\nHere, `SomeType` appears to originate in both the `import` declaration and the local `interface` declaration. Perhaps surprisingly, inside the module, `SomeType` refers exclusively to the `import`ed definition, and the local declaration `SomeType` is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.\n\nIn TypeScript 3.7, [this is now correctly identified as a duplicate identifier error](https://github.com/microsoft/TypeScript/pull/31231). The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.\n\n### [](#37-api-changes)3.7 API Changes\n\nTo enable the recursive type alias patterns described above, the `typeArguments` property has been removed from the `TypeReference` interface. Users should instead use the `getTypeArguments` function on `TypeChecker` instances.",
    "title": "TypeScript: Documentation - TypeScript 3.7",
    "description": "TypeScript 3.7 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html",
    "markdown": "# TypeScript: Documentation - TypeScript 5.0\n\n## [](#decorators)Decorators\n\nDecorators are an upcoming ECMAScript feature that allow us to customize classes and their members in a reusable way.\n\nLet’s consider the following code:\n\nts\n\n`class Person {`\n\n    `name: string;`\n\n    `constructor(name: string) {`\n\n        `this.name = name;`\n\n    `}`\n\n    `greet() {`\n\n        ``console.log(`Hello, my name is ${this.name}.`);``\n\n    `}`\n\n`}`\n\n`const p = new Person(\"Ray\");`\n\n`p.greet();`\n\n`greet` is pretty simple here, but let’s imagine it’s something way more complicated - maybe it does some async logic, it’s recursive, it has side effects, etc. Regardless of what kind of ball-of-mud you’re imagining, let’s say you throw in some `console.log` calls to help debug `greet`.\n\nts\n\n`class Person {`\n\n    `name: string;`\n\n    `constructor(name: string) {`\n\n        `this.name = name;`\n\n    `}`\n\n    `greet() {`\n\n        `console.log(\"LOG: Entering method.\");`\n\n        ``console.log(`Hello, my name is ${this.name}.`);``\n\n        `console.log(\"LOG: Exiting method.\")`\n\n    `}`\n\n`}`\n\nThis pattern is fairly common. It sure would be nice if there was a way we could do this for every method!\n\nThis is where decorators come in. We can write a function called `loggedMethod` that looks like the following:\n\nts\n\n`function loggedMethod(originalMethod: any, _context: any) {`\n\n    `function replacementMethod(this: any, ...args: any[]) {`\n\n        `console.log(\"LOG: Entering method.\")`\n\n        `const result = originalMethod.call(this, ...args);`\n\n        `console.log(\"LOG: Exiting method.\")`\n\n        `return result;`\n\n    `}`\n\n    `return replacementMethod;`\n\n`}`\n\n“What’s the deal with all of these `any`s? What is this, `any`Script!?”\n\nJust be patient - we’re keeping things simple for now so that we can focus on what this function is doing. Notice that `loggedMethod` takes the original method (`originalMethod`) and returns a function that\n\n1.  logs an “Entering…” message\n2.  passes along `this` and all of its arguments to the original method\n3.  logs an “Exiting…” message, and\n4.  returns whatever the original method returned.\n\nNow we can use `loggedMethod` to _decorate_ the method `greet`:\n\nts\n\n`class Person {`\n\n    `name: string;`\n\n    `constructor(name: string) {`\n\n        `this.name = name;`\n\n    `}`\n\n    `@loggedMethod`\n\n    `greet() {`\n\n        ``console.log(`Hello, my name is ${this.name}.`);``\n\n    `}`\n\n`}`\n\n`const p = new Person(\"Ray\");`\n\n`p.greet();`\n\n`// Output:`\n\n`//`\n\n`//   LOG: Entering method.`\n\n`//   Hello, my name is Ray.`\n\n`//   LOG: Exiting method.`\n\nWe just used `loggedMethod` as a decorator above `greet` - and notice that we wrote it as `@loggedMethod`. When we did that, it got called with the method _target_ and a _context object_. Because `loggedMethod` returned a new function, that function replaced the original definition of `greet`.\n\nWe didn’t mention it yet, but `loggedMethod` was defined with a second parameter. It’s called a “context object”, and it has some useful information about how the decorated method was declared - like whether it was a `#private` member, or `static`, or what the name of the method was. Let’s rewrite `loggedMethod` to take advantage of that and print out the name of the method that was decorated.\n\nts\n\n`function loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) {`\n\n    `const methodName = String(context.name);`\n\n    `function replacementMethod(this: any, ...args: any[]) {`\n\n        ``console.log(`LOG: Entering method '${methodName}'.`)``\n\n        `const result = originalMethod.call(this, ...args);`\n\n        ``console.log(`LOG: Exiting method '${methodName}'.`)``\n\n        `return result;`\n\n    `}`\n\n    `return replacementMethod;`\n\n`}`\n\nWe’re now using the context parameter - and that it’s the first thing in `loggedMethod` that has a type stricter than `any` and `any[]`. TypeScript provides a type called `ClassMethodDecoratorContext` that models the context object that method decorators take.\n\nApart from metadata, the context object for methods also has a useful function called `addInitializer`. It’s a way to hook into the beginning of the constructor (or the initialization of the class itself if we’re working with `static`s).\n\nAs an example - in JavaScript, it’s common to write something like the following pattern:\n\nts\n\n`class Person {`\n\n    `name: string;`\n\n    `constructor(name: string) {`\n\n        `this.name = name;`\n\n        `this.greet = this.greet.bind(this);`\n\n    `}`\n\n    `greet() {`\n\n        ``console.log(`Hello, my name is ${this.name}.`);``\n\n    `}`\n\n`}`\n\nAlternatively, `greet` might be declared as a property initialized to an arrow function.\n\nts\n\n`class Person {`\n\n    `name: string;`\n\n    `constructor(name: string) {`\n\n        `this.name = name;`\n\n    `}`\n\n    `greet = () => {`\n\n        ``console.log(`Hello, my name is ${this.name}.`);``\n\n    `};`\n\n`}`\n\nThis code is written to ensure that `this` isn’t re-bound if `greet` is called as a stand-alone function or passed as a callback.\n\nts\n\n`const greet = new Person(\"Ray\").greet;`\n\n`// We don't want this to fail!`\n\n`greet();`\n\nWe can write a decorator that uses `addInitializer` to call `bind` in the constructor for us.\n\nts\n\n`function bound(originalMethod: any, context: ClassMethodDecoratorContext) {`\n\n    `const methodName = context.name;`\n\n    `if (context.private) {`\n\n        ``throw new Error(`'bound' cannot decorate private properties like ${methodName as string}.`);``\n\n    `}`\n\n    `context.addInitializer(function () {`\n\n        `this[methodName] = this[methodName].bind(this);`\n\n    `});`\n\n`}`\n\n`bound` isn’t returning anything - so when it decorates a method, it leaves the original alone. Instead, it will add logic before any other fields are initialized.\n\nts\n\n`class Person {`\n\n    `name: string;`\n\n    `constructor(name: string) {`\n\n        `this.name = name;`\n\n    `}`\n\n    `@bound`\n\n    `@loggedMethod`\n\n    `greet() {`\n\n        ``console.log(`Hello, my name is ${this.name}.`);``\n\n    `}`\n\n`}`\n\n`const p = new Person(\"Ray\");`\n\n`const greet = p.greet;`\n\n`// Works!`\n\n`greet();`\n\nNotice that we stacked two decorators - `@bound` and `@loggedMethod`. These decorations run in “reverse order”. That is, `@loggedMethod` decorates the original method `greet`, and `@bound` decorates the result of `@loggedMethod`. In this example, it doesn’t matter - but it could if your decorators have side-effects or expect a certain order.\n\nAlso worth noting - if you’d prefer stylistically, you can put these decorators on the same line.\n\nts\n\n    `@bound @loggedMethod greet() {`\n\n        ``console.log(`Hello, my name is ${this.name}.`);``\n\n    `}`\n\nSomething that might not be obvious is that we can even make functions that _return_ decorator functions. That makes it possible to customize the final decorator just a little. If we wanted, we could have made `loggedMethod` return a decorator and customize how it logs its messages.\n\nts\n\n`function loggedMethod(headMessage = \"LOG:\") {`\n\n    `return function actualDecorator(originalMethod: any, context: ClassMethodDecoratorContext) {`\n\n        `const methodName = String(context.name);`\n\n        `function replacementMethod(this: any, ...args: any[]) {`\n\n            ``console.log(`${headMessage} Entering method '${methodName}'.`)``\n\n            `const result = originalMethod.call(this, ...args);`\n\n            ``console.log(`${headMessage} Exiting method '${methodName}'.`)``\n\n            `return result;`\n\n        `}`\n\n        `return replacementMethod;`\n\n    `}`\n\n`}`\n\nIf we did that, we’d have to call `loggedMethod` before using it as a decorator. We could then pass in any string as the prefix for messages that get logged to the console.\n\nts\n\n`class Person {`\n\n    `name: string;`\n\n    `constructor(name: string) {`\n\n        `this.name = name;`\n\n    `}`\n\n    `@loggedMethod(\"⚠️\")`\n\n    `greet() {`\n\n        ``console.log(`Hello, my name is ${this.name}.`);``\n\n    `}`\n\n`}`\n\n`const p = new Person(\"Ray\");`\n\n`p.greet();`\n\n`// Output:`\n\n`//`\n\n`//   ⚠️ Entering method 'greet'.`\n\n`//   Hello, my name is Ray.`\n\n`//   ⚠️ Exiting method 'greet'.`\n\nDecorators can be used on more than just methods! They can be used on properties/fields, getters, setters, and auto-accessors. Even classes themselves can be decorated for things like subclassing and registration.\n\nTo learn more about decorators in-depth, you can read up on [Axel Rauschmayer’s extensive summary](https://2ality.com/2022/10/javascript-decorators.html).\n\nFor more information about the changes involved, you can [view the original pull request](https://github.com/microsoft/TypeScript/pull/50820).\n\n### [](#differences-with-experimental-legacy-decorators)Differences with Experimental Legacy Decorators\n\nIf you’ve been using TypeScript for a while, you might be aware of the fact that it’s had support for “experimental” decorators for years. While these experimental decorators have been incredibly useful, they modeled a much older version of the decorators proposal, and always required an opt-in compiler flag called `--experimentalDecorators`. Any attempt to use decorators in TypeScript without this flag used to prompt an error message.\n\n`--experimentalDecorators` will continue to exist for the foreseeable future; however, without the flag, decorators will now be valid syntax for all new code. Outside of `--experimentalDecorators`, they will be type-checked and emitted differently. The type-checking rules and emit are sufficiently different that while decorators _can_ be written to support both the old and new decorators behavior, any existing decorator functions are not likely to do so.\n\nThis new decorators proposal is not compatible with `--emitDecoratorMetadata`, and it does not allow decorating parameters. Future ECMAScript proposals may be able to help bridge that gap.\n\nOn a final note: in addition to allowing decorators to be placed before the `export` keyword, the proposal for decorators now provides the option of placing decorators after `export` or `export default`. The only exception is that mixing the two styles is not allowed.\n\njs\n\n`// ✅ allowed`\n\n`@register export default class Foo {`\n\n    `// ...`\n\n`}`\n\n`// ✅ also allowed`\n\n`export default @register class Bar {`\n\n    `// ...`\n\n`}`\n\n`// ❌ error - before *and* after is not allowed`\n\n`@before export @after class Bar {`\n\n    `// ...`\n\n`}`\n\n### [](#writing-well-typed-decorators)Writing Well-Typed Decorators\n\nThe `loggedMethod` and `bound` decorator examples above are intentionally simple and omit lots of details about types.\n\nTyping decorators can be fairly complex. For example, a well-typed version of `loggedMethod` from above might look something like this:\n\nts\n\n`function loggedMethod<This, Args extends any[], Return>(`\n\n    `target: (this: This, ...args: Args) => Return,`\n\n    `context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>`\n\n`) {`\n\n    `const methodName = String(context.name);`\n\n    `function replacementMethod(this: This, ...args: Args): Return {`\n\n        ``console.log(`LOG: Entering method '${methodName}'.`)``\n\n        `const result = target.call(this, ...args);`\n\n        ``console.log(`LOG: Exiting method '${methodName}'.`)``\n\n        `return result;`\n\n    `}`\n\n    `return replacementMethod;`\n\n`}`\n\nWe had to separately model out the type of `this`, the parameters, and the return type of the original method, using the type parameters `This`, `Args`, and `Return`.\n\nExactly how complex your decorators functions are defined depends on what you want to guarantee. Just keep in mind, your decorators will be used more than they’re written, so a well-typed version will usually be preferable - but there’s clearly a trade-off with readability, so try to keep things simple.\n\nMore documentation on writing decorators will be available in the future - but [this post](https://2ality.com/2022/10/javascript-decorators.html) should have a good amount of detail for the mechanics of decorators.\n\n## [](#const-type-parameters)`const` Type Parameters\n\nWhen inferring the type of an object, TypeScript will usually choose a type that’s meant to be general. For example, in this case, the inferred type of `names` is `string[]`:\n\nts\n\n`type HasNames = { names: readonly string[] };`\n\n`function getNamesExactly<T extends HasNames>(arg: T): T[\"names\"] {`\n\n    `return arg.names;`\n\n`}`\n\n`// Inferred type: string[]`\n\n`const names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]});`\n\nUsually the intent of this is to enable mutation down the line.\n\nHowever, depending on what exactly `getNamesExactly` does and how it’s intended to be used, it can often be the case that a more-specific type is desired.\n\nUp until now, API authors have typically had to recommend adding `as const` in certain places to achieve the desired inference:\n\nts\n\n`// The type we wanted:`\n\n`//    readonly [\"Alice\", \"Bob\", \"Eve\"]`\n\n`// The type we got:`\n\n`//    string[]`\n\n`const names1 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]});`\n\n`// Correctly gets what we wanted:`\n\n`//    readonly [\"Alice\", \"Bob\", \"Eve\"]`\n\n`const names2 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]} as const);`\n\nThis can be cumbersome and easy to forget. In TypeScript 5.0, you can now add a `const` modifier to a type parameter declaration to cause `const`\\-like inference to be the default:\n\nts\n\n`type HasNames = { names: readonly string[] };`\n\n`function getNamesExactly<const T extends HasNames>(arg: T): T[\"names\"] {`\n\n`//                       ^^^^^`\n\n    `return arg.names;`\n\n`}`\n\n`// Inferred type: readonly [\"Alice\", \"Bob\", \"Eve\"]`\n\n`// Note: Didn't need to write 'as const' here`\n\n`const names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"] });`\n\nNote that the `const` modifier doesn’t _reject_ mutable values, and doesn’t require immutable constraints. Using a mutable type constraint might give surprising results. For example:\n\nts\n\n`declare function fnBad<const T extends string[]>(args: T): void;`\n\n`// 'T' is still 'string[]' since 'readonly [\"a\", \"b\", \"c\"]' is not assignable to 'string[]'`\n\n`fnBad([\"a\", \"b\" ,\"c\"]);`\n\nHere, the inferred candidate for `T` is `readonly [\"a\", \"b\", \"c\"]`, and a `readonly` array can’t be used where a mutable one is needed. In this case, inference falls back to the constraint, the array is treated as `string[]`, and the call still proceeds successfully.\n\nA better definition of this function should use `readonly string[]`:\n\nts\n\n`declare function fnGood<const T extends readonly string[]>(args: T): void;`\n\n`// T is readonly [\"a\", \"b\", \"c\"]`\n\n`fnGood([\"a\", \"b\" ,\"c\"]);`\n\nSimilarly, remember to keep in mind that the `const` modifier only affects inference of object, array and primitive expressions that were written within the call, so arguments which wouldn’t (or couldn’t) be modified with `as const` won’t see any change in behavior:\n\nts\n\n`declare function fnGood<const T extends readonly string[]>(args: T): void;`\n\n`const arr = [\"a\", \"b\" ,\"c\"];`\n\n`// 'T' is still 'string[]'-- the 'const' modifier has no effect here`\n\n`fnGood(arr);`\n\n[See the pull request](https://github.com/microsoft/TypeScript/pull/51865) and the ([first](https://github.com/microsoft/TypeScript/issues/30680) and second [second](https://github.com/microsoft/TypeScript/issues/41114)) motivating issues for more details.\n\n## [](#supporting-multiple-configuration-files-in-extends)Supporting Multiple Configuration Files in `extends`\n\nWhen managing multiple projects, it can be helpful to have a “base” configuration file that other `tsconfig.json` files can extend from. That’s why TypeScript supports an `extends` field for copying over fields from `compilerOptions`.\n\njsonc\n\n`// packages/front-end/src/tsconfig.json`\n\n`{`\n\n    `\"extends\": \"../../../tsconfig.base.json\",`\n\n    `\"compilerOptions\": {`\n\n        `\"outDir\": \"../lib\",`\n\n        `// ...`\n\n    `}`\n\n`}`\n\nHowever, there are scenarios where you might want to extend from multiple configuration files. For example, imagine using [a TypeScript base configuration file shipped to npm](https://github.com/tsconfig/bases). If you want all your projects to also use the options from the `@tsconfig/strictest` package on npm, then there’s a simple solution: have `tsconfig.base.json` extend from `@tsconfig/strictest`:\n\njsonc\n\n`// tsconfig.base.json`\n\n`{`\n\n    `\"extends\": \"@tsconfig/strictest/tsconfig.json\",`\n\n    `\"compilerOptions\": {`\n\n        `// ...`\n\n    `}`\n\n`}`\n\nThis works to a point. If you have any projects that _don’t_ want to use `@tsconfig/strictest`, they have to either manually disable the options, or create a separate version of `tsconfig.base.json` that _doesn’t_ extend from `@tsconfig/strictest`.\n\nTo give some more flexibility here, Typescript 5.0 now allows the `extends` field to take multiple entries. For example, in this configuration file:\n\njsonc\n\n`{`\n\n    `\"extends\": [\"a\", \"b\", \"c\"],`\n\n    `\"compilerOptions\": {`\n\n        `// ...`\n\n    `}`\n\n`}`\n\nWriting this is kind of like extending `c` directly, where `c` extends `b`, and `b` extends `a`. If any fields “conflict”, the latter entry wins.\n\nSo in the following example, both `strictNullChecks` and `noImplicitAny` are enabled in the final `tsconfig.json`.\n\njsonc\n\n`// tsconfig1.json`\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"strictNullChecks\": true`\n\n    `}`\n\n`}`\n\n`// tsconfig2.json`\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"noImplicitAny\": true`\n\n    `}`\n\n`}`\n\n`// tsconfig.json`\n\n`{`\n\n    `\"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"],`\n\n    `\"files\": [\"./index.ts\"]`\n\n`}`\n\nAs another example, we can rewrite our original example in the following way.\n\njsonc\n\n`// packages/front-end/src/tsconfig.json`\n\n`{`\n\n    `\"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"../../../tsconfig.base.json\"],`\n\n    `\"compilerOptions\": {`\n\n        `\"outDir\": \"../lib\",`\n\n        `// ...`\n\n    `}`\n\n`}`\n\nFor more details, [read more on the original pull request](https://github.com/microsoft/TypeScript/pull/50403).\n\n## [](#all-enums-are-union-enums)All `enum`s Are Union `enum`s\n\nWhen TypeScript originally introduced enums, they were nothing more than a set of numeric constants with the same type.\n\nts\n\n`enum E {`\n\n    `Foo = 10,`\n\n    `Bar = 20,`\n\n`}`\n\nThe only thing special about `E.Foo` and `E.Bar` was that they were assignable to anything expecting the type `E`. Other than that, they were pretty much just `number`s.\n\nts\n\n`function takeValue(e: E) {}`\n\n`takeValue(E.Foo); // works`\n\n`takeValue(123); // error!`\n\nIt wasn’t until TypeScript 2.0 introduced enum literal types that enums got a bit more special. Enum literal types gave each enum member its own type, and turned the enum itself into a _union_ of each member type. They also allowed us to refer to only a subset of the types of an enum, and to narrow away those types.\n\nts\n\n`// Color is like a union of Red | Orange | Yellow | Green | Blue | Violet`\n\n`enum Color {`\n\n    `Red, Orange, Yellow, Green, Blue, /* Indigo, */ Violet`\n\n`}`\n\n`// Each enum member has its own type that we can refer to!`\n\n`type PrimaryColor = Color.Red | Color.Green | Color.Blue;`\n\n`function isPrimaryColor(c: Color): c is PrimaryColor {`\n\n    `// Narrowing literal types can catch bugs.`\n\n    `// TypeScript will error here because`\n\n    `// we'll end up comparing 'Color.Red' to 'Color.Green'.`\n\n    `// We meant to use ||, but accidentally wrote &&.`\n\n    `return c === Color.Red && c === Color.Green && c === Color.Blue;`\n\n`}`\n\nOne issue with giving each enum member its own type was that those types were in some part associated with the actual value of the member. In some cases it’s not possible to compute that value - for instance, an enum member could be initialized by a function call.\n\nts\n\n`enum E {`\n\n    `Blah = Math.random()`\n\n`}`\n\nWhenever TypeScript ran into these issues, it would quietly back out and use the old enum strategy. That meant giving up all the advantages of unions and literal types.\n\nTypeScript 5.0 manages to make all enums into union enums by creating a unique type for each computed member. That means that all enums can now be narrowed and have their members referenced as types as well.\n\nFor more details on this change, you can [read the specifics on GitHub](https://github.com/microsoft/TypeScript/pull/50528).\n\n## [](#--moduleresolution-bundler)`--moduleResolution bundler`\n\nTypeScript 4.7 introduced the `node16` and `nodenext` options for its `--module` and `--moduleResolution` settings. The intent of these options was to better model the precise lookup rules for ECMAScript modules in Node.js; however, this mode has many restrictions that other tools don’t really enforce.\n\nFor example, in an ECMAScript module in Node.js, any relative import needs to include a file extension.\n\njs\n\n`// entry.mjs`\n\n`import * as utils from \"./utils\";     // ❌ wrong - we need to include the file extension.`\n\n`import * as utils from \"./utils.mjs\"; // ✅ works`\n\nThere are certain reasons for this in Node.js and the browser - it makes file lookups faster and works better for naive file servers. But for many developers using tools like bundlers, the `node16`/`nodenext` settings were cumbersome because bundlers don’t have most of these restrictions. In some ways, the `node` resolution mode was better for anyone using a bundler.\n\nBut in some ways, the original `node` resolution mode was already out of date. Most modern bundlers use a fusion of the ECMAScript module and CommonJS lookup rules in Node.js. For example, extensionless imports work just fine just like in CommonJS, but when looking through the [`export` conditions](https://nodejs.org/api/packages.html#nested-conditions) of a package, they’ll prefer an `import` condition just like in an ECMAScript file.\n\nTo model how bundlers work, TypeScript now introduces a new strategy: `--moduleResolution bundler`.\n\njsonc\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"target\": \"esnext\",`\n\n        `\"moduleResolution\": \"bundler\"`\n\n    `}`\n\n`}`\n\nIf you are using a modern bundler like Vite, esbuild, swc, Webpack, Parcel, and others that implement a hybrid lookup strategy, the new `bundler` option should be a good fit for you.\n\nOn the other hand, if you’re writing a library that’s meant to be published on npm, using the `bundler` option can hide compatibility issues that may arise for your users who _aren’t_ using a bundler. So in these cases, using the `node16` or `nodenext` resolution options is likely to be a better path.\n\nTo read more on `--moduleResolution bundler`, [take a look at the implementing pull request](https://github.com/microsoft/TypeScript/pull/51669).\n\n## [](#resolution-customization-flags)Resolution Customization Flags\n\nJavaScript tooling may now model “hybrid” resolution rules, like in the `bundler` mode we described above. Because tools may differ in their support slightly, TypeScript 5.0 provides ways to enable or disable a few features that may or may not work with your configuration.\n\n### [](#allowimportingtsextensions)`allowImportingTsExtensions`\n\n`--allowImportingTsExtensions` allows TypeScript files to import each other with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.\n\nThis flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is enabled, since these import paths would not be resolvable at runtime in JavaScript output files. The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between `.ts` files work.\n\n### [](#resolvepackagejsonexports)`resolvePackageJsonExports`\n\n`--resolvePackageJsonExports` forces TypeScript to consult [the `exports` field of `package.json` files](https://nodejs.org/api/packages.html#exports) if it ever reads from a package in `node_modules`.\n\nThis option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for `--moduleResolution`.\n\n### [](#resolvepackagejsonimports)`resolvePackageJsonImports`\n\n`--resolvePackageJsonImports` forces TypeScript to consult [the `imports` field of `package.json` files](https://nodejs.org/api/packages.html#imports) when performing a lookup that starts with `#` from a file whose ancestor directory contains a `package.json`.\n\nThis option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for `--moduleResolution`.\n\n### [](#allowarbitraryextensions)`allowArbitraryExtensions`\n\nIn TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of `{file basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:\n\ncss\n\n`/* app.css */`\n\n`.cookie-banner {`\n\n  `display: none;`\n\n`}`\n\nts\n\n`// app.d.css.ts`\n\n`declare const css: {`\n\n  `cookieBanner: string;`\n\n`};`\n\n`export default css;`\n\nts\n\n`// App.tsx`\n\n`import styles from \"./app.css\";`\n\n`styles.cookieBanner; // string`\n\nBy default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it. But if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new `--allowArbitraryExtensions` compiler option.\n\nNote that historically, a similar effect has often been achievable by adding a declaration file named `app.css.d.ts` instead of `app.d.css.ts` - however, this just worked through Node’s `require` resolution rules for CommonJS. Strictly speaking, the former is interpreted as a declaration file for a JavaScript file named `app.css.js`. Because relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under `--moduleResolution node16` or `nodenext`.\n\nFor more information, read up [the proposalfor this feature](https://github.com/microsoft/TypeScript/issues/50133) and [its corresponding pull request](https://github.com/microsoft/TypeScript/pull/51435).\n\n### [](#customconditions)`customConditions`\n\n`--customConditions` takes a list of additional [conditions](https://nodejs.org/api/packages.html#nested-conditions) that should succeed when TypeScript resolves from an [`exports`](https://nodejs.org/api/packages.html#exports) or [`imports`](https://nodejs.org/api/packages.html#imports) field of a `package.json`. These conditions are added to whatever existing conditions a resolver will use by default.\n\nFor example, when this field is set in a `tsconfig.json` as so:\n\njsonc\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"target\": \"es2022\",`\n\n        `\"moduleResolution\": \"bundler\",`\n\n        `\"customConditions\": [\"my-condition\"]`\n\n    `}`\n\n`}`\n\nAny time an `exports` or `imports` field is referenced in `package.json`, TypeScript will consider conditions called `my-condition`.\n\nSo when importing from a package with the following `package.json`\n\njsonc\n\n`{`\n\n    `// ...`\n\n    `\"exports\": {`\n\n        `\".\": {`\n\n            `\"my-condition\": \"./foo.mjs\",`\n\n            `\"node\": \"./bar.mjs\",`\n\n            `\"import\": \"./baz.mjs\",`\n\n            `\"require\": \"./biz.mjs\"`\n\n        `}`\n\n    `}`\n\n`}`\n\nTypeScript will try to look for files corresponding to `foo.mjs`.\n\nThis field is only valid under the `node16`, `nodenext`, and `bundler` options for `--moduleResolution`\n\n## [](#--verbatimmodulesyntax)`--verbatimModuleSyntax`\n\nBy default, TypeScript does something called _import elision_. Basically, if you write something like\n\nts\n\n`import { Car } from \"./car\";`\n\n`export function drive(car: Car) {`\n\n    `// ...`\n\n`}`\n\nTypeScript detects that you’re only using an import for types and drops the import entirely. Your output JavaScript might look something like this:\n\njs\n\n`export function drive(car) {`\n\n    `// ...`\n\n`}`\n\nMost of the time this is good, because if `Car` isn’t a value that’s exported from `./car`, we’ll get a runtime error.\n\nBut it does add a layer of complexity for certain edge cases. For example, notice there’s no statement like `import \"./car\";` - the import was dropped entirely. That actually makes a difference for modules that have side-effects or not.\n\nTypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well. So it’s not always clear whether code like the following\n\nts\n\n`export { Car } from \"./car\";`\n\nshould be preserved or dropped. If `Car` is declared with something like a `class`, then it can be preserved in the resulting JavaScript file. But if `Car` is only declared as a `type` alias or `interface`, then the JavaScript file shouldn’t export `Car` at all.\n\nWhile TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.\n\nThe `type` modifier on imports and exports helps with these situations a bit. We can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the `type` modifier.\n\nts\n\n`// This statement can be dropped entirely in JS output`\n\n`import type * as car from \"./car\";`\n\n`// The named import/export 'Car' can be dropped in JS output`\n\n`import { type Car } from \"./car\";`\n\n`export { type Car } from \"./car\";`\n\n`type` modifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between `type` and plain imports and exports. So TypeScript has the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier, `--preserveValueImports` to prevent _some_ module elision behavior, and `--isolatedModules` to make sure that your TypeScript code works across different compilers. Unfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.\n\nTypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to simplify the situation. The rules are much simpler - any imports or exports without a `type` modifier are left around. Anything that uses the `type` modifier is dropped entirely.\n\nts\n\n`// Erased away entirely.`\n\n`import type { A } from \"a\";`\n\n`// Rewritten to 'import { b } from \"bcd\";'`\n\n`import { b, type c, type d } from \"bcd\";`\n\n`// Rewritten to 'import {} from \"xyz\";'`\n\n`import { type xyz } from \"xyz\";`\n\nWith this new option, what you see is what you get.\n\nThat does have some implications when it comes to module interop though. Under this flag, ECMAScript `import`s and `export`s won’t be rewritten to `require` calls when your settings or file extension implied a different module system. Instead, you’ll get an error. If you need to emit code that uses `require` and `module.exports`, you’ll have to use TypeScript’s module syntax that predates ES2015:\n\n| Input TypeScript | Output JavaScript |\n| --- | --- |\n| ts<br><br>`import foo = require(\"foo\");` | js<br><br>`const foo = require(\"foo\");` |\n| ts<br><br>`function foo() {}`<br><br>`function bar() {}`<br><br>`function baz() {}`<br><br>`export = {`<br><br>    `foo,`<br><br>    `bar,`<br><br>    `baz`<br><br>`};` | js<br><br>`function foo() {}`<br><br>`function bar() {}`<br><br>`function baz() {}`<br><br>`module.exports = {`<br><br>    `foo,`<br><br>    `bar,`<br><br>    `baz`<br><br>`};` |\n\nWhile this is a limitation, it does help make some issues more obvious. For example, it’s very common to forget to set the [`type` field in `package.json`](https://nodejs.org/api/packages.html#type) under `--module node16`. As a result, developers would start writing CommonJS modules instead of an ES modules without realizing it, giving surprising lookup rules and JavaScript output. This new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different.\n\nBecause `--verbatimModuleSyntax` provides a more consistent story than `--importsNotUsedAsValues` and `--preserveValueImports`, those two existing flags are being deprecated in its favor.\n\nFor more details, read up on \\[the original pull request\\][https://github.com/microsoft/TypeScript/pull/52203](https://github.com/microsoft/TypeScript/pull/52203) and [its proposal issue](https://github.com/microsoft/TypeScript/issues/51479).\n\n## [](#support-for-export-type-)Support for `export type *`\n\nWhen TypeScript 3.8 introduced type-only imports, the new syntax wasn’t allowed on `export * from \"module\"` or `export * as ns from \"module\"` re-exports. TypeScript 5.0 adds support for both of these forms:\n\nts\n\n`// models/vehicles.ts`\n\n`export class Spaceship {`\n\n  `// ...`\n\n`}`\n\n`// models/index.ts`\n\n`export type * as vehicles from \"./vehicles\";`\n\n`// main.ts`\n\n`import { vehicles } from \"./models\";`\n\n`function takeASpaceship(s: vehicles.Spaceship) {`\n\n  ``// ✅ ok - `vehicles` only used in a type position``\n\n`}`\n\n`function makeASpaceship() {`\n\n  `return new vehicles.Spaceship();`\n\n  `//         ^^^^^^^^`\n\n  `// 'vehicles' cannot be used as a value because it was exported using 'export type'.`\n\n`}`\n\nYou can [read more about the implementation here](https://github.com/microsoft/TypeScript/pull/52217).\n\n## [](#satisfies-support-in-jsdoc)`@satisfies` Support in JSDoc\n\nTypeScript 4.9 introduced the `satisfies` operator. It made sure that the type of an expression was compatible, without affecting the type itself. For example, let’s take the following code:\n\nts\n\n`interface CompilerOptions {`\n\n    `strict?: boolean;`\n\n    `outDir?: string;`\n\n    `// ...`\n\n`}`\n\n`interface ConfigSettings {`\n\n    `compilerOptions?: CompilerOptions;`\n\n    `extends?: string | string[];`\n\n    `// ...`\n\n`}`\n\n`let myConfigSettings = {`\n\n    `compilerOptions: {`\n\n        `strict: true,`\n\n        `outDir: \"../lib\",`\n\n        `// ...`\n\n    `},`\n\n    `extends: [`\n\n        `\"@tsconfig/strictest/tsconfig.json\",`\n\n        `\"../../../tsconfig.base.json\"`\n\n    `],`\n\n`} satisfies ConfigSettings;`\n\nHere, TypeScript knows that `myConfigSettings.extends` was declared with an array - because while `satisfies` validated the type of our object, it didn’t bluntly change it to `CompilerOptions` and lose information. So if we want to map over `extends`, that’s fine.\n\nts\n\n`declare function resolveConfig(configPath: string): CompilerOptions;`\n\n`let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);`\n\nThis was helpful for TypeScript users, but plenty of people use TypeScript to type-check their JavaScript code using JSDoc annotations. That’s why TypeScript 5.0 is supporting a new JSDoc tag called `@satisfies` that does exactly the same thing.\n\n`/** @satisfies */` can catch type mismatches:\n\njs\n\n`// @ts-check`\n\n`/**`\n\n `* @typedef CompilerOptions`\n\n `* @prop {boolean} [strict]`\n\n `* @prop {string} [outDir]`\n\n `*/`\n\n`/**`\n\n `* @satisfies {CompilerOptions}`\n\n `*/`\n\n`let myCompilerOptions = {`\n\n    `outdir: \"../lib\",`\n\n`//  ~~~~~~ oops! we meant outDir`\n\n`};`\n\nBut it will preserve the original type of our expressions, allowing us to use our values more precisely later on in our code.\n\njs\n\n`// @ts-check`\n\n`/**`\n\n `* @typedef CompilerOptions`\n\n `* @prop {boolean} [strict]`\n\n `* @prop {string} [outDir]`\n\n `*/`\n\n`/**`\n\n `* @typedef ConfigSettings`\n\n `* @prop {CompilerOptions} [compilerOptions]`\n\n `* @prop {string | string[]} [extends]`\n\n `*/`\n\n`/**`\n\n `* @satisfies {ConfigSettings}`\n\n `*/`\n\n`let myConfigSettings = {`\n\n    `compilerOptions: {`\n\n        `strict: true,`\n\n        `outDir: \"../lib\",`\n\n    `},`\n\n    `extends: [`\n\n        `\"@tsconfig/strictest/tsconfig.json\",`\n\n        `\"../../../tsconfig.base.json\"`\n\n    `],`\n\n`};`\n\n`let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);`\n\n`/** @satisfies */` can also be used inline on any parenthesized expression. We could have written `myCompilerOptions` like this:\n\nts\n\n`let myConfigSettings = /** @satisfies {ConfigSettings} */ ({`\n\n    `compilerOptions: {`\n\n        `strict: true,`\n\n        `outDir: \"../lib\",`\n\n    `},`\n\n    `extends: [`\n\n        `\"@tsconfig/strictest/tsconfig.json\",`\n\n        `\"../../../tsconfig.base.json\"`\n\n    `],`\n\n`});`\n\nWhy? Well, it usually makes more sense when you’re deeper in some other code, like a function call.\n\njs\n\n`compileCode(/** @satisfies {CompilerOptions} */ ({`\n\n    `// ...`\n\n`}));`\n\n[This feature](https://github.com/microsoft/TypeScript/pull/51753) was provided thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)!\n\n## [](#overload-support-in-jsdoc)`@overload` Support in JSDoc\n\nIn TypeScript, you can specify overloads for a function. Overloads give us a way to say that a function can be called with different arguments, and possibly return different results. They can restrict how callers can actually use our functions, and refine what results they’ll get back.\n\nts\n\n`// Our overloads:`\n\n`function printValue(str: string): void;`\n\n`function printValue(num: number, maxFractionDigits?: number): void;`\n\n`// Our implementation:`\n\n`function printValue(value: string | number, maximumFractionDigits?: number) {`\n\n    `if (typeof value === \"number\") {`\n\n        `const formatter = Intl.NumberFormat(\"en-US\", {`\n\n            `maximumFractionDigits,`\n\n        `});`\n\n        `value = formatter.format(value);`\n\n    `}`\n\n    `console.log(value);`\n\n`}`\n\nHere, we’ve said that `printValue` takes either a `string` or a `number` as its first argument. If it takes a `number`, it can take a second argument to determine how many fractional digits we can print.\n\nTypeScript 5.0 now allows JSDoc to declare overloads with a new `@overload` tag. Each JSDoc comment with an `@overload` tag is treated as a distinct overload for the following function declaration.\n\njs\n\n`// @ts-check`\n\n`/**`\n\n `* @overload`\n\n `* @param {string} value`\n\n `* @return {void}`\n\n `*/`\n\n`/**`\n\n `* @overload`\n\n `* @param {number} value`\n\n `* @param {number} [maximumFractionDigits]`\n\n `* @return {void}`\n\n `*/`\n\n`/**`\n\n `* @param {string | number} value`\n\n `* @param {number} [maximumFractionDigits]`\n\n `*/`\n\n`function printValue(value, maximumFractionDigits) {`\n\n    `if (typeof value === \"number\") {`\n\n        `const formatter = Intl.NumberFormat(\"en-US\", {`\n\n            `maximumFractionDigits,`\n\n        `});`\n\n        `value = formatter.format(value);`\n\n    `}`\n\n    `console.log(value);`\n\n`}`\n\nNow regardless of whether we’re writing in a TypeScript or JavaScript file, TypeScript can let us know if we’ve called our functions incorrectly.\n\nts\n\n`// all allowed`\n\n`printValue(\"hello!\");`\n\n`printValue(123.45);`\n\n`printValue(123.45, 2);`\n\n`printValue(\"hello!\", 123); // error!`\n\nThis new tag [was implemented](https://github.com/microsoft/TypeScript/pull/51234) thanks to [Tomasz Lenarcik](https://github.com/apendua).\n\n## [](#passing-emit-specific-flags-under---build)Passing Emit-Specific Flags Under `--build`\n\nTypeScript now allows the following flags to be passed under `--build` mode\n\n*   `--declaration`\n*   `--emitDeclarationOnly`\n*   `--declarationMap`\n*   `--sourceMap`\n*   `--inlineSourceMap`\n\nThis makes it way easier to customize certain parts of a build where you might have different development and production builds.\n\nFor example, a development build of a library might not need to produce declaration files, but a production build would. A project can configure declaration emit to be off by default and simply be built with\n\nsh\n\n`tsc --build -p ./my-project-dir`\n\nOnce you’re done iterating in the inner loop, a “production” build can just pass the `--declaration` flag.\n\nsh\n\n`tsc --build -p ./my-project-dir --declaration`\n\n[More information on this change is available here](https://github.com/microsoft/TypeScript/pull/51241).\n\n## [](#case-insensitive-import-sorting-in-editors)Case-Insensitive Import Sorting in Editors\n\nIn editors like Visual Studio and VS Code, TypeScript powers the experience for organizing and sorting imports and exports. Often though, there can be different interpretations of when a list is “sorted”.\n\nFor example, is the following import list sorted?\n\nts\n\n`import {`\n\n    `Toggle,`\n\n    `freeze,`\n\n    `toBoolean,`\n\n`} from \"./utils\";`\n\nThe answer might surprisingly be “it depends”. If we _don’t_ care about case-sensitivity, then this list is clearly not sorted. The letter `f` comes before both `t` and `T`.\n\nBut in most programming languages, sorting defaults to comparing the byte values of strings. The way JavaScript compares strings means that `\"Toggle\"` always comes before `\"freeze\"` because according to the [ASCII character encoding](https://en.wikipedia.org/wiki/ASCII), uppercase letters come before lowercase. So from that perspective, the import list is sorted.\n\nTypeScript previously considered the import list to be sorted because it was doing a basic case-sensitive sort. This could be a point of frustration for developers who preferred a case-_insensitive_ ordering, or who used tools like ESLint which require to case-insensitive ordering by default.\n\nTypeScript now detects case sensitivity by default. This means that TypeScript and tools like ESLint typically won’t “fight” each other over how to best sort imports.\n\nOur team has also been experimenting [with further sorting strategies which you can read about here](https://github.com/microsoft/TypeScript/pull/52115). These options may eventually be configurable by editors. For now, they are still unstable and experimental, and you can opt into them in VS Code today by using the `typescript.unstable` entry in your JSON options. Below are all of the options you can try out (set to their defaults):\n\njsonc\n\n`{`\n\n    `\"typescript.unstable\": {`\n\n        `// Should sorting be case-sensitive? Can be:`\n\n        `// - true`\n\n        `// - false`\n\n        `// - \"auto\" (auto-detect)`\n\n        `\"organizeImportsIgnoreCase\": \"auto\",`\n\n        `// Should sorting be \"ordinal\" and use code points or consider Unicode rules? Can be:`\n\n        `// - \"ordinal\"`\n\n        `// - \"unicode\"`\n\n        `\"organizeImportsCollation\": \"ordinal\",`\n\n        ``// Under `\"organizeImportsCollation\": \"unicode\"`,``\n\n        `// what is the current locale? Can be:`\n\n        `// - [any other locale code]`\n\n        `// - \"auto\" (use the editor's locale)`\n\n        `\"organizeImportsLocale\": \"en\",`\n\n        ``// Under `\"organizeImportsCollation\": \"unicode\"`,``\n\n        `// should upper-case letters or lower-case letters come first? Can be:`\n\n        `// - false (locale-specific)`\n\n        `// - \"upper\"`\n\n        `// - \"lower\"`\n\n        `\"organizeImportsCaseFirst\": false,`\n\n        ``// Under `\"organizeImportsCollation\": \"unicode\"`,``\n\n        `// do runs of numbers get compared numerically (i.e. \"a1\" < \"a2\" < \"a100\")? Can be:`\n\n        `// - true`\n\n        `// - false`\n\n        `\"organizeImportsNumericCollation\": true,`\n\n        ``// Under `\"organizeImportsCollation\": \"unicode\"`,``\n\n        `// do letters with accent marks/diacritics get sorted distinctly`\n\n        `// from their \"base\" letter (i.e. is é different from e)? Can be`\n\n        `// - true`\n\n        `// - false`\n\n        `\"organizeImportsAccentCollation\": true`\n\n    `},`\n\n    `\"javascript.unstable\": {`\n\n        `// same options valid here...`\n\n    `},`\n\n`}`\n\nYou can read more details on [the original work for auto-detecting and specifying case-insensitivity](https://github.com/microsoft/TypeScript/pull/51733), followed by the [the broader set of options](https://github.com/microsoft/TypeScript/pull/52115).\n\n## [](#exhaustive-switchcase-completions)Exhaustive `switch`/`case` Completions\n\nWhen writing a `switch` statement, TypeScript now detects when the value being checked has a literal type. If so, it will offer a completion that scaffolds out each uncovered `case`.\n\n![A set of case statements generated through auto-completion based on literal types.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/01/switchCaseSnippets-5-0_1.gif)\n\nYou can [see specifics of the implementation on GitHub](https://github.com/microsoft/TypeScript/pull/50996).\n\n## [](#speed-memory-and-package-size-optimizations)Speed, Memory, and Package Size Optimizations\n\nTypeScript 5.0 contains lots of powerful changes across our code structure, our data structures, and algorithmic implementations. What these all mean is that your entire experience should be faster - not just running TypeScript, but even installing it.\n\nHere are a few interesting wins in speed and size that we’ve been able to capture relative to TypeScript 4.9.\n\n| Scenario | Time or Size Relative to TS 4.9 |\n| --- | --- |\n| material-ui build time | 89% |\n| TypeScript Compiler startup time | 89% |\n| Playwright build time | 88% |\n| TypeScript Compiler self-build time | 87% |\n| Outlook Web build time | 82% |\n| VS Code build time | 80% |\n| typescript npm Package Size | 59% |\n\n![Chart of build/run times and package size of TypeScript 5.0 relative to TypeScript 4.9: material-ui docs build time: 89%; Playwright build time: 88%; tsc startup time: 87%; tsc build time: 87%; Outlook Web build time: 82%; VS Code build time: 80%; typescript Package Size: 59%](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/speed-and-size-5-0-rc.png?1)\n\nHow? There are a few notable improvements we’d like give more details on in the future. But we won’t make you wait for that blog post.\n\nFirst off, we recently migrated TypeScript from namespaces to modules, allowing us to leverage modern build tooling that can perform optimizations like scope hoisting. Using this tooling, revisiting our packaging strategy, and removing some deprecated code has shaved off about 26.4 MB from TypeScript 4.9’s 63.8 MB package size. It also brought us a notable speed-up through direct function calls.\n\nTypeScript also added more uniformity to internal object types within the compiler, and also slimmed the data stored on some of these object types as well. This reduced polymorphic and megamorphic use sites, while offsetting most of the necessary memory consumption that was necessary for uniform shapes.\n\nWe’ve also performed some caching when serializing information to strings. Type display, which can happen as part of error reporting, declaration emit, code completions, and more, can end up being fairly expensive. TypeScript now caches some commonly used machinery to reuse across these operations.\n\nAnother notable change we made that improved our parser was leveraging `var` to occasionally side-step the cost of using `let` and `const` across closures. This improved some of our parsing performance.\n\nOverall, we expect most codebases should see speed improvements from TypeScript 5.0, and have consistently been able to reproduce wins between 10% to 20%. Of course this will depend on hardware and codebase characteristics, but we encourage you to try it out on your codebase today!\n\nFor more information, see some of our notable optimizations:\n\n*   [Migrate to Modules](https://github.com/microsoft/TypeScript/pull/51387)\n*   [`Node` Monomorphization](https://github.com/microsoft/TypeScript/pull/51682)\n*   [`Symbol` Monomorphization](https://github.com/microsoft/TypeScript/pull/51880)\n*   [`Identifier` Size Reduction](https://github.com/microsoft/TypeScript/pull/52170)\n*   [`Printer` Caching](https://github.com/microsoft/TypeScript/pull/52382)\n*   [Limited Usage of `var`](https://github.com/microsoft/TypeScript/issues/52924)\n\n## [](#breaking-changes-and-deprecations)Breaking Changes and Deprecations\n\n### [](#runtime-requirements)Runtime Requirements\n\nTypeScript now targets ECMAScript 2018. For Node users, that means a minimum version requirement of at least Node.js 10 and later.\n\n### [](#libdts-changes)`lib.d.ts` Changes\n\nChanges to how types for the DOM are generated might have an impact on existing code. Notably, certain properties have been converted from `number` to numeric literal types, and properties and methods for cut, copy, and paste event handling have been moved across interfaces.\n\n### [](#api-breaking-changes)API Breaking Changes\n\nIn TypeScript 5.0, we moved to modules, removed some unnecessary interfaces, and made some correctness improvements. For more details on what’s changed, see our [API Breaking Changes](https://github.com/microsoft/TypeScript/wiki/API-Breaking-Changes) page.\n\n### [](#forbidden-implicit-coercions-in-relational-operators)Forbidden Implicit Coercions in Relational Operators\n\nCertain operations in TypeScript will already warn you if you write code which may cause an implicit string-to-number coercion:\n\nts\n\n`function func(ns: number | string) {`\n\n  `return ns * 4; // Error, possible implicit coercion`\n\n`}`\n\nIn 5.0, this will also be applied to the relational operators `>`, `<`, `<=`, and `>=`:\n\nts\n\n`function func(ns: number | string) {`\n\n  `return ns > 4; // Now also an error`\n\n`}`\n\nTo allow this if desired, you can explicitly coerce the operand to a `number` using `+`:\n\nts\n\n`function func(ns: number | string) {`\n\n  `return +ns > 4; // OK`\n\n`}`\n\nThis [correctness improvement](https://github.com/microsoft/TypeScript/pull/52048) was contributed courtesy of [Mateusz Burzyński](https://github.com/Andarist).\n\n### [](#enum-overhaul)Enum Overhaul\n\nTypeScript has had some long-standing oddities around `enum`s ever since its first release. In 5.0, we’re cleaning up some of these problems, as well as reducing the concept count needed to understand the various kinds of `enum`s you can declare.\n\nThere are two main new errors you might see as part of this. The first is that assigning an out-of-domain literal to an `enum` type will now error as one might expect:\n\nts\n\n`enum SomeEvenDigit {`\n\n    `Zero = 0,`\n\n    `Two = 2,`\n\n    `Four = 4`\n\n`}`\n\n`// Now correctly an error`\n\n`let m: SomeEvenDigit = 1;`\n\nThe other is that declaration of certain kinds of indirected mixed string/number `enum` forms would, incorrectly, create an all-number `enum`:\n\nts\n\n`enum Letters {`\n\n    `A = \"a\"`\n\n`}`\n\n`enum Numbers {`\n\n    `one = 1,`\n\n    `two = Letters.A`\n\n`}`\n\n`// Now correctly an error`\n\n`const t: number = Numbers.two;`\n\nYou can [see more details in relevant change](https://github.com/microsoft/TypeScript/pull/50528).\n\n### [](#more-accurate-type-checking-for-parameter-decorators-in-constructors-under---experimentaldecorators)More Accurate Type-Checking for Parameter Decorators in Constructors Under `--experimentalDecorators`\n\nTypeScript 5.0 makes type-checking more accurate for decorators under `--experimentalDecorators`. One place where this becomes apparent is when using a decorator on a constructor parameter.\n\nts\n\n`export declare const inject:`\n\n  `(entity: any) =>`\n\n    `(target: object, key: string | symbol, index?: number) => void;`\n\n`export class Foo {}`\n\n`export class C {`\n\n    `constructor(@inject(Foo) private x: any) {`\n\n    `}`\n\n`}`\n\nThis call will fail because `key` expects a `string | symbol`, but constructor parameters receive a key of `undefined`. The correct fix is to change the type of `key` within `inject`. A reasonable workaround if you’re using a library that can’t be upgraded is is to wrap `inject` in a more type-safe decorator function, and use a type-assertion on `key`.\n\nFor more details, [see this issue](https://github.com/microsoft/TypeScript/issues/52435).\n\n### [](#deprecations-and-default-changes)Deprecations and Default Changes\n\nIn TypeScript 5.0, we’ve deprecated the following settings and setting values:\n\n*   `--target: ES3`\n*   `--out`\n*   `--noImplicitUseStrict`\n*   `--keyofStringsOnly`\n*   `--suppressExcessPropertyErrors`\n*   `--suppressImplicitAnyIndexErrors`\n*   `--noStrictGenericChecks`\n*   `--charset`\n*   `--importsNotUsedAsValues`\n*   `--preserveValueImports`\n*   `prepend` in project references\n\nThese configurations will continue to be allowed until TypeScript 5.5, at which point they will be removed entirely, however, you will receive a warning if you are using these settings. In TypeScript 5.0, as well as future releases 5.1, 5.2, 5.3, and 5.4, you can specify `\"ignoreDeprecations\": \"5.0\"` to silence those warnings. We’ll also shortly be releasing a 4.9 patch to allow specifying `ignoreDeprecations` to allow for smoother upgrades. Aside from deprecations, we’ve changed some settings to better improve cross-platform behavior in TypeScript.\n\n`--newLine`, which controls the line endings emitted in JavaScript files, used to be inferred based on the current operating system if not specified. We think builds should be as deterministic as possible, and Windows Notepad supports line-feed line endings now, so the new default setting is `LF`. The old OS-specific inference behavior is no longer available.\n\n`--forceConsistentCasingInFileNames`, which ensured that all references to the same file name in a project agreed in casing, now defaults to `true`. This can help catch differences issues with code written on case-insensitive file systems.\n\nYou can leave feedback and view more information on the [tracking issue for 5.0 deprecations](https://github.com/microsoft/TypeScript/issues/51909)",
    "title": "TypeScript: Documentation - TypeScript 5.0",
    "description": "TypeScript 5.0 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.9\n\n## [](#the-satisfies-operator)The `satisfies` Operator\n\nTypeScript developers are often faced with a dilemma: we want to ensure that some expression _matches_ some type, but also want to keep the _most specific_ type of that expression for inference purposes.\n\nFor example:\n\nts\n\n`// Each property can be a string or an RGB tuple.`\n\n`const palette = {`\n\n    `red: [255, 0, 0],`\n\n    `green: \"#00ff00\",`\n\n    `bleu: [0, 0, 255]`\n\n`//  ^^^^ sacrebleu - we've made a typo!`\n\n`};`\n\n`// We want to be able to use string methods on 'green'...`\n\n`const greenNormalized = palette.green.toUpperCase();`\n\nNotice that we’ve written `bleu`, whereas we probably should have written `blue`. We could try to catch that `bleu` typo by using a type annotation on `palette`, but we’d lose the information about each property.\n\nts\n\n`type Colors = \"red\" | \"green\" | \"blue\";`\n\n`type RGB = [red: number, green: number, blue: number];`\n\n`const palette: Record<Colors, string | RGB> = {`\n\n    `red: [255, 0, 0],`\n\n    `green: \"#00ff00\",`\n\n    `bleu: [0, 0, 255]`\n\n`//  ~~~~ The typo is now correctly detected`\n\n`};`\n\n`// But we now have an undesirable error here - 'palette.green' \"could\" be of type RGB and`\n\n`// property 'toUpperCase' does not exist on type 'string | RGB'.`\n\n`const greenNormalized = palette.green.toUpperCase();`\n\nThe new `satisfies` operator lets us validate that the type of an expression matches some type, without changing the resulting type of that expression. As an example, we could use `satisfies` to validate that all the properties of `palette` are compatible with `string | number[]`:\n\nts\n\n`type Colors = \"red\" | \"green\" | \"blue\";`\n\n`type RGB = [red: number, green: number, blue: number];`\n\n`const palette = {`\n\n    `red: [255, 0, 0],`\n\n    `green: \"#00ff00\",`\n\n    `bleu: [0, 0, 255]`\n\n`//  ~~~~ The typo is now caught!`\n\n`} satisfies Record<Colors, string | RGB>;`\n\n`// toUpperCase() method is still accessible!`\n\n`const greenNormalized = palette.green.toUpperCase();`\n\n`satisfies` can be used to catch lots of possible errors. For example, we could ensure that an object has _all_ the keys of some type, but no more:\n\nts\n\n`type Colors = \"red\" | \"green\" | \"blue\";`\n\n`// Ensure that we have exactly the keys from 'Colors'.`\n\n`const favoriteColors = {`\n\n    `\"red\": \"yes\",`\n\n    `\"green\": false,`\n\n    `\"blue\": \"kinda\",`\n\n    `\"platypus\": false`\n\n`//  ~~~~~~~~~~ error - \"platypus\" was never listed in 'Colors'.`\n\n`} satisfies Record<Colors, unknown>;`\n\n`// All the information about the 'red', 'green', and 'blue' properties are retained.`\n\n`const g: boolean = favoriteColors.green;`\n\nMaybe we don’t care about if the property names match up somehow, but we do care about the types of each property. In that case, we can also ensure that all of an object’s property values conform to some type.\n\nts\n\n`type RGB = [red: number, green: number, blue: number];`\n\n`const palette = {`\n\n    `red: [255, 0, 0],`\n\n    `green: \"#00ff00\",`\n\n    `blue: [0, 0]`\n\n    `//    ~~~~~~ error!`\n\n`} satisfies Record<string, string | RGB>;`\n\n`// Information about each property is still maintained.`\n\n`const redComponent = palette.red.at(0);`\n\n`const greenNormalized = palette.green.toUpperCase();`\n\nFor more examples, you can see the [issue proposing this](https://github.com/microsoft/TypeScript/issues/47920) and [the implementing pull request](https://github.com/microsoft/TypeScript/pull/46827). We’d like to thank [Oleksandr Tarasiuk](https://github.com/a-tarasyuk) who implemented and iterated on this feature with us.\n\n## [](#unlisted-property-narrowing-with-the-in-operator)Unlisted Property Narrowing with the `in` Operator\n\nAs developers, we often need to deal with values that aren’t fully known at runtime. In fact, we often don’t know if properties exist, whether we’re getting a response from a server or reading a configuration file. JavaScript’s `in` operator can check whether a property exists on an object.\n\nPreviously, TypeScript allowed us to narrow away any types that don’t explicitly list a property.\n\nts\n\n`interface RGB {`\n\n    `red: number;`\n\n    `green: number;`\n\n    `blue: number;`\n\n`}`\n\n`interface HSV {`\n\n    `hue: number;`\n\n    `saturation: number;`\n\n    `value: number;`\n\n`}`\n\n`function setColor(color: RGB | HSV) {`\n\n    `if (\"hue\" in color) {`\n\n        `// 'color' now has the type HSV`\n\n    `}`\n\n    `// ...`\n\n`}`\n\nHere, the type `RGB` didn’t list the `hue` and got narrowed away, and leaving us with the type `HSV`.\n\nBut what about examples where no type listed a given property? In those cases, the language didn’t help us much. Let’s take the following example in JavaScript:\n\njs\n\n`function tryGetPackageName(context) {`\n\n    `const packageJSON = context.packageJSON;`\n\n    `// Check to see if we have an object.`\n\n    `if (packageJSON && typeof packageJSON === \"object\") {`\n\n        `// Check to see if it has a string name property.`\n\n        `if (\"name\" in packageJSON && typeof packageJSON.name === \"string\") {`\n\n            `return packageJSON.name;`\n\n        `}`\n\n    `}`\n\n    `return undefined;`\n\n`}`\n\nRewriting this to canonical TypeScript would just be a matter of defining and using a type for `context`; however, picking a safe type like `unknown` for the `packageJSON` property would cause issues in older versions of TypeScript.\n\nts\n\n`interface Context {`\n\n    `packageJSON: unknown;`\n\n`}`\n\n`function tryGetPackageName(context: Context) {`\n\n    `const packageJSON = context.packageJSON;`\n\n    `// Check to see if we have an object.`\n\n    `if (packageJSON && typeof packageJSON === \"object\") {`\n\n        `// Check to see if it has a string name property.`\n\n        `if (\"name\" in packageJSON && typeof packageJSON.name === \"string\") {`\n\n        `//                                              ~~~~`\n\n        `// error! Property 'name' does not exist on type 'object.`\n\n            `return packageJSON.name;`\n\n        `//                     ~~~~`\n\n        `// error! Property 'name' does not exist on type 'object.`\n\n        `}`\n\n    `}`\n\n    `return undefined;`\n\n`}`\n\nThis is because while the type of `packageJSON` was narrowed from `unknown` to `object`, the `in` operator strictly narrowed to types that actually defined the property being checked. As a result, the type of `packageJSON` remained `object`.\n\nTypeScript 4.9 makes the `in` operator a little bit more powerful when narrowing types that _don’t_ list the property at all. Instead of leaving them as-is, the language will intersect their types with `Record<\"property-key-being-checked\", unknown>`.\n\nSo in our example, `packageJSON` will have its type narrowed from `unknown` to `object` to `object & Record<\"name\", unknown>` That allows us to access `packageJSON.name` directly and narrow that independently.\n\nts\n\n`interface Context {`\n\n    `packageJSON: unknown;`\n\n`}`\n\n`function tryGetPackageName(context: Context): string | undefined {`\n\n    `const packageJSON = context.packageJSON;`\n\n    `// Check to see if we have an object.`\n\n    `if (packageJSON && typeof packageJSON === \"object\") {`\n\n        `// Check to see if it has a string name property.`\n\n        `if (\"name\" in packageJSON && typeof packageJSON.name === \"string\") {`\n\n            `// Just works!`\n\n            `return packageJSON.name;`\n\n        `}`\n\n    `}`\n\n    `return undefined;`\n\n`}`\n\nTypeScript 4.9 also tightens up a few checks around how `in` is used, ensuring that the left side is assignable to the type `string | number | symbol`, and the right side is assignable to `object`. This helps check that we’re using valid property keys, and not accidentally checking primitives.\n\nFor more information, [read the implementing pull request](https://github.com/microsoft/TypeScript/pull/50666)\n\n## [](#auto-accessors-in-classes)Auto-Accessors in Classes\n\nTypeScript 4.9 supports an upcoming feature in ECMAScript called auto-accessors. Auto-accessors are declared just like properties on classes, except that they’re declared with the `accessor` keyword.\n\nts\n\n`class Person {`\n\n    `accessor name: string;`\n\n    `constructor(name: string) {`\n\n        `this.name = name;`\n\n    `}`\n\n`}`\n\nUnder the covers, these auto-accessors “de-sugar” to a `get` and `set` accessor with an unreachable private property.\n\nts\n\n`class Person {`\n\n    `#__name: string;`\n\n    `get name() {`\n\n        `return this.#__name;`\n\n    `}`\n\n    `set name(value: string) {`\n\n        `this.#__name = value;`\n\n    `}`\n\n    `constructor(name: string) {`\n\n        `this.name = name;`\n\n    `}`\n\n`}`\n\nYou can [read up more about the auto-accessors pull request on the original PR](https://github.com/microsoft/TypeScript/pull/49705).\n\n## [](#checks-for-equality-on-nan)Checks For Equality on `NaN`\n\nA major gotcha for JavaScript developers is checking against the value `NaN` using the built-in equality operators.\n\nFor some background, `NaN` is a special numeric value that stands for “Not a Number”. Nothing is ever equal to `NaN` - even `NaN`!\n\njs\n\n`console.log(NaN == 0)  // false`\n\n`console.log(NaN === 0) // false`\n\n`console.log(NaN == NaN)  // false`\n\n`console.log(NaN === NaN) // false`\n\nBut at least symmetrically _everything_ is always not-equal to `NaN`.\n\njs\n\n`console.log(NaN != 0)  // true`\n\n`console.log(NaN !== 0) // true`\n\n`console.log(NaN != NaN)  // true`\n\n`console.log(NaN !== NaN) // true`\n\nThis technically isn’t a JavaScript-specific problem, since any language that contains IEEE-754 floats has the same behavior; but JavaScript’s primary numeric type is a floating point number, and number parsing in JavaScript can often result in `NaN`. In turn, checking against `NaN` ends up being fairly common, and the correct way to do so is to use [`Number.isNaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN) - _but_ as we mentioned, lots of people accidentally end up checking with `someValue === NaN` instead.\n\nTypeScript now errors on direct comparisons against `NaN`, and will suggest using some variation of `Number.isNaN` instead.\n\nts\n\n`function validate(someValue: number) {`\n\n    `return someValue !== NaN;`\n\n    `//     ~~~~~~~~~~~~~~~~~`\n\n    `// error: This condition will always return 'true'.`\n\n    `//        Did you mean '!Number.isNaN(someValue)'?`\n\n`}`\n\nWe believe that this change should strictly help catch beginner errors, similar to how TypeScript currently issues errors on comparisons against object and array literals.\n\nWe’d like to extend our thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk) who [contributed this check](https://github.com/microsoft/TypeScript/pull/50626).\n\n## [](#file-watching-now-uses-file-system-events)File-Watching Now Uses File System Events\n\nIn earlier versions, TypeScript leaned heavily on _polling_ for watching individual files. Using a polling strategy meant checking the state of a file periodically for updates. On Node.js, [`fs.watchFile`](https://nodejs.org/docs/latest-v18.x/api/fs.html#fswatchfilefilename-options-listener) is the built-in way to get a polling file-watcher. While polling tends to be more predictable across platforms and file systems, it means that your CPU has to periodically get interrupted and check for updates to the file, even when nothing’s changed. For a few dozen files, this might not be noticeable; but on a bigger project with lots of files - or lots of files in `node_modules` - this can become a resource hog.\n\nGenerally speaking, a better approach is to use file system events. Instead of polling, we can announce that we’re interested in updates of specific files and provide a callback for when those files _actually do_ change. Most modern platforms in use provide facilities and APIs like `CreateIoCompletionPort`, `kqueue`, `epoll`, and `inotify`. Node.js mostly abstracts these away by providing [`fs.watch`](https://nodejs.org/docs/latest-v18.x/api/fs.html#fswatchfilename-options-listener). File system events usually work great, but there are [lots of caveats](https://nodejs.org/docs/latest-v18.x/api/fs.html#caveats) to using them, and in turn, to using the `fs.watch` API. A watcher needs to be careful to consider [inode watching](https://nodejs.org/docs/latest-v18.x/api/fs.html#inodes), [unavailability on certain file systems](https://nodejs.org/docs/latest-v18.x/api/fs.html#availability) (e.g.networked file systems), whether recursive file watching is available, whether directory renames trigger events, and even file watcher exhaustion! In other words, it’s not quite a free lunch, especially if you’re looking for something cross-platform.\n\nAs a result, our default was to pick the lowest common denominator: polling. Not always, but most of the time.\n\nOver time, we’ve provided the means to [choose other file-watching strategies](https://www.typescriptlang.org/docs/handbook/configuring-watch.html). This allowed us to get feedback and harden our file-watching implementation against most of these platform-specific gotchas. As TypeScript has needed to scale to larger codebases, and has improved in this area, we felt swapping to file system events as the default would be a worthwhile investment.\n\nIn TypeScript 4.9, file watching is powered by file system events by default, only falling back to polling if we fail to set up event-based watchers. For most developers, this should provide a much less resource-intensive experience when running in `--watch` mode, or running with a TypeScript-powered editor like Visual Studio or VS Code.\n\n[The way file-watching works can still be configured](https://www.typescriptlang.org/docs/handbook/configuring-watch.html) through environment variables and `watchOptions` - and [some editors like VS Code can support `watchOptions` independently](https://code.visualstudio.com/docs/getstarted/settings#:~:text=typescript%2etsserver%2ewatchOptions). Developers using more exotic set-ups where source code resides on a networked file systems (like NFS and SMB) may need to opt back into the older behavior; though if a server has reasonable processing power, it might just be better to enable SSH and run TypeScript remotely so that it has direct local file access. VS Code has plenty of [remote extensions](https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All%20categories&sortBy=Relevance) to make this easier.\n\nYou can [read up more on this change on GitHub](https://github.com/microsoft/TypeScript/pull/50366).\n\n## [](#remove-unused-imports-and-sort-imports-commands-for-editors)“Remove Unused Imports” and “Sort Imports” Commands for Editors\n\nPreviously, TypeScript only supported two editor commands to manage imports. For our examples, take the following code:\n\nts\n\n`import { Zebra, Moose, HoneyBadger } from \"./zoo\";`\n\n`import { foo, bar } from \"./helper\";`\n\n`let x: Moose | HoneyBadger = foo();`\n\nThe first was called “Organize Imports” which would remove unused imports, and then sort the remaining ones. It would rewrite that file to look like this one:\n\nts\n\n`import { foo } from \"./helper\";`\n\n`import { HoneyBadger, Moose } from \"./zoo\";`\n\n`let x: Moose | HoneyBadger = foo();`\n\nIn TypeScript 4.3, we introduced a command called “Sort Imports” which would _only_ sort imports in the file, but not remove them - and would rewrite the file like this.\n\nts\n\n`import { bar, foo } from \"./helper\";`\n\n`import { HoneyBadger, Moose, Zebra } from \"./zoo\";`\n\n`let x: Moose | HoneyBadger = foo();`\n\nThe caveat with “Sort Imports” was that in Visual Studio Code, this feature was only available as an on-save command - not as a manually triggerable command.\n\nTypeScript 4.9 adds the other half, and now provides “Remove Unused Imports”. TypeScript will now remove unused import names and statements, but will otherwise leave the relative ordering alone.\n\nts\n\n`import { Moose, HoneyBadger } from \"./zoo\";`\n\n`import { foo } from \"./helper\";`\n\n`let x: Moose | HoneyBadger = foo();`\n\nThis feature is available to all editors that wish to use either command; but notably, Visual Studio Code (1.73 and later) will have support built in _and_ will surface these commands via its Command Palette. Users who prefer to use the more granular “Remove Unused Imports” or “Sort Imports” commands should be able to reassign the “Organize Imports” key combination to them if desired.\n\nYou can [view specifics of the feature here](https://github.com/microsoft/TypeScript/pull/50931).\n\n## [](#go-to-definition-on-return-keywords)Go-to-Definition on `return` Keywords\n\nIn the editor, when running a go-to-definition on the `return` keyword, TypeScript will now jump you to the top of the corresponding function. This can be helpful to get a quick sense of which function a `return` belongs to.\n\nWe expect TypeScript will expand this functionality to more keywords [such as `await` and `yield`](https://github.com/microsoft/TypeScript/issues/51223) or [`switch`, `case`, and `default`](https://github.com/microsoft/TypeScript/issues/51225).\n\n[This feature was implemented](https://github.com/microsoft/TypeScript/pull/51227) thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk).\n\n## [](#performance-improvements)Performance Improvements\n\nTypeScript has a few small, but notable, performance improvements.\n\nFirst, TypeScript’s `forEachChild` function has been rewritten to use a function table lookup instead of a `switch` statement across all syntax nodes. `forEachChild` is a workhorse for traversing syntax nodes in the compiler, and is used heavily in the binding stage of our compiler, along with parts of the language service. The refactoring of `forEachChild` yielded up to a 20% reduction of time spent in our binding phase and across language service operations.\n\nOnce we discovered this performance win for `forEachChild`, we tried it out on `visitEachChild`, a function we use for transforming nodes in the compiler and language service. The same refactoring yielded up to a 3% reduction in time spent in generating project output.\n\nThe initial exploration in `forEachChild` was [inspired by a blog post](https://artemis.sh/2022/08/07/emulating-calculators-fast-in-js.html) by [Artemis Everfree](https://artemis.sh/). While we have some reason to believe the root cause of our speed-up might have more to do with function size/complexity than the issues described in the blog post, we’re grateful that we were able to learn from the experience and try out a relatively quick refactoring that made TypeScript faster.\n\nFinally, the way TypeScript preserves the information about a type in the true branch of a conditional type has been optimized. In a type like\n\nts\n\n`interface Zoo<T extends Animal> {`\n\n    `// ...`\n\n`}`\n\n`type MakeZoo<A> = A extends Animal ? Zoo<A> : never;`\n\nTypeScript has to “remember” that `A` must also be an `Animal` when checking if `Zoo<A>` is valid. This is basically done by creating a special type that used to hold the intersection of `A` with `Animal`; however, TypeScript previously did this eagerly which isn’t always necessary. Furthermore, some faulty code in our type-checker prevented these special types from being simplified. TypeScript now defers intersecting these types until it’s necessary. For codebases with heavy use of conditional types, you might witness significant speed-ups with TypeScript, but in our performance testing suite, we saw a more modest 3% reduction in type-checking time.\n\nYou can read up more on these optimizations on their respective pull requests:\n\n*   [`forEachChild` as a jump-table](https://github.com/microsoft/TypeScript/pull/50225)\n*   [`visitEachChild` as a jump-table](https://github.com/microsoft/TypeScript/pull/50266)\n*   [Optimize substitition types](https://github.com/microsoft/TypeScript/pull/50397)\n\n## [](#correctness-fixes-and-breaking-changes)Correctness Fixes and Breaking Changes\n\n### [](#libdts-updates)`lib.d.ts` Updates\n\nWhile TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don’t expect major breaks as a result of DOM and `lib.d.ts` updates, but there may be some small ones.\n\n### [](#better-types-for-promiseresolve)Better Types for `Promise.resolve`\n\n`Promise.resolve` now uses the `Awaited` type to unwrap Promise-like types passed to it. This means that it more often returns the right `Promise` type, but that improved type can break existing code if it was expecting `any` or `unknown` instead of a `Promise`. For more information, [see the original change](https://github.com/microsoft/TypeScript/pull/33074).\n\n### [](#javascript-emit-no-longer-elides-imports)JavaScript Emit No Longer Elides Imports\n\nWhen TypeScript first supported type-checking and compilation for JavaScript, it accidentally supported a feature called import elision. In short, if an import is not used as a value, or the compiler can detect that the import doesn’t refer to a value at runtime, the compiler will drop the import during emit.\n\nThis behavior was questionable, especially the detection of whether the import doesn’t refer to a value, since it means that TypeScript has to trust sometimes-inaccurate declaration files. In turn, TypeScript now preserves imports in JavaScript files.\n\njs\n\n`// Input:`\n\n`import { someValue, SomeClass } from \"some-module\";`\n\n`/** @type {SomeClass} */`\n\n`let val = someValue;`\n\n`// Previous Output:`\n\n`import { someValue } from \"some-module\";`\n\n`/** @type {SomeClass} */`\n\n`let val = someValue;`\n\n`// Current Output:`\n\n`import { someValue, SomeClass } from \"some-module\";`\n\n`/** @type {SomeClass} */`\n\n`let val = someValue;`\n\nMore information is available at [the implementing change](https://github.com/microsoft/TypeScript/pull/50404).\n\n### [](#exports-is-prioritized-over-typesversions)`exports` is Prioritized Over `typesVersions`\n\nPreviously, TypeScript incorrectly prioritized the `typesVersions` field over the `exports` field when resolving through a `package.json` under `--moduleResolution node16`. If this change impacts your library, you may need to add `types@` version selectors in your `package.json`’s `exports` field.\n\ndiff\n\n  `{`\n\n      `\"type\": \"module\",`\n\n      `\"main\": \"./dist/main.js\"`\n\n      `\"typesVersions\": {`\n\n          `\"<4.8\": { \".\": [\"4.8-types/main.d.ts\"] },`\n\n          `\"*\": { \".\": [\"modern-types/main.d.ts\"] }`\n\n      `},`\n\n      `\"exports\": {`\n\n          `\".\": {`\n\n`+             \"types@<4.8\": \"4.8-types/main.d.ts\",`\n\n`+             \"types\": \"modern-types/main.d.ts\",`\n\n              `\"import\": \"./dist/main.js\"`\n\n          `}`\n\n      `}`\n\n  `}`\n\nFor more information, [see this pull request](https://github.com/microsoft/TypeScript/pull/50890).\n\n## [](#substitute-replaced-with-constraint-on-substitutiontypes)`substitute` Replaced With `constraint` on `SubstitutionType`s\n\nAs part of an optimization on substitution types, `SubstitutionType` objects no longer contain the `substitute` property representing the effective substitution (usually an intersection of the base type and the implicit constraint) - instead, they just contain the `constraint` property.\n\nFor more details, [read more on the original pull request](https://github.com/microsoft/TypeScript/pull/50397).",
    "title": "TypeScript: Documentation - TypeScript 4.9",
    "description": "TypeScript 4.9 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.8\n\n## [](#improved-intersection-reduction-union-compatibility-and-narrowing)Improved Intersection Reduction, Union Compatibility, and Narrowing\n\nTypeScript 4.8 brings a series of correctness and consistency improvements under `--strictNullChecks`. These changes affect how intersection and union types work, and are leveraged in how TypeScript narrows types.\n\nFor example, `unknown` is close in spirit to the union type `{} | null | undefined` because it accepts `null`, `undefined`, and any other type. TypeScript now recognizes this, and allows assignments from `unknown` to `{} | null | undefined`.\n\nts\n\n`function f(x: unknown, y: {} | null | undefined) {`\n\n    `x = y; // always worked`\n\n    `y = x; // used to error, now works`\n\n`}`\n\nAnother change is that `{}` intersected with any other object type simplifies right down to that object type. That meant that we were able to rewrite `NonNullable` to just use an intersection with `{}`, because `{} & null` and `{} & undefined` just get tossed away.\n\ndiff\n\n`- type NonNullable<T> = T extends null | undefined ? never : T;`\n\n`+ type NonNullable<T> = T & {};`\n\nThis is an improvement because intersection types like this can be reduced and assigned to, while conditional types currently cannot. So `NonNullable<NonNullable<T>>` now simplifies at least to `NonNullable<T>`, whereas it didn’t before.\n\nts\n\n`function foo<T>(x: NonNullable<T>, y: NonNullable<NonNullable<T>>) {`\n\n    `x = y; // always worked`\n\n    `y = x; // used to error, now works`\n\n`}`\n\nThese changes also allowed us to bring in sensible improvements in control flow analysis and type narrowing. For example, `unknown` is now narrowed just like `{} | null | undefined` in truthy branches.\n\nts\n\n`function narrowUnknownishUnion(x: {} | null | undefined) {`\n\n    `if (x) {`\n\n        `x;  // {}`\n\n    `}`\n\n    `else {`\n\n        `x;  // {} | null | undefined`\n\n    `}`\n\n`}`\n\n`function narrowUnknown(x: unknown) {`\n\n    `if (x) {`\n\n        `x;  // used to be 'unknown', now '{}'`\n\n    `}`\n\n    `else {`\n\n        `x;  // unknown`\n\n    `}`\n\n`}`\n\nGeneric values also get narrowed similarly. When checking that a value isn’t `null` or `undefined`, TypeScript now just intersects it with `{}` - which again, is the same as saying it’s `NonNullable`. Putting many of the changes here together, we can now define the following function without any type assertions.\n\nts\n\n`function throwIfNullable<T>(value: T): NonNullable<T> {`\n\n    `if (value === undefined || value === null) {`\n\n        `throw Error(\"Nullable value!\");`\n\n    `}`\n\n    `// Used to fail because 'T' was not assignable to 'NonNullable<T>'.`\n\n    `// Now narrows to 'T & {}' and succeeds because that's just 'NonNullable<T>'.`\n\n    `return value;`\n\n`}`\n\n`value` now gets narrowed to `T & {}`, and is now identical with `NonNullable<T>` - so the body of the function just works with no TypeScript-specific syntax.\n\nOn their own, these changes may appear small - but they represent fixes for many many paper cuts that have been reported over several years.\n\nFor more specifics on these improvements, you can [read more here](https://github.com/microsoft/TypeScript/pull/49119).\n\n## [](#improved-inference-for-infer-types-in-template-string-types)Improved Inference for `infer` Types in Template String Types\n\nTypeScript recently introduced a way to add `extends` constraints to `infer` type variables in conditional types.\n\nts\n\n`// Grabs the first element of a tuple if it's assignable to 'number',`\n\n`// and returns 'never' if it can't find one.`\n\n`type TryGetNumberIfFirst<T> =`\n\n    `T extends [infer U extends number, ...unknown[]] ? U : never;`\n\nIf these `infer` types appear in a template string type and are constrained to a primitive type, TypeScript will now try to parse out a literal type.\n\nts\n\n`// SomeNum used to be 'number'; now it's '100'.`\n\n``type SomeNum = \"100\" extends `${infer U extends number}` ? U : never;``\n\n`// SomeBigInt used to be 'bigint'; now it's '100n'.`\n\n``type SomeBigInt = \"100\" extends `${infer U extends bigint}` ? U : never;``\n\n`// SomeBool used to be 'boolean'; now it's 'true'.`\n\n``type SomeBool = \"true\" extends `${infer U extends boolean}` ? U : never;``\n\nThis can now better convey what a library will do at runtime, and give more precise types.\n\nOne note on this is that when TypeScript parses these literal types out it will greedily try to parse out as much of what looks like of the appropriate primitive type; however it then checks to see if the print-back of that primitive matches up with the string contents. In other words, TypeScript checks whether the going from the string, to the primitive, and back matches. If it doesn’t see that the string can be “round-tripped”, then it will fall back to the base primitive type.\n\nts\n\n``// JustNumber is `number` here because TypeScript parses out `\"1.0\"`, but `String(Number(\"1.0\"))` is `\"1\"` and doesn't match.``\n\n``type JustNumber = \"1.0\" extends `${infer T extends number}` ? T : never;`` \n\nYou can [see more about this feature here](https://github.com/microsoft/TypeScript/pull/48094).\n\n## [](#--build---watch-and---incremental-performance-improvements)`--build`, `--watch`, and `--incremental` Performance Improvements\n\nTypeScript 4.8 introduces several optimizations that should speed up scenarios around `--watch` and `--incremental`, along with project references builds using `--build`. For example, TypeScript is now able to avoid spending time updating timestamps during no-op changes in `--watch` mode, which makes rebuilds faster and avoids messing with other build tools that might be watching for TypeScript’s output. Many other optimizations where we’re able to reuse information across `--build`, `--watch`, and `--incremental` have been introduced as well.\n\nHow big are these improvements? Well, on a fairly large internal codebase, we’ve seen time reductions on the order of 10%-25% on many simple common operations, with around 40% time reductions in no-change scenarios. We’ve seen similar results on the TypeScript codebase as well.\n\nYou can see [the changes, along with the performance results on GitHub](https://github.com/microsoft/TypeScript/pull/48784).\n\n## [](#errors-when-comparing-object-and-array-literals)Errors When Comparing Object and Array Literals\n\nIn many languages, operators like `==` perform what’s called “value” equality on objects. For example, in Python it’s valid to check whether a list is empty by checking whether a value is equal to the empty list using `==`.\n\npy\n\n`if people_at_home == []:`\n\n    `print(\"here's where I lie, broken inside. </3\")`\n\n    `adopt_animals()`\n\nThis is not the case in JavaScript, where `==` and `===` between objects (and therefore, arrays) check whether both references point to the same value. We believe that similar code in JavaScript is at best an early foot-gun for JavaScript developers, and at worst a bug in production code. That’s why TypeScript now disallows code like the following.\n\nts\n\n`if (peopleAtHome === []) {`\n\n`//  ~~~~~~~~~~~~~~~~~~~`\n\n`// This condition will always return 'false' since JavaScript compares objects by reference, not value.`\n\n    `console.log(\"here's where I lie, broken inside. </3\")`\n\n    `adoptAnimals();`\n\n`}`\n\nWe’d like to extend our gratitude to [Jack Works](https://github.com/Jack-Works) who contributed this check. You can [view the changes involved here](https://github.com/microsoft/TypeScript/pull/45978).\n\n## [](#improved-inference-from-binding-patterns)Improved Inference from Binding Patterns\n\nIn some cases, TypeScript will pick up a type from a binding pattern to make better inferences.\n\nts\n\n`declare function chooseRandomly<T>(x: T, y: T): T;`\n\n`let [a, b, c] = chooseRandomly([42, true, \"hi!\"], [0, false, \"bye!\"]);`\n\n`//   ^  ^  ^`\n\n`//   |  |  |`\n\n`//   |  |  string`\n\n`//   |  |`\n\n`//   |  boolean`\n\n`//   |`\n\n`//   number`\n\nWhen `chooseRandomly` needs to figure out a type for `T`, it will primarily look at `[42, true, \"hi!\"]` and `[0, false, \"bye!\"]`; but TypeScript needs to figure out whether those two types should be `Array<number | boolean | string>` or the tuple type `[number, boolean, string]`. To do that, it will look for existing candidates as a hint to see whether there are any tuple types. When TypeScript sees the binding pattern `[a, b, c]`, it creates the type `[any, any, any]`, and that type gets picked up as a low-priority candidate for `T` which also gets used as a hint for the types of `[42, true, \"hi!\"]` and `[0, false, \"bye!\"]`.\n\nYou can see how this was good for `chooseRandomly`, but it fell short in other cases. For example, take the following code\n\nts\n\n`declare function f<T>(x?: T): T;`\n\n`let [x, y, z] = f();`\n\nThe binding pattern `[x, y, z]` hinted that `f` should produce an `[any, any, any]` tuple; but `f` really shouldn’t change its type argument based on a binding pattern. It can’t suddenly conjure up a new array-like value based on what it’s being assigned to, so the binding pattern type has way too much influence on the produced type. On top of that, because the binding pattern type is full of `any`s, we’re left with `x`, `y`, and `z` being typed as `any`.\n\nIn TypeScript 4.8, these binding patterns are never used as candidates for type arguments. Instead, they’re just consulted in case a parameter needs a more specific type like in our `chooseRandomly` example. If you need to revert to the old behavior, you can always provide explicit type arguments.\n\nYou can [look at the change on GitHub](https://github.com/microsoft/TypeScript/pull/49086) if you’re curious to learn more.\n\n## [](#file-watching-fixes-especially-across-git-checkouts)File-Watching Fixes (Especially Across `git checkout`s)\n\nWe’ve had a long-standing bug where TypeScript has a very hard time with certain file changes in `--watch` mode and editor scenarios. Sometimes the symptoms are stale or inaccurate errors that might show up that require restarting `tsc` or VS Code. Frequently these occur on Unix systems, and you might have seen these after saving a file with vim or swapping branches in git.\n\nThis was caused by assumptions of how Node.js handles rename events across file systems. File systems used by Linux and macOS utilize [inodes](https://en.wikipedia.org/wiki/Inode), and [Node.js will attach file watchers to inodes rather than file paths](https://nodejs.org/api/fs.html#inodes). So when Node.js returns [a watcher object](https://nodejs.org/api/fs.html#class-fsfswatcher), it might be watching a path or an inode depending on the platform and file system.\n\nTo be a bit more efficient, TypeScript tries to reuse the same watcher objects if it detects a path still exists on disk. This is where things went wrong, because even if a file still exists at that path, a distinct file might have been created, and that file will have a different inode. So TypeScript would end up reusing the watcher object instead of installing a new watcher at the original location, and watch for changes at what might be a totally irrelevant file. So TypeScript 4.8 now handles these cases on inode systems and properly installs a new watcher and fixes this.\n\nWe’d like to extend our thanks to [Marc Celani](https://github.com/MarcCelani-at) and his team at Airtable who invested lots of time in investigating the issues they were experiencing and pointing out the root cause. You can view [the specific fixes around file-watching here](https://github.com/microsoft/TypeScript/pull/48997).\n\n## [](#find-all-references-performance-improvements)Find-All-References Performance Improvements\n\nWhen running find-all-references in your editor, TypeScript is now able to act a little smarter as it aggregates references. This reduced the amount of time TypeScript took to search a widely-used identifier in its own codebase by about 20%.\n\n[You can read up more on the improvement here](https://github.com/microsoft/TypeScript/pull/49581).\n\n## [](#exclude-specific-files-from-auto-imports)Exclude Specific Files from Auto-Imports\n\nTypeScript 4.8 introduces an editor preference for excluding files from auto-imports. In Visual Studio Code, file names or globs can be added under “Auto Import File Exclude Patterns” in the Settings UI, or in a `.vscode/settings.json` file:\n\njsonc\n\n`{`\n\n    ``// Note that `javascript.preferences.autoImportFileExcludePatterns` can be specified for JavaScript too.``\n\n    `\"typescript.preferences.autoImportFileExcludePatterns\": [`\n\n      `\"**/node_modules/@types/node\"`\n\n    `]`\n\n`}`\n\nThis can be useful in cases where you can’t avoid having certain modules or libraries in your compilation but you rarely want to import from them. These modules might have lots of exports that can pollute the auto-imports list and make it harder to navigate, and this option can help in those situations.\n\nYou can [see more specifics about the implementation here](https://github.com/microsoft/TypeScript/pull/49578).\n\n## [](#correctness-fixes-and-breaking-changes)Correctness Fixes and Breaking Changes\n\nDue to the nature of type system changes, there are very few changes that can be made that don’t affect _some_ code; however, there are a few changes that are more likely to require adapting existing code.\n\n### [](#libdts-updates)`lib.d.ts` Updates\n\nWhile TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don’t expect major breaks as a result of DOM and `lib.d.ts` updates, but one notable change is that the `cause` property on `Error`s now has the type `unknown` instead of `Error`.\n\n### [](#unconstrained-generics-no-longer-assignable-to-)Unconstrained Generics No Longer Assignable to `{}`\n\nIn TypeScript 4.8, for projects with `strictNullChecks` enabled, TypeScript will now correctly issue an error when an unconstrained type parameter is used in a position where `null` or `undefined` are not legal values. That will include any type that expects `{}`, `object`, or an object type with all-optional properties.\n\nA simple example can be seen in the following.\n\nts\n\n`// Accepts any non-null non-undefined value`\n\n`function bar(value: {}) {`\n\n  `Object.keys(value); // This call throws on null/undefined at runtime.`\n\n`}`\n\n`// Unconstrained type parameter T...`\n\n`function foo<T>(x: T) {`\n\n    `bar(x); // Used to be allowed, now is an error in 4.8.`\n\n    `//  ~`\n\n    `// error: Argument of type 'T' is not assignable to parameter of type '{}'.`\n\n`}`\n\n`foo(undefined);`\n\nAs demonstrated above, code like this has a potential bug - the values `null` and `undefined` can be indirectly passed through these unconstrained type parameters to code that is not supposed to observe those values.\n\nThis behavior will also be visible in type positions. One example would be:\n\nts\n\n`interface Foo<T> {`\n\n  `x: Bar<T>;`\n\n`}`\n\n`interface Bar<T extends {}> { }`\n\nExisting code that didn’t want to handle `null` and `undefined` can be fixed by propagating the appropriate constraints through.\n\ndiff\n\n`- function foo<T>(x: T) {`\n\n`+ function foo<T extends {}>(x: T) {`\n\nAnother work-around would be to check for `null` and `undefined` at runtime.\n\ndiff\n\n  `function foo<T>(x: T) {`\n\n`+     if (x !== null && x !== undefined) {`\n\n          `bar(x);`\n\n`+     }`\n\n  `}`\n\nAnd if you know that for some reason, your generic value can’t be `null` or `undefined`, you can just use a non-null assertion.\n\ndiff\n\n  `function foo<T>(x: T) {`\n\n`-     bar(x);`\n\n`+     bar(x!);`\n\n  `}`\n\nWhen it comes to types, you’ll often either need to propagate constraints, or intersect your types with `{}`.\n\nFor more information, you can [see the change that introduced this](https://github.com/microsoft/TypeScript/pull/49119) along with [the specific discussion issue regarding how unconstrained generics now work](https://github.com/microsoft/TypeScript/issues/49489).\n\n### [](#decorators-are-placed-on-modifiers-on-typescripts-syntax-trees)Decorators are placed on `modifiers` on TypeScript’s Syntax Trees\n\nThe current direction of decorators in TC39 means that TypeScript will have to handle a break in terms of placement of decorators. Previously, TypeScript assumed decorators would always be placed prior to all keywords/modifiers. For example\n\nts\n\n`@decorator`\n\n`export class Foo {`\n\n  `// ...`\n\n`}`\n\nDecorators as currently proposed do not support this syntax. Instead, the `export` keyword must precede the decorator.\n\nts\n\n`export @decorator class Foo {`\n\n  `// ...`\n\n`}`\n\nUnfortunately, TypeScript’s trees are _concrete_ rather than _abstract_, and our architecture expects syntax tree node fields to be entirely ordered before or after each other. To support both legacy decorators and decorators as proposed, TypeScript will have to gracefully parse, and intersperse, modifiers and decorators.\n\nTo do this, it exposes a new type alias called `ModifierLike` which is a `Modifier` or a `Decorator`.\n\nts\n\n`export type ModifierLike = Modifier | Decorator;`\n\nDecorators are now placed in the same field as `modifiers` which is now a `NodeArray<ModifierLike>` when set, and the entire field is deprecated.\n\ndiff\n\n`- readonly modifiers?: NodeArray<Modifier> | undefined;`\n\n`+ /**`\n\n`+  * @deprecated ...`\n\n``+  * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.``\n\n``+  * Use `ts.getModifiers()` to get the modifiers of a `Node`.``\n\n`+  * ...`\n\n`+  */`\n\n`+ readonly modifiers?: NodeArray<ModifierLike> | undefined;`\n\nAll existing `decorators` properties have been marked as deprecated and will always be `undefined` if read. The type has also been changed to `undefined` so that existing tools know to handle them correctly.\n\ndiff\n\n`- readonly decorators?: NodeArray<Decorator> | undefined;`\n\n`+ /**`\n\n`+  * @deprecated ...`\n\n``+  * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.``\n\n``+  * Use `ts.getDecorators()` to get the decorators of a `Node`.``\n\n`+  * ...`\n\n`+  */`\n\n`+ readonly decorators?: undefined;`\n\nTo avoid new deprecation warnings and other issues, TypeScript now exposes four new functions to use in place of the `decorators` and `modifiers` properties. There are individual predicates for testing whether a node has support modifiers and decorators, along with respective accessor functions for grabbing them.\n\nts\n\n`function canHaveModifiers(node: Node): node is HasModifiers;`\n\n`function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;`\n\n`function canHaveDecorators(node: Node): node is HasDecorators;`\n\n`function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;`\n\nAs an example of how to access modifiers off of a node, you can write\n\nts\n\n`const modifiers = canHaveModifiers(myNode) ? getModifiers(myNode) : undefined;`\n\nWith the note that each call to `getModifiers` and `getDecorators` may allocate a new array.\n\nFor more information, see changes around\n\n*   [the restructuring of our tree nodes](https://github.com/microsoft/TypeScript/pull/49089)\n*   [the deprecations](https://github.com/microsoft/TypeScript/pull/50343)\n*   [exposing the predicate functions](https://github.com/microsoft/TypeScript/pull/50399)\n\n### [](#types-cannot-be-importedexported-in-javascript-files)Types Cannot Be Imported/Exported in JavaScript Files\n\nTypeScript previously allowed JavaScript files to import and export entities declared with a type, but no value, in `import` and `export` statements. This behavior was incorrect, because named imports and exports for values that don’t exist will cause a runtime error under ECMAScript modules. When a JavaScript file is type-checked under `--checkJs` or through a `// @ts-check` comment, TypeScript will now issue an error.\n\nts\n\n`// @ts-check`\n\n`// Will fail at runtime because 'SomeType' is not a value.`\n\n`import { someValue, SomeType } from \"some-module\";`\n\n`/**`\n\n `* @type {SomeType}`\n\n `*/`\n\n`export const myValue = someValue;`\n\n`/**`\n\n `* @typedef {string | number} MyType`\n\n `*/`\n\n`// Will fail at runtime because 'MyType' is not a value.`\n\n`export { MyType as MyExportedType };`\n\nTo reference a type from another module, you can instead directly qualify the import.\n\ndiff\n\n`- import { someValue, SomeType } from \"some-module\";`\n\n`+ import { someValue } from \"some-module\";`\n\n  `/**`\n\n`-  * @type {SomeType}`\n\n`+  * @type {import(\"some-module\").SomeType}`\n\n   `*/`\n\n  `export const myValue = someValue;`\n\nTo export a type, you can just use a `/** @typedef */` comment in JSDoc. `@typedef` comments already automatically export types from their containing modules.\n\ndiff\n\n  `/**`\n\n   `* @typedef {string | number} MyType`\n\n   `*/`\n\n`+ /**`\n\n`+  * @typedef {MyType} MyExportedType`\n\n`+  */`\n\n`- export { MyType as MyExportedType };`\n\nYou can [read more about the change here](https://github.com/microsoft/TypeScript/pull/49580).\n\n### [](#binding-patterns-do-not-directly-contribute-to-inference-candidates)Binding Patterns Do Not Directly Contribute to Inference Candidates\n\nAs mentioned above, binding patterns no longer change the type of inference results in function calls. You can [read more about the original change here](https://github.com/microsoft/TypeScript/pull/49086).\n\n### [](#unused-renames-in-binding-patterns-are-now-errors-in-type-signatures)Unused Renames in Binding Patterns are Now Errors in Type Signatures\n\nTypeScript’s type annotation syntax often looks like it can be used when destructuring values. For example, take the following function.\n\nts\n\n`declare function makePerson({ name: string, age: number }): Person;`\n\nYou might read this signature and think that `makePerson` obviously takes an object with a `name` property with the type `string` and an `age` property with the type `number`; however, JavaScript’s destructuring syntax is actually taking precedence here. `makePerson` does say that it’s going to take an object with a `name` and an `age` property, but instead of specifying a type for them, it’s just saying that it renames `name` and `age` to `string` and `number` respectively.\n\nIn a pure type construct, writing code like this is useless, and typically a mistake since developers usually assume they’re writing a type annotation.\n\nTypeScript 4.8 makes these an error unless they’re referenced later in the signature. The correct way to write the above signature would be as follows:\n\nts\n\n`declare function makePerson(options: { name: string, age: number }): Person;`\n\n`// or`\n\n`declare function makePerson({ name, age }: { name: string, age: number }): Person;`\n\nThis change can catch bugs in declarations, and has been helpful for improving existing code. We’d like to extend our thanks to [GitHub user uhyo](https://github.com/uhyo) for providing this check. [You can read up on the change here](https://github.com/microsoft/TypeScript/pull/41044).",
    "title": "TypeScript: Documentation - TypeScript 4.8",
    "description": "TypeScript 4.8 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.3\n\n## [](#improved-behavior-for-calling-union-types)Improved behavior for calling union types\n\nIn prior versions of TypeScript, unions of callable types could _only_ be invoked if they had identical parameter lists.\n\nts\n\n`type Fruit = \"apple\" | \"orange\";`\n\n`type Color = \"red\" | \"orange\";`\n\n`type FruitEater = (fruit: Fruit) => number; // eats and ranks the fruit`\n\n`type ColorConsumer = (color: Color) => string; // consumes and describes the colors`\n\n`declare let f: FruitEater | ColorConsumer;`\n\n`// Cannot invoke an expression whose type lacks a call signature.`\n\n`//   Type 'FruitEater | ColorConsumer' has no compatible call signatures.ts(2349)`\n\n`f(\"orange\");`\n\nHowever, in the above example, both `FruitEater`s and `ColorConsumer`s should be able to take the string `\"orange\"`, and return either a `number` or a `string`.\n\nIn TypeScript 3.3, this is no longer an error.\n\nts\n\n`type Fruit = \"apple\" | \"orange\";`\n\n`type Color = \"red\" | \"orange\";`\n\n`type FruitEater = (fruit: Fruit) => number; // eats and ranks the fruit`\n\n`type ColorConsumer = (color: Color) => string; // consumes and describes the colors`\n\n`declare let f: FruitEater | ColorConsumer;`\n\n`f(\"orange\"); // It works! Returns a 'number | string'.`\n\n`f(\"apple\"); // error - Argument of type '\"apple\"' is not assignable to parameter of type '\"orange\"'.`\n\n`f(\"red\"); // error - Argument of type '\"red\"' is not assignable to parameter of type '\"orange\"'.`\n\nIn TypeScript 3.3, the parameters of these signatures are _intersected_ together to create a new signature.\n\nIn the example above, the parameters `fruit` and `color` are intersected together to a new parameter of type `Fruit & Color`. `Fruit & Color` is really the same as `(\"apple\" | \"orange\") & (\"red\" | \"orange\")` which is equivalent to `(\"apple\" & \"red\") | (\"apple\" & \"orange\") | (\"orange\" & \"red\") | (\"orange\" & \"orange\")`. Each of those impossible intersections reduces to `never`, and we’re left with `\"orange\" & \"orange\"` which is just `\"orange\"`.\n\n## [](#caveats)Caveats\n\nThis new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on `number[] | string[]` like `map` (which is generic) still won’t be callable.\n\nOn the other hand, methods like `forEach` will now be callable, but under [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) there may be some issues.\n\nts\n\n`interface Dog {`\n\n  `kind: \"dog\";`\n\n  `dogProp: any;`\n\n`}`\n\n`interface Cat {`\n\n  `kind: \"cat\";`\n\n  `catProp: any;`\n\n`}`\n\n`const catOrDogArray: Dog[] | Cat[] = [];`\n\n`catOrDogArray.forEach(animal => {`\n\n  `//                ~~~~~~ error!`\n\n  `// Parameter 'animal' implicitly has an 'any' type.`\n\n`});`\n\nThis is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.\n\nts\n\n`interface Dog {`\n\n  `kind: \"dog\";`\n\n  `dogProp: any;`\n\n`}`\n\n`interface Cat {`\n\n  `kind: \"cat\";`\n\n  `catProp: any;`\n\n`}`\n\n`const catOrDogArray: Dog[] | Cat[] = [];`\n\n`catOrDogArray.forEach((animal: Dog | Cat) => {`\n\n  `if (animal.kind === \"dog\") {`\n\n    `animal.dogProp;`\n\n    `// ...`\n\n  `} else if (animal.kind === \"cat\") {`\n\n    `animal.catProp;`\n\n    `// ...`\n\n  `}`\n\n`});`\n\n## [](#incremental-file-watching-for-composite-projects-in---build---watch)Incremental file watching for composite projects in `--build --watch`\n\nTypeScript 3.0 introduced a new feature for structuring builds called “composite projects”. Part of the goal here was to ensure users could break up large projects into smaller parts that build quickly and preserve project structure, without compromising the existing TypeScript experience. Thanks to composite projects, TypeScript can use `--build` mode to recompile only the set of projects and dependencies. You can think of this as optimizing _inter_\\-project builds.\n\nTypeScript 2.7 also introduced `--watch` mode builds via a new incremental “builder” API. In a similar vein, the entire idea is that this mode only re-checks and re-emits changed files or files whose dependencies might impact type-checking. You can think of this as optimizing _intra_\\-project builds.\n\nPrior to 3.3, building composite projects using `--build --watch` actually didn’t use this incremental file watching infrastructure. An update in one project under `--build --watch` mode would force a full build of that project, rather than determining which files within that project were affected.\n\nIn TypeScript 3.3, `--build` mode’s `--watch` flag _does_ leverage incremental file watching as well. That can mean significantly faster builds under `--build --watch`. In our testing, this functionality has resulted in **a reduction of 50% to 75% in build times** of the original `--build --watch` times. [You can read more on the original pull request for the change](https://github.com/Microsoft/TypeScript/pull/29161) to see specific numbers, but we believe most composite project users will see significant wins here.",
    "title": "TypeScript: Documentation - TypeScript 3.3",
    "description": "TypeScript 3.3 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.5\n\n## [](#speed-improvements)Speed improvements\n\nTypeScript 3.5 introduces several optimizations around type-checking and incremental builds.\n\n### [](#type-checking-speed-ups)Type-checking speed-ups\n\nTypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently. These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.\n\n### [](#--incremental-improvements)`--incremental` improvements\n\nTypeScript 3.5 improves on 3.4’s [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc. In scenarios involving hundreds of projects using TypeScript’s project references in `--build` mode, [we’ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4](https://github.com/Microsoft/TypeScript/pull/31101)!\n\nFor more details, you can see the pull requests to\n\n*   [cache module resolution](https://github.com/Microsoft/TypeScript/pull/31100)\n*   [cache settings calculated from `tsconfig.json`](https://github.com/Microsoft/TypeScript/pull/31101)\n\n## [](#the-omit-helper-type)The `Omit` helper type\n\nTypeScript 3.5 introduces the new `Omit` helper type, which creates a new type with some properties dropped from the original.\n\nts\n\n`type Person = {`\n\n  `name: string;`\n\n  `age: number;`\n\n  `location: string;`\n\n`};`\n\n`type QuantumPerson = Omit<Person, \"location\">;`\n\n`// equivalent to`\n\n`type QuantumPerson = {`\n\n  `name: string;`\n\n  `age: number;`\n\n`};`\n\nHere we were able to copy over all the properties of `Person` except for `location` using the `Omit` helper.\n\nFor more details, [see the pull request on GitHub to add `Omit`](https://github.com/Microsoft/TypeScript/pull/30552), as well as [the change to use `Omit` for object rest](https://github.com/microsoft/TypeScript/pull/31134).\n\n### [](#improved-excess-property-checks-in-union-types)Improved excess property checks in union types\n\nIn TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn’t have been. For instance, TypeScript 3.4 permitted the incorrect `name` property in the object literal even though its types don’t match between `Point` and `Label`.\n\nts\n\n`type Point = {`\n\n  `x: number;`\n\n  `y: number;`\n\n`};`\n\n`type Label = {`\n\n  `name: string;`\n\n`};`\n\n`const thing: Point | Label = {`\n\n  `x: 0,`\n\n  `y: 0,`\n\n  `name: true // uh-oh!`\n\n`};`\n\nPreviously, a non-disciminated union wouldn’t have _any_ excess property checking done on its members, and as a result, the incorrectly typed `name` property slipped by.\n\nIn TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to _some_ union member and have the appropriate type, meaning that the sample above correctly issues an error.\n\nNote that partial overlap is still permitted as long as the property types are valid.\n\nts\n\n`const pl: Point | Label = {`\n\n  `x: 0,`\n\n  `y: 0,`\n\n  `name: \"origin\" // okay`\n\n`};`\n\n## [](#the---allowumdglobalaccess-flag)The `--allowUmdGlobalAccess` flag\n\nIn TypeScript 3.5, you can now reference UMD global declarations like\n\n`export as namespace foo;`\n\nfrom anywhere - even modules - using the new [`allowUmdGlobalAccess`](https://www.typescriptlang.org/tsconfig#allowUmdGlobalAccess) flag.\n\nThis mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.\n\nFor more details, [see the pull request on GitHub](https://github.com/Microsoft/TypeScript/pull/30776/files).\n\n## [](#smarter-union-type-checking)Smarter union type checking\n\nIn TypeScript 3.4 and prior, the following example would fail:\n\nts\n\n`type S = { done: boolean; value: number };`\n\n`type T = { done: false; value: number } | { done: true; value: number };`\n\n`declare let source: S;`\n\n`declare let target: T;`\n\n`target = source;`\n\nThat’s because `S` isn’t assignable to `{ done: false, value: number }` nor `{ done: true, value: number }`. Why? Because the `done` property in `S` isn’t specific enough - it’s `boolean` whereas each constituent of `T` has a `done` property that’s specifically `true` or `false`. That’s what we meant by each constituent type being checked in isolation: TypeScript doesn’t just union each property together and see if `S` is assignable to that. If it did, some bad code could get through like the following:\n\nts\n\n`interface Foo {`\n\n  `kind: \"foo\";`\n\n  `value: string;`\n\n`}`\n\n`interface Bar {`\n\n  `kind: \"bar\";`\n\n  `value: number;`\n\n`}`\n\n`function doSomething(x: Foo | Bar) {`\n\n  `if (x.kind === \"foo\") {`\n\n    `x.value.toLowerCase();`\n\n  `}`\n\n`}`\n\n`// uh-oh - luckily TypeScript errors here!`\n\n`doSomething({`\n\n  `kind: \"foo\",`\n\n  `value: 123`\n\n`});`\n\nHowever, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of `S`, you can actually see that it matches the types in `T` exactly.\n\nIn TypeScript 3.5, when assigning to types with discriminant properties like in `T`, the language actually _will_ go further and decompose types like `S` into a union of every possible inhabitant type. In this case, since `boolean` is a union of `true` and `false`, `S` will be viewed as a union of `{ done: false, value: number }` and `{ done: true, value: number }`.\n\nFor more details, you can [see the original pull request on GitHub](https://github.com/microsoft/TypeScript/pull/30779).\n\n## [](#higher-order-type-inference-from-generic-constructors)Higher order type inference from generic constructors\n\nIn TypeScript 3.4, we improved inference for when generic functions that return functions like so:\n\nts\n\n`function compose<T, U, V>(f: (x: T) => U, g: (y: U) => V): (x: T) => V {`\n\n  `return x => g(f(x));`\n\n`}`\n\ntook other generic functions as arguments, like so:\n\nts\n\n`function arrayify<T>(x: T): T[] {`\n\n  `return [x];`\n\n`}`\n\n`type Box<U> = { value: U };`\n\n`function boxify<U>(y: U): Box<U> {`\n\n  `return { value: y };`\n\n`}`\n\n`let newFn = compose(arrayify, boxify);`\n\nInstead of a relatively useless type like `(x: {}) => Box<{}[]>`, which older versions of the language would infer, TypeScript 3.4’s inference allows `newFn` to be generic. Its new type is `<T>(x: T) => Box<T[]>`.\n\nTypeScript 3.5 generalizes this behavior to work on constructor functions as well.\n\nts\n\n`class Box<T> {`\n\n  `kind: \"box\";`\n\n  `value: T;`\n\n  `constructor(value: T) {`\n\n    `this.value = value;`\n\n  `}`\n\n`}`\n\n`class Bag<U> {`\n\n  `kind: \"bag\";`\n\n  `value: U;`\n\n  `constructor(value: U) {`\n\n    `this.value = value;`\n\n  `}`\n\n`}`\n\n`function composeCtor<T, U, V>(`\n\n  `F: new (x: T) => U,`\n\n  `G: new (y: U) => V`\n\n`): (x: T) => V {`\n\n  `return x => new G(new F(x));`\n\n`}`\n\n`let f = composeCtor(Box, Bag); // has type '<T>(x: T) => Bag<Box<T>>'`\n\n`let a = f(1024); // has type 'Bag<Box<number>>'`\n\nIn addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.\n\nts\n\n`type ComponentClass<P> = new (props: P) => Component<P>;`\n\n`declare class Component<P> {`\n\n  `props: P;`\n\n  `constructor(props: P);`\n\n`}`\n\n`declare function myHoc<P>(C: ComponentClass<P>): ComponentClass<P>;`\n\n`type NestedProps<T> = { foo: number; stuff: T };`\n\n`declare class GenericComponent<T> extends Component<NestedProps<T>> {}`\n\n`// type is 'new <T>(props: NestedProps<T>) => Component<NestedProps<T>>'`\n\n`const GenericComponent2 = myHoc(GenericComponent);`\n\nTo learn more, [check out the original pull request on GitHub](https://github.com/microsoft/TypeScript/pull/31116).",
    "title": "TypeScript: Documentation - TypeScript 3.5",
    "description": "TypeScript 3.5 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.6\n\n## [](#stricter-generators)Stricter Generators\n\nTypeScript 3.6 introduces stricter checking for iterators and generator functions. In earlier versions, users of generators had no way to differentiate whether a value was yielded or returned from a generator.\n\nts\n\n`function* foo() {`\n\n  `if (Math.random() < 0.5) yield 100;`\n\n  `return \"Finished!\";`\n\n`}`\n\n`let iter = foo();`\n\n`let curr = iter.next();`\n\n`if (curr.done) {`\n\n  `// TypeScript 3.5 and prior thought this was a 'string | number'.`\n\n  `// It should know it's 'string' since 'done' was 'true'!`\n\n  `curr.value;`\n\n`}`\n\nAdditionally, generators just assumed the type of `yield` was always `any`.\n\nts\n\n`function* bar() {`\n\n  `let x: { hello(): void } = yield;`\n\n  `x.hello();`\n\n`}`\n\n`let iter = bar();`\n\n`iter.next();`\n\n`iter.next(123); // oops! runtime error!`\n\nIn TypeScript 3.6, the checker now knows that the correct type for `curr.value` should be `string` in our first example, and will correctly error on our call to `next()` in our last example. This is thanks to some changes in the `Iterator` and `IteratorResult` type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the `Generator` type.\n\nThe `Iterator` type now allows users to specify the yielded type, the returned type, and the type that `next` can accept.\n\nts\n\n`interface Iterator<T, TReturn = any, TNext = undefined> {`\n\n  `// Takes either 0 or 1 arguments - doesn't accept 'undefined'`\n\n  `next(...args: [] | [TNext]): IteratorResult<T, TReturn>;`\n\n  `return?(value?: TReturn): IteratorResult<T, TReturn>;`\n\n  `throw?(e?: any): IteratorResult<T, TReturn>;`\n\n`}`\n\nBuilding on that work, the new `Generator` type is an `Iterator` that always has both the `return` and `throw` methods present, and is also iterable.\n\nts\n\n`interface Generator<T = unknown, TReturn = any, TNext = unknown>`\n\n  `extends Iterator<T, TReturn, TNext> {`\n\n  `next(...args: [] | [TNext]): IteratorResult<T, TReturn>;`\n\n  `return(value: TReturn): IteratorResult<T, TReturn>;`\n\n  `throw(e: any): IteratorResult<T, TReturn>;`\n\n  `[Symbol.iterator](): Generator<T, TReturn, TNext>;`\n\n`}`\n\nTo allow differentiation between returned values and yielded values, TypeScript 3.6 converts the `IteratorResult` type to a discriminated union type:\n\nts\n\n`type IteratorResult<T, TReturn = any> =`\n\n  `| IteratorYieldResult<T>`\n\n  `| IteratorReturnResult<TReturn>;`\n\n`interface IteratorYieldResult<TYield> {`\n\n  `done?: false;`\n\n  `value: TYield;`\n\n`}`\n\n`interface IteratorReturnResult<TReturn> {`\n\n  `done: true;`\n\n  `value: TReturn;`\n\n`}`\n\nIn short, what this means is that you’ll be able to appropriately narrow down values from iterators when dealing with them directly.\n\nTo correctly represent the types that can be passed in to a generator from calls to `next()`, TypeScript 3.6 also infers certain uses of `yield` within the body of a generator function.\n\nts\n\n`function* foo() {`\n\n  `let x: string = yield;`\n\n  `console.log(x.toUpperCase());`\n\n`}`\n\n`let x = foo();`\n\n`x.next(); // first call to 'next' is always ignored`\n\n`x.next(42); // error! 'number' is not assignable to 'string'`\n\nIf you’d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from `yield` expressions using an explicit return type. Below, `next()` can only be called with `boolean`s, and depending on the value of `done`, `value` is either a `string` or a `number`.\n\nts\n\n`/**`\n\n `* - yields numbers`\n\n `* - returns strings`\n\n `* - can be passed in booleans`\n\n `*/`\n\n`function* counter(): Generator<number, string, boolean> {`\n\n  `let i = 0;`\n\n  `while (true) {`\n\n    `if (yield i++) {`\n\n      `break;`\n\n    `}`\n\n  `}`\n\n  `return \"done!\";`\n\n`}`\n\n`var iter = counter();`\n\n`var curr = iter.next();`\n\n`while (!curr.done) {`\n\n  `console.log(curr.value);`\n\n  `curr = iter.next(curr.value === 5);`\n\n`}`\n\n`console.log(curr.value.toUpperCase());`\n\n`// prints:`\n\n`//`\n\n`// 0`\n\n`// 1`\n\n`// 2`\n\n`// 3`\n\n`// 4`\n\n`// 5`\n\n`// DONE!`\n\nFor more details on the change, [see the pull request here](https://github.com/Microsoft/TypeScript/issues/2983).\n\n## [](#more-accurate-array-spread)More Accurate Array Spread\n\nIn pre-ES2015 targets, the most faithful emit for constructs like `for`/`of` loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration) flag. The looser default without [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration) works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread\n\nts\n\n`[...Array(5)];`\n\ncan be rewritten as the following array literal\n\njs\n\n`[undefined, undefined, undefined, undefined, undefined];`\n\nHowever, TypeScript would instead transform the original code into this code:\n\nts\n\n`Array(5).slice();`\n\nwhich is slightly different. `Array(5)` produces an array with a length of 5, but with no defined property slots.\n\nTypeScript 3.6 introduces a new `__spreadArrays` helper to accurately model what happens in ECMAScript 2015 in older targets outside of [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration). `__spreadArrays` is also available in [tslib](https://github.com/Microsoft/tslib/).\n\nFor more information, [see the relevant pull request](https://github.com/microsoft/TypeScript/pull/31166).\n\n## [](#improved-ux-around-promises)Improved UX Around Promises\n\nTypeScript 3.6 introduces some improvements for when `Promise`s are mis-handled.\n\nFor example, it’s often very common to forget to `.then()` or `await` the contents of a `Promise` before passing it to another function. TypeScript’s error messages are now specialized, and inform the user that perhaps they should consider using the `await` keyword.\n\nts\n\n`interface User {`\n\n  `name: string;`\n\n  `age: number;`\n\n  `location: string;`\n\n`}`\n\n`declare function getUserData(): Promise<User>;`\n\n`declare function displayUser(user: User): void;`\n\n`async function f() {`\n\n  `displayUser(getUserData());`\n\n  `//              ~~~~~~~~~~~~~`\n\n  `// Argument of type 'Promise<User>' is not assignable to parameter of type 'User'.`\n\n  `//   ...`\n\n  `// Did you forget to use 'await'?`\n\n`}`\n\nIt’s also common to try to access a method before `await`\\-ing or `.then()`\\-ing a `Promise`. This is another example, among many others, where we’re able to do better.\n\nts\n\n`async function getCuteAnimals() {`\n\n  `fetch(\"https://reddit.com/r/aww.json\").json();`\n\n  `//   ~~~~`\n\n  `// Property 'json' does not exist on type 'Promise<Response>'.`\n\n  `//`\n\n  `// Did you forget to use 'await'?`\n\n`}`\n\nFor more details, [see the originating issue](https://github.com/microsoft/TypeScript/issues/30646), as well as the pull requests that link back to it.\n\n## [](#better-unicode-support-for-identifiers)Better Unicode Support for Identifiers\n\nTypeScript 3.6 contains better support for Unicode characters in identifiers when emitting to ES2015 and later targets.\n\nts\n\n`const 𝓱𝓮𝓵𝓵𝓸 = \"world\"; // previously disallowed, now allowed in '--target es2015'`\n\nTypeScript 3.6 supports transforming `import.meta` to `context.meta` when your `module` target is set to `system`.\n\nts\n\n`// This module:`\n\n`console.log(import.meta.url);`\n\n`// gets turned into the following:`\n\n`System.register([], function (exports, context) {`\n\n  `return {`\n\n    `setters: [],`\n\n    `execute: function () {`\n\n      `console.log(context.meta.url);`\n\n    `},`\n\n  `};`\n\n`});`\n\n## [](#get-and-set-accessors-are-allowed-in-ambient-contexts)`get` and `set` Accessors Are Allowed in Ambient Contexts\n\nIn previous versions of TypeScript, the language didn’t allow `get` and `set` accessors in ambient contexts (like in `declare`\\-d classes, or in `.d.ts` files in general). The rationale was that accessors weren’t distinct from properties as far as writing and reading to these properties; however, [because ECMAScript’s class fields proposal may have differing behavior from in existing versions of TypeScript](https://github.com/tc39/proposal-class-fields/issues/248), we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.\n\nAs a result, users can write getters and setters in ambient contexts in TypeScript 3.6.\n\nts\n\n`declare class Foo {`\n\n  `// Allowed in 3.6+.`\n\n  `get x(): number;`\n\n  `set x(val: number);`\n\n`}`\n\nIn TypeScript 3.7, the compiler itself will take advantage of this feature so that generated `.d.ts` files will also emit `get`/`set` accessors.\n\n## [](#ambient-classes-and-functions-can-merge)Ambient Classes and Functions Can Merge\n\nIn previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the `declare` modifier, or in `.d.ts` files) can merge. This means that now you can write the following:\n\nts\n\n`export declare function Point2D(x: number, y: number): Point2D;`\n\n`export declare class Point2D {`\n\n  `x: number;`\n\n  `y: number;`\n\n  `constructor(x: number, y: number);`\n\n`}`\n\ninstead of needing to use\n\nts\n\n`export interface Point2D {`\n\n  `x: number;`\n\n  `y: number;`\n\n`}`\n\n`export declare var Point2D: {`\n\n  `(x: number, y: number): Point2D;`\n\n  `new (x: number, y: number): Point2D;`\n\n`};`\n\nOne advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since `var` declarations can’t merge with `namespace`s).\n\nIn TypeScript 3.7, the compiler will take advantage of this feature so that `.d.ts` files generated from `.js` files can appropriately capture both the callability and constructability of a class-like function.\n\nFor more details, [see the original PR on GitHub](https://github.com/microsoft/TypeScript/pull/32584).\n\n## [](#apis-to-support---build-and---incremental)APIs to Support `--build` and `--incremental`\n\nTypeScript 3.0 introduced support for referencing other projects and building them incrementally using the `--build` flag. Additionally, TypeScript 3.4 introduced the [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) flag for saving information about previous compilations to only rebuild certain files. These flags were incredibly useful for structuring projects more flexibly and speeding builds up. Unfortunately, using these flags didn’t work with 3rd party build tools like Gulp and Webpack. TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.\n\nFor creating [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) builds, users can leverage the `createIncrementalProgram` and `createIncrementalCompilerHost` APIs. Users can also re-hydrate old program instances from `.tsbuildinfo` files generated by this API using the newly exposed `readBuilderProgram` function, which is only meant to be used as for creating new programs (i.e. you can’t modify the returned instance - it’s only meant to be used for the `oldProgram` parameter in other `create*Program` functions).\n\nFor leveraging project references, a new `createSolutionBuilder` function has been exposed, which returns an instance of the new type `SolutionBuilder`.\n\nFor more details on these APIs, you can [see the original pull request](https://github.com/microsoft/TypeScript/pull/31432).\n\n## [](#semicolon-aware-code-edits)Semicolon-Aware Code Edits\n\nEditors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users’ style guidelines, and many users were displeased with the editor inserting semicolons.\n\nTypeScript is now smart enough to detect whether your file uses semicolons when applying these sorts of edits. If your file generally lacks semicolons, TypeScript won’t add one.\n\nFor more details, [see the corresponding pull request](https://github.com/microsoft/TypeScript/pull/31801).\n\n## [](#smarter-auto-import-syntax)Smarter Auto-Import Syntax\n\nJavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and `require` calls.\n\nTypeScript 3.6 is now a bit smarter about looking at your existing imports before deciding on how to auto-import other modules. You can [see more details in the original pull request here](https://github.com/microsoft/TypeScript/pull/32684).\n\n## [](#new-typescript-playground)New TypeScript Playground\n\nThe TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of [Artem Tyurin](https://github.com/agentcooper)’s [TypeScript playground](https://github.com/agentcooper/typescript-play) which community members have been using more and more. We owe Artem a big thanks for helping out here!\n\nThe new playground now supports many new options including:\n\n*   The [`target`](https://www.typescriptlang.org/tsconfig#target) option (allowing users to switch out of `es5` to `es3`, `es2015`, `esnext`, etc.)\n*   All the strictness flags (including just [`strict`](https://www.typescriptlang.org/tsconfig#strict))\n*   Support for plain JavaScript files (using `allowJS` and optionally [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs))\n\nThese options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient “oh, don’t forget to turn on the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) option!“.\n\nIn the near future, we’re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you’ll be able to see the same experience on the playground as you’d get in your personal editor.\n\nAs we improve the playground and the website, [we welcome feedback and pull requests on GitHub](https://github.com/microsoft/TypeScript-Website/)!",
    "title": "TypeScript: Documentation - TypeScript 3.6",
    "description": "TypeScript 3.6 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.4\n\n## [](#faster-subsequent-builds-with-the---incremental-flag)Faster subsequent builds with the `--incremental` flag\n\nTypeScript 3.4 introduces a new flag called [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) which tells TypeScript to save information about the project graph from the last compilation. The next time TypeScript is invoked with [`incremental`](https://www.typescriptlang.org/tsconfig#incremental), it will use that information to detect the least costly way to type-check and emit changes to your project.\n\n`// tsconfig.json`\n\n`{`\n\n  `\"\": {`\n\n    `\"\": true,`\n\n    `\"\": \"./lib\"`\n\n  `},`\n\n  `\"\": [\"./src\"]`\n\n`}`\n\nBy default with these settings, when we run `tsc`, TypeScript will look for a file called `.tsbuildinfo` in the output directory (`./lib`). If `./lib/.tsbuildinfo` doesn’t exist, it’ll be generated. But if it does, `tsc` will try to use that file to incrementally type-check and update our output files.\n\nThese `.tsbuildinfo` files can be safely deleted and don’t have any impact on our code at runtime - they’re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the [`tsBuildInfoFile`](https://www.typescriptlang.org/tsconfig#tsBuildInfoFile) option.\n\n`// front-end.tsconfig.json`\n\n`{`\n\n  `\"\": {`\n\n    `\"\": true,`\n\n    `\"\": \"./buildcache/front-end\",`\n\n    `\"\": \"./lib\"`\n\n  `},`\n\n  `\"\": [\"./src\"]`\n\n`}`\n\n### [](#composite-projects)Composite projects\n\nPart of the intent with composite projects (`tsconfig.json`s with [`composite`](https://www.typescriptlang.org/tsconfig#composite) set to `true`) is that references between different projects can be built incrementally. As such, composite projects will **always** produce `.tsbuildinfo` files.\n\n### [](#outfile)`outFile`\n\nWhen [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) is used, the build information file’s name will be based on the output file’s name. As an example, if our output JavaScript file is `./output/foo.js`, then under the [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) flag, TypeScript will generate the file `./output/foo.tsbuildinfo`. As above, this can be controlled with the [`tsBuildInfoFile`](https://www.typescriptlang.org/tsconfig#tsBuildInfoFile) option.\n\n## [](#higher-order-type-inference-from-generic-functions)Higher order type inference from generic functions\n\nTypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences. This means many function composition patterns now work better in 3.4.\n\nTo get more specific, let’s build up some motivation and consider the following `compose` function:\n\nts\n\n`function compose<A, B, C>(f: (arg: A) => B, g: (arg: B) => C): (arg: A) => C {`\n\n  `return (x) => g(f(x));`\n\n`}`\n\n`compose` takes two other functions:\n\n*   `f` which takes some argument (of type `A`) and returns a value of type `B`\n*   `g` which takes an argument of type `B` (the type `f` returned), and returns a value of type `C`\n\n`compose` then returns a function which feeds its argument through `f` and then `g`.\n\nWhen calling this function, TypeScript will try to figure out the types of `A`, `B`, and `C` through a process called _type argument inference_. This inference process usually works pretty well:\n\nts\n\n`interface Person {`\n\n  `name: string;`\n\n  `age: number;`\n\n`}`\n\n`function getDisplayName(p: Person) {`\n\n  `return p.name.toLowerCase();`\n\n`}`\n\n`function getLength(s: string) {`\n\n  `return s.length;`\n\n`}`\n\n`// has type '(p: Person) => number'`\n\n`const getDisplayNameLength = compose(getDisplayName, getLength);`\n\n`// works and returns the type 'number'`\n\n`getDisplayNameLength({ name: \"Person McPersonface\", age: 42 });`\n\nThe inference process is fairly straightforward here because `getDisplayName` and `getLength` use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like `compose` didn’t work so well when passed other generic functions.\n\nts\n\n`interface Box<T> {`\n\n  `value: T;`\n\n`}`\n\n`function makeArray<T>(x: T): T[] {`\n\n  `return [x];`\n\n`}`\n\n`function makeBox<U>(value: U): Box<U> {`\n\n  `return { value };`\n\n`}`\n\n`// has type '(arg: {}) => Box<{}[]>'`\n\n`const makeBoxedArray = compose(makeArray, makeBox);`\n\n`makeBoxedArray(\"hello!\").value[0].toUpperCase();`\n\n`//                                ~~~~~~~~~~~`\n\n`// error: Property 'toUpperCase' does not exist on type '{}'.`\n\nIn older versions, TypeScript would infer the empty object type (`{}`) when inferring from other type variables like `T` and `U`.\n\nDuring type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript _will_, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.\n\nIn other words, instead of producing the type\n\nts\n\n`(arg: {}) => Box<{}[]>`\n\nTypeScript 3.4 produces the type\n\nts\n\n`<T>(arg: T) => Box<T[]>`\n\nNotice that `T` has been propagated from `makeArray` into the resulting type’s type parameter list. This means that genericity from `compose`’s arguments has been preserved and our `makeBoxedArray` sample will just work!\n\nts\n\n`interface Box<T> {`\n\n  `value: T;`\n\n`}`\n\n`function makeArray<T>(x: T): T[] {`\n\n  `return [x];`\n\n`}`\n\n`function makeBox<U>(value: U): Box<U> {`\n\n  `return { value };`\n\n`}`\n\n`// has type '<T>(arg: T) => Box<T[]>'`\n\n`const makeBoxedArray = compose(makeArray, makeBox);`\n\n`// works with no problem!`\n\n`makeBoxedArray(\"hello!\").value[0].toUpperCase();`\n\nFor more details, you can [read more at the original change](https://github.com/Microsoft/TypeScript/pull/30215).\n\n## [](#improvements-for-readonlyarray-and-readonly-tuples)Improvements for `ReadonlyArray` and `readonly` tuples\n\nTypeScript 3.4 makes it a little bit easier to use read-only array-like types.\n\n### [](#a-new-syntax-for-readonlyarray)A new syntax for `ReadonlyArray`\n\nThe `ReadonlyArray` type describes `Array`s that can only be read from. Any variable with a reference to a `ReadonlyArray` can’t add, remove, or replace any elements of the array.\n\nts\n\n`function foo(arr: ReadonlyArray<string>) {`\n\n  `arr.slice(); // okay`\n\n  `arr.push(\"hello!\"); // error!`\n\n`}`\n\nWhile it’s good practice to use `ReadonlyArray` over `Array` when no mutation is intended, it’s often been a pain given that arrays have a nicer syntax. Specifically, `number[]` is a shorthand version of `Array<number>`, just as `Date[]` is a shorthand for `Array<Date>`.\n\nTypeScript 3.4 introduces a new syntax for `ReadonlyArray` using a new `readonly` modifier for array types.\n\nts\n\n`function foo(arr: readonly string[]) {`\n\n  `arr.slice(); // okay`\n\n  `arr.push(\"hello!\"); // error!`\n\n`}`\n\n### [](#readonly-tuples)`readonly` tuples\n\nTypeScript 3.4 also introduces new support for `readonly` tuples. We can prefix any tuple type with the `readonly` keyword to make it a `readonly` tuple, much like we now can with array shorthand syntax. As you might expect, unlike ordinary tuples whose slots could be written to, `readonly` tuples only permit reading from those positions.\n\nts\n\n`function foo(pair: readonly [string, string]) {`\n\n  `console.log(pair[0]); // okay`\n\n  `pair[1] = \"hello!\"; // error`\n\n`}`\n\nThe same way that ordinary tuples are types that extend from `Array` - a tuple with elements of type `T1`, `T2`, … `Tn` extends from `Array< T1 | T2 | … Tn >` - `readonly` tuples are types that extend from `ReadonlyArray`. So a `readonly` tuple with elements `T1`, `T2`, … `Tn` extends from `ReadonlyArray< T1 | T2 | … Tn`.\n\n### [](#readonly-mapped-type-modifiers-and-readonly-arrays)`readonly` mapped type modifiers and `readonly` arrays\n\nIn earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like `Boxify` could work on arrays and tuples alike.\n\nts\n\n`interface Box<T> {`\n\n  `value: T;`\n\n`}`\n\n`type Boxify<T> = {`\n\n  `[K in keyof T]: Box<T[K]>;`\n\n`};`\n\n`// { a: Box<string>, b: Box<number> }`\n\n`type A = Boxify<{ a: string; b: number }>;`\n\n`// Array<Box<number>>`\n\n`type B = Boxify<number[]>;`\n\n`// [Box<string>, Box<number>]`\n\n`type C = Boxify<[string, boolean]>;`\n\nUnfortunately, mapped types like the `Readonly` utility type were effectively no-ops on array and tuple types.\n\nts\n\n`// lib.d.ts`\n\n`type Readonly<T> = {`\n\n  `readonly [K in keyof T]: T[K];`\n\n`};`\n\n`// How code acted *before* TypeScript 3.4`\n\n`// { readonly a: string, readonly b: number }`\n\n`type A = Readonly<{ a: string; b: number }>;`\n\n`// number[]`\n\n`type B = Readonly<number[]>;`\n\n`// [string, boolean]`\n\n`type C = Readonly<[string, boolean]>;`\n\nIn TypeScript 3.4, the `readonly` modifier in a mapped type will automatically convert array-like types to their corresponding `readonly` counterparts.\n\nts\n\n`// How code acts now *with* TypeScript 3.4`\n\n`// { readonly a: string, readonly b: number }`\n\n`type A = Readonly<{ a: string; b: number }>;`\n\n`// readonly number[]`\n\n`type B = Readonly<number[]>;`\n\n`// readonly [string, boolean]`\n\n`type C = Readonly<[string, boolean]>;`\n\nSimilarly, you could write a utility type like `Writable` mapped type that strips away `readonly`\\-ness, and that would convert `readonly` array containers back to their mutable equivalents.\n\nts\n\n`type Writable<T> = {`\n\n  `-readonly [K in keyof T]: T[K];`\n\n`};`\n\n`// { a: string, b: number }`\n\n`type A = Writable<{`\n\n  `readonly a: string;`\n\n  `readonly b: number;`\n\n`}>;`\n\n`// number[]`\n\n`type B = Writable<readonly number[]>;`\n\n`// [string, boolean]`\n\n`type C = Writable<readonly [string, boolean]>;`\n\n### [](#caveats)Caveats\n\nDespite its appearance, the `readonly` type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.\n\nts\n\n`let err1: readonly Set<number>; // error!`\n\n`let err2: readonly Array<boolean>; // error!`\n\n`let okay: readonly boolean[]; // works fine`\n\nYou can [see more details in the pull request](https://github.com/Microsoft/TypeScript/pull/29435).\n\n## [](#const-assertions)`const` assertions\n\nTypeScript 3.4 introduces a new construct for literal values called _`const`_ assertions. Its syntax is a type assertion with `const` in place of the type name (e.g. `123 as const`). When we construct new literal expressions with `const` assertions, we can signal to the language that\n\n*   no literal types in that expression should be widened (e.g. no going from `\"hello\"` to `string`)\n*   object literals get `readonly` properties\n*   array literals become `readonly` tuples\n\nts\n\n`// Type '\"hello\"'`\n\n`let x = \"hello\" as const;`\n\n`// Type 'readonly [10, 20]'`\n\n`let y = [10, 20] as const;`\n\n`// Type '{ readonly text: \"hello\" }'`\n\n`let z = { text: \"hello\" } as const;`\n\nOutside of `.tsx` files, the angle bracket assertion syntax can also be used.\n\nts\n\n`// Type '\"hello\"'`\n\n`let x = <const>\"hello\";`\n\n`// Type 'readonly [10, 20]'`\n\n`let y = <const>[10, 20];`\n\n`// Type '{ readonly text: \"hello\" }'`\n\n`let z = <const>{ text: \"hello\" };`\n\nThis feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.\n\nts\n\n`// Works with no types referenced or declared.`\n\n`// We only needed a single const assertion.`\n\n`function getShapes() {`\n\n  `let result = [`\n\n    `{ kind: \"circle\", radius: 100 },`\n\n    `{ kind: \"square\", sideLength: 50 },`\n\n  `] as const;`\n\n  `return result;`\n\n`}`\n\n`for (const shape of getShapes()) {`\n\n  `// Narrows perfectly!`\n\n  `if (shape.kind === \"circle\") {`\n\n    `console.log(\"Circle radius\", shape.radius);`\n\n  `} else {`\n\n    `console.log(\"Square side length\", shape.sideLength);`\n\n  `}`\n\n`}`\n\nNotice the above needed no type annotations. The `const` assertion allowed TypeScript to take the most specific type of the expression.\n\nThis can even be used to enable `enum`\\-like patterns in plain JavaScript code if you choose not to use TypeScript’s `enum` construct.\n\nts\n\n`export const Colors = {`\n\n  `red: \"RED\",`\n\n  `blue: \"BLUE\",`\n\n  `green: \"GREEN\",`\n\n`} as const;`\n\n`// or use an 'export default'`\n\n`export default {`\n\n  `red: \"RED\",`\n\n  `blue: \"BLUE\",`\n\n  `green: \"GREEN\",`\n\n`} as const;`\n\n### [](#caveats-1)Caveats\n\nOne thing to note is that `const` assertions can only be applied immediately on simple literal expressions.\n\nts\n\n`// Error! A 'const' assertion can only be applied to a`\n\n`// to a string, number, boolean, array, or object literal.`\n\n`let a = (Math.random() < 0.5 ? 0 : 1) as const;`\n\n`let b = (60 * 60 * 1000) as const;`\n\n`// Works!`\n\n`let c = Math.random() < 0.5 ? (0 as const) : (1 as const);`\n\n`let d = 3_600_000 as const;`\n\nAnother thing to keep in mind is that `const` contexts don’t immediately convert an expression to be fully immutable.\n\nts\n\n`let arr = [1, 2, 3, 4];`\n\n`let foo = {`\n\n  `name: \"foo\",`\n\n  `contents: arr,`\n\n`} as const;`\n\n`foo.name = \"bar\"; // error!`\n\n`foo.contents = []; // error!`\n\n`foo.contents.push(5); // ...works!`\n\nFor more details, you can [check out the respective pull request](https://github.com/Microsoft/TypeScript/pull/29510).\n\n## [](#type-checking-for-globalthis)Type-checking for `globalThis`\n\nTypeScript 3.4 introduces support for type-checking ECMAScript’s new `globalThis` - a global variable that, well, refers to the global scope. Unlike the above solutions, `globalThis` provides a standard way for accessing the global scope which can be used across different environments.\n\nts\n\n`// in a global file:`\n\n`var abc = 100;`\n\n`// Refers to 'abc' from above.`\n\n`globalThis.abc = 200;`\n\nNote that global variables declared with `let` and `const` don’t show up on `globalThis`.\n\nts\n\n`let answer = 42;`\n\n`// error! Property 'answer' does not exist on 'typeof globalThis'.`\n\n`globalThis.answer = 333333;`\n\nIt’s also important to note that TypeScript doesn’t transform references to `globalThis` when compiling to older versions of ECMAScript. As such, unless you’re targeting evergreen browsers (which already support `globalThis`), you may want to [use an appropriate polyfill](https://github.com/ljharb/globalThis) instead.\n\nFor more details on the implementation, see [the feature’s pull request](https://github.com/Microsoft/TypeScript/pull/29332).",
    "title": "TypeScript: Documentation - TypeScript 3.4",
    "description": "TypeScript 3.4 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.5\n\n## [](#supporting-lib-from-node_modules)Supporting `lib` from `node_modules`\n\nTo ensure that TypeScript and JavaScript support works well out of the box, TypeScript bundles a series of declaration files (`.d.ts` files). These declaration files represent the available APIs in the JavaScript language, and the standard browser DOM APIs. While there are some reasonable defaults based on your [`target`](https://www.typescriptlang.org/tsconfig#target), you can pick and choose which declaration files your program uses by configuring the [`lib`](https://www.typescriptlang.org/tsconfig#lib) setting in the `tsconfig.json`.\n\nThere are two occasional downsides to including these declaration files with TypeScript though:\n\n*   When you upgrade TypeScript, you’re also forced to handle changes to TypeScript’s built-in declaration files, and this can be a challenge when the DOM APIs change as frequently as they do.\n*   It is hard to customize these files to match your needs with the needs of your project’s dependencies (e.g. if your dependencies declare that they use the DOM APIs, you might also be forced into using the DOM APIs).\n\nTypeScript 4.5 introduces a way to override a specific built-in `lib` in a manner similar to how `@types/` support works. When deciding which `lib` files TypeScript should include, it will first look for a scoped `@typescript/lib-*` package in `node_modules`. For example, when including `dom` as an option in `lib`, TypeScript will use the types in `node_modules/@typescript/lib-dom` if available.\n\nYou can then use your package manager to install a specific package to take over for a given `lib` For example, today TypeScript publishes versions of the DOM APIs on `@types/web`. If you wanted to lock your project to a specific version of the DOM APIs, you could add this to your `package.json`:\n\njson\n\n`{`\n\n  `\"dependencies\": {`\n\n    `\"@typescript/lib-dom\": \"npm:@types/web\"`\n\n  `}`\n\n`}`\n\nThen from 4.5 onwards, you can update TypeScript and your dependency manager’s lockfile will ensure that it uses the exact same version of the DOM types. That means you get to update your types on your own terms.\n\nWe’d like to give a shout-out to [saschanaz](https://github.com/saschanaz) who has been extremely helpful and patient as we’ve been building out and experimenting with this feature.\n\nFor more information, you can [see the implementation of this change](https://github.com/microsoft/TypeScript/pull/45771).\n\n## [](#the-awaited-type-and-promise-improvements)The `Awaited` Type and `Promise` Improvements\n\nTypeScript 4.5 introduces a new utility type called the `Awaited` type. This type is meant to model operations like `await` in `async` functions, or the `.then()` method on `Promise`s - specifically, the way that they recursively unwrap `Promise`s.\n\nts\n\n`// A = string`\n\n`type A = Awaited<Promise<string>>;`\n\n`// B = number`\n\n`type B = Awaited<Promise<Promise<number>>>;`\n\n`// C = boolean | number`\n\n`type C = Awaited<boolean | Promise<number>>;`\n\nThe `Awaited` type can be helpful for modeling existing APIs, including JavaScript built-ins like `Promise.all`, `Promise.race`, etc. In fact, some of the problems around inference with `Promise.all` served as motivations for `Awaited`. Here’s an example that fails in TypeScript 4.4 and earlier.\n\nts\n\n`declare function MaybePromise<T>(value: T): T | Promise<T> | PromiseLike<T>;`\n\n`async function doSomething(): Promise<[number, number]> {`\n\n  `const result = await Promise.all([MaybePromise(100), MaybePromise(200)]);`\n\n  `// Error!`\n\n  `//`\n\n  `//    [number | Promise<100>, number | Promise<200>]`\n\n  `//`\n\n  `// is not assignable to type`\n\n  `//`\n\n  `//    [number, number]`\n\n  `return result;`\n\n`}`\n\nNow `Promise.all` leverages the combination of certain features with `Awaited` to give much better inference results, and the above example works.\n\nFor more information, you [can read about this change on GitHub](https://github.com/microsoft/TypeScript/pull/45350).\n\n## [](#template-string-types-as-discriminants)Template String Types as Discriminants\n\nTypeScript 4.5 now can narrow values that have template string types, and also recognizes template string types as discriminants.\n\nAs an example, the following used to fail, but now successfully type-checks in TypeScript 4.5.\n\nts\n\n`export interface Success {`\n\n    ``type: `${string}Success`;``\n\n    `body: string;`\n\n`}`\n\n`export interface Error {`\n\n    ``type: `${string}Error`;``\n\n    `message: string`\n\n`}`\n\n`export function handler(r: Success | Error) {`\n\n    `if (r.type === \"HttpSuccess\") {`\n\n        `const token = r.body;`\n\n                     `(parameter) r: Success`\n\n    `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBASwHY2FAZgQwMbDgZQFdtcBnUuAbwCg464YBPMYALjgAMASS0mKZAHMAvkRLByHANy16AIwgATRuz4CkgmcOrVQkWIhRosuOAFEoUaFVl0mLdt178hwi1ajTbcALYTSmIJscGpC1Nq64NDw6IRI2DAIEEhwABaYSIoANmgAFFDsYmQUAD7mltAAlDb0iOhw+QB09ngAvO1wAEQAEjAwYEX+ndU0tbXYyXwMEADWwCmtcFCNCsoyY-QA9JsbGwB6APze2sJAA)\n\nFor more information, [see the change that enables this feature](https://github.com/microsoft/TypeScript/pull/46137).\n\n## [](#module-es2022)`module es2022`\n\nThanks to [Kagami S. Rosylight](https://github.com/saschanaz), TypeScript now supports a new `module` setting: `es2022`. The main feature in [`module es2022`](https://www.typescriptlang.org/tsconfig#module) is top-level `await`, meaning you can use `await` outside of `async` functions. This was already supported in `--module esnext` (and now [`--module nodenext`](https://www.typescriptlang.org/tsconfig#target)), but `es2022` is the first stable target for this feature.\n\nYou can [read up more on this change here](https://github.com/microsoft/TypeScript/pull/44656).\n\n## [](#tail-recursion-elimination-on-conditional-types)Tail-Recursion Elimination on Conditional Types\n\nTypeScript often needs to gracefully fail when it detects possibly infinite recursion, or any type expansions that can take a long time and affect your editor experience. As a result, TypeScript has heuristics to make sure it doesn’t go off the rails when trying to pick apart an infinitely-deep type, or working with types that generate a lot of intermediate results.\n\nts\n\n`type InfiniteBox<T> = { item: InfiniteBox<T> };`\n\n`type Unpack<T> = T extends { item: infer U } ? Unpack<U> : T;`\n\n`// error: Type instantiation is excessively deep and possibly infinite.`\n\n`type Test = Unpack<InfiniteBox<number>>;`\n\nThe above example is intentionally simple and useless, but there are plenty of types that are actually useful, and unfortunately trigger our heuristics. As an example, the following `TrimLeft` type removes spaces from the beginning of a string-like type. If given a string type that has a space at the beginning, it immediately feeds the remainder of the string back into `TrimLeft`.\n\nts\n\n`type TrimLeft<T extends string> =`\n\n    ``T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;``\n\n`// Test = \"hello\" | \"world\"`\n\n`type Test = TrimLeft<\"   hello\" | \" world\">;`\n\nThis type can be useful, but if a string has 50 leading spaces, you’ll get an error.\n\nts\n\n`type TrimLeft<T extends string> =`\n\n    ``T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;``\n\n`// error: Type instantiation is excessively deep and possibly infinite.`\n\n`type Test = TrimLeft<\"                                                oops\">;`\n\nThat’s unfortunate, because these kinds of types tend to be extremely useful in modeling operations on strings - for example, parsers for URL routers. To make matters worse, a more useful type typically creates more type instantiations, and in turn has even more limitations on input length.\n\nBut there’s a saving grace: `TrimLeft` is written in a way that is _tail-recursive_ in one branch. When it calls itself again, it immediately returns the result and doesn’t do anything with it. Because these types don’t need to create any intermediate results, they can be implemented more quickly and in a way that avoids triggering many of type recursion heuristics that are built into TypeScript.\n\nThat’s why TypeScript 4.5 performs some tail-recursion elimination on conditional types. As long as one branch of a conditional type is simply another conditional type, TypeScript can avoid intermediate instantiations. There are still heuristics to ensure that these types don’t go off the rails, but they are much more generous.\n\nKeep in mind, the following type _won’t_ be optimized, since it uses the result of a conditional type by adding it to a union.\n\nts\n\n`type GetChars<S> =`\n\n    ``S extends `${infer Char}${infer Rest}` ? Char | GetChars<Rest> : never;``\n\nIf you would like to make it tail-recursive, you can introduce a helper that takes an “accumulator” type parameter, just like with tail-recursive functions.\n\nts\n\n`type GetChars<S> = GetCharsHelper<S, never>;`\n\n`type GetCharsHelper<S, Acc> =`\n\n    ``S extends `${infer Char}${infer Rest}` ? GetCharsHelper<Rest, Char | Acc> : Acc;``\n\nYou can read up more on the implementation [here](https://github.com/microsoft/TypeScript/pull/45711).\n\n## [](#disabling-import-elision)Disabling Import Elision\n\nThere are some cases where TypeScript can’t detect that you’re using an import. For example, take the following code:\n\nts\n\n`import { Animal } from \"./animal.js\";`\n\n`eval(\"console.log(new Animal().isDangerous())\");`\n\nBy default, TypeScript always removes this import because it appears to be unused. In TypeScript 4.5, you can enable a new flag called [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports) to prevent TypeScript from stripping out any imported values from your JavaScript outputs. Good reasons to use `eval` are few and far between, but something very similar to this happens in Svelte:\n\nhtml\n\n`<!-- A .svelte File -->`\n\n`<script>`\n\n  `import { someFunc } from \"./some-module.js\";`\n\n`</script>`\n\n`<button on:click=\"{someFunc}\">Click me!</button>`\n\nalong with in Vue.js, using its `<script setup>` feature:\n\nhtml\n\n`<!-- A .vue File -->`\n\n`<script setup>`\n\n  `import { someFunc } from \"./some-module.js\";`\n\n`</script>`\n\n`<button @click=\"someFunc\">Click me!</button>`\n\nThese frameworks generate some code based on markup outside of their `<script>` tags, but TypeScript _only_ sees code within the `<script>` tags. That means TypeScript will automatically drop the import of `someFunc`, and the above code won’t be runnable! With TypeScript 4.5, you can use [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports) to avoid these situations.\n\nNote that this flag has a special requirement when combined with [—isolatedModules\\`](https://www.typescriptlang.org/tsconfig#isolatedModules): imported types _must_ be marked as type-only because compilers that process single files at a time have no way of knowing whether imports are values that appear unused, or a type that must be removed in order to avoid a runtime crash.\n\nts\n\n``// Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,``\n\n``// ts-loader, esbuild, etc. don't, so `isolatedModules` gives an error.``\n\n`import { someFunc, BaseType } from \"./some-module.js\";`\n\n`//                 ^^^^^^^^`\n\n`// Error: 'BaseType' is a type and must be imported using a type-only import`\n\n`// when 'preserveValueImports' and 'isolatedModules' are both enabled.`\n\nThat makes another TypeScript 4.5 feature, [`type` modifiers on import names](#type-on-import-names), especially important.\n\nFor more information, [see the pull request here](https://github.com/microsoft/TypeScript/pull/44619).\n\n## [](#type-modifiers-on-import-names)`type` Modifiers on Import Names\n\nAs mentioned above, [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports) and [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules) have special requirements so that there’s no ambiguity for build tools whether it’s safe to drop type imports.\n\nts\n\n``// Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,``\n\n``// ts-loader, esbuild, etc. don't, so `isolatedModules` issues an error.``\n\n`import { someFunc, BaseType } from \"./some-module.js\";`\n\n`//                 ^^^^^^^^`\n\n`// Error: 'BaseType' is a type and must be imported using a type-only import`\n\n`// when 'preserveValueImports' and 'isolatedModules' are both enabled.`\n\nWhen these options are combined, we need a way to signal when an import can be legitimately dropped. TypeScript already has something for this with `import type`:\n\nts\n\n`import type { BaseType } from \"./some-module.js\";`\n\n`import { someFunc } from \"./some-module.js\";`\n\n`export class Thing implements BaseType {`\n\n  `// ...`\n\n`}`\n\nThis works, but it would be nice to avoid two import statements for the same module. That’s part of why TypeScript 4.5 allows a `type` modifier on individual named imports, so that you can mix and match as needed.\n\nts\n\n`import { someFunc, type BaseType } from \"./some-module.js\";`\n\n`export class Thing implements BaseType {`\n\n    `someMethod() {`\n\n        `someFunc();`\n\n    `}`\n\n`}`\n\nIn the above example, `BaseType` is always guaranteed to be erased and `someFunc` will be preserved under [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports), leaving us with the following code:\n\njs\n\n`import { someFunc } from \"./some-module.js\";`\n\n`export class Thing {`\n\n  `someMethod() {`\n\n    `someFunc();`\n\n  `}`\n\n`}`\n\nFor more information, see [the changes on GitHub](https://github.com/microsoft/TypeScript/pull/45998).\n\n## [](#private-field-presence-checks)Private Field Presence Checks\n\nTypeScript 4.5 supports an ECMAScript proposal for checking whether an object has a private field on it. You can now write a class with a `#private` field member and see whether another object has the same field by using the `in` operator.\n\nts\n\n`class Person {`\n\n    `#name: string;`\n\n    `constructor(name: string) {`\n\n        `this.#name = name;`\n\n    `}`\n\n    `equals(other: unknown) {`\n\n        `return other &&`\n\n            `typeof other === \"object\" &&`\n\n            `#name in other && // <- this is new!`\n\n            `this.#name === other.#name;`\n\n    `}`\n\n`}`\n\nOne interesting aspect of this feature is that the check `#name in other` implies that `other` must have been constructed as a `Person`, since there’s no other way that field could be present. This is actually one of the key features of the proposal, and it’s why the proposal is named “ergonomic brand checks” - because private fields often act as a “brand” to guard against objects that aren’t instances of their class. As such, TypeScript is able to appropriately narrow the type of `other` on each check, until it ends up with the type `Person`.\n\nWe’d like to extend a big thanks to our friends at Bloomberg [who contributed this pull request](https://github.com/microsoft/TypeScript/pull/44648): [Ashley Claymore](https://github.com/acutmore), [Titian Cernicova-Dragomir](https://github.com/dragomirtitian), [Kubilay Kahveci](https://github.com/mkubilayk), and [Rob Palmer](https://github.com/robpalme)!\n\n## [](#import-assertions)Import Assertions\n\nTypeScript 4.5 supports an ECMAScript proposal for _import assertions_. This is a syntax used by runtimes to make sure that an import has an expected format.\n\nts\n\n`import obj from \"./something.json\" assert { type: \"json\" };`\n\nThe contents of these assertions are not checked by TypeScript since they’re host-specific, and are simply left alone so that browsers and runtimes can handle them (and possibly error).\n\nts\n\n`// TypeScript is fine with this.`\n\n`// But your browser? Probably not.`\n\n`import obj from \"./something.json\" assert {`\n\n    `type: \"fluffy bunny\"`\n\n`};`\n\nDynamic `import()` calls can also use import assertions through a second argument.\n\nts\n\n`const obj = await import(\"./something.json\", {`\n\n  `assert: { type: \"json\" },`\n\n`});`\n\nThe expected type of that second argument is defined by a new type called `ImportCallOptions`, and currently only accepts an `assert` property.\n\nWe’d like to thank [Wenlu Wang](https://github.com/Kingwl/) for [implementing this feature](https://github.com/microsoft/TypeScript/pull/40698)!\n\n## [](#const-assertions-and-default-type-arguments-in-jsdoc)Const Assertions and Default Type Arguments in JSDoc\n\nTypeScript 4.5 brings some extra expressivity to our JSDoc support.\n\nOne example of this is with `const` assertions. In TypeScript, you can get a more precise and immutable type by writing `as const` after a literal.\n\nts\n\n`// type is { prop: string }`\n\n`let a = { prop: \"hello\" };`\n\n`// type is { readonly prop: \"hello\" }`\n\n`let b = { prop: \"hello\" } as const;`\n\nIn JavaScript files, you can now use JSDoc type assertions to achieve the same thing.\n\nts\n\n`// type is { prop: string }`\n\n`let a = { prop: \"hello\" };`\n\n`// type is { readonly prop: \"hello\" }`\n\n`let b = /** @type {const} */ ({ prop: \"hello\" });`\n\nAs a reminder, JSDoc type assertions comments start with `/** @type {TheTypeWeWant} */` and are followed by a parenthesized expression:\n\njs\n\n``/** @type {TheTypeWeWant} */` (someExpression)``\n\nTypeScript 4.5 also adds default type arguments to JSDoc, which means the following `type` declaration in TypeScript:\n\nts\n\n`type Foo<T extends string | number = number> = { prop: T };`\n\ncan be rewritten as the following `@typedef` declaration in JavaScript:\n\njs\n\n`/**`\n\n `* @template {string | number} [T=number]`\n\n `* @typedef Foo`\n\n `* @property prop {T}`\n\n `*/`\n\n`// or`\n\n`/**`\n\n `* @template {string | number} [T=number]`\n\n `* @typedef {{ prop: T }} Foo`\n\n `*/`\n\nFor more information, see [the pull request for const assertions](https://github.com/microsoft/TypeScript/pull/45464) along with [the changes for type argument defaults](https://github.com/microsoft/TypeScript/pull/45483).\n\n## [](#faster-load-time-with-realpathsyncnative)Faster Load Time with `realPathSync.native`\n\nTypeScript now leverages a system-native implementation of the Node.js `realPathSync` function on all operating systems.\n\nPreviously this function was only used on Linux, but in TypeScript 4.5 it has been adopted to operating systems that are typically case-insensitive, like Windows and MacOS. On certain codebases, this change sped up project loading by 5-13% (depending on the host operating system).\n\nFor more information, see [the original change here](https://github.com/microsoft/TypeScript/pull/44966), along with [the 4.5-specific changes here](https://github.com/microsoft/TypeScript/pull/44966).\n\n## [](#snippet-completions-for-jsx-attributes)Snippet Completions for JSX Attributes\n\nTypeScript 4.5 brings _snippet completions_ for JSX attributes. When writing out an attribute in a JSX tag, TypeScript will already provide suggestions for those attributes; but with snippet completions, they can remove a little bit of extra typing by adding an initializer and putting your cursor in the right place.\n\n![Snippet completions for JSX attributes. For a string property, quotes are automatically added. For a numeric properties, braces are added.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/jsx-attributes-snippets-4-5.gif)\n\nTypeScript will typically use the type of an attribute to figure out what kind of initializer to insert, but you can customize this behavior in Visual Studio Code.\n\n![Settings in VS Code for JSX attribute completions](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/jsx-snippet-settings-4-5.png)\n\nKeep in mind, this feature will only work in newer versions of Visual Studio Code, so you might have to use an Insiders build to get this working. For more information, [read up on the original pull request](https://github.com/microsoft/TypeScript/pull/45903)\n\n## [](#better-editor-support-for-unresolved-types)Better Editor Support for Unresolved Types\n\nIn some cases, editors will leverage a lightweight “partial” semantic mode - either while the editor is waiting for the full project to load, or in contexts like [GitHub’s web-based editor](https://docs.github.com/en/codespaces/developing-in-codespaces/web-based-editor).\n\nIn older versions of TypeScript, if the language service couldn’t find a type, it would just print `any`.\n\n![Hovering over a signature where Buffer isn't found, TypeScript replaces it with any.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/quick-info-unresolved-4-4.png)\n\nIn the above example, `Buffer` wasn’t found, so TypeScript replaced it with `any` in _quick info_. In TypeScript 4.5, TypeScript will try its best to preserve what you wrote.\n\n![Hovering over a signature where Buffer isn't found, it continues to use the name Buffer.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/quick-info-unresolved-4-5.png)\n\nHowever, if you hover over `Buffer` itself, you’ll get a hint that TypeScript couldn’t find `Buffer`.\n\n![TypeScript displays type Buffer = /* unresolved */ any;](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/quick-info-unresolved-on-type-4-5.png)\n\nAltogether, this provides a smoother experience when TypeScript doesn’t have the full program available. Keep in mind, you’ll always get an error in regular scenarios to tell you when a type isn’t found.\n\nFor more information, [see the implementation here](https://github.com/microsoft/TypeScript/pull/45976).\n\n## [](#breaking-changes)Breaking Changes\n\n### [](#libdts-changes)`lib.d.ts` Changes\n\nTypeScript 4.5 contains changes to its built-in declaration files which may affect your compilation; however, [these changes were fairly minimal](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1143), and we expect most code will be unaffected.\n\n### [](#inference-changes-from-awaited)Inference Changes from `Awaited`\n\nBecause `Awaited` is now used in `lib.d.ts` and as a result of `await`, you may see certain generic types change that might cause incompatibilities; however, given many intentional design decisions around `Awaited` to avoid breakage, we expect most code will be unaffected.\n\n### [](#compiler-options-checking-at-the-root-of-tsconfigjson)Compiler Options Checking at the Root of `tsconfig.json`\n\nIt’s an easy mistake to accidentally forget about the `compilerOptions` section in a `tsconfig.json`. To help catch this mistake, in TypeScript 4.5, it is an error to add a top-level field which matches any of the available options in `compilerOptions` _without_ having also defined `compilerOptions` in that `tsconfig.json`.",
    "title": "TypeScript: Documentation - TypeScript 4.5",
    "description": "TypeScript 4.5 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.6\n\n## [](#allowing-code-in-constructors-before-super)Allowing Code in Constructors Before `super()`\n\nIn JavaScript classes it’s mandatory to call `super()` before referring to `this`. TypeScript enforces this as well, though it was a bit too strict in _how_ it ensured this. In TypeScript, it was previously an error to contain _any_ code at the beginning of a constructor if its containing class had any property initializers.\n\nts\n\n`class Base {`\n\n  `// ...`\n\n`}`\n\n`class Derived extends Base {`\n\n  `someProperty = true;`\n\n  `constructor() {`\n\n    `// error!`\n\n    `// have to call 'super()' first because it needs to initialize 'someProperty'.`\n\n    `doSomeStuff();`\n\n    `super();`\n\n  `}`\n\n`}`\n\nThis made it cheap to check that `super()` gets called before `this` is referenced, but it ended up rejecting a lot of valid code. TypeScript 4.6 is now much more lenient in that check and permits other code to run before `super()`., all while still ensuring that `super()` occurs at the top-level before any references to `this`.\n\nWe’d like to extend our thanks to [Joshua Goldberg](https://github.com/JoshuaKGoldberg) for [patiently working with us to land this change](https://github.com/microsoft/TypeScript/pull/29374)!\n\n## [](#control-flow-analysis-for-destructured-discriminated-unions)Control Flow Analysis for Destructured Discriminated Unions\n\nTypeScript is able to narrow types based on what’s called a discriminant property. For example, in the following code snippet, TypeScript is able to narrow the type of `action` based on every time we check against the value of `kind`.\n\nts\n\n`type Action =`\n\n  `| { kind: \"NumberContents\"; payload: number }`\n\n  `| { kind: \"StringContents\"; payload: string };`\n\n`function processAction(action: Action) {`\n\n  `if (action.kind === \"NumberContents\") {`\n\n    ``// `action.payload` is a number here.``\n\n    `let num = action.payload * 2;`\n\n    `// ...`\n\n  `} else if (action.kind === \"StringContents\") {`\n\n    ``// `action.payload` is a string here.``\n\n    `const str = action.payload.trim();`\n\n    `// ...`\n\n  `}`\n\n`}`\n\nThis lets us work with objects that can hold different data, but a common field tells us _which_ data those objects have.\n\nThis is very common in TypeScript; however, depending on your preferences, you might have wanted to destructure `kind` and `payload` in the example above. Perhaps something like the following:\n\nts\n\n`type Action =`\n\n  `| { kind: \"NumberContents\"; payload: number }`\n\n  `| { kind: \"StringContents\"; payload: string };`\n\n`function processAction(action: Action) {`\n\n  `const { kind, payload } = action;`\n\n  `if (kind === \"NumberContents\") {`\n\n    `let num = payload * 2;`\n\n    `// ...`\n\n  `} else if (kind === \"StringContents\") {`\n\n    `const str = payload.trim();`\n\n    `// ...`\n\n  `}`\n\n`}`\n\nPreviously TypeScript would error on these - once `kind` and `payload` were extracted from the same object into variables, they were considered totally independent.\n\nIn TypeScript 4.6, this just works!\n\nWhen destructuring individual properties into a `const` declaration, or when destructuring a parameter into variables that are never assigned to, TypeScript will check for if the destructured type is a discriminated union. If it is, TypeScript can now narrow the types of variables depending on checks of other variables So in our example, a check on `kind` narrows the type of `payload`.\n\nFor more information, [see the pull request that implemented this analysis](https://github.com/microsoft/TypeScript/pull/46266).\n\n## [](#improved-recursion-depth-checks)Improved Recursion Depth Checks\n\nTypeScript has some interesting challenges due to the fact that it’s built on a structural type system that also provides generics.\n\nIn a structural type system, object types are compatible based on the members they have.\n\nts\n\n`interface Source {`\n\n  `prop: string;`\n\n`}`\n\n`interface Target {`\n\n  `prop: number;`\n\n`}`\n\n`function check(source: Source, target: Target) {`\n\n  `target = source;`\n\n  `// error!`\n\n  `// Type 'Source' is not assignable to type 'Target'.`\n\n  `//   Types of property 'prop' are incompatible.`\n\n  `//     Type 'string' is not assignable to type 'number'.`\n\n`}`\n\nNotice that whether or not `Source` is compatible with `Target` has to do with whether their _properties_ are assignable. In this case, that’s just `prop`.\n\nWhen you introduce generics into this, there are some harder questions to answer. For instance, is a `Source<string>` assignable to a `Target<number>` in the following case?\n\nts\n\n`interface Source<T> {`\n\n  `prop: Source<Source<T>>;`\n\n`}`\n\n`interface Target<T> {`\n\n  `prop: Target<Target<T>>;`\n\n`}`\n\n`function check(source: Source<string>, target: Target<number>) {`\n\n  `target = source;`\n\n`}`\n\nIn order to answer that, TypeScript needs to check whether the types of `prop` are compatible. That leads to the another question: is a `Source<Source<string>>` assignable to a `Target<Target<number>>`? To answer that, TypeScript checks whether `prop` is compatible for _those_ types, and ends up checking whether `Source<Source<Source<string>>>` is assignable to `Target<Target<Target<number>>>`. Keep going for a bit, and you might notice that the type infinitely expands the more you dig in.\n\nTypeScript has a few heuristics here - if a type _appears_ to be infinitely expanding after encountering a certain depth check, then it considers that the types _could_ be compatible. This is usually enough, but embarrassingly there were some false-negatives that this wouldn’t catch.\n\nts\n\n`interface Foo<T> {`\n\n  `prop: T;`\n\n`}`\n\n`declare let x: Foo<Foo<Foo<Foo<Foo<Foo<string>>>>>>;`\n\n`declare let y: Foo<Foo<Foo<Foo<Foo<string>>>>>;`\n\n`x = y;`\n\nA human reader can see that `x` and `y` should be incompatible in the above example. While the types are deeply nested, that’s just a consequence of how they were declared. The heuristic was meant to capture cases where deeply-nested types were generated through exploring the types, not from when a developer wrote that type out themselves.\n\nTypeScript 4.6 is now able to distinguish these cases, and correctly errors on the last example. Additionally, because the language is no longer concerned with false-positives from explicitly-written types, TypeScript can conclude that a type is infinitely expanding much earlier, and save a bunch of work in checking for type compatibility. As a result, libraries on DefinitelyTyped like `redux-immutable`, `react-lazylog`, and `yup` saw a 50% reduction in check-time.\n\nYou may already have this change because it was cherry-picked into TypeScript 4.5.3, but it is a notable feature of TypeScript 4.6 which you can read up more about [here](https://github.com/microsoft/TypeScript/pull/46599).\n\n## [](#indexed-access-inference-improvements)Indexed Access Inference Improvements\n\nTypeScript now can correctly infer to indexed access types which immediately index into a mapped object type.\n\nts\n\n`interface TypeMap {`\n\n  `number: number;`\n\n  `string: string;`\n\n  `boolean: boolean;`\n\n`}`\n\n`type UnionRecord<P extends keyof TypeMap> = {`\n\n  `[K in P]: {`\n\n    `kind: K;`\n\n    `v: TypeMap[K];`\n\n    `f: (p: TypeMap[K]) => void;`\n\n  `};`\n\n`}[P];`\n\n`function processRecord<K extends keyof TypeMap>(record: UnionRecord<K>) {`\n\n  `record.f(record.v);`\n\n`}`\n\n`// This call used to have issues - now works!`\n\n`processRecord({`\n\n  `kind: \"string\",`\n\n  `v: \"hello!\",`\n\n  `// 'val' used to implicitly have the type 'string | number | boolean',`\n\n  `// but now is correctly inferred to just 'string'.`\n\n  `f: (val) => {`\n\n    `console.log(val.toUpperCase());`\n\n  `},`\n\n`});`\n\nThis pattern was already supported and allowed TypeScript to understand that the call to `record.f(record.v)` is valid, but previously the call to `processRecord` would give poor inference results for `val`\n\nTypeScript 4.6 improves this so that no type assertions are necessary within the call to `processRecord`.\n\nFor more information, you can [read up on the pull request](https://github.com/microsoft/TypeScript/pull/47109).\n\n## [](#control-flow-analysis-for-dependent-parameters)Control Flow Analysis for Dependent Parameters\n\nA signature can be declared with a rest parameter whose type is a discriminated union of tuples.\n\nts\n\n`function func(...args: [\"str\", string] | [\"num\", number]) {`\n\n  `// ...`\n\n`}`\n\nWhat this says is that the arguments to `func` depends entirely on the first argument. When the first argument is the string `\"str\"`, then its second argument has to be a `string`. When its first argument is the string `\"num\"`, its second argument has to be a `number`.\n\nIn cases where TypeScript infers the type of a function from a signature like this, TypeScript can now narrow parameters that depend on each other.\n\nts\n\n`type Func = (...args: [\"a\", number] | [\"b\", string]) => void;`\n\n`const f1: Func = (kind, payload) => {`\n\n  `if (kind === \"a\") {`\n\n    `payload.toFixed(); // 'payload' narrowed to 'number'`\n\n  `}`\n\n  `if (kind === \"b\") {`\n\n    `payload.toUpperCase(); // 'payload' narrowed to 'string'`\n\n  `}`\n\n`};`\n\n`f1(\"a\", 42);`\n\n`f1(\"b\", \"hello\");`\n\nFor more information, [see the change on GitHub](https://github.com/microsoft/TypeScript/pull/47190).\n\n## [](#--target-es2022)`--target es2022`\n\nTypeScript’s `--target` option now supports `es2022`. This means features like class fields now have a stable output target where they can be preserved. It also means that new built-in functionality like the [`at()` method on `Array`s](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at), [`Object.hasOwn`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn), or [the `cause` option on `new Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error#rethrowing_an_error_with_a_cause) can be used either with this new `--target` setting, or with `--lib es2022`.\n\nThis functionality was [implemented](https://github.com/microsoft/TypeScript/pull/46291) by [Kagami Sascha Rosylight (saschanaz)](https://github.com/saschanaz) over several PRs, and we’re grateful for that contribution!\n\n## [](#removed-unnecessary-arguments-in-react-jsx)Removed Unnecessary Arguments in `react-jsx`\n\nPreviously, when compiling code like the following in `--jsx react-jsx`\n\ntsx\n\n`export const el = <div>foo</div>;`\n\nTypeScript would produce the following JavaScript code:\n\njsx\n\n`import { jsx as _jsx } from \"react/jsx-runtime\";`\n\n`export const el = _jsx(\"div\", { children: \"foo\" }, void 0);`\n\nThat last `void 0` argument is unnecessary in this emit mode, and removing it can improve bundle sizes.\n\ndiff\n\n`- export const el = _jsx(\"div\", { children: \"foo\" }, void 0);`\n\n`+ export const el = _jsx(\"div\", { children: \"foo\" });`\n\nThanks to [a pull request](https://github.com/microsoft/TypeScript/pull/47467) from [Alexander Tarasyuk](https://github.com/a-tarasyuk), TypeScript 4.6 now drops the `void 0` argument.\n\n## [](#jsdoc-name-suggestions)JSDoc Name Suggestions\n\nIn JSDoc, you can document parameters using an `@param` tag.\n\njs\n\n`/**`\n\n `* @param x The first operand`\n\n `* @param y The second operand`\n\n `*/`\n\n`function add(x, y) {`\n\n  `return x + y;`\n\n`}`\n\nBut what happens when these comments fall out of date? What if we rename `x` and `y` to `a` and `b`?\n\njs\n\n`/**`\n\n `* @param x {number} The first operand`\n\n `* @param y {number} The second operand`\n\n `*/`\n\n`function add(a, b) {`\n\n  `return a + b;`\n\n`}`\n\nPreviously TypeScript would only tell you about this when performing type-checking on JavaScript files - when using either the `checkJs` option, or adding a `// @ts-check` comment to the top of your file.\n\nYou can now get similar information for TypeScript files in your editor! TypeScript now provides suggestions for when parameter names don’t match between your function and its JSDoc comment.\n\n![Suggestion diagnostics being shown in the editor for parameter names in JSDoc comments that don't match an actual parameter name.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/02/jsdoc-comment-suggestions-4-6.png)\n\n[This change](https://github.com/microsoft/TypeScript/pull/47257) was provided courtesy of [Alexander Tarasyuk](https://github.com/a-tarasyuk)!\n\n## [](#more-syntax-and-binding-errors-in-javascript)More Syntax and Binding Errors in JavaScript\n\nTypeScript has expanded its set of syntax and binding errors in JavaScript files. You’ll see these new errors if you open JavaScript files in an editor like Visual Studio or Visual Studio Code, or if you run JavaScript code through the TypeScript compiler - even if you don’t turn on `checkJs` or add a `// @ts-check` comment to the top of your files.\n\nAs one example, if you have two declarations of a `const` in the same scope of a JavaScript file, TypeScript will now issue an error on those declarations.\n\nts\n\n`const foo = 1234;`\n\n`//    ~~~`\n\n`// error: Cannot redeclare block-scoped variable 'foo'.`\n\n`// ...`\n\n`const foo = 5678;`\n\n`//    ~~~`\n\n`// error: Cannot redeclare block-scoped variable 'foo'.`\n\nAs another example, TypeScript will let you know if a modifier is being incorrectly used.\n\nts\n\n`function container() {`\n\n    `export function foo() {`\n\n`//  ~~~~~~`\n\n`// error: Modifiers cannot appear here.`\n\n    `}`\n\n`}`\n\nThese errors can be disabled by adding a `// @ts-nocheck` at the top of your file, but we’re interested in hearing some early feedback about how it works for your JavaScript workflow. You can easily try it out for Visual Studio Code by installing the [TypeScript and JavaScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next), and read up more on the [first](https://github.com/microsoft/TypeScript/pull/47067) and [second](https://github.com/microsoft/TypeScript/pull/47075) pull requests.\n\n## [](#typescript-trace-analyzer)TypeScript Trace Analyzer\n\nOccasionally, teams may encounter types that are computationally expensive to create and compare against other types. [TypeScript has a `--generateTrace` flag](https://github.com/microsoft/TypeScript/wiki/Performance#performance-tracing) to help identify some of those expensive types, or sometimes help diagnose issues in the TypeScript compiler. While the information generated by `--generateTrace` can be useful (especially with some information added in TypeScript 4.6), it can often be hard to read in existing trace visualizers.\n\nWe recently published a tool called [@typescript/analyze-trace](https://www.npmjs.com/package/@typescript/analyze-trace) to get a more digestible view of this information. While we don’t expect everyone to need `analyze-trace`, we think it can come in handy for any team that is running into [build performance issues with TypeScript](https://github.com/microsoft/TypeScript/wiki/Performance).\n\nFor more information, [see the `analyze-trace` tool’s repo](https://github.com/microsoft/typescript-analyze-trace).\n\n## [](#breaking-changes)Breaking Changes\n\n### [](#object-rests-drop-unspreadable-members-from-generic-objects)Object Rests Drop Unspreadable Members from Generic Objects\n\nObject rest expressions now drop members that appear to be unspreadable on generic objects. In the following example…\n\nts\n\n`class Thing {`\n\n  `someProperty = 42;`\n\n  `someMethod() {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\n`function foo<T extends Thing>(x: T) {`\n\n  `let { someProperty, ...rest } = x;`\n\n  `// Used to work, is now an error!`\n\n  `// Property 'someMethod' does not exist on type 'Omit<T, \"someProperty\" | \"someMethod\">'.`\n\n  `rest.someMethod();`\n\n`}`\n\nthe variable `rest` used to have the type `Omit<T, \"someProperty\">` because TypeScript would strictly analyze which other properties were destructured. This doesn’t model how `...rest` would work in a destructuring from a non-generic type because `someMethod` would typically be dropped as well. In TypeScript 4.6, the type of `rest` is `Omit<T, \"someProperty\" | \"someMethod\">`.\n\nThis can also come up in cases when destructuring from `this`. When destructuring `this` using a `...rest` element, unspreadable and non-public members are now dropped, which is consistent with destructuring instances of a class in other places.\n\nts\n\n`class Thing {`\n\n  `someProperty = 42;`\n\n  `someMethod() {`\n\n    `// ...`\n\n  `}`\n\n  `someOtherMethod() {`\n\n    `let { someProperty, ...rest } = this;`\n\n    `// Used to work, is now an error!`\n\n    `// Property 'someMethod' does not exist on type 'Omit<T, \"someProperty\" | \"someMethod\">'.`\n\n    `rest.someMethod();`\n\n  `}`\n\n`}`\n\nFor more details, [see the corresponding change here](https://github.com/microsoft/TypeScript/pull/47078).\n\n### [](#javascript-files-always-receive-grammar-and-binding-errors)JavaScript Files Always Receive Grammar and Binding Errors\n\nPreviously, TypeScript would ignore most grammar errors in JavaScript apart from accidentally using TypeScript syntax in a JavaScript file. TypeScript now shows JavaScript syntax and binding errors in your file, such as using incorrect modifiers, duplicate declarations, and more. These will typically be most apparent in Visual Studio Code or Visual Studio, but can also occur when running JavaScript code through the TypeScript compiler.\n\nYou can explicitly turn these errors off by inserting a `// @ts-nocheck` comment at the top of your file.\n\nFor more information, see the [first](https://github.com/microsoft/TypeScript/pull/47067) and [second](https://github.com/microsoft/TypeScript/pull/47075) implementing pull requests for these features.",
    "title": "TypeScript: Documentation - TypeScript 4.6",
    "description": "TypeScript 4.6 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.7\n\n## [](#ecmascript-module-support-in-nodejs)ECMAScript Module Support in Node.js\n\nFor the last few years, Node.js has been working to support ECMAScript modules (ESM). This has been a very difficult feature, since the Node.js ecosystem is built on a different module system called CommonJS (CJS). Interoperating between the two brings large challenges, with many new features to juggle; however, support for ESM in Node.js was largely implemented in Node.js 12 and later. Around TypeScript 4.5 we rolled out nightly-only support for ESM in Node.js to get some feedback from users and let library authors ready themselves for broader support.\n\nTypeScript 4.7 adds this functionality with two new `module` settings: `node16` and `nodenext`.\n\njsonc\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"module\": \"node16\",`\n\n    `}`\n\n`}`\n\nThese new modes bring a few high-level features which we’ll explore here.\n\n### [](#type-in-packagejson-and-new-extensions)`type` in `package.json` and New Extensions\n\nNode.js supports [a new setting in `package.json`](https://nodejs.org/api/packages.html#packages_package_json_and_file_extensions) called `type`. `\"type\"` can be set to either `\"module\"` or `\"commonjs\"`.\n\njsonc\n\n`{`\n\n    `\"name\": \"my-package\",`\n\n    `\"type\": \"module\",`\n\n    `\"//\": \"...\",`\n\n    `\"dependencies\": {`\n\n    `}`\n\n`}`\n\nThis setting controls whether `.js` and `.d.ts` files are interpreted as ES modules or CommonJS modules, and defaults to CommonJS when not set. When a file is considered an ES module, a few different rules come into play compared to CommonJS:\n\n*   `import`/`export` statements can be used.\n*   Top-level `await` can be used\n*   Relative import paths need full extensions (we have to write `import \"./foo.js\"` instead of `import \"./foo\"`).\n*   Imports might resolve differently from dependencies in `node_modules`.\n*   Certain global-like values like `require` and `module` cannot be used directly.\n*   CommonJS modules get imported under certain special rules.\n\nWe’ll come back to some of these.\n\nTo overlay the way TypeScript works in this system, `.ts` and `.tsx` files now work the same way. When TypeScript finds a `.ts`, `.tsx`, `.js`, or `.jsx` file, it will walk up looking for a `package.json` to see whether that file is an ES module, and use that to determine:\n\n*   how to find other modules which that file imports\n*   and how to transform that file if producing outputs\n\nWhen a `.ts` file is compiled as an ES module, ECMAScript `import`/`export` statements are left alone in the `.js` output; when it’s compiled as a CommonJS module, it will produce the same output you get today under `--module commonjs`.\n\nThis also means paths resolve differently between `.ts` files that are ES modules and ones that are CJS modules. For example, let’s say you have the following code today:\n\nts\n\n`// ./foo.ts`\n\n`export function helper() {`\n\n    `// ...`\n\n`}`\n\n`// ./bar.ts`\n\n`import { helper } from \"./foo\"; // only works in CJS`\n\n`helper();`\n\nThis code works in CommonJS modules, but will fail in ES modules because relative import paths need to use extensions. As a result, it will have to be rewritten to use the extension of the _output_ of `foo.ts` - so `bar.ts` will instead have to import from `./foo.js`.\n\nts\n\n`// ./bar.ts`\n\n`import { helper } from \"./foo.js\"; // works in ESM & CJS`\n\n`helper();`\n\nThis might feel a bit cumbersome at first, but TypeScript tooling like auto-imports and path completion will typically just do this for you.\n\nOne other thing to mention is the fact that this applies to `.d.ts` files too. When TypeScript finds a `.d.ts` file in a package, it is interpreted based on the containing package.\n\n### [](#new-file-extensions)New File Extensions\n\nThe `type` field in `package.json` is nice because it allows us to continue using the `.ts` and `.js` file extensions which can be convenient; however, you will occasionally need to write a file that differs from what `type` specifies. You might also just prefer to always be explicit.\n\nNode.js supports two extensions to help with this: `.mjs` and `.cjs`. `.mjs` files are always ES modules, and `.cjs` files are always CommonJS modules, and there’s no way to override these.\n\nIn turn, TypeScript supports two new source file extensions: `.mts` and `.cts`. When TypeScript emits these to JavaScript files, it will emit them to `.mjs` and `.cjs` respectively.\n\nFurthermore, TypeScript also supports two new declaration file extensions: `.d.mts` and `.d.cts`. When TypeScript generates declaration files for `.mts` and `.cts`, their corresponding extensions will be `.d.mts` and `.d.cts`.\n\nUsing these extensions is entirely optional, but will often be useful even if you choose not to use them as part of your primary workflow.\n\n### [](#commonjs-interoperability)CommonJS Interoperability\n\nNode.js allows ES modules to import CommonJS modules as if they were ES modules with a default export.\n\nts\n\n`// ./foo.cts`\n\n`export function helper() {`\n\n    `console.log(\"hello world!\");`\n\n`}`\n\n`// ./bar.mts`\n\n`import foo from \"./foo.cjs\";`\n\n`// prints \"hello world!\"`\n\n`foo.helper();`\n\nIn some cases, Node.js also synthesizes named exports from CommonJS modules, which can be more convenient. In these cases, ES modules can use a “namespace-style” import (i.e. `import * as foo from \"...\"`), or named imports (i.e. `import { helper } from \"...\"`).\n\nts\n\n`// ./foo.cts`\n\n`export function helper() {`\n\n    `console.log(\"hello world!\");`\n\n`}`\n\n`// ./bar.mts`\n\n`import { helper } from \"./foo.cjs\";`\n\n`// prints \"hello world!\"`\n\n`helper();`\n\nThere isn’t always a way for TypeScript to know whether these named imports will be synthesized, but TypeScript will err on being permissive and use some heuristics when importing from a file that is definitely a CommonJS module.\n\nOne TypeScript-specific note about interop is the following syntax:\n\nts\n\n`import foo = require(\"foo\");`\n\nIn a CommonJS module, this just boils down to a `require()` call, and in an ES module, this imports [`createRequire`](https://nodejs.org/api/module.html#module_module_createrequire_filename) to achieve the same thing. This will make code less portable on runtimes like the browser (which don’t support `require()`), but will often be useful for interoperability. In turn, you can write the above example using this syntax as follows:\n\nts\n\n`// ./foo.cts`\n\n`export function helper() {`\n\n    `console.log(\"hello world!\");`\n\n`}`\n\n`// ./bar.mts`\n\n`import foo = require(\"./foo.cjs\");`\n\n`foo.helper()`\n\nFinally, it’s worth noting that the only way to import ESM files from a CJS module is using dynamic `import()` calls. This can present challenges, but is the behavior in Node.js today.\n\nYou can [read more about ESM/CommonJS interop in Node.js here](https://nodejs.org/api/esm.html#esm_interoperability_with_commonjs).\n\n### [](#packagejson-exports-imports-and-self-referencing)`package.json` Exports, Imports, and Self-Referencing\n\nNode.js supports [a new field for defining entry points in `package.json` called `\"exports\"`](https://nodejs.org/api/packages.html#packages_exports). This field is a more powerful alternative to defining `\"main\"` in `package.json`, and can control what parts of your package are exposed to consumers.\n\nHere’s a `package.json` that supports separate entry-points for CommonJS and ESM:\n\njsonc\n\n`// package.json`\n\n`{`\n\n    `\"name\": \"my-package\",`\n\n    `\"type\": \"module\",`\n\n    `\"exports\": {`\n\n        `\".\": {`\n\n            ``// Entry-point for `import \"my-package\"` in ESM``\n\n            `\"import\": \"./esm/index.js\",`\n\n            ``// Entry-point for `require(\"my-package\") in CJS``\n\n            `\"require\": \"./commonjs/index.cjs\",`\n\n        `},`\n\n    `},`\n\n    `// CJS fall-back for older versions of Node.js`\n\n    `\"main\": \"./commonjs/index.cjs\",`\n\n`}`\n\nThere’s a lot to this feature, [which you can read more about on the Node.js documentation](https://nodejs.org/api/packages.html). Here we’ll try to focus on how TypeScript supports it.\n\nWith TypeScript’s original Node support, it would look for a `\"main\"` field, and then look for declaration files that corresponded to that entry. For example, if `\"main\"` pointed to `./lib/index.js`, TypeScript would look for a file called `./lib/index.d.ts`. A package author could override this by specifying a separate field called `\"types\"` (e.g. `\"types\": \"./types/index.d.ts\"`).\n\nThe new support works similarly with [import conditions](https://nodejs.org/api/packages.html). By default, TypeScript overlays the same rules with import conditions - if you write an `import` from an ES module, it will look up the `import` field, and from a CommonJS module, it will look at the `require` field. If it finds them, it will look for a corresponding declaration file. If you need to point to a different location for your type declarations, you can add a `\"types\"` import condition.\n\njsonc\n\n`// package.json`\n\n`{`\n\n    `\"name\": \"my-package\",`\n\n    `\"type\": \"module\",`\n\n    `\"exports\": {`\n\n        `\".\": {`\n\n            ``// Entry-point for `import \"my-package\"` in ESM``\n\n            `\"import\": {`\n\n                `// Where TypeScript will look.`\n\n                `\"types\": \"./types/esm/index.d.ts\",`\n\n                `// Where Node.js will look.`\n\n                `\"default\": \"./esm/index.js\"`\n\n            `},`\n\n            ``// Entry-point for `require(\"my-package\") in CJS``\n\n            `\"require\": {`\n\n                `// Where TypeScript will look.`\n\n                `\"types\": \"./types/commonjs/index.d.cts\",`\n\n                `// Where Node.js will look.`\n\n                `\"default\": \"./commonjs/index.cjs\"`\n\n            `},`\n\n        `}`\n\n    `},`\n\n    `// Fall-back for older versions of TypeScript`\n\n    `\"types\": \"./types/index.d.ts\",`\n\n    `// CJS fall-back for older versions of Node.js`\n\n    `\"main\": \"./commonjs/index.cjs\"`\n\n`}`\n\n> The `\"types\"` condition should always come first in `\"exports\"`.\n\nIt’s important to note that the CommonJS entrypoint and the ES module entrypoint each needs its own declaration file, even if the contents are the same between them. Every declaration file is interpreted either as a CommonJS module or as an ES module, based on its file extension and the `\"type\"` field of the `package.json`, and this detected module kind must match the module kind that Node will detect for the corresponding JavaScript file for type checking to be correct. Attempting to use a single `.d.ts` file to type both an ES module entrypoint and a CommonJS entrypoint will cause TypeScript to think only one of those entrypoints exists, causing compiler errors for users of the package.\n\nTypeScript also supports [the `\"imports\"` field of `package.json`](https://nodejs.org/api/packages.html#packages_imports) in a similar manner by looking for declaration files alongside corresponding files, and supports [packages self-referencing themselves](https://nodejs.org/api/packages.html#packages_self_referencing_a_package_using_its_name). These features are generally not as involved to set up, but are supported.\n\n### [](#your-feedback-wanted)Your Feedback Wanted!\n\nAs we continue working on TypeScript 4.7, we expect to see more documentation and polish go into this functionality. Supporting these new features has been an ambitious under-taking, and that’s why we’re looking for early feedback on it! Please try it out and let us know how it works for you.\n\nFor more information, [you can see the implementing PR here](https://github.com/microsoft/TypeScript/pull/44501).\n\n## [](#control-over-module-detection)Control over Module Detection\n\nOne issue with the introduction of modules to JavaScript was the ambiguity between existing “script” code and the new module code. JavaScript code in a module runs slightly differently, and has different scoping rules, so tools have to make decisions as to how each file runs. For example, Node.js requires module entry-points to be written in a `.mjs`, or have a nearby `package.json` with `\"type\": \"module\"`. TypeScript treats a file as a module whenever it finds any `import` or `export` statement in a file, but otherwise, will assume a `.ts` or `.js` file is a script file acting on the global scope.\n\nThis doesn’t quite match up with the behavior of Node.js where the `package.json` can change the format of a file, or the `--jsx` setting `react-jsx`, where any JSX file contains an implicit import to a JSX factory. It also doesn’t match modern expectations where most new TypeScript code is written with modules in mind.\n\nThat’s why TypeScript 4.7 introduces a new option called `moduleDetection`. `moduleDetection` can take on 3 values: `\"auto\"` (the default), `\"legacy\"` (the same behavior as 4.6 and prior), and `\"force\"`.\n\nUnder the mode `\"auto\"`, TypeScript will not only look for `import` and `export` statements, but it will also check whether\n\n*   the `\"type\"` field in `package.json` is set to `\"module\"` when running under `--module nodenext`/`--module node16`, and\n*   check whether the current file is a JSX file when running under `--jsx react-jsx`\n\nIn cases where you want every file to be treated as a module, the `\"force\"` setting ensures that every non-declaration file is treated as a module. This will be true regardless of how `module`, `moduleResolution`, and `jsx` are configured.\n\nMeanwhile, the `\"legacy\"` option simply goes back to the old behavior of only seeking out `import` and `export` statements to determine whether a file is a module.\n\nYou can [read up more about this change on the pull request](https://github.com/microsoft/TypeScript/pull/47495).\n\n## [](#control-flow-analysis-for-bracketed-element-access)Control-Flow Analysis for Bracketed Element Access\n\nTypeScript 4.7 now narrows the types of element accesses when the indexed keys are literal types and unique symbols. For example, take the following code:\n\nts\n\n`const key = Symbol();`\n\n`const numberOrString = Math.random() < 0.5 ? 42 : \"hello\";`\n\n`const obj = {`\n\n    `[key]: numberOrString,`\n\n`};`\n\n`if (typeof obj[key] === \"string\") {`\n\n    `let str = obj[key].toUpperCase();`\n\n`}`\n\nPreviously, TypeScript would not consider any type guards on `obj[key]`, and would have no idea that `obj[key]` was really a `string`. Instead, it would think that `obj[key]` was still a `string | number` and accessing `toUpperCase()` would trigger an error.\n\nTypeScript 4.7 now knows that `obj[key]` is a string.\n\nThis also means that under `--strictPropertyInitialization`, TypeScript can correctly check that computed properties are initialized by the end of a constructor body.\n\nts\n\n`// 'key' has type 'unique symbol'`\n\n`const key = Symbol();`\n\n`class C {`\n\n    `[key]: string;`\n\n    `constructor(str: string) {`\n\n        `// oops, forgot to set 'this[key]'`\n\n    `}`\n\n    `screamString() {`\n\n        `return this[key].toUpperCase();`\n\n    `}`\n\n`}`\n\nUnder TypeScript 4.7, `--strictPropertyInitialization` reports an error telling us that the `[key]` property wasn’t definitely assigned by the end of the constructor.\n\nWe’d like to extend our gratitude to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk) who provided [this change](https://github.com/microsoft/TypeScript/pull/45974)!\n\n## [](#improved-function-inference-in-objects-and-methods)Improved Function Inference in Objects and Methods\n\nTypeScript 4.7 can now perform more granular inferences from functions within objects and arrays. This allows the types of these functions to consistently flow in a left-to-right manner just like for plain arguments.\n\nts\n\n`declare function f<T>(arg: {`\n\n    `produce: (n: string) => T,`\n\n    `consume: (x: T) => void }`\n\n`): void;`\n\n`// Works`\n\n`f({`\n\n    `produce: () => \"hello\",`\n\n    `consume: x => x.toLowerCase()`\n\n`});`\n\n`// Works`\n\n`f({`\n\n    `produce: (n: string) => n,`\n\n    `consume: x => x.toLowerCase(),`\n\n`});`\n\n`// Was an error, now works.`\n\n`f({`\n\n    `produce: n => n,`\n\n    `consume: x => x.toLowerCase(),`\n\n`});`\n\n`// Was an error, now works.`\n\n`f({`\n\n    `produce: function () { return \"hello\"; },`\n\n    `consume: x => x.toLowerCase(),`\n\n`});`\n\n`// Was an error, now works.`\n\n`f({`\n\n    `produce() { return \"hello\" },`\n\n    `consume: x => x.toLowerCase(),`\n\n`});`\n\nInference failed in some of these examples because knowing the type of their `produce` functions would indirectly request the type of `arg` before finding a good type for `T`. TypeScript now gathers functions that could contribute to the inferred type of `T` and infers from them lazily.\n\nFor more information, you can [take a look at the specific modifications to our inference process](https://github.com/microsoft/TypeScript/pull/48538).\n\n## [](#instantiation-expressions)Instantiation Expressions\n\nOccasionally functions can be a bit more general than we want. For example, let’s say we had a `makeBox` function.\n\nts\n\n`interface Box<T> {`\n\n    `value: T;`\n\n`}`\n\n`function makeBox<T>(value: T) {`\n\n    `return { value };`\n\n`}`\n\nMaybe we want to create a more specialized set of functions for making `Box`es of `Wrench`es and `Hammer`s. To do that today, we’d have to wrap `makeBox` in other functions, or use an explicit type for an alias of `makeBox`.\n\nts\n\n`function makeHammerBox(hammer: Hammer) {`\n\n    `return makeBox(hammer);`\n\n`}`\n\n`// or...`\n\n`const makeWrenchBox: (wrench: Wrench) => Box<Wrench> = makeBox;`\n\nThese work, but wrapping a call to `makeBox` is a bit wasteful, and writing the full signature of `makeWrenchBox` could get unwieldy. Ideally, we would be able to say that we just want to alias `makeBox` while replacing all of the generics in its signature.\n\nTypeScript 4.7 allows exactly that! We can now take functions and constructors and feed them type arguments directly.\n\nts\n\n`const makeHammerBox = makeBox<Hammer>;`\n\n`const makeWrenchBox = makeBox<Wrench>;`\n\nSo with this, we can specialize `makeBox` to accept more specific types and reject anything else.\n\nts\n\n`const makeStringBox = makeBox<string>;`\n\n`// TypeScript correctly rejects this.`\n\n`makeStringBox(42);`\n\nThis logic also works for constructor functions such as `Array`, `Map`, and `Set`.\n\nts\n\n`` // Has type `new () => Map<string, Error>` ``\n\n`const ErrorMap = Map<string, Error>;`\n\n`` // Has type `// Map<string, Error>` ``\n\n`const errorMap = new ErrorMap();`\n\nWhen a function or constructor is given type arguments, it will produce a new type that keeps all signatures with compatible type parameter lists, and replaces the corresponding type parameters with the given type arguments. Any other signatures are dropped, as TypeScript will assume that they aren’t meant to be used.\n\nFor more information on this feature, [check out the pull request](https://github.com/microsoft/TypeScript/pull/47607).\n\n## [](#extends-constraints-on-infer-type-variables)`extends` Constraints on `infer` Type Variables\n\nConditional types are a bit of a power-user feature. They allow us to match and infer against the shape of types, and make decisions based on them. For example, we can write a conditional type that returns the first element of a tuple type if it’s a `string`\\-like type.\n\nts\n\n`type FirstIfString<T> =`\n\n    `T extends [infer S, ...unknown[]]`\n\n        `? S extends string ? S : never`\n\n        `: never;`\n\n `// string`\n\n`type A = FirstIfString<[string, number, number]>;`\n\n`// \"hello\"`\n\n`type B = FirstIfString<[\"hello\", number, number]>;`\n\n`// \"hello\" | \"world\"`\n\n`type C = FirstIfString<[\"hello\" | \"world\", boolean]>;`\n\n`// never`\n\n`type D = FirstIfString<[boolean, number, string]>;`\n\n`FirstIfString` matches against any tuple with at least one element and grabs the type of the first element as `S`. Then it checks if `S` is compatible with `string` and returns that type if it is.\n\nNote that we had to use two conditional types to write this. We could have written `FirstIfString` as follows:\n\nts\n\n`type FirstIfString<T> =`\n\n    `T extends [string, ...unknown[]]`\n\n        `` // Grab the first type out of `T` ``\n\n        `? T[0]`\n\n        `: never;`\n\nThis works, but it’s slightly more “manual” and less declarative. Instead of just pattern-matching on the type and giving the first element a name, we have to fetch out the `0`th element of `T` with `T[0]`. If we were dealing with types more complex than tuples, this could get a lot trickier, so `infer` can simplify things.\n\nUsing nested conditionals to infer a type and then match against that inferred type is pretty common. To avoid that second level of nesting, TypeScript 4.7 now allows you to place a constraint on any `infer` type.\n\nts\n\n`type FirstIfString<T> =`\n\n    `T extends [infer S extends string, ...unknown[]]`\n\n        `? S`\n\n        `: never;`\n\nThis way, when TypeScript matches against `S`, it also ensures that `S` has to be a `string`. If `S` isn’t a `string`, it takes the false path, which in these cases is `never`.\n\nFor more details, you can [read up on the change on GitHub](https://github.com/microsoft/TypeScript/pull/48112).\n\n## [](#optional-variance-annotations-for-type-parameters)Optional Variance Annotations for Type Parameters\n\nLet’s take the following types.\n\nts\n\n`interface Animal {`\n\n    `animalStuff: any;`\n\n`}`\n\n`interface Dog extends Animal {`\n\n    `dogStuff: any;`\n\n`}`\n\n`// ...`\n\n`type Getter<T> = () => T;`\n\n`type Setter<T> = (value: T) => void;`\n\nImagine we had two different instances of `Getter`s. Figuring out whether any two different `Getter`s are substitutable for one another depends entirely on `T`. In the case of whether an assignment of `Getter<Dog>` → `Getter<Animal>` is valid, we have to check whether `Dog` → `Animal` is valid. Because each type for `T` just gets related in the same “direction”, we say that the `Getter` type is _covariant_ on `T`. On the other hand, checking whether `Setter<Dog>` → `Setter<Animal>` is valid involves checking whether `Animal` → `Dog` is valid. That “flip” in direction is kind of like how in math, checking whether −_x_ < _−y_ is the same as checking whether _y_ < _x_. When we have to flip directions like this to compare `T`, we say that `Setter` is _contravariant_ on `T`.\n\nWith TypeScript 4.7, we’re now able to _explicitly_ specify variance on type parameters.\n\nSo now, if we want to make it explicit that `Getter` is covariant on `T`, we can now give it an `out` modifier.\n\nts\n\n`type Getter<out T> = () => T;`\n\nAnd similarly, if we also want to make it explicit that `Setter` is contravariant on `T`, we can give it an `in` modifier.\n\nts\n\n`type Setter<in T> = (value: T) => void;`\n\n`out` and `in` are used here because a type parameter’s variance depends on whether it’s used in an _output_ or an _input_. Instead of thinking about variance, you can just think about if `T` is used in output and input positions.\n\nThere are also cases for using both `in` and `out`.\n\nts\n\n`interface State<in out T> {`\n\n    `get: () => T;`\n\n    `set: (value: T) => void;`\n\n`}`\n\nWhen a `T` is used in both an output and input position, it becomes _invariant_. Two different `State<T>`s can’t be interchanged unless their `T`s are the same. In other words, `State<Dog>` and `State<Animal>` aren’t substitutable for the other.\n\nNow technically speaking, in a purely structural type system, type parameters and their variance don’t really matter - you can just plug in types in place of each type parameter and check whether each matching member is structurally compatible. So if TypeScript uses a structural type system, why are we interested in the variance of type parameters? And why might we ever want to annotate them?\n\nOne reason is that it can be useful for a reader to explicitly see how a type parameter is used at a glance. For much more complex types, it can be difficult to tell whether a type is meant to be read, written, or both. TypeScript will also help us out if we forget to mention how that type parameter is used. As an example, if we forgot to specify both `in` and `out` on `State`, we’d get an error.\n\nts\n\n`interface State<out T> {`\n\n    `//          ~~~~~`\n\n    `// error!`\n\n    `// Type 'State<sub-T>' is not assignable to type 'State<super-T>' as implied by variance annotation.`\n\n    `//   Types of property 'set' are incompatible.`\n\n    `//     Type '(value: sub-T) => void' is not assignable to type '(value: super-T) => void'.`\n\n    `//       Types of parameters 'value' and 'value' are incompatible.`\n\n    `//         Type 'super-T' is not assignable to type 'sub-T'.`\n\n    `get: () => T;`\n\n    `set: (value: T) => void;`\n\n`}`\n\nAnother reason is precision and speed! TypeScript already tries to infer the variance of type parameters as an optimization. By doing this, it can type-check larger structural types in a reasonable amount of time. Calculating variance ahead of time allows the type-checker to skip deeper comparisons and just compare type arguments which can be _much_ faster than comparing the full structure of a type over and over again. But often there are cases where this calculation is still fairly expensive, and the calculation may find circularities that can’t be accurately resolved, meaning there’s no clear answer for the variance of a type.\n\nts\n\n`type Foo<T> = {`\n\n    `x: T;`\n\n    `f: Bar<T>;`\n\n`}`\n\n`type Bar<U> = (x: Baz<U[]>) => void;`\n\n`type Baz<V> = {`\n\n    `value: Foo<V[]>;`\n\n`}`\n\n`declare let foo1: Foo<unknown>;`\n\n`declare let foo2: Foo<string>;`\n\n`foo1 = foo2;  // Should be an error but isn't ❌`\n\n`foo2 = foo1;  // Error - correct ✅`\n\nProviding an explicit annotation can speed up type-checking at these circularities and provide better accuracy. For instance, marking `T` as invariant in the above example can help stop the problematic assignment.\n\ndiff\n\n`- type Foo<T> = {`\n\n`+ type Foo<in out T> = {`\n\n      `x: T;`\n\n      `f: Bar<T>;`\n\n  `}`\n\nWe don’t necessarily recommend annotating every type parameter with its variance; For example, it’s possible (but not recommended) to make variance a little stricter than is necessary, so TypeScript won’t stop you from marking something as invariant if it’s really just covariant, contravariant, or even independent. So if you do choose to add explicit variance markers, we would encourage thoughtful and precise use of them.\n\nBut if you’re working with deeply recursive types, especially if you’re a library author, you may be interested in using these annotations to the benefit of your users. Those annotations can provide wins in both accuracy and type-checking speed, which can even affect their code editing experience. Determining when variance calculation is a bottleneck on type-checking time can be done experimentally, and determined using tooling like our [analyze-trace](https://github.com/microsoft/typescript-analyze-trace) utility.\n\nFor more details on this feature, you can [read up on the pull request](https://github.com/microsoft/TypeScript/pull/48240).\n\n## [](#resolution-customization-with-modulesuffixes)Resolution Customization with `moduleSuffixes`\n\nTypeScript 4.7 now supports a `moduleSuffixes` option to customize how module specifiers are looked up.\n\njsonc\n\n`{`\n\n    `\"compilerOptions\": {`\n\n        `\"moduleSuffixes\": [\".ios\", \".native\", \"\"]`\n\n    `}`\n\n`}`\n\nGiven the above configuration, an import like the following…\n\nts\n\n`import * as foo from \"./foo\";`\n\nwill try to look at the relative files `./foo.ios.ts`, `./foo.native.ts`, and finally `./foo.ts`.\n\nThis feature can be useful for React Native projects where each target platform can use a separate `tsconfig.json` with differing `moduleSuffixes`.\n\n[The `moduleSuffixes` option](https://github.com/microsoft/TypeScript/pull/48189) was contributed thanks to [Adam Foxman](https://github.com/afoxman)!\n\n## [](#resolution-mode)resolution-mode\n\nWith Node’s ECMAScript resolution, the mode of the containing file and the syntax you use determines how imports are resolved; however it would be useful to reference the types of a CommonJS module from an ECMAScript module, or vice-versa.\n\nTypeScript now allows `/// <reference types=\"...\" />` directives.\n\nts\n\n`/// <reference types=\"pkg\" resolution-mode=\"require\" />`\n\n`// or`\n\n`/// <reference types=\"pkg\" resolution-mode=\"import\" />`\n\nAdditionally, in nightly versions of TypeScript, `import type` can specify an import assertion to achieve something similar.\n\nts\n\n`` // Resolve `pkg` as if we were importing with a `require()` ``\n\n`import type { TypeFromRequire } from \"pkg\" assert {`\n\n    `\"resolution-mode\": \"require\"`\n\n`};`\n\n`` // Resolve `pkg` as if we were importing with an `import` ``\n\n`import type { TypeFromImport } from \"pkg\" assert {`\n\n    `\"resolution-mode\": \"import\"`\n\n`};`\n\n`export interface MergedType extends TypeFromRequire, TypeFromImport {}`\n\nThese import assertions can also be used on `import()` types.\n\nts\n\n`export type TypeFromRequire =`\n\n    `import(\"pkg\", { assert: { \"resolution-mode\": \"require\" } }).TypeFromRequire;`\n\n`export type TypeFromImport =`\n\n    `import(\"pkg\", { assert: { \"resolution-mode\": \"import\" } }).TypeFromImport;`\n\n`export interface MergedType extends TypeFromRequire, TypeFromImport {}`\n\nThe `import type` and `import()` syntaxes only support `resolution-mode` in [nightly builds of TypeScript](https://www.typescriptlang.org/docs/handbook/nightly-builds.html). You’ll likely get an error like\n\n`Resolution mode assertions are unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'.`\n\nIf you do find yourself using this feature in nightly versions of TypeScript, [consider providing feedback on this issue](https://github.com/microsoft/TypeScript/issues/49055).\n\nYou can see the respective changes [for reference directives](https://github.com/microsoft/TypeScript/pull/47732) and [for type import assertions](https://github.com/microsoft/TypeScript/pull/47807).\n\n## [](#go-to-source-definition)Go to Source Definition\n\nTypeScript 4.7 contains support for a new experimental editor command called _Go To Source Definition_. It’s similar to _Go To Definition_, but it never returns results inside declaration files. Instead, it tries to find corresponding _implementation_ files (like `.js` or `.ts` files), and find definitions there — even if those files are normally shadowed by `.d.ts` files.\n\nThis comes in handy most often when you need to peek at the implementation of a function you’re importing from a library instead of its type declaration in a `.d.ts` file.\n\n![The \"Go to Source Definition\" command on a use of the yargs package jumps the editor to an index.cjs file in yargs.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/05/go-to-source-definition-4-7-v1.gif)\n\nYou can try this new command in the latest versions of Visual Studio Code. Note, though, that this functionality is still in preview, and there are some known limitations. In some cases TypeScript uses heuristics to guess which `.js` file corresponds to the given result of a definition, so these results might be inaccurate. Visual Studio Code also doesn’t yet indicate whether a result was a guess, but it’s something we’re collaborating on.\n\nYou can leave feedback about the feature, read about known limitations, or learn more at [our dedicated feedback issue](https://github.com/microsoft/TypeScript/issues/49003).\n\n## [](#group-aware-organize-imports)Group-Aware Organize Imports\n\nTypeScript has an _Organize Imports_ editor feature for both JavaScript and TypeScript. Unfortunately, it could be a bit of a blunt instrument, and would often naively sort your import statements.\n\nFor instance, if you ran Organize Imports on the following file…\n\nts\n\n`// local code`\n\n`import * as bbb from \"./bbb\";`\n\n`import * as ccc from \"./ccc\";`\n\n`import * as aaa from \"./aaa\";`\n\n`// built-ins`\n\n`import * as path from \"path\";`\n\n`import * as child_process from \"child_process\"`\n\n`import * as fs from \"fs\";`\n\n`// some code...`\n\nYou would get something like the following\n\nts\n\n`// local code`\n\n`import * as child_process from \"child_process\";`\n\n`import * as fs from \"fs\";`\n\n`// built-ins`\n\n`import * as path from \"path\";`\n\n`import * as aaa from \"./aaa\";`\n\n`import * as bbb from \"./bbb\";`\n\n`import * as ccc from \"./ccc\";`\n\n`// some code...`\n\nThis is… not ideal. Sure, our imports are sorted by their paths, and our comments and newlines are preserved, but not in a way we expected. Much of the time, if we have our imports grouped in a specific way, then we want to keep them that way.\n\nTypeScript 4.7 performs Organize Imports in a group-aware manner. Running it on the above code looks a little bit more like what you’d expect:\n\nts\n\n`// local code`\n\n`import * as aaa from \"./aaa\";`\n\n`import * as bbb from \"./bbb\";`\n\n`import * as ccc from \"./ccc\";`\n\n`// built-ins`\n\n`import * as child_process from \"child_process\";`\n\n`import * as fs from \"fs\";`\n\n`import * as path from \"path\";`\n\n`// some code...`\n\nWe’d like to extend our thanks to [Minh Quy](https://github.com/MQuy) who provided [this feature](https://github.com/microsoft/TypeScript/pull/48330).\n\n## [](#object-method-snippet-completions)Object Method Snippet Completions\n\nTypeScript now provides snippet completions for object literal methods. When completing members in an object, TypeScript will provide a typical completion entry for just the name of a method, along with a separate completion entry for the full method definition!\n\n![Completion a full method signature from an object](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/05/object-method-completions-4-7-v2.gif)\n\nFor more details, [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/48168).\n\n## [](#breaking-changes)Breaking Changes\n\n### [](#libdts-updates)`lib.d.ts` Updates\n\nWhile TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don’t expect major breaks as a result of DOM and `lib.d.ts` updates, but there may be some small ones.\n\n### [](#stricter-spread-checks-in-jsx)Stricter Spread Checks in JSX\n\nWhen writing a `...spread` in JSX, TypeScript now enforces stricter checks that the given type is actually an object. As a result, values with the types `unknown` and `never` (and more rarely, just bare `null` and `undefined`) can no longer be spread into JSX elements.\n\nSo for the following example:\n\ntsx\n\n`import * as React from \"react\";`\n\n`interface Props {`\n\n    `stuff?: string;`\n\n`}`\n\n`function MyComponent(props: unknown) {`\n\n    `return <div {...props} />;`\n\n`}`\n\nyou’ll now receive an error like the following:\n\n`Spread types may only be created from object types.`\n\nThis makes this behavior more consistent with spreads in object literals.\n\nFor more details, [see the change on GitHub](https://github.com/microsoft/TypeScript/pull/48570).\n\n### [](#stricter-checks-with-template-string-expressions)Stricter Checks with Template String Expressions\n\nWhen a `symbol` value is used in a template string, it will trigger a runtime error in JavaScript.\n\njs\n\n``let str = `hello ${Symbol()}`;``\n\n`// TypeError: Cannot convert a Symbol value to a string`\n\nAs a result, TypeScript will issue an error as well; however, TypeScript now also checks if a generic value that is constrained to a symbol in some way is used in a template string.\n\nts\n\n`function logKey<S extends string | symbol>(key: S): S {`\n\n    `// Now an error.`\n\n    ``console.log(`${key} is the key`);``\n\n    `return key;`\n\n`}`\n\n`function get<T, K extends keyof T>(obj: T, key: K) {`\n\n    `// Now an error.`\n\n    ``console.log(`Grabbing property '${key}'.`);``\n\n    `return obj[key];`\n\n`}`\n\nTypeScript will now issue the following error:\n\n`Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'.`\n\nIn some cases, you can get around this by wrapping the expression in a call to `String`, just like the error message suggests.\n\nts\n\n`function logKey<S extends string | symbol>(key: S): S {`\n\n    `// No longer an error.`\n\n    ``console.log(`${String(key)} is the key`);``\n\n    `return key;`\n\n`}`\n\nIn others, this error is too pedantic, and you might not ever care to even allow `symbol` keys when using `keyof`. In such cases, you can switch to `string & keyof ...`:\n\nts\n\n`function get<T, K extends string & keyof T>(obj: T, key: K) {`\n\n    `// No longer an error.`\n\n    ``console.log(`Grabbing property '${key}'.`);``\n\n    `return obj[key];`\n\n`}`\n\nFor more information, you can [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/44578).\n\n### [](#readfile-method-is-no-longer-optional-on-languageservicehost)`readFile` Method is No Longer Optional on `LanguageServiceHost`\n\nIf you’re creating `LanguageService` instances, then provided `LanguageServiceHost`s will need to provide a `readFile` method. This change was necessary to support the new `moduleDetection` compiler option.\n\nYou can [read more on the change here](https://github.com/microsoft/TypeScript/pull/47495).\n\n### [](#readonly-tuples-have-a-readonly-length-property)`readonly` Tuples Have a `readonly` `length` Property\n\nA `readonly` tuple will now treat its `length` property as `readonly`. This was almost never witnessable for fixed-length tuples, but was an oversight which could be observed for tuples with trailing optional and rest element types.\n\nAs a result, the following code will now fail:\n\nts\n\n`function overwriteLength(tuple: readonly [string, string, string]) {`\n\n    `// Now errors.`\n\n    `tuple.length = 7;`\n\n`}`\n\nYou can [read more on this change here](https://github.com/microsoft/TypeScript/pull/47717).",
    "title": "TypeScript: Documentation - TypeScript 4.7",
    "description": "TypeScript 4.7 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.2\n\n## [](#strictbindcallapply)`strictBindCallApply`\n\nTypeScript 3.2 introduces a new [`strictBindCallApply`](https://www.typescriptlang.org/tsconfig#strictBindCallApply) compiler option (in the [`strict`](https://www.typescriptlang.org/tsconfig#strict) family of options) with which the `bind`, `call`, and `apply` methods on function objects are strongly typed and strictly checked.\n\nts\n\n`function foo(a: number, b: string): string {`\n\n  `return a + b;`\n\n`}`\n\n`let a = foo.apply(undefined, [10]); // error: too few arguments`\n\n`let b = foo.apply(undefined, [10, 20]); // error: 2nd argument is a number`\n\n`let c = foo.apply(undefined, [10, \"hello\", 30]); // error: too many arguments`\n\n`let d = foo.apply(undefined, [10, \"hello\"]); // okay! returns a string`\n\nThis is achieved by introducing two new types, `CallableFunction` and `NewableFunction`, in `lib.d.ts`. These types contain specialized generic method declarations for `bind`, `call`, and `apply` for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In [`strictBindCallApply`](https://www.typescriptlang.org/tsconfig#strictBindCallApply) mode these declarations are used in place of the (very permissive) declarations provided by type `Function`.\n\n## [](#caveats)Caveats\n\nSince the stricter checks may uncover previously unreported errors, this is a breaking change in [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode.\n\nAdditionally, [another caveat](https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450) of this new functionality is that due to certain limitations, `bind`, `call`, and `apply` can’t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type (`{}`), and when used on a function with overloads, only the last overload will ever be modeled.\n\n## [](#generic-spread-expressions-in-object-literals)Generic spread expressions in object literals\n\nIn TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the `Object.assign` function and JSX literals. For example:\n\nts\n\n`function taggedObject<T, U extends string>(obj: T, tag: U) {`\n\n  `return { ...obj, tag }; // T & { tag: U }`\n\n`}`\n\n`let x = taggedObject({ x: 10, y: 20 }, \"point\"); // { x: number, y: number } & { tag: \"point\" }`\n\nProperty assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:\n\nts\n\n`function foo1<T>(t: T, obj1: { a: string }, obj2: { b: string }) {`\n\n  `return { ...obj1, x: 1, ...t, ...obj2, y: 2 }; // { a: string, x: number } & T & { b: string, y: number }`\n\n`}`\n\nNon-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:\n\nts\n\n`function spread<T, U>(t: T, u: U) {`\n\n  `return { ...t, ...u }; // T & U`\n\n`}`\n\n`declare let x: { a: string; b: number };`\n\n`declare let y: { b: string; c: boolean };`\n\n`let s1 = { ...x, ...y }; // { a: string, b: string, c: boolean }`\n\n`let s2 = spread(x, y); // { a: string, b: number } & { b: string, c: boolean }`\n\n`let b1 = s1.b; // string`\n\n`let b2 = s2.b; // number & string`\n\n## [](#generic-object-rest-variables-and-parameters)Generic object rest variables and parameters\n\nTypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined `Pick` and `Exclude` helper types from `lib.d.ts`, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.\n\nts\n\n`function excludeTag<T extends { tag: string }>(obj: T) {`\n\n  `let { tag, ...rest } = obj;`\n\n  `return rest; // Pick<T, Exclude<keyof T, \"tag\">>`\n\n`}`\n\n`const taggedPoint = { x: 10, y: 20, tag: \"point\" };`\n\n`const point = excludeTag(taggedPoint); // { x: number, y: number }`\n\n## [](#bigint)BigInt\n\nBigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting `esnext`.\n\nBigInt support in TypeScript introduces a new primitive type called the `bigint` (all lowercase). You can get a `bigint` by calling the `BigInt()` function or by writing out a BigInt literal by adding an `n` to the end of any integer numeric literal:\n\nts\n\n`let foo: bigint = BigInt(100); // the BigInt function`\n\n`let bar: bigint = 100n; // a BigInt literal`\n\n`// *Slaps roof of fibonacci function*`\n\n`// This bad boy returns ints that can get *so* big!`\n\n`function fibonacci(n: bigint) {`\n\n  `let result = 1n;`\n\n  `for (let last = 0n, i = 0n; i < n; i++) {`\n\n    `const current = result;`\n\n    `result += last;`\n\n    `last = current;`\n\n  `}`\n\n  `return result;`\n\n`}`\n\n`fibonacci(10000n);`\n\nWhile you might imagine close interaction between `number` and `bigint`, the two are separate domains.\n\nts\n\n`declare let foo: number;`\n\n`declare let bar: bigint;`\n\n`foo = bar; // error: Type 'bigint' is not assignable to type 'number'.`\n\n`bar = foo; // error: Type 'number' is not assignable to type 'bigint'.`\n\nAs specified in ECMAScript, mixing `number`s and `bigint`s in arithmetic operations is an error. You’ll have to explicitly convert values to `BigInt`s.\n\nts\n\n`console.log(3.141592 * 10000n); // error`\n\n`console.log(3145 * 10n); // error`\n\n`console.log(BigInt(3145) * 10n); // okay!`\n\nAlso important to note is that `bigint`s produce a new string when using the `typeof` operator: the string `\"bigint\"`. Thus, TypeScript correctly narrows using `typeof` as you’d expect.\n\nts\n\n`function whatKindOfNumberIsIt(x: number | bigint) {`\n\n  `if (typeof x === \"bigint\") {`\n\n    `console.log(\"'x' is a bigint!\");`\n\n  `} else {`\n\n    `console.log(\"'x' is a floating-point number\");`\n\n  `}`\n\n`}`\n\nWe’d like to extend a huge thanks to [Caleb Sander](https://github.com/calebsander) for all the work on this feature. We’re grateful for the contribution, and we’re sure our users are too!\n\n## [](#caveats-1)Caveats\n\nAs we mentioned, BigInt support is only available for the `esnext` target. It may not be obvious, but because BigInts have different behavior for mathematical operators like `+`, `-`, `*`, etc., providing functionality for older targets where the feature doesn’t exist (like `es2017` and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.\n\nFor that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you’ll be able to use BigInts there when targeting `esnext`.\n\nCertain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add `esnext.bigint` to the [`lib`](https://www.typescriptlang.org/tsconfig#lib) setting in your compiler options.\n\n## [](#non-unit-types-as-union-discriminants)Non-unit types as union discriminants\n\nTypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property. Common properties of unions are now considered discriminants as long as they contain _some_ singleton type (e.g. a string literal, `null`, or `undefined`), and they contain no generics.\n\nAs a result, TypeScript 3.2 considers the `error` property in the following example to be a discriminant, whereas before it wouldn’t since `Error` isn’t a singleton type. Thanks to this, narrowing works correctly in the body of the `unwrap` function.\n\nts\n\n`type Result<T> = { error: Error; data: null } | { error: null; data: T };`\n\n`function unwrap<T>(result: Result<T>) {`\n\n  `if (result.error) {`\n\n    `// Here 'error' is non-null`\n\n    `throw result.error;`\n\n  `}`\n\n  `// Now 'data' is non-null`\n\n  `return result.data;`\n\n`}`\n\n## [](#tsconfigjson-inheritance-via-nodejs-packages)`tsconfig.json` inheritance via Node.js packages\n\nTypeScript 3.2 now resolves `tsconfig.json`s from `node_modules`. When using a bare path for the `extends` field in `tsconfig.json`, TypeScript will dive into `node_modules` packages for us.\n\n`{`\n\n  `\"\": \"@my-team/tsconfig-base\",`\n\n  `\"\": [\"./**/*\"],`\n\n  `\"\": {`\n\n    `// Override certain options on a project-by-project basis.`\n\n    `\"\": false`\n\n  `}`\n\n`}`\n\nHere, TypeScript will climb up `node_modules` folders looking for a `@my-team/tsconfig-base` package. For each of those packages, TypeScript will first check whether `package.json` contains a `\"tsconfig\"` field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a `tsconfig.json` at the root. This is similar to the lookup process for `.js` files in packages that Node uses, and the `.d.ts` lookup process that TypeScript already uses.\n\nThis feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.\n\n## [](#the-new---showconfig-flag)The new `--showConfig` flag\n\n`tsc`, the TypeScript compiler, supports a new flag called `--showConfig`. When running `tsc --showConfig`, TypeScript will calculate the effective `tsconfig.json` (after calculating options inherited from the `extends` field) and print that out. This can be useful for diagnosing configuration issues in general.\n\n## [](#objectdefineproperty-declarations-in-javascript)`Object.defineProperty` declarations in JavaScript\n\nWhen writing in JavaScript files (using [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)), TypeScript now recognizes declarations that use `Object.defineProperty`. This means you’ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs) option or adding a `// @ts-check` comment to the top of your file).\n\njs\n\n`// @ts-check`\n\n`let obj = {};`\n\n`Object.defineProperty(obj, \"x\", { value: \"hello\", writable: false });`\n\n`obj.x.toLowercase();`\n\n`//    ~~~~~~~~~~~`\n\n`//    error:`\n\n`//     Property 'toLowercase' does not exist on type 'string'.`\n\n`//     Did you mean 'toLowerCase'?`\n\n`obj.x = \"world\";`\n\n`//  ~`\n\n`//  error:`\n\n`//   Cannot assign to 'x' because it is a read-only property.`",
    "title": "TypeScript: Documentation - TypeScript 3.2",
    "description": "TypeScript 3.2 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.4\n\n## [](#control-flow-analysis-of-aliased-conditions-and-discriminants)Control Flow Analysis of Aliased Conditions and Discriminants\n\nIn JavaScript, we often have to probe a value in different ways, and do something different once we know more about its type. TypeScript understands these checks and calls them _type guards_. Instead of having to convince TypeScript of a variable’s type whenever we use it, the type-checker leverages something called _control flow analysis_ to see if we’ve used a type guard before a given piece of code.\n\nFor example, we can write something like\n\nts\n\n`function foo(arg: unknown) {`\n\n  `if (typeof arg === \"string\") {`\n\n    `console.log(arg.toUpperCase());`\n\n                `(parameter) arg: string`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMOcAUBDATgcwFyLgDWYcA7mAJSIDeAUIojMImlAJ4AOApnC9jkQBeEYgBEAZyhYYYHGOr1GjCAglwANtwB0GuDky5tUOAFVOPLAGEME7mkqUA3A2UB6N8q9eAegH5XAF86QKA)\n\nIn this example, we checked whether `arg` was a `string`. TypeScript recognized the `typeof arg === \"string\"` check, which it considered a type guard, and knew that `arg` was a `string` inside the body of the `if` block. That let us access `string` methods like `toUpperCase()` without getting an error.\n\nHowever, what would happen if we moved the condition out to a constant called `argIsString`?\n\nts\n\n`// In TS 4.3 and below`\n\n`function foo(arg: unknown) {`\n\n  `const argIsString = typeof arg === \"string\";`\n\n  `if (argIsString) {`\n\n    `console.log(arg.toUpperCase());`\n\n    `//              ~~~~~~~~~~~`\n\n    `// Error! Property 'toUpperCase' does not exist on type 'unknown'.`\n\n  `}`\n\n`}`\n\nIn previous versions of TypeScript, this would be an error - even though `argIsString` was assigned the value of a type guard, TypeScript simply lost that information. That’s unfortunate since we might want to re-use the same check in several places. To get around that, users often have to repeat themselves or use type assertions (a.k.a. casts).\n\nIn TypeScript 4.4, that is no longer the case. The above example works with no errors! When TypeScript sees that we are testing a constant value, it will do a little bit of extra work to see if it contains a type guard. If that type guard operates on a `const`, a `readonly` property, or an un-modified parameter, then TypeScript is able to narrow that value appropriately.\n\nDifferent sorts of type guard conditions are preserved - not just `typeof` checks. For example, checks on discriminated unions work like a charm.\n\nts\n\n`type Shape =`\n\n  `| { kind: \"circle\"; radius: number }`\n\n  `| { kind: \"square\"; sideLength: number };`\n\n`function area(shape: Shape): number {`\n\n  `const isCircle = shape.kind === \"circle\";`\n\n  `if (isCircle) {`\n\n    `// We know we have a circle here!`\n\n    `return Math.PI * shape.radius ** 2;`\n\n  `} else {`\n\n    `// We know we're left with a square here!`\n\n    `return shape.sideLength ** 2;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwFEyEADIQSAc2BxhYydJns0aAGZ8StYEQD2JKFogIAFAKIkFTwSBAAlFYSUnjytF4CwFBEAgDCjCzQKFBB4QB0xOSoKDl0mawc8kSOUP6pGUysEXGYmAD07VAA6tAEJB4A7lCD0IgAbtAIUPRNY1IQAITymNrAfAzeALIIFvkACgCSUABUucEQ+dy8gqdnAEz2mDJQEMwC0LgrUJ09fQPDUYAcm0UFYjmSgyIFh8uQ0vigcAWyzaXAg6025wKegMxjMMJODyesjQMiAA)\n\nAnalysis on discriminants in 4.4 also goes a little bit deeper - we can now extract out discriminants and TypeScript can narrow the original object.\n\nts\n\n`type Shape =`\n\n  `| { kind: \"circle\"; radius: number }`\n\n  `| { kind: \"square\"; sideLength: number };`\n\n`function area(shape: Shape): number {`\n\n  `// Extract out the 'kind' field first.`\n\n  `const { kind } = shape;`\n\n  `if (kind === \"circle\") {`\n\n    `// We know we have a circle here!`\n\n    `return Math.PI * shape.radius ** 2;`\n\n  `} else {`\n\n    `// We know we're left with a square here!`\n\n    `return shape.sideLength ** 2;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwFEyEADIQSAc2BxhYydJns0aAGZ8StYEQD2JKFogIAFAKIkFTwSBAAlFYSUnjyAPTxUACiAB7A3G5QHnzAUBbQAOTE5IVQjkQQzGTljALAAHTytF71iiU1MqhQQeH28kSOUP4dqCgoNPRMrNQRcZiYiVAA6tAEJB4A7lCb0IgAbtAIUFMse1IQAITymNrAfAzeALIIFg0ACgCSUABUPcEQBrcXiCX5-ABM9kwXSqAmguBuUCWq0IG22u0K2igrEceU2RAsPh6Gl8UDgF2uCy4EHuj3+4QaegMxjMhJ+EKhsjQMiAA)\n\nAs another example, here’s a function that checks whether two of its inputs have contents.\n\nts\n\n`function doSomeChecks(`\n\n  `inputA: string | undefined,`\n\n  `inputB: string | undefined,`\n\n  `shouldDoExtraWork: boolean`\n\n`) {`\n\n  `const mustDoWork = inputA && inputB && shouldDoExtraWork;`\n\n  `if (mustDoWork) {`\n\n    `// We can access 'string' properties on both 'inputA' and 'inputB'!`\n\n    `const upperA = inputA.toUpperCase();`\n\n    `const upperB = inputB.toUpperCase();`\n\n    `// ...`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKYGEAW2EA1gM4AUAUIojGAA4hQCCAXIqVAE50DmiAH0Thk2YHWzIANNVoMmAIXaceYfkJFiJ02aXxwQAG2QAROAFEAHtwCGAdThdi7AEZw4h7DbCUAlIgBvWQgETkRMEE4zBydEAF45RhZEADIUxMVU9L0DYzMrWxjiAG5ZGGBEcgiouCL-IJoaAHomxDtsRAhvRBsICGxSUkQAchU+YcR6Ljh6bC5YAcQERDcofBG6JOYJ72QN+SgFYYBCWRoQsDCQelmuZniMlgA6KDgAVRu53BtSbHJfUqNTqhKDCT5cBQPTaKF7vcHfX7-QGNFqIJ7o2QAX0omKAA)\n\nTypeScript can understand that both `inputA` and `inputB` are both present if `mustDoWork` is `true`. That means we don’t have to write a non-null assertion like `inputA!` to convince TypeScript that `inputA` isn’t `undefined`.\n\nOne neat feature here is that this analysis works transitively. TypeScript will hop through constants to understand what sorts of checks you’ve already performed.\n\nts\n\n`function f(x: string | number | boolean) {`\n\n  `const isString = typeof x === \"string\";`\n\n  `const isNumber = typeof x === \"number\";`\n\n  `const isStringOrNumber = isString || isNumber;`\n\n  `if (isStringOrNumber) {`\n\n    `x;`\n\n   `(parameter) x: string | number`\n\n  `} else {`\n\n    `x;`\n\n   `(parameter) x: boolean`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwFyIM5QE4xgDmiAPomCALYBGApnmYjXHADZ0CGYAlIgN4AoRIggJciGNgDK+QiQC8iKAE8ADnTjBEaRAv2IARLgLFDAbmGjxUSdgBy1eoyWqNWnXoOHKtBhasxMAkpWVMiAHk8Rz8XOzD5MnIpGOdLERhtFFC5YijUhj4hERE0SwB6cpEAPQB+KwBfRDo2bDoBK1KKqsQ6xsEGoA)\n\nNote that there’s a cutoff - TypeScript doesn’t go arbitrarily deep when checking these conditions, but its analysis is deep enough for most checks.\n\nThis feature should make a lot of intuitive JavaScript code “just work” in TypeScript without it getting in your way. For more details, [check out the implementation on GitHub](https://github.com/microsoft/TypeScript/pull/44730)!\n\n## [](#symbol-and-template-string-pattern-index-signatures)Symbol and Template String Pattern Index Signatures\n\nTypeScript lets us describe objects where every property has to have a certain type using _index signatures_. This allows us to use these objects as dictionary-like types, where we can use string keys to index into them with square brackets.\n\nFor example, we can write a type with an index signature that takes `string` keys and maps to `boolean` values. If we try to assign anything other than a `boolean` value, we’ll get an error.\n\nts\n\n`interface BooleanDictionary {`\n\n  `[key: string]: boolean;`\n\n`}`\n\n`declare let myDict: BooleanDictionary;`\n\n`// Valid to assign boolean values`\n\n`myDict[\"foo\"] = true;`\n\n`myDict[\"bar\"] = false;`\n\n`// Error, \"oops\" isn't a boolean`\n\n`myDict[\"baz\"] = \"oops\";`\n\n`Type 'string' is not assignable to type 'boolean'.2322Type 'string' is not assignable to type 'boolean'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vRg7AKwBQAlgHYAuMAZgIYDGkoAQnHADaS1kAiJ9FEnDK1oAT1ABvIqFABtANaQxqRBWjkA5gF1UAIzaduAbiIBfIkQAmkeu1FNOFUAFsxfAalYcuvfoOFRMVMiEFAANVp2EitQCjhQWkREEk0yUAMfblAANyiAV0hEIjcPCjkAImo2Cu1QAF446ELTUv9KvVFahtA6dkRIELCAUVgEABpQCrYAB0QK0BJEMgByZ1oMw18S93aKzoAvbsbpuDmK4yA)\n\nWhile [a `Map` might be a better data structure here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) (specifically, a `Map<string, boolean>`), JavaScript objects are often more convenient to use or just happen to be what we’re given to work with.\n\nSimilarly, `Array<T>` already defines a `number` index signature that lets us insert/retrieve values of type `T`.\n\nts\n\n`// @errors: 2322 2375`\n\n`// This is part of TypeScript's definition of the built-in Array type.`\n\n`interface Array<T> {`\n\n  `[index: number]: T;`\n\n  `// ...`\n\n`}`\n\n`let arr = new Array<string>();`\n\n`// Valid`\n\n`arr[0] = \"hello!\";`\n\n`// Error, expecting a 'string' value here`\n\n`arr[1] = 123;`\n\nIndex signatures are very useful to express lots of code out in the wild; however, until now they’ve been limited to `string` and `number` keys (and `string` index signatures have an intentional quirk where they can accept `number` keys since they’ll be coerced to strings anyway). That means that TypeScript didn’t allow indexing objects with `symbol` keys. TypeScript also couldn’t model an index signature of some _subset_ of `string` keys - for example, an index signature which describes just properties whose names start with the text `data-`.\n\nTypeScript 4.4 addresses these limitations, and allows index signatures for `symbol`s and template string patterns.\n\nFor example, TypeScript now allows us to declare a type that can be keyed on arbitrary `symbol`s.\n\nts\n\n`interface Colors {`\n\n  `[sym: symbol]: number;`\n\n`}`\n\n`const red = Symbol(\"red\");`\n\n`const green = Symbol(\"green\");`\n\n`const blue = Symbol(\"blue\");`\n\n`let colors: Colors = {};`\n\n`// Assignment of a number is allowed`\n\n`colors[red] = 255;`\n\n`let redVal = colors[red];`\n\n      `let redVal: number`\n\n`colors[blue] = \"da ba dee\";`\n\n`Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vRg7AKwBQAlgHYAuMAZgIYDGkoAwnADYKKgDeRooAbUQBPALaoRogEbsAuqjIBXaTADcRAL5Ei9OGUQVQ0SABNQAXlABlMTLYAKAETGTjgJTrd+wwHNjkMgtrW3YnP0gA9089A1ApNkUmSxtpUMd4xKjtNkhDXQ4kVFYCrktuDXUiEFAAQUREEh8yUQDDOGpQWlAlFWhQEi5aNg4Ad1Mddk4BF1kgtAICdRzDFwA1IaD8qZn1atAAPQB+bS2kAQzIWctHEy6pLpMIx1UgA)\n\nSimilarly, we can write an index signature with template string pattern type. One use of this might be to exempt properties starting with `data-` from TypeScript’s excess property checking. When we pass an object literal to something with an expected type, TypeScript will look for excess properties that weren’t declared in the expected type.\n\nts\n\n`// @errors: 2322 2375`\n\n`interface Options {`\n\n    `width?: number;`\n\n    `height?: number;`\n\n`}`\n\n`let a: Options = {`\n\n    `width: 100,`\n\n    `height: 100,`\n\n    `\"data-blah\": true,`\n\n`};`\n\n`interface OptionsWithDataProps extends Options {`\n\n    `// Permit any property starting with 'data-'.`\n\n    ``[optName: `data-${string}`]: unknown;``\n\n`}`\n\n`let b: OptionsWithDataProps = {`\n\n    `width: 100,`\n\n    `height: 100,`\n\n    `\"data-blah\": true,`\n\n    `// Fails for a property which is not known, nor`\n\n    `// starts with 'data-'`\n\n    `\"unknown-property\": true,`\n\n`};`\n\nA final note on index signatures is that they now permit union types, as long as they’re a union of infinite-domain primitive types - specifically:\n\n*   `string`\n*   `number`\n*   `symbol`\n*   template string patterns (e.g. `` `hello-${string}` ``)\n\nAn index signature whose argument is a union of these types will de-sugar into several different index signatures.\n\nts\n\n`interface Data {`\n\n  `[optName: string | symbol]: any;`\n\n`}`\n\n`// Equivalent to`\n\n`interface Data {`\n\n  `[optName: string]: any;`\n\n  `[optName: symbol]: any;`\n\n`}`\n\nFor more details, [read up on the pull request](https://github.com/microsoft/TypeScript/pull/44512)\n\n## [](#defaulting-to-the-unknown-type-in-catch-variables---useunknownincatchvariables)Defaulting to the `unknown` Type in Catch Variables (`--useUnknownInCatchVariables`)\n\nIn JavaScript, any type of value can be thrown with `throw` and caught in a `catch` clause. Because of this, TypeScript historically typed catch clause variables as `any`, and would not allow any other type annotation:\n\nts\n\n`try {`\n\n  `// Who knows what this might throw...`\n\n  `executeSomeThirdPartyCode();`\n\n`} catch (err) {`\n\n  `// err: any`\n\n  `console.error(err.message); // Allowed, because 'any'`\n\n  `err.thisWillProbablyFail(); // Allowed, because 'any' :(`\n\n`}`\n\nOnce TypeScript added the `unknown` type, it became clear that `unknown` was a better choice than `any` in `catch` clause variables for users who want the highest degree of correctness and type-safety, since it narrows better and forces us to test against arbitrary values. Eventually TypeScript 4.0 allowed users to specify an explicit type annotation of `unknown` (or `any`) on each `catch` clause variable so that we could opt into stricter types on a case-by-case basis; however, for some, manually specifying `: unknown` on every `catch` clause was a chore.\n\nThat’s why TypeScript 4.4 introduces a new flag called [`useUnknownInCatchVariables`](https://www.typescriptlang.org/tsconfig#useUnknownInCatchVariables). This flag changes the default type of `catch` clause variables from `any` to `unknown`.\n\nts\n\n`try {`\n\n  `executeSomeThirdPartyCode();`\n\n`} catch (err) {`\n\n  `// err: unknown`\n\n  `// Error! Property 'message' does not exist on type 'unknown'.`\n\n  `console.error(err.message);`\n\n`'err' is of type 'unknown'.18046'err' is of type 'unknown'.    // Works! We can narrow 'err' from 'unknown' to 'Error'.    if (err instanceof Error) {      console.error(err.message);    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AKABNIBjAGwENpJQAzAVwDtaAXASzhdQkAB50OvSAGU4AW0gAVABb9oVAArNeATwDCcGgAoAlKgBucflQDcFEKAC0z2pOeOKvaDtABvCqAi4q5Ssgoqapra+oaQpnYAvqC0jLy0yqBGMNAmfgGgDtmo3ADWXHAA7lwU+Q4AorAIAISgGvAADjC6oADkCoiIjADmkD2gVHCQiKDlvEH8iHNCoLqdvaXlVT0AdPm0Qohw9JDb2QhZsNv9gyMmdrVgAOoIJYgtj6wpwlzM8BW92TGbHgcnWXDKlS4Y14cF6DXg0B2+X4bEy2VA-C4i0YPEgcFR8IQuX8gUC+yxRxOZ2gF2gVymN0gd3yCQoCSAA)\n\nThis flag is enabled under the [`strict`](https://www.typescriptlang.org/tsconfig#strict) family of options. That means that if you check your code using [`strict`](https://www.typescriptlang.org/tsconfig#strict), this option will automatically be turned on. You may end up with errors in TypeScript 4.4 such as\n\n`Property 'message' does not exist on type 'unknown'.`\n\n`Property 'name' does not exist on type 'unknown'.`\n\n`Property 'stack' does not exist on type 'unknown'.`\n\nIn cases where we don’t want to deal with an `unknown` variable in a `catch` clause, we can always add an explicit `: any` annotation so that we can opt _out_ of stricter types.\n\nts\n\n`try {`\n\n  `executeSomeThirdPartyCode();`\n\n`} catch (err: any) {`\n\n  `console.error(err.message); // Works again!`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXxAA9xkMQBlHAWxABUALLGYABVgwE8BhHUACgCUALngA3HFmABuAFAB6OfAC0KsKRVKZGGB3gBvGfALE1ZSjQZNW7brxCDZAX3hgoGMPXh8QMGCKioHAL6hi54AM44ECAAdD4wODDevjE04eFQAOYgAlLwCvAA6okA1uHwWVBYqACEMo5AA)\n\nFor more information, take a look at [the implementing pull request](https://github.com/microsoft/TypeScript/pull/41013).\n\n## [](#exact-optional-property-types---exactoptionalpropertytypes)Exact Optional Property Types (`--exactOptionalPropertyTypes`)\n\nIn JavaScript, reading a _missing_ property on an object produces the value `undefined`. It’s also possible to _have_ an actual property with the value `undefined`. A lot of code in JavaScript tends to treat these situations the same way, and so initially TypeScript just interpreted every optional property as if a user had written `undefined` in the type. For example,\n\nts\n\n`interface Person {`\n\n  `name: string;`\n\n  `age?: number;`\n\n`}`\n\nwas considered equivalent to\n\nts\n\n`interface Person {`\n\n  `name: string;`\n\n  `age?: number | undefined;`\n\n`}`\n\nWhat this meant is that a user could explicitly write `undefined` in place of `age`.\n\nts\n\n`const p: Person = {`\n\n  `name: \"Daniel\",`\n\n  `age: undefined, // This is okay by default.`\n\n`};`\n\nSo by default, TypeScript doesn’t distinguish between a present property with the value `undefined` and a missing property. While this works most of the time, not all code in JavaScript makes the same assumptions. Functions and operators like `Object.assign`, `Object.keys`, object spread (`{ ...obj }`), and `for`\\-`in` loops behave differently depending on whether or not a property actually exists on an object. In the case of our `Person` example, this could potentially lead to runtime errors if the `age` property was observed in a context where its presence was important.\n\nIn TypeScript 4.4, the new flag [`exactOptionalPropertyTypes`](https://www.typescriptlang.org/tsconfig#exactOptionalPropertyTypes) specifies that optional property types should be interpreted exactly as written, meaning that `| undefined` is not added to the type:\n\nts\n\n`// With 'exactOptionalPropertyTypes' on:`\n\n`const p: Person = {`\n\n`Type '{ name: string; age: undefined; }' is not assignable to type 'Person' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.   Types of property 'age' are incompatible.     Type 'undefined' is not assignable to type 'number'.2375Type '{ name: string; age: undefined; }' is not assignable to type 'Person' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.   Types of property 'age' are incompatible.     Type 'undefined' is not assignable to type 'number'.    name: \"Daniel\",    age: undefined, // Error! undefined isn't a number  };  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8EMGMAuB5ADoglgewHawDYAKATlqpMYgJ4AqV5AzgFAgQWnEMBcoATAMy9effgHYArEww5EFAGYJIoQhQa5QAbyahQeALaQeDRMWkBzANzbQsM5AD8PHAFc9AIwpWAvizABaAPhnRAC-X1AAdQxEAAtQAHIYBBR0bDwiUnJKWnpIBnjQXC4meFxjUFQeFU51AF5Na31DUAAiABFYHAxIfBaAGmtbZuccABNIOWlIUb7QVgBRYg4AQlAR8cmcadAMBhx4xBtdVw9iJi8LIA)\n\nThis flag is **not** part of the [`strict`](https://www.typescriptlang.org/tsconfig#strict) family and needs to be turned on explicitly if you’d like this behavior. It also requires [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) to be enabled as well. We’ve been making updates to DefinitelyTyped and other definitions to try to make the transition as straightforward as possible, but you may encounter some friction with this depending on how your code is structured.\n\nFor more information, you can [take a look at the implementing pull request here](https://github.com/microsoft/TypeScript/pull/43947).\n\n## [](#static-blocks-in-classes)`static` Blocks in Classes\n\nTypeScript 4.4 brings support for [`static` blocks in classes](https://github.com/tc39/proposal-class-static-block#ecmascript-class-static-initialization-blocks), an upcoming ECMAScript feature that can help you write more-complex initialization code for static members.\n\nts\n\n`class Foo {`\n\n    `static count = 0;`\n\n    `// This is a static block:`\n\n    `static {`\n\n        `if (someCondition()) {`\n\n            `Foo.count++;`\n\n        `}`\n\n    `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwGccBbEAYT2C2zwAoBKALngCMccIQpUAoAej7wAtCLDIMIoT0hQCBeADF28AN494GwhijYw8MDjQZ4AXngAGANw91mgfAAqACyzzX8KFp1Y9LCDjAAa0ZbDQJtXVVQzQ0sRHhaIlIKVCoaVAZ6KJiczSUcADoDIwBqEutcjQBfaJqqoA)\n\nThese static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. That means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.\n\nts\n\n`class Foo {`\n\n    `static #count = 0;`\n\n    `get count() {`\n\n        `return Foo.#count;`\n\n    `}`\n\n    `static {`\n\n        `try {`\n\n            `const lastInstances = loadLastInstances();`\n\n            `Foo.#count += lastInstances.length;`\n\n        `}`\n\n        `catch {}`\n\n    `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwhymABkoBnDASVUqnRHIAoBKALnnoE8BtAXQBQAeiHwAtBLDIMEsQMgVy8AGI4c8AN4D4O+HWxh4AYjA40GeAF54ABgDcA7boDmIC6fOtNT3brgZkGHxVHAA6EzNUDAdfAF9HX30sQy1fXwwYLm80nPhTWgtoSho6BiVrQmIyYoL6MEZWGNzfEPCPKPgAagqKalqy0IgQVGcMAAsmnPjmsCgMMDHNad142KA)\n\nWithout `static` blocks, writing the code above was possible, but often involved several different types of hacks that had to compromise in some way.\n\nNote that a class can have multiple `static` blocks, and they’re run in the same order in which they’re written.\n\nts\n\n`// Prints:`\n\n`//    1`\n\n`//    2`\n\n`//    3`\n\n`class Foo {`\n\n    `static prop = 1`\n\n    `static {`\n\n        `console.log(Foo.prop++);`\n\n    `}`\n\n    `static {`\n\n        `console.log(Foo.prop++);`\n\n    `}`\n\n    `static {`\n\n        `console.log(Foo.prop++);`\n\n    `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAUCcEsDsBcDOAuAUCUnQEZ1iwEx5agDMqAxgDYCGiioAYgPbOgDeqJi8N80FUAAdIzIaAC8OLlh58BHGSUwVmsRMyoBTAHRVmAcwAULZjpFiA1JYCUAbiWgAvo7n9BnZVlXrNu-cam5qJC1vaOLty87opeKmoa2nqGJqzBVrYOJC5OQA)\n\nWe’d like to extend our thanks to [Wenlu Wang](https://github.com/Kingwl) for TypeScript’s implementation of this feature. For more details, you can [see that pull request here](https://github.com/microsoft/TypeScript/pull/43370).\n\n## [](#tsc---help-updates-and-improvements)`tsc --help` Updates and Improvements\n\nTypeScript’s `--help` option has gotten a refresh! Thanks to work in part by [Song Gao](https://github.com/ShuiRuTian), we’ve brought in changes to [update the descriptions of our compiler options](https://github.com/microsoft/TypeScript/pull/44409) and [restyle the `--help` menu](https://github.com/microsoft/TypeScript/pull/44157) with colors and other visual separation.\n\n![The new TypeScript --help menu where the output is bucketed into several different areas](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/tsc-help-ps-wt-4-4.png)\n\nYou can read more on [the original proposal thread](https://github.com/microsoft/TypeScript/issues/44074).\n\n## [](#performance-improvements)Performance Improvements\n\n### [](#faster-declaration-emit)Faster Declaration Emit\n\nTypeScript now caches whether internal symbols are accessible in different contexts, along with how specific types should be printed. These changes can improve TypeScript’s general performance in code with fairly complex types, and is especially observed when emitting `.d.ts` files under the [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) flag.\n\n[See more details here](https://github.com/microsoft/TypeScript/pull/43973).\n\n### [](#faster-path-normalization)Faster Path Normalization\n\nTypeScript often has to do several types of “normalization” on file paths to get them into a consistent format that the compiler can use everywhere. This involves things like replacing backslashes with slashes, or removing intermediate `/./` and `/../` segments of paths. When TypeScript has to operate over millions of these paths, these operations end up being a bit slow. In TypeScript 4.4, paths first undergo quick checks to see whether they need any normalization in the first place. These improvements together reduce project load time by 5-10% on bigger projects, and significantly more in massive projects that we’ve tested internally.\n\nFor more details, you can [view the PR for path segment normalization](https://github.com/microsoft/TypeScript/pull/44173) along with [the PR for slash normalization](https://github.com/microsoft/TypeScript/pull/44100).\n\n### [](#faster-path-mapping)Faster Path Mapping\n\nTypeScript now caches the way it constructs path-mappings (using the [`paths`](https://www.typescriptlang.org/tsconfig#paths) option in `tsconfig.json`). For projects with several hundred mappings, the reduction is significant. You can see more [on the change itself](https://github.com/microsoft/TypeScript/pull/44078).\n\n### [](#faster-incremental-builds-with---strict)Faster Incremental Builds with `--strict`\n\nIn what was effectively a bug, TypeScript would end up redoing type-checking work under [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) compilations if [`strict`](https://www.typescriptlang.org/tsconfig#strict) was on. This led to many builds being just as slow as if [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) was turned off. TypeScript 4.4 fixes this, though the change has also been back-ported to TypeScript 4.3.\n\nSee more [here](https://github.com/microsoft/TypeScript/pull/44394).\n\n### [](#faster-source-map-generation-for-big-outputs)Faster Source Map Generation for Big Outputs\n\nTypeScript 4.4 adds an optimization for source map generation on extremely large output files. When building an older version of the TypeScript compiler, this results in around an 8% reduction in emit time.\n\nWe’d like to extend our thanks to [David Michon](https://github.com/dmichon-msft) who provided a [simple and clean change](https://github.com/microsoft/TypeScript/pull/44031) to enable this performance win.\n\n### [](#faster---force-builds)Faster `--force` Builds\n\nWhen using `--build` mode on project references, TypeScript has to perform up-to-date checks to determine which files need to be rebuilt. When performing a [`--force`](https://www.typescriptlang.org/tsconfig#force) build, however, that information is irrelevant since every project dependency will be rebuilt from scratch. In TypeScript 4.4, [`--force`](https://www.typescriptlang.org/tsconfig#force) builds avoid those unnecessary steps and start a full build. See more about the change [here](https://github.com/microsoft/TypeScript/pull/43666).\n\n## [](#spelling-suggestions-for-javascript)Spelling Suggestions for JavaScript\n\nTypeScript powers the JavaScript editing experience in editors like Visual Studio and Visual Studio Code. Most of the time, TypeScript tries to stay out of the way in JavaScript files; however, TypeScript often has a lot of information to make confident suggestions, and ways of surfacing suggestions that aren’t _too_ invasive.\n\nThat’s why TypeScript now issues spelling suggestions in plain JavaScript files - ones without `// @ts-check` or in a project with [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs) turned off. These are the same _“Did you mean…?”_ suggestions that TypeScript files already have, and now they’re available in _all_ JavaScript files in some form.\n\nThese spelling suggestions can provide a subtle clue that your code is wrong. We managed to find a few bugs in existing code while testing this feature!\n\nFor more details on this new feature, [take a look at the pull request](https://github.com/microsoft/TypeScript/pull/44271)!\n\n## [](#inlay-hints)Inlay Hints\n\nTypeScript 4.4 provides support for _inlay hints_ which can help display useful information like parameter names and return types in your code. You can think of it as a sort of friendly “ghost text”.\n\n![A preview of inlay hints in Visual Studio Code](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/inlayHints-4.4-rc-ghd.png)\n\nThis feature was built by [Wenlu Wang](https://github.com/Kingwl) whose [pull request](https://github.com/microsoft/TypeScript/pull/42089) has more details.\n\nWenlu also contributed [the integration for inlay hints in Visual Studio Code](https://github.com/microsoft/vscode/pull/113412) which has shipped as [part of the July 2021 (1.59) release](https://code.visualstudio.com/updates/v1_59#_typescript-44). If you’d like to try inlay hints out, make sure you’re using a recent [stable](https://code.visualstudio.com/updates/v1_59) or [insiders](https://code.visualstudio.com/insiders/) version of the editor. You can also modify when and where inlay hints get displayed in Visual Studio Code’s settings.\n\n## [](#auto-imports-show-true-paths-in-completion-lists)Auto-Imports Show True Paths in Completion Lists\n\nWhen editors like Visual Studio Code show a completion list, completions which include auto-imports are displayed with a path to the given module; however, this path usually isn’t what TypeScript ends up placing in a module specifier. The path is usually something relative to the _workspace_, meaning that if you’re importing from a package like `moment`, you’ll often see a path like `node_modules/moment`.\n\n![A completion list containing unwieldy paths containing 'node_modules'. For example, the label for 'calendarFormat' is 'node_modules/moment/moment' instead of 'moment'.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/completion-import-labels-pre-4-4.png)\n\nThese paths end up being unwieldy and often misleading, especially given that the path that actually gets inserted into your file needs to consider Node’s `node_modules` resolution, path mappings, symlinks, and re-exports.\n\nThat’s why with TypeScript 4.4, the completion item label now shows the _actual_ module path that will be used for the import!\n\n![A completion list containing clean paths with no intermediate 'node_modules'. For example, the label for 'calendarFormat' is 'moment' instead of 'node_modules/moment/moment'.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/completion-import-labels-4-4.png)\n\nSince this calculation can be expensive, completion lists containing many auto-imports may fill in the final module specifiers in batches as you type more characters. It’s possible that you’ll still sometimes see the old workspace-relative path labels; however, as your editing experience “warms up”, they should get replaced with the actual path after another keystroke or two.\n\n## [](#breaking-changes)Breaking Changes\n\n### [](#libdts-changes-for-typescript-44)`lib.d.ts` Changes for TypeScript 4.4\n\nAs with every TypeScript version, declarations for `lib.d.ts` (especially the declarations generated for web contexts), have changed. You can consult [our list of known `lib.dom.d.ts` changes](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1029#issuecomment-869224737) to understand what is impacted.\n\n### [](#more-compliant-indirect-calls-for-imported-functions)More-Compliant Indirect Calls for Imported Functions\n\nIn earlier versions of TypeScript, calling an import from CommonJS, AMD, and other non-ES module systems would set the `this` value of the called function. Specifically, in the following example, when calling `fooModule.foo()`, the `foo()` method will have `fooModule` set as the value of `this`.\n\nts\n\n`// Imagine this is our imported module, and it has an export named 'foo'.`\n\n`let fooModule = {`\n\n  `foo() {`\n\n    `console.log(this);`\n\n  `},`\n\n`};`\n\n`fooModule.foo();`\n\nThis is not the way exported functions in ECMAScript are supposed to work when we call them. That’s why TypeScript 4.4 intentionally discards the `this` value when calling imported functions, by using the following emit.\n\nts\n\n`// Imagine this is our imported module, and it has an export named 'foo'.`\n\n`let fooModule = {`\n\n  `foo() {`\n\n    `console.log(this);`\n\n  `},`\n\n`};`\n\n`// Notice we're actually calling '(0, fooModule.foo)' now, which is subtly different.`\n\n`(0, fooModule.foo)();`\n\nYou can [read up more about the changes here](https://github.com/microsoft/TypeScript/pull/44624).\n\n### [](#using-unknown-in-catch-variables)Using `unknown` in Catch Variables\n\nUsers running with the [`strict`](https://www.typescriptlang.org/tsconfig#strict) flag may see new errors around `catch` variables being `unknown`, especially if the existing code assumes only `Error` values have been caught. This often results in error messages such as:\n\n`Property 'message' does not exist on type 'unknown'.`\n\n`Property 'name' does not exist on type 'unknown'.`\n\n`Property 'stack' does not exist on type 'unknown'.`\n\nTo get around this, you can specifically add runtime checks to ensure that the thrown type matches your expected type. Otherwise, you can just use a type assertion, add an explicit `: any` to your catch variable, or turn off [`useUnknownInCatchVariables`](https://www.typescriptlang.org/tsconfig#useUnknownInCatchVariables).\n\n### [](#broader-always-truthy-promise-checks)Broader Always-Truthy Promise Checks\n\nIn prior versions, TypeScript introduced “Always Truthy Promise checks” to catch code where an `await` may have been forgotten; however, the checks only applied to named declarations. That meant that while this code would correctly receive an error…\n\nts\n\n`async function foo(): Promise<boolean> {`\n\n  `return false;`\n\n`}`\n\n`async function bar(): Promise<string> {`\n\n  `const fooResult = foo();`\n\n  `if (fooResult) {`\n\n    `// <- error! :D`\n\n    `return \"true\";`\n\n  `}`\n\n  `return \"false\";`\n\n`}`\n\n…the following code would not.\n\nts\n\n`async function foo(): Promise<boolean> {`\n\n  `return false;`\n\n`}`\n\n`async function bar(): Promise<string> {`\n\n  `if (foo()) {`\n\n    `// <- no error :(`\n\n    `return \"true\";`\n\n  `}`\n\n  `return \"false\";`\n\n`}`\n\nTypeScript 4.4 now flags both. For more information, [read up on the original change](https://github.com/microsoft/TypeScript/pull/44491).\n\n### [](#abstract-properties-do-not-allow-initializers)Abstract Properties Do Not Allow Initializers\n\nThe following code is now an error because abstract properties may not have initializers:\n\nts\n\n`abstract class C {`\n\n  `abstract prop = 1;`\n\n  `//       ~~~~`\n\n  `// Property 'prop' cannot have an initializer because it is marked abstract.`\n\n`}`\n\nInstead, you may only specify a type for the property:\n\nts\n\n`abstract class C {`\n\n  `abstract prop: number;`\n\n`}`",
    "title": "TypeScript: Documentation - TypeScript 4.4",
    "description": "TypeScript 4.4 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.1\n\n## [](#mapped-types-on-tuples-and-arrays)Mapped types on tuples and arrays\n\nIn TypeScript 3.1, mapped object types[\\[1\\]](#ts-3-1-only-homomorphic) over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like `push()`, `pop()`, and `length` are converted. For example:\n\nts\n\n`type MapToPromise<T> = { [K in keyof T]: Promise<T[K]> };`\n\n`type Coordinate = [number, number];`\n\n`type PromiseCoordinate = MapToPromise<Coordinate>; // [Promise<number>, Promise<number>]`\n\n`MapToPromise` takes a type `T`, and when that type is a tuple like `Coordinate`, only the numeric properties are converted. In `[number, number]`, there are two numerically named properties: `0` and `1`. When given a tuple like that, `MapToPromise` will create a new tuple where the `0` and `1` properties are `Promise`s of the original type. So the resulting type `PromiseCoordinate` ends up with the type `[Promise<number>, Promise<number>]`.\n\n## [](#properties-declarations-on-functions)Properties declarations on functions\n\nTypeScript 3.1 brings the ability to define properties on function declarations and `const`\\-declared functions, simply by assigning to properties on these functions in the same scope. This allows us to write canonical JavaScript code without resorting to `namespace` hacks. For example:\n\nts\n\n`function readImage(path: string, callback: (err: any, image: Image) => void) {`\n\n  `// ...`\n\n`}`\n\n`readImage.sync = (path: string) => {`\n\n  `const contents = fs.readFileSync(path);`\n\n  `return decodeImageSync(contents);`\n\n`};`\n\nHere, we have a function `readImage` which reads an image in a non-blocking asynchronous way. In addition to `readImage`, we’ve provided a convenience function on `readImage` itself called `readImage.sync`.\n\nWhile ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to “just work” in TypeScript. Additionally, this approach for property declarations allows us to express common patterns like `defaultProps` and `propTypes` on React function components (formerly known as SFCs).\n\nts\n\n`export const FooComponent = ({ name }) => <div>Hello! I am {name}</div>;`\n\n`FooComponent.defaultProps = {`\n\n  `name: \"(anonymous)\",`\n\n`};`\n\n* * *\n\n\\[1\\] More specifically, homomorphic mapped types like in the above form.\n\n## [](#version-selection-with-typesversions)Version selection with `typesVersions`\n\nFeedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called `typesVersions` to help accommodate these scenarios.\n\nYou can read [about it in the Publishing section of the declaration files section](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#version-selection-with-typesversions)",
    "title": "TypeScript: Documentation - TypeScript 3.1",
    "description": "TypeScript 3.1 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.3\n\n## [](#separate-write-types-on-properties)Separate Write Types on Properties\n\nIn JavaScript, it’s pretty common for APIs to convert values that are passed in before storing them. This often happens with getters and setters too. For example, let’s imagine we’ve got a class with a setter that always converts a value into a `number` before saving it in a private field.\n\njs\n\n`class Thing {`\n\n  `#size = 0;`\n\n  `get size() {`\n\n    `return this.#size;`\n\n  `}`\n\n  `set size(value) {`\n\n    `let num = Number(value);`\n\n    `// Don't allow NaN and stuff.`\n\n    `if (!Number.isFinite(num)) {`\n\n      `this.#size = 0;`\n\n      `return;`\n\n    `}`\n\n    `this.#size = num;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwFDWgYgkQC8BTaAXmgAYBuLHaVEgF2kNIAoBKTB3AJxYBXfsmjMkEAHQFiJOrgC+DCCzZyOANzAghJHtly4Qa5EIC2FaADkLAIxL8tOvVzp9oAek-QAIgHtkAHJWHRB-AHcbMGtoMGQAEzZmIQAzVKkPRFToDgBCW3MHfilECAAxFERmEg4zcy4DD1wJMpl2MkpaZuhBFNEFI2UPVulZUit6weVFIA)\n\nHow would we type this JavaScript code in TypeScript? Well, technically we don’t have to do anything special here - TypeScript can look at this with no explicit types and can figure out that `size` is a number.\n\nThe problem is that `size` allows you to assign more than just `number`s to it. We could get around this by saying that `size` has the type `unknown` or `any` like in this snippet:\n\nts\n\n`class Thing {`\n\n  `// ...`\n\n  `get size(): unknown {`\n\n    `return this.#size;`\n\n  `}`\n\n`}`\n\nBut that’s no good - `unknown` forces people reading `size` to do a type assertion, and `any` won’t catch any mistakes. If we really want to model APIs that convert values, previous versions of TypeScript forced us to pick between being precise (which makes reading values easier, and writing harder) and being permissive (which makes writing values easier, and reading harder).\n\nThat’s why TypeScript 4.3 allows you to specify types for reading and writing to properties.\n\nts\n\n`class Thing {`\n\n  `#size = 0;`\n\n  `get size(): number {`\n\n    `return this.#size;`\n\n  `}`\n\n  `set size(value: string | number | boolean) {`\n\n    `let num = Number(value);`\n\n    `// Don't allow NaN and stuff.`\n\n    `if (!Number.isFinite(num)) {`\n\n      `this.#size = 0;`\n\n      `return;`\n\n    `}`\n\n    `this.#size = num;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwFDWgYgkQC8BTaAXmgAYBuLHaVEgF2kNIAoBKALmmQCuAWwBGJAE6YGucSwHjk0ZkggA6AsRJ1cAX3q4ILNpo4A3MCAEk+EZuJToAPv2FjJzkQHtPIEmGRcUri4vqyCQhTQAHKuEmYWVlx00tAA9KnQACKeyADkrBYgngDu0WBR0P4AJmzMAgBm9aopiPXQHACEMaISqogQAGIoiMwkHOFcgdjBwcr96uxklLQpMnIK2sF6KXNqGqSR4Zt6OkA)\n\nIn the above example, our `set` accessor takes a broader set of types (`string`s, `boolean`s, and `number`s), but our `get` accessor always guarantees it will be a `number`. Now we can finally assign other types to these properties with no errors!\n\nts\n\n`let thing = new Thing();`\n\n``// Assigning other types to `thing.size` works!``\n\n`thing.size = \"hello\";`\n\n`thing.size = true;`\n\n`thing.size = 42;`\n\n``// Reading `thing.size` always produces a number!``\n\n`let mySize: number = thing.size;`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwFDWgYgkQC8BTaAXmgAYBuLHaVEgF2kNIAoBKALmmQCuAWwBGJAE6YGucSwHjk0ZkggA6AsRJ1cAX3q4ILNpo4A3MCAEk+EZuJToAPv2FjJzkQHtPIEmGRcUri4vqyCQhTQAHKuEmYWVlx00tAA9KnQACKeyADkrBYgngDu0WBR0P4AJmzMAgBm9aopiPXQHACEMaISqogQAGIoiMwkHOFcgdjBwcr96uxklLQpMnIK2sF6KXNqGqSR4Zt6eunQALSXwALMl+dYoUpIaIckpQgO3MlnAIJQiKhkA5oJ5lBIlABPAAOJBgzE80AABnM0KpFojoMVPOIANYQDpYFGoNGaSIAIngJBARTJdCJJIOlDsVjpz2Ji0iABYAEzfDIAJT8VWByLZDJIGIsxTAEJgUPEniqAmAsMqLh64gJjyEEIAypo+OE3JF6YsaEA)\n\nWhen considering how two properties with the same name relate to each other, TypeScript will only use the “reading” type (e.g. the type on the `get` accessor above). “Writing” types are only considered when directly writing to a property.\n\nKeep in mind, this isn’t a pattern that’s limited to classes. You can write getters and setters with different types in object literals.\n\nts\n\n`function makeThing(): Thing {`\n\n  `let size = 0;`\n\n  `return {`\n\n    `get size(): number {`\n\n      `return size;`\n\n    `},`\n\n    `set size(value: string | number | boolean) {`\n\n      `let num = Number(value);`\n\n      `// Don't allow NaN and stuff.`\n\n      `if (!Number.isFinite(num)) {`\n\n        `size = 0;`\n\n        `return;`\n\n      `}`\n\n      `size = num;`\n\n    `},`\n\n  `};`\n\n`}`\n\nIn fact, we’ve added syntax to interfaces/object types to support different reading/writing types on properties.\n\nts\n\n`// Now valid!`\n\n`interface Thing {`\n\n    `get size(): number`\n\n    `set size(value: number | string | boolean);`\n\n`}`\n\nOne limitation of using different types for reading and writing properties is that the type for reading a property has to be assignable to the type that you’re writing. In other words, the getter type has to be assignable to the setter. This ensures some level of consistency, so that a property is always assignable to itself.\n\nFor more information on this feature, take a look at [the implementing pull request](https://github.com/microsoft/TypeScript/pull/42425).\n\n## [](#override-and-the---noimplicitoverride-flag)`override` and the `--noImplicitOverride` Flag\n\nWhen extending classes in JavaScript, the language makes it super easy (pun intended) to override methods - but unfortunately, there are some mistakes that you can run into.\n\nOne big one is missing renames. For example, take the following classes:\n\nts\n\n`class SomeComponent {`\n\n  `show() {`\n\n    `// ...`\n\n  `}`\n\n  `hide() {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\n`class SpecializedComponent extends SomeComponent {`\n\n  `show() {`\n\n    `// ...`\n\n  `}`\n\n  `hide() {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\n`SpecializedComponent` subclasses `SomeComponent`, and overrides the `show` and `hide` methods. What happens if someone decides to rip out `show` and `hide` and replace them with a single method?\n\ndiff\n\n `class SomeComponent {`\n\n`-    show() {`\n\n`-        // ...`\n\n`-    }`\n\n`-    hide() {`\n\n`-        // ...`\n\n`-    }`\n\n`+    setVisible(value: boolean) {`\n\n`+        // ...`\n\n`+    }`\n\n `}`\n\n `class SpecializedComponent extends SomeComponent {`\n\n     `show() {`\n\n         `// ...`\n\n     `}`\n\n     `hide() {`\n\n         `// ...`\n\n     `}`\n\n `}`\n\n_Oh no!_ Our `SpecializedComponent` didn’t get updated. Now it’s just adding these two useless `show` and `hide` methods that probably won’t get called.\n\nPart of the issue here is that a user can’t make it clear whether they meant to add a new method, or to override an existing one. That’s why TypeScript 4.3 adds the `override` keyword.\n\nts\n\n`class SpecializedComponent extends SomeComponent {`\n\n    `override show() {`\n\n        `// ...`\n\n    `}`\n\n    `override hide() {`\n\n        `// ...`\n\n    `}`\n\n`}`\n\nWhen a method is marked with `override`, TypeScript will always make sure that a method with the same name exists in a the base class.\n\nts\n\n`class SomeComponent {`\n\n    `setVisible(value: boolean) {`\n\n        `// ...`\n\n    `}`\n\n`}`\n\n`class SpecializedComponent extends SomeComponent {`\n\n    `override show() {`\n\n`This member cannot have an 'override' modifier because it is not declared in the base class 'SomeComponent'.4113This member cannot have an 'override' modifier because it is not declared in the base class 'SomeComponent'.      }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwPIDcBTAJyNQBMCAoECYo6IgZwC5QAWARg4GZL1kAho0agAytHgEAwhMTRIBSFlABvSqA2hGBLADVUjVACNkBABR4ByAK4FWR6NFMDIASlXrNXmgDo-njQBfSmD+IRFRRAJMK1QALwIyGSR5RWUCAA8sRTIIiWlZVKUPL2hCEnICLQALaAB3M3c1ANBgwKA)\n\nThis is a big improvement, but it doesn’t help if you _forget_ to write `override` on a method - and that’s a big mistake users can run into also.\n\nFor example, you might accidentally “trample over” a method that exists in a base class without realizing it.\n\nts\n\n`class Base {`\n\n  `someHelperMethod() {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\n`class Derived extends Base {`\n\n  `// Oops! We weren't trying to override here,`\n\n  `// we just needed to write a local helper method.`\n\n  `someHelperMethod() {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\nThat’s why TypeScript 4.3 _also_ provides a new [`noImplicitOverride`](https://www.typescriptlang.org/tsconfig#noImplicitOverride) flag. When this option is turned on, it becomes an error to override any method from a superclass unless you explicitly use an `override` keyword. In that last example, TypeScript would error under [`noImplicitOverride`](https://www.typescriptlang.org/tsconfig#noImplicitOverride), and give us a clue that we probably need to rename our method inside of `Derived`.\n\nWe’d like to extend our thanks to our community for the implementation here. The work for these items was implemented in [a pull request](https://github.com/microsoft/TypeScript/pull/39669) by [Wenlu Wang](https://github.com/Kingwl), though an earlier pull request implementing only the `override` keyword by [Paul Cody Johnston](https://github.com/pcj) served as a basis for direction and discussion. We extend our gratitude for putting in the time for these features.\n\n## [](#template-string-type-improvements)Template String Type Improvements\n\nIn recent versions, TypeScript introduced a new type construct: template string types. These are types that either construct new string-like types by concatenating…\n\nts\n\n`type Color = \"red\" | \"blue\";`\n\n`type Quantity = \"one\" | \"two\";`\n\n``type SeussFish = `${Quantity | Color} fish`;``\n\n`// same as`\n\n`//   type SeussFish = \"one fish\" | \"two fish\"`\n\n`//                  | \"red fish\" | \"blue fish\";`\n\n…or match patterns of other string-like types.\n\nts\n\n``declare let s1: `${number}-${number}-${number}`;``\n\n``declare let s2: `1-2-3`;``\n\n`// Works!`\n\n`s1 = s2;`\n\nThe first change we made is just in when TypeScript will infer a template string type. When a template string is _contextually typed_ by a string-literal-like type (i.e. when TypeScript sees we’re passing a template string to something that takes a literal type) it will try to give that expression a template type.\n\nts\n\n``function bar(s: string): `hello ${string}` {``\n\n    `// Previously an error, now works!`\n\n    ``return `hello ${s}`;``\n\n`}`\n\nThis also kicks in when inferring types, and the type parameter `extends string`\n\nts\n\n`declare let s: string;`\n\n`declare function f<T extends string>(x: T): T;`\n\n`// Previously: string`\n\n`` // Now       : `hello ${string}` ``\n\n``let x2 = f(`hello ${s}`);``\n\nThe second major change here is that TypeScript can now better-relate, and _infer between_, different template string types.\n\nTo see this, take the following example code:\n\nts\n\n``declare let s1: `${number}-${number}-${number}`;``\n\n``declare let s2: `1-2-3`;``\n\n``declare let s3: `${number}-2-3`;``\n\n`s1 = s2;`\n\n`s1 = s3;`\n\nWhen checking against a string literal type like on `s2`, TypeScript could match against the string contents and figure out that `s2` was compatible with `s1` in the first assignment; however, as soon as it saw another template string, it just gave up. As a result, assignments like `s3` to `s1` just didn’t work.\n\nTypeScript now actually does the work to prove whether or not each part of a template string can successfully match. You can now mix and match template strings with different substitutions and TypeScript will do a good job to figure out whether they’re really compatible.\n\nts\n\n``declare let s1: `${number}-${number}-${number}`;``\n\n``declare let s2: `1-2-3`;``\n\n``declare let s3: `${number}-2-3`;``\n\n``declare let s4: `1-${number}-3`;``\n\n``declare let s5: `1-2-${number}`;``\n\n``declare let s6: `${number}-2-${number}`;``\n\n`// Now *all of these* work!`\n\n`s1 = s2;`\n\n`s1 = s3;`\n\n`s1 = s4;`\n\n`s1 = s5;`\n\n`s1 = s6;`\n\nIn doing this work, we were also sure to add better inference capabilities. You can see an example of these in action:\n\nts\n\n``declare function foo<V extends string>(arg: `*${V}*`): V;``\n\n`function test<T extends string>(s: string, n: number, b: boolean, t: T) {`\n\n    `let x1 = foo(\"*hello*\");            // \"hello\"`\n\n    `let x2 = foo(\"**hello**\");          // \"*hello*\"`\n\n    ``let x3 = foo(`*${s}*` as const);    // string``\n\n    `` let x4 = foo(`*${n}*` as const);    // `${number}` ``\n\n    ``let x5 = foo(`*${b}*` as const);    // \"true\" | \"false\"``\n\n    `` let x6 = foo(`*${t}*` as const);    // `${T}` ``\n\n    `` let x7 = foo(`**${s}**` as const);  // `*${string}*` ``\n\n`}`\n\nFor more information, see [the original pull request on leveraging contextual types](https://github.com/microsoft/TypeScript/pull/43376), along with [the pull request that improved inference and checking between template types](https://github.com/microsoft/TypeScript/pull/43361).\n\n## [](#ecmascript-private-class-elements)ECMAScript `#private` Class Elements\n\nTypeScript 4.3 expands which elements in a class can be given `#private` `#names` to make them truly private at run-time. In addition to properties, methods and accessors can also be given private names.\n\nts\n\n`class Foo {`\n\n  `#someMethod() {`\n\n    `//...`\n\n  `}`\n\n  `get #someValue() {`\n\n    `return 100;`\n\n  `}`\n\n  `publicMethod() {`\n\n    `// These work.`\n\n    `// We can access private-named members inside this class.`\n\n    `this.#someMethod();`\n\n    `return this.#someValue;`\n\n  `}`\n\n`}`\n\n`new Foo().#someMethod();`\n\n`//        ~~~~~~~~~~~`\n\n`// error!`\n\n`// Property '#someMethod' is not accessible`\n\n`// outside class 'Foo' because it has a private identifier.`\n\n`new Foo().#someValue;`\n\n`//        ~~~~~~~~~~`\n\n`// error!`\n\n`// Property '#someValue' is not accessible`\n\n`// outside class 'Foo' because it has a private identifier.`\n\nEven more broadly, static members can now also have private names.\n\nts\n\n`class Foo {`\n\n  `static #someMethod() {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\n`Foo.#someMethod();`\n\n`//  ~~~~~~~~~~~`\n\n`// error!`\n\n`// Property '#someMethod' is not accessible`\n\n`// outside class 'Foo' because it has a private identifier.`\n\nThis feature was authored [in a pull request](https://github.com/microsoft/TypeScript/pull/42458) from our friends at Bloomberg - written by [Titian Cernicova-Dragomir](https://github.com/dragomirtitian)and [Kubilay Kahveci](https://github.com/mkubilayk), with support and expertise from [Joey Watts](https://github.com/joeywatts), [Rob Palmer](https://github.com/robpalme), and [Tim McClure](https://github.com/tim-mc). We’d like to extend our thanks to all of them!\n\n## [](#constructorparameters-works-on-abstract-classes)`ConstructorParameters` Works on Abstract Classes\n\nIn TypeScript 4.3, the `ConstructorParameters` type helper now works on `abstract` classes.\n\nts\n\n`abstract class C {`\n\n  `constructor(a: string, b: number) {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\n`// Has the type '[a: string, b: number]'.`\n\n`type CParams = ConstructorParameters<typeof C>;`\n\nThis is thanks to work done in TypeScript 4.2, where construct signatures can be marked as abstract:\n\nts\n\n`type MyConstructorOf<T> = {`\n\n    `abstract new(...args: any[]): T;`\n\n`}`\n\n`// or using the shorthand syntax:`\n\n`type MyConstructorOf<T> = abstract new (...args: any[]) => T;`\n\nYou can [see the change in more detail on GitHub](https://github.com/microsoft/TypeScript/pull/43380).\n\n## [](#contextual-narrowing-for-generics)Contextual Narrowing for Generics\n\nTypeScript 4.3 now includes some slightly smarter type-narrowing logic on generic values. This allows TypeScript to accept more patterns, and sometimes even catch mistakes.\n\nFor some motivation, let’s say we’re trying to write a function called `makeUnique`. It’ll take a `Set` or an `Array` of elements, and if it’s given an `Array`, it’ll sort that `Array` remove duplicates according to some comparison function. After all that, it will return the original collection.\n\nts\n\n`function makeUnique<T>(`\n\n  `collection: Set<T> | T[],`\n\n  `comparer: (x: T, y: T) => number`\n\n`): Set<T> | T[] {`\n\n  `// Early bail-out if we have a Set.`\n\n  `// We assume the elements are already unique.`\n\n  `if (collection instanceof Set) {`\n\n    `return collection;`\n\n  `}`\n\n  `// Sort the array, then remove consecutive duplicates.`\n\n  `collection.sort(comparer);`\n\n  `for (let i = 0; i < collection.length; i++) {`\n\n    `let j = i;`\n\n    `while (`\n\n      `j < collection.length &&`\n\n      `comparer(collection[i], collection[j + 1]) === 0`\n\n    `) {`\n\n      `j++;`\n\n    `}`\n\n    `collection.splice(i + 1, j - i);`\n\n  `}`\n\n  `return collection;`\n\n`}`\n\nLet’s leave questions about this function’s implementation aside, and assume it arose from the requirements of a broader application. Something that you might notice is that the signature doesn’t capture the original type of `collection`. We can do that by adding a type parameter called `C` in place of where we’ve written `Set<T> | T[]`.\n\ndiff\n\n`- function makeUnique<T>(collection: Set<T> | T[], comparer: (x: T, y: T) => number): Set<T> | T[]`\n\n`+ function makeUnique<T, C extends Set<T> | T[]>(collection: C, comparer: (x: T, y: T) => number): C`\n\nIn TypeScript 4.2 and earlier, you’d end up with a bunch of errors as soon as you tried this.\n\nts\n\n`function makeUnique<T, C extends Set<T> | T[]>(`\n\n  `collection: C,`\n\n  `comparer: (x: T, y: T) => number`\n\n`): C {`\n\n  `// Early bail-out if we have a Set.`\n\n  `// We assume the elements are already unique.`\n\n  `if (collection instanceof Set) {`\n\n    `return collection;`\n\n  `}`\n\n  `// Sort the array, then remove consecutive duplicates.`\n\n  `collection.sort(comparer);`\n\n  `//         ~~~~`\n\n  `// error: Property 'sort' does not exist on type 'C'.`\n\n  `for (let i = 0; i < collection.length; i++) {`\n\n    `//                             ~~~~~~`\n\n    `// error: Property 'length' does not exist on type 'C'.`\n\n    `let j = i;`\n\n    `while (`\n\n      `j < collection.length &&`\n\n      `comparer(collection[i], collection[j + 1]) === 0`\n\n    `) {`\n\n      `//                    ~~~~~~`\n\n      `// error: Property 'length' does not exist on type 'C'.`\n\n      `//                                       ~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~`\n\n      `// error: Element implicitly has an 'any' type because expression of type 'number'`\n\n      `//        can't be used to index type 'Set<T> | T[]'.`\n\n      `j++;`\n\n    `}`\n\n    `collection.splice(i + 1, j - i);`\n\n    `//         ~~~~~~`\n\n    `// error: Property 'splice' does not exist on type 'C'.`\n\n  `}`\n\n  `return collection;`\n\n`}`\n\nEw, errors! Why is TypeScript being so mean to us?\n\nThe issue is that when we perform our `collection instanceof Set` check, we’re expecting that to act as a type guard that narrows the type from `Set<T> | T[]` to `Set<T>` and `T[]` depending on the branch we’re in; however, we’re not dealing with a `Set<T> | T[]`, we’re trying to narrow the generic value `collection`, whose type is `C`.\n\nIt’s a very subtle distinction, but it makes a difference. TypeScript can’t just grab the constraint of `C` (which is `Set<T> | T[]`) and narrow that. If TypeScript _did_ try to narrow from `Set<T> | T[]`, it would forget that `collection` is also a `C` in each branch because there’s no easy way to preserve that information. If hypothetically TypeScript tried that approach, it would break the above example in a different way. At the return positions, where the function expects values with the type `C`, we would instead get a `Set<T>` and a `T[]` in each branch, which TypeScript would reject.\n\nts\n\n`function makeUnique<T>(`\n\n  `collection: Set<T> | T[],`\n\n  `comparer: (x: T, y: T) => number`\n\n`): Set<T> | T[] {`\n\n  `// Early bail-out if we have a Set.`\n\n  `// We assume the elements are already unique.`\n\n  `if (collection instanceof Set) {`\n\n    `return collection;`\n\n    `//     ~~~~~~~~~~`\n\n    `// error: Type 'Set<T>' is not assignable to type 'C'.`\n\n    `//          'Set<T>' is assignable to the constraint of type 'C', but`\n\n    `//          'C' could be instantiated with a different subtype of constraint 'Set<T> | T[]'.`\n\n  `}`\n\n  `// ...`\n\n  `return collection;`\n\n  `//     ~~~~~~~~~~`\n\n  `// error: Type 'T[]' is not assignable to type 'C'.`\n\n  `//          'T[]' is assignable to the constraint of type 'C', but`\n\n  `//          'C' could be instantiated with a different subtype of constraint 'Set<T> | T[]'.`\n\n`}`\n\nSo how does TypeScript 4.3 change things? Well, basically in a few key places when writing code, all the type system really cares about is the constraint of a type. For example, when we write `collection.length`, TypeScript doesn’t care about the fact that `collection` has the type `C`, it only cares about the properties available, which are determined by the constraint `T[] | Set<T>`.\n\nIn cases like this, TypeScript will grab the narrowed type of the constraint because that will give you the data you care about; however, in any other case, we’ll just try to narrow the original generic type (and often end up with the original generic type).\n\nIn other words, based on how you use a generic value, TypeScript will narrow it a little differently. The end result is that the entire above example compiles with no type-checking errors.\n\nFor more details, you can [look at the original pull request on GitHub](https://github.com/microsoft/TypeScript/pull/43183).\n\n## [](#always-truthy-promise-checks)Always-Truthy Promise Checks\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), checking whether a `Promise` is “truthy” in a conditional will trigger an error.\n\nts\n\n`async function foo(): Promise<boolean> {`\n\n  `return false;`\n\n`}`\n\n`async function bar(): Promise<string> {`\n\n  `if (foo()) {`\n\n    `//  ~~~~~`\n\n    `// Error!`\n\n    `// This condition will always return true since`\n\n    `// this 'Promise<boolean>' appears to always be defined.`\n\n    `// Did you forget to use 'await'?`\n\n    `return \"true\";`\n\n  `}`\n\n  `return \"false\";`\n\n`}`\n\n[This change](https://github.com/microsoft/TypeScript/pull/39175) was contributed by [Jack Works](https://github.com/Jack-Works), and we extend our thanks to them!\n\n## [](#static-index-signatures)`static` Index Signatures\n\nIndex signatures allow us to set more properties on a value than a type explicitly declares.\n\nts\n\n`class Foo {`\n\n  `hello = \"hello\";`\n\n  `world = 1234;`\n\n  `// This is an index signature:`\n\n  `[propName: string]: string | number | undefined;`\n\n`}`\n\n`let instance = new Foo();`\n\n`// Valid assignment`\n\n`instance[\"whatever\"] = 42;`\n\n`// Has type 'string | number | undefined'.`\n\n`let x = instance[\"something\"];`\n\nUp until now, an index signature could only be declared on the instance side of a class. Thanks to [a pull request](https://github.com/microsoft/TypeScript/pull/37797) from [Wenlu Wang](https://github.com/microsoft/TypeScript/pull/37797), index signatures can now be declared as `static`.\n\nts\n\n`class Foo {`\n\n  `static hello = \"hello\";`\n\n  `static world = 1234;`\n\n  `static [propName: string]: string | number | undefined;`\n\n`}`\n\n`// Valid.`\n\n`Foo[\"whatever\"] = 42;`\n\n`// Has type 'string | number | undefined'`\n\n`let x = Foo[\"something\"];`\n\nThe same sorts of rules apply for index signatures on the static side of a class as they do for the instance side - namely, that every other static property has to be compatible with the index signature.\n\nts\n\n`class Foo {`\n\n  `static prop = true;`\n\n  `//     ~~~~`\n\n  `// Error! Property 'prop' of type 'boolean'`\n\n  `// is not assignable to string index type`\n\n  `// 'string | number | undefined'.`\n\n  `static [propName: string]: string | number | undefined;`\n\n`}`\n\n## [](#tsbuildinfo-size-improvements)`.tsbuildinfo` Size Improvements\n\nIn TypeScript 4.3, `.tsbuildinfo` files that are generated as part of [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) builds should be significantly smaller. This is thanks to several optimizations in the internal format, creating tables with numeric identifiers to be used throughout the file instead of repeating full paths and similar information. This work was spear-headed by [Tobias Koppers](https://github.com/sokra) in [their pull request](https://github.com/microsoft/TypeScript/pull/43079), serving as inspiration for [the ensuing pull request](https://github.com/microsoft/TypeScript/pull/43155) and [further optimizations](https://github.com/microsoft/TypeScript/pull/43695).\n\nWe have seen significant reductions of `.tsbuildinfo` file sizes including\n\n*   1MB to 411 KB\n*   14.9MB to 1MB\n*   1345MB to 467MB\n\nNeedless to say, these sorts of savings in size translate to slightly faster build times as well.\n\n## [](#lazier-calculations-in---incremental-and---watch-compilations)Lazier Calculations in `--incremental` and `--watch` Compilations\n\nOne of the issues with [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) and `--watch` modes are that while they make later compilations go faster, the initial compilation can be a bit slower - in some cases, significantly slower. This is because these modes have to perform a bunch of book-keeping, computing information about the current project, and sometimes saving that data in a `.tsbuildinfo` file for later builds.\n\nThat’s why on top of `.tsbuildinfo` size improvements, TypeScript 4.3 also ships some changes to [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) and `--watch` modes that make the first build of a project with these flags just as fast as an ordinary build! To do this, much of the information that would ordinarily be computed up-front is instead done on an on-demand basis for later builds. While this can add some overhead to a subsequent build, TypeScript’s [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) and `--watch` functionality will still typically operate on a much smaller set of files, and any needed information will be saved afterwards. In a sense, [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) and `--watch` builds will “warm up” and get faster at compiling files once you’ve updated them a few times.\n\nIn a repository with 3000 files, **this reduced initial build times to almost a third**!\n\n[This work was started](https://github.com/microsoft/TypeScript/pull/42960) by [Tobias Koppers](https://github.com/sokra), whose work ensued in [the resulting final change](https://github.com/microsoft/TypeScript/pull/43314) for this functionality. We’d like to extend a great thanks to Tobias for helping us find these opportunities for improvements!\n\n## [](#import-statement-completions)Import Statement Completions\n\nOne of the biggest pain-points users run into with import and export statements in JavaScript is the order - specifically that imports are written as\n\nts\n\n`import { func } from \"./module.js\";`\n\ninstead of\n\nts\n\n`from \"./module.js\" import { func };`\n\nThis causes some pain when writing out a full import statement from scratch because auto-complete wasn’t able to work correctly. For example, if you start writing something like `import {`, TypeScript has no idea what module you’re planning on importing from, so it couldn’t provide any scoped-down completions.\n\nTo alleviate this, we’ve leveraged the power of auto-imports! Auto-imports already deal with the issue of not being able to narrow down completions from a specific module - their whole point is to provide every possible export and automatically insert an import statement at the top of your file.\n\nSo when you now start writing an `import` statement that doesn’t have a path, we’ll provide you with a list of possible imports. When you commit a completion, we’ll complete the full import statement, including the path that you were going to write.\n\n![Import statement completions](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/05/auto-import-statement-4-3.gif)\n\nThis work requires editors that specifically support the feature. You’ll be able to try this out by using the latest [Insiders versions of Visual Studio Code](https://code.visualstudio.com/insiders/).\n\nFor more information, take a look at [the implementing pull request](https://github.com/microsoft/TypeScript/pull/43149)!\n\nTypeScript can now understand `@link` tags, and will try to resolve declarations that they link to. What this means is that you’ll be able to hover over names within `@link` tags and get quick information, or use commands like go-to-definition or find-all-references.\n\nFor example, you’ll be able to go-to-definition on `plantCarrot` in `@link plantCarrot` in the example below and a TypeScript-supported editor will jump to `plantCarrot`’s function declaration.\n\nts\n\n`/**`\n\n `* To be called 70 to 80 days after {@link plantCarrot}.`\n\n `*/`\n\n`function harvestCarrot(carrot: Carrot) {}`\n\n`/**`\n\n `* Call early in spring for best results. Added in v2.1.0.`\n\n `* @param seed Make sure it's a carrot seed!`\n\n `*/`\n\n`function plantCarrot(seed: Seed) {`\n\n  `// TODO: some gardening`\n\n`}`\n\n![Jumping to definition and requesting quick info on a @link tag for ](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/05/link-tag-4-3.gif)\n\nFor more information, see [the pull request on GitHub](https://github.com/microsoft/TypeScript/pull/41877)!\n\n## [](#go-to-definition-on-non-javascript-file-paths)Go-to-Definition on Non-JavaScript File Paths\n\nMany loaders allow users to include assets in their applications using JavaScript imports. They’ll typically be written as something like `import \"./styles.css\"` or the like.\n\nUp until now, TypeScript’s editor functionality wouldn’t even attempt to read this file, so go-to-definition would typically fail. At best, go-to-definition would jump to a declaration like `declare module \"*.css\"` if it could find something along those lines.\n\nTypeScript’s language service now tries to jump to the correct file when you perform a go-to-definition on relative file paths, even if they’re not JavaScript or TypeScript files! Try it out with imports to CSS, SVGs, PNGs, font files, Vue files, and more.\n\nFor more information, you can check out [the implementing pull request](https://github.com/microsoft/TypeScript/pull/42539).\n\n## [](#breaking-changes)Breaking Changes\n\n### [](#libdts-changes)`lib.d.ts` Changes\n\nAs with every TypeScript version, declarations for `lib.d.ts` (especially the declarations generated for web contexts), have changed. In this release, we leveraged [Mozilla’s browser-compat-data](https://github.com/mdn/browser-compat-data) to remove APIs that no browser implements. While it is unlike that you are using them, APIs such as `Account`, `AssertionOptions`, `RTCStatsEventInit`, `MSGestureEvent`, `DeviceLightEvent`, `MSPointerEvent`, `ServiceWorkerMessageEvent`, and `WebAuthentication` have all been removed from `lib.d.ts`. This is discussed [in some detail here](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991).\n\n[https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991)\n\n### [](#usedefineforclassfields-now-defaults-to-true-on-esnext-and-eventually-on-es2022)`useDefineForClassFields` now defaults to true on `esnext` and eventually on `es2022`\n\nIn 2021 the class fields feature was added into the JavaScript specification with behavior which differed from how TypeScript had implemented it. In preparation for this, in TypeScript 3.7, a flag was added ([`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)) to migrate to emitted JavaScript to match the JavaScript standard behavior.\n\nNow that the feature is in JavaScript we are changing the default to `true` for ES2022 and above, including ESNext.\n\n### [](#errors-on-always-truthy-promise-checks)Errors on Always-Truthy Promise Checks\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), using a `Promise` that always appears to be defined within a condition check is now considered an error.\n\nts\n\n`declare var p: Promise<number>;`\n\n`if (p) {`\n\n  `//  ~`\n\n  `// Error!`\n\n  `// This condition will always return true since`\n\n  `// this 'Promise<number>' appears to always be defined.`\n\n  `//`\n\n  `// Did you forget to use 'await'?`\n\n`}`\n\nFor more details, [see the original change](https://github.com/microsoft/TypeScript/pull/39175).\n\n### [](#union-enums-cannot-be-compared-to-arbitrary-numbers)Union Enums Cannot Be Compared to Arbitrary Numbers\n\nCertain `enum`s are considered _union `enum`s_ when their members are either automatically filled in, or trivially written. In those cases, an enum can recall each value that it potentially represents.\n\nIn TypeScript 4.3, if a value with a union `enum` type is compared with a numeric literal that it could never be equal to, then the type-checker will issue an error.\n\nts\n\n`enum E {`\n\n  `A = 0,`\n\n  `B = 1,`\n\n`}`\n\n`function doSomething(x: E) {`\n\n  `// Error! This condition will always return 'false' since the types 'E' and '-1' have no overlap.`\n\n  `if (x === -1) {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\nAs a workaround, you can re-write an annotation to include the appropriate literal type.\n\nts\n\n`enum E {`\n\n  `A = 0,`\n\n  `B = 1,`\n\n`}`\n\n`// Include -1 in the type, if we're really certain that -1 can come through.`\n\n`function doSomething(x: E | -1) {`\n\n  `if (x === -1) {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\nYou can also use a type-assertion on the value.\n\nts\n\n`enum E {`\n\n  `A = 0,`\n\n  `B = 1,`\n\n`}`\n\n`function doSomething(x: E) {`\n\n  `// Use a type assertion on 'x' because we know we're not actually just dealing with values from 'E'.`\n\n  `if ((x as number) === -1) {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\nAlternatively, you can re-declare your enum to have a non-trivial initializer so that any number is both assignable and comparable to that enum. This may be useful if the intent is for the enum to specify a few well-known values.\n\nts\n\n`enum E {`\n\n  `// the leading + on 0 opts TypeScript out of inferring a union enum.`\n\n  `A = +0,`\n\n  `B = 1,`\n\n`}`\n\nFor more details, [see the original change](https://github.com/microsoft/TypeScript/pull/42472)",
    "title": "TypeScript: Documentation - TypeScript 4.3",
    "description": "TypeScript 4.3 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html",
    "markdown": "# TypeScript: Documentation - TypeScript 3.0\n\n## [](#project-references)Project References\n\nTypeScript 3.0 introduces a new concept of project references. Project references allow TypeScript projects to depend on other TypeScript projects - specifically, allowing `tsconfig.json` files to reference other `tsconfig.json` files. Specifying these dependencies makes it easier to split your code into smaller projects, since it gives TypeScript (and tools around it) a way to understand build ordering and output structure.\n\nTypeScript 3.0 also introduces a new mode for tsc, the `--build` flag, that works hand-in-hand with project references to enable faster TypeScript builds.\n\nSee [Project References handbook page](https://www.typescriptlang.org/docs/handbook/project-references.html) for more documentation.\n\n## [](#tuples-in-rest-parameters-and-spread-expressions)Tuples in rest parameters and spread expressions\n\nTypeScript 3.0 adds support to multiple new capabilities to interact with function parameter lists as tuple types. TypeScript 3.0 adds support for:\n\n*   [Expansion of rest parameters with tuple types into discrete parameters.](#rest-parameters-with-tuple-types)\n*   [Expansion of spread expressions with tuple types into discrete arguments.](#spread-expressions-with-tuple-types)\n*   [Generic rest parameters and corresponding inference of tuple types.](#generic-rest-parameters)\n*   [Optional elements in tuple types.](#optional-elements-in-tuple-types)\n*   [Rest elements in tuple types.](#rest-elements-in-tuple-types)\n\nWith these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists.\n\n## [](#rest-parameters-with-tuple-types)Rest parameters with tuple types\n\nWhen a rest parameter has a tuple type, the tuple type is expanded into a sequence of discrete parameters. For example the following two declarations are equivalent:\n\nts\n\n`declare function foo(...args: [number, string, boolean]): void;`\n\nts\n\n`declare function foo(args_0: number, args_1: string, args_2: boolean): void;`\n\n## [](#spread-expressions-with-tuple-types)Spread expressions with tuple types\n\nWhen a function call includes a spread expression of a tuple type as the last argument, the spread expression corresponds to a sequence of discrete arguments of the tuple element types.\n\nThus, the following calls are equivalent:\n\nts\n\n`const args: [number, string, boolean] = [42, \"hello\", true];`\n\n`foo(42, \"hello\", true);`\n\n`foo(args[0], args[1], args[2]);`\n\n`foo(...args);`\n\n## [](#generic-rest-parameters)Generic rest parameters\n\nA rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:\n\n##### [](#example)Example\n\nts\n\n`declare function bind<T, U extends any[], V>(`\n\n  `f: (x: T, ...args: U) => V,`\n\n  `x: T`\n\n`): (...args: U) => V;`\n\n`declare function f3(x: number, y: string, z: boolean): void;`\n\n`const f2 = bind(f3, 42); // (y: string, z: boolean) => void`\n\n`const f1 = bind(f2, \"hello\"); // (z: boolean) => void`\n\n`const f0 = bind(f1, true); // () => void`\n\n`f3(42, \"hello\", true);`\n\n`f2(\"hello\", true);`\n\n`f1(true);`\n\n`f0();`\n\nIn the declaration of `f2` above, type inference infers types `number`, `[string, boolean]` and `void` for `T`, `U` and `V` respectively.\n\nNote that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for `U`, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).\n\n## [](#optional-elements-in-tuple-types)Optional elements in tuple types\n\nTuple types now permit a `?` postfix on element types to indicate that the element is optional:\n\n##### [](#example-1)Example\n\nts\n\n`let t: [number, string?, boolean?];`\n\n`t = [42, \"hello\", true];`\n\n`t = [42, \"hello\"];`\n\n`t = [42];`\n\nIn [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) mode, a `?` modifier automatically includes `undefined` in the element type, similar to optional parameters.\n\nA tuple type permits an element to be omitted if it has a postfix `?` modifier on its type and all elements to the right of it also have `?` modifiers.\n\nWhen tuple types are inferred for rest parameters, optional parameters in the source become optional tuple elements in the inferred type.\n\nThe `length` property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the `length` property in the tuple type `[number, string?, boolean?]` is `1 | 2 | 3`.\n\n### [](#rest-elements-in-tuple-types)Rest elements in tuple types\n\nThe last element of a tuple type can be a rest element of the form `...X`, where `X` is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, `[number, ...string[]]` means tuples with a `number` element followed by any number of `string` elements.\n\n##### [](#example-2)Example\n\nts\n\n`function tuple<T extends any[]>(...args: T): T {`\n\n  `return args;`\n\n`}`\n\n`const numbers: number[] = getArrayOfNumbers();`\n\n`const t1 = tuple(\"foo\", 1, true); // [string, number, boolean]`\n\n`const t2 = tuple(\"bar\", ...numbers); // [string, ...number[]]`\n\nThe type of the `length` property of a tuple type with a rest element is `number`.\n\n## [](#new-unknown-top-type)New `unknown` top type\n\nTypeScript 3.0 introduces a new top type `unknown`. `unknown` is the type-safe counterpart of `any`. Anything is assignable to `unknown`, but `unknown` isn’t assignable to anything but itself and `any` without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an `unknown` without first asserting or narrowing to a more specific type.\n\n##### [](#example-3)Example\n\nts\n\n`// In an intersection everything absorbs unknown`\n\n`type T00 = unknown & null; // null`\n\n`type T01 = unknown & undefined; // undefined`\n\n`type T02 = unknown & null & undefined; // null & undefined (which becomes never)`\n\n`type T03 = unknown & string; // string`\n\n`type T04 = unknown & string[]; // string[]`\n\n`type T05 = unknown & unknown; // unknown`\n\n`type T06 = unknown & any; // any`\n\n`// In a union an unknown absorbs everything`\n\n`type T10 = unknown | null; // unknown`\n\n`type T11 = unknown | undefined; // unknown`\n\n`type T12 = unknown | null | undefined; // unknown`\n\n`type T13 = unknown | string; // unknown`\n\n`type T14 = unknown | string[]; // unknown`\n\n`type T15 = unknown | unknown; // unknown`\n\n`type T16 = unknown | any; // any`\n\n`// Type variable and unknown in union and intersection`\n\n`type T20<T> = T & {}; // T & {}`\n\n`type T21<T> = T | {}; // T | {}`\n\n`type T22<T> = T & unknown; // T`\n\n`type T23<T> = T | unknown; // unknown`\n\n`// unknown in conditional types`\n\n`type T30<T> = unknown extends T ? true : false; // Deferred`\n\n`type T31<T> = T extends unknown ? true : false; // Deferred (so it distributes)`\n\n`type T32<T> = never extends T ? true : false; // true`\n\n`type T33<T> = T extends never ? true : false; // Deferred`\n\n`// keyof unknown`\n\n`type T40 = keyof any; // string | number | symbol`\n\n`type T41 = keyof unknown; // never`\n\n`// Only equality operators are allowed with unknown`\n\n`function f10(x: unknown) {`\n\n  `x == 5;`\n\n  `x !== 10;`\n\n  `x >= 0; // Error`\n\n  `x + 1; // Error`\n\n  `x * 2; // Error`\n\n  `-x; // Error`\n\n  `+x; // Error`\n\n`}`\n\n`// No property accesses, element accesses, or function calls`\n\n`function f11(x: unknown) {`\n\n  `x.foo; // Error`\n\n  `x[5]; // Error`\n\n  `x(); // Error`\n\n  `new x(); // Error`\n\n`}`\n\n`// typeof, instanceof, and user defined type predicates`\n\n`declare function isFunction(x: unknown): x is Function;`\n\n`function f20(x: unknown) {`\n\n  `if (typeof x === \"string\" || typeof x === \"number\") {`\n\n    `x; // string | number`\n\n  `}`\n\n  `if (x instanceof Error) {`\n\n    `x; // Error`\n\n  `}`\n\n  `if (isFunction(x)) {`\n\n    `x; // Function`\n\n  `}`\n\n`}`\n\n`// Homomorphic mapped type over unknown`\n\n`type T50<T> = { [P in keyof T]: number };`\n\n`type T51 = T50<any>; // { [x: string]: number }`\n\n`type T52 = T50<unknown>; // {}`\n\n`// Anything is assignable to unknown`\n\n`function f21<T>(pAny: any, pNever: never, pT: T) {`\n\n  `let x: unknown;`\n\n  `x = 123;`\n\n  `x = \"hello\";`\n\n  `x = [1, 2, 3];`\n\n  `x = new Error();`\n\n  `x = x;`\n\n  `x = pAny;`\n\n  `x = pNever;`\n\n  `x = pT;`\n\n`}`\n\n`// unknown assignable only to itself and any`\n\n`function f22(x: unknown) {`\n\n  `let v1: any = x;`\n\n  `let v2: unknown = x;`\n\n  `let v3: object = x; // Error`\n\n  `let v4: string = x; // Error`\n\n  `let v5: string[] = x; // Error`\n\n  `let v6: {} = x; // Error`\n\n  `let v7: {} | null | undefined = x; // Error`\n\n`}`\n\n`// Type parameter 'T extends unknown' not related to object`\n\n`function f23<T extends unknown>(x: T) {`\n\n  `let y: object = x; // Error`\n\n`}`\n\n`// Anything but primitive assignable to { [x: string]: unknown }`\n\n`function f24(x: { [x: string]: unknown }) {`\n\n  `x = {};`\n\n  `x = { a: 5 };`\n\n  `x = [1, 2, 3];`\n\n  `x = 123; // Error`\n\n`}`\n\n`// Locals of type unknown always considered initialized`\n\n`function f25() {`\n\n  `let x: unknown;`\n\n  `let y = x;`\n\n`}`\n\n`// Spread of unknown causes result to be unknown`\n\n`function f26(x: {}, y: unknown, z: any) {`\n\n  `let o1 = { a: 42, ...x }; // { a: number }`\n\n  `let o2 = { a: 42, ...x, ...y }; // unknown`\n\n  `let o3 = { a: 42, ...x, ...y, ...z }; // any`\n\n`}`\n\n`// Functions with unknown return type don't need return expressions`\n\n`function f27(): unknown {}`\n\n`// Rest type cannot be created from unknown`\n\n`function f28(x: unknown) {`\n\n  `let { ...a } = x; // Error`\n\n`}`\n\n`// Class properties of type unknown don't need definite assignment`\n\n`class C1 {`\n\n  `a: string; // Error`\n\n  `b: unknown;`\n\n  `c: any;`\n\n`}`\n\n## [](#support-for-defaultprops-in-jsx)Support for `defaultProps` in JSX\n\nTypeScript 2.9 and earlier didn’t leverage [React `defaultProps`](https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values) declarations inside JSX components. Users would often have to declare properties optional and use non-null assertions inside of `render`, or they’d use type-assertions to fix up the type of the component before exporting it.\n\nTypeScript 3.0 adds support for a new type alias in the `JSX` namespace called `LibraryManagedAttributes`. This helper type defines a transformation on the component’s `Props` type, before using to check a JSX expression targeting it; thus allowing customization like: how conflicts between provided props and inferred props are handled, how inferences are mapped, how optionality is handled, and how inferences from differing places should be combined.\n\nIn short using this general type, we can model React’s specific behavior for things like `defaultProps` and, to some extent, `propTypes`.\n\ntsx\n\n`export interface Props {`\n\n  `name: string;`\n\n`}`\n\n`export class Greet extends React.Component<Props> {`\n\n  `render() {`\n\n    `const { name } = this.props;`\n\n    `return <div>Hello {name.toUpperCase()}!</div>;`\n\n  `}`\n\n  `static defaultProps = { name: \"world\" };`\n\n`}`\n\n`// Type-checks! No type assertions needed!`\n\n`let el = <Greet />;`\n\n## [](#caveats)Caveats\n\n### [](#explicit-types-on-defaultprops)Explicit types on `defaultProps`\n\nThe default-ed properties are inferred from the `defaultProps` property type. If an explicit type annotation is added, e.g. `static defaultProps: Partial<Props>;` the compiler will not be able to identify which properties have defaults (since the type of `defaultProps` include all properties of `Props`).\n\nUse `static defaultProps: Pick<Props, \"name\">;` as an explicit type annotation instead, or do not add a type annotation as done in the example above.\n\nFor function components (formerly known as SFCs) use ES2015 default initializers:\n\ntsx\n\n`function Greet({ name = \"world\" }: Props) {`\n\n  `return <div>Hello {name.toUpperCase()}!</div>;`\n\n`}`\n\n#### [](#changes-to-typesreact)Changes to `@types/React`\n\nCorresponding changes to add `LibraryManagedAttributes` definition to the `JSX` namespace in `@types/React` are still needed. Keep in mind that there are some limitations.\n\n## [](#-reference-lib--reference-directives)`/// <reference lib=\"...\" />` reference directives\n\nTypeScript adds a new triple-slash-reference directive (`/// <reference lib=\"name\" />`), allowing a file to explicitly include an existing built-in _lib_ file.\n\nBuilt-in _lib_ files are referenced in the same fashion as the [`lib`](https://www.typescriptlang.org/tsconfig#lib) compiler option in _tsconfig.json_ (e.g. use `lib=\"es2015\"` and not `lib=\"lib.es2015.d.ts\"`, etc.).\n\nFor declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like `Symbol` or `Iterable`, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.\n\n##### [](#example-4)Example\n\nUsing `/// <reference lib=\"es2017.string\" />` to one of the files in a compilation is equivalent to compiling with `--lib es2017.string`.\n\nts\n\n`/// <reference lib=\"es2017.string\" />`\n\n`\"foo\".padStart(4);`",
    "title": "TypeScript: Documentation - TypeScript 3.0",
    "description": "TypeScript 3.0 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.2\n\n## [](#smarter-type-alias-preservation)Smarter Type Alias Preservation\n\nTypeScript has a way to declare new names for types called type aliases. If you’re writing a set of functions that all work on `string | number | boolean`, you can write a type alias to avoid repeating yourself over and over again.\n\nts\n\n`type BasicPrimitive = number | string | boolean;`\n\nTypeScript has always used a set of rules and guesses for when to reuse type aliases when printing out types. For example, take the following code snippet.\n\nts\n\n`export type BasicPrimitive = number | string | boolean;`\n\n`export function doStuff(value: BasicPrimitive) {`\n\n  `let x = value;`\n\n  `return x;`\n\n`}`\n\nIf we hover our mouse over `x` in an editor like Visual Studio, Visual Studio Code, or [the TypeScript Playground](https://www.typescriptlang.org/play?ts=4.1.3#code/KYDwDg9gTgLgBDAnmYcBCBDAzgSwMYAKUOAtjjDgG6oC8cAdgK4kBGwUcAPnFjMfQHMucFhAgAbYBnoBuAFBzQkWHABmjengoR6cACYQAyjEarVACkoZxjYAC502fEVLkqwAJRwA3nLj+4SXgQODorG2B5ALgoYBMoXRB5AF8gA), we’ll get a quick info panel that shows the type `BasicPrimitive`. Likewise, if we get the declaration file output (`.d.ts` output) for this file, TypeScript will say that `doStuff` returns `BasicPrimitive`.\n\nHowever, what happens if we return a `BasicPrimitive` or `undefined`?\n\nts\n\n`export type BasicPrimitive = number | string | boolean;`\n\n`export function doStuff(value: BasicPrimitive) {`\n\n  `if (Math.random() < 0.5) {`\n\n    `return undefined;`\n\n  `}`\n\n  `return value;`\n\n`}`\n\nWe can see what happens [in the TypeScript 4.1 playground](https://www.typescriptlang.org/play?ts=4.1.3#code/KYDwDg9gTgLgBDAnmYcBCBDAzgSwMYAKUOAtjjDgG6oC8cAdgK4kBGwUcAPnFjMfQHMucFhAgAbYBnoBuALAAoRQHplcABIRqHCPTgByACYQAyjEYAzC-pHBxEAO4IIPYKgcALDPAAqyYCZ4xGDwhjhYYOIYiFhwFtAIHqhQwOZQekgoAHQqagDqqGQCHvBe1HCgKHgwwIZw5M5wYPzw2Lm5cJ2YuITEZBTl3Iz0hsAWOPS1HR0sjPBs9k5+KIHB8AAsWQBMADT18BO8UnVhEVExcG0Kqh2dTKzswrz8QtyiElJ6QyNjE1PXykUlWg8Asw2qOF0cGMZksFgAFJQMOJGMAAFzobD4IikchUYAASjgAG9FJ1yTgLHB4QBZbweLJQaTGEjwokAHjgAAYsgBWImkhTk4WdFJpPTDUbjSaGeRC4UAX0UZOFYsY6TgSJRwDlcAVQA). While we might want TypeScript to display the return type of `doStuff` as `BasicPrimitive | undefined`, it instead displays `string | number | boolean | undefined`! What gives?\n\nWell this has to do with how TypeScript represents types internally. When creating a union type out of one or more union types, it will always _normalize_ those types into a new flattened union type - but doing that loses information. The type-checker would have to find every combination of types from `string | number | boolean | undefined` to see what type aliases could have been used, and even then, there might be multiple type aliases to `string | number | boolean`.\n\nIn TypeScript 4.2, our internals are a little smarter. We keep track of how types were constructed by keeping around parts of how they were originally written and constructed over time. We also keep track of, and differentiate, type aliases to instances of other aliases!\n\nBeing able to print back the types based on how you used them in your code means that as a TypeScript user, you can avoid some unfortunately humongous types getting displayed, and that often translates to getting better `.d.ts` file output, error messages, and in-editor type displays in quick info and signature help. This can help TypeScript feel a little bit more approachable for newcomers.\n\nFor more information, check out [the first pull request that improves various cases around preserving union type aliases](https://github.com/microsoft/TypeScript/pull/42149), along with [a second pull request that preserves indirect aliases](https://github.com/microsoft/TypeScript/pull/42284).\n\n## [](#leadingmiddle-rest-elements-in-tuple-types)Leading/Middle Rest Elements in Tuple Types\n\nIn TypeScript, tuple types are meant to model arrays with specific lengths and element types.\n\nts\n\n`// A tuple that stores a pair of numbers`\n\n`let a: [number, number] = [1, 2];`\n\n`// A tuple that stores a string, a number, and a boolean`\n\n`let b: [string, number, boolean] = [\"hello\", 42, true];`\n\nOver time, TypeScript’s tuple types have become more and more sophisticated, since they’re also used to model things like parameter lists in JavaScript. As a result, they can have optional elements and rest elements, and can even have labels for tooling and readability.\n\nts\n\n`// A tuple that has either one or two strings.`\n\n`let c: [string, string?] = [\"hello\"];`\n\n`c = [\"hello\", \"world\"];`\n\n`// A labeled tuple that has either one or two strings.`\n\n`let d: [first: string, second?: string] = [\"hello\"];`\n\n`d = [\"hello\", \"world\"];`\n\n`// A tuple with a *rest element* - holds at least 2 strings at the front,`\n\n`// and any number of booleans at the back.`\n\n`let e: [string, string, ...boolean[]];`\n\n`e = [\"hello\", \"world\"];`\n\n`e = [\"hello\", \"world\", false];`\n\n`e = [\"hello\", \"world\", true, false, true];`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEEFQFwVwBwDYFNoAsCGVQYM6iQJZSpIBOoA9gHYoXlQDuFoOUpBVA5jgHQBQyLAGMAXKADardlwA0LNh04B+ALqgAvBIBEJBAgpaVAbj5CN23fq1ytTUggAmhk3xARQCdACMkyB9HhkNExsdDxCYjJKGkp6Jnlpbn5BUAcxcQAzAlJWMSlFORwkIWoHJTyFLjVNcR1fK2M+fxq6vQMbO0dnPlcwSFhEFAYiVFB0UAAqUiRWfGQAWyQqKAnQAFpsCkc8EOQwrAAmBMUdrEjQDNJqKBlesap-dCoAT1AqGHmfcgoM0C8KLZIJ6nNAoLzoIQAa2SSCwSHS+VkxyRPFR-0BT3EKkafBQLUs7VAtjoXUaeIs9UJxPsTjkGXQCCKZPMtQJ1iJnVp0FIMCQdIZRTkbF5xiAA)\n\nIn TypeScript 4.2, rest elements specifically been expanded in how they can be used. In prior versions, TypeScript only allowed `...rest` elements at the very last position of a tuple type.\n\nHowever, now rest elements can occur _anywhere_ within a tuple - with only a few restrictions.\n\nts\n\n`let foo: [...string[], number];`\n\n`foo = [123];`\n\n`foo = [\"hello\", 123];`\n\n`foo = [\"hello!\", \"hello!\", \"hello!\", 123];`\n\n`let bar: [boolean, ...string[], boolean];`\n\n`bar = [true, false];`\n\n`bar = [true, \"some text\", false];`\n\n`bar = [true, \"some\", \"separated\", \"text\", false];`\n\n[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAZg9jBcEDaA6NBnMAnAlgOwHMkBdAGgjwFcBbAIxC2IG4AoF2GCAXmQEYAmAMzN2cbsgBEACxDBgMCeQHDWHcUmmz5AQkURNcmLvIGde5SJahItAIZZESWnFC285NCky5CJcs5hXPEs7LHVsShByKFtgdBARUPCsSJN0GGoQCDAQAA8wPRi4hNYkniQIqP10zL0JeIAHe1scgBM6nPzC2PjmIA)\n\nThe only restriction is that a rest element can be placed anywhere in a tuple, so long as it’s not followed by another optional element or rest element. In other words, only one rest element per tuple, and no optional elements after rest elements.\n\nts\n\n`interface Clown {`\n\n  `/*...*/`\n\n`}`\n\n`interface Joker {`\n\n  `/*...*/`\n\n`}`\n\n`let StealersWheel: [...Clown[], \"me\", ...Joker[]];`\n\n`A rest element cannot follow another rest element.1265A rest element cannot follow another rest element.  let StringsAndMaybeBoolean: [...string[], boolean?];  An optional element cannot follow a rest element.1266An optional element cannot follow a rest element.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwCYBsBWd2sAoASwDsAXGAMwEMBjSUAYQBs4B3U0Ab0NFGAAqAHSjBwQgF8SFavUYApOAGsYPPgJFiJ0wi0jlQAZUo19SAOoALSJBaoA2qOGsOpBwF0ANKABEAW0hfH2clVWhPDwBuQj0DY3JoMgBzRABBUgATAFkaAE8AI0gAITg4fRpSR2dERJTPHwKyitIAfmigA)\n\nThese non-trailing rest elements can be used to model functions that take any number of leading arguments, followed by a few fixed ones.\n\nts\n\n`declare function doStuff(...args: [...names: string[], shouldCapitalize: boolean]): void;`\n\n`doStuff(/*shouldCapitalize:*/ false)`\n\n`doStuff(\"fee\", \"fi\", \"fo\", \"fum\", /*shouldCapitalize:*/ true);`\n\n[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtX2BwGUNlFEAKAOhtgHMBnALngG0arUoBbEZ+BhhhZUdVgF0ANAIAWOZBGABhKAAcsGKBCwAvECwBGOHBBBRU4gJQsAbjizAA3AChnhEmUoB6AFQM5CspqGlq6+j5eSFoMIJZuxKTkFABEiCAgydKpWJnwqTi5qcjcub7+8ooq6praekwR8ELIsY5AA)\n\nEven though JavaScript doesn’t have any syntax to model leading rest parameters, we were still able to declare `doStuff` as a function that takes leading arguments by declaring the `...args` rest parameter with _a tuple type that uses a leading rest element_. This can help model lots of existing JavaScript out there!\n\nFor more details, [see the original pull request](https://github.com/microsoft/TypeScript/pull/41544).\n\n## [](#stricter-checks-for-the-in-operator)Stricter Checks For The `in` Operator\n\nIn JavaScript, it is a runtime error to use a non-object type on the right side of the `in` operator. TypeScript 4.2 ensures this can be caught at design-time.\n\nts\n\n`\"foo\" in 42;`\n\n`Type 'number' is not assignable to type 'object'.2322Type 'number' is not assignable to type 'object'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsBGdG00AoAIgDM44TQBLAO1ABY0BuIA)\n\nThis check is fairly conservative for the most part, so if you have received an error about this, it is likely an issue in the code.\n\nA big thanks to our external contributor [Jonas Hübotter](https://github.com/jonhue) for [their pull request](https://github.com/microsoft/TypeScript/pull/41928)!\n\n## [](#--nopropertyaccessfromindexsignature)`--noPropertyAccessFromIndexSignature`\n\nBack when TypeScript first introduced index signatures, you could only get properties declared by them with “bracketed” element access syntax like `person[\"name\"]`.\n\nts\n\n`interface SomeType {`\n\n  `/** This is an index signature. */`\n\n  `[propName: string]: any;`\n\n`}`\n\n`function doStuff(value: SomeType) {`\n\n  `let x = value[\"someProperty\"];`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoHsC2EAqBPABxQG8AoZZAegCprkcALYAZ2ReThDZABMIAPZM2ABzEHDABXKBAB0yapXLIA2gSjoCAOTjYAXELBRQIgLoHOeANykAvqVIxJIBGGDouPdKikwYACgA3OAAbSQgDDGx8IgBKZDIKEIgwZEEAXmRgsIgVACJmLAgABQ0iKDA8PNMbWyA)\n\nThis ended up being cumbersome in situations where we need to work with objects that have arbitrary properties. For example, imagine an API where it’s common to misspell a property name by adding an extra `s` character at the end.\n\nts\n\n`interface Options {`\n\n  `/** File patterns to be excluded. */`\n\n  `exclude?: string[];`\n\n  `/**`\n\n   `* It handles any extra properties that we haven't declared as type 'any'.`\n\n   `*/`\n\n  `[x: string]: any;`\n\n`}`\n\n`function processOptions(opts: Options) {`\n\n  `` // Notice we're *intentionally* accessing `excludes`, not `exclude` ``\n\n  `if (opts.excludes) {`\n\n    `console.error(`\n\n      ``\"The option `excludes` is not valid. Did you mean `exclude`?\"``\n\n    `);`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM7IDeAUMsgPQBUlyAYsADYrpxiRT7JjbIBGKEAB4IGAVwAmEcQDpklcqWRCREiAH4AXMjxgooAOYBtALoBuYoqqVFc5AEkwyABZwQ4pgVcBPJYN1xkdChsdGgsCAIwF0cAdxQXADcIEAByR0kROCgpZDhIr1DkFO8U6Rt5RUNBLR09EH1jLW9zAF8LGFEQBCxcQOCkPDwMHvwAChCwPC1hnHwASiJLcmQAOWwsJGQ4lOy5UEhwWbgGBi8aRAG8A2QAA2UxSTwbgBpkEHXb+9UbxWAYZHGmDw0i+jwWJDIZAQuDw2CYIKgwSgoxskIARAAVJwoCazT7CB4RG7IYAEd6OBLHYAyZAAEWpyC82FEyAAthBXPiVJIbmo0ai5uYyG0WkA)\n\nTo make these types of situations easier, a while back, TypeScript made it possible to use “dotted” property access syntax like `person.name` when a type had a string index signature. This also made it easier to transition existing JavaScript code over to TypeScript.\n\nHowever, loosening the restriction also meant that misspelling an explicitly declared property became much easier.\n\nts\n\n`function processOptions(opts: Options) {`\n\n  `// ...`\n\n  ``// Notice we're *accidentally* accessing `excludes` this time.``\n\n  `// Oops! Totally valid.`\n\n  `for (const excludePattern of opts.excludes) {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM7IDeAUMsgPQBUlyAYsADYrpxiRT7JjbIBGKEAB4IGAVwAmEcQDpklcqWRCREiAH4AXMjxgooAOYBtALoBuYoqqVFc5AEkwyABZwQ4pgVcBPJYN1xkdChsdGgsCAIwF0cAdxQXADcIEAByR0kROCgpZDhIr1DkFO8U6Rt5RUNBLR09EH1jLW9zAF9icnJkAFoehFEwHq7iGFEQBCxcQOCkPDwMCfwAChCwPC15nHwASiJLTukDizIO5AA5bCwkZDiU7LlEBGBJcDgGBi8aB4i8A2QAA2UYkkeD+XCcwEiwAAthAysdOqgQngAITIAAqF1e72QCVeTzhyBg2CgyEWCFwOl8KkkAAVWOwQMhsDAmZg8NJAao8DsSGR4cgDgS2i0gA)\n\nIn some cases, users would prefer to explicitly opt into the index signature - they would prefer to get an error message when a dotted property access doesn’t correspond to a specific property declaration.\n\nThat’s why TypeScript introduces a new flag called [`noPropertyAccessFromIndexSignature`](https://www.typescriptlang.org/tsconfig#noPropertyAccessFromIndexSignature). Under this mode, you’ll be opted in to TypeScript’s older behavior that issues an error. This new setting is not under the [`strict`](https://www.typescriptlang.org/tsconfig#strict) family of flags, since we believe users will find it more useful on certain codebases than others.\n\nYou can understand this feature in more detail by reading up on the corresponding [pull request](https://github.com/microsoft/TypeScript/pull/40171/). We’d also like to extend a big thanks to [Wenlu Wang](https://github.com/Kingwl) who sent us this pull request!\n\n## [](#abstract-construct-signatures)`abstract` Construct Signatures\n\nTypeScript allows us to mark a class as _abstract_. This tells TypeScript that the class is only meant to be extended from, and that certain members need to be filled in by any subclass to actually create an instance.\n\nts\n\n`abstract class Shape {`\n\n  `abstract getArea(): number;`\n\n`}`\n\n`new Shape();`\n\n`Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.  class Square extends Shape {    #sideLength: number;    constructor(sideLength: number) {      super();      this.#sideLength = sideLength;    }    getArea() {      return this.#sideLength ** 2;    }  }  // Works fine.  new Square(42);  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWBQBDAI0QBdp8BjE0CgG30UVAGUALfAB0lAG9dRQRUuSqgA5pBIBBaJHwAKAJSoAdgFcAtoRgBuXAF9cuFZADuLdlyV7cdBk2YBHNflmhIADxKQVAEweW3HwCAMSIAJa+kAAyPmIkrKqa2tA2AhRwKsJqVAjyEVGxKvGJoOpaMIq8-AKgiGpc0NY1AgnhiAB0YZExcQmgALx1PUUlegKGNRLSsgpVwbWyJGrQKqBtnd2FfaygAFR76OOghpMgoADqCADWTABm4SYdxmYszq6Q8gAsaIo6QA)\n\nTo make sure this restriction in `new`\\-ing up `abstract` classes is consistently applied, you can’t assign an `abstract` class to anything that expects a construct signature.\n\nts\n\n`interface HasArea {`\n\n  `getArea(): number;`\n\n`}`\n\n`let Ctor: new () => HasArea = Shape;`\n\n`Type 'typeof Shape' is not assignable to type 'new () => HasArea'.   Cannot assign an abstract constructor type to a non-abstract constructor type.2322Type 'typeof Shape' is not assignable to type 'new () => HasArea'.   Cannot assign an abstract constructor type to a non-abstract constructor type.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEMAjRAF2jwGNjRyAbPRRUAZQAs8AHSUAbx1FEIkylUAHNIxAILRIeABQBKVADsArgFsCMANw4AvjhCgAtKfKrip4zgCWy4jABmFLgAl602Tz5iJn+Uqgapo6+jg4NBKgAMLECCqQAO6giqAAvAB8oO6I-unMbJzaQA)\n\nThis does the right thing in case we intend to run code like `new Ctor`, but it’s overly-restrictive in case we want to write a subclass of `Ctor`.\n\nts\n\n`abstract class Shape {`\n\n  `abstract getArea(): number;`\n\n`}`\n\n`interface HasArea {`\n\n  `getArea(): number;`\n\n`}`\n\n`function makeSubclassWithArea(Ctor: new () => HasArea) {`\n\n  `return class extends Ctor {`\n\n    `getArea() {`\n\n      `return 42`\n\n    `}`\n\n  `};`\n\n`}`\n\n`let MyShape = makeSubclassWithArea(Shape);`\n\n`Argument of type 'typeof Shape' is not assignable to parameter of type 'new () => HasArea'.   Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Shape' is not assignable to parameter of type 'new () => HasArea'.   Cannot assign an abstract constructor type to a non-abstract constructor type.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAIYBGiALtAQMamiUA2BiioAygBYEAOkoA3nqFDEyFaqADmkUgEFokAgAoAlKgB2AVwC2RGAG48AXzx4AlqtIwAZlR4AJRrPl8BEqY8UrQG7XsPHL6qrUJnCqoJoEANaQLOpE9IyIAOompGzuCgDCpAhqkADuoMqgALwAfKD2iO5KzoJypOrQYQlMoJAAHhaqACbM2Qh1gq4ych5Dw6ANTWFYaC6CRov6Rnh0UqAAsgCe7Fw8JeFRMXGtyanpYwp73Eq6QA)\n\nIt also doesn’t work well with built-in helper types like `InstanceType`.\n\nts\n\n`type MyInstance = InstanceType<typeof Shape>;`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQBDAI0QBdp8BjE0CgG30UVAGUALfAB0lAG9dRQRUuSqgA5pBIBBaJHwAKAJSoAdgFcAtoRgBuXAF9cIUAFozFNSTMncJAJ5dQAWTsBJFaXwqK3ALyh3T29IABUHSAAeey44ADMWdi4APh0gA)\n\nThat’s why TypeScript 4.2 allows you to specify an `abstract` modifier on constructor signatures.\n\nts\n\n`interface HasArea {`\n\n    `getArea(): number;`\n\n`}`\n\n`// Works!`\n\n`let Ctor: abstract new () => HasArea = Shape;`\n\n[Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgygC2ABwFMEBvAKAQVEhngQHMCIBBKA4ACgEoAuBAOwCuAWxAEoAblIBfUgHpZCALTLYAiMsWkAlnwhiAZnCIAJNCzYlyFeo3Mce-YaInTSchQHUA9lADWYAEJSZEYEAGEIH14qaDhEPgIAdwQuBABeAD4EUzA7dKxcQnEgA)\n\nAdding the `abstract` modifier to a construct signature signals that you can pass in `abstract` constructors. It doesn’t stop you from passing in other classes/constructor functions that are “concrete” - it really just signals that there’s no intent to run the constructor directly, so it’s safe to pass in either class type.\n\nThis feature allows us to write _mixin factories_ in a way that supports abstract classes. For example, in the following code snippet, we’re able to use the mixin function `withStyles` with the `abstract` class `SuperClass`.\n\nts\n\n`abstract class SuperClass {`\n\n    `abstract someMethod(): void;`\n\n    `badda() {}`\n\n`}`\n\n`type AbstractConstructor<T> = abstract new (...args: any[]) => T`\n\n`function withStyles<T extends AbstractConstructor<object>>(Ctor: T) {`\n\n    `abstract class StyledClass extends Ctor {`\n\n        `getStyles() {`\n\n            `// ...`\n\n        `}`\n\n    `}`\n\n    `return StyledClass;`\n\n`}`\n\n`class SubClass extends withStyles(SuperClass) {`\n\n    `someMethod() {`\n\n        `this.someMethod()`\n\n    `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgygVwA4FMoBhVdBAbwCgEaFRIZ4EwB7AW3wFl8IALFgCYAKAJQAuBADcWASwEBuarRDABA4KIoBfSjsoQAngQQBBcNDgQiLAHYNs8FlAA8AFQB8CALx1zjRDb4AO4IQgB0EcBQAOZgEsA2BgDaALoi3p6ulJQAZtg28DK2CEEyfJiGyPhgbgj4AB4Q+DYCGGYMltZ20A4QTs4sIABW+PDu7kJEfVASrulUtL4dTChoGBUGVQIka3WNza0IU04USos00TwbVWCaC+cPAPSPCBFhZ+c6i1+0UDzYUBsWEq+G2pDAij0qzIOBAOzIDSaLQwpXKINuOAIxHB8w+rA43D4gjuH0WfBkYDC+K4PH4whEHx0WiAA)\n\nNote that `withStyles` is demonstrating a specific rule, where a class (like `StyledClass`) that extends a value that’s generic and bounded by an abstract constructor (like `Ctor`) has to also be declared `abstract`. This is because there’s no way to know if a class with _more_ abstract members was passed in, and so it’s impossible to know whether the subclass implements all the abstract members.\n\nYou can read up more on abstract construct signatures [on its pull request](https://github.com/microsoft/TypeScript/pull/36392).\n\n## [](#understanding-your-project-structure-with---explainfiles)Understanding Your Project Structure With `--explainFiles`\n\nA surprisingly common scenario for TypeScript users is to ask “why is TypeScript including this file?“. Inferring the files of your program turns out to be a complicated process, and so there are lots of reasons why a specific combination of `lib.d.ts` got used, why certain files in `node_modules` are getting included, and why certain files are being included even though we thought specifying [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) would keep them out.\n\nThat’s why TypeScript now provides an [`explainFiles`](https://www.typescriptlang.org/tsconfig#explainFiles) flag.\n\nsh\n\n`tsc --explainFiles`\n\nWhen using this option, the TypeScript compiler will give some very verbose output about why a file ended up in your program. To read it more easily, you can forward the output to a file, or pipe it to a program that can easily view it.\n\nsh\n\n`# Forward output to a text file`\n\n`tsc --explainFiles > explanation.txt`\n\n``# Pipe output to a utility program like `less`, or an editor like VS Code``\n\n`tsc --explainFiles | less`\n\n`tsc --explainFiles | code -`\n\nTypically, the output will start out by listing out reasons for including `lib.d.ts` files, then for local files, and then `node_modules` files.\n\n`TS_Compiler_Directory/4.2.2/lib/lib.es5.d.ts`\n\n  `Library referenced via 'es5' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts'`\n\n`TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts`\n\n  `Library referenced via 'es2015' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts'`\n\n`TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts`\n\n  `Library referenced via 'es2016' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts'`\n\n`TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts`\n\n  `Library referenced via 'es2017' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts'`\n\n`TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts`\n\n  `Library referenced via 'es2018' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts'`\n\n`TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts`\n\n  `Library referenced via 'es2019' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts'`\n\n`TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts`\n\n  `Library referenced via 'es2020' from file 'TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts'`\n\n`TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts`\n\n  `Library 'lib.esnext.d.ts' specified in compilerOptions`\n\n`... More Library References...`\n\n`foo.ts`\n\n  `Matched by include pattern '**/*' in 'tsconfig.json'`\n\nRight now, we make no guarantees about the output format - it might change over time. On that note, we’re interested in improving this format if you have any suggestions!\n\nFor more information, [check out the original pull request](https://github.com/microsoft/TypeScript/pull/40011)!\n\n## [](#improved-uncalled-function-checks-in-logical-expressions)Improved Uncalled Function Checks in Logical Expressions\n\nThanks to further improvements from [Alex Tarasyuk](https://github.com/a-tarasyuk), TypeScript’s uncalled function checks now apply within `&&` and `||` expressions.\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), the following code will now error.\n\nts\n\n`function shouldDisplayElement(element: Element) {`\n\n  `// ...`\n\n  `return true;`\n\n`}`\n\n`function getVisibleItems(elements: Element[]) {`\n\n  `return elements.filter((e) => shouldDisplayElement && e.children.length);`\n\n  `//                          ~~~~~~~~~~~~~~~~~~~~`\n\n  `// This condition will always return true since the function is always defined.`\n\n  `// Did you mean to call it instead.`\n\n`}`\n\nFor more details, [check out the pull request here](https://github.com/microsoft/TypeScript/issues/40197).\n\n## [](#destructured-variables-can-be-explicitly-marked-as-unused)Destructured Variables Can Be Explicitly Marked as Unused\n\nThanks to another pull request from [Alex Tarasyuk](https://github.com/a-tarasyuk), you can now mark destructured variables as unused by prefixing them with an underscore (the `_` character).\n\nts\n\n`let [_first, second] = getValues();`\n\nPreviously, if `_first` was never used later on, TypeScript would issue an error under [`noUnusedLocals`](https://www.typescriptlang.org/tsconfig#noUnusedLocals). Now, TypeScript will recognize that `_first` was intentionally named with an underscore because there was no intent to use it.\n\nFor more details, take a look at [the full change](https://github.com/microsoft/TypeScript/pull/41378).\n\n## [](#relaxed-rules-between-optional-properties-and-string-index-signatures)Relaxed Rules Between Optional Properties and String Index Signatures\n\nString index signatures are a way of typing dictionary-like objects, where you want to allow access with arbitrary keys:\n\nts\n\n`const movieWatchCount: { [key: string]: number } = {};`\n\n`function watchMovie(title: string) {`\n\n  `movieWatchCount[title] = (movieWatchCount[title] ?? 0) + 1;`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtiAbgSwKYHUCGVgAsDCIArmFAFwwDeMA2gNaoCeF0ATsmAOYC6FYRcAEapWMAL4wAvFTEBuAFDyAZiWBRk4GAHdseALJI0ACnVQANqhZR2XAJRV5MeIYy6CxUjVMXuUmEYQUVxx3EigvZHNUXwB+GJgABnsAahgARgUxIA)\n\nOf course, for any movie title not yet in the dictionary, `movieWatchCount[title]` will be `undefined` (TypeScript 4.1 added the option [`noUncheckedIndexedAccess`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#checked-indexed-accesses---nouncheckedindexedaccess) to include `undefined` when reading from an index signature like this). Even though it’s clear that there must be some strings not present in `movieWatchCount`, previous versions of TypeScript treated optional object properties as unassignable to otherwise compatible index signatures, due to the presence of `undefined`.\n\nts\n\n`type WesAndersonWatchCount = {`\n\n  `\"Fantastic Mr. Fox\"?: number;`\n\n  `\"The Royal Tenenbaums\"?: number;`\n\n  `\"Moonrise Kingdom\"?: number;`\n\n  `\"The Grand Budapest Hotel\"?: number;`\n\n`};`\n\n`declare const wesAndersonWatchCount: WesAndersonWatchCount;`\n\n`const movieWatchCount: { [key: string]: number } = wesAndersonWatchCount;`\n\n`//    ~~~~~~~~~~~~~~~ error!`\n\n`// Type 'WesAndersonWatchCount' is not assignable to type '{ [key: string]: number; }'.`\n\n`//    Property '\"Fantastic Mr. Fox\"' is incompatible with index signature.`\n\n`//      Type 'number | undefined' is not assignable to type 'number'.`\n\n`//        Type 'undefined' is not assignable to type 'number'. (2322)`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6hDOBBAdgEwgJ3ge2TAhsAMYAWAwtgK7LBQC8UA3gFBRQBEAYvjfvMAEsiUALIYAdFE7YAHuwD8ALijJKAWwBGmANysOAFRLQASthD4ANlH0RktjfnXwFy1Zp172I7LgwD40ADSAsgA5qjYai4q6loYumzshtAA4hg8qFAAQpSo+JD8UAAS2MAQFtFucboAvrrM6EQW+BjQRLiFAO4IKOhYuATE5FQ0ynBIaJg4eISkFNTAuu3IhWrYAG4CEINzI8DKjFAA2gDWECDK-H5hALqusZhQNfRQ3RN90zvDC7oA9L9sNgAPxBoLB4KgmAw2AwAEJmP9rOBoAByca9KYDWbfGgoqD+FSlKB8eACULIfAaCzQYDYKCgSBQFGHU7nS7Aa6hO4xdzxJ4o8QIgGAgAK0MgGFATK4PGAfEEwjEkmkcjxBJC7TUYEIAip0E6AmAJHxkxkUFJ5MIlFagsRgLY+mRTKqjwAPlBqOgAGYhCCoNXwQm0Elkil6+l0hmol0YAVC+32x2MlGeiA+uz+-GB5BEkOW8O0+lOlExgVQAAUACYAMyVysASiAA)\n\nTypeScript 4.2 allows this assignment. However, it does _not_ allow the assignment of non-optional properties with `undefined` in their types, nor does it allow writing `undefined` to a specific key:\n\nts\n\n`type BatmanWatchCount = {`\n\n  `\"Batman Begins\": number | undefined;`\n\n  `\"The Dark Knight\": number | undefined;`\n\n  `\"The Dark Knight Rises\": number | undefined;`\n\n`};`\n\n`declare const batmanWatchCount: BatmanWatchCount;`\n\n`// Still an error in TypeScript 4.2.`\n\n`const movieWatchCount: { [key: string]: number } = batmanWatchCount;`\n\n``Type 'BatmanWatchCount' is not assignable to type '{ [key: string]: number; }'.   Property '\"Batman Begins\"' is incompatible with index signature.     Type 'number | undefined' is not assignable to type 'number'.       Type 'undefined' is not assignable to type 'number'.2322Type 'BatmanWatchCount' is not assignable to type '{ [key: string]: number; }'.   Property '\"Batman Begins\"' is incompatible with index signature.     Type 'number | undefined' is not assignable to type 'number'.       Type 'undefined' is not assignable to type 'number'.  // Still an error in TypeScript 4.2.  // Index signatures don't implicitly allow explicit `undefined`.  movieWatchCount[\"It's the Great Pumpkin, Charlie Brown\"] = undefined;  Type 'undefined' is not assignable to type 'number'.2322Type 'undefined' is not assignable to type 'number'.``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lACEBDPAWwoDsB1KgYwAsBhOAVzr1AF5QAbxyhQAIko165SAHMAlnUTjUdLtQBGMUAB9QPACaQAZksiGA3KIkAVVqQAiFaAGtQAaToK5rPKtB1LR19I1NzKxtxeycXdy8fP1AAJQVESBU1DW1oPQM6YzM6C2sAX2scY2YAGxdSZjhlPk0qWkYWDm5eVCk2pjw2Th48CpBQAGU8BWrq0BkYeFylUFtiSHHmaAUiPgAWADo0fZwGptBqOAA3BUh+wa68VCFQAG1XSAJURDwtujkAXSywVypQEoBa0naA06w1GYEm01m81gCFAy1WJA2Wx2oAORxwYwAkgVIAAPUCIHx0KhcaAZUCGRoAcj4CmoRGqCmYCjw1QIcxmcAA7qAyRyuTzQAADMJFCxS44Xa63DpDXgvcSEvBMxCgPAOUAAcTpVFAAAUNERXEoADSgdisFyc0hkeBCujif5g2URSxAA)\n\nThe new rule also does not apply to number index signatures, since they are assumed to be array-like and dense:\n\nts\n\n`declare let sortOfArrayish: { [key: number]: string };`\n\n`declare let numberKeys: { 42?: string };`\n\n`sortOfArrayish = numberKeys;`\n\n`Type '{ 42?: string | undefined; }' is not assignable to type '{ [key: number]: string; }'.   Property '42' is incompatible with index signature.     Type 'string | undefined' is not assignable to type 'string'.       Type 'undefined' is not assignable to type 'string'.2322Type '{ 42?: string | undefined; }' is not assignable to type '{ [key: number]: string; }'.   Property '42' is incompatible with index signature.     Type 'string | undefined' is not assignable to type 'string'.       Type 'undefined' is not assignable to type 'string'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABNIBjAGwENpJRjIAXURBGgeQDMBBWUgTwEtEALVAG9QAbQDWkLqgB2AVwC2AIxgBdVIhrQeMgOagAvgG58RMhSq1Q85TADSUlKBEAWNAH4NWnfuM4cDNDM7Jy8AqAAvNaKKtAOXIhGQA)\n\nYou can get a better sense of this change [by reading up on the original PR](https://github.com/microsoft/TypeScript/pull/41921).\n\n## [](#declare-missing-helper-function)Declare Missing Helper Function\n\nThanks to [a community pull request](https://github.com/microsoft/TypeScript/pull/41215) from [Alexander Tarasyuk](https://github.com/a-tarasyuk), we now have a quick fix for declaring new functions and methods based on the call-site!\n\n![An un-declared function foo being called, with a quick fix scaffolding out the new contents of the file](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/01/addMissingFunction-4.2.gif)\n\n## [](#breaking-changes)Breaking Changes\n\nWe always strive to minimize breaking changes in a release. TypeScript 4.2 contains some breaking changes, but we believe they should be manageable in an upgrade.\n\n### [](#libdts-updates)`lib.d.ts` Updates\n\nAs with every TypeScript version, declarations for `lib.d.ts` (especially the declarations generated for web contexts), have changed. There are various changes, though `Intl` and `ResizeObserver`’s may end up being the most disruptive.\n\n### [](#noimplicitany-errors-apply-to-loose-yield-expressions)`noImplicitAny` Errors Apply to Loose `yield` Expressions\n\nWhen the value of a `yield` expression is captured, but TypeScript can’t immediately figure out what type you intend for it to receive (i.e. the `yield` expression isn’t contextually typed), TypeScript will now issue an implicit `any` error.\n\nts\n\n`function* g1() {`\n\n  `const value = yield 1;`\n\n``'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.7057'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.  }  function* g2() {    // No error.    // The result of `yield 1` is unused.    yield 1;  }  function* g3() {    // No error.    // `yield 1` is contextually typed by 'string'.    const value: string = yield 1;  }  function* g4(): Generator<number, void, string> {    // No error.    // TypeScript can figure out the type of `yield 1`    // from the explicit return type of `g4`.    const value = yield 1;  }  ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYCsaBQAzAVwDsBjAFwEs5iAqUAcwEYAKASlAG9dRRSbE5UADcAhgBtCkUAF5QAT0qRxAE1BMA3LgC+uAiQrU6jAEzsuPUCFAA5OKBjxoAOkvWAKgAtp0SIkLiQnD4oAAGispqTKGglIigJISIkCquvBGq6lq6+mRUNPQMAMzm3LzWdg6wCGlWYOFKmdGx8fzE5JAAHuSEEuLyoOTyAA4poABGAwDkgtCUxAxTtW2CIhJSqLPzDLIKjVHZekR5RoUALOyoAOKQxDCi5AgAPMSEALbjMAA0InCUKj8tgsAHwWcpgSqOGpuMDuEaQADKpDmwyEpFExFA+EoDEIvlAcEIQnI3kG8IJIQakXUoRhWPgb0GpK6w3ElFIlCEvh60ExQ1GFLCDDOoWWAiEYkk0jkGQOOiAA)\n\nSee more details in [the corresponding changes](https://github.com/microsoft/TypeScript/pull/41348).\n\n### [](#expanded-uncalled-function-checks)Expanded Uncalled Function Checks\n\nAs described above, uncalled function checks will now operate consistently within `&&` and `||` expressions when using [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks). This can be a source of new breaks, but is typically an indication of a logic error in existing code.\n\n### [](#type-arguments-in-javascript-are-not-parsed-as-type-arguments)Type Arguments in JavaScript Are Not Parsed as Type Arguments\n\nType arguments were already not allowed in JavaScript, but in TypeScript 4.2, the parser will parse them in a more spec-compliant way. So when writing the following code in a JavaScript file:\n\nts\n\n`f<T>(100);`\n\nTypeScript will parse it as the following JavaScript:\n\njs\n\n`f < T > 100;`\n\nThis may impact you if you were leveraging TypeScript’s API to parse type constructs in JavaScript files, which may have occurred when trying to parse Flow files.\n\nSee [the pull request](https://github.com/microsoft/TypeScript/pull/41928) for more details on what’s checked.\n\n### [](#tuple-size-limits-for-spreads)Tuple size limits for spreads\n\nTuple types can be made by using any sort of spread syntax (`...`) in TypeScript.\n\nts\n\n`// Tuple types with spread elements`\n\n`type NumStr = [number, string];`\n\n`type NumStrNumStr = [...NumStr, ...NumStr];`\n\n`// Array spread expressions`\n\n`const numStr = [123, \"hello\"] as const;`\n\n`const numStrNumStr = [...numStr, ...numStr] as const;`\n\nSometimes these tuple types can accidentally grow to be huge, and that can make type-checking take a long time. Instead of letting the type-checking process hang (which is especially bad in editor scenarios), TypeScript has a limiter in place to avoid doing all that work.\n\nYou can [see this pull request](https://github.com/microsoft/TypeScript/pull/42448) for more details.\n\n### [](#dts-extensions-cannot-be-used-in-import-paths)`.d.ts` Extensions Cannot Be Used In Import Paths\n\nIn TypeScript 4.2, it is now an error for your import paths to contain `.d.ts` in the extension.\n\nts\n\n`// must be changed to something like`\n\n`//   - \"./foo\"`\n\n`//   - \"./foo.js\"`\n\n`import { Foo } from \"./foo.d.ts\";`\n\nInstead, your import paths should reflect whatever your loader will do at runtime. Any of the following imports might be usable instead.\n\nts\n\n`import { Foo } from \"./foo\";`\n\n`import { Foo } from \"./foo.js\";`\n\n`import { Foo } from \"./foo/index.js\";`\n\n### [](#reverting-template-literal-inference)Reverting Template Literal Inference\n\nThis change removed a feature from TypeScript 4.2 beta. If you haven’t yet upgraded past our last stable release, you won’t be affected, but you may still be interested in the change.\n\nThe beta version of TypeScript 4.2 included a change in inference to template strings. In this change, template string literals would either be given template string types or simplify to multiple string literal types. These types would then _widen_ to `string` when assigning to mutable variables.\n\nts\n\n`declare const yourName: string;`\n\n`// 'bar' is constant.`\n\n``// It has type '`hello ${string}`'.``\n\n``const bar = `hello ${yourName}`;``\n\n`// 'baz' is mutable.`\n\n`// It has type 'string'.`\n\n``let baz = `hello ${yourName}`;``\n\nThis is similar to how string literal inference works.\n\nts\n\n`// 'bar' has type '\"hello\"'.`\n\n`const bar = \"hello\";`\n\n`// 'baz' has type 'string'.`\n\n`let baz = \"hello\";`\n\nFor that reason, we believed that making template string expressions have template string types would be “consistent”; however, from what we’ve seen and heard, that isn’t always desirable.\n\nIn response, we’ve reverted this feature (and potential breaking change). If you _do_ want a template string expression to be given a literal-like type, you can always add `as const` to the end of it.\n\nts\n\n`declare const yourName: string;`\n\n``// 'bar' has type '`hello ${string}`'.``\n\n``const bar = `hello ${yourName}` as const;``\n\n`//                              ^^^^^^^^`\n\n`// 'baz' has type 'string'.`\n\n``const baz = `hello ${yourName}`;``\n\n### [](#typescripts-lift-callback-in-visitnode-uses-a-different-type)TypeScript’s `lift` Callback in `visitNode` Uses a Different Type\n\nTypeScript has a `visitNode` function that takes a `lift` function. `lift` now expects a `readonly Node[]` instead of a `NodeArray<Node>`. This is technically an API breaking change which you can read more on [here](https://github.com/microsoft/TypeScript/pull/42000).",
    "title": "TypeScript: Documentation - TypeScript 4.2",
    "description": "TypeScript 4.2 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.7\n\n## [](#constant-named-properties)Constant-named properties\n\nTypeScript 2.7 adds support for declaring const-named properties on types including ECMAScript symbols.\n\n##### [](#example)Example\n\nts\n\n`// Lib`\n\n`export const SERIALIZE = Symbol(\"serialize-method-key\");`\n\n`export interface Serializable {`\n\n  `[SERIALIZE](obj: {}): string;`\n\n`}`\n\nts\n\n`// consumer`\n\n`import { SERIALIZE, Serializable } from \"lib\";`\n\n`class JSONSerializableItem implements Serializable {`\n\n  `[SERIALIZE](obj: {}) {`\n\n    `return JSON.stringify(obj);`\n\n  `}`\n\n`}`\n\nThis also applies to numeric and string literals.\n\n##### [](#example-1)Example\n\nts\n\n`const Foo = \"Foo\";`\n\n`const Bar = \"Bar\";`\n\n`let x = {`\n\n  `[Foo]: 100,`\n\n  `[Bar]: \"hello\"`\n\n`};`\n\n`let a = x[Foo]; // has type 'number'`\n\n`let b = x[Bar]; // has type 'string'`\n\n## [](#unique-symbol)`unique symbol`\n\nTo enable treating symbols as unique literals a new type `unique symbol` is available. `unique symbol` is a subtype of `symbol`, and are produced only from calling `Symbol()` or `Symbol.for()`, or from explicit type annotations. The new type is only allowed on `const` declarations and `readonly static` properties, and in order to reference a specific unique symbol, you’ll have to use the `typeof` operator. Each reference to a `unique symbol` implies a completely unique identity that’s tied to a given declaration.\n\n##### [](#example-2)Example\n\nts\n\n`// Works`\n\n`declare const Foo: unique symbol;`\n\n`// Error! 'Bar' isn't a constant.`\n\n`let Bar: unique symbol = Symbol();`\n\n`// Works - refers to a unique symbol, but its identity is tied to 'Foo'.`\n\n`let Baz: typeof Foo = Foo;`\n\n`// Also works.`\n\n`class C {`\n\n  `static readonly StaticSymbol: unique symbol = Symbol();`\n\n`}`\n\nBecause each `unique symbol` has a completely separate identity, no two `unique symbol` types are assignable or comparable to each other.\n\n##### [](#example-3)Example\n\nts\n\n`const Foo = Symbol();`\n\n`const Bar = Symbol();`\n\n`// Error: can't compare two unique symbols.`\n\n`if (Foo === Bar) {`\n\n  `// ...`\n\n`}`\n\n## [](#strict-class-initialization)Strict Class Initialization\n\nTypeScript 2.7 introduces a new flag called [`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization). This flag performs checks to ensure that each instance property of a class gets initialized in the constructor body, or by a property initializer. For example\n\nts\n\n`class C {`\n\n  `foo: number;`\n\n  `bar = \"hello\";`\n\n  `baz: boolean;`\n\n  `//  ~~~`\n\n  `//  Error! Property 'baz' has no initializer and is not definitely assigned in the`\n\n  `//         constructor.`\n\n  `constructor() {`\n\n    `this.foo = 42;`\n\n  `}`\n\n`}`\n\nIn the above, if we truly meant for `baz` to potentially be `undefined`, we should have declared it with the type `boolean | undefined`.\n\nThere are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new _definite assignment assertion modifiers_ for your properties (discussed below).\n\nts\n\n`class C {`\n\n  `foo!: number;`\n\n  `// ^`\n\n  `// Notice this '!' modifier.`\n\n  `// This is the \"definite assignment assertion\"`\n\n  `constructor() {`\n\n    `this.initialize();`\n\n  `}`\n\n  `initialize() {`\n\n    `this.foo = 0;`\n\n  `}`\n\n`}`\n\nKeep in mind that [`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization) will be turned on along with other [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode flags, which can impact your project. You can set the [`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization) setting to `false` in your `tsconfig.json`’s `compilerOptions`, or `--strictPropertyInitialization false` on the command line to turn off this checking.\n\n## [](#definite-assignment-assertions)Definite Assignment Assertions\n\nThe definite assignment assertion is a feature that allows a `!` to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript’s analyses cannot detect so.\n\n##### [](#example-4)Example\n\nts\n\n`let x: number;`\n\n`initialize();`\n\n`console.log(x + x);`\n\n`//          ~   ~`\n\n`// Error! Variable 'x' is used before being assigned.`\n\n`function initialize() {`\n\n  `x = 10;`\n\n`}`\n\nWith definite assignment assertions, we can assert that `x` is really assigned by appending an `!` to its declaration:\n\nts\n\n`// Notice the '!'`\n\n`let x!: number;`\n\n`initialize();`\n\n`// No error!`\n\n`console.log(x + x);`\n\n`function initialize() {`\n\n  `x = 10;`\n\n`}`\n\nIn a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which _expressions_ are post-fixed with a `!`), which we could also have used in the example.\n\nts\n\n`let x: number;`\n\n`initialize();`\n\n`// No error!`\n\n`console.log(x! + x!);`\n\n`function initialize() {`\n\n    `x = 10;`\n\n`}`\n\nIn our example, we knew that all uses of `x` would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.\n\n## [](#fixed-length-tuples)Fixed Length Tuples\n\nIn TypeScript 2.6 and earlier, `[number, string, string]` was considered a subtype of `[number, string]`. This was motivated by TypeScript’s structural nature; the first and second elements of a `[number, string, string]` are respectively subtypes of the first and second elements of `[number, string]`. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.\n\nIn TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from [Kiara Grouwstra](https://github.com/KiaraGrouwstra), tuple types now encode their arity into the type of their respective `length` property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.\n\nConceptually, you might consider the type `[number, string]` to be equivalent to the following declaration of `NumStrTuple`:\n\nts\n\n`interface NumStrTuple extends Array<number | string> {`\n\n  `0: number;`\n\n  `1: string;`\n\n  `length: 2; // using the numeric literal type '2'`\n\n`}`\n\nNote that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a `length` property, falling back to `number`.\n\nts\n\n`interface MinimumNumStrTuple extends Array<number | string> {`\n\n  `0: number;`\n\n  `1: string;`\n\n`}`\n\nNote that this does not imply tuples represent immutable arrays, but it is an implied convention.\n\n## [](#improved-type-inference-for-object-literals)Improved type inference for object literals\n\nTypeScript 2.7 improves type inference for multiple object literals occurring in the same context. When multiple object literal types contribute to a union type, we now _normalize_ the object literal types such that all properties are present in each constituent of the union type.\n\nConsider:\n\nts\n\n`const obj = test ? { text: \"hello\" } : {}; // { text: string } | { text?: undefined }`\n\n`const s = obj.text; // string | undefined`\n\nPreviously type `{}` was inferred for `obj` and the second line subsequently caused an error because `obj` would appear to have no properties. That obviously wasn’t ideal.\n\n##### [](#example-5)Example\n\nts\n\n`// let obj: { a: number, b: number } |`\n\n`//     { a: string, b?: undefined } |`\n\n`//     { a?: undefined, b?: undefined }`\n\n`let obj = [{ a: 1, b: 2 }, { a: \"abc\" }, {}][0];`\n\n`obj.a; // string | number | undefined`\n\n`obj.b; // number | undefined`\n\nMultiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:\n\nts\n\n`declare function f<T>(...items: T[]): T;`\n\n`// let obj: { a: number, b: number } |`\n\n`//     { a: string, b?: undefined } |`\n\n`//     { a?: undefined, b?: undefined }`\n\n`let obj = f({ a: 1, b: 2 }, { a: \"abc\" }, {});`\n\n`obj.a; // string | number | undefined`\n\n`obj.b; // number | undefined`\n\n## [](#improved-handling-of-structurally-identical-classes-and-instanceof-expressions)Improved handling of structurally identical classes and `instanceof` expressions\n\nTypeScript 2.7 improves the handling of structurally identical classes in union types and `instanceof` expressions:\n\n*   Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).\n*   Union type subtype reduction only removes a class type if it is a subclass of _and_ derives from another class type in the union.\n*   Type checking of the `instanceof` operator is now based on whether the type of the left operand _derives from_ the type indicated by the right operand (as opposed to a structural subtype check).\n\nThis means that union types and `instanceof` properly distinguish between structurally identical classes.\n\n##### [](#example-6)Example\n\nts\n\n`class A {}`\n\n`class B extends A {}`\n\n`class C extends A {}`\n\n`class D extends A {`\n\n  `c: string;`\n\n`}`\n\n`class E extends D {}`\n\n`let x1 = !true ? new A() : new B(); // A`\n\n`let x2 = !true ? new B() : new C(); // B | C (previously B)`\n\n`let x3 = !true ? new C() : new D(); // C | D (previously C)`\n\n`let a1 = [new A(), new B(), new C(), new D(), new E()]; // A[]`\n\n`let a2 = [new B(), new C(), new D(), new E()]; // (B | C | D)[] (previously B[])`\n\n`function f1(x: B | C | D) {`\n\n  `if (x instanceof B) {`\n\n    `x; // B (previously B | D)`\n\n  `} else if (x instanceof C) {`\n\n    `x; // C`\n\n  `} else {`\n\n    `x; // D (previously never)`\n\n  `}`\n\n`}`\n\n## [](#type-guards-inferred-from-in-operator)Type guards inferred from `in` operator\n\nThe `in` operator now acts as a narrowing expression for types.\n\nFor a `n in x` expression, where `n` is a string literal or string literal type and `x` is a union type, the “true” branch narrows to types which have an optional or required property `n`, and the “false” branch narrows to types which have an optional or missing property `n`.\n\n##### [](#example-7)Example\n\nts\n\n`interface A {`\n\n  `a: number;`\n\n`}`\n\n`interface B {`\n\n  `b: string;`\n\n`}`\n\n`function foo(x: A | B) {`\n\n  `if (\"a\" in x) {`\n\n    `return x.a;`\n\n  `}`\n\n  `return x.b;`\n\n`}`\n\n## [](#support-for-import-d-from-cjs-from-commonjs-modules-with---esmoduleinterop)Support for `import d from \"cjs\"` from CommonJS modules with `--esModuleInterop`\n\nTypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace records based on the presence of an `__esModule` indicator under [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop). The change brings the generated output from TypeScript closer to that generated by Babel.\n\nPreviously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:\n\n*   TypeScript treats a namespace import (i.e. `import * as foo from \"foo\"`) for a CommonJS/AMD/UMD module as equivalent to `const foo = require(\"foo\")`.Things are simple here, but they don’t work out if the primary object being imported is a primitive or a class or a function. ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (`foo` in the example above) is not callable, though allowed by TypeScript\n*   Similarly a default import (i.e. `import d from \"foo\"`) for a CommonJS/AMD/UMD module as equivalent to `const d = require(\"foo\").default`.Most of the CommonJS/AMD/UMD modules available today do not have a `default` export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance `import fs from \"fs\"` or `import express from \"express\"` are not allowed.\n\nUnder the new [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop) these two issues should be addressed:\n\n*   A namespace import (i.e. `import * as foo from \"foo\"`) is now correctly flagged as uncallable. Calling it will result in an error.\n*   Default imports to CommonJS/AMD/UMD are now allowed (e.g. `import fs from \"fs\"`), and should work as expected.\n\n> Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. **We highly recommend applying it both to new and existing projects.** For existing projects, namespace imports (`import * as express from \"express\"; express();`) will need to be converted to default imports (`import express from \"express\"; express();`).\n\n##### [](#example-8)Example\n\nWith [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop) two new helpers are generated `__importStar` and `__importDefault` for import `*` and import `default` respectively. For instance input like:\n\nts\n\n`import * as foo from \"foo\";`\n\n`import b from \"bar\";`\n\nWill generate:\n\njs\n\n`\"use strict\";`\n\n`var __importStar =`\n\n  `(this && this.__importStar) ||`\n\n  `function(mod) {`\n\n    `if (mod && mod.__esModule) return mod;`\n\n    `var result = {};`\n\n    `if (mod != null)`\n\n      `for (var k in mod)`\n\n        `if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];`\n\n    `result[\"default\"] = mod;`\n\n    `return result;`\n\n  `};`\n\n`var __importDefault =`\n\n  `(this && this.__importDefault) ||`\n\n  `function(mod) {`\n\n    `return mod && mod.__esModule ? mod : { default: mod };`\n\n  `};`\n\n`exports.__esModule = true;`\n\n`var foo = __importStar(require(\"foo\"));`\n\n`var bar_1 = __importDefault(require(\"bar\"));`\n\n## [](#numeric-separators)Numeric separators\n\nTypeScript 2.7 brings support for [ES Numeric Separators](https://github.com/tc39/proposal-numeric-separator). Numeric literals can now be separated into segments using `_`.\n\n##### [](#example-9)Example\n\nts\n\n`const million = 1_000_000;`\n\n`const phone = 555_734_2231;`\n\n`const bytes = 0xff_0c_00_ff;`\n\n`const word = 0b1100_0011_1101_0001;`\n\n## [](#cleaner-output-in---watch-mode)Cleaner output in `--watch` mode\n\nTypeScript’s `--watch` mode now clears the screen after a re-compilation is requested.\n\n## [](#prettier---pretty-output)Prettier `--pretty` output\n\nTypeScript’s [`pretty`](https://www.typescriptlang.org/tsconfig#pretty) flag can make error messages easier to read and manage. [`pretty`](https://www.typescriptlang.org/tsconfig#pretty) now uses colors for file names, diagnostic codes, and line numbers. File names and positions are now also formatted to allow navigation in common terminals (e.g. Visual Studio Code terminal).",
    "title": "TypeScript: Documentation - TypeScript 2.7",
    "description": "TypeScript 2.7 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.0\n\n## [](#variadic-tuple-types)Variadic Tuple Types\n\nConsider a function in JavaScript called `concat` that takes two array or tuple types and concatenates them together to make a new array.\n\njs\n\n`function concat(arr1, arr2) {`\n\n  `return [...arr1, ...arr2];`\n\n`}`\n\nAlso consider `tail`, that takes an array or tuple, and returns all elements but the first.\n\njs\n\n`function tail(arg) {`\n\n  `const [_, ...result] = arg;`\n\n  `return result;`\n\n`}`\n\nHow would we type either of these in TypeScript?\n\nFor `concat`, the only valid thing we could do in older versions of the language was to try and write some overloads.\n\nts\n\n`function concat(arr1: [], arr2: []): [];`\n\n`function concat<A>(arr1: [A], arr2: []): [A];`\n\n`function concat<A, B>(arr1: [A, B], arr2: []): [A, B];`\n\n`function concat<A, B, C>(arr1: [A, B, C], arr2: []): [A, B, C];`\n\n`function concat<A, B, C, D>(arr1: [A, B, C, D], arr2: []): [A, B, C, D];`\n\n`function concat<A, B, C, D, E>(arr1: [A, B, C, D, E], arr2: []): [A, B, C, D, E];`\n\n`function concat<A, B, C, D, E, F>(arr1: [A, B, C, D, E, F], arr2: []): [A, B, C, D, E, F];`\n\nUh…okay, that’s…seven overloads for when the second array is always empty. Let’s add some for when `arr2` has one argument.\n\nts\n\n`function concat<A2>(arr1: [], arr2: [A2]): [A2];`\n\n`function concat<A1, A2>(arr1: [A1], arr2: [A2]): [A1, A2];`\n\n`function concat<A1, B1, A2>(arr1: [A1, B1], arr2: [A2]): [A1, B1, A2];`\n\n`function concat<A1, B1, C1, A2>(arr1: [A1, B1, C1], arr2: [A2]): [A1, B1, C1, A2];`\n\n`function concat<A1, B1, C1, D1, A2>(arr1: [A1, B1, C1, D1], arr2: [A2]): [A1, B1, C1, D1, A2];`\n\n`function concat<A1, B1, C1, D1, E1, A2>(arr1: [A1, B1, C1, D1, E1], arr2: [A2]): [A1, B1, C1, D1, E1, A2];`\n\n`function concat<A1, B1, C1, D1, E1, F1, A2>(arr1: [A1, B1, C1, D1, E1, F1], arr2: [A2]): [A1, B1, C1, D1, E1, F1, A2];`\n\nWe hope it’s clear that this is getting unreasonable. Unfortunately, you’d also end up with the same sorts of issues typing a function like `tail`.\n\nThis is another case of what we like to call “death by a thousand overloads”, and it doesn’t even solve the problem generally. It only gives correct types for as many overloads as we care to write. If we wanted to make a catch-all case, we’d need an overload like the following:\n\nts\n\n`function concat<T, U>(arr1: T[], arr2: U[]): Array<T | U>;`\n\nBut that signature doesn’t encode anything about the lengths of the input, or the order of the elements, when using tuples.\n\nTypeScript 4.0 brings two fundamental changes, along with inference improvements, to make typing these possible.\n\nThe first change is that spreads in tuple type syntax can now be generic. This means that we can represent higher-order operations on tuples and arrays even when we don’t know the actual types we’re operating over. When generic spreads are instantiated (or, replaced with a real type) in these tuple types, they can produce other sets of array and tuple types.\n\nFor example, that means we can type function like `tail`, without our “death by a thousand overloads” issue.\n\nts\n\n`function tail<T extends any[]>(arr: readonly [any, ...T]) {`\n\n  `const [_ignored, ...rest] = arr;`\n\n  `return rest;`\n\n`}`\n\n`const myTuple = [1, 2, 3, 4] as const;`\n\n`const myArray = [\"hello\", \"world\"];`\n\n`const r1 = tail(myTuple);`\n\n      `const r1: [2, 3, 4]`\n\n`const r2 = tail([...myTuple, ...myArray] as const);`\n\n      `const r2: [2, 3, 4, ...string[]]`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFAhjANgHgCqIKYAeUeYAJgM6IpgCeA2gLoB8AFCgE7sBci7eKpBOhqI61GgBpEAOlnYGASkQBvAFCJEEBOSiiA+jADmYOH1JTZ0vjoaIAvFU4BudbzxQQ7JNaguAvqqqWmA6iAC2NNggAA7oePaiAIxSAExSAMxSACy2KJTBOi4FuhEAgpwoIg50AEQAFnjo6HA1UjUA7qbopDUMLkHauuyJCagYLBFRsXgKLgD0cxoaAHoA-IHFvCmjaOgsdJaTMXEWsmUVNLn5g7OqC0uIa0A)\n\nThe second change is that rest elements can occur anywhere in a tuple - not just at the end!\n\nts\n\n`type Strings = [string, string];`\n\n`type Numbers = [number, number];`\n\n`type StrStrNumNumBool = [...Strings, ...Numbers, boolean];`\n\nPreviously, TypeScript would issue an error like the following:\n\n`A rest element must be last in a tuple type.`\n\nBut with TypeScript 4.0, this restriction is relaxed.\n\nNote that in cases when we spread in a type without a known length, the resulting type becomes unbounded as well, and all the following elements factor into the resulting rest element type.\n\nts\n\n`type Strings = [string, string];`\n\n`type Numbers = number[];`\n\n`type Unbounded = [...Strings, ...Numbers, boolean];`\n\nBy combining both of these behaviors together, we can write a single well-typed signature for `concat`:\n\nts\n\n`type Arr = readonly any[];`\n\n`function concat<T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U] {`\n\n  `return [...arr1, ...arr2];`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnKBeKcIEMAmB7AdgGxCnVxAG0BdAbgCgaAzAV1wGNgBLPKFvF9YADwAVKBAAewCLkwBnWAgA0UAKqiJU2fLgA+ABToEARgBcUIUoNwATKeUBKU2QB0L81BdPlFKAG8aUVAhgRjhcKGcXS0MlD0srahoAXyA)\n\nWhile that one signature is still a bit lengthy, it’s just one signature that doesn’t have to be repeated, and it gives predictable behavior on all arrays and tuples.\n\nThis functionality on its own is great, but it shines in more sophisticated scenarios too. For example, consider a function to [partially apply arguments](https://en.wikipedia.org/wiki/Partial_application) called `partialCall`. `partialCall` takes a function - let’s call it `f` - along with the initial few arguments that `f` expects. It then returns a new function that takes any other arguments that `f` still needs, and calls `f` when it receives them.\n\njs\n\n`function partialCall(f, ...headArgs) {`\n\n  `return (...tailArgs) => f(...headArgs, ...tailArgs);`\n\n`}`\n\nTypeScript 4.0 improves the inference process for rest parameters and rest tuple elements so that we can type this and have it “just work”.\n\nts\n\n`type Arr = readonly unknown[];`\n\n`function partialCall<T extends Arr, U extends Arr, R>(`\n\n  `f: (...args: [...T, ...U]) => R,`\n\n  `...headArgs: T`\n\n`) {`\n\n  `return (...tailArgs: U) => f(...headArgs, ...tailArgs);`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnKBeKcIEMAmB7AdgGxCgFdcBrXbAd1wG0BdAbgChmAzUgY2AEs8ow6OL3T4AwqPwAeACpQIAD2ARcmAM6wEAGigBVeUpXrNcHQCUAfAApmUKGwBcUKwDo3QgOZqntNy5k6frr0AJTIFlBmWrZQfgAWGJjwXk4yzGEA3jFowMRwuM5+wOg8+MneemFIEWyubglY5YFuxaXlISwAvkA)\n\nIn this case, `partialCall` understands which parameters it can and can’t initially take, and returns functions that appropriately accept and reject anything left over.\n\nts\n\n`const foo = (x: string, y: number, z: boolean) => {};`\n\n`const f1 = partialCall(foo, 100);`\n\n`Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.  const f2 = partialCall(foo, \"hello\", 100, true, \"oops\");  Expected 4 arguments, but got 5.2554Expected 4 arguments, but got 5.  // This works!  const f3 = partialCall(foo, \"hello\");        const f3: (y: number, z: boolean) => void  // What can we do with f3 now?  // Works!  f3(123, true);  f3();  Expected 2 arguments, but got 0.2554Expected 2 arguments, but got 0.  f3(123, \"hello\");  Argument of type 'string' is not assignable to parameter of type 'boolean'.2345Argument of type 'string' is not assignable to parameter of type 'boolean'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdOct9D1scAoAFwE8AHSUAQVlAF5RpIBDAEzgDsANtVABXfgGt+cAO78A2gF0A3OXIAzcQGNKASwGhaXaHq6CAwmcEAeACqhIAD0qR+PRE1gAaUAFUHzq7untA+AEoAfAAU5KCg6qhRAHQpxgDmKKDyKUm2Pjm+igCUbBGgYV6xoDkAFtw8zBmotuQlAN5VnJSi0PygySmUXLqCjZm+Jaxl6gNJdbxj+YPDo9AZRaoAvuQgoAC0B1qilAd75FoCiJTxcHBs-Y6oV9C6-Gk+1Kj8ogC2AEYwHwAL1Qf1ugm4-EmZTam1U50u13UAEZ7kYTLozJZBIIoupbj5kQAGIkbNQXfhXeJoNHGUwWKx4gmgABEdRxcBZhJJPko0FEkB8LNutEQLLJOzAthqug8MgQEkQAEIEZSkRhaRisYz8XAhezBJyybs4qAAHoAfjUuwA6jUuNctFw+jIGHxQDJdJQavENdIZFbJaAbQrlRoMFFkZhefzIBL1BH4xGoxh9ZAOeLlEA)\n\nVariadic tuple types enable a lot of new exciting patterns, especially around function composition. We expect we may be able to leverage it to do a better job type-checking JavaScript’s built-in `bind` method. A handful of other inference improvements and patterns also went into this, and if you’re interested in learning more, you can take a look at [the pull request](https://github.com/microsoft/TypeScript/pull/39094) for variadic tuples.\n\n## [](#labeled-tuple-elements)Labeled Tuple Elements\n\nImproving the experience around tuple types and parameter lists is important because it allows us to get strongly typed validation around common JavaScript idioms - really just slicing and dicing argument lists and passing them to other functions. The idea that we can use tuple types for rest parameters is one place where this is crucial.\n\nFor example, the following function that uses a tuple type as a rest parameter…\n\nts\n\n`function foo(...args: [string, number]): void {`\n\n  `// ...`\n\n`}`\n\n…should appear no different from the following function…\n\nts\n\n`function foo(arg0: string, arg1: number): void {`\n\n  `// ...`\n\n`}`\n\n…for any caller of `foo`.\n\nts\n\n`foo(\"hello\", 42);`\n\n`foo(\"hello\", 42, true);`\n\n`Expected 2 arguments, but got 3.2554Expected 2 arguments, but got 3.  foo(\"hello\");  Expected 2 arguments, but got 1.2554Expected 2 arguments, but got 1.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jR844AKAQ2gHMAGVRc6S4tgBpQrNgEZUxQgFsARjACUqAG5xKAE1ABvXKFAhQAOmO4AvrgMBaa6ULlrlgg0YAiABaQANp7gvh2NAUAblwnJncvHz9QAOFeQkhgsNcPb19goA)\n\nThere is one place where the differences begin to become observable though: readability. In the first example, we have no parameter names for the first and second elements. While these have no impact on type-checking, the lack of labels on tuple positions can make them harder to use - harder to communicate our intent.\n\nThat’s why in TypeScript 4.0, tuples types can now provide labels.\n\nts\n\n`type Range = [start: number, end: number];`\n\nTo deepen the connection between parameter lists and tuple types, the syntax for rest elements and optional elements mirrors the syntax for parameter lists.\n\nts\n\n`type Foo = [first: number, second?: string, ...rest: any[]];`\n\nThere are a few rules when using labeled tuples. For one, when labeling a tuple element, all other elements in the tuple must also be labeled.\n\nts\n\n`type Bar = [first: string, number];`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygKwAYAcAWAUAC4CeADpKAEICG0oAvKANoBmAlkgaogdKwHYBzADSg+AVwC2AIxgBdANxA)\n\nIt’s worth noting - labels don’t require us to name our variables differently when destructuring. They’re purely there for documentation and tooling.\n\nts\n\n`function foo(x: [first: string, second: number]) {`\n\n    `// ...`\n\n    `// note: we didn't need to name these 'first' and 'second'`\n\n    `const [a, b] = x;`\n\n    `a`\n\n   `const a: string`\n\n    `b`\n\n   `const b: number`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMOcAUAPAXIg2sGAJwGcodTCYwBzAGkWIFMIEATHMEAWwCNHCAugEpEAbwBQiKYgD0MxADol4ydLmIwcKIxwB3RolYxWYAORQNjRq0RQ4GgIZcDUABaMmiUwRJRTiBzAbUyYWINNVKTDSPAd6HgFEAF5EDABuSIDxdUQAPQB+TJ5s+TzCgF8gA)\n\nOverall, labeled tuples are handy when taking advantage of patterns around tuples and argument lists, along with implementing overloads in a type-safe way. In fact, TypeScript’s editor support will try to display them as overloads when possible.\n\n![Signature help displaying a union of labeled tuples as in a parameter list as two signatures](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/signatureHelpLabeledTuples.gif)\n\nTo learn more, check out [the pull request](https://github.com/microsoft/TypeScript/pull/38234) for labeled tuple elements.\n\n## [](#class-property-inference-from-constructors)Class Property Inference from Constructors\n\nTypeScript 4.0 can now use control flow analysis to determine the types of properties in classes when [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) is enabled.\n\nts\n\n`class Square {`\n\n  `// Previously both of these were any`\n\n  `area;`\n\n   `(property) Square.area: number`\n\n  `sideLength;`\n\n      `(property) Square.sideLength: number`\n\n  `constructor(sideLength: number) {`\n\n    `this.sideLength = sideLength;`\n\n    `this.area = sideLength ** 2;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKCOBXMAnAptA3gKGtA9PtAAroBuAlgPaIQgCe0ARlQC4AW0VAZtB2hAwB3NOmhgAdvVzj0YANzZC0AHoB+GRAoATNABk0EgOYdFy9TOBUJEVikTBWVFAAotug8Y4AuaBMQAtkyiAJRYMngcFBAAdO76hiacALzQ8Z5JiniR7NExqGhg0KnpiRzQAFQV0ABMWdAAvtgNQA)\n\nIn cases where not all paths of a constructor assign to an instance member, the property is considered to potentially be `undefined`.\n\nts\n\n`class Square {`\n\n  `sideLength;`\n\n      `(property) Square.sideLength: number | undefined`\n\n  `constructor(sideLength: number) {`\n\n    `if (Math.random()) {`\n\n      `this.sideLength = sideLength;`\n\n    `}`\n\n  `}`\n\n  `get area() {`\n\n    `return this.sideLength ** 2;`\n\n`Object is possibly 'undefined'.2532Object is possibly 'undefined'.    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoAYwBsBDRRUAZQEcBXW6SUAb3NFCIAlgBNIAGUgA7AOYAXABYBuciFAA9APzl+oSnCmI50NpTkIAFMLGTZi1FLYBbAEYwAlL10ChAM1AWALK0igB00LRSInBOFu6efAJJoIpCiKHWEtLyCqAAvIKiWXbK3qAAvrqVujKQcqCckLRxXslccmzQUikKaRlFtjmgAFTD6CoCleVAA)\n\nIn cases where you know better (e.g. you have an `initialize` method of some sort), you’ll still need an explicit type annotation along with a definite assignment assertion (`!`) if you’re in [`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization).\n\nts\n\n`class Square {`\n\n  `// definite assignment assertion`\n\n  `//        v`\n\n  `sideLength!: number;`\n\n  `// type annotation`\n\n  `constructor(sideLength: number) {`\n\n    `this.initialize(sideLength);`\n\n  `}`\n\n  `initialize(sideLength: number) {`\n\n    `this.sideLength = sideLength;`\n\n  `}`\n\n  `get area() {`\n\n    `return this.sideLength ** 2;`\n\n  `}`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKCOBXMAnAptA3gKGtA9PtACZoBmAlgHYUAuGkEFA5lQLZpW3SNoq0UA9lVwEieCXgBuopqQAynZrQAWAQgBc0KojYAjPgG5RhSWYB6lq5ZNFaATwAODKlUG0wA4dlHBhEWhREYFpBFAAKOTRFKmUVLR19PgBKLFE8VQoIADpqOgowEAoALzRIigUlVWTjPABfHzw8gUKSsqiYuITdAxRUnElMnI6qlWgAXmgR2NVa6AbRZjRuVDQwcP706HRaRBQqaCHs6bjoACoz6AAmOYa6oA)\n\nFor more details, [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/37920).\n\n## [](#short-circuiting-assignment-operators)Short-Circuiting Assignment Operators\n\nJavaScript, and a lot of other languages, support a set of operators called _compound assignment_ operators. Compound assignment operators apply an operator to two arguments, and then assign the result to the left side. You may have seen these before:\n\nts\n\n`// Addition`\n\n`// a = a + b`\n\n`a += b;`\n\n`// Subtraction`\n\n`// a = a - b`\n\n`a -= b;`\n\n`// Multiplication`\n\n`// a = a * b`\n\n`a *= b;`\n\n`// Division`\n\n`// a = a / b`\n\n`a /= b;`\n\n`// Exponentiation`\n\n`// a = a ** b`\n\n`a **= b;`\n\n`// Left Bit Shift`\n\n`// a = a << b`\n\n`a <<= b;`\n\nSo many operators in JavaScript have a corresponding assignment operator! Up until recently, however, there were three notable exceptions: logical _and_ (`&&`), logical _or_ (`||`), and nullish coalescing (`??`).\n\nThat’s why TypeScript 4.0 supports a new ECMAScript feature to add three new assignment operators: `&&=`, `||=`, and `??=`.\n\nThese operators are great for substituting any example where a user might write code like the following:\n\nts\n\n`a = a && b;`\n\n`a = a || b;`\n\n`a = a ?? b;`\n\nOr a similar `if` block like\n\nts\n\n`// could be 'a ||= b'`\n\n`if (!a) {`\n\n  `a = b;`\n\n`}`\n\nThere are even some patterns we’ve seen (or, uh, written ourselves) to lazily initialize values, only if they’ll be needed.\n\nts\n\n`let values: string[];`\n\n`(values ?? (values = [])).push(\"hello\");`\n\n`// After`\n\n`(values ??= []).push(\"hello\");`\n\n(look, we’re not proud of _all_ the code we write…)\n\nOn the rare case that you use getters or setters with side-effects, it’s worth noting that these operators only perform assignments if necessary. In that sense, not only is the right side of the operator “short-circuited” - the assignment itself is too.\n\nts\n\n`obj.prop ||= foo();`\n\n`// roughly equivalent to either of the following`\n\n`obj.prop || (obj.prop = foo());`\n\n`if (!obj.prop) {`\n\n    `obj.prop = foo();`\n\n`}`\n\n[Try running the following example](https://www.typescriptlang.org/play?ts=next#code/MYewdgzgLgBCBGArGBeGBvAsAKBnmA5gKawAOATiKQBQCUGO+TMokIANkQHTsgHUAiYlChFyMABYBDCDHIBXMANoBuHI2Z4A9FpgAlIqXZTgRGAFsiAQg2byJeeTAwAslKgSu5KWAAmIczoYAB4YAAYuAFY1XHwAXwAaWxgIEhgKKmoAfQA3KXYALhh4EA4iH3osWM1WCDKePkFUkTFJGTlFZRimOJw4mJwAM0VgKABLcBhB0qCqplr63n4BcjGCCVgIMd8zIjz2eXciXy7k+yhHZygFIhje7BwFzgblgBUJMdlwM3yAdykAJ6yBSQGAeMzNUTkU7YBCILgZUioOBIBGUJEAHwxUxmqnU2Ce3CWgnenzgYDMACo6pZxpYIJSOqDwSkSFCYXC0VQYFi0NMQHQVEA) to see how that differs from _always_ performing the assignment.\n\nts\n\n`const obj = {`\n\n    `get prop() {`\n\n        `console.log(\"getter has run\");`\n\n        `// Replace me!`\n\n        `return Math.random() < 0.5;`\n\n    `},`\n\n    `set prop(_val: boolean) {`\n\n        `console.log(\"setter has run\");`\n\n    `}`\n\n`};`\n\n`function foo() {`\n\n    `console.log(\"right side evaluated\");`\n\n    `return true;`\n\n`}`\n\n`console.log(\"This one always runs the setter\");`\n\n`obj.prop = obj.prop || foo();`\n\n`console.log(\"This one *sometimes* runs the setter\");`\n\n`obj.prop ||= foo();`\n\n[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBCBGArGBeGBvAUDHMDmAprAA4BOIxAFAJQba4OiQgA2BAdCyHpQESFQoBUjAAWAQwgxSAVzC9qAbkz0GOAPTqYAJQLEW44ARgBbAgEJVa0kRmkwMALLioo9qXFgAJiBM0YADwwAAzsAKzKDAC+ADRWEEQwZBSUAPoAbuIsAFww8CCsBJ60WGq4TBCFnNx8CYLCYpLScgqRuFGYUcqYAGZywFAAluAwPQX+peXglWzVPLykg3iisBCDXsYEmSwyLgRerVY2UHYOULIEyh2YFVVc8wAqooNS4MZZAO7iAJ5SspAwVzGOpCUiHBCIdjJYioOBIKHkGEAHyRo3GShUt1m9z4TxecDAxgAVJUzEMzBAic0AUCYCDhOD4dCYCi0GMQDRFEA)\n\nWe’d like to extend a big thanks to community member [Wenlu Wang](https://github.com/Kingwl) for this contribution!\n\nFor more details, you can [take a look at the pull request here](https://github.com/microsoft/TypeScript/pull/37727). You can also [check out TC39’s proposal repository for this feature](https://github.com/tc39/proposal-logical-assignment/).\n\n## [](#unknown-on-catch-clause-bindings)`unknown` on `catch` Clause Bindings\n\nSince the beginning days of TypeScript, `catch` clause variables have always been typed as `any`. This meant that TypeScript allowed you to do anything you wanted with them.\n\nts\n\n`try {`\n\n  `// Do some work`\n\n`} catch (x) {`\n\n  `// x has type 'any' - have fun!`\n\n  `console.log(x.message);`\n\n  `console.log(x.toUpperCase());`\n\n  `x++;`\n\n  `x.yadda.yadda.yadda();`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEFcGcFMFUB2BrRB7A7ogkogwgIYAuAxgBYBqBATgJYEBGANrNAFygBmBTcAUEWoBPUAG8+oUCFAARNKGhoAtrFAY01ZHwC+oEsXKgAFAA8AlGIlSwJ0GQLRQRIQAdVAcgKIh70AFo7AgA3VU5IRABCKxI0REUWADomNABzUwSVaGgCFNgzAG5o2PjYJNT0ojR4FzdqQjgjMwKrEwBqVsLJEwShAgATPoIe-sHhgYJGwu0gA)\n\nThe above has some undesirable behavior if we’re trying to prevent _more_ errors from happening in our error-handling code! Because these variables have the type `any` by default, they lack any type-safety which could have errored on invalid operations.\n\nThat’s why TypeScript 4.0 now lets you specify the type of `catch` clause variables as `unknown` instead. `unknown` is safer than `any` because it reminds us that we need to perform some sorts of type-checks before operating on our values.\n\nts\n\n`try {`\n\n  `// ...`\n\n`} catch (e: unknown) {`\n\n  `// Can't access values on unknowns`\n\n  `console.log(e.toUpperCase());`\n\n`'e' is of type 'unknown'.18046'e' is of type 'unknown'.    if (typeof e === \"string\") {      // We've narrowed 'e' down to the type 'string'.      console.log(e.toUpperCase());    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AKABdoBPUAbwtFBFADpOKBfUAYwCGVPgAtQACkioArgDsA1rLgB3WQEpGzVmADCA2QHIqoAXz6REiUADcBAG2kXQcWaDmKVsxFr4vEcO0h2OzgAc0l2KjgAVQAHWJg9REhxNTUAbgotAEsAMwkqWgS4fMhQAF5K0AAiRBps2VDqjSYWFjYAdUgDazLZAVgVSAATUANu0GHPUCiZkTLChLG66AbQg3YtFl8vAKCQ8KCouIToJJS0zJZuHiA)\n\nWhile the types of `catch` variables won’t change by default, we might consider a new [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode flag in the future so that users can opt in to this behavior. In the meantime, it should be possible to write a lint rule to force `catch` variables to have an explicit annotation of either `: any` or `: unknown`.\n\nFor more details you can [peek at the changes for this feature](https://github.com/microsoft/TypeScript/pull/39015).\n\n## [](#custom-jsx-factories)Custom JSX Factories\n\nWhen using JSX, a [_fragment_](https://reactjs.org/docs/fragments.html) is a type of JSX element that allows us to return multiple child elements. When we first implemented fragments in TypeScript, we didn’t have a great idea about how other libraries would utilize them. Nowadays most other libraries that encourage using JSX and support fragments have a similar API shape.\n\nIn TypeScript 4.0, users can customize the fragment factory through the new [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory) option.\n\nAs an example, the following `tsconfig.json` file tells TypeScript to transform JSX in a way compatible with React, but switches each factory invocation to `h` instead of `React.createElement`, and uses `Fragment` instead of `React.Fragment`.\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"esnext\",`\n\n    `\"\": \"commonjs\",`\n\n    `\"\": \"react\",`\n\n    `\"\": \"h\",`\n\n    `\"\": \"Fragment\"`\n\n  `}`\n\n`}`\n\nIn cases where you need to have a different JSX factory on a per-file basis, you can take advantage of the new `/** @jsxFrag */` pragma comment. For example, the following…\n\ntsx\n\n`// Note: these pragma comments need to be written`\n\n`// with a JSDoc-style multiline syntax to take effect.`\n\n`/** @jsx h */`\n\n`/** @jsxFrag Fragment */`\n\n`import { h, Fragment } from \"preact\";`\n\n`export const Header = (`\n\n  `<>`\n\n    `<h1>Welcome</h1>`\n\n  `</>`\n\n`);`\n\n[Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAOwgFEocoAzqzgA5CDCQAuODAAWSAUjhgoKAOYgUcNLhBIOMAXA5IkAExkQ4AIyUB3KMBgSOwu09lwtAKQDKAEQg0agEYAE8AGyUQegiYYAjgEzgBMIMUAA9LGRQAayUkTEwkDAA6UgoAKkq4NgArASzPSvIqmvrGgDFVNThu9T0DOBaK0EhYOABvOFkAGj6ewfgAXzhsXDgAIhViGE2AbgqkDPH4HQ5QuAAJVDMkKDgAXjgAClI4OAAeAD53j6-ZABGb4AdSQER0ek+5CBvw+0N+AEp9kA)\n\n…will get transformed to this output JavaScript…\n\ntsx\n\n`import React from 'react';`\n\n`export const Header = (React.createElement(React.Fragment, null,`\n\n    `React.createElement(\"h1\", null, \"Welcome\")));`\n\n[Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAOwgFEocoAzqzhsBACwgB3biGAxhAOQgwkALjgwxSAUjhgoKAOYgUcNLhBIOMAXA5IkAEw0Q4AI12SoclR2GS5MThTACkAZQARCDRqARgATwAbXRB6RJhgROB7OAF46xQADxcNFABrXSRMTCQMADpSCgAqJpEAKwFioKbyZta2DsKAMQNDOBGjS2s4HsbQSFg4AG84MQAacdGp+ABfOGxcOAAifWIYI4BuRqRChfhzDji4AAlURyQoOABeOAAKUjgcAAPAA+AGA4FiACMIIA6khEuZLEDyNCwYCUWCAJQXIA)\n\nWe’d like to extend a big thanks to community member [Noj Vek](https://github.com/nojvek) for sending this pull request and patiently working with our team on it.\n\nYou can see that [the pull request](https://github.com/microsoft/TypeScript/pull/38720) for more details!\n\n## [](#speed-improvements-in-build-mode-with---noemitonerror)Speed Improvements in `build` mode with `--noEmitOnError`\n\nPreviously, compiling a program after a previous compile with errors under [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) would be extremely slow when using the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) flag. This is because none of the information from the last compilation would be cached in a `.tsbuildinfo` file based on the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) flag.\n\nTypeScript 4.0 changes this which gives a great speed boost in these scenarios, and in turn improves `--build` mode scenarios (which imply both [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) and [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)).\n\nFor details, [read up more on the pull request](https://github.com/microsoft/TypeScript/pull/38853).\n\n## [](#--incremental-with---noemit)`--incremental` with `--noEmit`\n\nTypeScript 4.0 allows us to use the [`noEmit`](https://www.typescriptlang.org/tsconfig#noEmit) flag when while still leveraging [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) compiles. This was previously not allowed, as [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) needs to emit a `.tsbuildinfo` files; however, the use-case to enable faster incremental builds is important enough to enable for all users.\n\nFor more details, you can [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/39122).\n\n## [](#editor-improvements)Editor Improvements\n\nThe TypeScript compiler doesn’t only power the editing experience for TypeScript itself in most major editors - it also powers the JavaScript experience in the Visual Studio family of editors and more. For that reason, much of our work focuses on improving editor scenarios - the place you spend most of your time as a developer.\n\nUsing new TypeScript/JavaScript functionality in your editor will differ depending on your editor, but\n\n*   Visual Studio Code supports [selecting different versions of TypeScript](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript). Alternatively, there’s the [JavaScript/TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next) to stay on the bleeding edge (which is typically very stable).\n*   Visual Studio 2017/2019 have \\[the SDK installers above\\] and [MSBuild installs](https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild).\n*   Sublime Text 3 supports [selecting different versions of TypeScript](https://github.com/microsoft/TypeScript-Sublime-Plugin#note-using-different-versions-of-typescript)\n\nYou can check out a partial [list of editors that have support for TypeScript](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support) to learn more about whether your favorite editor has support to use new versions.\n\n### [](#convert-to-optional-chaining)Convert to Optional Chaining\n\nOptional chaining is a recent feature that’s received a lot of love. That’s why TypeScript 4.0 brings a new refactoring to convert common patterns to take advantage of [optional chaining](https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#optional-chaining) and [nullish coalescing](https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing)!\n\n![Converting a && a.b.c && a.b.c.d.e.f() to a?.b.c?.d.e.f.()](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/convertToOptionalChain-4-0.gif)\n\nKeep in mind that while this refactoring doesn’t _perfectly_ capture the same behavior due to subtleties with truthiness/falsiness in JavaScript, we believe it should capture the intent for most use-cases, especially when TypeScript has more precise knowledge of your types.\n\nFor more details, [check out the pull request for this feature](https://github.com/microsoft/TypeScript/pull/39135).\n\n### [](#-deprecated--support)`/** @deprecated */` Support\n\nTypeScript’s editing support now recognizes when a declaration has been marked with a `/** @deprecated */` JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed a strike-though style ~like this~.\n\n![Some examples of deprecated declarations with strikethrough text in the editor](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/06/deprecated_4-0.png)\n\nThis new functionality is available thanks to [Wenlu Wang](https://github.com/Kingwl). See [the pull request](https://github.com/microsoft/TypeScript/pull/38523) for more details.\n\n### [](#partial-semantic-mode-at-startup)Partial Semantic Mode at Startup\n\nWe’ve heard a lot from users suffering from long startup times, especially on bigger projects. The culprit is usually a process called _program construction_. This is the process of starting with an initial set of root files, parsing them, finding their dependencies, parsing those dependencies, finding those dependencies’ dependencies, and so on. The bigger your project is, the longer you’ll have to wait before you can get basic editor operations like go-to-definition or quick info.\n\nThat’s why we’ve been working on a new mode for editors to provide a _partial_ experience until the full language service experience has loaded up. The core idea is that editors can run a lightweight partial server that only looks at the current files that the editor has open.\n\nIt’s hard to say precisely what sorts of improvements you’ll see, but anecdotally, it used to take anywhere between _20 seconds to a minute_ before TypeScript would become fully responsive on the Visual Studio Code codebase. In contrast, **our new partial semantic mode seems to bring that delay down to just a few seconds**. As an example, in the following video, you can see two side-by-side editors with TypeScript 3.9 running on the left and TypeScript 4.0 running on the right.\n\nWhen restarting both editors on a particularly large codebase, the one with TypeScript 3.9 can’t provide completions or quick info at all. On the other hand, the editor with TypeScript 4.0 can _immediately_ give us a rich experience in the current file we’re editing, despite loading the full project in the background.\n\nCurrently the only editor that supports this mode is [Visual Studio Code](http://code.visualstudio.com/) which has some UX improvements coming up in [Visual Studio Code Insiders](http://code.visualstudio.com/insiders). We recognize that this experience may still have room for polish in UX and functionality, and we have [a list of improvements](https://github.com/microsoft/TypeScript/issues/39035) in mind. We’re looking for more feedback on what you think might be useful.\n\nFor more information, you can [see the original proposal](https://github.com/microsoft/TypeScript/issues/37713), [the implementing pull request](https://github.com/microsoft/TypeScript/pull/38561), along with [the follow-up meta issue](https://github.com/microsoft/TypeScript/issues/39035).\n\n### [](#smarter-auto-imports)Smarter Auto-Imports\n\nAuto-import is a fantastic feature that makes coding a lot easier; however, every time auto-import doesn’t seem to work, it can throw users off a lot. One specific issue that we heard from users was that auto-imports didn’t work on dependencies that were written in TypeScript - that is, until they wrote at least one explicit import somewhere else in their project.\n\nWhy would auto-imports work for `@types` packages, but not for packages that ship their own types? It turns out that auto-imports only work on packages your project _already_ includes. Because TypeScript has some quirky defaults that automatically add packages in `node_modules/@types` to your project, _those_ packages would be auto-imported. On the other hand, other packages were excluded because crawling through all your `node_modules` packages can be _really_ expensive.\n\nAll of this leads to a pretty lousy getting started experience for when you’re trying to auto-import something that you’ve just installed but haven’t used yet.\n\nTypeScript 4.0 now does a little extra work in editor scenarios to include the packages you’ve listed in your `package.json`’s `dependencies` (and `peerDependencies`) fields. The information from these packages is only used to improve auto-imports, and doesn’t change anything else like type-checking. This allows us to provide auto-imports for all of your dependencies that have types, without incurring the cost of a complete `node_modules` search.\n\nIn the rare cases when your `package.json` lists more than ten typed dependencies that haven’t been imported yet, this feature automatically disables itself to prevent slow project loading. To force the feature to work, or to disable it entirely, you should be able to configure your editor. For Visual Studio Code, this is the “Include Package JSON Auto Imports” (or `typescript.preferences.includePackageJsonAutoImports`) setting.\n\n![Configuring 'include package JSON auto imports'](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/configurePackageJsonAutoImports4-0.png) For more details, you can see the [proposal issue](https://github.com/microsoft/TypeScript/issues/37812) along with [the implementing pull request](https://github.com/microsoft/TypeScript/pull/38923).\n\n## [](#our-new-website)Our New Website!\n\n[The TypeScript website](https://www.typescriptlang.org/) has recently been rewritten from the ground up and rolled out!\n\n![A screenshot of the new TypeScript website](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/ts-web.png)\n\n[We already wrote a bit about our new site](https://devblogs.microsoft.com/typescript/announcing-the-new-typescript-website/), so you can read up more there; but it’s worth mentioning that we’re still looking to hear what you think! If you have questions, comments, or suggestions, you can [file them over on the website’s issue tracker](https://github.com/microsoft/TypeScript-Website).\n\n## [](#breaking-changes)Breaking Changes\n\n### [](#libdts-changes)`lib.d.ts` Changes\n\nOur `lib.d.ts` declarations have changed - most specifically, types for the DOM have changed. The most notable change may be the removal of [`document.origin`](https://developer.mozilla.org/en-US/docs/Web/API/Document/origin) which only worked in old versions of IE and Safari MDN recommends moving to [`self.origin`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/origin).\n\n### [](#properties-overriding-accessors-and-vice-versa-is-an-error)Properties Overriding Accessors (and vice versa) is an Error\n\nPreviously, it was only an error for properties to override accessors, or accessors to override properties, when using [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields); however, TypeScript now always issues an error when declaring a property in a derived class that would override a getter or setter in the base class.\n\nts\n\n`class Base {`\n\n  `get foo() {`\n\n    `return 100;`\n\n  `}`\n\n  `set foo(value) {`\n\n    `// ...`\n\n  `}`\n\n`}`\n\n`class Derived extends Base {`\n\n  `foo = 10;`\n\n`'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.2610'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYAsBOUAmANkwCgBjAGwENFFQAhGyUAbxNFAHNIAXUAMzhwAFAEpW7DqGi8ArtAB26DBgDckgL6TEvAUOEA3KhVmRxbKaBCgAdHc0kt5arVAARGAEsDkACahIAA8eSAVfOkYdCQ5BOFAAXmV1DSA)\n\nts\n\n`class Base {`\n\n  `prop = 10;`\n\n`}`\n\n`class Derived extends Base {`\n\n  `get prop() {`\n\n`'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.2611'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.      return 100;    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCMWBQBjAGwENFFQAhUyUAb11FAAd4nQBeULABgG5cAvrgIkyoACIwAlgDdIAE1CQAHgBdIAO3nkqiGvUYBzSKuasAFAEo6DRqGgmArtA1dufW0IFA)\n\nSee more details on [the implementing pull request](https://github.com/microsoft/TypeScript/pull/37894).\n\n### [](#operands-for-delete-must-be-optional)Operands for `delete` must be optional.\n\nWhen using the `delete` operator in [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), the operand must now be `any`, `unknown`, `never`, or be optional (in that it contains `undefined` in the type). Otherwise, use of the `delete` operator is an error.\n\nts\n\n`interface Thing {`\n\n  `prop: string;`\n\n`}`\n\n`function f(x: Thing) {`\n\n  `delete x.prop;`\n\n`The operand of a 'delete' operator must be optional.2790The operand of a 'delete' operator must be optional.  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYCcAGAUAJYB2ALjAGYCGAxpKACoAWxA5qAN56igAO8PqRCWisA3HgC+ePOQCuRaiQJwiocgAoAHqiasAlBy6gAJpAA2kMqE0A6PnB7iJQA)\n\nSee more details on [the implementing pull request](https://github.com/microsoft/TypeScript/pull/37921).\n\n### [](#usage-of-typescripts-node-factory-is-deprecated)Usage of TypeScript’s Node Factory is Deprecated\n\nToday TypeScript provides a set of “factory” functions for producing AST Nodes; however, TypeScript 4.0 provides a new node factory API. As a result, for TypeScript 4.0 we’ve made the decision to deprecate these older functions in favor of the new ones.\n\nFor more details, [read up on the relevant pull request for this change](https://github.com/microsoft/TypeScript/pull/35282).",
    "title": "TypeScript: Documentation - TypeScript 4.0",
    "description": "TypeScript 4.0 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.9\n\n## [](#support-number-and-symbol-named-properties-with-keyof-and-mapped-types)Support `number` and `symbol` named properties with `keyof` and mapped types\n\nTypeScript 2.9 adds support for `number` and `symbol` named properties in index types and mapped types. Previously, the `keyof` operator and mapped types only supported `string` named properties.\n\nChanges include:\n\n*   An index type `keyof T` for some type `T` is a subtype of `string | number | symbol`.\n*   A mapped type `{ [P in K]: XXX }` permits any `K` assignable to `string | number | symbol`.\n*   In a `for...in` statement for an object of a generic type `T`, the inferred type of the iteration variable was previously `keyof T` but is now `Extract<keyof T, string>`. (In other words, the subset of `keyof T` that includes only string-like values.)\n\nGiven an object type `X`, `keyof X` is resolved as follows:\n\n*   If `X` contains a string index signature, `keyof X` is a union of `string`, `number`, and the literal types representing symbol-like properties, otherwise\n*   If `X` contains a numeric index signature, `keyof X` is a union of `number` and the literal types representing string-like and symbol-like properties, otherwise\n*   `keyof X` is a union of the literal types representing string-like, number-like, and symbol-like properties.\n\nWhere:\n\n*   String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.\n*   Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.\n*   Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.\n\nIn a mapped type `{ [P in K]: XXX }`, each string literal type in `K` introduces a property with a string name, each numeric literal type in `K` introduces a property with a numeric name, and each unique symbol type in `K` introduces a property with a unique symbol name. Furthermore, if `K` includes type `string`, a string index signature is introduced, and if `K` includes type `number`, a numeric index signature is introduced.\n\n##### [](#example)Example\n\nts\n\n`const c = \"c\";`\n\n`const d = 10;`\n\n`const e = Symbol();`\n\n`const enum E1 {`\n\n  `A,`\n\n  `B,`\n\n  `C,`\n\n`}`\n\n`const enum E2 {`\n\n  `A = \"A\",`\n\n  `B = \"B\",`\n\n  `C = \"C\",`\n\n`}`\n\n`type Foo = {`\n\n  `a: string; // String-like name`\n\n  `5: string; // Number-like name`\n\n  `[c]: string; // String-like name`\n\n  `[d]: string; // Number-like name`\n\n  `[e]: string; // Symbol-like name`\n\n  `[E1.A]: string; // Number-like name`\n\n  `[E2.A]: string; // String-like name`\n\n`};`\n\n`type K1 = keyof Foo; // \"a\" | 5 | \"c\" | 10 | typeof e | E1.A | E2.A`\n\n`type K2 = Extract<keyof Foo, string>; // \"a\" | \"c\" | E2.A`\n\n`type K3 = Extract<keyof Foo, number>; // 5 | 10 | E1.A`\n\n`type K4 = Extract<keyof Foo, symbol>; // typeof e`\n\nSince `keyof` now reflects the presence of a numeric index signature by including type `number` in the key type, mapped types such as `Partial<T>` and `Readonly<T>` work correctly when applied to object types with numeric index signatures:\n\nts\n\n`type Arrayish<T> = {`\n\n  `length: number;`\n\n  `[x: number]: T;`\n\n`};`\n\n`type ReadonlyArrayish<T> = Readonly<Arrayish<T>>;`\n\n`declare const map: ReadonlyArrayish<string>;`\n\n`let n = map.length;`\n\n`let x = map[123]; // Previously of type any (or an error with --noImplicitAny)`\n\nFurthermore, with the `keyof` operator’s support for `number` and `symbol` named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.\n\nts\n\n`const enum Enum {`\n\n  `A,`\n\n  `B,`\n\n  `C,`\n\n`}`\n\n`const enumToStringMap = {`\n\n  `[Enum.A]: \"Name A\",`\n\n  `[Enum.B]: \"Name B\",`\n\n  `[Enum.C]: \"Name C\",`\n\n`};`\n\n`const sym1 = Symbol();`\n\n`const sym2 = Symbol();`\n\n`const sym3 = Symbol();`\n\n`const symbolToNumberMap = {`\n\n  `[sym1]: 1,`\n\n  `[sym2]: 2,`\n\n  `[sym3]: 3,`\n\n`};`\n\n`type KE = keyof typeof enumToStringMap; // Enum (i.e. Enum.A | Enum.B | Enum.C)`\n\n`type KS = keyof typeof symbolToNumberMap; // typeof sym1 | typeof sym2 | typeof sym3`\n\n`function getValue<T, K extends keyof T>(obj: T, key: K): T[K] {`\n\n  `return obj[key];`\n\n`}`\n\n`let x1 = getValue(enumToStringMap, Enum.C); // Returns \"Name C\"`\n\n`let x2 = getValue(symbolToNumberMap, sym3); // Returns 3`\n\nThis is a breaking change; previously, the `keyof` operator and mapped types only supported `string` named properties. Code that assumed values typed with `keyof T` were always `string`s, will now be flagged as error.\n\n##### [](#example-1)Example\n\nts\n\n`function useKey<T, K extends keyof T>(o: T, k: K) {`\n\n  `var name: string = k; // Error: keyof T is not assignable to string`\n\n`}`\n\n#### [](#recommendations)Recommendations\n\n*   If your functions are only able to handle string named property keys, use `Extract<keyof T, string>` in the declaration:\n    \n    ts\n    \n    `function useKey<T, K extends Extract<keyof T, string>>(o: T, k: K) {`\n    \n      `var name: string = k; // OK`\n    \n    `}`\n    \n*   If your functions are open to handling all property keys, then the changes should be done down-stream:\n    \n    ts\n    \n    `function useKey<T, K extends keyof T>(o: T, k: K) {`\n    \n      `var name: string | number | symbol = k;`\n    \n    `}`\n    \n*   Otherwise use [`keyofStringsOnly`](https://www.typescriptlang.org/tsconfig#keyofStringsOnly) compiler option to disable the new behavior.\n    \n\n## [](#generic-type-arguments-in-jsx-elements)Generic type arguments in JSX elements\n\nJSX elements now allow passing type arguments to generic components.\n\n##### [](#example-2)Example\n\nts\n\n`class GenericComponent<P> extends React.Component<P> {`\n\n  `internalProp: P;`\n\n`}`\n\n`type Props = { a: number; b: string };`\n\n`const x = <GenericComponent<Props> a={10} b=\"hi\" />; // OK`\n\n`const y = <GenericComponent<Props> a={10} b={20} />; // Error`\n\n## [](#generic-type-arguments-in-generic-tagged-templates)Generic type arguments in generic tagged templates\n\nTagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.\n\nTypeScript 2.9 allows passing generic type arguments to tagged template strings.\n\n##### [](#example-3)Example\n\nts\n\n`declare function styledComponent<Props>(`\n\n  `strs: TemplateStringsArray`\n\n`): Component<Props>;`\n\n`interface MyProps {`\n\n  `name: string;`\n\n  `age: number;`\n\n`}`\n\n`` styledComponent<MyProps>` ``\n\n  `font-size: 1.5em;`\n\n  `text-align: center;`\n\n  `color: palevioletred;`\n\n`` `; ``\n\n`declare function tag<T>(strs: TemplateStringsArray, ...args: T[]): T;`\n\n`// inference fails because 'number' and 'string' are both candidates that conflict`\n\n``let a = tag<string | number>`${100} ${\"hello\"}`;``\n\n## [](#import-types)`import` types\n\nModules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter `import` types.\n\nUsing `import(\"mod\")` in a type annotation allows for reaching in a module and accessing its exported declaration without importing it.\n\n##### [](#example-4)Example\n\nGiven a declaration of a class `Pet` in a module file:\n\nts\n\n`// module.d.ts`\n\n`export declare class Pet {`\n\n  `name: string;`\n\n`}`\n\nCan be used in a non-module file `global-script.ts`:\n\nts\n\n`// global-script.ts`\n\n`function adopt(p: import(\"./module\").Pet) {`\n\n  ``console.log(`Adopting ${p.name}...`);``\n\n`}`\n\nThis also works in JSDoc comments to refer to types from other modules in `.js`:\n\njs\n\n`// a.js`\n\n`/**`\n\n `* @param p { import(\"./module\").Pet }`\n\n `*/`\n\n`function walk(p) {`\n\n  ``console.log(`Walking ${p.name}...`);``\n\n`}`\n\n## [](#relaxing-declaration-emit-visibility-rules)Relaxing declaration emit visibility rules\n\nWith `import` types available, many of the visibility errors reported during declaration file generation can be handled by the compiler without the need to change the input.\n\nFor instance:\n\nts\n\n`import { createHash } from \"crypto\";`\n\n`export const hash = createHash(\"sha256\");`\n\n`//           ^^^^`\n\n`// Exported variable 'hash' has or is using name 'Hash' from external module \"crypto\" but cannot be named.`\n\nWith TypeScript 2.9, no errors are reported, and now the generated file looks like:\n\nts\n\n`export declare const hash: import(\"crypto\").Hash;`\n\nTypeScript 2.9 introduces support for `import.meta`, a new meta-property as described by the current [TC39 proposal](https://github.com/tc39/proposal-import-meta).\n\nThe type of `import.meta` is the global `ImportMeta` type which is defined in `lib.es5.d.ts`. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.\n\n##### [](#example-5)Example\n\nAssuming that `__dirname` is always available on `import.meta`, the declaration would be done through reopening `ImportMeta` interface:\n\nts\n\n`// node.d.ts`\n\n`interface ImportMeta {`\n\n  `__dirname: string;`\n\n`}`\n\nAnd usage would be:\n\nts\n\n`import.meta.__dirname; // Has type 'string'`\n\n`import.meta` is only allowed when targeting `ESNext` modules and ECMAScript targets.\n\n## [](#new---resolvejsonmodule)New `--resolveJsonModule`\n\nOften in Node.js applications a `.json` is needed. With TypeScript 2.9, [`resolveJsonModule`](https://www.typescriptlang.org/tsconfig#resolveJsonModule) allows for importing, extracting types from and generating `.json` files.\n\n##### [](#example-6)Example\n\nts\n\n`// settings.json`\n\n`{`\n\n    `\"repo\": \"TypeScript\",`\n\n    `\"dry\": false,`\n\n    `\"debug\": false`\n\n`}`\n\nts\n\n`// a.ts`\n\n`import settings from \"./settings.json\";`\n\n`settings.debug === true; // OK`\n\n`settings.dry === 2; // Error: Operator '===' cannot be applied boolean and number`\n\n`// tsconfig.json`\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"commonjs\",`\n\n    `\"\": true,`\n\n    `\"\": true`\n\n  `}`\n\n`}`\n\n## [](#--pretty-output-by-default)`--pretty` output by default\n\nStarting TypeScript 2.9 errors are displayed under [`pretty`](https://www.typescriptlang.org/tsconfig#pretty) by default if the output device is applicable for colorful text. TypeScript will check if the output stream has [`isTty`](https://nodejs.org/api/tty.html) property set.\n\nUse `--pretty false` on the command line or set `\"pretty\": false` in your `tsconfig.json` to disable [`pretty`](https://www.typescriptlang.org/tsconfig#pretty) output.\n\n## [](#new---declarationmap)New `--declarationMap`\n\nEnabling [`declarationMap`](https://www.typescriptlang.org/tsconfig#declarationMap) alongside [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) causes the compiler to emit `.d.ts.map` files alongside the output `.d.ts` files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.\n\nIn other words, hitting go-to-definition on a declaration from a `.d.ts` file generated with [`declarationMap`](https://www.typescriptlang.org/tsconfig#declarationMap) will take you to the source file (`.ts`) location where that declaration was defined, and not to the `.d.ts`.",
    "title": "TypeScript: Documentation - TypeScript 2.9",
    "description": "TypeScript 2.9 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.8\n\n## [](#conditional-types)Conditional Types\n\nTypeScript 2.8 introduces _conditional types_ which add the ability to express non-uniform type mappings. A conditional type selects one of two possible types based on a condition expressed as a type relationship test:\n\nts\n\n`T extends U ? X : Y`\n\nThe type above means when `T` is assignable to `U` the type is `X`, otherwise the type is `Y`.\n\nA conditional type `T extends U ? X : Y` is either _resolved_ to `X` or `Y`, or _deferred_ because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:\n\n*   First, given types `T'` and `U'` that are instantiations of `T` and `U` where all occurrences of type parameters are replaced with `any`, if `T'` is not assignable to `U'`, the conditional type is resolved to `Y`. Intuitively, if the most permissive instantiation of `T` is not assignable to the most permissive instantiation of `U`, we know that no instantiation will be and we can just resolve to `Y`.\n*   Next, for each type variable introduced by an `infer` (more later) declaration within `U` collect a set of candidate types by inferring from `T` to `U` (using the same inference algorithm as type inference for generic functions). For a given `infer` type variable `V`, if any candidates were inferred from co-variant positions, the type inferred for `V` is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for `V` is an intersection of those candidates. Otherwise, the type inferred for `V` is `never`.\n*   Then, given a type `T''` that is an instantiation of `T` where all `infer` type variables are replaced with the types inferred in the previous step, if `T''` is _definitely assignable_ to `U`, the conditional type is resolved to `X`. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for _all instantiations_ of those types.\n*   Otherwise, the condition depends on one or more type variables and the conditional type is deferred.\n\n##### [](#example)Example\n\nts\n\n`type TypeName<T> = T extends string`\n\n  `? \"string\"`\n\n  `: T extends number`\n\n  `? \"number\"`\n\n  `: T extends boolean`\n\n  `? \"boolean\"`\n\n  `: T extends undefined`\n\n  `? \"undefined\"`\n\n  `: T extends Function`\n\n  `? \"function\"`\n\n  `: \"object\";`\n\n`type T0 = TypeName<string>; // \"string\"`\n\n`type T1 = TypeName<\"a\">; // \"string\"`\n\n`type T2 = TypeName<true>; // \"boolean\"`\n\n`type T3 = TypeName<() => void>; // \"function\"`\n\n`type T4 = TypeName<string[]>; // \"object\"`\n\n## [](#distributive-conditional-types)Distributive conditional types\n\nConditional types in which the checked type is a naked type parameter are called _distributive conditional types_. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of `T extends U ? X : Y` with the type argument `A | B | C` for `T` is resolved as `(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)`.\n\n##### [](#example-1)Example\n\nts\n\n`type T10 = TypeName<string | (() => void)>; // \"string\" | \"function\"`\n\n`type T12 = TypeName<string | string[] | undefined>; // \"string\" | \"object\" | \"undefined\"`\n\n`type T11 = TypeName<string[] | number[]>; // \"object\"`\n\nIn instantiations of a distributive conditional type `T extends U ? X : Y`, references to `T` within the conditional type are resolved to individual constituents of the union type (i.e. `T` refers to the individual constituents _after_ the conditional type is distributed over the union type). Furthermore, references to `T` within `X` have an additional type parameter constraint `U` (i.e. `T` is considered assignable to `U` within `X`).\n\n##### [](#example-2)Example\n\nts\n\n`type BoxedValue<T> = { value: T };`\n\n`type BoxedArray<T> = { array: T[] };`\n\n`type Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;`\n\n`type T20 = Boxed<string>; // BoxedValue<string>;`\n\n`type T21 = Boxed<number[]>; // BoxedArray<number>;`\n\n`type T22 = Boxed<string | number[]>; // BoxedValue<string> | BoxedArray<number>;`\n\nNotice that `T` has the additional constraint `any[]` within the true branch of `Boxed<T>` and it is therefore possible to refer to the element type of the array as `T[number]`. Also, notice how the conditional type is distributed over the union type in the last example.\n\nThe distributive property of conditional types can conveniently be used to _filter_ union types:\n\nts\n\n`type Diff<T, U> = T extends U ? never : T; // Remove types from T that are assignable to U`\n\n`type Filter<T, U> = T extends U ? T : never; // Remove types from T that are not assignable to U`\n\n`type T30 = Diff<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"b\" | \"d\"`\n\n`type T31 = Filter<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"a\" | \"c\"`\n\n`type T32 = Diff<string | number | (() => void), Function>; // string | number`\n\n`type T33 = Filter<string | number | (() => void), Function>; // () => void`\n\n`type NonNullable<T> = Diff<T, null | undefined>; // Remove null and undefined from T`\n\n`type T34 = NonNullable<string | number | undefined>; // string | number`\n\n`type T35 = NonNullable<string | string[] | null | undefined>; // string | string[]`\n\n`function f1<T>(x: T, y: NonNullable<T>) {`\n\n  `x = y; // Ok`\n\n  `y = x; // Error`\n\n`}`\n\n`function f2<T extends string | undefined>(x: T, y: NonNullable<T>) {`\n\n  `x = y; // Ok`\n\n  `y = x; // Error`\n\n  `let s1: string = x; // Error`\n\n  `let s2: string = y; // Ok`\n\n`}`\n\nConditional types are particularly useful when combined with mapped types:\n\nts\n\n`type FunctionPropertyNames<T> = {`\n\n  `[K in keyof T]: T[K] extends Function ? K : never;`\n\n`}[keyof T];`\n\n`type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;`\n\n`type NonFunctionPropertyNames<T> = {`\n\n  `[K in keyof T]: T[K] extends Function ? never : K;`\n\n`}[keyof T];`\n\n`type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;`\n\n`interface Part {`\n\n  `id: number;`\n\n  `name: string;`\n\n  `subparts: Part[];`\n\n  `updatePart(newName: string): void;`\n\n`}`\n\n`type T40 = FunctionPropertyNames<Part>; // \"updatePart\"`\n\n`type T41 = NonFunctionPropertyNames<Part>; // \"id\" | \"name\" | \"subparts\"`\n\n`type T42 = FunctionProperties<Part>; // { updatePart(newName: string): void }`\n\n`type T43 = NonFunctionProperties<Part>; // { id: number, name: string, subparts: Part[] }`\n\nSimilar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.\n\n##### [](#example-3)Example\n\nts\n\n`type ElementType<T> = T extends any[] ? ElementType<T[number]> : T; // Error`\n\n## [](#type-inference-in-conditional-types)Type inference in conditional types\n\nWithin the `extends` clause of a conditional type, it is now possible to have `infer` declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple `infer` locations for the same type variable.\n\nFor example, the following extracts the return type of a function type:\n\nts\n\n`type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;`\n\nConditional types can be nested to form a sequence of pattern matches that are evaluated in order:\n\nts\n\n`type Unpacked<T> = T extends (infer U)[]`\n\n  `? U`\n\n  `: T extends (...args: any[]) => infer U`\n\n  `? U`\n\n  `: T extends Promise<infer U>`\n\n  `? U`\n\n  `: T;`\n\n`type T0 = Unpacked<string>; // string`\n\n`type T1 = Unpacked<string[]>; // string`\n\n`type T2 = Unpacked<() => string>; // string`\n\n`type T3 = Unpacked<Promise<string>>; // string`\n\n`type T4 = Unpacked<Promise<string>[]>; // Promise<string>`\n\n`type T5 = Unpacked<Unpacked<Promise<string>[]>>; // string`\n\nThe following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:\n\nts\n\n`type Foo<T> = T extends { a: infer U; b: infer U } ? U : never;`\n\n`type T10 = Foo<{ a: string; b: string }>; // string`\n\n`type T11 = Foo<{ a: string; b: number }>; // string | number`\n\nLikewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:\n\nts\n\n`type Bar<T> = T extends { a: (x: infer U) => void; b: (x: infer U) => void }`\n\n  `? U`\n\n  `: never;`\n\n`type T20 = Bar<{ a: (x: string) => void; b: (x: string) => void }>; // string`\n\n`type T21 = Bar<{ a: (x: string) => void; b: (x: number) => void }>; // string & number`\n\nWhen inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the _last_ signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.\n\nts\n\n`declare function foo(x: string): number;`\n\n`declare function foo(x: number): string;`\n\n`declare function foo(x: string | number): string | number;`\n\n`type T30 = ReturnType<typeof foo>; // string | number`\n\nIt is not possible to use `infer` declarations in constraint clauses for regular type parameters:\n\nts\n\n`type ReturnType<T extends (...args: any[]) => infer R> = R; // Error, not supported`\n\nHowever, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:\n\nts\n\n`type AnyFunction = (...args: any[]) => any;`\n\n`type ReturnType<T extends AnyFunction> = T extends (...args: any[]) => infer R`\n\n  `? R`\n\n  `: any;`\n\n## [](#predefined-conditional-types)Predefined conditional types\n\nTypeScript 2.8 adds several predefined conditional types to `lib.d.ts`:\n\n*   `Exclude<T, U>` — Exclude from `T` those types that are assignable to `U`.\n*   `Extract<T, U>` — Extract from `T` those types that are assignable to `U`.\n*   `NonNullable<T>` — Exclude `null` and `undefined` from `T`.\n*   `ReturnType<T>` — Obtain the return type of a function type.\n*   `InstanceType<T>` — Obtain the instance type of a constructor function type.\n\n##### [](#example-4)Example\n\nts\n\n`type T00 = Exclude<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"b\" | \"d\"`\n\n`type T01 = Extract<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"a\" | \"c\"`\n\n`type T02 = Exclude<string | number | (() => void), Function>; // string | number`\n\n`type T03 = Extract<string | number | (() => void), Function>; // () => void`\n\n`type T04 = NonNullable<string | number | undefined>; // string | number`\n\n`type T05 = NonNullable<(() => string) | string[] | null | undefined>; // (() => string) | string[]`\n\n`function f1(s: string) {`\n\n  `return { a: 1, b: s };`\n\n`}`\n\n`class C {`\n\n  `x = 0;`\n\n  `y = 0;`\n\n`}`\n\n`type T10 = ReturnType<() => string>; // string`\n\n`type T11 = ReturnType<(s: string) => void>; // void`\n\n`type T12 = ReturnType<<T>() => T>; // {}`\n\n`type T13 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]`\n\n`type T14 = ReturnType<typeof f1>; // { a: number, b: string }`\n\n`type T15 = ReturnType<any>; // any`\n\n`type T16 = ReturnType<never>; // any`\n\n`type T17 = ReturnType<string>; // Error`\n\n`type T18 = ReturnType<Function>; // Error`\n\n`type T20 = InstanceType<typeof C>; // C`\n\n`type T21 = InstanceType<any>; // any`\n\n`type T22 = InstanceType<never>; // any`\n\n`type T23 = InstanceType<string>; // Error`\n\n`type T24 = InstanceType<Function>; // Error`\n\n> Note: The `Exclude` type is a proper implementation of the `Diff` type suggested [here](https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458). We’ve used the name `Exclude` to avoid breaking existing code that defines a `Diff`, plus we feel that name better conveys the semantics of the type. We did not include the `Omit<T, K>` type because it is trivially written as `Pick<T, Exclude<keyof T, K>>`.\n\n## [](#improved-control-over-mapped-type-modifiers)Improved control over mapped type modifiers\n\nMapped types support adding a `readonly` or `?` modifier to a mapped property, but they did not provide support the ability to _remove_ modifiers. This matters in [_homomorphic mapped types_](https://github.com/Microsoft/TypeScript/pull/12563) which by default preserve the modifiers of the underlying type.\n\nTypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier. Specifically, a `readonly` or `?` property modifier in a mapped type can now be prefixed with either `+` or `-` to indicate that the modifier should be added or removed.\n\n#### [](#example-5)Example\n\nts\n\n`type MutableRequired<T> = { -readonly [P in keyof T]-?: T[P] }; // Remove readonly and ?`\n\n`type ReadonlyPartial<T> = { +readonly [P in keyof T]+?: T[P] }; // Add readonly and ?`\n\nA modifier with no `+` or `-` prefix is the same as a modifier with a `+` prefix. So, the `ReadonlyPartial<T>` type above corresponds to\n\nts\n\n`type ReadonlyPartial<T> = { readonly [P in keyof T]?: T[P] }; // Add readonly and ?`\n\nUsing this ability, `lib.d.ts` now has a new `Required<T>` type. This type strips `?` modifiers from all properties of `T`, thus making all properties required.\n\n##### [](#example-6)Example\n\nts\n\n`type Required<T> = { [P in keyof T]-?: T[P] };`\n\nNote that in [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) mode, when a homomorphic mapped type removes a `?` modifier from a property in the underlying type it also removes `undefined` from the type of that property:\n\n##### [](#example-7)Example\n\nts\n\n`type Foo = { a?: string }; // Same as { a?: string | undefined }`\n\n`type Bar = Required<Foo>; // Same as { a: string }`\n\n## [](#improved-keyof-with-intersection-types)Improved `keyof` with intersection types\n\nWith TypeScript 2.8 `keyof` applied to an intersection type is transformed to a union of `keyof` applied to each intersection constituent. In other words, types of the form `keyof (A & B)` are transformed to be `keyof A | keyof B`. This change should address inconsistencies with inference from `keyof` expressions.\n\n##### [](#example-8)Example\n\nts\n\n`type A = { a: string };`\n\n`type B = { b: string };`\n\n`type T1 = keyof (A & B); // \"a\" | \"b\"`\n\n`type T2<T> = keyof (T & B); // keyof T | \"b\"`\n\n`type T3<U> = keyof (A & U); // \"a\" | keyof U`\n\n`type T4<T, U> = keyof (T & U); // keyof T | keyof U`\n\n`type T5 = T2<A>; // \"a\" | \"b\"`\n\n`type T6 = T3<B>; // \"a\" | \"b\"`\n\n`type T7 = T4<A, B>; // \"a\" | \"b\"`\n\n## [](#better-handling-for-namespace-patterns-in-js-files)Better handling for namespace patterns in `.js` files\n\nTypeScript 2.8 adds support for understanding more namespace patterns in `.js` files. Empty object literals declarations on top level, just like functions and classes, are now recognized as namespace declarations in JavaScript.\n\njs\n\n`` var ns = {}; // recognized as a declaration for a namespace `ns` ``\n\n`` ns.constant = 1; // recognized as a declaration for var `constant` ``\n\nAssignments at the top-level should behave the same way; in other words, a `var` or `const` declaration is not required.\n\njs\n\n`` app = {}; // does NOT need to be `var app = {}` ``\n\n`app.C = class {};`\n\n`app.f = function() {};`\n\n`app.prop = 1;`\n\n## [](#iifes-as-namespace-declarations)IIFEs as namespace declarations\n\nAn IIFE returning a function, class or empty object literal, is also recognized as a namespace:\n\njs\n\n`var C = (function() {`\n\n  `function C(n) {`\n\n    `this.p = n;`\n\n  `}`\n\n  `return C;`\n\n`})();`\n\n`C.staticProperty = 1;`\n\n## [](#defaulted-declarations)Defaulted declarations\n\n“Defaulted declarations” allow initializers that reference the declared name in the left side of a logical or:\n\njs\n\n`my = window.my || {};`\n\n`my.app = my.app || {};`\n\n## [](#prototype-assignment)Prototype assignment\n\nYou can assign an object literal directly to the prototype property. Individual prototype assignments still work too:\n\nts\n\n`var C = function(p) {`\n\n  `this.p = p;`\n\n`};`\n\n`C.prototype = {`\n\n  `m() {`\n\n    `console.log(this.p);`\n\n  `}`\n\n`};`\n\n`C.prototype.q = function(r) {`\n\n  `return this.p === r;`\n\n`};`\n\n## [](#nested-and-merged-declarations)Nested and merged declarations\n\nNesting works to any level now, and merges correctly across files. Previously neither was the case.\n\njs\n\n`var app = window.app || {};`\n\n`app.C = class {};`\n\n## [](#per-file-jsx-factories)Per-file JSX factories\n\nTypeScript 2.8 adds support for a per-file configurable JSX factory name using `@jsx dom` pragma. JSX factory can be configured for a compilation using [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory) (default is `React.createElement`). With TypeScript 2.8 you can override this on a per-file-basis by adding a comment to the beginning of the file.\n\n##### [](#example-9)Example\n\nts\n\n`/** @jsx dom */`\n\n`import { dom } from \"./renderer\";`\n\n`<h></h>;`\n\nGenerates:\n\njs\n\n`var renderer_1 = require(\"./renderer\");`\n\n`renderer_1.dom(\"h\", null);`\n\n## [](#locally-scoped-jsx-namespaces)Locally scoped JSX namespaces\n\nJSX type checking is driven by definitions in a JSX namespace, for instance `JSX.Element` for the type of a JSX element, and `JSX.IntrinsicElements` for built-in elements. Before TypeScript 2.8 the `JSX` namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the `JSX` namespace will be looked under the `jsxNamespace` (e.g. `React`) allowing for multiple jsx factories in one compilation. For backward compatibility the global `JSX` namespace is used as a fallback if none was defined on the factory function. Combined with the per-file `@jsx` pragma, each file can have a different JSX factory.\n\n## [](#new---emitdeclarationonly)New `--emitDeclarationOnly`\n\n[`emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly) allows for _only_ generating declaration files; `.js`/`.jsx` output generation will be skipped with this flag. The flag is useful when the `.js` output generation is handled by a different transpiler like Babel.",
    "title": "TypeScript: Documentation - TypeScript 2.8",
    "description": "TypeScript 2.8 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html",
    "markdown": "# TypeScript: Documentation - TypeScript 4.1\n\n## [](#template-literal-types)Template Literal Types\n\nString literal types in TypeScript allow us to model functions and APIs that expect a set of specific strings.\n\nts\n\n`function setVerticalAlignment(location: \"top\" | \"middle\" | \"bottom\") {`\n\n  `// ...`\n\n`}`\n\n`setVerticalAlignment(\"middel\");`\n\n`Argument of type '\"middel\"' is not assignable to parameter of type '\"top\" | \"middle\" | \"bottom\"'.2345Argument of type '\"middel\"' is not assignable to parameter of type '\"top\" | \"middle\" | \"bottom\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaIpBQGozVkCGANgIKdUDmJALaQSFABSc4HarVQAiCnAAO80AB9Q8oVQAmuzpDWb5AIzgUlQ+QEpQAbzyhQIUADoPeAL548DZqxUHDx8giJi4tp6upCctgDcQA)\n\nThis is pretty nice because string literal types can basically spell-check our string values.\n\nWe also like that string literals can be used as property names in mapped types. In this sense, they’re also usable as building blocks:\n\nts\n\n`type Options = {`\n\n  `[K in \"noImplicitAny\" | \"strictNullChecks\" | \"strictFunctionTypes\"]?: boolean;`\n\n`};`\n\n`// same as`\n\n`//   type Options = {`\n\n`//       noImplicitAny?: boolean,`\n\n`//       strictNullChecks?: boolean,`\n\n`//       strictFunctionTypes?: boolean`\n\n`//   };`\n\nBut there’s another place that that string literal types could be used as building blocks: building other string literal types.\n\nThat’s why TypeScript 4.1 brings the template literal string type. It has the same syntax as [template literal strings in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), but is used in type positions. When you use it with concrete literal types, it produces a new string literal type by concatenating the contents.\n\nts\n\n`type World = \"world\";`\n\n``type Greeting = `hello ${World}`;``\n\n        `type Greeting = \"hello world\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6g9gJwDYBMoF4oCIDujVYDcAUMaJFAOIIQTACWAdgOYZQAGAFhEknFABIA3vGQoAvuxIB6aVHkA9APxA)\n\nWhat happens when you have unions in substitution positions? It produces the set of every possible string literal that could be represented by each union member.\n\nts\n\n`type Color = \"red\" | \"blue\";`\n\n`type Quantity = \"one\" | \"two\";`\n\n``type SeussFish = `${Quantity | Color} fish`;``\n\n`type SeussFish = \"one fish\" | \"two fish\" | \"red fish\" | \"blue fish\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gGzgJygXigImRAJpqAHywCMEBXCTAbgChRIoBFcgQwDtgBLUdLOdlSJZgAdzg1a9cNADKEcgGdFAMS6KAFnwAGAEgDeLDt17F4SZAF8oAM3UbtdAPROobgHoB+IA)\n\nThis can be used beyond cute examples in release notes. For example, several libraries for UI components have a way to specify both vertical and horizontal alignment in their APIs, often with both at once using a single string like `\"bottom-right\"`. Between vertically aligning with `\"top\"`, `\"middle\"`, and `\"bottom\"`, and horizontally aligning with `\"left\"`, `\"center\"`, and `\"right\"`, there are 9 possible strings where each of the former strings is connected with each of the latter strings using a dash.\n\nts\n\n`type VerticalAlignment = \"top\" | \"middle\" | \"bottom\";`\n\n`type HorizontalAlignment = \"left\" | \"center\" | \"right\";`\n\n`// Takes`\n\n`//   | \"top-left\"    | \"top-center\"    | \"top-right\"`\n\n`//   | \"middle-left\" | \"middle-center\" | \"middle-right\"`\n\n`//   | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"`\n\n``declare function setAlignment(value: `${VerticalAlignment}-${HorizontalAlignment}`): void;``\n\n`setAlignment(\"top-left\");   // works!`\n\n`setAlignment(\"top-middel\"); // error!`\n\n`Argument of type '\"top-middel\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.2345Argument of type '\"top-middel\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.  setAlignment(\"top-pot\");    // error! but good doughnuts if you're ever in Seattle  Argument of type '\"top-pot\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.2345Argument of type '\"top-pot\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAGowECWAxgIYA2AgkzQOYB2AtpFwVABeUACICcEqNAAfMTxoATRU0jS5ogEZwCEnqIDchUuQASCGgC84A5m069+gkaNUAzAurF0nML6OhOAAtPIzwQUAAVBgBrSERwsFBZMQkSAFp3T2TkjTT0nwE-HJTxSXTAjhDRRJyNBWVVTMgPfwaVSALfaDalDorgz1rcsW1dOB5m1tKxvS6inpmdOcrqvDxFSDomBmhyNwBXLjpaG1BESAJ7bj4BAAoAN2YDyFQAAwASAG8qaFpGVjsG5OAC+6W+5kC1lsgIctwIILeAEpUA84EowhcrkDHPcyhksqIkQYchEAO4IGKIACEeCx11xBDu+PS7UgTCJJIiMHg0Fp9Jx8OZ+RIOk5JW5sAQ1NAmgOgg4cDgilAijgByqXHliFANDcoCI6oA5HtQJAHjBdVxQABlSAMXSqIA)\n\nWhile there are **lots** of examples of this sort of API in the wild, this is still a bit of a toy example since we could write these out manually. In fact, for 9 strings, this is likely fine; but when you need a ton of strings, you should consider automatically generating them ahead of time to save work on every type-check (or just use `string`, which will be much simpler to comprehend).\n\nSome of the real value comes from dynamically creating new string literals. For example, imagine a `makeWatchedObject` API that takes an object and produces a mostly identical object, but with a new `on` method to detect for changes to the properties.\n\nts\n\n`let person = makeWatchedObject({`\n\n  `firstName: \"Homer\",`\n\n  `age: 42, // give-or-take`\n\n  `location: \"Springfield\",`\n\n`});`\n\n`person.on(\"firstNameChanged\", () => {`\n\n  ``console.log(`firstName was changed!`);``\n\n`});`\n\nNotice that `on` listens on the event `\"firstNameChanged\"`, not just `\"firstName\"`. How would we type this?\n\nts\n\n`type PropEventSource<T> = {`\n\n    ``on(eventName: `${string & keyof T}Changed`, callback: () => void): void;``\n\n`};`\n\n`/// Create a \"watched object\" with an 'on' method`\n\n`/// so that you can watch for changes to properties.`\n\n`declare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;`\n\nWith this, we can build something that errors when we give the wrong property!\n\nts\n\n`// error!`\n\n`person.on(\"firstName\", () => {});`\n\n`Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.2345Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.  // error!  person.on(\"frstNameChanged\", () => {});  Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.2345Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAArwkCiAbpAHYEDKcArtAMaQA8AKgD5QAXlABvPKGmg4jABSQGzAHIBDALaRUAAwAk4xAWgBLRgHNQAMlABrSETgAzUPwC+AYQAWai5AAmOgA0oFxqADbhAEZqXLao8gCUosJ0cCb+iahpGQDceG75-pBc4WrQ5E7sjFwEJnKgGmr2AOpqBFxeAQDyUQBWJQQCgvJw-aj8Wa7WlNT0TKwc3HxC+eGQBKBkSA1iTa3tnT39g-KS0k4mSATqWqgARAAScFrQ90FSoGrm2qBYaCEQKBzCYGABaBBggjNSCfcJwMJ1OQPFgkUwWS6QcL+d4FRL5PBAsHErjsAjEsGEsAweDQACEeG2iDkADo5PJ7pdrrdIO9QEkUhI3Pi8FTQDSEAymaz2ZzuZpIN5fD8cSEBSJhOJhbkgA)\n\nWe can also do something special in template literal types: we can _infer_ from substitution positions. We can make our last example generic to infer from parts of the `eventName` string to figure out the associated property.\n\nts\n\n`type PropEventSource<T> = {`\n\n    `on<K extends string & keyof T>`\n\n        ``(eventName: `${K}Changed`, callback: (newValue: T[K]) => void ): void;``\n\n`};`\n\n`declare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;`\n\n`let person = makeWatchedObject({`\n\n    `firstName: \"Homer\",`\n\n    `age: 42,`\n\n    `location: \"Springfield\",`\n\n`});`\n\n`// works! 'newName' is typed as 'string'`\n\n`person.on(\"firstNameChanged\", newName => {`\n\n    `// 'newName' has the type of 'firstName'`\n\n    ``console.log(`new name is ${newName.toUpperCase()}`);``\n\n`});`\n\n`// works! 'newAge' is typed as 'number'`\n\n`person.on(\"ageChanged\", newAge => {`\n\n    `if (newAge < 0) {`\n\n        `console.log(\"warning! negative age\");`\n\n    `}`\n\n`})`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACoB8UAvFAN4BQUzUCGJA0lBAB7CYATAM5QhwOAEsMAcygAyKAGsIIBADMolJix0AKCOiwA5AIYBbCAC4oAAwAkdDgF8AwgAsTMiAJsAaKIQmADZBAEYmhIrWuhgQAO4AasF4VpoA2hwAugCUNFSoCBICUNnWBUUA3AxOVQwCEIRBJnDQangYhMASbFBmJsoA6ibAhG7eAPKhAFYNwOQUugjT1mSlmvKwiCiGOPhEpJS1QRDAUJBwQj20fYPDoxPTs7qMOmoSF8CmFtYARAASCAscB+vm0zBM0lSABYAEygnRBBCBLpsX7YMCSGRvCBBAQg6rZWoAeiJUDiCDgiiEAEIoAByWJxL4QOlQCQiUCQYomER0sSY6R0hjnS4YAB0bF0PzeH2Z7k8kLx-kZzLy9DBUBJ9JV5hZUA8HLGUE50HU9JlYmZQp0hDYl2OYsR0l0NkZUAwurZIgcOosYuACAAqmBzi4eRBdNknDZCQTiaTyZSadr4gBBSGs9nG8DeKA87V4MyhCBwIUitgSjBSiEQeVeJXutOQtUvFgSDQxJvQEhQAAMuVbOmYtow9ogjoQzp+cWaGCk0lpsWkwwk6DzkJ+sZ0TgJQA)\n\nHere we made `on` into a generic method. When a user calls with the string `\"firstNameChanged'`, TypeScript will try to infer the right type for `K`. To do that, it will match `K` against the content prior to `\"Changed\"` and infer the string `\"firstName\"`. Once TypeScript figures that out, the `on` method can fetch the type of `firstName` on the original object, which is `string` in this case. Similarly, when we call with `\"ageChanged\"`, it finds the type for the property `age` which is `number`).\n\nInference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways. In fact, to help with modifying these string literal types, we’ve added a few new utility type aliases for modifying casing in letters (i.e. converting to lowercase and uppercase characters).\n\nts\n\n`` type EnthusiasticGreeting<T extends string> = `${Uppercase<T>}` ``\n\n`type HELLO = EnthusiasticGreeting<\"hello\">;`\n\n      `type HELLO = \"HELLO\"`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogdsAFgVwM4EsCGrjoMYDiAThBLnAOYA8AKlBAB7ARwAmqUOR6lAfFAF4oAAwAkAbwCqYSETzYItXgF9hAKDWhIUABIwAMvoDyg2AhQZsuQiTI9qAIkQQANi4D2D3gG41Aej8oIIA9AH4gA)\n\nThe new type aliases are `Uppercase`, `Lowercase`, `Capitalize` and `Uncapitalize`. The first two transform every character in a string, and the latter two transform only the first character in a string.\n\nFor more details, [see the original pull request](https://github.com/microsoft/TypeScript/pull/40336) and [the in-progress pull request to switch to type alias helpers](https://github.com/microsoft/TypeScript/pull/40580).\n\n## [](#key-remapping-in-mapped-types)Key Remapping in Mapped Types\n\nJust as a refresher, a mapped type can create new object types based on arbitrary keys\n\nts\n\n`type Options = {`\n\n  `[K in \"noImplicitAny\" | \"strictNullChecks\" | \"strictFunctionTypes\"]?: boolean;`\n\n`};`\n\n`// same as`\n\n`//   type Options = {`\n\n`//       noImplicitAny?: boolean,`\n\n`//       strictNullChecks?: boolean,`\n\n`//       strictFunctionTypes?: boolean`\n\n`//   };`\n\nor new object types based on other object types.\n\nts\n\n`/// 'Partial<T>' is the same as 'T', but with each property marked optional.`\n\n`type Partial<T> = {`\n\n  `[K in keyof T]?: T[K];`\n\n`};`\n\nUntil now, mapped types could only produce new object types with keys that you provided them; however, lots of the time you want to be able to create new keys, or filter out keys, based on the inputs.\n\nThat’s why TypeScript 4.1 allows you to re-map keys in mapped types with a new `as` clause.\n\nts\n\n`type MappedTypeWithNewKeys<T> = {`\n\n    `[K in keyof T as NewKeyType]: T[K]`\n\n    `//            ^^^^^^^^^^^^^`\n\n    `//            This is the new syntax!`\n\n`}`\n\nWith this new `as` clause, you can leverage features like template literal types to easily create property names based off of old ones.\n\nts\n\n`type Getters<T> = {`\n\n    ``[K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]``\n\n`};`\n\n`interface Person {`\n\n    `name: string;`\n\n    `age: number;`\n\n    `location: string;`\n\n`}`\n\n`type LazyPerson = Getters<Person>;`\n\n         `type LazyPerson = {     getName: () => string;     getAge: () => number;     getLocation: () => string; }`\n\n[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hzAgJwM4B4AqA+KBeKA3gFBSlQDaA0lAJYB2UA1hCAPYBmUGUAhilAAMA5vAAkBAMI8wNYDwA2NAF4Q0KYEnpCoAMiiUsAXwEBdAFxQAFAEo8ODFRNFDAbiJF6iJOx4BjaAAKyCisDMRkUHQ8ALYQFuqadEJuETwiFnQArtEARsgpZPKsvjzANKHxGlpuhu6gkFAAMjxKIEGooXiw8F7o7SF0WG4A9MNkAHoA-EA)\n\nand you can even filter out keys by producing `never`. That means you don’t have to use an extra `Omit` helper type in some cases.\n\nts\n\n`// Remove the 'kind' property`\n\n`type RemoveKindField<T> = {`\n\n    `[K in keyof T as Exclude<K, \"kind\">]: T[K]`\n\n`};`\n\n`interface Circle {`\n\n    `kind: \"circle\";`\n\n    `radius: number;`\n\n`}`\n\n`type KindlessCircle = RemoveKindField<Circle>;`\n\n           `type KindlessCircle = {     radius: number; }`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdKgC4AskHIDWBLAdgCYagAOATrCZGcgJ4BQdVEMCkA0vgQGI6QA2BADwAVAHygAvKADe9UAtABtdqHygskWrABmoEaACGAZ1ABRAB4BjfgFcCkIewA0oAES5CbsQF0AXPoqPvQAvgDc9PT4yNQ6hlZIAMI4ZDZIcooaXAFuVilpbhGZZIYEOLbGAXi20ABG1BEhkUxInIT8kMbGyakdUixwiG08fIJCPWliESCKAHoA-EA)\n\nFor more information, take a look at [the original pull request over on GitHub](https://github.com/microsoft/TypeScript/pull/40336).\n\n## [](#recursive-conditional-types)Recursive Conditional Types\n\nIn JavaScript it’s fairly common to see functions that can flatten and build up container types at arbitrary levels. For example, consider the `.then()` method on instances of `Promise`. `.then(...)` unwraps each promise until it finds a value that’s not “promise-like”, and passes that value to a callback. There’s also a relatively new `flat` method on `Array`s that can take a depth of how deep to flatten.\n\nExpressing this in TypeScript’s type system was, for all practical intents and purposes, not possible. While there were hacks to achieve this, the types ended up looking very unreasonable.\n\nThat’s why TypeScript 4.1 eases some restrictions on conditional types - so that they can model these patterns. In TypeScript 4.1, conditional types can now immediately reference themselves within their branches, making it easier to write recursive type aliases.\n\nFor example, if we wanted to write a type to get the element types of nested arrays, we could write the following `deepFlatten` type.\n\nts\n\n`type ElementType<T> = T extends ReadonlyArray<infer U> ? ElementType<U> : T;`\n\n`function deepFlatten<T extends readonly unknown[]>(x: T): ElementType<T>[] {`\n\n  `throw \"not implemented\";`\n\n`}`\n\n`// All of these return the type 'number[]':`\n\n`deepFlatten([1, 2, 3]);`\n\n`deepFlatten([[1], [2, 3]]);`\n\n`deepFlatten([[1], [[2]], [[[3]]]]);`\n\nSimilarly, in TypeScript 4.1 we can write an `Awaited` type to deeply unwrap `Promise`s.\n\nts\n\n`type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;`\n\n``/// Like `promise.then(...)`, but more accurate in types.``\n\n`declare function customThen<T, U>(`\n\n  `p: Promise<T>,`\n\n  `onFulfilled: (value: Awaited<T>) => U`\n\n`): Promise<Awaited<U>>;`\n\nKeep in mind that while these recursive types are powerful, but they should be used responsibly and sparingly.\n\nFirst off, these types can do a lot of work which means that they can increase type-checking time. Trying to model numbers in the Collatz conjecture or Fibonacci sequence might be fun, but don’t ship that in `.d.ts` files on npm.\n\nBut apart from being computationally intensive, these types can hit an internal recursion depth limit on sufficiently-complex inputs. When that recursion limit is hit, that results in a compile-time error. In general, it’s better not to use these types at all than to write something that fails on more realistic examples.\n\nSee more [at the implementation](https://github.com/microsoft/TypeScript/pull/40002).\n\n## [](#checked-indexed-accesses---nouncheckedindexedaccess)Checked Indexed Accesses (`--noUncheckedIndexedAccess`)\n\nTypeScript has a feature called _index signatures_. These signatures are a way to signal to the type system that users can access arbitrarily-named properties.\n\nts\n\n`interface Options {`\n\n  `path: string;`\n\n  `permissions: number;`\n\n  `// Extra properties are caught by this index signature.`\n\n  `[propName: string]: string | number;`\n\n`}`\n\n`function checkOptions(opts: Options) {`\n\n  `opts.path; // string`\n\n  `opts.permissions; // number`\n\n  `// These are all allowed too!`\n\n  `// They have the type 'string | number'.`\n\n  `opts.yadda.toString();`\n\n  `opts[\"foo bar baz\"].toString();`\n\n  `opts[Math.random()].toString();`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM7IDeAUMsunGABYBcyeYUoA5gNynnQC2weeO+OiACuXAEbR2HAPTTkAUQAejOOSjZ00LBAJwoKBHGHMqYZGICeyar2SgAJhEX1gzEJWH6AdBwDa6dXQAOTguCDoGJhBmAF0IxhZkAB9kEXFJYgBfYmIYYRAELFxkBCoIBABrDCL8AAoNMDw6aoE8AEoiDga8LwpqVmRZegTorswezSgePlaBobSJKByyIYAVMrwUPS2AGx3kOD3sAHcIe2tsbABCGTl1iCsqOAA3FGo3i01kAHJIxJSFtBvj4yN0vBY4PZ7HAvGBsABlEbMWptdig8a+ABEMEu5j0eIAXpiYrCEUiUWjkN1fABZShULxQOAgezYLgoklwxFRZGorJAA)\n\nIn the above example, `Options` has an index signature that says any accessed property that’s not already listed should have the type `string | number`. This is often convenient for optimistic code that assumes you know what you’re doing, but the truth is that most values in JavaScript do not support every potential property name. Most types will not, for example, have a value for a property key created by `Math.random()` like in the previous example. For many users, this behavior was undesirable, and felt like it wasn’t leveraging the full strict-checking of [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks).\n\nThat’s why TypeScript 4.1 ships with a new flag called [`noUncheckedIndexedAccess`](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess). Under this new mode, every property access (like `foo.bar`) or indexed access (like `foo[\"bar\"]`) is considered potentially undefined. That means that in our last example, `opts.yadda` will have the type `string | number | undefined` as opposed to just `string | number`. If you need to access that property, you’ll either have to check for its existence first or use a non-null assertion operator (the postfix `!` character).\n\nts\n\n`function checkOptions(opts: Options) {`\n\n  `opts.path; // string`\n\n  `opts.permissions; // number`\n\n  `// These are not allowed with noUncheckedIndexedAccess`\n\n  `opts.yadda.toString();`\n\n`'opts.yadda' is possibly 'undefined'.18048'opts.yadda' is possibly 'undefined'.    opts[\"foo bar baz\"].toString();  Object is possibly 'undefined'.2532Object is possibly 'undefined'.    opts[Math.random()].toString();  Object is possibly 'undefined'.2532Object is possibly 'undefined'.    // Checking if it's really there first.    if (opts.yadda) {      console.log(opts.yadda.toString());    }    // Basically saying \"trust me I know what I'm doing\"    // with the '!' non-null assertion operator.    opts.yadda!.toString();  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoECAOzgFVqBjAC0kYGtIATASWq8gAPbgEFGjSIkTkAltQAuMAGYBDCaADyAB3ky41RKADe5UKC0r5zVInnQ5AcwDcp8zAC2MqXoOpqAV3cAIxgXVyoAUUE7FXN4LRhdSVAVaEhQRhV-B2Z5UCCAT1ArL1A5AUFQRBkHakt-NIA6VwBtLXiAORV3SBs7RwBdPvtqB1AAH1AA4NDyAF9KMABaFcZ-eRWl8iV-Jl19DNYObX2DAAo4HRRNHR9EAEpjV0v5REaLKydQKlsRh2eru8PF5qvpEF8qNMQtByOEwAAVViIdKpdK0PIqAA2mLgAHduKBcTIrFN6EwjpxePwhKJxJJpGYXm8CiouFwVI15HAAMr9UZne4uRlXFoAIiUcDg+VS0oAXqKBpyeXyHAKhaAmS0ALKWZiNaAqfhwdwCxVc3l-NWwsxUADCFMcZSUZXkAHJDGksZiilYYOklDIkPJmmYZM6LoCWWyVI8TGYzIwwXBMZBGjjVUzGlH2UqLY4BYLXAs4aAAEIqaqZbFFRAqAqO0V2fy2UA9UA8UDsWi4wnMSzt13uUBcOCOUUlokk32gV0AQldpOoSwC2JSUkSPg1CQNXOgIa3ryzrPZs9zKqtcyAA)\n\nOne consequence of using [`noUncheckedIndexedAccess`](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess) is that indexing into an array is also more strictly checked, even in a bounds-checked loop.\n\nts\n\n`function screamLines(strs: string[]) {`\n\n  `// This will have issues`\n\n  `for (let i = 0; i < strs.length; i++) {`\n\n    `console.log(strs[i].toUpperCase());`\n\n`Object is possibly 'undefined'.2532Object is possibly 'undefined'.    }  }  `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoECAOzgFVqBjAC0kYGtIATASWq8gAPbgEFGjSIkTkAZgFcmAFwCWcaqESNokAIYBbADLLqkgBSJFSVBejGA5gG0AugEpQAb3KhQVACrNlRFAAd2UAGzDQZh0AN0hQQMQ5SS9QGQRQUzDIRQTQAF5QIgBuPIAeDUtEADps6jtFZlLlAGoWt09vb0Y1RDhs2rg7cyqHZSdqxXoAB2mYAGEdREhTFxdi1IBfck2gA)\n\nIf you don’t need the indexes, you can iterate over individual elements by using a `for`\\-`of` loop or a `forEach` call.\n\nts\n\n`function screamLines(strs: string[]) {`\n\n  `// This works fine`\n\n  `for (const str of strs) {`\n\n    `console.log(str.toUpperCase());`\n\n  `}`\n\n  `// This works fine`\n\n  `strs.forEach((str) => {`\n\n    `console.log(str.toUpperCase());`\n\n  `});`\n\n`}`\n\n[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIMYAsCmCDWKAmBJSWUAPbAQQQRQGdKAoAMwFdEAXAS2klEoQCcUBDALYAZVpCoAKSsx6UAXFxliA5gG0AugEpQAbxqhQIUABUkrSqADu0Hugt0xKfaDo3QEhB2mKeoaHR9KbT0DA09ISmgAGxQAOijoZSkZWOY4AAd0lB4AYX5KFAlNTQBuZwBfGmcjU3MrGzsXR2dpWVjXHgBRfmQJZJ5tAF4APl1nMK9ouISk1tSMrNz8wuKyg3LSmnKgA)\n\nThis flag can be handy for catching out-of-bounds errors, but it might be noisy for a lot of code, so it is not automatically enabled by the [`strict`](https://www.typescriptlang.org/tsconfig#strict) flag; however, if this feature is interesting to you, you should feel free to try it and determine whether it makes sense for your team’s codebase!\n\nYou can learn more [at the implementing pull request](https://github.com/microsoft/TypeScript/pull/39560).\n\n## [](#paths-without-baseurl)`paths` without `baseUrl`\n\nUsing path-mapping is fairly common - often it’s to have nicer imports, often it’s to simulate monorepo linking behavior.\n\nUnfortunately, specifying [`paths`](https://www.typescriptlang.org/tsconfig#paths) to enable path-mapping required also specifying an option called [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl), which allows bare specifier paths to be reached relative to the [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl) too. This also often caused poor paths to be used by auto-imports.\n\nIn TypeScript 4.1, the [`paths`](https://www.typescriptlang.org/tsconfig#paths) option can be used without [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl). This helps avoid some of these issues.\n\n## [](#checkjs-implies-allowjs)`checkJs` Implies `allowJs`\n\nPreviously if you were starting a checked JavaScript project, you had to set both [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs) and [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs). This was a slightly annoying bit of friction in the experience, so [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs) now implies [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs) by default.\n\n[See more details at the pull request](https://github.com/microsoft/TypeScript/pull/40275).\n\n## [](#react-17-jsx-factories)React 17 JSX Factories\n\nTypeScript 4.1 supports React 17’s upcoming `jsx` and `jsxs` factory functions through two new options for the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) compiler option:\n\n*   `react-jsx`\n*   `react-jsxdev`\n\nThese options are intended for production and development compiles respectively. Often, the options from one can extend from the other. For example, a `tsconfig.json` for production builds might look like the following:\n\n`// ./src/tsconfig.json`\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"esnext\",`\n\n    `\"\": \"es2015\",`\n\n    `\"\": \"react-jsx\",`\n\n    `\"\": true`\n\n  `},`\n\n  `\"\": [\"./**/*\"]`\n\n`}`\n\nand one for development builds might look like the following:\n\n`// ./src/tsconfig.dev.json`\n\n`{`\n\n  `\"\": \"./tsconfig.json\",`\n\n  `\"\": {`\n\n    `\"\": \"react-jsxdev\"`\n\n  `}`\n\n`}`\n\nFor more information, [check out the corresponding PR](https://github.com/microsoft/TypeScript/pull/39199).\n\n## [](#editor-support-for-the-jsdoc-see-tag)Editor Support for the JSDoc `@see` Tag\n\nThe JSDoc tag `@see` tag now has better support in editors for TypeScript and JavaScript. This allows you to use functionality like go-to-definition in a dotted name following the tag. For example, going to definition on `first` or `C` in the JSDoc comment just works in the following example:\n\nts\n\n`// @filename: first.ts`\n\n`export class C {}`\n\n`// @filename: main.ts`\n\n`import * as first from \"./first\";`\n\n`/**`\n\n `* @see first.C`\n\n `*/`\n\n`function related() {}`\n\nThanks to frequent contributor [Wenlu Wang](https://github.com/Kingwl) [for implementing this](https://github.com/microsoft/TypeScript/pull/39760)!\n\n## [](#breaking-changes)Breaking Changes\n\n### [](#libdts-changes)`lib.d.ts` Changes\n\n`lib.d.ts` may have a set of changed APIs, potentially in part due to how the DOM types are automatically generated. One specific change is that `Reflect.enumerate` has been removed, as it was removed from ES2016.\n\n### [](#abstract-members-cant-be-marked-async)`abstract` Members Can’t Be Marked `async`\n\nMembers marked as `abstract` can no longer be marked as `async`. The fix here is to remove the `async` keyword, since callers are only concerned with the return type.\n\n### [](#anyunknown-are-propagated-in-falsy-positions)`any`/`unknown` Are Propagated in Falsy Positions\n\nPreviously, for an expression like `foo && somethingElse`, the type of `foo` was `any` or `unknown`, the type of the whole that expression would be the type of `somethingElse`.\n\nFor example, previously the type for `x` here was `{ someProp: string }`.\n\nts\n\n`declare let foo: unknown;`\n\n`declare let somethingElse: { someProp: string };`\n\n`let x = foo && somethingElse;`\n\nHowever, in TypeScript 4.1, we are more careful about how we determine this type. Since nothing is known about the type on the left side of the `&&`, we propagate `any` and `unknown` outward instead of the type on the right side.\n\nThe most common pattern we saw of this tended to be when checking compatibility with `boolean`s, especially in predicate functions.\n\nts\n\n`function isThing(x: any): boolean {`\n\n  `return x && typeof x === \"object\" && x.blah === \"foo\";`\n\n`}`\n\nOften the appropriate fix is to switch from `foo && someExpression` to `!!foo && someExpression`.\n\n### [](#resolves-parameters-are-no-longer-optional-in-promises)`resolve`’s Parameters Are No Longer Optional in `Promise`s\n\nWhen writing code like the following\n\nts\n\n`new Promise((resolve) => {`\n\n  `doSomethingAsync(() => {`\n\n    `doSomething();`\n\n    `resolve();`\n\n  `});`\n\n`});`\n\nYou may get an error like the following:\n\n  `resolve()`\n\n  `~~~~~~~~~`\n\n`error TS2554: Expected 1 arguments, but got 0.`\n\n  `An argument for 'value' was not provided.`\n\nThis is because `resolve` no longer has an optional parameter, so by default, it must now be passed a value. Often this catches legitimate bugs with using `Promise`s. The typical fix is to pass it the correct argument, and sometimes to add an explicit type argument.\n\nts\n\n`new Promise<number>((resolve) => {`\n\n  `//     ^^^^^^^^`\n\n  `doSomethingAsync((value) => {`\n\n    `doSomething();`\n\n    `resolve(value);`\n\n    `//      ^^^^^`\n\n  `});`\n\n`});`\n\nHowever, sometimes `resolve()` really does need to be called without an argument. In these cases, we can give `Promise` an explicit `void` generic type argument (i.e. write it out as `Promise<void>`). This leverages new functionality in TypeScript 4.1 where a potentially-`void` trailing parameter can become optional.\n\nts\n\n`new Promise<void>((resolve) => {`\n\n  `//     ^^^^^^`\n\n  `doSomethingAsync(() => {`\n\n    `doSomething();`\n\n    `resolve();`\n\n  `});`\n\n`});`\n\nTypeScript 4.1 ships with a quick fix to help fix this break.\n\n### [](#conditional-spreads-create-optional-properties)Conditional Spreads Create Optional Properties\n\nIn JavaScript, object spreads (like `{ ...foo }`) don’t operate over falsy values. So in code like `{ ...foo }`, `foo` will be skipped over if it’s `null` or `undefined`.\n\nMany users take advantage of this to spread in properties “conditionally”.\n\nts\n\n`interface Person {`\n\n  `name: string;`\n\n  `age: number;`\n\n  `location: string;`\n\n`}`\n\n`interface Animal {`\n\n  `name: string;`\n\n  `owner: Person;`\n\n`}`\n\n`function copyOwner(pet?: Animal) {`\n\n  `return {`\n\n    `...(pet && pet.owner),`\n\n    `otherStuff: 123,`\n\n  `};`\n\n`}`\n\n`// We could also use optional chaining here:`\n\n`function copyOwner(pet?: Animal) {`\n\n  `return {`\n\n    `...pet?.owner,`\n\n    `otherStuff: 123,`\n\n  `};`\n\n`}`\n\nHere, if `pet` is defined, the properties of `pet.owner` will be spread in - otherwise, no properties will be spread into the returned object.\n\nThe return type of `copyOwner` was previously a union type based on each spread:\n\n`{ x: number } | { x: number, name: string, age: number, location: string }`\n\nThis modeled exactly how the operation would occur: if `pet` was defined, all the properties from `Person` would be present; otherwise, none of them would be defined on the result. It was an all-or-nothing operation.\n\nHowever, we’ve seen this pattern taken to the extreme, with hundreds of spreads in a single object, each spread potentially adding in hundreds or thousands of properties. It turns out that for various reasons, this ends up being extremely expensive, and usually for not much benefit.\n\nIn TypeScript 4.1, the returned type sometimes uses all-optional properties.\n\n`{`\n\n    `x: number;`\n\n    `name?: string;`\n\n    `age?: number;`\n\n    `location?: string;`\n\n`}`\n\nThis ends up performing better and generally displaying better too.\n\nFor more details, [see the original change](https://github.com/microsoft/TypeScript/pull/40778). While this behavior is not entirely consistent right now, we expect a future release will produce cleaner and more predictable results.\n\nTypeScript would previously relate parameters that didn’t correspond to each other by relating them to the type `any`. With [changes in TypeScript 4.1](https://github.com/microsoft/TypeScript/pull/41308), the language now skips this process entirely. This means that some cases of assignability will now fail, but it also means that some cases of overload resolution can fail as well. For example, overload resolution on `util.promisify` in Node.js may select a different overload in TypeScript 4.1, sometimes causing new or different errors downstream.\n\nAs a workaround, you may be best using a type assertion to squelch errors.",
    "title": "TypeScript: Documentation - TypeScript 4.1",
    "description": "TypeScript 4.1 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.6\n\n## [](#strict-function-types)Strict function types\n\nTypeScript 2.6 introduces a new strict checking flag, [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes). The [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes) switch is part of the [`strict`](https://www.typescriptlang.org/tsconfig#strict) family of switches, meaning that it defaults to on in [`strict`](https://www.typescriptlang.org/tsconfig#strict) mode. You can opt-out by setting `--strictFunctionTypes false` on your command line or in your tsconfig.json.\n\nUnder [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes) function type parameter positions are checked _contravariantly_ instead of _bivariantly_. For some background on what variance means for function types check out [What are covariance and contravariance?](https://web.archive.org/web/20220823104433/https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance).\n\nThe stricter checking applies to all function types, _except_ those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as `Array<T>`) continue to mostly relate covariantly.\n\nConsider the following example in which `Animal` is the supertype of `Dog` and `Cat`:\n\nts\n\n`declare let f1: (x: Animal) => void;`\n\n`declare let f2: (x: Dog) => void;`\n\n`declare let f3: (x: Cat) => void;`\n\n`f1 = f2; // Error with --strictFunctionTypes`\n\n`f2 = f1; // Ok`\n\n`f2 = f3; // Error`\n\nThe first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is _possibly_ sound, whereas strict function types mode makes it an error because it isn’t _provably_ sound. In either mode the third assignment is an error because it is _never_ sound.\n\nAnother way to describe the example is that the type `(x: T) => void` is _bivariant_ (i.e. covariant _or_ contravariant) for `T` in default type checking mode, but _contravariant_ for `T` in strict function types mode.\n\n##### [](#example)Example\n\nts\n\n`interface Comparer<T> {`\n\n  `compare: (a: T, b: T) => number;`\n\n`}`\n\n`declare let animalComparer: Comparer<Animal>;`\n\n`declare let dogComparer: Comparer<Dog>;`\n\n`animalComparer = dogComparer; // Error`\n\n`dogComparer = animalComparer; // Ok`\n\nThe first assignment is now an error. Effectively, `T` is contravariant in `Comparer<T>` because it is used only in function type parameter positions.\n\nBy the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (`out`/`in` or `+`/`-`), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript’s structural type system.\n\n##### [](#note)Note\n\nUnder [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes) the first assignment is still permitted if `compare` was declared as a method. Effectively, `T` is bivariant in `Comparer<T>` because it is used only in method parameter positions.\n\nts\n\n`interface Comparer<T> {`\n\n  `compare(a: T, b: T): number;`\n\n`}`\n\n`declare let animalComparer: Comparer<Animal>;`\n\n`declare let dogComparer: Comparer<Dog>;`\n\n`animalComparer = dogComparer; // Ok because of bivariance`\n\n`dogComparer = animalComparer; // Ok`\n\nTypeScript 2.6 also improves type inference involving contravariant positions:\n\nts\n\n`function combine<T>(...funcs: ((x: T) => void)[]): (x: T) => void {`\n\n  `return x => {`\n\n    `for (const f of funcs) f(x);`\n\n  `};`\n\n`}`\n\n`function animalFunc(x: Animal) {}`\n\n`function dogFunc(x: Dog) {}`\n\n`let combined = combine(animalFunc, dogFunc); // (x: Dog) => void`\n\nAbove, all inferences for `T` originate in contravariant positions, and we therefore infer the _best common subtype_ for `T`. This contrasts with inferences from covariant positions, where we infer the _best common supertype_.\n\n## [](#cache-tagged-template-objects-in-modules)Cache tagged template objects in modules\n\nTypeScript 2.6 fixes the tagged string template emit to align better with the ECMAScript spec. As per the [ECMAScript spec](https://tc39.github.io/ecma262/#sec-gettemplateobject), every time a template tag is evaluated, the _same_ template strings object (the same `TemplateStringsArray`) should be passed as the first argument. Before TypeScript 2.6, the generated output was a completely new template object each time. Though the string contents are the same, this emit affects libraries that use the identity of the string for cache invalidation purposes, e.g. [lit-html](https://github.com/PolymerLabs/lit-html/issues/58).\n\n##### [](#example-1)Example\n\nts\n\n`export function id(x: TemplateStringsArray) {`\n\n  `return x;`\n\n`}`\n\n`export function templateObjectFactory() {`\n\n  ``return id`hello world`;``\n\n`}`\n\n`let result = templateObjectFactory() === templateObjectFactory(); // true in TS 2.6`\n\nResults in the following generated code:\n\njs\n\n`\"use strict\";`\n\n`var __makeTemplateObject =`\n\n  `(this && this.__makeTemplateObject) ||`\n\n  `function(cooked, raw) {`\n\n    `if (Object.defineProperty) {`\n\n      `Object.defineProperty(cooked, \"raw\", { value: raw });`\n\n    `} else {`\n\n      `cooked.raw = raw;`\n\n    `}`\n\n    `return cooked;`\n\n  `};`\n\n`function id(x) {`\n\n  `return x;`\n\n`}`\n\n`var _a;`\n\n`function templateObjectFactory() {`\n\n  `return id(`\n\n    `_a || (_a = __makeTemplateObject([\"hello world\"], [\"hello world\"]))`\n\n  `);`\n\n`}`\n\n`var result = templateObjectFactory() === templateObjectFactory();`\n\n> Note: This change brings a new emit helper, `__makeTemplateObject`; if you are using [`importHelpers`](https://www.typescriptlang.org/tsconfig#importHelpers) with [`tslib`](https://github.com/Microsoft/tslib), an updated to version 1.8 or later.\n\n## [](#localized-diagnostics-on-the-command-line)Localized diagnostics on the command line\n\nTypeScript 2.6 npm package ships with localized versions of diagnostic messages for 13 languages. The localized messages are available when using `--locale` flag on the command line.\n\n##### [](#example-2)Example\n\nError messages in Russian:\n\nsh\n\n`c:\\ts>tsc --v`\n\n`Version 2.6.0-dev.20171003`\n\n`c:\\ts>tsc --locale ru --pretty c:\\test\\a.ts`\n\n`../test/a.ts(1,5): error TS2322: Тип \"\"string\"\" не может быть назначен для типа \"number\".`\n\n`1 var x: number = \"string\";`\n\n      `~`\n\nAnd help in Japanese:\n\nsh\n\n`PS C:\\ts> tsc --v`\n\n`Version 2.6.0-dev.20171003`\n\n`PS C:\\ts> tsc --locale ja-jp`\n\n`バージョン 2.6.0-dev.20171003`\n\n`構文: tsc [オプション] [ファイル ...]`\n\n`例:  tsc hello.ts`\n\n    `tsc --outFile file.js file.ts`\n\n    `tsc @args.txt`\n\n`オプション:`\n\n `-h, --help                                 このメッセージを表示します。`\n\n `--all                                      コンパイラ オプションをすべて表示します。`\n\n `-v, --version                              コンパイラのバージョンを表示します。`\n\n `--init                                     TypeScript プロジェクトを初期化して、tsconfig.json ファイルを作成します。`\n\n `-p ファイルまたはディレクトリ, --project ファイルまたはディレクトリ  構成ファイルか、'tsconfig.json' を含むフォルダーにパスが指定されたプロジェクトをコ`\n\n`ンパイルします。`\n\n `--pretty                                   色とコンテキストを使用してエラーとメッセージにスタイルを適用します (試験的)。`\n\n `-w, --watch                                入力ファイルを監視します。`\n\n `-t バージョン, --target バージョン                   ECMAScript のターゲット バージョンを指定します: 'ES3' (既定)、'ES5'、'ES2015'、'ES2016'、'ES2017'、'ES`\n\n`NEXT'。`\n\n `-m 種類, --module 種類                         モジュール コード生成を指定します: 'none'、'commonjs'、'amd'、'system'、'umd'、'es2015'、'ESNext'。`\n\n `--lib                                      コンパイルに含めるライブラリ ファイルを指定します:`\n\n                                              `'es5' 'es6' 'es2015' 'es7' 'es2016' 'es2017' 'esnext' 'dom' 'dom.iterable' 'webworker' 'scripthost' 'es201`\n\n`5.core' 'es2015.collection' 'es2015.generator' 'es2015.iterable' 'es2015.promise' 'es2015.proxy' 'es2015.reflect' 'es2015.symbol' 'es2015.symbol.wellkno`\n\n`wn' 'es2016.array.include' 'es2017.object' 'es2017.sharedmemory' 'es2017.string' 'es2017.intl' 'esnext.asynciterable'`\n\n `--allowJs                                  javascript ファイルのコンパイルを許可します。`\n\n `--jsx 種類                                   JSX コード生成を指定します: 'preserve'、'react-native'、'react'。`\n\n `-d, --declaration                          対応する '.d.ts' ファイルを生成します。`\n\n `--sourceMap                                対応する '.map' ファイルを生成します。`\n\n `--outFile ファイル                             出力を連結して 1 つのファイルを生成します。`\n\n `--outDir ディレクトリ                            ディレクトリへ出力構造をリダイレクトします。`\n\n `--removeComments                           コメントを出力しないでください。`\n\n `--noEmit                                   出力しないでください。`\n\n `--strict                                   strict 型チェックのオプションをすべて有効にします。`\n\n `--noImplicitAny                            暗黙的な 'any' 型を含む式と宣言に関するエラーを発生させます。`\n\n `--strictNullChecks                         厳格な null チェックを有効にします。`\n\n `--noImplicitThis                           暗黙的な 'any' 型を持つ 'this' 式でエラーが発生します。`\n\n `--alwaysStrict                             厳格モードで解析してソース ファイルごとに \"use strict\" を生成します。`\n\n `--noUnusedLocals                           使用されていないローカルに関するエラーを報告します。`\n\n `--noUnusedParameters                       使用されていないパラメーターに関するエラーを報告します。`\n\n `--noImplicitReturns                        関数の一部のコード パスが値を返さない場合にエラーを報告します。`\n\n `--noFallthroughCasesInSwitch               switch ステートメントに case のフォールスルーがある場合にエラーを報告します。`\n\n `--types                                    コンパイルに含む型宣言ファイル。`\n\n `@<ファイル>`\n\nTypeScript 2.6 support suppressing errors in .ts files using `// @ts-ignore` comments placed above the offending lines.\n\n##### [](#example-3)Example\n\nts\n\n`if (false) {`\n\n  `// @ts-ignore: Unreachable code error`\n\n  `console.log(\"hello\");`\n\n`}`\n\nA `// @ts-ignore` comment suppresses all errors that originate on the following line. It is recommended practice to have the remainder of the comment following `@ts-ignore` explain which error is being suppressed.\n\nPlease note that this comment only suppresses the error reporting, and we recommend you use this comments _very sparingly_.\n\n## [](#faster-tsc---watch)Faster `tsc --watch`\n\nTypeScript 2.6 brings a faster `--watch` implementation. The new version optimizes code generation and checking for code bases using ES modules. Changes detected in a module file will result in _only_ regenerating the changed module, and files that depend on it, instead of the whole project. Projects with large number of files should reap the most benefit from this change.\n\nThe new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.\n\n## [](#write-only-references-now-flagged-as-unused)Write-only references now flagged as unused\n\nTypeScript 2.6 adds revised implementation the [`noUnusedLocals`](https://www.typescriptlang.org/tsconfig#noUnusedLocals) and [`noUnusedParameters`](https://www.typescriptlang.org/tsconfig#noUnusedParameters) [compiler options](https://www.typescriptlang.org/docs/handbook/compiler-options.html). Declarations are only written to but never read from are now flagged as unused.\n\n##### [](#example-4)Example\n\nBellow both `n` and `m` will be marked as unused, because their values are never _read_. Previously TypeScript would only check whether their values were _referenced_.\n\nts\n\n`function f(n: number) {`\n\n  `n = 0;`\n\n`}`\n\n`class C {`\n\n  `private m: number;`\n\n  `constructor() {`\n\n    `this.m = 0;`\n\n  `}`\n\n`}`\n\nAlso functions that are only called within their own bodies are considered unused.\n\n##### [](#example-5)Example\n\nts\n\n`function f() {`\n\n  `f(); // Error: 'f' is declared but its value is never read`\n\n`}`",
    "title": "TypeScript: Documentation - TypeScript 2.6",
    "description": "TypeScript 2.6 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-5.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.5\n\n## [](#optional-catch-clause-variables)Optional `catch` clause variables\n\nThanks to work done by [@tinganho](https://github.com/tinganho), TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in `catch` clauses. For example, when using `JSON.parse` you may need to wrap calls to the function with a `try`/`catch`, but you may not end up using the `SyntaxError` that gets thrown when input is erroneous.\n\nts\n\n`let input = \"...\";`\n\n`try {`\n\n  `JSON.parse(input);`\n\n`} catch {`\n\n  ``// ^ Notice that our `catch` clause doesn't declare a variable.``\n\n  `console.log(\"Invalid JSON given\\n\\n\" + input);`\n\n`}`\n\n## [](#type-assertioncast-syntax-in-checkjsts-check-mode)Type assertion/cast syntax in `checkJs`/`@ts-check` mode\n\nTypeScript 2.5 introduces the ability to [assert the type of expressions when using plain JavaScript in your projects](https://github.com/Microsoft/TypeScript/issues/5158). The syntax is an `/** @type {...} */` annotation comment followed by a parenthesized expression whose type needs to be re-evaluated. For example:\n\nts\n\n`var x = /** @type {SomeType} */ AnyParenthesizedExpression;`\n\n## [](#deduplicated-and-redirected-packages)Deduplicated and redirected packages\n\nWhen importing using the `Node` module resolution strategy in TypeScript 2.5, the compiler will now check whether files originate from “identical” packages. If a file originates from a package with a `package.json` containing the same `name` and `version` fields as a previously encountered package, then TypeScript will redirect itself to the top-most package. This helps resolve problems where two packages might contain identical declarations of classes, but which contain `private` members that cause them to be structurally incompatible.\n\nAs a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading `.d.ts` files from duplicate packages.\n\n## [](#the---preservesymlinks-compiler-flag)The `--preserveSymlinks` compiler flag\n\nTypeScript 2.5 brings the [`preserveSymlinks`](https://www.typescriptlang.org/tsconfig#preserveSymlinks) flag, which parallels the behavior of [the `--preserve-symlinks` flag in Node.js](https://nodejs.org/api/cli.html#cli_preserve_symlinks). This flag also exhibits the opposite behavior to Webpack’s `resolve.symlinks` option (i.e. setting TypeScript’s [`preserveSymlinks`](https://www.typescriptlang.org/tsconfig#preserveSymlinks) to `true` parallels setting Webpack’s `resolve.symlinks` to `false`, and vice-versa).\n\nIn this mode, references to modules and packages (e.g. `import`s and `/// <reference type=\"...\" />` directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we’ll defer to [the documentation on the Node.js website](https://nodejs.org/api/cli.html#cli_preserve_symlinks).",
    "title": "TypeScript: Documentation - TypeScript 2.5",
    "description": "TypeScript 2.5 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.4\n\n## [](#dynamic-import-expressions)Dynamic Import Expressions\n\nDynamic `import` expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.\n\nThis means that you can conditionally and lazily import other modules and libraries. For example, here’s an `async` function that only imports a utility library when it’s needed:\n\nts\n\n`async function getZipFile(name: string, files: File[]): Promise<File> {`\n\n  `const zipUtil = await import(\"./utils/create-zip-file\");`\n\n  `const zipContents = await zipUtil.getContentAsBlob(files);`\n\n  `return new File(zipContents, name);`\n\n`}`\n\nMany bundlers have support for automatically splitting output bundles based on these `import` expressions, so consider using this new feature with the `esnext` module target.\n\n## [](#string-enums)String Enums\n\nTypeScript 2.4 now allows enum members to contain string initializers.\n\nts\n\n`enum Colors {`\n\n  `Red = \"RED\",`\n\n  `Green = \"GREEN\",`\n\n  `Blue = \"BLUE\"`\n\n`}`\n\nThe caveat is that string-initialized enums can’t be reverse-mapped to get the original enum member name. In other words, you can’t write `Colors[\"RED\"]` to get the string `\"Red\"`.\n\n## [](#improved-inference-for-generics)Improved inference for generics\n\nTypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.\n\n### [](#return-types-as-inference-targets)Return types as inference targets\n\nFor one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:\n\nts\n\n`function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[] {`\n\n  `return a => a.map(f);`\n\n`}`\n\n`const lengths: (a: string[]) => number[] = arrayMap(s => s.length);`\n\nAs an example of new errors you might spot as a result:\n\nts\n\n`let x: Promise<string> = new Promise(resolve => {`\n\n  `resolve(10);`\n\n  `//      ~~ Error!`\n\n`});`\n\n### [](#type-parameter-inference-from-contextual-types)Type parameter inference from contextual types\n\nPrior to TypeScript 2.4, in the following example\n\nts\n\n`let f: <T>(x: T) => T = y => y;`\n\n`y` would have the type `any`. This meant the program would type-check, but you could technically do anything with `y`, such as the following:\n\nts\n\n`let f: <T>(x: T) => T = y => y() + y.foo.bar;`\n\nThat last example isn’t actually type-safe.\n\nIn TypeScript 2.4, the function on the right side implicitly _gains_ type parameters, and `y` is inferred to have the type of that type-parameter.\n\nIf you use `y` in a way that the type parameter’s constraint doesn’t support, you’ll correctly get an error. In this case, the constraint of `T` was (implicitly) `{}`, so the last example will appropriately fail.\n\n### [](#stricter-checking-for-generic-functions)Stricter checking for generic functions\n\nTypeScript now tries to unify type parameters when comparing two single-signature types. As a result, you’ll get stricter checks when relating two generic signatures, and may catch some bugs.\n\nts\n\n`type A = <T, U>(x: T, y: U) => [T, U];`\n\n`type B = <S>(x: S, y: S) => [S, S];`\n\n`function f(a: A, b: B) {`\n\n  `a = b; // Error`\n\n  `b = a; // Ok`\n\n`}`\n\n## [](#strict-contravariance-for-callback-parameters)Strict contravariance for callback parameters\n\nTypeScript has always compared parameters in a bivariant way. There are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with `Promise`s and `Observable`s.\n\nTypeScript 2.4 introduces tightens this up when relating two callback types. For example:\n\nts\n\n`interface Mappable<T> {`\n\n  `map<U>(f: (x: T) => U): Mappable<U>;`\n\n`}`\n\n`declare let a: Mappable<number>;`\n\n`declare let b: Mappable<string | number>;`\n\n`a = b;`\n\n`b = a;`\n\nPrior to TypeScript 2.4, this example would succeed. When relating the types of `map`, TypeScript would bidirectionally relate their parameters (i.e. the type of `f`). When relating each `f`, TypeScript would also bidirectionally relate the type of _those_ parameters.\n\nWhen relating the type of `map` in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.\n\nIn other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.\n\n## [](#weak-type-detection)Weak Type Detection\n\nTypeScript 2.4 introduces the concept of “weak types”. Any type that contains nothing but a set of all-optional properties is considered to be _weak_. For example, this `Options` type is a weak type:\n\nts\n\n`interface Options {`\n\n  `data?: string;`\n\n  `timeout?: number;`\n\n  `maxRetries?: number;`\n\n`}`\n\nIn TypeScript 2.4, it’s now an error to assign anything to a weak type when there’s no overlap in properties. For example:\n\nts\n\n`function sendMessage(options: Options) {`\n\n  `// ...`\n\n`}`\n\n`const opts = {`\n\n  `payload: \"hello world!\",`\n\n  `retryOnFail: true`\n\n`};`\n\n`// Error!`\n\n`sendMessage(opts);`\n\n`// No overlap between the type of 'opts' and 'Options' itself.`\n\n`// Maybe we meant to use 'data'/'maxRetries' instead of 'payload'/'retryOnFail'.`\n\nYou can think of this as TypeScript “toughening up” the weak guarantees of these types to catch what would otherwise be silent bugs.\n\nSince this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:\n\n1.  Declare the properties if they really do exist.\n2.  Add an index signature to the weak type (i.e. `[propName: string]: {}`).\n3.  Use a type assertion (i.e. `opts as Options`).",
    "title": "TypeScript: Documentation - TypeScript 2.4",
    "description": "TypeScript 2.4 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.3\n\n## [](#generators-and-iteration-for-es5es3)Generators and Iteration for ES5/ES3\n\n_First some ES2016 terminology:_\n\n##### [](#iterators)Iterators\n\n[ES2015 introduced `Iterator`](http://www.ecma-international.org/ecma-262/6.0/#sec-iteration), which is an object that exposes three methods, `next`, `return`, and `throw`, as per the following interface:\n\nts\n\n`interface Iterator<T> {`\n\n  `next(value?: any): IteratorResult<T>;`\n\n  `return?(value?: any): IteratorResult<T>;`\n\n  `throw?(e?: any): IteratorResult<T>;`\n\n`}`\n\nThis kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be “iterable” if it has a `Symbol.iterator` method that returns an `Iterator` object.\n\nThe Iterator protocol also defines the target of some of the ES2015 features like `for..of` and spread operator and the array rest in destructuring assignments.\n\n##### [](#generators)Generators\n\n[ES2015 also introduced “Generators”](http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects), which are functions that can be used to yield partial computation results via the `Iterator` interface and the `yield` keyword. Generators can also internally delegate calls to another iterable through `yield *`. For example:\n\nts\n\n`function* f() {`\n\n  `yield 1;`\n\n  `yield* [2, 3];`\n\n`}`\n\n##### [](#new---downleveliteration)New `--downlevelIteration`\n\nPreviously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. `for..of` were only supported if they operate on arrays for targets below ES6/ES2015.\n\nTypeScript 2.3 adds full support for generators and the Iterator protocol for ES3 and ES5 targets with [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration) flag.\n\nWith [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration), the compiler uses new type check and emit behavior that attempts to call a `[Symbol.iterator]()` method on the iterated object if it is found, and creates a synthetic array iterator over the object if it is not.\n\n> Please note that this requires a native `Symbol.iterator` or `Symbol.iterator` shim at runtime for any non-array values.\n\n`for..of` statements, Array Destructuring, and Spread elements in Array, Call, and New expressions support `Symbol.iterator` in ES5/E3 if available when using [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration), but can be used on an Array even if it does not define `Symbol.iterator` at run time or design time.\n\n## [](#async-iteration)Async Iteration\n\nTypeScript 2.3 adds support for the async iterators and generators as described by the current [TC39 proposal](https://github.com/tc39/proposal-async-iteration).\n\n##### [](#async-iterators)Async iterators\n\nThe Async Iteration introduces an `AsyncIterator`, which is similar to `Iterator`. The difference lies in the fact that the `next`, `return`, and `throw` methods of an `AsyncIterator` return a `Promise` for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the `AsyncIterator` has advanced to the point of yielding a value. An `AsyncIterator` has the following shape:\n\nts\n\n`interface AsyncIterator<T> {`\n\n  `next(value?: any): Promise<IteratorResult<T>>;`\n\n  `return?(value?: any): Promise<IteratorResult<T>>;`\n\n  `throw?(e?: any): Promise<IteratorResult<T>>;`\n\n`}`\n\nAn object that supports async iteration is said to be “iterable” if it has a `Symbol.asyncIterator` method that returns an `AsyncIterator` object.\n\n##### [](#async-generators)Async Generators\n\nThe [Async Iteration proposal](https://github.com/tc39/proposal-async-iteration) introduces “Async Generators”, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via `yield*` to either an iterable or async iterable:\n\nts\n\n`async function* g() {`\n\n  `yield 1;`\n\n  `await sleep(100);`\n\n  `yield* [2, 3];`\n\n  `yield* (async function*() {`\n\n    `await sleep(100);`\n\n    `yield 4;`\n\n  `})();`\n\n`}`\n\nAs with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global `Promise` implementation (either native or an ES2015-compatible polyfill), in addition to a valid `Symbol.asyncIterator` reference (either a native symbol or a shim).\n\n##### [](#the-for-await-of-statement)The `for-await-of` Statement\n\nFinally, ES2015 introduced the `for..of` statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the `for..await..of` statement to iterate over an async iterable:\n\nts\n\n`async function f() {`\n\n  `for await (const x of g()) {`\n\n    `console.log(x);`\n\n  `}`\n\n`}`\n\nThe `for..await..of` statement is only legal within an Async Function or Async Generator.\n\n##### [](#caveats)Caveats\n\n*   Keep in mind that our support for async iterators relies on support for `Symbol.asyncIterator` to exist at runtime. You may need to polyfill `Symbol.asyncIterator`, which for simple purposes can be as simple as: `(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(\"Symbol.asyncIterator\");`\n*   You also need to include `esnext` in your [`lib`](https://www.typescriptlang.org/tsconfig#lib) option, to get the `AsyncIterator` declaration if you do not already have it.\n*   Finally, if your target is ES5 or ES3, you’ll also need to set the `--downlevelIterators` flag.\n\n## [](#generic-parameter-defaults)Generic parameter defaults\n\nTypeScript 2.3 adds support for declaring defaults for generic type parameters.\n\n##### [](#example)Example\n\nConsider a function that creates a new `HTMLElement`, calling it with no arguments generates a `Div`; you can optionally pass a list of children as well. Previously you would have to define it as:\n\nts\n\n`declare function create(): Container<HTMLDivElement, HTMLDivElement[]>;`\n\n`declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;`\n\n`declare function create<T extends HTMLElement, U extends HTMLElement>(`\n\n  `element: T,`\n\n  `children: U[]`\n\n`): Container<T, U[]>;`\n\nWith generic parameter defaults we can reduce it to:\n\nts\n\n`declare function create<T extends HTMLElement = HTMLDivElement, U = T[]>(`\n\n  `element?: T,`\n\n  `children?: U`\n\n`): Container<T, U>;`\n\nA generic parameter default follows the following rules:\n\n*   A type parameter is deemed optional if it has a default.\n*   Required type parameters must not follow optional type parameters.\n*   Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.\n*   When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.\n*   If a default type is specified and inference cannot choose a candidate, the default type is inferred.\n*   A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.\n*   A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.\n\n## [](#new---strict-master-option)New `--strict` master option\n\nNew checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the [`strict`](https://www.typescriptlang.org/tsconfig#strict) option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.\n\nThe new [`strict`](https://www.typescriptlang.org/tsconfig#strict) compiler option represents the recommended setting of a number of type checking options. Specifically, specifying [`strict`](https://www.typescriptlang.org/tsconfig#strict) corresponds to specifying all of the following options (and may in the future include more options):\n\n*   [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n*   [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n*   [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis)\n*   [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict)\n\nIn exact terms, the [`strict`](https://www.typescriptlang.org/tsconfig#strict) option sets the _default_ value for the compiler options listed above. This means it is still possible to individually control the options. For example,\n\nsh\n\n`--strict --noImplicitThis false`\n\nhas the effect of turning on all strict options _except_ the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis) option. Using this scheme it is possible to express configurations consisting of _all_ strict options except some explicitly listed options. In other words, it is now possible to default to the highest level of type safety but opt out of certain checks.\n\nStarting with TypeScript 2.3, the default `tsconfig.json` generated by `tsc --init` includes a `\"strict\": true` setting in the `\"compilerOptions\"` section. Thus, new projects started with `tsc --init` will by default have the highest level of type safety enabled.\n\n## [](#enhanced---init-output)Enhanced `--init` output\n\nAlong with setting [`strict`](https://www.typescriptlang.org/tsconfig#strict) on by default, `tsc --init` has an enhanced output. Default `tsconfig.json` files generated by `tsc --init` now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.\n\n## [](#errors-in-js-files-with---checkjs)Errors in .js files with `--checkJs`\n\nBy default the TypeScript compiler does not report any errors in .js files including using [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs). With TypeScript 2.3 type-checking errors can also be reported in `.js` files with [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs).\n\nYou can skip checking some files by adding `// @ts-nocheck` comment to them; conversely you can choose to check only a few `.js` files by adding `// @ts-check` comment to them without setting [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs). You can also ignore errors on specific lines by adding `// @ts-ignore` on the preceding line.\n\n`.js` files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in `.ts` files and are flagged as errors in `.js` files. JSDoc comments can be used to add some type information to your JavaScript code, see [JSDoc Support documentation](https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript) for more details about the supported JSDoc constructs.\n\nSee [Type checking JavaScript Files documentation](https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files) for more details.",
    "title": "TypeScript: Documentation - TypeScript 2.3",
    "description": "TypeScript 2.3 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.2\n\n## [](#support-for-mix-in-classes)Support for Mix-in classes\n\nTypeScript 2.2 adds support for the ECMAScript 2015 mixin class pattern (see [MDN Mixin description](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Classes#Mix-ins) and [“Real” Mixins with JavaScript Classes](http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/) for more details) as well as rules for combining mixin construct signatures with regular construct signatures in intersection types.\n\n##### [](#first-some-terminology)First some terminology\n\nA **mixin constructor type** refers to a type that has a single construct signature with a single rest argument of type `any[]` and an object-like return type. For example, given an object-like type `X`, `new (...args: any[]) => X` is a mixin constructor type with an instance type `X`.\n\nA **mixin class** is a class declaration or expression that `extends` an expression of a type parameter type. The following rules apply to mixin class declarations:\n\n*   The type parameter type of the `extends` expression must be constrained to a mixin constructor type.\n*   The constructor of a mixin class (if any) must have a single rest parameter of type `any[]` and must use the spread operator to pass those parameters as arguments in a `super(...args)` call.\n\nGiven an expression `Base` of a parametric type `T` with a constraint `X`, a mixin class `class C extends Base {...}` is processed as if `Base` had type `X` and the resulting type is the intersection `typeof C & T`. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.\n\nWhen obtaining the construct signatures of an intersection type that contains mixin constructor types, the mixin construct signatures are discarded and their instance types are mixed into the return types of the other construct signatures in the intersection type. For example, the intersection type `{ new(...args: any[]) => A } & { new(s: string) => B }` has a single construct signature `new(s: string) => A & B`.\n\n##### [](#putting-all-of-the-above-rules-together-in-an-example)Putting all of the above rules together in an example\n\nts\n\n`class Point {`\n\n  `constructor(public x: number, public y: number) {}`\n\n`}`\n\n`class Person {`\n\n  `constructor(public name: string) {}`\n\n`}`\n\n`type Constructor<T> = new (...args: any[]) => T;`\n\n`function Tagged<T extends Constructor<{}>>(Base: T) {`\n\n  `return class extends Base {`\n\n    `_tag: string;`\n\n    `constructor(...args: any[]) {`\n\n      `super(...args);`\n\n      `this._tag = \"\";`\n\n    `}`\n\n  `};`\n\n`}`\n\n`const TaggedPoint = Tagged(Point);`\n\n`let point = new TaggedPoint(10, 20);`\n\n`point._tag = \"hello\";`\n\n`class Customer extends Tagged(Person) {`\n\n  `accountBalance: number;`\n\n`}`\n\n`let customer = new Customer(\"Joe\");`\n\n`customer._tag = \"test\";`\n\n`customer.accountBalance = 0;`\n\nMixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following `WithLocation` function implements a subclass factory that adds a `getLocation` method to any class that satisfies the `Point` interface (i.e. that has `x` and `y` properties of type `number`).\n\nts\n\n`interface Point {`\n\n  `x: number;`\n\n  `y: number;`\n\n`}`\n\n`const WithLocation = <T extends Constructor<Point>>(Base: T) =>`\n\n  `class extends Base {`\n\n    `getLocation(): [number, number] {`\n\n      `return [this.x, this.y];`\n\n    `}`\n\n  `};`\n\n## [](#object-type)`object` type\n\nTypeScript did not have a type that represents the non-primitive type, i.e. any thing that is not `number`, `string`, `boolean`, `symbol`, `null`, or `undefined`. Enter the new `object` type.\n\nWith `object` type, APIs like `Object.create` can be better represented. For example:\n\nts\n\n`declare function create(o: object | null): void;`\n\n`create({ prop: 0 }); // OK`\n\n`create(null); // OK`\n\n`create(42); // Error`\n\n`create(\"string\"); // Error`\n\n`create(false); // Error`\n\n`create(undefined); // Error`\n\n## [](#support-for-newtarget)Support for `new.target`\n\nThe `new.target` meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via `new`, the value of `new.target` is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via `new`, `new.target` is set to `undefined`.\n\n`new.target` comes in handy when `Object.setPrototypeOf` or `__proto__` needs to be set in a class constructor. One such use case is inheriting from `Error` in NodeJS v4 and higher.\n\n##### [](#example)Example\n\nts\n\n`class CustomError extends Error {`\n\n  `constructor(message?: string) {`\n\n    `super(message); // 'Error' breaks prototype chain here`\n\n    `Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain`\n\n  `}`\n\n`}`\n\nThis results in the generated JS\n\njs\n\n`var CustomError = (function(_super) {`\n\n  `__extends(CustomError, _super);`\n\n  `function CustomError() {`\n\n    `var _newTarget = this.constructor;`\n\n    `var _this = _super.apply(this, arguments); // 'Error' breaks prototype chain here`\n\n    `_this.__proto__ = _newTarget.prototype; // restore prototype chain`\n\n    `return _this;`\n\n  `}`\n\n  `return CustomError;`\n\n`})(Error);`\n\n`new.target` also comes in handy for writing constructable functions, for example:\n\nts\n\n`function f() {`\n\n  `if (new.target) {`\n\n    `/* called via 'new' */`\n\n  `}`\n\n`}`\n\nWhich translates to:\n\njs\n\n`function f() {`\n\n  `var _newTarget = this && this instanceof f ? this.constructor : void 0;`\n\n  `if (_newTarget) {`\n\n    `/* called via 'new' */`\n\n  `}`\n\n`}`\n\n## [](#better-checking-for-nullundefined-in-operands-of-expressions)Better checking for `null`/`undefined` in operands of expressions\n\nTypeScript 2.2 improves checking of nullable operands in expressions. Specifically, these are now flagged as errors:\n\n*   If either operand of a `+` operator is nullable, and neither operand is of type `any` or `string`.\n*   If either operand of a `-`, `*`, `**`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, or `^` operator is nullable.\n*   If either operand of a `<`, `>`, `<=`, `>=`, or `in` operator is nullable.\n*   If the right operand of an `instanceof` operator is nullable.\n*   If the operand of a `+`, `-`, `~`, `++`, or `--` unary operator is nullable.\n\nAn operand is considered nullable if the type of the operand is `null` or `undefined` or a union type that includes `null` or `undefined`. Note that the union type case only only occurs in [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) mode because `null` and `undefined` disappear from unions in classic type checking mode.\n\n## [](#dotted-property-for-types-with-string-index-signatures)Dotted property for types with string index signatures\n\nTypes with a string index signature can be indexed using the `[]` notation, but were not allowed to use the `.`. Starting with TypeScript 2.2 using either should be allowed.\n\nts\n\n`interface StringMap<T> {`\n\n  `[x: string]: T;`\n\n`}`\n\n`const map: StringMap<number>;`\n\n`map[\"prop1\"] = 1;`\n\n`map.prop2 = 2;`\n\nThis only apply to types with an _explicit_ string index signature. It is still an error to access unknown properties on a type using `.` notation.\n\n## [](#support-for-spread-operator-on-jsx-element-children)Support for spread operator on JSX element children\n\nTypeScript 2.2 adds support for using spread on a JSX element children. Please see [facebook/jsx#57](https://github.com/facebook/jsx/issues/57) for more details.\n\n##### [](#example-1)Example\n\nts\n\n`function Todo(prop: { key: number; todo: string }) {`\n\n  `return <div>{prop.key.toString() + prop.todo}</div>;`\n\n`}`\n\n`function TodoList({ todos }: TodoListProps) {`\n\n  `return (`\n\n    `<div>{...todos.map(todo => <Todo key={todo.id} todo={todo.todo} />)}</div>`\n\n  `);`\n\n`}`\n\n`let x: TodoListProps;`\n\n`<TodoList {...x} />;`\n\n## [](#new-jsx-react-native)New `jsx: react-native`\n\nReact-native build pipeline expects all files to have a `.js` extensions even if the file contains JSX syntax. The new [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) value `react-native` will persevere the JSX syntax in the output file, but give it a `.js` extension.",
    "title": "TypeScript: Documentation - TypeScript 2.2",
    "description": "TypeScript 2.2 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.1\n\n## [](#keyof-and-lookup-types)`keyof` and Lookup Types\n\nIn JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn’t been possible to express the type relationships that occur in those APIs.\n\nEnter Index Type Query or `keyof`; An indexed type query `keyof T` yields the type of permitted property names for `T`. A `keyof T` type is considered a subtype of `string`.\n\n##### [](#example)Example\n\nts\n\n`interface Person {`\n\n  `name: string;`\n\n  `age: number;`\n\n  `location: string;`\n\n`}`\n\n`type K1 = keyof Person; // \"name\" | \"age\" | \"location\"`\n\n`type K2 = keyof Person[]; // \"length\" | \"push\" | \"pop\" | \"concat\" | ...`\n\n`type K3 = keyof { [x: string]: Person }; // string`\n\nThe dual of this is _indexed access types_, also called _lookup types_. Syntactically, they look exactly like an element access, but are written as types:\n\n##### [](#example-1)Example\n\nts\n\n`type P1 = Person[\"name\"]; // string`\n\n`type P2 = Person[\"name\" | \"age\"]; // string | number`\n\n`type P3 = string[\"charAt\"]; // (pos: number) => string`\n\n`type P4 = string[][\"push\"]; // (...items: string[]) => number`\n\n`type P5 = string[][0]; // string`\n\nYou can use this pattern with other parts of the type system to get type-safe lookups.\n\nts\n\n`function getProperty<T, K extends keyof T>(obj: T, key: K) {`\n\n  `return obj[key]; // Inferred type is T[K]`\n\n`}`\n\n`function setProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]) {`\n\n  `obj[key] = value;`\n\n`}`\n\n`let x = { foo: 10, bar: \"hello!\" };`\n\n`let foo = getProperty(x, \"foo\"); // number`\n\n`let bar = getProperty(x, \"bar\"); // string`\n\n`let oops = getProperty(x, \"wargarbl\"); // Error! \"wargarbl\" is not \"foo\" | \"bar\"`\n\n`setProperty(x, \"foo\", \"string\"); // Error!, string expected number`\n\n## [](#mapped-types)Mapped Types\n\nOne common task is to take an existing type and make each of its properties entirely optional. Let’s say we have a `Person`:\n\nts\n\n`interface Person {`\n\n  `name: string;`\n\n  `age: number;`\n\n  `location: string;`\n\n`}`\n\nA partial version of it would be:\n\nts\n\n`interface PartialPerson {`\n\n  `name?: string;`\n\n  `age?: number;`\n\n  `location?: string;`\n\n`}`\n\nwith Mapped types, `PartialPerson` can be written as a generalized transformation on the type `Person` as:\n\nts\n\n`type Partial<T> = {`\n\n  `[P in keyof T]?: T[P];`\n\n`};`\n\n`type PartialPerson = Partial<Person>;`\n\nMapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They’re like [list comprehensions in Python](https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions), but instead of producing new elements in a list, they produce new properties in a type.\n\nIn addition to `Partial`, Mapped Types can express many useful transformations on types:\n\nts\n\n`// Keep types the same, but make each property to be read-only.`\n\n`type Readonly<T> = {`\n\n  `readonly [P in keyof T]: T[P];`\n\n`};`\n\n`// Same property names, but make the value a promise instead of a concrete one`\n\n`type Deferred<T> = {`\n\n  `[P in keyof T]: Promise<T[P]>;`\n\n`};`\n\n`// Wrap proxies around properties of T`\n\n`type Proxify<T> = {`\n\n  `[P in keyof T]: { get(): T[P]; set(v: T[P]): void };`\n\n`};`\n\n## [](#partial-readonly-record-and-pick)`Partial`, `Readonly`, `Record`, and `Pick`\n\n`Partial` and `Readonly`, as described earlier, are very useful constructs. You can use them to describe some common JS routines like:\n\nts\n\n`function assign<T>(obj: T, props: Partial<T>): void;`\n\n`function freeze<T>(obj: T): Readonly<T>;`\n\nBecause of that, they are now included by default in the standard library.\n\nWe’re also including two other utility types as well: `Record` and `Pick`.\n\nts\n\n`// From T pick a set of properties K`\n\n`declare function pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K>;`\n\n`const nameAndAgeOnly = pick(person, \"name\", \"age\"); // { name: string, age: number }`\n\nts\n\n`// For every properties K of type T, transform it to U`\n\n`function mapObject<K extends string, T, U>(`\n\n  `obj: Record<K, T>,`\n\n  `f: (x: T) => U`\n\n`): Record<K, U>;`\n\n`const names = { foo: \"hello\", bar: \"world\", baz: \"bye\" };`\n\n`const lengths = mapObject(names, s => s.length); // { foo: number, bar: number, baz: number }`\n\n## [](#object-spread-and-rest)Object Spread and Rest\n\nTypeScript 2.1 brings support for [ESnext Spread and Rest](https://github.com/sebmarkbage/ecmascript-rest-spread).\n\nSimilar to array spread, spreading an object can be handy to get a shallow copy:\n\nts\n\n`let copy = { ...original };`\n\nSimilarly, you can merge several different objects. In the following example, `merged` will have properties from `foo`, `bar`, and `baz`.\n\nts\n\n`let merged = { ...foo, ...bar, ...baz };`\n\nYou can also override existing properties and add new ones:\n\nts\n\n`let obj = { x: 1, y: \"string\" };`\n\n`var newObj = { ...obj, z: 3, y: 4 }; // { x: number, y: number, z: number }`\n\nThe order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads “win out” over previously created properties.\n\nObject rests are the dual of object spreads, in that they can extract any extra properties that don’t get picked up when destructuring an element:\n\nts\n\n`let obj = { x: 1, y: 1, z: 1 };`\n\n`let { z, ...obj1 } = obj;`\n\n`obj1; // {x: number, y:number};`\n\n## [](#downlevel-async-functions)Downlevel Async Functions\n\nThis feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you’ll be free to take advantage of it no matter what environment you’re using.\n\n> Note: first, we need to make sure our run-time has an ECMAScript-compliant `Promise` available globally. That might involve grabbing [a polyfill](https://github.com/stefanpenner/es6-promise) for `Promise`, or relying on one that you might have in the run-time that you’re targeting. We also need to make sure that TypeScript knows `Promise` exists by setting your [`lib`](https://www.typescriptlang.org/tsconfig#lib) option to something like `\"dom\", \"es2015\"` or `\"dom\", \"es2015.promise\", \"es5\"`\n\n##### [](#example-2)Example\n\n##### [](#tsconfigjson)tsconfig.json\n\n`{`\n\n  `\"\": {`\n\n    `\"\": [\"dom\", \"es2015.promise\", \"es5\"]`\n\n  `}`\n\n`}`\n\n##### [](#dramaticwelcomets)dramaticWelcome.ts\n\nts\n\n`function delay(milliseconds: number) {`\n\n  `return new Promise<void>(resolve => {`\n\n    `setTimeout(resolve, milliseconds);`\n\n  `});`\n\n`}`\n\n`async function dramaticWelcome() {`\n\n  `console.log(\"Hello\");`\n\n  `for (let i = 0; i < 3; i++) {`\n\n    `await delay(500);`\n\n    `console.log(\".\");`\n\n  `}`\n\n  `console.log(\"World!\");`\n\n`}`\n\n`dramaticWelcome();`\n\nCompiling and running the output should result in the correct behavior on an ES3/ES5 engine.\n\n## [](#support-for-external-helpers-library-tslib)Support for external helpers library (`tslib`)\n\nTypeScript injects a handful of helper functions such as `__extends` for inheritance, `__assign` for spread operator in object literals and JSX elements, and `__awaiter` for async functions.\n\nPreviously there were two options:\n\n1.  inject helpers in _every_ file that needs them, or\n2.  no helpers at all with [`noEmitHelpers`](https://www.typescriptlang.org/tsconfig#noEmitHelpers).\n\nThe two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.\n\nTypeScript 2.1 allows for including these files in your project once in a separate module, and the compiler will emit imports to them as needed.\n\nFirst, install the [`tslib`](https://github.com/Microsoft/tslib) utility library:\n\nsh\n\n`npm install tslib`\n\nSecond, compile your files using [`importHelpers`](https://www.typescriptlang.org/tsconfig#importHelpers):\n\nsh\n\n`tsc --module commonjs --importHelpers a.ts`\n\nSo given the following input, the resulting `.js` file will include an import to `tslib` and use the `__assign` helper from it instead of inlining it.\n\nts\n\n`export const o = { a: 1, name: \"o\" };`\n\n`export const copy = { ...o };`\n\njs\n\n`\"use strict\";`\n\n`var tslib_1 = require(\"tslib\");`\n\n`exports.o = { a: 1, name: \"o\" };`\n\n`exports.copy = tslib_1.__assign({}, exports.o);`\n\n## [](#untyped-imports)Untyped imports\n\nTypeScript has traditionally been overly strict about how you can import modules. This was to avoid typos and prevent users from using modules incorrectly.\n\nHowever, a lot of the time, you might just want to import an existing module that may not have its own `.d.ts` file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.\n\nWith TypeScript 2.1, you can import a JavaScript module without needing a type declaration. A type declaration (such as `declare module \"foo\" { ... }` or `node_modules/@types/foo`) still takes priority if it exists.\n\nAn import to a module with no declaration file will still be flagged as an error under [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny).\n\n##### [](#example-3)Example\n\nts\n\n``// Succeeds if `node_modules/asdf/index.js` exists``\n\n`import { x } from \"asdf\";`\n\n## [](#support-for---target-es2016---target-es2017-and---target-esnext)Support for `--target ES2016`, `--target ES2017` and `--target ESNext`\n\nTypeScript 2.1 supports three new target values `--target ES2016`, `--target ES2017` and `--target ESNext`.\n\nUsing target `--target ES2016` will instruct the compiler not to transform ES2016-specific features, e.g. `**` operator.\n\nSimilarly, `--target ES2017` will instruct the compiler not to transform ES2017-specific features like `async`/`await`.\n\n`--target ESNext` targets latest supported [ES proposed features](https://github.com/tc39/proposals).\n\n## [](#improved-any-inference)Improved `any` Inference\n\nPreviously, if TypeScript couldn’t figure out the type of a variable, it would choose the `any` type.\n\nts\n\n`let x; // implicitly 'any'`\n\n`let y = []; // implicitly 'any[]'`\n\n`let z: any; // explicitly 'any'.`\n\nWith TypeScript 2.1, instead of just choosing `any`, TypeScript will infer types based on what you end up assigning later on.\n\nThis is only enabled if [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) is set.\n\n##### [](#example-4)Example\n\nts\n\n`let x;`\n\n`// You can still assign anything you want to 'x'.`\n\n`x = () => 42;`\n\n`// After that last assignment, TypeScript 2.1 knows that 'x' has type '() => number'.`\n\n`let y = x();`\n\n`// Thanks to that, it will now tell you that you can't add a number to a function!`\n\n`console.log(x + y);`\n\n`//          ~~~~~`\n\n`// Error! Operator '+' cannot be applied to types '() => number' and 'number'.`\n\n`// TypeScript still allows you to assign anything you want to 'x'.`\n\n`x = \"Hello world!\";`\n\n`// But now it also knows that 'x' is a 'string'!`\n\n`x.toLowerCase();`\n\nThe same sort of tracking is now also done for empty arrays.\n\nA variable declared with no type annotation and an initial value of `[]` is considered an implicit `any[]` variable. However, each subsequent `x.push(value)`, `x.unshift(value)` or `x[n] = value` operation _evolves_ the type of the variable in accordance with what elements are added to it.\n\nts\n\n`function f1() {`\n\n  `let x = [];`\n\n  `x.push(5);`\n\n  `x[1] = \"hello\";`\n\n  `x.unshift(true);`\n\n  `return x; // (string | number | boolean)[]`\n\n`}`\n\n`function f2() {`\n\n  `let x = null;`\n\n  `if (cond()) {`\n\n    `x = [];`\n\n    `while (cond()) {`\n\n      `x.push(\"hello\");`\n\n    `}`\n\n  `}`\n\n  `return x; // string[] | null`\n\n`}`\n\n## [](#implicit-any-errors)Implicit any errors\n\nOne great benefit of this is that you’ll see _way fewer_ implicit `any` errors when running with [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny). Implicit `any` errors are only reported when the compiler is unable to know the type of a variable without a type annotation.\n\n##### [](#example-5)Example\n\nts\n\n`function f3() {`\n\n  `let x = []; // Error: Variable 'x' implicitly has type 'any[]' in some locations where its type cannot be determined.`\n\n  `x.push(5);`\n\n  `function g() {`\n\n    `x; // Error: Variable 'x' implicitly has an 'any[]' type.`\n\n  `}`\n\n`}`\n\n## [](#better-inference-for-literal-types)Better inference for literal types\n\nString, numeric and boolean literal types (e.g. `\"abc\"`, `1`, and `true`) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are _always_ inferred for `const` variables and `readonly` properties.\n\nThe type inferred for a `const` variable or `readonly` property without a type annotation is the type of the literal initializer. The type inferred for a `let` variable, `var` variable, parameter, or non-`readonly` property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is `string`, `number` for numeric literal types, `boolean` for `true` or `false` and the containing enum for enum literal types.\n\n##### [](#example-6)Example\n\nts\n\n`const c1 = 1; // Type 1`\n\n`const c2 = c1; // Type 1`\n\n`const c3 = \"abc\"; // Type \"abc\"`\n\n`const c4 = true; // Type true`\n\n`const c5 = cond ? 1 : \"abc\"; // Type 1 | \"abc\"`\n\n`let v1 = 1; // Type number`\n\n`let v2 = c2; // Type number`\n\n`let v3 = c3; // Type string`\n\n`let v4 = c4; // Type boolean`\n\n`let v5 = c5; // Type number | string`\n\nLiteral type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that `const` variable gets a widening literal type inferred. But when a `const` location has an explicit literal type annotation, the `const` variable gets a non-widening literal type.\n\n##### [](#example-7)Example\n\nts\n\n`const c1 = \"hello\"; // Widening type \"hello\"`\n\n`let v1 = c1; // Type string`\n\n`const c2: \"hello\" = \"hello\"; // Type \"hello\"`\n\n`let v2 = c2; // Type \"hello\"`\n\n## [](#use-returned-values-from-super-calls-as-this)Use returned values from super calls as ‘this’\n\nIn ES2015, constructors which return an object implicitly substitute the value of `this` for any callers of `super()`. As a result, it is necessary to capture any potential return value of `super()` and replace it with `this`. This change enables working with [Custom Elements](https://www.w3.org/TR/custom-elements/), which takes advantage of this to initialize browser-allocated elements with user-written constructors.\n\n##### [](#example-8)Example\n\nts\n\n`class Base {`\n\n  `x: number;`\n\n  `constructor() {`\n\n    `` // return a new object other than `this` ``\n\n    `return {`\n\n      `x: 1`\n\n    `};`\n\n  `}`\n\n`}`\n\n`class Derived extends Base {`\n\n  `constructor() {`\n\n    `super();`\n\n    `this.x = 2;`\n\n  `}`\n\n`}`\n\nGenerates:\n\njs\n\n`var Derived = (function(_super) {`\n\n  `__extends(Derived, _super);`\n\n  `function Derived() {`\n\n    `var _this = _super.call(this) || this;`\n\n    `_this.x = 2;`\n\n    `return _this;`\n\n  `}`\n\n  `return Derived;`\n\n`})(Base);`\n\n> This change entails a break in the behavior of extending built-in classes like `Error`, `Array`, `Map`, etc.. Please see the [extending built-ins breaking change documentation](https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work) for more details.\n\n## [](#configuration-inheritance)Configuration inheritance\n\nOften a project has multiple output targets, e.g. `ES5` and `ES2015`, debug and production or `CommonJS` and `System`; Just a few configuration options change between these two targets, and maintaining multiple `tsconfig.json` files can be a hassle.\n\nTypeScript 2.1 supports inheriting configuration using `extends`, where:\n\n*   `extends` is a new top-level property in `tsconfig.json` (alongside `compilerOptions`, [`files`](https://www.typescriptlang.org/tsconfig#files), [`include`](https://www.typescriptlang.org/tsconfig#include), and [`exclude`](https://www.typescriptlang.org/tsconfig#exclude)).\n*   The value of `extends` must be a string containing a path to another configuration file to inherit from.\n*   The configuration from the base file are loaded first, then overridden by those in the inheriting config file.\n*   Circularity between configuration files is not allowed.\n*   [`files`](https://www.typescriptlang.org/tsconfig#files), [`include`](https://www.typescriptlang.org/tsconfig#include), and [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) from the inheriting config file _overwrite_ those from the base config file.\n*   All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.\n\n##### [](#example-9)Example\n\n`configs/base.json`:\n\n`{`\n\n  `\"\": {`\n\n    `\"\": true,`\n\n    `\"\": true`\n\n  `}`\n\n`}`\n\n`tsconfig.json`:\n\n`{`\n\n  `\"\": \"./configs/base\",`\n\n  `\"\": [\"main.ts\", \"supplemental.ts\"]`\n\n`}`\n\n`tsconfig.nostrictnull.json`:\n\n`{`\n\n  `\"\": \"./tsconfig\",`\n\n  `\"\": {`\n\n    `\"\": false`\n\n  `}`\n\n`}`\n\n## [](#new---alwaysstrict)New `--alwaysStrict`\n\nInvoking the compiler with [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict) causes:\n\n1.  Parses all the code in strict mode.\n2.  Writes `\"use strict\";` directive atop every generated file.\n\nModules are parsed automatically in strict mode. The new flag is recommended for non-module code.",
    "title": "TypeScript: Documentation - TypeScript 2.1",
    "description": "TypeScript 2.1 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-7.html",
    "markdown": "# TypeScript: Documentation - TypeScript 1.7\n\n## [](#asyncawait-support-in-es6-targets-node-v4)`async`/`await` support in ES6 targets (Node v4+)\n\nTypeScript now supports asynchronous functions for engines that have native support for ES6 generators, e.g. Node v4 and above. Asynchronous functions are prefixed with the `async` keyword; `await` suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the `Promise` returned.\n\n##### [](#example)Example\n\nIn the following example, each input element will be printed out one at a time with a 400ms delay:\n\nts\n\n`\"use strict\";`\n\n`// printDelayed is a 'Promise<void>'`\n\n`async function printDelayed(elements: string[]) {`\n\n  `for (const element of elements) {`\n\n    `await delay(400);`\n\n    `console.log(element);`\n\n  `}`\n\n`}`\n\n`async function delay(milliseconds: number) {`\n\n  `return new Promise<void>((resolve) => {`\n\n    `setTimeout(resolve, milliseconds);`\n\n  `});`\n\n`}`\n\n`printDelayed([\"Hello\", \"beautiful\", \"asynchronous\", \"world\"]).then(() => {`\n\n  `console.log();`\n\n  `console.log(\"Printed every element!\");`\n\n`});`\n\nFor more information see [async function reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function) reference.\n\n## [](#support-for---target-es6-with---module)Support for `--target ES6` with `--module`\n\nTypeScript 1.7 adds `ES6` to the list of options available for the [`module`](https://www.typescriptlang.org/tsconfig#module) option and allows you to specify the module output when targeting `ES6`. This provides more flexibility to target exactly the features you want in specific runtimes.\n\n##### [](#example-1)Example\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"amd\",`\n\n    `\"\": \"es6\"`\n\n  `}`\n\n`}`\n\n## [](#this-typing)`this`\\-typing\n\nIt is a common pattern to return the current object (i.e. `this`) from a method to create [fluent-style APIs](https://wikipedia.org/wiki/Fluent_interface). For instance, consider the following `BasicCalculator` module:\n\nts\n\n`export default class BasicCalculator {`\n\n  `public constructor(protected value: number = 0) {}`\n\n  `public currentValue(): number {`\n\n    `return this.value;`\n\n  `}`\n\n  `public add(operand: number) {`\n\n    `this.value += operand;`\n\n    `return this;`\n\n  `}`\n\n  `public subtract(operand: number) {`\n\n    `this.value -= operand;`\n\n    `return this;`\n\n  `}`\n\n  `public multiply(operand: number) {`\n\n    `this.value *= operand;`\n\n    `return this;`\n\n  `}`\n\n  `public divide(operand: number) {`\n\n    `this.value /= operand;`\n\n    `return this;`\n\n  `}`\n\n`}`\n\nA user could express `2 * 5 + 1` as\n\nts\n\n`import calc from \"./BasicCalculator\";`\n\n`let v = new calc(2).multiply(5).add(1).currentValue();`\n\nThis often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from `BasicCalculator`. Imagine a user wanted to start writing a `ScientificCalculator`:\n\nts\n\n`import BasicCalculator from \"./BasicCalculator\";`\n\n`export default class ScientificCalculator extends BasicCalculator {`\n\n  `public constructor(value = 0) {`\n\n    `super(value);`\n\n  `}`\n\n  `public square() {`\n\n    `this.value = this.value ** 2;`\n\n    `return this;`\n\n  `}`\n\n  `public sin() {`\n\n    `this.value = Math.sin(this.value);`\n\n    `return this;`\n\n  `}`\n\n`}`\n\nBecause TypeScript used to infer the type `BasicCalculator` for each method in `BasicCalculator` that returned `this`, the type system would forget that it had `ScientificCalculator` whenever using a `BasicCalculator` method.\n\nFor instance:\n\nts\n\n`import calc from \"./ScientificCalculator\";`\n\n`let v = new calc(0.5)`\n\n  `.square()`\n\n  `.divide(2)`\n\n  `.sin() // Error: 'BasicCalculator' has no 'sin' method.`\n\n  `.currentValue();`\n\nThis is no longer the case - TypeScript now infers `this` to have a special type called `this` whenever inside an instance method of a class. The `this` type is written as so, and basically means “the type of the left side of the dot in a method call”.\n\nThe `this` type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:\n\nts\n\n`interface MyType {`\n\n  `extend<T>(other: T): this & T;`\n\n`}`\n\n## [](#es7-exponentiation-operator)ES7 exponentiation operator\n\nTypeScript 1.7 supports upcoming [ES7/ES2016 exponentiation operators](https://github.com/rwaldron/exponentiation-operator): `**` and `**=`. The operators will be transformed in the output to ES3/ES5 using `Math.pow`.\n\n##### [](#example-2)Example\n\nts\n\n`var x = 2 ** 3;`\n\n`var y = 10;`\n\n`y **= 2;`\n\n`var z = -(4 ** 3);`\n\nWill generate the following JavaScript output:\n\njs\n\n`var x = Math.pow(2, 3);`\n\n`var y = 10;`\n\n`y = Math.pow(y, 2);`\n\n`var z = -Math.pow(4, 3);`\n\n## [](#improved-checking-for-destructuring-object-literal)Improved checking for destructuring object literal\n\nTypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.\n\nWhen an object literal is contextually typed by the implied type of an object binding pattern:\n\n*   Properties with default values in the object binding pattern become optional in the object literal.\n*   Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.\n*   Properties in the object literal that have no match in the object binding pattern are an error.\n\nWhen an array literal is contextually typed by the implied type of an array binding pattern:\n\n*   Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.\n\n##### [](#example-3)Example\n\nts\n\n`// Type of f1 is (arg?: { x?: number, y?: number }) => void`\n\n`function f1({ x = 0, y = 0 } = {}) {}`\n\n`// And can be called as:`\n\n`f1();`\n\n`f1({});`\n\n`f1({ x: 1 });`\n\n`f1({ y: 1 });`\n\n`f1({ x: 1, y: 1 });`\n\n`// Type of f2 is (arg?: (x: number, y?: number) => void`\n\n`function f2({ x, y = 0 } = { x: 0 }) {}`\n\n`f2();`\n\n`f2({}); // Error, x not optional`\n\n`f2({ x: 1 });`\n\n`f2({ y: 1 }); // Error, x not optional`\n\n`f2({ x: 1, y: 1 });`\n\n## [](#support-for-decorators-when-targeting-es3)Support for decorators when targeting ES3\n\nDecorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of `reduceRight` from the `__decorate` helper. The changes also inline calls `Object.getOwnPropertyDescriptor` and `Object.defineProperty` in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned `Object` methods.",
    "title": "TypeScript: Documentation - TypeScript 1.7",
    "description": "TypeScript 1.7 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html",
    "markdown": "# TypeScript: Documentation - TypeScript 1.6\n\n## [](#jsx-support)JSX support\n\nJSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.\n\n#### [](#new-tsx-file-extension-and-as-operator)New `.tsx` file extension and `as` operator\n\nTypeScript 1.6 introduces a new `.tsx` file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new `as` operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:\n\nts\n\n`var x = <any>foo;`\n\n`// is equivalent to:`\n\n`var x = foo as any;`\n\n#### [](#using-react)Using React\n\nTo use JSX-support with React you should use the [React typings](https://github.com/borisyankov/DefinitelyTyped/tree/master/react). These typings define the `JSX` namespace so that TypeScript can correctly check JSX expressions for React. For example:\n\nts\n\n`/// <reference path=\"react.d.ts\" />`\n\n`interface Props {`\n\n  `name: string;`\n\n`}`\n\n`class MyComponent extends React.Component<Props, {}> {`\n\n  `render() {`\n\n    `return <span>{this.props.name}</span>;`\n\n  `}`\n\n`}`\n\n`<MyComponent name=\"bar\" />; // OK`\n\n``<MyComponent name={0} />; // error, `name` is not a number``\n\n#### [](#using-other-jsx-frameworks)Using other JSX frameworks\n\nJSX element names and properties are validated against the `JSX` namespace. Please see the \\[\\[JSX\\]\\] wiki page for defining the `JSX` namespace for your framework.\n\n#### [](#output-generation)Output generation\n\nTypeScript ships with two JSX modes: `preserve` and `react`.\n\n*   The `preserve` mode will keep JSX expressions as part of the output to be further consumed by another transform step. _Additionally the output will have a `.jsx` file extension._\n*   The `react` mode will emit `React.createElement`, does not need to go through a JSX transformation before use, and the output will have a `.js` file extension.\n\nSee the \\[\\[JSX\\]\\] wiki page for more information on using JSX in TypeScript.\n\n## [](#intersection-types)Intersection types\n\nTypeScript 1.6 introduces intersection types, the logical complement of union types. A union type `A | B` represents an entity that is either of type `A` or type `B`, whereas an intersection type `A & B` represents an entity that is both of type `A` _and_ type `B`.\n\n##### [](#example)Example\n\nts\n\n`function extend<T, U>(first: T, second: U): T & U {`\n\n  `let result = <T & U>{};`\n\n  `for (let id in first) {`\n\n    `result[id] = first[id];`\n\n  `}`\n\n  `for (let id in second) {`\n\n    `if (!result.hasOwnProperty(id)) {`\n\n      `result[id] = second[id];`\n\n    `}`\n\n  `}`\n\n  `return result;`\n\n`}`\n\n`var x = extend({ a: \"hello\" }, { b: 42 });`\n\n`var s = x.a;`\n\n`var n = x.b;`\n\nts\n\n`type LinkedList<T> = T & { next: LinkedList<T> };`\n\n`interface Person {`\n\n  `name: string;`\n\n`}`\n\n`var people: LinkedList<Person>;`\n\n`var s = people.name;`\n\n`var s = people.next.name;`\n\n`var s = people.next.next.name;`\n\n`var s = people.next.next.next.name;`\n\nts\n\n`interface A {`\n\n  `a: string;`\n\n`}`\n\n`interface B {`\n\n  `b: string;`\n\n`}`\n\n`interface C {`\n\n  `c: string;`\n\n`}`\n\n`var abc: A & B & C;`\n\n`abc.a = \"hello\";`\n\n`abc.b = \"hello\";`\n\n`abc.c = \"hello\";`\n\nSee [issue #1256](https://github.com/Microsoft/TypeScript/issues/1256) for more information.\n\n## [](#local-type-declarations)Local type declarations\n\nLocal class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with `let` and `const`. For example:\n\nts\n\n`function f() {`\n\n  `if (true) {`\n\n    `interface T {`\n\n      `x: number;`\n\n    `}`\n\n    `let v: T;`\n\n    `v.x = 5;`\n\n  `} else {`\n\n    `interface T {`\n\n      `x: string;`\n\n    `}`\n\n    `let v: T;`\n\n    `v.x = \"hello\";`\n\n  `}`\n\n`}`\n\nThe inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:\n\nts\n\n`interface Point {`\n\n  `x: number;`\n\n  `y: number;`\n\n`}`\n\n`function getPointFactory(x: number, y: number) {`\n\n  `class P {`\n\n    `x = x;`\n\n    `y = y;`\n\n  `}`\n\n  `return P;`\n\n`}`\n\n`var PointZero = getPointFactory(0, 0);`\n\n`var PointOne = getPointFactory(1, 1);`\n\n`var p1 = new PointZero();`\n\n`var p2 = new PointZero();`\n\n`var p3 = new PointOne();`\n\nLocal types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:\n\nts\n\n`function f3() {`\n\n  `function f<X, Y>(x: X, y: Y) {`\n\n    `class C {`\n\n      `public x = x;`\n\n      `public y = y;`\n\n    `}`\n\n    `return C;`\n\n  `}`\n\n  `let C = f(10, \"hello\");`\n\n  `let v = new C();`\n\n  `let x = v.x; // number`\n\n  `let y = v.y; // string`\n\n`}`\n\n## [](#class-expressions)Class expressions\n\nTypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:\n\nts\n\n`let Point = class {`\n\n  `constructor(public x: number, public y: number) {}`\n\n  `public length() {`\n\n    `return Math.sqrt(this.x * this.x + this.y * this.y);`\n\n  `}`\n\n`};`\n\n`var p = new Point(3, 4); // p has anonymous class type`\n\n`console.log(p.length());`\n\n## [](#extending-expressions)Extending expressions\n\nTypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.\n\nThe `extends` clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the `extends` clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and “class-like” expressions to be specified in the `extends` clause.\n\nSome examples:\n\nts\n\n`// Extend built-in types`\n\n`class MyArray extends Array<number> {}`\n\n`class MyError extends Error {}`\n\n`// Extend computed base class`\n\n`class ThingA {`\n\n  `getGreeting() {`\n\n    `return \"Hello from A\";`\n\n  `}`\n\n`}`\n\n`class ThingB {`\n\n  `getGreeting() {`\n\n    `return \"Hello from B\";`\n\n  `}`\n\n`}`\n\n`interface Greeter {`\n\n  `getGreeting(): string;`\n\n`}`\n\n`interface GreeterConstructor {`\n\n  `new (): Greeter;`\n\n`}`\n\n`function getGreeterBase(): GreeterConstructor {`\n\n  `return Math.random() >= 0.5 ? ThingA : ThingB;`\n\n`}`\n\n`class Test extends getGreeterBase() {`\n\n  `sayHello() {`\n\n    `console.log(this.getGreeting());`\n\n  `}`\n\n`}`\n\n## [](#abstract-classes-and-methods)`abstract` classes and methods\n\nTypeScript 1.6 adds support for `abstract` keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.\n\n##### [](#examples)Examples\n\nts\n\n`abstract class Base {`\n\n  `abstract getThing(): string;`\n\n  `getOtherThing() {`\n\n    `return \"hello\";`\n\n  `}`\n\n`}`\n\n`let x = new Base(); // Error, 'Base' is abstract`\n\n`// Error, must either be 'abstract' or implement concrete 'getThing'`\n\n`class Derived1 extends Base {}`\n\n`class Derived2 extends Base {`\n\n  `getThing() {`\n\n    `return \"hello\";`\n\n  `}`\n\n  `foo() {`\n\n    `super.getThing(); // Error: cannot invoke abstract members through 'super'`\n\n  `}`\n\n`}`\n\n`var x = new Derived2(); // OK`\n\n`var y: Base = new Derived2(); // Also OK`\n\n`y.getThing(); // OK`\n\n`y.getOtherThing(); // OK`\n\n## [](#generic-type-aliases)Generic type aliases\n\nWith TypeScript 1.6, type aliases can be generic. For example:\n\nts\n\n`type Lazy<T> = T | (() => T);`\n\n`var s: Lazy<string>;`\n\n`s = \"eager\";`\n\n`s = () => \"lazy\";`\n\n`interface Tuple<A, B> {`\n\n  `a: A;`\n\n  `b: B;`\n\n`}`\n\n`type Pair<T> = Tuple<T, T>;`\n\n## [](#stricter-object-literal-assignment-checks)Stricter object literal assignment checks\n\nTypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don’t exist in the target type.\n\n##### [](#examples-1)Examples\n\nts\n\n`var x: { foo: number };`\n\n`` x = { foo: 1, baz: 2 }; // Error, excess property `baz` ``\n\n`var y: { foo: number; bar?: number };`\n\n`` y = { foo: 1, baz: 2 }; // Error, excess or misspelled property `baz` ``\n\nA type can include an index signature to explicitly indicate that excess properties are permitted:\n\nts\n\n`var x: { foo: number; [x: string]: any };`\n\n``x = { foo: 1, baz: 2 }; // Ok, `baz` matched by index signature``\n\n## [](#es6-generators)ES6 generators\n\nTypeScript 1.6 adds support for generators when targeting ES6.\n\nA generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:\n\nts\n\n`function* g(): Iterable<string> {`\n\n  `for (var i = 0; i < 100; i++) {`\n\n    `yield \"\"; // string is assignable to string`\n\n  `}`\n\n  `yield* otherStringGenerator(); // otherStringGenerator must be iterable and element type assignable to string`\n\n`}`\n\nA generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:\n\nts\n\n`function* g() {`\n\n  `for (var i = 0; i < 100; i++) {`\n\n    `yield \"\"; // infer string`\n\n  `}`\n\n  `yield* otherStringGenerator(); // infer element type of otherStringGenerator`\n\n`}`\n\n## [](#experimental-support-for-async-functions)Experimental support for `async` functions\n\nTypeScript 1.6 introduces experimental support of `async` functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible `Promise` implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.\n\nAn _async function_ is a function or method that has been prefixed with the `async` modifier. This modifier informs the compiler that function body transposition is required, and that the keyword `await` should be treated as a unary expression instead of an identifier. An _Async Function_ must provide a return type annotation that points to a compatible `Promise` type. Return type inference can only be used if there is a globally defined, compatible `Promise` type.\n\n##### [](#example-1)Example\n\nts\n\n`var p: Promise<number> = /* ... */;`\n\n`async function fn(): Promise<number> {`\n\n  `var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"`\n\n  `return 1 + i;`\n\n`}`\n\n`var a = async (): Promise<number> => 1 + await p; // suspends execution.`\n\n`var a = async () => 1 + await p; // suspends execution. return type is inferred as \"Promise<number>\" when compiling with --target ES6`\n\n`var fe = async function(): Promise<number> {`\n\n  `var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"`\n\n  `return 1 + i;`\n\n`}`\n\n`class C {`\n\n  `async m(): Promise<number> {`\n\n    `var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"`\n\n    `return 1 + i;`\n\n  `}`\n\n  `async get p(): Promise<number> {`\n\n    `var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"`\n\n    `return 1 + i;`\n\n  `}`\n\n`}`\n\n## [](#nightly-builds)Nightly builds\n\nWhile not strictly a language change, nightly builds are now available by installing with the following command:\n\n`npm install -g typescript@next`\n\n## [](#adjustments-in-module-resolution-logic)Adjustments in module resolution logic\n\nStarting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting ‘commonjs’. These [rules](https://github.com/Microsoft/TypeScript/issues/2338) attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution) command line option. Possible values are:\n\n*   ‘classic’ - module resolution rules used by pre 1.6 TypeScript compiler\n*   ‘node’ - node-like module resolution\n\n## [](#merging-ambient-class-and-interface-declaration)Merging ambient class and interface declaration\n\nThe instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:\n\nts\n\n`declare class Foo {`\n\n  `public x: number;`\n\n`}`\n\n`interface Foo {`\n\n  `y: string;`\n\n`}`\n\n`function bar(foo: Foo) {`\n\n  `foo.x = 1; // OK, declared in the class Foo`\n\n  `foo.y = \"1\"; // OK, declared in the interface Foo`\n\n`}`\n\n## [](#user-defined-type-guard-functions)User-defined type guard functions\n\nTypeScript 1.6 adds a new way to narrow a variable type inside an `if` block, in addition to `typeof` and `instanceof`. A user-defined type guard functions is one with a return type annotation of the form `x is T`, where `x` is a declared parameter in the signature, and `T` is any type. When a user-defined type guard function is invoked on a variable in an `if` block, the type of the variable will be narrowed to `T`.\n\n##### [](#examples-2)Examples\n\nts\n\n`function isCat(a: any): a is Cat {`\n\n  `return a.name === \"kitty\";`\n\n`}`\n\n`var x: Cat | Dog;`\n\n`if (isCat(x)) {`\n\n  `x.meow(); // OK, x is Cat in this block`\n\n`}`\n\n## [](#exclude-property-support-in-tsconfigjson)`exclude` property support in tsconfig.json\n\nA tsconfig.json file that doesn’t specify a files property (and therefore implicitly references all \\*.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"test.js\"`\n\n  `},`\n\n  `\"\": [\"node_modules\", \"test.ts\", \"utils/t2.ts\"]`\n\n`}`\n\nThe [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) list does not support wildcards. It must simply be a list of files and/or directories.\n\n## [](#--init-command-line-option)`--init` command line option\n\nRun `tsc --init` in a directory to create an initial `tsconfig.json` in this directory with preset defaults. Optionally pass command line arguments along with `--init` to be stored in your initial tsconfig.json on creation.",
    "title": "TypeScript: Documentation - TypeScript 1.6",
    "description": "TypeScript 1.6 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html",
    "markdown": "# TypeScript: Documentation - TypeScript 1.8\n\n## [](#type-parameters-as-constraints)Type parameters as constraints\n\nWith TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error. This capability is usually referred to as [F-Bounded Polymorphism](https://wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification).\n\n##### [](#example)Example\n\nts\n\n`function assign<T extends U, U>(target: T, source: U): T {`\n\n  `for (let id in source) {`\n\n    `target[id] = source[id];`\n\n  `}`\n\n  `return target;`\n\n`}`\n\n`let x = { a: 1, b: 2, c: 3, d: 4 };`\n\n`assign(x, { b: 10, d: 20 });`\n\n`assign(x, { e: 0 }); // Error`\n\n## [](#control-flow-analysis-errors)Control flow analysis errors\n\nTypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:\n\n![cfa](https://cloud.githubusercontent.com/assets/8052307/5210657/c5ae0f28-7585-11e4-97d8-86169ef2a160.gif)\n\n### [](#unreachable-code)Unreachable code\n\nStatements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional `return`, `throw`, `break` or `continue` statements are considered unreachable. Use [`allowUnreachableCode`](https://www.typescriptlang.org/tsconfig#allowUnreachableCode) to disable unreachable code detection and reporting.\n\n##### [](#example-1)Example\n\nHere’s a simple example of an unreachable code error:\n\nts\n\n`function f(x) {`\n\n  `if (x) {`\n\n    `return true;`\n\n  `} else {`\n\n    `return false;`\n\n  `}`\n\n  `x = 0; // Error: Unreachable code detected.`\n\n`}`\n\nA more common error that this feature catches is adding a newline after a `return` statement:\n\nts\n\n`function f() {`\n\n  `return; // Automatic Semicolon Insertion triggered at newline`\n\n  `{`\n\n    `x: \"string\"; // Error: Unreachable code detected.`\n\n  `}`\n\n`}`\n\nSince JavaScript automatically terminates the `return` statement at the end of the line, the object literal becomes a block.\n\n### [](#unused-labels)Unused labels\n\nUnused labels are also flagged. Just like unreachable code checks, these are turned on by default; use [`allowUnusedLabels`](https://www.typescriptlang.org/tsconfig#allowUnusedLabels) to stop reporting these errors.\n\n##### [](#example-2)Example\n\nts\n\n`loop: while (x > 0) {`\n\n  `// Error: Unused label.`\n\n  `x++;`\n\n`}`\n\n### [](#implicit-returns)Implicit returns\n\nFunctions with code paths that do not return a value in JS implicitly return `undefined`. These can now be flagged by the compiler as implicit returns. The check is turned _off_ by default; use [`noImplicitReturns`](https://www.typescriptlang.org/tsconfig#noImplicitReturns) to turn it on.\n\n##### [](#example-3)Example\n\nts\n\n`function f(x) {`\n\n  `// Error: Not all code paths return a value.`\n\n  `if (x) {`\n\n    `return false;`\n\n  `}`\n\n  `` // implicitly returns `undefined` ``\n\n`}`\n\n### [](#case-clause-fall-throughs)Case clause fall-throughs\n\nTypeScript can reports errors for fall-through cases in switch statement where the case clause is non-empty. This check is turned _off_ by default, and can be enabled using [`noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch).\n\n##### [](#example-4)Example\n\nWith [`noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch), this example will trigger an error:\n\nts\n\n`switch (x % 2) {`\n\n  `case 0: // Error: Fallthrough case in switch.`\n\n    `console.log(\"even\");`\n\n  `case 1:`\n\n    `console.log(\"odd\");`\n\n    `break;`\n\n`}`\n\nHowever, in the following example, no error will be reported because the fall-through case is empty:\n\nts\n\n`switch (x % 3) {`\n\n  `case 0:`\n\n  `case 1:`\n\n    `console.log(\"Acceptable\");`\n\n    `break;`\n\n  `case 2:`\n\n    `console.log(\"This is *two much*!\");`\n\n    `break;`\n\n`}`\n\n## [](#function-components-in-react)Function Components in React\n\nTypeScript now supports [Function components](https://reactjs.org/docs/components-and-props.html#functional-and-class-components). These are lightweight components that easily compose other components:\n\nts\n\n`// Use parameter destructuring and defaults for easy definition of 'props' type`\n\n`const Greeter = ({ name = \"world\" }) => <div>Hello, {name}!</div>;`\n\n`// Properties get validated`\n\n`let example = <Greeter name=\"TypeScript 1.8\" />;`\n\nFor this feature and simplified props, be sure to be use the [latest version of react.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts).\n\n## [](#simplified-props-type-management-in-react)Simplified `props` type management in React\n\nIn TypeScript 1.8 with the latest version of react.d.ts (see above), we’ve also greatly simplified the declaration of `props` types.\n\nSpecifically:\n\n*   You no longer need to either explicitly declare `ref` and `key` or `extend React.Props`\n*   The `ref` and `key` properties will appear with correct types on all components\n*   The `ref` property is correctly disallowed on instances of Stateless Function components\n\n## [](#augmenting-globalmodule-scope-from-modules)Augmenting global/module scope from modules\n\nUsers can now declare any augmentations that they want to make, or that any other consumers already have made, to an existing module. Module augmentations look like plain old ambient module declarations (i.e. the `declare module \"foo\" { }` syntax), and are directly nested either your own modules, or in another top level ambient external module.\n\nFurthermore, TypeScript also has the notion of _global_ augmentations of the form `declare global { }`. This allows modules to augment global types such as `Array` if necessary.\n\nThe name of a module augmentation is resolved using the same set of rules as module specifiers in `import` and `export` declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.\n\nNeither module augmentations nor global augmentations can add new items to the top level scope - they can only “patch” existing declarations.\n\n##### [](#example-5)Example\n\nHere `map.ts` can declare that it will internally patch the `Observable` type from `observable.ts` and add the `map` method to it.\n\nts\n\n`// observable.ts`\n\n`export class Observable<T> {`\n\n  `// ...`\n\n`}`\n\nts\n\n`// map.ts`\n\n`import { Observable } from \"./observable\";`\n\n`// Create an augmentation for \"./observable\"`\n\n`declare module \"./observable\" {`\n\n    `// Augment the 'Observable' class definition with interface merging`\n\n    `interface Observable<T> {`\n\n        `map<U>(proj: (el: T) => U): Observable<U>;`\n\n    `}`\n\n`}`\n\n`Observable.prototype.map = /*...*/;`\n\nts\n\n`// consumer.ts`\n\n`import { Observable } from \"./observable\";`\n\n`import \"./map\";`\n\n`let o: Observable<number>;`\n\n`o.map((x) => x.toFixed());`\n\nSimilarly, the global scope can be augmented from modules using a `declare global` declarations:\n\n##### [](#example-6)Example\n\nts\n\n`// Ensure this is treated as a module.`\n\n`export {};`\n\n`declare global {`\n\n  `interface Array<T> {`\n\n    `mapToNumbers(): number[];`\n\n  `}`\n\n`}`\n\n`Array.prototype.mapToNumbers = function () {`\n\n  `/* ... */`\n\n`};`\n\n## [](#string-literal-types)String literal types\n\nIt’s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the [“easing” of the animation.](https://wikipedia.org/wiki/Inbetweening)\n\nts\n\n`declare class UIElement {`\n\n  `animate(options: AnimationOptions): void;`\n\n`}`\n\n`interface AnimationOptions {`\n\n  `deltaX: number;`\n\n  `deltaY: number;`\n\n  `easing: string; // Can be \"ease-in\", \"ease-out\", \"ease-in-out\"`\n\n`}`\n\nHowever, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:\n\nts\n\n`// No errors`\n\n`new UIElement().animate({ deltaX: 100, deltaY: 100, easing: \"ease-inout\" });`\n\nWith TypeScript 1.8, we’ve introduced string literal types. These types are written the same way string literals are, but in type positions.\n\nUsers can now ensure that the type system will catch such errors. Here’s our new `AnimationOptions` using string literal types:\n\nts\n\n`interface AnimationOptions {`\n\n  `deltaX: number;`\n\n  `deltaY: number;`\n\n  `easing: \"ease-in\" | \"ease-out\" | \"ease-in-out\";`\n\n`}`\n\n`// Error: Type '\"ease-inout\"' is not assignable to type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'`\n\n`new UIElement().animate({ deltaX: 100, deltaY: 100, easing: \"ease-inout\" });`\n\n## [](#improved-unionintersection-type-inference)Improved union/intersection type inference\n\nTypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from `string | string[]` to `string | T`, we reduce the types to `string[]` and `T`, thus inferring `string[]` for `T`.\n\n##### [](#example-7)Example\n\nts\n\n`type Maybe<T> = T | void;`\n\n`function isDefined<T>(x: Maybe<T>): x is T {`\n\n  `return x !== undefined && x !== null;`\n\n`}`\n\n`function isUndefined<T>(x: Maybe<T>): x is void {`\n\n  `return x === undefined || x === null;`\n\n`}`\n\n`function getOrElse<T>(x: Maybe<T>, defaultValue: T): T {`\n\n  `return isDefined(x) ? x : defaultValue;`\n\n`}`\n\n`function test1(x: Maybe<string>) {`\n\n  `let x1 = getOrElse(x, \"Undefined\"); // string`\n\n  `let x2 = isDefined(x) ? x : \"Undefined\"; // string`\n\n  `let x3 = isUndefined(x) ? \"Undefined\" : x; // string`\n\n`}`\n\n`function test2(x: Maybe<number>) {`\n\n  `let x1 = getOrElse(x, -1); // number`\n\n  `let x2 = isDefined(x) ? x : -1; // number`\n\n  `let x3 = isUndefined(x) ? -1 : x; // number`\n\n`}`\n\n## [](#concatenate-amd-and-system-modules-with---outfile)Concatenate `AMD` and `System` modules with `--outFile`\n\nSpecifying [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) in conjunction with `--module amd` or `--module system` will concatenate all modules in the compilation into a single output file containing multiple module closures.\n\nA module name will be computed for each module based on its relative location to [`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir).\n\n##### [](#example-8)Example\n\nts\n\n`// file src/a.ts`\n\n`import * as B from \"./lib/b\";`\n\n`export function createA() {`\n\n  `return B.createB();`\n\n`}`\n\nts\n\n`// file src/lib/b.ts`\n\n`export function createB() {`\n\n  `return {};`\n\n`}`\n\nResults in:\n\njs\n\n`define(\"lib/b\", [\"require\", \"exports\"], function (require, exports) {`\n\n  `\"use strict\";`\n\n  `function createB() {`\n\n    `return {};`\n\n  `}`\n\n  `exports.createB = createB;`\n\n`});`\n\n`define(\"a\", [\"require\", \"exports\", \"lib/b\"], function (require, exports, B) {`\n\n  `\"use strict\";`\n\n  `function createA() {`\n\n    `return B.createB();`\n\n  `}`\n\n  `exports.createA = createA;`\n\n`});`\n\n## [](#support-for-default-import-interop-with-systemjs)Support for `default` import interop with SystemJS\n\nModule loaders like SystemJS wrap CommonJS modules and expose then as a `default` ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.\n\nSetting the new compiler flag [`allowSyntheticDefaultImports`](https://www.typescriptlang.org/tsconfig#allowSyntheticDefaultImports) indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a `default` export that has the shape of the entire module itself.\n\nSystem modules have this flag on by default.\n\n## [](#allow-captured-letconst-in-loops)Allow captured `let`/`const` in loops\n\nPreviously an error, now supported in TypeScript 1.8. `let`/`const` declarations within loops and captured in functions are now emitted to correctly match `let`/`const` freshness semantics.\n\n##### [](#example-9)Example\n\nts\n\n`let list = [];`\n\n`for (let i = 0; i < 5; i++) {`\n\n  `list.push(() => i);`\n\n`}`\n\n`list.forEach((f) => console.log(f()));`\n\nis compiled to:\n\njs\n\n`var list = [];`\n\n`var _loop_1 = function (i) {`\n\n  `list.push(function () {`\n\n    `return i;`\n\n  `});`\n\n`};`\n\n`for (var i = 0; i < 5; i++) {`\n\n  `_loop_1(i);`\n\n`}`\n\n`list.forEach(function (f) {`\n\n  `return console.log(f());`\n\n`});`\n\nAnd results in\n\ncmd\n\n`0`\n\n`1`\n\n`2`\n\n`3`\n\n`4`\n\n## [](#improved-checking-for-forin-statements)Improved checking for `for..in` statements\n\nPreviously the type of a `for..in` variable is inferred to `any`; that allowed the compiler to ignore invalid uses within the `for..in` body.\n\nStarting with TypeScript 1.8:\n\n*   The type of a variable declared in a `for..in` statement is implicitly `string`.\n*   When an object with a numeric index signature of type `T` (such as an array) is indexed by a `for..in` variable of a containing `for..in` statement for an object _with_ a numeric index signature and _without_ a string index signature (again such as an array), the value produced is of type `T`.\n\n##### [](#example-10)Example\n\nts\n\n`var a: MyObject[];`\n\n`for (var x in a) {`\n\n  `// Type of x is implicitly string`\n\n  `var obj = a[x]; // Type of obj is MyObject`\n\n`}`\n\n## [](#modules-are-now-emitted-with-a-use-strict-prologue)Modules are now emitted with a `\"use strict\";` prologue\n\nModules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn’t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to `NaN`, will now loudly fail. You can reference the [MDN Article](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode) on strict mode for a detailed list of the differences between strict mode and non-strict mode.\n\n## [](#including-js-files-with---allowjs)Including `.js` files with `--allowJs`\n\nOften there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.\n\n`.js` files are now allowed as input to `tsc`. The TypeScript compiler checks the input `.js` files for syntax errors, and emits valid output based on the [`target`](https://www.typescriptlang.org/tsconfig#target) and [`module`](https://www.typescriptlang.org/tsconfig#module) flags. The output can be combined with other `.ts` files as well. Source maps are still generated for `.js` files just like with `.ts` files.\n\n## [](#custom-jsx-factories-using---reactnamespace)Custom JSX factories using `--reactNamespace`\n\nPassing `--reactNamespace <JSX factory Name>` along with `--jsx react` allows for using a different JSX factory from the default `React`.\n\nThe new factory name will be used to call `createElement` and `__spread` functions.\n\n##### [](#example-11)Example\n\nts\n\n`import { jsxFactory } from \"jsxFactory\";`\n\n`var div = <div>Hello JSX!</div>;`\n\nCompiled with:\n\nshell\n\n`tsc --jsx react --reactNamespace jsxFactory --m commonJS`\n\nResults in:\n\njs\n\n`\"use strict\";`\n\n`var jsxFactory_1 = require(\"jsxFactory\");`\n\n`var div = jsxFactory_1.jsxFactory.createElement(\"div\", null, \"Hello JSX!\");`\n\n## [](#this-based-type-guards)`this`\\-based type guards\n\nTypeScript 1.8 extends [user-defined type guard functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1.6.html#user-defined-type-guard-functions) to class and interface methods.\n\n`this is T` is now valid return type annotation for methods in classes and interfaces. When used in a type narrowing position (e.g. `if` statement), the type of the call expression target object would be narrowed to `T`.\n\n##### [](#example-12)Example\n\nts\n\n`class FileSystemObject {`\n\n  `isFile(): this is File {`\n\n    `return this instanceof File;`\n\n  `}`\n\n  `isDirectory(): this is Directory {`\n\n    `return this instanceof Directory;`\n\n  `}`\n\n  `isNetworked(): this is Networked & this {`\n\n    `return this.networked;`\n\n  `}`\n\n  `constructor(public path: string, private networked: boolean) {}`\n\n`}`\n\n`class File extends FileSystemObject {`\n\n  `constructor(path: string, public content: string) {`\n\n    `super(path, false);`\n\n  `}`\n\n`}`\n\n`class Directory extends FileSystemObject {`\n\n  `children: FileSystemObject[];`\n\n`}`\n\n`interface Networked {`\n\n  `host: string;`\n\n`}`\n\n`let fso: FileSystemObject = new File(\"foo/bar.txt\", \"foo\");`\n\n`if (fso.isFile()) {`\n\n  `fso.content; // fso is File`\n\n`} else if (fso.isDirectory()) {`\n\n  `fso.children; // fso is Directory`\n\n`} else if (fso.isNetworked()) {`\n\n  `fso.host; // fso is networked`\n\n`}`\n\n## [](#official-typescript-nuget-package)Official TypeScript NuGet package\n\nStarting with TypeScript 1.8, official NuGet packages are available for the TypeScript Compiler (`tsc.exe`) as well as the MSBuild integration (`Microsoft.TypeScript.targets` and `Microsoft.TypeScript.Tasks.dll`).\n\nStable packages are available here:\n\n*   [Microsoft.TypeScript.Compiler](https://www.nuget.org/packages/Microsoft.TypeScript.Compiler/)\n*   [Microsoft.TypeScript.MSBuild](https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild/)\n\nAlso, a nightly NuGet package to match the [nightly npm package](http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx) is available on [myget](https://myget.org/):\n\n*   [TypeScript-Preview](https://www.myget.org/gallery/typescript-preview)\n\n## [](#prettier-error-messages-from-tsc)Prettier error messages from `tsc`\n\nWe understand that a ton of monochrome output can be a little difficult on the eyes. Colors can help discern where a message starts and ends, and these visual clues are important when error output gets overwhelming.\n\nBy just passing the [`pretty`](https://www.typescriptlang.org/tsconfig#pretty) command line option, TypeScript gives more colorful output with context about where things are going wrong.\n\n![Showing off pretty error messages in ConEmu](https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-in-typescript/pretty01.png)\n\n## [](#colorization-of-jsx-code-in-vs-2015)Colorization of JSX code in VS 2015\n\nWith TypeScript 1.8, JSX tags are now classified and colorized in Visual Studio 2015.\n\n![jsx](https://cloud.githubusercontent.com/assets/8052307/12271404/b875c502-b90f-11e5-93d8-c6740be354d1.png)\n\nThe classification can be further customized by changing the font and color settings for the `VB XML` color and font settings through `Tools`\\->`Options`\\->`Environment`\\->`Fonts and Colors` page.\n\n## [](#the---project--p-flag-can-now-take-any-file-path)The `--project` (`-p`) flag can now take any file path\n\nThe `--project` command line option originally could only take paths to a folder containing a `tsconfig.json`. Given the different scenarios for build configurations, it made sense to allow `--project` to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using `tsc` alone without having to perform hacky workarounds like placing `tsconfig.json` files in separate directories.\n\nThe old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named `tsconfig.json`.\n\nIt’s always nice to be able to document your configuration! `tsconfig.json` now accepts single and multi-line comments.\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"ES2015\", // running on node v5, yaay!`\n\n    `\"\": true // makes debugging easier`\n\n  `},`\n\n  `/*`\n\n   `* Excluded files`\n\n   `*/`\n\n  `\"\": [\"file.d.ts\"]`\n\n`}`\n\n## [](#support-output-to-ipc-driven-files)Support output to IPC-driven files\n\nTypeScript 1.8 allows users to use the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) argument with special file system entities like named pipes, devices, etc.\n\nAs an example, on many Unix-like systems, the standard output stream is accessible by the file `/dev/stdout`.\n\nshell\n\n`tsc foo.ts --outFile /dev/stdout`\n\nThis can be used to pipe output between commands as well.\n\nAs an example, we can pipe our emitted JavaScript into a pretty printer like [pretty-js](https://www.npmjs.com/package/pretty-js):\n\nshell\n\n`tsc foo.ts --outFile /dev/stdout | pretty-js`\n\n## [](#improved-support-for-tsconfigjson-in-visual-studio-2015)Improved support for `tsconfig.json` in Visual Studio 2015\n\nTypeScript 1.8 allows `tsconfig.json` files in all project types. This includes ASP.NET v4 projects, _Console Application_, and the _Html Application with TypeScript_ project types. Further, you are no longer limited to a single `tsconfig.json` file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.\n\n![Showing off tsconfig.json in Visual Studio](https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-in-typescript/tsconfig-in-vs.png)\n\nWe also disable the project properties page when you add a `tsconfig.json` file. This means that all configuration changes have to be made in the `tsconfig.json` file itself.\n\n### [](#a-couple-of-limitations)A couple of limitations\n\n*   If you add a `tsconfig.json` file, TypeScript files that are not considered part of that context are not compiled.\n*   Apache Cordova Apps still have the existing limitation of a single `tsconfig.json` file, which must be in either the root or the `scripts` folder.\n*   There is no template for `tsconfig.json` in most project types.",
    "title": "TypeScript: Documentation - TypeScript 1.8",
    "description": "TypeScript 1.8 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html",
    "markdown": "# TypeScript: Documentation - TypeScript 1.5\n\n## [](#es6-modules)ES6 Modules\n\nTypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript’s original internal and external module constructs and the constructs can be mixed and matched at will.\n\n#### [](#export-declarations)Export Declarations\n\nIn addition to the existing TypeScript support for decorating declarations with `export`, module members can also be exported using separate export declarations, optionally specifying different names for exports using `as` clauses.\n\nts\n\n`interface Stream { ... }`\n\n`function writeToStream(stream: Stream, data: string) { ... }`\n\n`export { Stream, writeToStream as write };  // writeToStream exported as write`\n\nImport declarations, as well, can optionally use `as` clauses to specify different local names for the imports. For example:\n\nts\n\n`import { read, write, standardOutput as stdout } from \"./inout\";`\n\n`var s = read(stdout);`\n\n`write(stdout, s);`\n\nAs an alternative to individual imports, a namespace import can be used to import an entire module:\n\nts\n\n`import * as io from \"./inout\";`\n\n`var s = io.read(io.standardOutput);`\n\n`io.write(io.standardOutput, s);`\n\n#### [](#re-exporting)Re-exporting\n\nUsing `from` clause a module can copy the exports of a given module to the current module without introducing local names.\n\nts\n\n`export { read, write, standardOutput as stdout } from \"./inout\";`\n\n`export *` can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.\n\nts\n\n`export function transform(s: string): string { ... }`\n\n`export * from \"./mod1\";`\n\n`export * from \"./mod2\";`\n\n#### [](#default-export)Default Export\n\nAn export default declaration specifies an expression that becomes the default export of a module:\n\nts\n\n`export default class Greeter {`\n\n  `sayHello() {`\n\n    `console.log(\"Greetings!\");`\n\n  `}`\n\n`}`\n\nWhich in turn can be imported using default imports:\n\nts\n\n`import Greeter from \"./greeter\";`\n\n`var g = new Greeter();`\n\n`g.sayHello();`\n\n#### [](#bare-import)Bare Import\n\nA “bare import” can be used to import a module only for its side-effects.\n\nts\n\n`import \"./polyfills\";`\n\nFor more information about module, please see the [ES6 module support spec](https://github.com/Microsoft/TypeScript/issues/2242).\n\n## [](#destructuring-in-declarations-and-assignments)Destructuring in declarations and assignments\n\nTypeScript 1.5 adds support to ES6 destructuring declarations and assignments.\n\n#### [](#declarations)Declarations\n\nA destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.\n\nFor example, the following sample declares variables `x`, `y`, and `z`, and initializes them to `getSomeObject().x`, `getSomeObject().y` and `getSomeObject().z` respectively:\n\nts\n\n`var { x, y, z } = getSomeObject();`\n\nDestructuring declarations also works for extracting values from arrays:\n\nts\n\n`var [x, y, z = 10] = getSomeArray();`\n\nSimilarly, destructuring can be used in function parameter declarations:\n\nts\n\n`function drawText({ text = \"\", location: [x, y] = [0, 0], bold = false }) {`\n\n  `// Draw text`\n\n`}`\n\n`// Call drawText with an object literal`\n\n`var item = { text: \"someText\", location: [1, 2, 3], style: \"italics\" };`\n\n`drawText(item);`\n\n#### [](#assignments)Assignments\n\nDestructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:\n\nts\n\n`var x = 1;`\n\n`var y = 2;`\n\n`[x, y] = [y, x];`\n\n## [](#namespace-keyword)`namespace` keyword\n\nTypeScript used the `module` keyword to define both “internal modules” and “external modules”; this has been a bit of confusion for developers new to TypeScript. “Internal modules” are closer to what most people would call a namespace; likewise, “external modules” in JS speak really just are modules now.\n\n> Note: Previous syntax defining internal modules are still supported.\n\n**Before**:\n\nts\n\n`module Math {`\n\n    `export function add(x, y) { ... }`\n\n`}`\n\n**After**:\n\nts\n\n`namespace Math {`\n\n    `export function add(x, y) { ... }`\n\n`}`\n\n## [](#let-and-const-support)`let` and `const` support\n\nES6 `let` and `const` declarations are now supported when targeting ES3 and ES5.\n\n#### [](#const)Const\n\nts\n\n`const MAX = 100;`\n\n`++MAX; // Error: The operand of an increment or decrement`\n\n`//        operator cannot be a constant.`\n\n#### [](#block-scoped)Block scoped\n\nts\n\n`if (true) {`\n\n  `let a = 4;`\n\n  `// use a`\n\n`} else {`\n\n  `let a = \"string\";`\n\n  `// use a`\n\n`}`\n\n`alert(a); // Error: a is not defined in this scope.`\n\n## [](#forof-support)for..of support\n\nTypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.\n\n##### [](#example)Example\n\nThe TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:\n\nts\n\n`for (var v of expr) {`\n\n`}`\n\nwill be emitted as:\n\njs\n\n`for (var _i = 0, _a = expr; _i < _a.length; _i++) {`\n\n  `var v = _a[_i];`\n\n`}`\n\n## [](#decorators)Decorators\n\n> TypeScript decorators are based on the [ES7 decorator proposal](https://github.com/wycats/javascript-decorators).\n\nA decorator is:\n\n*   an expression\n*   that evaluates to a function\n*   that takes the target, name, and property descriptor as arguments\n*   and optionally returns a property descriptor to install on the target object\n\n> For more information, please see the [Decorators](https://github.com/Microsoft/TypeScript/issues/2249) proposal.\n\n##### [](#example-1)Example\n\nDecorators `readonly` and `enumerable(false)` will be applied to the property `method` before it is installed on class `C`. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.\n\nts\n\n`class C {`\n\n  `@readonly`\n\n  `@enumerable(false)`\n\n  `method() { ... }`\n\n`}`\n\n`function readonly(target, key, descriptor) {`\n\n    `descriptor.writable = false;`\n\n`}`\n\n`function enumerable(value) {`\n\n    `return function (target, key, descriptor) {`\n\n        `descriptor.enumerable = value;`\n\n    `};`\n\n`}`\n\n## [](#computed-properties)Computed properties\n\nInitializing an object with dynamic properties can be a bit of a burden. Take the following example:\n\nts\n\n`type NeighborMap = { [name: string]: Node };`\n\n`type Node = { name: string; neighbors: NeighborMap };`\n\n`function makeNode(name: string, initialNeighbor: Node): Node {`\n\n  `var neighbors: NeighborMap = {};`\n\n  `neighbors[initialNeighbor.name] = initialNeighbor;`\n\n  `return { name: name, neighbors: neighbors };`\n\n`}`\n\nHere we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:\n\nts\n\n`function makeNode(name: string, initialNeighbor: Node): Node {`\n\n  `return {`\n\n    `name: name,`\n\n    `neighbors: {`\n\n      `[initialNeighbor.name]: initialNeighbor,`\n\n    `},`\n\n  `};`\n\n`}`\n\n## [](#support-for-umd-and-system-module-output)Support for `UMD` and `System` module output\n\nIn addition to `AMD` and `CommonJS` module loaders, TypeScript now supports emitting modules `UMD` ([Universal Module Definition](https://github.com/umdjs/umd)) and [`System`](https://github.com/systemjs/systemjs) module formats.\n\n**Usage**:\n\n> tsc —module umd\n\nand\n\n> tsc —module system\n\n## [](#unicode-codepoint-escapes-in-strings)Unicode codepoint escapes in strings\n\nES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.\n\nAs an example, consider the need to escape a string that contains the character ’𠮷‘. In UTF-16/UCS2, ’𠮷’ is represented as a surrogate pair, meaning that it’s encoded using a pair of 16-bit code units of values, specifically `0xD842` and `0xDFB7`. Previously this meant that you’d have to escape the codepoint as `\"\\uD842\\uDFB7\"`. This has the major downside that it’s difficult to discern two independent characters from a surrogate pair.\n\nWith ES6’s codepoint escapes, you can cleanly represent that exact character in strings and template strings with a single escape: `\"\\u{20bb7}\"`. TypeScript will emit the string in ES3/ES5 as `\"\\uD842\\uDFB7\"`.\n\n## [](#tagged-template-strings-in-es3es5)Tagged template strings in ES3/ES5\n\nIn TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by [@ivogabe](https://github.com/ivogabe), we bridged the gap for for tagged templates in ES3 and ES5.\n\nWhen targeting ES3/ES5, the following code\n\nts\n\n`function oddRawStrings(strs: TemplateStringsArray, n1, n2) {`\n\n  `return strs.raw.filter((raw, index) => index % 2 === 1);`\n\n`}`\n\n``oddRawStrings`Hello \\n${123} \\t ${456}\\n world`;``\n\nwill be emitted as\n\njs\n\n`function oddRawStrings(strs, n1, n2) {`\n\n  `return strs.raw.filter(function (raw, index) {`\n\n    `return index % 2 === 1;`\n\n  `});`\n\n`}`\n\n`(_a = [\"Hello \\n\", \" \\t \", \"\\n world\"]),`\n\n  `(_a.raw = [\"Hello \\\\n\", \" \\\\t \", \"\\\\n world\"]),`\n\n  `oddRawStrings(_a, 123, 456);`\n\n`var _a;`\n\n## [](#amd-dependency-optional-names)AMD-dependency optional names\n\n`/// <amd-dependency path=\"x\" />` informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call; however, there was no way to consume this module in the TS code.\n\nThe new `amd-dependency name` property allows passing an optional name for an amd-dependency:\n\nts\n\n`/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>`\n\n`declare var moduleA: MyType;`\n\n`moduleA.callStuff();`\n\nGenerated JS code:\n\njs\n\n`define([\"require\", \"exports\", \"legacy/moduleA\"], function (`\n\n  `require,`\n\n  `exports,`\n\n  `moduleA`\n\n`) {`\n\n  `moduleA.callStuff();`\n\n`});`\n\n## [](#project-support-through-tsconfigjson)Project support through `tsconfig.json`\n\nAdding a `tsconfig.json` file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:\n\n*   By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.\n*   By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.\n\n##### [](#example-2)Example\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"commonjs\",`\n\n    `\"\": true,`\n\n    `\"\": true`\n\n  `}`\n\n`}`\n\nSee the [tsconfig.json wiki page](https://github.com/Microsoft/TypeScript/wiki/tsconfig.json) for more details.\n\n## [](#--rootdir-command-line-option)`--rootDir` command line option\n\nOption [`outDir`](https://www.typescriptlang.org/tsconfig#outDir) duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.\n\nSometimes this is not desirable, for instance inputs `FolderA\\FolderB\\1.ts` and `FolderA\\FolderB\\2.ts` would result in output structure mirroring `FolderA\\FolderB\\`. Now if a new file `FolderA\\3.ts` is added to the input, the output structure will pop out to mirror `FolderA\\`.\n\n[`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir) specifies the input directory to be mirrored in output instead of computing it.\n\n## [](#--noemithelpers-command-line-option)`--noEmitHelpers` command line option\n\nThe TypeScript compiler emits a few helpers like `__extends` when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use [`noEmitHelpers`](https://www.typescriptlang.org/tsconfig#noEmitHelpers) to instructs the compiler not to emit them.\n\n## [](#--newline-command-line-option)`--newLine` command line option\n\nBy default the output new line character is `\\r\\n` on Windows based systems and `\\n` on \\*nix based systems. [`newLine`](https://www.typescriptlang.org/tsconfig#newLine) command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.\n\n## [](#--inlinesourcemap-and-inlinesources-command-line-options)`--inlineSourceMap` and `inlineSources` command line options\n\n[`inlineSourceMap`](https://www.typescriptlang.org/tsconfig#inlineSourceMap) causes source map files to be written inline in the generated `.js` files instead of in a independent `.js.map` file. [`inlineSources`](https://www.typescriptlang.org/tsconfig#inlineSources) allows for additionally inlining the source `.ts` file into the `.js` file.",
    "title": "TypeScript: Documentation - TypeScript 1.5",
    "description": "TypeScript 1.5 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html",
    "markdown": "# TypeScript: Documentation - TypeScript 2.0\n\n## [](#null--and-undefined-aware-types)Null- and undefined-aware types\n\nTypeScript has two special types, Null and Undefined, that have the values `null` and `undefined` respectively. Previously it was not possible to explicitly name these types, but `null` and `undefined` may now be used as type names regardless of type checking mode.\n\nThe type checker previously considered `null` and `undefined` assignable to anything. Effectively, `null` and `undefined` were valid values of _every_ type and it wasn’t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).\n\n## [](#--strictnullchecks)`--strictNullChecks`\n\n[`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) switches to a new strict null checking mode.\n\nIn strict null checking mode, the `null` and `undefined` values are _not_ in the domain of every type and are only assignable to themselves and `any` (the one exception being that `undefined` is also assignable to `void`). So, whereas `T` and `T | undefined` are considered synonymous in regular type checking mode (because `undefined` is considered a subtype of any `T`), they are different types in strict type checking mode, and only `T | undefined` permits `undefined` values. The same is true for the relationship of `T` to `T | null`.\n\n##### [](#example)Example\n\nts\n\n`// Compiled with --strictNullChecks`\n\n`let x: number;`\n\n`let y: number | undefined;`\n\n`let z: number | null | undefined;`\n\n`x = 1; // Ok`\n\n`y = 1; // Ok`\n\n`z = 1; // Ok`\n\n`x = undefined; // Error`\n\n`y = undefined; // Ok`\n\n`z = undefined; // Ok`\n\n`x = null; // Error`\n\n`y = null; // Error`\n\n`z = null; // Ok`\n\n`x = y; // Error`\n\n`x = z; // Error`\n\n`y = x; // Ok`\n\n`y = z; // Error`\n\n`z = x; // Ok`\n\n`z = y; // Ok`\n\n## [](#assigned-before-use-checking)Assigned-before-use checking\n\nIn strict null checking mode the compiler requires every reference to a local variable of a type that doesn’t include `undefined` to be preceded by an assignment to that variable in every possible preceding code path.\n\n##### [](#example-1)Example\n\nts\n\n`// Compiled with --strictNullChecks`\n\n`let x: number;`\n\n`let y: number | null;`\n\n`let z: number | undefined;`\n\n`x; // Error, reference not preceded by assignment`\n\n`y; // Error, reference not preceded by assignment`\n\n`z; // Ok`\n\n`x = 1;`\n\n`y = null;`\n\n`x; // Ok`\n\n`y; // Ok`\n\nThe compiler checks that variables are definitely assigned by performing _control flow based type analysis_. See later for further details on this topic.\n\n## [](#optional-parameters-and-properties)Optional parameters and properties\n\nOptional parameters and properties automatically have `undefined` added to their types, even when their type annotations don’t specifically include `undefined`. For example, the following two types are identical:\n\nts\n\n`// Compiled with --strictNullChecks`\n\n`type T1 = (x?: number) => string; // x has type number | undefined`\n\n`type T2 = (x?: number | undefined) => string; // x has type number | undefined`\n\n## [](#non-null-and-non-undefined-type-guards)Non-null and non-undefined type guards\n\nA property access or a function call produces a compile-time error if the object or function is of a type that includes `null` or `undefined`. However, type guards are extended to support non-null and non-undefined checks.\n\n##### [](#example-2)Example\n\nts\n\n`// Compiled with --strictNullChecks`\n\n`declare function f(x: number): string;`\n\n`let x: number | null | undefined;`\n\n`if (x) {`\n\n  `f(x); // Ok, type of x is number here`\n\n`} else {`\n\n  `f(x); // Error, type of x is number? here`\n\n`}`\n\n`let a = x != null ? f(x) : \"\"; // Type of a is string`\n\n`let b = x && f(x); // Type of b is string | 0 | null | undefined`\n\nNon-null and non-undefined type guards may use the `==`, `!=`, `===`, or `!==` operator to compare to `null` or `undefined`, as in `x != null` or `x === undefined`. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).\n\n## [](#dotted-names-in-type-guards)Dotted names in type guards\n\nType guards previously only supported checking local variables and parameters. Type guards now support checking “dotted names” consisting of a variable or parameter name followed one or more property accesses.\n\n##### [](#example-3)Example\n\nts\n\n`interface Options {`\n\n  `location?: {`\n\n    `x?: number;`\n\n    `y?: number;`\n\n  `};`\n\n`}`\n\n`function foo(options?: Options) {`\n\n  `if (options && options.location && options.location.x) {`\n\n    `const x = options.location.x; // Type of x is number`\n\n  `}`\n\n`}`\n\nType guards for dotted names also work with user defined type guard functions and the `typeof` and `instanceof` operators and do not depend on the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) compiler option.\n\nA type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for `x.y.z` will have no effect following an assignment to `x`, `x.y`, or `x.y.z`.\n\n## [](#expression-operators)Expression operators\n\nExpression operators permit operand types to include `null` and/or `undefined` but always produce values of non-null and non-undefined types.\n\nts\n\n`// Compiled with --strictNullChecks`\n\n`function sum(a: number | null, b: number | null) {`\n\n  `return a + b; // Produces value of type number`\n\n`}`\n\nThe `&&` operator adds `null` and/or `undefined` to the type of the right operand depending on which are present in the type of the left operand, and the `||` operator removes both `null` and `undefined` from the type of the left operand in the resulting union type.\n\nts\n\n`// Compiled with --strictNullChecks`\n\n`interface Entity {`\n\n  `name: string;`\n\n`}`\n\n`let x: Entity | null;`\n\n`let s = x && x.name; // s is of type string | null`\n\n`let y = x || { name: \"test\" }; // y is of type Entity`\n\n## [](#type-widening)Type widening\n\nThe `null` and `undefined` types are _not_ widened to `any` in strict null checking mode.\n\nts\n\n`let z = null; // Type of z is null`\n\nIn regular type checking mode the inferred type of `z` is `any` because of widening, but in strict null checking mode the inferred type of `z` is `null` (and therefore, absent a type annotation, `null` is the only possible value for `z`).\n\n## [](#non-null-assertion-operator)Non-null assertion operator\n\nA new `!` post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation `x!` produces a value of the type of `x` with `null` and `undefined` excluded. Similar to type assertions of the forms `<T>x` and `x as T`, the `!` non-null assertion operator is simply removed in the emitted JavaScript code.\n\nts\n\n`// Compiled with --strictNullChecks`\n\n`function validateEntity(e?: Entity) {`\n\n  `// Throw exception if e is null or invalid entity`\n\n`}`\n\n`function processEntity(e?: Entity) {`\n\n  `validateEntity(e);`\n\n  `let s = e!.name; // Assert that e is non-null and access name`\n\n`}`\n\n## [](#compatibility)Compatibility\n\nThe new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the `null` and `undefined` types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the `!` non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.\n\nIn practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.\n\n## [](#control-flow-based-type-analysis)Control flow based type analysis\n\nTypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to `if` statements and `?:` conditional expressions and didn’t include effects of assignments and control flow constructs such as `return` and `break` statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the _narrowed type_) at any given location for a local variable or parameter that is declared to have a union type.\n\n##### [](#example-4)Example\n\nts\n\n`function foo(x: string | number | boolean) {`\n\n  `if (typeof x === \"string\") {`\n\n    `x; // type of x is string here`\n\n    `x = 1;`\n\n    `x; // type of x is number here`\n\n  `}`\n\n  `x; // type of x is number | boolean here`\n\n`}`\n\n`function bar(x: string | number) {`\n\n  `if (typeof x === \"number\") {`\n\n    `return;`\n\n  `}`\n\n  `x; // type of x is string here`\n\n`}`\n\nControl flow based type analysis is particularly relevant in [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) mode because nullable types are represented using union types:\n\nts\n\n`function test(x: string | null) {`\n\n  `if (x === null) {`\n\n    `return;`\n\n  `}`\n\n  `x; // type of x is string in remainder of function`\n\n`}`\n\nFurthermore, in [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) mode, control flow based type analysis includes _definite assignment analysis_ for local variables of types that don’t permit the value `undefined`.\n\nts\n\n`function mumble(check: boolean) {`\n\n  `let x: number; // Type doesn't permit undefined`\n\n  `x; // Error, x is undefined`\n\n  `if (check) {`\n\n    `x = 1;`\n\n    `x; // Ok`\n\n  `}`\n\n  `x; // Error, x is possibly undefined`\n\n  `x = 2;`\n\n  `x; // Ok`\n\n`}`\n\n## [](#tagged-union-types)Tagged union types\n\nTypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to `switch` statements.\n\n##### [](#example-5)Example\n\nts\n\n`interface Square {`\n\n  `kind: \"square\";`\n\n  `size: number;`\n\n`}`\n\n`interface Rectangle {`\n\n  `kind: \"rectangle\";`\n\n  `width: number;`\n\n  `height: number;`\n\n`}`\n\n`interface Circle {`\n\n  `kind: \"circle\";`\n\n  `radius: number;`\n\n`}`\n\n`type Shape = Square | Rectangle | Circle;`\n\n`function area(s: Shape) {`\n\n  `// In the following switch statement, the type of s is narrowed in each case clause`\n\n  `// according to the value of the discriminant property, thus allowing the other properties`\n\n  `// of that variant to be accessed without a type assertion.`\n\n  `switch (s.kind) {`\n\n    `case \"square\":`\n\n      `return s.size * s.size;`\n\n    `case \"rectangle\":`\n\n      `return s.width * s.height;`\n\n    `case \"circle\":`\n\n      `return Math.PI * s.radius * s.radius;`\n\n  `}`\n\n`}`\n\n`function test1(s: Shape) {`\n\n  `if (s.kind === \"square\") {`\n\n    `s; // Square`\n\n  `} else {`\n\n    `s; // Rectangle | Circle`\n\n  `}`\n\n`}`\n\n`function test2(s: Shape) {`\n\n  `if (s.kind === \"square\" || s.kind === \"rectangle\") {`\n\n    `return;`\n\n  `}`\n\n  `s; // Circle`\n\n`}`\n\nA _discriminant property type guard_ is an expression of the form `x.p == v`, `x.p === v`, `x.p != v`, or `x.p !== v`, where `p` and `v` are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of `x` to those constituent types of `x` that have a discriminant property `p` with one of the possible values of `v`.\n\nNote that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.\n\n## [](#the-never-type)The `never` type\n\nTypeScript 2.0 introduces a new primitive type `never`. The `never` type represents the type of values that never occur. Specifically, `never` is the return type for functions that never return and `never` is the type of variables under type guards that are never true.\n\nThe `never` type has the following characteristics:\n\n*   `never` is a subtype of and assignable to every type.\n*   No type is a subtype of or assignable to `never` (except `never` itself).\n*   In a function expression or arrow function with no return type annotation, if the function has no `return` statements, or only `return` statements with expressions of type `never`, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is `never`.\n*   In a function with an explicit `never` return type annotation, all `return` statements (if any) must have expressions of type `never` and the end point of the function must not be reachable.\n\nBecause `never` is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.\n\nSome examples of functions returning `never`:\n\nts\n\n`// Function returning never must have unreachable end point`\n\n`function error(message: string): never {`\n\n  `throw new Error(message);`\n\n`}`\n\n`// Inferred return type is never`\n\n`function fail() {`\n\n  `return error(\"Something failed\");`\n\n`}`\n\n`// Function returning never must have unreachable end point`\n\n`function infiniteLoop(): never {`\n\n  `while (true) {}`\n\n`}`\n\nSome examples of use of functions returning `never`:\n\nts\n\n`// Inferred return type is number`\n\n`function move1(direction: \"up\" | \"down\") {`\n\n  `switch (direction) {`\n\n    `case \"up\":`\n\n      `return 1;`\n\n    `case \"down\":`\n\n      `return -1;`\n\n  `}`\n\n  `return error(\"Should never get here\");`\n\n`}`\n\n`// Inferred return type is number`\n\n`function move2(direction: \"up\" | \"down\") {`\n\n  `return direction === \"up\"`\n\n    `? 1`\n\n    `: direction === \"down\"`\n\n    `? -1`\n\n    `: error(\"Should never get here\");`\n\n`}`\n\n`// Inferred return type is T`\n\n`function check<T>(x: T | undefined) {`\n\n  `return x || error(\"Undefined value\");`\n\n`}`\n\nBecause `never` is assignable to every type, a function returning `never` can be used when a callback returning a more specific type is required:\n\nts\n\n`function test(cb: () => string) {`\n\n  `let s = cb();`\n\n  `return s;`\n\n`}`\n\n`test(() => \"hello\");`\n\n`test(() => fail());`\n\n`test(() => {`\n\n  `throw new Error();`\n\n`});`\n\n## [](#read-only-properties-and-index-signatures)Read-only properties and index signatures\n\nA property or index signature can now be declared with the `readonly` modifier.\n\nRead-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.\n\nIn addition, entities are _implicitly_ read-only in several situations:\n\n*   A property declared with a `get` accessor and no `set` accessor is considered read-only.\n*   In the type of an enum object, enum members are considered read-only properties.\n*   In the type of a module object, exported `const` variables are considered read-only properties.\n*   An entity declared in an `import` statement is considered read-only.\n*   An entity accessed through an ES2015 namespace import is considered read-only (e.g. `foo.x` is read-only when `foo` is declared as `import * as foo from \"foo\"`).\n\n##### [](#example-6)Example\n\nts\n\n`interface Point {`\n\n  `readonly x: number;`\n\n  `readonly y: number;`\n\n`}`\n\n`var p1: Point = { x: 10, y: 20 };`\n\n`p1.x = 5; // Error, p1.x is read-only`\n\n`var p2 = { x: 1, y: 1 };`\n\n`var p3: Point = p2; // Ok, read-only alias for p2`\n\n`p3.x = 5; // Error, p3.x is read-only`\n\n`p2.x = 5; // Ok, but also changes p3.x because of aliasing`\n\nts\n\n`class Foo {`\n\n  `readonly a = 1;`\n\n  `readonly b: string;`\n\n  `constructor() {`\n\n    `this.b = \"hello\"; // Assignment permitted in constructor`\n\n  `}`\n\n`}`\n\nts\n\n`let a: Array<number> = [0, 1, 2, 3, 4];`\n\n`let b: ReadonlyArray<number> = a;`\n\n`b[5] = 5; // Error, elements are read-only`\n\n`b.push(5); // Error, no push method (because it mutates array)`\n\n`b.length = 3; // Error, length is read-only`\n\n`a = b; // Error, mutating methods are missing`\n\n## [](#specifying-the-type-of-this-for-functions)Specifying the type of `this` for functions\n\nFollowing up on specifying the type of `this` in a class or an interface, functions and methods can now declare the type of `this` they expect.\n\nBy default the type of `this` inside a function is `any`. Starting with TypeScript 2.0, you can provide an explicit `this` parameter. `this` parameters are fake parameters that come first in the parameter list of a function:\n\nts\n\n`function f(this: void) {`\n\n  ``// make sure `this` is unusable in this standalone function``\n\n`}`\n\n## [](#this-parameters-in-callbacks)`this` parameters in callbacks\n\nLibraries can also use `this` parameters to declare how callbacks will be invoked.\n\n##### [](#example-7)Example\n\nts\n\n`interface UIElement {`\n\n  `addClickListener(onclick: (this: void, e: Event) => void): void;`\n\n`}`\n\n`this: void` means that `addClickListener` expects `onclick` to be a function that does not require a `this` type.\n\nNow if you annotate calling code with `this`:\n\nts\n\n`class Handler {`\n\n  `info: string;`\n\n  `onClickBad(this: Handler, e: Event) {`\n\n    `// oops, used this here. using this callback would crash at runtime`\n\n    `this.info = e.message;`\n\n  `}`\n\n`}`\n\n`let h = new Handler();`\n\n`uiElement.addClickListener(h.onClickBad); // error!`\n\n## [](#--noimplicitthis)`--noImplicitThis`\n\nA new flag is also added in TypeScript 2.0 to flag all uses of `this` in functions without an explicit type annotation.\n\n## [](#glob-support-in-tsconfigjson)Glob support in `tsconfig.json`\n\nGlob support is here!! Glob support has been [one of the most requested features](https://github.com/Microsoft/TypeScript/issues/1927).\n\nGlob-like file patterns are supported two properties [`include`](https://www.typescriptlang.org/tsconfig#include) and [`exclude`](https://www.typescriptlang.org/tsconfig#exclude).\n\n##### [](#example-8)Example\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"commonjs\",`\n\n    `\"\": true,`\n\n    `\"\": true,`\n\n    `\"\": true,`\n\n    `\"\": \"../../built/local/tsc.js\",`\n\n    `\"\": true`\n\n  `},`\n\n  `\"\": [\"src/**/*\"],`\n\n  `\"\": [\"node_modules\", \"**/*.spec.ts\"]`\n\n`}`\n\nThe supported glob wildcards are:\n\n*   `*` matches zero or more characters (excluding directory separators)\n*   `?` matches any one character (excluding directory separators)\n*   `**/` recursively matches any subdirectory\n\nIf a segment of a glob pattern includes only `*` or `.*`, then only files with supported extensions are included (e.g. `.ts`, `.tsx`, and `.d.ts` by default with `.js` and `.jsx` if [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs) is set to true).\n\nIf the [`files`](https://www.typescriptlang.org/tsconfig#files) and [`include`](https://www.typescriptlang.org/tsconfig#include) are both left unspecified, the compiler defaults to including all TypeScript (`.ts`, `.d.ts` and `.tsx`) files in the containing directory and subdirectories except those excluded using the [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) property. JS files (`.js` and `.jsx`) are also included if [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs) is set to true.\n\nIf the [`files`](https://www.typescriptlang.org/tsconfig#files) or [`include`](https://www.typescriptlang.org/tsconfig#include) properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the [`outDir`](https://www.typescriptlang.org/tsconfig#outDir) compiler option are always excluded unless explicitly included via the [`files`](https://www.typescriptlang.org/tsconfig#files) property (even when the [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) property is specified).\n\nFiles included using [`include`](https://www.typescriptlang.org/tsconfig#include) can be filtered using the [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) property. However, files included explicitly using the [`files`](https://www.typescriptlang.org/tsconfig#files) property are always included regardless of [`exclude`](https://www.typescriptlang.org/tsconfig#exclude). The [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) property defaults to excluding the `node_modules`, `bower_components`, and `jspm_packages` directories when not specified.\n\n## [](#module-resolution-enhancements-baseurl-path-mapping-rootdirs-and-tracing)Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing\n\nTypeScript 2.0 provides a set of additional module resolution knops to _inform_ the compiler where to find declarations for a given module.\n\nSee [Module Resolution](http://www.typescriptlang.org/docs/handbook/module-resolution.html) documentation for more details.\n\n## [](#base-url)Base URL\n\nUsing a [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl) is a common practice in applications using AMD module loaders where modules are “deployed” to a single folder at run-time. All module imports with bare specifier names are assumed to be relative to the [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl).\n\n##### [](#example-9)Example\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"./modules\"`\n\n  `}`\n\n`}`\n\nNow imports to `\"moduleA\"` would be looked up in `./modules/moduleA`\n\nts\n\n`import A from \"moduleA\";`\n\n## [](#path-mapping)Path mapping\n\nSometimes modules are not directly located under _baseUrl_. Loaders use a mapping configuration to map module names to files at run-time, see [RequireJs documentation](http://requirejs.org/docs/api.html#config-paths) and [SystemJS documentation](https://github.com/systemjs/systemjs/blob/main/docs/import-maps.md).\n\nThe TypeScript compiler supports the declaration of such mappings using [`paths`](https://www.typescriptlang.org/tsconfig#paths) property in `tsconfig.json` files.\n\n##### [](#example-10)Example\n\nFor instance, an import to a module `\"jquery\"` would be translated at runtime to `\"node_modules/jquery/dist/jquery.slim.min.js\"`.\n\n`{`\n\n  `\"\": {`\n\n    `\"\": \"./node_modules\",`\n\n    `\"\": {`\n\n      `\"jquery\": [\"jquery/dist/jquery.slim.min\"]`\n\n    `}`\n\n`}`\n\nUsing [`paths`](https://www.typescriptlang.org/tsconfig#paths) also allow for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another.\n\n## [](#virtual-directories-with-rootdirs)Virtual Directories with `rootDirs`\n\nUsing ‘rootDirs’, you can inform the compiler of the _roots_ making up this “virtual” directory; and thus the compiler can resolve relative modules imports within these “virtual” directories _as if_ they were merged together in one directory.\n\n##### [](#example-11)Example\n\nGiven this project structure:\n\n `src  └── views      └── view1.ts (imports './template1')      └── view2.ts   generated  └── templates          └── views              └── template1.ts (imports './view2')`\n\nA build step will copy the files in `/src/views` and `/generated/templates/views` to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as `\"./template\"`.\n\n[`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs) specify a list of _roots_ whose contents are expected to merge at run-time. So following our example, the `tsconfig.json` file should look like:\n\n`{`\n\n  `\"\": {`\n\n    `\"\": [\"src/views\", \"generated/templates/views\"]`\n\n  `}`\n\n`}`\n\n## [](#tracing-module-resolution)Tracing module resolution\n\n[`traceResolution`](https://www.typescriptlang.org/tsconfig#traceResolution) offers a handy way to understand how modules have been resolved by the compiler.\n\nshell\n\n`tsc --traceResolution`\n\n## [](#shorthand-ambient-module-declarations)Shorthand ambient module declarations\n\nIf you don’t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.\n\n##### [](#declarationsdts)declarations.d.ts\n\nts\n\n`declare module \"hot-new-module\";`\n\nAll imports from a shorthand module will have the any type.\n\nts\n\n`import x, { y } from \"hot-new-module\";`\n\n`x(y);`\n\n## [](#wildcard-character-in-module-names)Wildcard character in module names\n\nImporting none-code resources using module loaders extension (e.g. [AMD](https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md) or [SystemJS](https://github.com/systemjs/systemjs/blob/main/docs/module-types.md)) has not been easy before; previously an ambient module declaration had to be defined for each resource.\n\nTypeScript 2.0 supports the use of the wildcard character (`*`) to declare a “family” of module names; this way, a declaration is only required once for an extension, and not for every resource.\n\n##### [](#example-12)Example\n\nts\n\n`declare module \"*!text\" {`\n\n  `const content: string;`\n\n  `export default content;`\n\n`}`\n\n`// Some do it the other way around.`\n\n`declare module \"json!*\" {`\n\n  `const value: any;`\n\n  `export default value;`\n\n`}`\n\nNow you can import things that match `\"*!text\"` or `\"json!*\"`.\n\nts\n\n`import fileContent from \"./xyz.txt!text\";`\n\n`import data from \"json!http://example.com/data.json\";`\n\n`console.log(data, fileContent);`\n\nWildcard module names can be even more useful when migrating from an un-typed code base. Combined with Shorthand ambient module declarations, a set of modules can be easily declared as `any`.\n\n##### [](#example-13)Example\n\nts\n\n`declare module \"myLibrary/*\";`\n\nAll imports to any module under `myLibrary` would be considered to have the type `any` by the compiler; thus, shutting down any checking on the shapes or types of these modules.\n\nts\n\n``import { readFile } from \"myLibrary/fileSystem/readFile`;``\n\n`readFile(); // readFile is 'any'`\n\n## [](#support-for-umd-module-definitions)Support for UMD module definitions\n\nSome libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as [UMD](https://github.com/umdjs/umd) or [Isomorphic](http://isomorphic.net/) modules. These libraries can be accessed through either an import or a global variable.\n\nFor example:\n\n##### [](#math-libdts)math-lib.d.ts\n\nts\n\n`export const isPrime(x: number): boolean;`\n\n`export as namespace mathLib;`\n\nThe library can then be used as an import within modules:\n\nts\n\n`import { isPrime } from \"math-lib\";`\n\n`isPrime(2);`\n\n`mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module`\n\nIt can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)\n\nts\n\n`mathLib.isPrime(2);`\n\n## [](#optional-class-properties)Optional class properties\n\nOptional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.\n\n##### [](#example-14)Example\n\nts\n\n`class Bar {`\n\n  `a: number;`\n\n  `b?: number;`\n\n  `f() {`\n\n    `return 1;`\n\n  `}`\n\n  `g?(): number; // Body of optional method can be omitted`\n\n  `h?() {`\n\n    `return 2;`\n\n  `}`\n\n`}`\n\nWhen compiled in [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) mode, optional properties and methods automatically have `undefined` included in their type. Thus, the `b` property above is of type `number | undefined` and the `g` method above is of type `(() => number) | undefined`. Type guards can be used to strip away the `undefined` part of the type:\n\nts\n\n`function test(x: Bar) {`\n\n  `x.a; // number`\n\n  `x.b; // number | undefined`\n\n  `x.f; // () => number`\n\n  `x.g; // (() => number) | undefined`\n\n  `let f1 = x.f(); // number`\n\n  `let g1 = x.g && x.g(); // number | undefined`\n\n  `let g2 = x.g ? x.g() : 0; // number`\n\n`}`\n\n## [](#private-and-protected-constructors)Private and Protected Constructors\n\nA class constructor may be marked `private` or `protected`. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.\n\n##### [](#example-15)Example\n\nts\n\n`class Singleton {`\n\n  `private static instance: Singleton;`\n\n  `private constructor() {}`\n\n  `static getInstance() {`\n\n    `if (!Singleton.instance) {`\n\n      `Singleton.instance = new Singleton();`\n\n    `}`\n\n    `return Singleton.instance;`\n\n  `}`\n\n`}`\n\n`let e = new Singleton(); // Error: constructor of 'Singleton' is private.`\n\n`let v = Singleton.getInstance();`\n\n## [](#abstract-properties-and-accessors)Abstract properties and accessors\n\nAn abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.\n\n##### [](#example-16)Example\n\nts\n\n`abstract class Base {`\n\n  `abstract name: string;`\n\n  `abstract get value();`\n\n  `abstract set value(v: number);`\n\n`}`\n\n`class Derived extends Base {`\n\n  `name = \"derived\";`\n\n  `value = 1;`\n\n`}`\n\n## [](#implicit-index-signatures)Implicit index signatures\n\nAn object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:\n\nts\n\n`function httpService(path: string, headers: { [x: string]: string }) {}`\n\n`const headers = {`\n\n  `\"Content-Type\": \"application/x-www-form-urlencoded\",`\n\n`};`\n\n`httpService(\"\", { \"Content-Type\": \"application/x-www-form-urlencoded\" }); // Ok`\n\n`httpService(\"\", headers); // Now ok, previously wasn't`\n\n## [](#including-built-in-type-declarations-with---lib)Including built-in type declarations with `--lib`\n\nGetting to ES6/ES2015 built-in API declarations were only limited to `target: ES6`. Enter [`lib`](https://www.typescriptlang.org/tsconfig#lib); with [`lib`](https://www.typescriptlang.org/tsconfig#lib) you can specify a list of built-in API declaration groups that you can choose to include in your project. For instance, if you expect your runtime to have support for `Map`, `Set` and `Promise` (e.g. most evergreen browsers today), just include `--lib es2015.collection,es2015.promise`. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using `--lib es5,es6`.\n\nHere is a list of available API groups:\n\n*   dom\n*   webworker\n*   es5\n*   es6 / es2015\n*   es2015.core\n*   es2015.collection\n*   es2015.iterable\n*   es2015.promise\n*   es2015.proxy\n*   es2015.reflect\n*   es2015.generator\n*   es2015.symbol\n*   es2015.symbol.wellknown\n*   es2016\n*   es2016.array.include\n*   es2017\n*   es2017.object\n*   es2017.sharedmemory\n*   scripthost\n\n##### [](#example-17)Example\n\nbash\n\n`tsc --target es5 --lib es5,es2015.promise`\n\n`\"compilerOptions\": {`\n\n    `\"\": [\"es5\", \"es2015.promise\"]`\n\n`}`\n\n## [](#flag-unused-declarations-with---nounusedparameters-and---nounusedlocals)Flag unused declarations with `--noUnusedParameters` and `--noUnusedLocals`\n\nTypeScript 2.0 has two new flags to help you maintain a clean code base. [`noUnusedParameters`](https://www.typescriptlang.org/tsconfig#noUnusedParameters) flags any unused function or method parameters errors. [`noUnusedLocals`](https://www.typescriptlang.org/tsconfig#noUnusedLocals) flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc… Also, unused private members of a class would be flagged as errors under [`noUnusedLocals`](https://www.typescriptlang.org/tsconfig#noUnusedLocals).\n\n##### [](#example-18)Example\n\nts\n\n`import B, { readFile } from \"./b\";`\n\n``//     ^ Error: `B` declared but never used``\n\n`readFile();`\n\n`export function write(message: string, args: string[]) {`\n\n  `//                                 ^^^^  Error: 'arg' declared but never used.`\n\n  `console.log(message);`\n\n`}`\n\nParameters declaration with names starting with `_` are exempt from the unused parameter checking. e.g.:\n\nts\n\n`function returnNull(_a) {`\n\n  `// OK`\n\n  `return null;`\n\n`}`\n\n## [](#module-identifiers-allow-for-js-extension)Module identifiers allow for `.js` extension\n\nBefore TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as `import d from \"./moduleA.js\"`, the compiler looked up the definition of `\"moduleA.js\"` in `./moduleA.js.ts` or `./moduleA.js.d.ts`. This made it hard to use bundling/loading tools like [SystemJS](https://github.com/systemjs/systemjs) that expect URI’s in their module identifier.\n\nWith TypeScript 2.0, the compiler will look up definition of `\"moduleA.js\"` in `./moduleA.ts` or `./moduleA.d.t`.\n\n## [](#support-target--es5-with-module-es6)Support ‘target : es5’ with ‘module: es6’\n\nPreviously flagged as an invalid flag combination, `target: es5` and ‘module: es6’ is now supported. This should facilitate using ES2015-based tree shakers like [rollup](https://github.com/rollup/rollup).\n\n## [](#trailing-commas-in-function-parameter-and-argument-lists)Trailing commas in function parameter and argument lists\n\nTrailing comma in function parameter and argument lists are now allowed. This is an implementation for a [Stage-3 ECMAScript proposal](https://jeffmo.github.io/es-trailing-function-commas/) that emits down to valid ES3/ES5/ES6.\n\n##### [](#example-19)Example\n\nts\n\n`function foo(`\n\n  `bar: Bar,`\n\n  `baz: Baz // trailing commas are OK in parameter lists`\n\n`) {`\n\n  `// Implementation...`\n\n`}`\n\n`foo(`\n\n  `bar,`\n\n  `baz // and in argument lists`\n\n`);`\n\n## [](#new---skiplibcheck)New `--skipLibCheck`\n\nTypeScript 2.0 adds a new [`skipLibCheck`](https://www.typescriptlang.org/tsconfig#skipLibCheck) compiler option that causes type checking of declaration files (files with extension `.d.ts`) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.\n\nSince declarations in one file can affect type checking in other files, some errors may not be detected when [`skipLibCheck`](https://www.typescriptlang.org/tsconfig#skipLibCheck) is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.\n\n## [](#allow-duplicate-identifiers-across-declarations)Allow duplicate identifiers across declarations\n\nThis has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.\n\nTypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have _identical_ types.\n\nWithin the same block duplicate definitions are still disallowed.\n\n##### [](#example-20)Example\n\nts\n\n`interface Error {`\n\n  `stack?: string;`\n\n`}`\n\n`interface Error {`\n\n  `code?: string;`\n\n  `path?: string;`\n\n  `stack?: string; // OK`\n\n`}`\n\n## [](#new---declarationdir)New `--declarationDir`\n\n[`declarationDir`](https://www.typescriptlang.org/tsconfig#declarationDir) allows for generating declaration files in a different location than JavaScript files.",
    "title": "TypeScript: Documentation - TypeScript 2.0",
    "description": "TypeScript 2.0 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html",
    "markdown": "# TypeScript: Documentation - TypeScript 1.4\n\n## [](#union-types)Union types\n\n### [](#overview)Overview\n\nUnion types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a `string`, a `string[]` or a function that returns a `string`. You can now write:\n\nts\n\n`interface RunOptions {`\n\n  `program: string;`\n\n  `commandline: string[] | string | (() => string);`\n\n`}`\n\nAssignment to union types works very intuitively — anything you could assign to one of the union type’s members is assignable to the union:\n\nts\n\n`var opts: RunOptions = /* ... */;`\n\n`opts.commandline = '-hello world'; // OK`\n\n`opts.commandline = ['-hello', 'world']; // OK`\n\n`opts.commandline = [42]; // Error, number is not string or string[]`\n\nWhen reading from a union type, you can see any properties that are shared by them:\n\nts\n\n`if (opts.commandline.length === 0) {`\n\n  `// OK, string and string[] both have 'length' property`\n\n  `console.log(\"it's empty\");`\n\n`}`\n\nUsing Type Guards, you can easily work with a variable of a union type:\n\nts\n\n`function formatCommandline(c: string | string[]) {`\n\n  `if (typeof c === \"string\") {`\n\n    `return c.trim();`\n\n  `} else {`\n\n    `return c.join(\" \");`\n\n  `}`\n\n`}`\n\n### [](#stricter-generics)Stricter Generics\n\nWith union types able to represent a wide range of type scenarios, we’ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:\n\nts\n\n`function equal<T>(lhs: T, rhs: T): boolean {`\n\n  `return lhs === rhs;`\n\n`}`\n\n`// Previously: No error`\n\n`// New behavior: Error, no best common type between 'string' and 'number'`\n\n`var e = equal(42, \"hello\");`\n\nWith union types, you can now specify the desired behavior at both the function declaration site and the call site:\n\nts\n\n`// 'choose' function where types must match`\n\n`function choose1<T>(a: T, b: T): T {`\n\n  `return Math.random() > 0.5 ? a : b;`\n\n`}`\n\n`var a = choose1(\"hello\", 42); // Error`\n\n`var b = choose1<string | number>(\"hello\", 42); // OK`\n\n`// 'choose' function where types need not match`\n\n`function choose2<T, U>(a: T, b: U): T | U {`\n\n  `return Math.random() > 0.5 ? a : b;`\n\n`}`\n\n`var c = choose2(\"bar\", \"foo\"); // OK, c: string`\n\n`var d = choose2(\"hello\", 42); // OK, d: string|number`\n\n### [](#better-type-inference)Better Type Inference\n\nUnion types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:\n\nts\n\n`var x = [1, \"hello\"]; // x: Array<string|number>`\n\n`x[0] = \"world\"; // OK`\n\n`x[0] = false; // Error, boolean is not string or number`\n\n## [](#let-declarations)`let` declarations\n\nIn JavaScript, `var` declarations are “hoisted” to the top of their enclosing scope. This can result in confusing bugs:\n\nts\n\n`console.log(x); // meant to write 'y' here`\n\n`/* later in the same block */`\n\n`var x = \"hello\";`\n\nThe new ES6 keyword `let`, now supported in TypeScript, declares a variable with more intuitive “block” semantics. A `let` variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:\n\nts\n\n`if (foo) {`\n\n  `console.log(x); // Error, cannot refer to x before its declaration`\n\n  `let x = \"hello\";`\n\n`} else {`\n\n  `console.log(x); // Error, x is not declared in this block`\n\n`}`\n\n`let` is only available when targeting ECMAScript 6 (`--target ES6`).\n\n## [](#const-declarations)`const` declarations\n\nThe other new ES6 declaration type supported in TypeScript is `const`. A `const` variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don’t want to change the value after its initialization:\n\nts\n\n`const halfPi = Math.PI / 2;`\n\n`` halfPi = 2; // Error, can't assign to a `const` ``\n\n`const` is only available when targeting ECMAScript 6 (`--target ES6`).\n\n## [](#template-strings)Template strings\n\nTypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:\n\nts\n\n`var name = \"TypeScript\";`\n\n``var greeting = `Hello, ${name}! Your name has ${name.length} characters`;``\n\nWhen compiling to pre-ES6 targets, the string is decomposed:\n\njs\n\n`var name = \"TypeScript!\";`\n\n`var greeting =`\n\n  `\"Hello, \" + name + \"! Your name has \" + name.length + \" characters\";`\n\n## [](#type-guards)Type Guards\n\nA common pattern in JavaScript is to use `typeof` or `instanceof` to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an `if` block.\n\nUsing `typeof` to test a variable:\n\nts\n\n`var x: any = /* ... */;`\n\n`if(typeof x === 'string') {`\n\n    `console.log(x.subtr(1)); // Error, 'subtr' does not exist on 'string'`\n\n`}`\n\n`// x is still any here`\n\n`x.unknown(); // OK`\n\nUsing `typeof` with union types and `else`:\n\nts\n\n`var x: string | HTMLElement = /* ... */;`\n\n`if(typeof x === 'string') {`\n\n    `// x is string here, as shown above`\n\n`}`\n\n`else {`\n\n    `// x is HTMLElement here`\n\n    `console.log(x.innerHTML);`\n\n`}`\n\nUsing `instanceof` with classes and union types:\n\nts\n\n`class Dog { woof() { } }`\n\n`class Cat { meow() { } }`\n\n`var pet: Dog|Cat = /* ... */;`\n\n`if (pet instanceof Dog) {`\n\n    `pet.woof(); // OK`\n\n`}`\n\n`else {`\n\n    `pet.woof(); // Error`\n\n`}`\n\n## [](#type-aliases)Type Aliases\n\nYou can now define an _alias_ for a type using the `type` keyword:\n\nts\n\n`type PrimitiveArray = Array<string | number | boolean>;`\n\n`type MyNumber = number;`\n\n`type NgScope = ng.IScope;`\n\n`type Callback = () => void;`\n\nType aliases are exactly the same as their original types; they are simply alternative names.\n\n## [](#const-enum-completely-inlined-enums)`const enum` (completely inlined enums)\n\nEnums are very useful, but some programs don’t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new `const enum` declaration works just like a regular `enum` for type safety, but erases completely at compile time.\n\nts\n\n`const enum Suit {`\n\n  `Clubs,`\n\n  `Diamonds,`\n\n  `Hearts,`\n\n  `Spades`\n\n`}`\n\n`var d = Suit.Diamonds;`\n\nCompiles to exactly:\n\njs\n\n`var d = 1;`\n\nTypeScript will also now compute enum values when possible:\n\nts\n\n`enum MyFlags {`\n\n  `None = 0,`\n\n  `Neat = 1,`\n\n  `Cool = 2,`\n\n  `Awesome = 4,`\n\n  `Best = Neat | Cool | Awesome`\n\n`}`\n\n`var b = MyFlags.Best; // emits var b = 7;`\n\n## [](#-noemitonerror-commandline-option)`-noEmitOnError` commandline option\n\nThe default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a `string` to a `number`). This can be undesirable on build servers or other scenarios where only output from a “clean” build is desired. The new flag [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) prevents the compiler from emitting .js code if there were any errors.\n\nThis is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.\n\n## [](#amd-module-names)AMD Module names\n\nBy default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. `r.js`).\n\nThe new `amd-module name` tag allows passing an optional module name to the compiler:\n\nts\n\n`//// [amdModule.ts]`\n\n`///<amd-module name='NamedModule'/>`\n\n`export class C {}`\n\nWill result in assigning the name `NamedModule` to the module as part of calling the AMD `define`:\n\njs\n\n`//// [amdModule.js]`\n\n`define(\"NamedModule\", [\"require\", \"exports\"], function(require, exports) {`\n\n  `var C = (function() {`\n\n    `function C() {}`\n\n    `return C;`\n\n  `})();`\n\n  `exports.C = C;`\n\n`});`",
    "title": "TypeScript: Documentation - TypeScript 1.4",
    "description": "TypeScript 1.3 Release Notes",
    "languageCode": "en"
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/modules.html",
    "markdown": null,
    "title": "",
    "description": null,
    "languageCode": null
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/react-&-webpack.html",
    "markdown": null,
    "title": "",
    "description": null,
    "languageCode": null
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html",
    "markdown": "# TypeScript: Documentation - Templates\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/Templates.md) ❤\n\nContributors to this page:\n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nLast updated: Jul 11, 2024",
    "title": "TypeScript: Documentation - Templates",
    "description": "Different d.ts module template examples",
    "languageCode": "en"
  },
  {
    "url": "http://www.typescriptlang.org/docs/handbook/module-resolution.html",
    "markdown": null,
    "title": "",
    "description": null,
    "languageCode": null
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1.6.html",
    "markdown": "# Page not found · GitHub Pages\n\n## 404\n\n**File not found**\n\nThe site configured at this address does not contain the requested file.\n\nIf this is your site, make sure that the filename case matches the URL as well as any file permissions.  \nFor root URLs (like `http://example.com/`) you must provide an `index.html` file.\n\n[Read the full documentation](https://help.github.com/pages/) for more information about using **GitHub Pages**.\n\n [![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMTZCRDY3REIzRjAxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMTZCRDY3RUIzRjAxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdCQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjdDQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+SM9MCAAAA+5JREFUeNrEV11Ik1EY3s4+ddOp29Q5b0opCgKFsoKoi5Kg6CIhuwi6zLJLoYLopq4qsKKgi4i6CYIoU/q5iDAKs6syoS76IRWtyJ+p7cdt7sf1PGOD+e0c3dygAx/67ZzzPM95/877GYdHRg3ZjMXFxepQKNS6sLCwJxqNNuFpiMfjVs4ZjUa/pmmjeD6VlJS8NpvNT4QQ7mxwjSsJiEQim/1+/9lgMHgIr5ohuxG1WCw9Vqv1clFR0dCqBODElV6v90ogEDjGdYbVjXhpaendioqK07CIR7ZAqE49PT09BPL2PMgTByQGsYiZlQD4uMXtdr+JxWINhgINYhGT2MsKgMrm2dnZXgRXhaHAg5jEJodUAHxux4LudHJE9RdEdA+i3Juz7bGHe4mhE9FNrgwBCLirMFV9Okh5eflFh8PR5nK5nDabrR2BNJlKO0T35+Li4n4+/J+/JQCxhmu5h3uJoXNHPbmWZAHMshWB8l5/ipqammaAf0zPDDx1ONV3vurdidqwAQL+pEc8sLcAe1CCvQ3YHxIW8Pl85xSWNC1hADDIv0rIE/o4J0k3kww4xSlwIhcq3EFFOm7KN/hUGOQkt0CFa5WpNJlMvxBEz/IVQAxg/ZRZl9wiHA63yDYieM7DnLP5CiAGsC7I5sgtYKJGWe2A8seFqgFJrJjEPY1Cn3pJ8/9W1e5VWsFDTEmFrBcoDhZJEQkXuhICMyKpjhahqN21hRYATKfUOlDmkygrR4o4C0VOLGJKrOITKB4jijzdXygBKixyC5TDQdnk/Pz8qRw6oOWGlsTKGOQW6OH6FBWsyePxdOXLTgxiyebILZCjz+GLgMIKnXNzc49YMlcRdHXcSwxFVgTInQhC9G33UhNoJLuqq6t345p9y3eUy8OTk5PjAHuI9uo4b07FBaOhsu0A4Unc+T1TU1Nj3KsSSE5yJ65jqF2DDd8QqWYmAZrIM2VlZTdnZmb6AbpdV9V6ec9znf5Q7HjYumdRE0JOp3MjitO4SFa+cZz8Umqe3TCbSLvdfkR/kWDdNQl5InuTcysOcpFT35ZrbBxx4p3JAHlZVVW1D/634VRt+FvLBgK/v5LV9WS+10xMTEwtRw7XvqOL+e2Q8V3AYIOIAXQ26/heWVnZCVfcyKHg2CBgTpmPmjYM8l24GyaUHyaIh7XwfR9ErE8qHoDfn2LTNAVC0HX6MFcBIP8Bi+6F6cdW/DICkANRfx99fEYFQ7Nph5i/uQiA214gno7K+guhaiKg9gC62+M8eR7XsBsYJ4ilam60Fb7r7uAj8wFyuwM1oIOWgfmDy6RXEEQzJMPe23DXrVS7rtyD3Df8z/FPgAEAzWU5Ku59ZAUAAAAASUVORK5CYII=)](https://www.typescriptlang.org/)[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEQUM1QkUxRUI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEQUM1QkUxRkI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdGQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjgwQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+hfPRaQAAB6lJREFUeNrsW2mME2UYbodtt+2222u35QheoCCYGBQligIJgkZJNPzgigoaTEj8AdFEMfADfyABkgWiiWcieK4S+QOiHAYUj2hMNKgYlEujpNttu9vttbvdw+chU1K6M535pt3ubHCSyezR+b73eb73+t7vrfXsufOW4bz6+vom9/b23ovnNNw34b5xYGAgODg46Mbt4mesVmsWd1qSpHhdXd2fuP/Afcput5/A88xwymcdBgLqenp6FuRyuWV4zu/v759QyWBjxoz5t76+/gun09mK5xFyakoCAPSaTCazNpvNPoYVbh6O1YKGRF0u13sNDQ27QMzfpiAAKj0lnU6/gBVfAZW2WWpwwVzy0IgP3G73FpjI6REhAGA9qVRqA1b9mVoBVyIC2tDi8Xg24+dUzQiAbS/s7Ox8G2o/3mKCC+Zw0efzPQEfcVjYrARX3dbV1bUtHo8fMgt42f+Mp0yUTVQbdWsAHVsikdiHkHaPxcQXQufXgUBgMRxme9U0AAxfH4vFvjM7eF6UkbJS5qoQwEQGA57Ac5JllFyUVZZ5ckUEgMVxsK2jlSYzI+QXJsiyjzNEAJyJAzb/KQa41jJKL8pODMQiTEAymXw5n8/P0IjD3bh7Rgog59aanxiIRTVvV/oj0tnHca/WMrVwODwB3raTGxzkBg/gnZVapFV62Wy2n5AO70HM/5wbJ0QnXyQSaVPDIuNZzY0V3ntHMwxiwHA0Gj2Np7ecIBDgaDAYXKCQJM1DhrgJ3nhulcPbl8j4NmHe46X/g60fwbz3aewjkqFQaAqebWU1AOqyQwt8Id6qEHMc97zu7u7FGGsn7HAiVuosVw7P35C1nccdgSCxop1dHeZswmfHMnxBo6ZTk+jN8dl/vF7vWofDsa+MLN9oEUBMxOb3+1eoEsBVw6Zmua49r8YmhAKDiEPcMwBsxMiqQ+ixzPFxZyqRpXARG/YOr1ObFJ0gUskXBbamcR1OKmMUvDxHRAu8/LmY3jFLMUpFqz9HxG65smYJdyKyECOxDiEAe/p1gjF2oonivZAsxVgl2daa4EQWCW6J55qFAFFZiJWYLxNQy2qOSUzGRsyXCUDIeliwAHEO4WSlWQBRFoZakXcKmCXmyXAKs0Ve9vl8q42WoIYpJU4hV3hKcNs8m9gl7p/xQ73eF5kB4j5mNrWmTJRNwAzqiV1CxjVTZCIkEq+Z1bZFZSN2CenmVAFVy4Plz8xKAGWjjAKFk6lCBMDR/MJjLLMSQNm43xAiQKTaA+9/wewhDjL+JVI1kkTSSOTcKbMTwPqESAot6dn6Fr1gHwVJju6IRuyiByPuUUBAg5DGkAgBmxlvdgIEK9gDkohdY/BJo4CAG0R8miRSsGABkgVQs4KXu098IgUXSSRsFAoKZiVAVDY2WUiiPTjYRi41KwGisrGsLtlsth8Fiwnz2fBkQvWfRtlE3iF2yW63/yCacXZ1dW02GwGyTFaRd4idJnCKHRaCxYRHoG5LTKT6SyiToP1fJHbmAYPYRR0UnZQtMnA6s0zg+GZBlt0Gdo7EPHgpE3Q6nZ8YyLhc8Xj8MJh/aKTAY+5FPAKHLE7RdwuYJZmNwzyCMkBCYyKROJBMJl9B/PXXCjjmCmDOVzH3fiPpObEWGqoKe4EBl8v1hlqsdLvd23mkxHM9pc9kMpmno9HoeTii7ewbHEZPPx1ztLS1tV3AnGuMjiNjvbQFuHw6zDo5By7dTPAQNBgMLrRarTkSls1mnwT7uwp9virx9QzbW/HuV/j5d/b+6jniKlllP8lkeONJDk+dq9GsQTnC4fB1heO0K47Hwe7WdDr9nAKgXwOBwHI+C45Htj1d6sd429TUNEcmUdc+PRaLHcvn87dXW4ugzdsaGxufL94NFv9zi1J7GVbhlvb2dnaJ3SVrxfc+n2+NTsZ7/H7/Mr3g5XdSIHyJSH1PZ+7fToyl2+ErqilgZ4NaLYB9goVGaHjR93Hv1ZrU4XDsFT20kH3PObzbWk0CgG1jacVIUnAQb9F+VexyLMzkpcLv0IJV7AHQIOCAUYHx7v5qgScmYHtTqSAyZLEJTK22Bie4iq3xsqpm4SAf9Hq9a2DnJ4uLK3SEULcdRvp3i3zHySqpficxEdsQc1NrlYXXvR+O7qASSezXB+h1SuUomgg9LL8BUoV4749EIolKh+EiqWmqVEZlDgHks2pxHw7xTqUQw9J5NcAXOK10AGIoZ6Zli6JY6Z1Q461KoZ4NiKLHarW+KDsxlDUPHZ5zPQZqUVDPJsTqb5n9malbpAh8C2XXDLl62+WZIDFRUlNVOiwencnNU3aQEkL+cDMSoLvZo2fQB7AJssNAuFuvorlDVVkkg2I87+jo2K2QAVphDrfyViK5VqtO34OkaxXCp+7drdDBCAdubm6eidX+2WwqT5komwh4YQLk+H4aE93h8Xg2gvHekQZOGSgLZTLyDTLJ4Lx9/KZWKBSainT4Iy3FqQBfnUZR42PKQFksBr9QKVXCPusD3OiA/RkQ5kP8qV/Jl1WywAp/6+dcmPM2zL1UrUahe4JqfnWWKXIul3uUbfP8njAFLW1OFr3gdFtZ72cNH+PtQT7/brW+NXqJAHh0y9V8/U/A1U7AfwIMAD7mS3pCbuWJAAAAAElFTkSuQmCC)](https://www.typescriptlang.org/)",
    "title": "Page not found · GitHub Pages",
    "description": null,
    "languageCode": null
  },
  {
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-plugin-d-ts.html",
    "markdown": "# TypeScript: Documentation - Global: Plugin\n\n## [](#umd)_UMD_\n\nA _UMD_ module is one that can _either_ be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as [Moment.js](http://momentjs.com/), are written this way. For example, in Node.js or using RequireJS, you would write:\n\nts\n\n`import moment = require(\"moment\");`\n\n`console.log(moment.format());`\n\nwhereas in a vanilla browser environment you would write:\n\njs\n\n`console.log(moment.format());`\n\n### [](#identifying-a-umd-library)Identifying a UMD library\n\n[UMD modules](https://github.com/umdjs/umd) check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:\n\njs\n\n`(function (root, factory) {`\n\n    `if (typeof define === \"function\" && define.amd) {`\n\n        `define([\"libName\"], factory);`\n\n    `} else if (typeof module === \"object\" && module.exports) {`\n\n        `module.exports = factory(require(\"libName\"));`\n\n    `} else {`\n\n        `root.returnExports = factory(root.libName);`\n\n    `}`\n\n`}(this, function (b) {`\n\nIf you see tests for `typeof define`, `typeof window`, or `typeof module` in the code of a library, especially at the top of the file, it’s almost always a UMD library.\n\nDocumentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing `require`, and a “Using in the browser” example showing using a `<script>` tag to load the script.\n\n### [](#examples-of-umd-libraries)Examples of UMD libraries\n\nMost popular libraries are now available as UMD packages. Examples include [jQuery](https://jquery.com/), [Moment.js](http://momentjs.com/), [lodash](https://lodash.com/), and many more.\n\n### [](#template)Template\n\nThere are three templates available for modules, [`module.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html), [`module-class.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html) and [`module-function.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html).\n\nUse [`module-function.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html) if your module can be _called_ like a function:\n\njs\n\n`var x = require(\"foo\");`\n\n`// Note: calling 'x' as a function`\n\n`var y = x(42);`\n\nBe sure to read the [footnote “The Impact of ES6 on Module Call Signatures”](#the-impact-of-es6-on-module-plugins)\n\nUse [`module-class.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html) if your module can be _constructed_ using `new`:\n\njs\n\n`var x = require(\"bar\");`\n\n`// Note: using 'new' operator on the imported variable`\n\n`var y = new x(\"hello\");`\n\nThe same [footnote](#the-impact-of-es6-on-module-plugins) applies to these modules.\n\nIf your module is not callable or constructable, use the [`module.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html) file.\n\n## [](#module-plugin-or-umd-plugin)_Module Plugin_ or _UMD Plugin_\n\nA _module plugin_ changes the shape of another module (either UMD or module). For example, in Moment.js, `moment-range` adds a new `range` method to the `moment` object.\n\nFor the purposes of writing a declaration file, you’ll write the same code whether the module being changed is a plain module or UMD module.\n\n### [](#template-1)Template\n\nUse the [`module-plugin.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html) template.\n\n## [](#global-plugin)_Global Plugin_\n\nA _global plugin_ is global code that changes the shape of some global. As with _global-modifying modules_, these raise the possibility of runtime conflict.\n\nFor example, some libraries add new functions to `Array.prototype` or `String.prototype`.\n\n### [](#identifying-global-plugins)Identifying global plugins\n\nGlobal plugins are generally easy to identify from their documentation.\n\nYou’ll see examples that look like this:\n\njs\n\n`var x = \"hello, world\";`\n\n`// Creates new methods on built-in types`\n\n`console.log(x.startsWithHello());`\n\n`var y = [1, 2, 3];`\n\n`// Creates new methods on built-in types`\n\n`console.log(y.reverseAndSort());`\n\n### [](#template-2)Template\n\nUse the [`global-plugin.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-plugin-d-ts.html) template.\n\n## [](#global-modifying-modules)_Global-modifying Modules_\n\nA _global-modifying module_ alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to `String.prototype` when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.\n\n### [](#identifying-global-modifying-modules)Identifying global-modifying modules\n\nGlobal-modifying modules are generally easy to identify from their documentation. In general, they’re similar to global plugins, but need a `require` call to activate their effects.\n\nYou might see documentation like this:\n\njs\n\n`// 'require' call that doesn't use its return value`\n\n`var unused = require(\"magic-string-time\");`\n\n`/* or */`\n\n`require(\"magic-string-time\");`\n\n`var x = \"hello, world\";`\n\n`// Creates new methods on built-in types`\n\n`console.log(x.startsWithHello());`\n\n`var y = [1, 2, 3];`\n\n`// Creates new methods on built-in types`\n\n`console.log(y.reverseAndSort());`\n\n### [](#template-3)Template\n\nUse the [`global-modifying-module.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html) template.\n\n## [](#consuming-dependencies)Consuming Dependencies\n\nThere are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.\n\n### [](#dependencies-on-global-libraries)Dependencies on Global Libraries\n\nIf your library depends on a global library, use a `/// <reference types=\"...\" />` directive:\n\nts\n\n`/// <reference types=\"someLib\" />`\n\n`function getThing(): someLib.thing;`\n\n### [](#dependencies-on-modules)Dependencies on Modules\n\nIf your library depends on a module, use an `import` statement:\n\nts\n\n`import * as moment from \"moment\";`\n\n`function getThing(): moment;`\n\n### [](#dependencies-on-umd-libraries)Dependencies on UMD libraries\n\n#### [](#from-a-global-library)From a Global Library\n\nIf your global library depends on a UMD module, use a `/// <reference types` directive:\n\nts\n\n`/// <reference types=\"moment\" />`\n\n`function getThing(): moment;`\n\n#### [](#from-a-module-or-umd-library)From a Module or UMD Library\n\nIf your module or UMD library depends on a UMD library, use an `import` statement:\n\nts\n\n`import * as someLib from \"someLib\";`\n\nDo _not_ use a `/// <reference` directive to declare a dependency to a UMD library!\n\n### [](#preventing-name-conflicts)Preventing Name Conflicts\n\nNote that it’s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to only declare types _namespaced_ by whatever global variable the library defines. For example, if the library defines the global value ‘cats’, you should write\n\nts\n\n`declare namespace cats {`\n\n  `interface KittySettings {}`\n\n`}`\n\nBut _not_\n\nts\n\n`// at top-level`\n\n`interface CatsKittySettings {}`\n\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\n### [](#the-impact-of-es6-on-module-plugins)The Impact of ES6 on Module Plugins\n\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.\n\n### [](#the-impact-of-es6-on-module-call-signatures)The Impact of ES6 on Module Call Signatures\n\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\nts\n\n`import exp = require(\"express\");`\n\n`var app = exp();`\n\nIn ES6 module loaders, the top-level object (here imported as `exp`) can only have properties; the top-level module object is _never_ callable. The most common solution here is to define a `default` export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the `default` export.\n\n### [](#library-file-layout)Library file layout\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\n`myLib`\n\n  `+---- index.js`\n\n  `+---- foo.js`\n\n  `+---- bar`\n\n         `+---- index.js`\n\n         `+---- baz.js`\n\nThese could be imported as\n\njs\n\n`var a = require(\"myLib\");`\n\n`var b = require(\"myLib/foo\");`\n\n`var c = require(\"myLib/bar\");`\n\n`var d = require(\"myLib/bar/baz\");`\n\nYour declaration files should thus be\n\n`@types/myLib`\n\n  `+---- index.d.ts`\n\n  `+---- foo.d.ts`\n\n  `+---- bar`\n\n         `+---- index.d.ts`\n\n         `+---- baz.d.ts`\n\nts\n\n`// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]`\n\n`// Project: [~THE PROJECT NAME~]`\n\n`// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>`\n\n`/*~ This template shows how to write a global plugin. */`\n\n`/*~ Write a declaration for the original type and add new members.`\n\n `*~ For example, this adds a 'toBinaryString' method with overloads to`\n\n `*~ the built-in number type.`\n\n `*/`\n\n`interface Number {`\n\n  `toBinaryString(opts?: MyLibrary.BinaryFormatOptions): string;`\n\n  `toBinaryString(`\n\n    `callback: MyLibrary.BinaryFormatCallback,`\n\n    `opts?: MyLibrary.BinaryFormatOptions`\n\n  `): string;`\n\n`}`\n\n`/*~ If you need to declare several types, place them inside a namespace`\n\n `*~ to avoid adding too many things to the global namespace.`\n\n `*/`\n\n`declare namespace MyLibrary {`\n\n  `type BinaryFormatCallback = (n: number) => string;`\n\n  `interface BinaryFormatOptions {`\n\n    `prefix?: string;`\n\n    `padding: number;`\n\n  `}`\n\n`}`",
    "title": "TypeScript: Documentation - Global: Plugin",
    "description": "",
    "languageCode": "en"
  }
]