sistent** (e.g., the cookie persists beyond the browser session) |\n\nThe browser, upon receipt, parses the headers and updates its cookie jar accordingly.\n\n## Browser cookie changes\n\nAs of February 2020, Google Chrome v80 changed the way it handles cookies. Auth0 implemented the following changes in the way it handles cookies:\n\n*   Cookies without the `SameSite` attribute set will be set to `lax`\n    \n*   Cookies with `SameSite=none` must be secured; otherwise they cannot be saved in the browser's cookie jar\n    \n\nThe goal of these changes is to improve security and help mitigate CSRF attacks.\n\nThese changes affect the following cookies:\n\n*   `auth0` (handles user sessions)\n    \n*   `auth0-mf` (handles information relevant to multi-factor authentication)\n    \n*   `did` (the identifier for a device/user agent)\n    \n\nFor these cookies, Auth0 will:\n\n*   Set the `SameSite` attribute to `none`, with the cookie requiring the use of HTTPS (regardless of environment)\n    \n*   Set fallback cookies in the event that a legacy browser does not support `SameSite` being set to `None`. These fallback cookies are `auth0_compat`, `auth0-mf_compat` and `did_compat`\n    \n\nThe diagram below shows what happens during a fresh interaction. The end user requests a page not previously visited. The server changes the way it renders when the visitor returns and sets a seen cookie. The grey part of the `set-cookie` header is the actual cookie `key=value.` The red portion are the cookie attributes the browser stores in the cookie jar to decide later if it should include the cookie `key+value` pair in requests.\n\n![sameSite Cookie Attributes Fresh Interaction Flow](https://images.ctfassets.net/cdy7uua7fh8z/ItaoOzUnri9dkCkZ3V0dj/e64711c0f3ae5c361fe2321e3666b1cf/cookie-fresh-interaction.png)\n\nThe following diagram shows what happens if you make the same request using the same browsing session. The request goes to the same server, and because the cookie attributes don't prohibit the seen cookie to be sent, it is automatically included as a cookie header in the request. The server will now respond differently based on the fact that it received this cookie.\n\n![sameSite Cookie Attributes Cookie Return Interaction flow](https://images.ctfassets.net/cdy7uua7fh8z/4dc2HWnmPBOV6cvdKbNM6g/50149f55e38fdf7453944932a3ef9d1c/cookie-return-interaction.png)\n\n## Features affected\n\nThe table below shows how the `SameSite` attribute changes may affect your apps.\n\n| App Behavior | Affected by Change |\n| --- | --- |\n| Cookies set as `sameSite=none` when the website is not `https://` | Yes |\n| Cookies don't have explicit `sameSite` attribute value set and are required in a cross-origin context (such as HTTP form\\_post, embedding an iframe) | Yes |\n| Native apps (everything not cookies + web based) | No (M2M) |\n| Already setting an explicit `sameSite` cookie attribute value | No  |\n| Different subdomain on the same eTLD+1 (app is on the same eTLD+1 as the custom domain Auth0 tenant) | Potentially |\n\nIf you are using a web app with sessions (e.g. for saving user preferences, shopping carts, etc.), and you allow users to sign in using identity providers such as Google, Github, or Auth0, then you rely on cookies to achieve that functionality. There are browser cookie behavior changes that may break the user experience. Google Chrome, for example, is the first browser vendor to roll out a change that might not be compatible with your web application.\n\nYou may notice that the Google Chrome and Microsoft Edge specs for setting `SameSite` to undefined has changed from `SameSite` defaulting to `none` to `lax` instead.\n\nFor example, let's say you build a new UI and have several services that you proxy to via an Auth0 gateway. At this gateway, you create a cookie session. If you make a cross-origin request, you may see this warning in the Javascript console:\n\n`A cookie associated with a cross-site resource (URL) was set without the SameSite attribute. A future release of Chrome will only deliver cookies with cross-site requests if they are set with SameSite=None and Secure. You can review cookies in developer tools under Application>Storage>Cookies and see more details at https://www.chromestatus.com/feature/5088147346030592 and https://www.chromestatus.com/feature/5633521622188032`\n\n## Actions you need to take\n\nTo prepare for this change, you should:\n\n*   Review the list of [unsupported browsers](https://www.chromium.org/updates/same-site/incompatible-clients).\n    \n*   Set your application to use `SameSite=none` if it uses `response_mode=form_post` when interacting with Auth0 (note that Chrome makes no exceptions, even for `localhost`)\n    \n*   Set your cookie as secure if its `SameSite` attribute equals `None.` Otherwise, it will be rejected by the browser. If you use HTTP for your Callback URLs, these will break if you use such cookies for binding the authorization request state/nonce. Therefore, you must either use HTTPS or set `SameSite=lax`",
  "title": "SameSite Cookie Attribute Changes",
  "description": "Describes how browser changes, such as the SameSite cookie attribute, affects your web applications that embed content from third-party domains.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates",
  "markdown": "# Configure Custom Domains with Self-Managed Certificates\n\nIf you choose to manage the certificates for your custom domains without assistance from Auth0, you need to know how to manage your own proxy and certificates for inbound connections that require multiple DNS records on the domain. You have to purchase or provide the certificates and manage the renewals yourself. You will also need a reverse proxy where the certificate will be installed. Once the domain is verified, we will accept traffic from the proxy.\n\nChoose this option to:\n\n*   Have more control of your certificates (such as choosing your own CA or certificate expiration).\n    \n*   Enable additional monitoring over your API calls to Auth0.\n    \n\nTo set up your custom domain using self-managed certificates, you need to provide your domain name to Auth0, verify that you own that domain, and configure the reverse proxy. Once your custom domain has been set up, you will need to configure your Auth0 features to start using your custom domain.\n\n## Provide your domain name to Auth0\n\n1.  Go to [Dashboard > Settings > Custom Domains](https://manage.auth0.com/#/tenant/custom_domains) or [Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/custom_domains). Enter your custom domain in the provided box, and select **Self-managed Certificates** from the drop-down menu.\n    \n    ![Dashboard Settings Custom Domains Tab Certificate Type Self-Managed Certificates](https://images.ctfassets.net/cdy7uua7fh8z/5v7KeS7m64oNZQowWsm1gG/1862702190ef6dc9205409d8c4069f4e/dashboard-settings-custom-domains-self-managed-certificates.png)\n2.  Click **Add Domain**. You can only add one domain per tenant even though the **Add Domain** button still appears after you add a domain.\n    \n\n## Verify ownership\n\nBefore you can use the domain with Auth0, you'll need to verify that you own it.\n\n1.  Go to [Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/branding/custom_domains).\n    \n    ![Auth0 Branding Custom Domains Self-Managed Certificate Verify Domain](https://images.ctfassets.net/cdy7uua7fh8z/4XhEmQwKfoqydOldfHnnud/3d49bd3de7fa059877247c4946d5b463/dashboard_-_branding_-_custom_domains_-_self-managed.png)\n2.  Add the TXT verification information to your domain's DNS record. These steps may vary for your domain host provider:\n    \n    1.  Keep the Auth0 custom domain page open in your browser so you can copy values.\n        \n    2.  Log in to your domain management service.\n        \n    3.  Create a new record, and save it with these settings:\n        \n        | **Parameter** | **Value** |\n        | --- | --- |\n        | Record type | TXT |\n        | Name | Copy and paste your domain's **TXT Record** value from Auth0. |\n        | Time to Live (TTL) | Use default value. |\n        | Value | Copy and paste your domain's **TXT Content** value from Auth0. |\n        \n3.  Click **Verify** to proceed.\n    \n    It may take a few minutes before Auth0 can verify your domain, depending on your DNS settings.\n    \n    If Auth0 successfully verified your domain name, you'll see a confirmation window. Save the information provided in this window, specifically the `cname-api-key` value, since this is the **only** time you'll see this value.\n    \n    ![Auth0 Branding Custom Domains Domain verification](https://images.ctfassets.net/cdy7uua7fh8z/3I2xfwddYVnUBXGY7hGP8q/8423d41642364b3bbb2a0c829317376b/dashboard-branding-custom_domains-domain_verification.png)\n    \n    The verification process is complete, and within 1 to 2 minutes, your custom domain should be ready to use. If you are unable to complete the verification process within three days, repeat these steps.\n    \n\n## Configure reverse proxy\n\nThe reverse proxy server retrieves resources on behalf of your application from one or more servers. These resources are then returned to the application, appearing as if they originated from the proxy server itself.\n\nYou can use a service such as [Cloudflare](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy), [Azure CDN](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-azure-cdn-for-use-as-reverse-proxy), [Google Cloud Platform](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-gcp-as-reverse-proxy), or [AWS Cloudfront](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-aws-cloudfront-for-use-as-reverse-proxy) and configure settings for your custom domain. You will add the new CNAME value to your DNS for your custom domain pointing to the reverse proxy server domain name for distribution.\n\n1.  After you've created the reverse proxy settings on your service, go to [Auth0 Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/branding/custom_domains) tab.\n    \n2.  Add a new CNAME record to your DNS for your custom domain pointing to the service domain name for your distribution. You can find this by looking for the **Distribution ID** on your reverse proxy server configuration. Once added, the CNAME record must be present at all times to avoid issues during certificate renewal.\n    \n3.  The way you configure the proxy server will vary depending on the service you use. You will likely need to configure the following types of settings:\n    \n\n*   [Distribution](#distribution-settings)\n    \n*   [Origin custom headers](#origin-custom-header-settings)\n    \n*   [Origin hostname](#origin-hostname-settings)\n    \n*   [Default cache behavior](#default-cache-behavior-settings)\n    \n\n### Distribution settings\n\n| **Setting** | **Value** |\n| --- | --- |\n| Origin Domain Name | Set this to the **Origin Domain Name** value obtained from the Auth0 Dashboard during the Custom Domains setup process. |\n| Origin ID | A description for the origin. This value lets you distinguish between multiple origins in the same distribution and therefore must be unique. |\n| Origin Protocol Policy | Set to `HTTPS Only`. |\n| Alternate Domain Names (CNAMEs) | Set to your custom domain name (the same one your configured in the Auth0 Dashboard). |\n\n| **Setting** | **Value** |\n| --- | --- |\n| Header Name | Set to `cname-api-key`. |\n| Value | Set to the CNAME API Key value that you were given immediately after you verified ownership of your domain name with Auth0. |\n\n### Origin hostname settings\n\n| **Setting** | **Value** |\n| --- | --- |\n| Origin hostname | Enter `{yourTenant}-<CUSTOM_DOMAIN_ID>.edge.tenants.us.auth0.com`, making sure to replace `<CUSTOM_DOMAIN_ID>` with the value of the Origin Domain Name (custom domain ID) you received from Auth0 when setting up the new custom domain. If your tenants are not in the US region, use one of the following:<br><br>*   EU: `{yourTenant}-<CUSTOM_DOMAIN_ID>.edge.tenants.eu.auth0.com`<br>*   AU: `{yourTenant}-<CUSTOM_DOMAIN_ID>.edge.tenants.au.auth0.com`<br>*   JP: `{yourTenant}-<CUSTOM_DOMAIN_ID>.edge.tenants.jp.auth0.com`<br><br>For example, if your CUSTOM\\_DOMAIN\\_ID is:<br><br>`cd_TXIdNgQ07HrAFVmz`<br><br>For a US tenant, then the Origin hostname should be:<br><br>`US: {yourTenant}-cd-txIdngq07hrafvmz.edge.tenants.us.auth0.com` |\n| Host header | Use the name you provided for the Origin hostname. |\n\nFor more information on retrieving the details of your custom domain, see [Get custom domain configurations](https://auth0.com/docs/api/management/v2/custom-domains/get-custom-domains).\n\n### Default cache behavior settings\n\n| **Setting** | **Value** |\n| --- | --- |\n| Viewer Protocol Policy | Select **Redirect HTTP to HTTPS**. |\n| Allowed HTTP Methods | Select **GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE**. |\n| Cache Based on Selected Request Headers | Select **Allow list**. |\n| Allow List Headers | The following headers should be allowed: `User-Agent`, `Origin`, `Referer`, `Authorization`, `Accept`, and `Accept-Language`. |\n| Forward Cookies | Select **All**. |\n| Query String Forwarding and Caching | Select **Forward all, cache based on all**. |\n\n## Additional steps for specific Auth0 features\n\nThere are additional configuration steps you must complete depending on which Auth0 features you are using. To learn more, read [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains).\n\nCloudflare uses a feature called CNAME Flattening, which affects Auth0 verification and certificate renewal in the way that it handles DNS records. We recommend that you turn off CNAME Flattening unless it's absolutely necessary. To learn more, read [Cloudflare documentation](https://support.cloudflare.com/hc/en-us/articles/200169056-Understand-and-configure-CNAME-Flattening).\n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Configure Google Cloud Platform with Load Balancing as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-gcp-as-reverse-proxy)\n*   [Configure Cloudflare as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy)\n*   [Configure AWS CloudFront as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-aws-cloudfront-for-use-as-reverse-proxy)\n*   [Configure Azure CDN as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-azure-cdn-for-use-as-reverse-proxy)\n*   [Configure Akamai as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-akamai-for-use-as-reverse-proxy)",
  "title": "Configure Custom Domains with Self-Managed Certificates",
  "description": "Learn how to configure custom domains where you are responsible for TLS (SSL) certificates, the reverse proxy to handle SSL termination, and forwarding requests to Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/data-security/allowlist",
  "markdown": "# Auth0 IP Addresses for Allow Lists\n\nIf you have custom code executing in Auth0 that calls a service inside your network, or if you've configured an on-premise SMTP provider in Auth0, then you may need to configure your firewall to allow inbound traffic from Auth0.\n\nFeatures that may require you to allow inbound traffic from Auth0 include:\n\n*   [Actions](https://auth0.com/docs/customize/actions)\n    \n*   [Rules](https://auth0.com/docs/customize/rules)\n    \n*   [Hooks](https://auth0.com/docs/customize/hooks)\n    \n*   [Custom Database Action Scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates)\n    \n*   [Log Streams](https://auth0.com/docs/customize/log-streams)\n    \n*   [External STMP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n    \n\n## Outbound calls\n\nWhen Auth0 makes outbound calls, the IP addresses are static. Auth0 translates internal IP addresses to one of the displayed options when reaching out using NAT.\n\n### Public Cloud\n\nFor Public Cloud tenants, the IP addresses that you must allow through your firewall are specific to the tenant's region.\n\nThe list of IP addresses for each region are listed below:\n\n#### United States\n\n174.129.105.183, 18.116.79.126, 18.117.64.128, 18.191.46.63, 18.218.26.94, 18.232.225.224, 18.233.90.226, 3.131.238.180, 3.131.55.63, 3.132.201.78, 3.133.18.220, 3.134.176.17, 3.19.44.88, 3.20.244.231, 3.21.254.195, 3.211.189.167, 34.211.191.214, 34.233.19.82, 34.233.190.223, 35.160.3.103, 35.162.47.8, 35.166.202.113, 35.167.74.121, 35.171.156.124, 35.82.131.220, 44.205.93.104, 44.218.235.21, 44.219.52.110, 52.12.243.90, 52.2.61.131, 52.204.128.250, 52.206.34.127, 52.43.255.209, 52.88.192.232, 52.89.116.72, 54.145.227.59, 54.157.101.160, 54.200.12.78, 54.209.32.202, 54.245.16.146, 54.68.157.8, 54.69.107.228\n\n#### Europe\n\n18.197.9.11, 18.198.229.148, 3.125.185.137, 3.65.249.224, 3.67.233.131, 3.68.125.137, 3.72.27.152, 3.74.90.247, 34.246.118.27, 35.157.198.116, 35.157.221.52, 52.17.111.199, 52.19.3.147, 52.208.95.174, 52.210.121.45, 52.210.122.50, 52.28.184.187, 52.30.153.34, 52.57.230.214, 54.228.204.106, 54.228.86.224, 54.73.137.216, 54.75.208.179, 54.76.184.103\n\n#### Australia\n\n13.210.52.131, 13.238.180.132, 13.55.232.24, 16.50.37.252, 16.51.137.244, 16.51.49.47, 54.153.131.0, 54.252.2.143, 54.79.31.78\n\n#### Canada\n\n15.222.97.193, 3.97.144.31, 40.176.144.225, 40.176.166.165, 40.177.34.170, 99.79.94.44\n\n#### Japan\n\n13.208.85.227, 15.152.185.222, 15.152.2.46, 15.152.28.221, 15.152.56.146, 15.152.95.63, 176.34.22.106, 35.74.30.168, 43.206.201.6, 46.51.243.250, 54.150.87.80, 54.248.192.141\n\n#### United Kingdom\n\n18.135.40.36, 3.10.89.10, 3.8.59.62\n\n### Private Cloud\n\nFor Private Cloud tenants, the IP addresses that you must allow through your firewall are unique to the tenant's environment. Auth0 may receive your tenant's private IP addresses if you enable features like Tenant Logs, Suspicious IP throttling, Custom Databases, and Actions that rely on them.\n\nThese IP addresses are known as **Primary Egress IPs** and are listed under the environment's configuration data available in the [Auth0 Support Center](https://support.auth0.com/tenants/private).\n\n## Inbound calls\n\nIP addresses related to inbound calls to Auth0 may be variable due to the lack of fixed IP addresses on the load balancers. In this case, firewall rules should operate on the name of the service (for example: `<YOUR_TENANT>.<YOUR_REGION>.auth0.com`).\n\nIf your Auth0 subscription allows you to configure a self-managed custom domain, you can configure that custom domain to have a static IP address. Self-managed custom domains give you control over the network entry point and let you ensure that the IP address is fixed. For information on subscription plans, see [Auth0 Pricing](https://auth0.com/pricing).\n\n## Learn more\n\n*   [Auth0 Public Cloud Service Endpoints](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/public-cloud-service-endpoints)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n*   [Custom Database Connection Security Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/connection-security)",
  "title": "Auth0 IP Addresses for Allow Lists ",
  "description": "Lists Auth0 IP addresses for use in allow lists for inbound traffic behind a firewall.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider",
  "markdown": "# Configure Auth0 as SAML Identity Provider\n\nYou can use Auth0 as the identity provider in SAML configurations with SAML 2.0.\n\n## SSO integrations with built-in Auth0 support\n\n1.  Go to [Dashboard > Applications > SSO Integrations](https://manage.auth0.com/#/externalapps) and select **Create SSO Integration**.\n    \n2.  Choose an SSO identity provider integration. On the next screen, click **Continue**.\n    \n3.  Enter the required details for your selected provider and click **Save**.\n    \n\nOn the Tutorial view, you will see additional configuration instructions that are specific to the integration you have chosen.\n\nSome of the following integrations make use of the [SAML2 Web App addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon).\n\n*   [Amazon Web Services](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)\n    \n*   [Atlassian](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-atlassian)\n    \n*   [Cisco-WebEx](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-cisco-webex)\n    \n*   [DataDog](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-datadog)\n    \n*   [Egencia](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-egencia)\n    \n*   [Oracle Eloqua Marketing Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-addon-eloqua)\n    \n*   [Freshdesk](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-freshdesk)\n    \n*   [GitHub Enterprise Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n    \n*   [GitHub Enterprise Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n    \n*   [Google Workspace](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-idp-for-google-g-suite)\n    \n*   [Heroku](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-heroku)\n    \n*   [Hosted Graphite](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-hosted-graphite)\n    \n*   [Litmos](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-litmos)\n    \n*   [PluralSight](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-pluralsight)\n    \n*   [Sprout Video](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-sprout-video)\n    \n*   [Tableau Online](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-online)\n    \n*   [Tableau Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-server)\n    \n*   [Workday](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workday)\n    \n*   [Workpath](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workpath)\n    \n\n## Manually configure SSO integrations\n\nYou can manually configure a SAML SSO integration with the SAML2 Web App addon in the Auth0 Dashboard. You can configure the SAML addon using the instructions on the screen along with the information available on the service provider's settings.\n\n### Obtain the Application Callback URL from the service provider\n\nObtain the URL to which the SAML Authentication Assertion should be sent from the service provider. This may be called **Assertion Consumer Service URL**, **Post-back URL**, or **Callback URL**.\n\n### Configure SAML SSO in Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to configure.\n    \n2.  Scroll to the bottom of the **Settings** page and click **Advanced Settings**.\n    \n3.  Select the **Certificates** tab and click **Download Certificates** and choose **`PEM`** format. The certificate will be downloaded to a file called `{yourTenant}.pem`. Save this file; you will need to upload it when you configure the service provider.\n    \n    ![Dashboard Applications Advanced Settings Certificates tab](https://images.ctfassets.net/cdy7uua7fh8z/5eB167clrfOiBEtyrMOtkn/fba0b689fda32cb9fd16eba1c0725c65/dashboard-applications-applications-settings-advanced-certificates.png)\n4.  Select the **Endpoints** tab and locate **SAML Protocol URL.** Copy and save it. You will need to provide it to the service provider.\n    \n    ![Dashboard Applications Application Settings Tabs Advanced Endpoints tab](https://images.ctfassets.net/cdy7uua7fh8z/6aYWCyJXwGKwVmP42te2oI/118305c73038e2661286b66d1122b5e2/dashboard-applications-applications-settings-advanced-endpoints.png)\n5.  Scroll to the top and select the **Addons** tab.\n    \n6.  Enable the **SAML2 Web App** toggle.\n    \n7.  On the **Settings** tab, enter the **Application Callback URL** from the service provider (or application) to which the SAML assertions should be sent after Auth0 has authenticated the user. This is the Assertion Consumer Service (ACS) URL.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n8.  Scroll to the bottom of the tab and click **Enable**.\n    \n9.  If your service provider sends multiple ACS URLs in the SAML request, you will need to add them to the allow list by navigating to your application's **Settings** tab, locating **Allowed Callback URLs**, and adding them.\n    \n\n### Configure SAML SSO on the service provider\n\n1.  Go to the SAML Addon **Usage** tab to view the information that you need to configure the service provider application.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n2.  Locate **Identity Provider Metadata**, and click **Download** to download the metadata file. Add information to the service provider, so it knows how to send SAML-based authentication requests to Auth0. The instructions provided here are generic. You will need to find the appropriate screens and fields on the service provider.\n    \n\n*   If the service provider supports uploading a metadata file, provide the metadata URL obtained on the SAML2 Web Addon **Usage** tab.\n    \n*   If the service provider does not support uploading a metadata file, configure settings manually, using the information from the SAML Addon's **Usage** view.\n    \n    *   For a Login URL, use the **Identity Provider Login URL**, which is the URL to which the service provider should send its SAML Authentication Requests.\n        \n    *   If you have a custom domain, use the custom-domain-based URL rather than your Auth0 domain. Instead of using a URL in this format: `https://{yourTenant}.auth0.com/samlp/CLIENTID?connection=Username-Password-Authentication` You will want to use one in this format: `https://{yourCustomDomain}/samlp/CLIENTID?connection=Username-Password-Authentication`.\n        \n    *   If you are using [Organizations](https://auth0.com/docs/manage-users/organizations), you can direct users to a specific organization's login prompt by providing an organization ID in the query string as the `organization` parameter. Optionally, you can also specify the connection by including the `connection` parameter. Example: `https://{yourTenant}.auth0.com/samlp/CLIENTID?connection=Acme-Saml-Connection&organization=org_123456789`\n        \n    *   If the service provider also has a field for a Logout URL, enter the **Identity Provider Login URL** again; both login and logout are handled by the same URL.\n        \n*   Download the certificate from the SAML Addon's **Usage** view and provide it to the service provider. This certificate will be used to validate the signature of the SAML Authentication Assertions sent from Auth0 to the service provider. If the service provider asks for an **Issuer**, this can also be obtained from the SAML Addon's **Usage** view.\n    \n\n### Test configuration\n\nOnce you have completed the above configuration, test the login.\n\n*   If your application doesn't work the first time, clear your browser history and (ideally) cookies each time before you test. Otherwise, the browser may not pick up the latest version of your HTML page, or it may have stale cookies that impact execution.\n    \n*   To help troubleshoot SSO, capture an HTTP trace of the interaction. Many tools will capture the HTTP traffic from your browser for analysis.\n    \n    *   Search the internet for \"HTTP Trace\" to find and install a tool.\n        \n    *   Capture the login sequence from start to finish and analyze the trace. Track the sequence of GETs to see how far in the expected sequence you get. You should see a redirect from your original site to the SP and then to the IdP, a post of credentials if you had to log in, then a redirect back to the callback URL or the SP, and then a redirect to the callback URL specified in your application.\n        \n*   Make sure that cookies and JavaScript are enabled for your browser.\n    \n*   Use the [http://samltool.io](http://samltool.io/) tool to decode a SAML assertion.\n    \n\n## Learn more\n\n*   [Customize SAML Assertions](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)",
  "title": "Configure Auth0 as SAML Identity Provider",
  "description": "Describes how to configure Auth0 to serve as a SAML identity provider in a SAML federation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains",
  "markdown": "# Configure Features to Use Custom Domains\n\nTo configure Auth0 features to use your custom domain, you may need to complete additional steps depending on the features you are using. For example, you may need to make changes before you can use your custom domain on your login page or to call your APIs.\n\nIf you have been using Auth0 for some time and decide to enable a custom domain, you will have to migrate your existing apps and update the settings as described below, including to any VPN or firewall you use. Note that existing sessions created at `{yourDomain}` will no longer be valid once you start using your custom domain, so users will have to log in again.\n\n## Prerequisites\n\nYou should have already configured and verified your custom domain.\n\n## Features\n\n| **Feature** | **Section to read** |\n| --- | --- |\n| Universal Login with a customized login page | [Universal Login](#universal-login) |\n| Lock embedded in your application | [Embedded Lock](#embedded-lock) |\n| Auth0 SPA SDK, Auth0.js, or other Auth0 SDKs | [Auth0 SPA SDK, Auth0.js, and other SDKs](#auth0-spa-sdk-auth0-js-and-other-sdks) |\n| Custom domain with Auth0 emails | [Use custom domains in emails](#use-custom-domains-in-emails) |\n| Social identity providers | [Configure social identity providers](#configure-social-identity-providers) |\n| Google Workspace connections with your custom domain | [Configure Google Workspace connections](#configure-g-suite-connections) |\n| Issue Access Tokens for your APIs or access Auth0 APIs from your application | [APIs](#apis) |\n| SAML Identity Providers | [Configure SAML identity providers](#configure-saml-identity-providers) |\n| SAML applications | [Configure SAML applications](#configure-saml-applications) |\n| Web Service Federation (WS-Fed) applications | [Configure WS-Fed applications](#configure-ws-fed-applications) |\n| Azure AD connections | [Configure Azure AD connections](#configure-azure-ad-connections) |\n| ADFS connections | [Configure ADFS connections](#configure-adfs-connections) |\n| AD/LAP connections with Kerberos support | [Configure AD/LAP connections](#configure-ad-ldap-connections) |\n\n## Universal Login\n\nIf you use [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) and you have customized the login page, you must update the code to use your custom domain. If you use the **default** login page without customization, you do not need to make any changes. To learn more, read Auth0 Universal Login.\n\nIf you use [Lock for Web](https://auth0.com/docs/libraries/lock), you must set the `configurationBaseUrl` and `overrides` options as seen in the following sample script:\n\n```\nvar lock = new Auth0Lock(config.clientID, config.auth0Domain, {\n  //code omitted for brevity\n  configurationBaseUrl: config.clientConfigurationBaseUrl,\n  overrides: {\n  \t__tenant: config.auth0Tenant,\n  \t__token_issuer: config.authorizationServer.issuer\n  },\n  //code omitted for brevity\n});\n```\n\nIf you use [Auth0.js](https://auth0.com/docs/libraries/auth0js) on the Universal Login page, you must set the `overrides` option.\n\n```\nvar webAuth = new auth0.WebAuth({\n  clientID: config.clientID,\n  domain: config.auth0Domain,\n  //code omitted for brevity\n  overrides: {\n  \t__tenant: config.auth0Tenant,\n  \t__token_issuer: config.authorizationServer.issuer\n  },\n  //code omitted for brevity\n});\n```\n\nFor most, the Auth0.js and Lock libraries retrieve the tenant name (required for `/usernamepassword/login`) and the issuer (required for `id_token` validation) from the domain. However, if you're a Private Cloud customer who uses a proxy or a custom domain name where the domain name is different from the tenant/issuer, you can use `__tenant` and `__token_issuer` to provide your unique values.\n\n## Embedded Lock\n\nIf you use [Lock for Web](https://auth0.com/docs/libraries/lock) embedded in your application, you must update the code to use your custom domain when initializing Lock. You will also need to set the `configurationBaseUrl` to the appropriate CDN URL.\n\nto configure this snippet with your account\n\n```\nvar lock = new Auth0Lock('{yourClientId}', '{yourCustomDomain}', {\n  //code omitted for brevity\n  configurationBaseUrl: 'https://cdn.us.auth0.com'\n  //code omitted for brevity\n});\n```\n\nThe CDN URL varies by region. Use `https://cdn.[us|eu|au|jp].auth0.com` (`us` for US, `eu` for Europe, `au` for Australia, or `jp` for Japan).\n\n## Auth0 SPA SDK, Auth0.js, and other SDKs\n\nIf you use the [Auth0 SPA SDK](https://auth0.com/docs/libraries/auth0-spa-js), [Auth0.js](https://auth0.com/docs/libraries/auth0js), or [other SDKs](https://auth0.com/docs/support/matrix#auth0-sdks), you will have to initialize the SDK using your custom domain. For example, if you are using the Auth0.js SDK, you must set the following:\n\nto configure this snippet with your account\n\n```\nwebAuth = new auth0.WebAuth({\n  domain: '{yourCustomDomain}',\n  clientID: '{yourClientId}'\n});\n```\n\nAnd for the Auth0 SPA SDK:\n\nto configure this snippet with your account\n\n```\nconst auth0 = await createAuth0Client({\n  domain: '{yourCustomDomain}',\n  client_id: '{yourClientId}'\n});\n```\n\nSee APIs section below if you use a custom domain and also intend to perform [Management API actions with Auth0.js](https://auth0.com/docs/libraries/auth0js/v9#user-management).\n\n## Use custom domains in emails\n\nIf you want to use your custom domain with your Auth0 emails, you must enable this feature.\n\n1.  Go to [Auth0 Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/branding/custom_domains).\n    \n2.  Enable the **Use Custom Domain in Emails** toggle.\n    \n\nIf you want to use your custom domain with Social identity providers (IdP), you must update your IdP's list of Authorized Redirect URIs to include your custom domain (such as `https://login.northwind.com/login/callback`).\n\nYou cannot use [Auth0 developer keys](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/devkeys) with custom domains.\n\n## Configure Google Workspace connections\n\nIf you want to use your custom domain with Google Workspace connections, you must update the Authorized Redirect URI in your OAuth Client Settings. In the Google Developer Console, go to **Credentials**, choose your OAuth client in the list, and you will see a settings page with the app Client ID, secret, and other fields. In the **Authorized redirect URIs** field, add a URL in the format `https://<YOUR-CUSTOM-DOMAIN>/login/callback` that includes your custom domain (such as `https://login.northwind.com/login/callback`).\n\n## APIs\n\nAPI identifiers (i.e. `audience`) will not change. This is a constant value for each API, and despite the fact that it's conventional to use a URI, it is completely independent of the domain used to obtain the token.\n\nAuth0 issues tokens with the `iss` claim of whichever domain you used to obtain the token.\n\n##### Auth0 APIs\n\nContinue to use your default tenant domain name (such as `https://{yourDomain}/userinfo` and `https://{yourDomain}/api/v2/`) instead of your custom domain when specifying an `audience`. This is the only place to use your default tenant domain.\n\nAll requests (i.e. obtaining the token, and actually calling the API) must use the same domain. Tokens obtained via a custom domain must be used on an Auth0 API using the same custom domain.\n\nIf you use an authentication flow with your Custom Domain to request Access Tokens to access the Management API, you must call the Management API endpoint with your Custom Domain too.\n\n```\nPOST https://mycustomdomain.com/oauth/token\n... // other parameters \n...\naudience:https://defaulttenant.eu.auth0.com/api/v2/\n```\n\nYour Access Token request should be something similar to\n\n```\nGET https://mycustomdomain.com/api/v2/clients\n\nHeaders:\nAuthorization: Bearer <access_token>\n```\n\n##### Custom APIs\n\nIf you use Auth0 with a custom domain to issue Access Tokens for your APIs, you must validate the JWT issuer(s) against your custom domain. For example, if you use the [express-jwt](https://github.com/auth0/express-jwt) middleware, you must make the following change:\n\n```\napp.use(jwt({\n  issuer: 'https://<YOUR-CUSTOM-DOMAIN>/',\n  //code omitted for brevity\n}));\n```\n\n## Configure SAML identity providers\n\nTo use your custom domain with SAML Identity Providers (IdPs), you must update your **Assertion Consumer Service (ACS) URL(s)** with the Identity Provider(s). Depending on what is supported by the IdP, you can do this in one of two ways:\n\n1.  You can get the service provider metadata from Auth0 at `https://<YOUR-CUSTOM-DOMAIN>/samlp/metadata?connection=<YOUR-CONNECTION-NAME>`. This will include the updated ACS URL. Then, you must manually update this value in your IdP(s) settings. This change to your IdP(s) must happen at the same time as you begin using your custom domain in your applications. This can pose a problem if there are multiple IdPs to configure.\n    \n2.  If supported by the IdP, you can use signed requests to fulfill this requirement:\n    \n\n*   Download the signing certificate from `https://<TENANT>.auth0.com/pem`. Note that `https://<YOUR-CUSTOM-DOMAIN>.com/pem` will return the same certificate\n    \n*   Give the certificate to the IdP(s) to upload. This enables the IdP to validate the signature on the `AuthnRequest` message that Auth0 sends to the IdP\n    \n*   The IdP will import the certificate and, if necessary, signature verification should be enabled (exact steps vary by IdP)\n    \n*   Turn on the **Sign Request** toggle in the Dashboard under **Connections > Enterprise > SAML > CONNECTION**. This will trigger Auth0 to sign the SAML `AuthnRequest` messages it sends to the IdP.\n    \n\nOnce this is done, and you start using your custom domain when you initiate an authentication request in your application, the IdP will receive that custom domain in your signed request. Because your application’s signed request is trusted, the IdP should automatically override whatever was configured as your ACS URL and replace it with the value sent in the signed request. However, there are IdPs that do **not** accept the ACS URL in the signed request, so you must check with yours first to confirm whether this is supported or not.\n\nIf this is supported, it will prevent you from having to change one or many IdP settings all at the same time and allow you to prepare them to accept your signed requests ahead of time. You can then change the statically configured ACS URL in your IdP settings at a later date as well.\n\nNote that if your SAML identity provider is configured to use your custom domain, testing the connection via the **Try** button in the Dashboard will **not** work and the default links for downloading metadata from Auth0 will always show the default domain, not the custom domain.\n\nIf you have an IdP-initiated authentication flow, you will need to update the IdP(s) and your application(s) at the same time to use the custom domain.\n\n## Configure SAML applications\n\nIf you want to use your custom domain with SAML applications (when Auth0 is the IdP), you must update your service provider with new identity provider metadata from Auth0. You can obtain the updated metadata reflecting the custom domain from `https://<YOUR-CUSTOM-DOMAIN>/samlp/metadata/<YOUR-CLIENT-ID>`. Note that the issuer entity ID for the assertion returned by Auth0 will change when using a custom domain (from something like `urn:northwind.auth0.com` to one with the custom domain, such as `urn:login.northwind.com`).\n\nIf you have an IdP-initiated authentication flow, you will need to update the URL used to invoke the IdP-initiated authentication flow to reflect the custom domain. Instead of `https://<TENANT>.auth0.com/samlp/<YOUR-CLIENT-ID>`, you should use `https://<YOUR-CUSTOM-DOMAIN>/samlp/<YOUR-CLIENT-ID>`.\n\n## Configure WS-Fed applications\n\nIf you want to use your custom domain with WS-Fed applications with Auth0 as the IdP, you must update your Service Provider with new identity provider metadata from Auth0. You can obtain the metadata reflecting the custom domain from `https://<YOUR-CUSTOM-DOMAIN>/wsfed/FederationMetadata/2007-06/FederationMetadata.xml`.\n\nIf you want to use your custom domain with Azure AD connections, you must update the Allowed Reply URL in your Azure AD settings. In your Azure Active Directory, go to **Apps registrations** and select your app. Then click **Settings -> Reply URLs** and add a URL with your custom domain in the format `https://<YOUR-CUSTOM-DOMAIN>/login/callback` (such as `https://login.northwind.com/login/callback`).\n\n## Configure ADFS connections\n\nIf you want to use your custom domain with ADFS connections, you must update the endpoint in your ADFS settings. This will need to be updated to use your custom domain in the callback URL in the format `https://<YOUR-CUSTOM-DOMAIN>/login/callback` (such as `https://login.northwind.com/login/callback`).\n\nIf you do not need Kerberos support, AD/LDAP connections do not require further configuration.\n\nIn order to use AD/LDAP connections with Kerberos support, you will need to update the Ticket endpoint to work with the custom domain. As mentioned in the [Auth0 AD/LDAP connector documentation](https://auth0.com/docs/connector/modify#point-an-ad-ldap-connector-to-a-new-connection), the `config.json` file needs to be modified, with the `PROVISIONING_TICKET` value changed to use your custom domain in the format `https://<YOUR-CUSTOM-DOMAIN>/p/ad/jUG0dN0R`.\n\nOnce this change is saved, you need to restart the AD/LDAP Connector service for the change to take effect.\n\n## Learn more\n\n*   [Configure Custom Domains with Auth0-Managed Certificates](https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates)\n*   [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)",
  "title": "Configure Features to Use Custom Domains",
  "description": "Learn how to configure a custom domain for Auth0 authentication features. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates",
  "markdown": "# Configure Custom Domains with Auth0-Managed Certificates\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nIf you want Auth0 to manage the certificates for your custom domain, you only need to add a CNAME record on the domain. Auth0 validates the record and then generates the certificate on Auth0 servers. These certificates are renewed automatically every three months. You can configure this easily, and you won't have to maintain the certificates yourself.\n\nTo set up your custom domain using Auth0-managed certificates, you must provide your domain name to Auth0 and verify that you own that domain. Once verified, you will need to configure your Auth0 features to start using your custom domain.\n\n## Provide your domain name to Auth0\n\n1.  Go to [Dashboard > Settings > Custom Domains](https://manage.auth0.com/#/tenant/custom_domains) or [Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/custom_domains). Enter your custom domain in the provided box, and select **Auth0-managed certificates.**\n    \n    ![Dashboard Settings Custom Domains Tab Certificate Type Auth0-Managed Certificates](https://images.ctfassets.net/cdy7uua7fh8z/7l8DLGTSWM7Kgj6C9NV74R/754645982613689b962b04d202b27d44/dashboard-settings-custom-domains-auth0-managed-certificates.png)\n2.  Click **Add Domain**. You can only add one domain per tenant even though the **Add Domain** button still appears after you add a domain.\n    \n\n## Verify ownership\n\nBefore you can use the domain with Auth0, you'll need to verify that you own it.\n\n1.  Go to [Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/branding/custom_domains) and add the CNAME verification record listed in the Dashboard to your domain's DNS record.\n    \n    ![Auth0 Branding Custom Domains Auth0-Managed Certificate Verify Domain](https://images.ctfassets.net/cdy7uua7fh8z/3dz8ii70nm0a5amS0PNJ5K/9590026beb0d6f7bd0046d964ab25c89/dashboard-branding-custom_domains-auth0-managed-verify.png)\n2.  Click **Verify** to proceed. It may take a few minutes before Auth0 is able to verify your CNAME record, depending on your DNS settings. If Auth0 was able to verify your domain name, you'll see a confirmation window. This means the verification process is complete. Within 1 to 2 minutes, your custom domain should be ready to use.\n    \n\n## Add CNAME verification record to DNS record\n\nOnce added, the CNAME record must be present at all times to avoid issues during certificate renewal.\n\nIf you need to enable CNAME flattening for all subdomains managed by Cloudfare and also configure a specific subdomain to be an Auth0 custom domain, consider delegating the subdomain for Auth0 to another DNS provider. To learn more, read [Delegating Subdomains Outside of Cloudflare](https://support.cloudflare.com/hc/en-us/articles/360021357131-Delegating-Subdomains-Outside-of-Cloudflare) in the Cloudflare documentation. This will enable you to use CNAME flattening for all subdomains except the one used for Auth0.\n\nThe following steps may vary for your domain host provider.\n\n1.  Log in to your domain management service.\n    \n2.  Create a new record.\n    \n    | Parameter | Value |\n    | --- | --- |\n    | **Record type** | **CNAME** |\n    | **Name** | Enter your custom domain name (such as **login.northwind.com**). |\n    | **Time to Live (TTL)** | Use default value. |\n    | **Value** | Paste in the **CNAME** value provided by the Auth0 Dashboard for your domain's DNS record. |\n    \n3.  When done, save your record.\n    \n\nIf Auth0 was able to verify your domain name, you'll see a confirmation window. This means the verification process is complete. Within 1 to 2 minutes, your custom domain should be ready to use.\n\nIf you are unable to complete the verification process, wait at least 4 hours before repeating these steps. To avoid any interruptions to your service, do not recreate the custom domain when reverifying. For troubleshooting guidelines, see [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains).\n\n## Additional steps for specific Auth0 features\n\nThere are additional configuration steps you must complete depending on which Auth0 features you are using. To learn more, see [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains).\n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates)",
  "title": "Configure Custom Domains with Auth0-Managed Certificates",
  "description": "Learn how to configure custom domains where Auth0 manages the TLS (SSL) certificates.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider",
  "markdown": "# Configure Auth0 as SAML Service Provider\n\nTo configure Auth0 as the service provider (SP) in a SAML federation, you will need to create an Enterprise connection in Auth0 and then update your SAML identity provider (IdP) with the connection's metadata.\n\nAuth0 supports using Auth0 as the SP in configurations that conform to the SAML 1.1 or SAML 2.0 protocol.\n\n## Get metadata and certificate from the IdP\n\nYou'll need to collect some configuration metadata from the IdP to create a connection in Auth0:\n\n| **Field** | **Description** |\n| --- | --- |\n| Sign In URL | The URL where SAML authentication requests are sent. This is also called the single sign-on (SSO) endpoint. |\n| Sign Out URL | The URL where SAML logout requests are sent. This is also called the single logout (SLO) endpoint. |\n| X509 Signing Certificate | The public-key certificate required by the SP to validate the signature of the authentication assertions that have been digitally signed by the IdP. Auth0 accepts the .pem and .cer formats. |\n\n## Create SAML Enterprise connection in Auth0\n\nYou can create a SAML Enterprise connection in the Auth0 Dashboard or with the Auth0 Management API:\n\n1.  Go to [**Dashboard > Authentication > Enterprise**](https://manage.auth0.com/#/connections/enterprise/samlp) and select **SAML**.\n    \n2.  Select **Create Connection**.\n    \n3.  Configure the following settings:\n    \n    | **Setting** | **Description** |\n    | --- | --- |\n    | Connection Name | Enter a connection name such as `SAML-SP`. |\n    | Sign In URL | Enter the **Sign In URL** that you obtained from the IdP. |\n    | X509 Signing Certificate | Upload the X509 Signing Certificate file (in `.pem` or `.cer` format) that you obtained from the IdP. |\n    | Enable Sign Out | Enable the **Sign Out URL** field. |\n    | Sign Out URL | Enter the **Sign Out URL** obtained from the IdP. |\n    | User ID Attribute | Enter the attribute in the SAML token that will be mapped to the `user_id` property in Auth0. If not set, then the `user_id` will be retrieved from the following (in listed order):<br><br>*   `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`<br>*   `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn`<br>*   `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name` |\n    | Debug Mode | Enable **Debug Mode** for more verbose logging. |\n    | Sign Request | Enable signed SAML authentication requests. |\n    | Sign Request Algorithm | From the dropdown menu, select the hash algorithm to use. |\n    | Sign Request Algorithm Digest | From the dropdown menu, select the algorithm to use to check the validity of the assertion. |\n    | Protocol Binding | From the dropdown menu, select one of the following options:<br><br>*   `HTTP-Redirect`: Enables messages to be transmitted within URL parameters.<br>*   `HTTP-POST`: Enables messages to be transmitted within an HTML form. |\n    | Sync user profile attributes at each login | Enable syncing user profile attributes during each login. |\n    \n4.  Select **Create**.\n    \n\n### Configure SAML connection for proxy gateways\n\nIf you have Auth0 behind a proxy gateway, you’ll need to configure the SAML connection’s `destinationUrl` and `recipientUrl` fields accordingly.\n\n1.  Get your SAML connection's current configuration with the Management API [Get a connection](https://auth0.com/docs/api/management/v2/connections/get-connections-by-id) endpoint.\n    \n2.  Copy the value of the `options` object from the returned response.\n    \n3.  Add the following fields to the `options` object:\n    \n    | **Field** | **Type** | **Value** |\n    | --- | --- | --- |\n    | `destinationUrl` | String | URL of the proxy gateway. |\n    | `recipientUrl` | String | URL of the proxy gateway. |\n    \n4.  Call the Management API [Update a connection](https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id) endpoint with the entire updated `options` object in the request body.\n    \n\n### Customize the request template\n\nWhen Auth0 sends the authentication request to the IdP, the request body contains an `AuthnRequest` object. You can customize the template used for this object:\n\n1.  Go to [Dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp), and select your connection.\n    \n2.  Switch to the **Settings** view, and locate the **Request Template** field.\n    \n3.  Modify the template.\n    \n4.  Select **Save Changes**.\n    \n\n#### Template variables\n\nVariables can be placed into the `AuthnRequest` template using the `@@VariableName@@` syntax. The following variables are available:\n\n| **Name** | **Description** |\n| --- | --- |\n| **ID** | The transaction ID. |\n| **IssueInstant** | The transaction date timestamp. |\n| **Issuer** | The entity ID of the SP in `urn` format. For example, `urn:auth0:<YOUR_AUTH0_TENANT_NAME>:<YOUR_AUTH0_CONNECTION_NAME>`. |\n| **ProtocolBinding** | The protocol [binding type](https://www.ibm.com/support/knowledgecenter/en/SSPREK_9.0.4/com.ibm.isam.doc/config/concept/fed_SAML20_bindings.html). |\n| **AssertionConsumerServiceURL** | The URL where the IdP sends the response after the user signs in. Include the `ProtocolBinding` attribute in the request template if you use this. |\n| **Destination** | The URL where Auth0 sends the request. This should be the **Sign In URL** configured for the connection. |\n| **LoginHint** | The username or email of the user logging in. If you are using [Identifier First Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first), Auth0 can send this value to the IdP to pre-populate it in the IdP's login form. |\n| **ProviderName** | The name of the application that initiated the request. |\n| **Connection.<options-key>** | Use dot notation on the `Connection` key to access any of the connection's `options` values as returned from the Auth0 Management API's [Get a Connection](https://auth0.com/docs/api/management/v2/#!/Connections/get_connections_by_id) endpoint. For example, if the connection has `options.some_property: \"value\"`, then you can use `@@Connection.some_property@@` in the template. |\n| **AssertServiceURLAndDestination** | Deprecated. For new configurations, use `AssertionConsumerServiceURL` and `Destination` instead. |\n\n## Configure the IdP\n\nGo to [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings) to find the metadata you'll need to provide to the IdP.\n\nAuth0 supports all SAML IdPs that conform to the SAML 1.1 or SAML 2.0 protocol. We have detailed instructions for configuring specific providers:\n\n*   [ADFS](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-adfs-saml-connections)\n    \n*   [Okta](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-okta-as-saml-identity-provider)\n    \n*   [OneLogin](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-onelogin-as-saml-identity-provider)\n    \n*   [Ping7](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-pingfederate-as-saml-identity-provider)\n    \n*   [Salesforce](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-salesforce-as-saml-identity-provider)\n    \n*   [SiteMinder](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-siteminder-as-saml-identity-provider)\n    \n*   [SSOCircle](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-ssocircle-as-saml-identity-provider)\n    \n\n## Test connection\n\nTo test your connection in the Dashboard:\n\n1.  Go to [Dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n2.  Locate the connection you created, select the **...** (three dots) menu icon, and select **Try**.\n    \n3.  A Universal Login Page will appear and prompt you to enter credentials.\n    \n4.  Enter the email address of a user who exists in the IdP. If you configured [Home Realm Discovery](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first#define-home-realm-discovery-identity-providers), make sure you enter an email address that uses one of the specified domains.\n    \n5.  After you are redirected to the login screen for the IdP, log in as you normally would.\n    \n6.  You will be redirected to a page on Auth0 that displays the contents of the authentication assertion sent to Auth0 from the IdP.\n    \n\n## Troubleshoot connection\n\nIf your connection is not working as expected, try the following steps:\n\n*   Clear your browser history, cookies, and cache before each test. If you do not, the browser may not pick up the latest configuration information, or it may have stale cookies that affect execution.\n    \n*   Ensure that your browser allows cookies and has JavaScript enabled.\n    \n*   [Capture a HAR file](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files) of the transaction, and then use the [Auth0 SAML Tool](http://samltool.io/) to decode the SAML assertion and inspect its contents.\n    \n\n## Learn more\n\n*   [Customize SAML Assertions](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)\n*   [Sign and Encrypt SAML Requests](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/sign-and-encrypt-saml-requests)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors)",
  "title": "Configure Auth0 as SAML Service Provider",
  "description": "Describes how to configure Auth0 to serve as a service provider in a SAML federation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-gcp-as-reverse-proxy",
  "markdown": "# Configure Google Cloud Platform with Load Balancing as Reverse Proxy\n\nYou can set up Google Cloud Platform (GCP) with load balancing as a reverse proxy. The following diagram describes components in the configuration.\n\n*   **Google Cloud Platform Load Balancer** distributes traffic across multiple instances of applications.\n    \n*   **Internet Network Endpoint Group** is a backend that resides outside of Google Cloud. See [Internet Network endpoint group](https://cloud.google.com/load-balancing/docs/negs/internet-neg-concepts) for details.\n    \n\n![Google Cloud Platform with Load Balancing as Reverse Proxy flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/62abKXSoxy0b7uxBfmoWjs/4d6c05060d16d36265e5184ccb3d95b9/gcp-load-balancing-reverse-proxy-diagram.png)\n\n1.  [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates) if you haven't already. Make note of the **Origin Domain Name** and `cname-api-key` values for use later.\n    \n2.  Verify ownership of the domain by adding a TXT record in your DNS server in the [Auth0 Dashboard > Tenant Settings > Custom Domains](https://manage.auth0.com/#/tenant/custom_domains) and click **Verify**.\n    \n3.  Once GCP has verified your domain, log in to the [GCP console](https://console.cloud.google.com/).\n    \n4.  Go to **Network Services > Load Balancing**. Click **Create Load Balancer**. To learn more, see [Google Cloud Platform Load Balancing](https://cloud.google.com/load-balancing/docs) in Google Cloud documentation.\n    \n    1.  Select **HTTP(S) Load Balancing**.\n        \n    2.  Select **From Internet to my VMs** because we need to route the traffic from Internet to Auth0. Click **Continue**.\n        \n    3.  Provide a name for the load balancer such as `auth0-reverse-proxy` and click **Create**.\n        \n5.  Configure the backend.\n    \n    1.  Create an [](https://cloud.google.com/load-balancing/docs/negs/internet-neg-concepts)internet network endpoint group (NEG) which is a backend that resides outside of Google Cloud. To learn more, see [Internet network endpoint groups overview](https://cloud.google.com/load-balancing/docs/negs/internet-neg-concepts) in Google Cloud documentation.\n        \n    2.  Select the newly created Internet NEG as a backend in the backend service configuration and set the `cname-api-key` and `host` value (origin domain name) from your Auth0 tenant.\n        \n    3.  Click **Done**.\n        \n6.  Set up the `host` and `path` rules.\n    \n    1.  Choose **Action** as **Route traffic to a single backend**.\n        \n    2.  In **Host rewrite**, enter your origin domain name from your Auth0 tenant that you saved earlier.\n        \n    3.  Click **Create**.\n        \n7.  Configure the frontend.\n    \n    1.  Create a certificate. The easiest method is to choose **Google-managed certificate** because Google automatically provisions the SSL certificate for you.\n        \n    \n    1.  If you do not choose a Google-managed certificate, then it is your responsibility to renew and upload the SSL certificate with your certificate authority before it expires.\n        \n8.  Review and finalize the configuration. It will take a minute for GCP to configure the load balancer. Typical issues that might cause an error include:\n    \n    *   **Invalid API key**: The `cname-api-key` was not set to Auth0 from GCP.\n        \n    *   **403 Forbidden**: The `host` header was not sent to Auth0 from GCP.\n        \n9.  Log in to your DNS provider and [set up the CNAME](https://auth0.com/docs/custom-domains/configure-custom-domains-with-auth0-managed-certificates#add-cname-verification-record-to-dns-record).\n    \n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)",
  "title": "Configure Google Cloud Platform with Load Balancing as Reverse Proxy",
  "description": "Learn how to set up Google Cloud Platform (GCP) with load balancing for use as the custom domain proxy for Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy",
  "markdown": "# Configure Cloudflare as Reverse Proxy\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects the availability of this feature. To learn more, read [Auth0's Pricing Page](https://auth0.com/pricing).\n\nTo set up Cloudflare as a reverse proxy using the recommended approach, a Cloudflare Enterprise Plan with the following features is required:\n\n## Configure Cloudflare\n\nTo configure Cloudflare as a reverse proxy, you’ll need to create a CNAME record, a Page Rule, and a Transform Rule in Cloudflare.\n\n1.  [Configure and verify a Custom Domain with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates) if you haven't already. Make note of the **Origin Domain Name** and **cname-api-key** values since you'll need these later.\n    \n2.  In the Cloudflare dashboard for the target zone, [create a CNAME record](https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-dns-records/#create-dns-records) with the following settings:\n    \n    | **Setting** | **Value** |\n    | --- | --- |\n    | Name | The custom domain name. |\n    | Target | The **Origin Domain Name** value recorded earlier. |\n    | Proxy Status | `Proxied` |\n    \n3.  [Create a Page Rule](https://support.cloudflare.com/hc/en-us/articles/200172336-Creating-Page-Rules) scoped to all URLs under the chosen custom domain and with the following settings:\n    \n    | **Setting** | **Value** |\n    | --- | --- |\n    | Host Header Override | The **Origin Domain Name** value recorded earlier. |\n    | True-Client-IP | `Enable` |\n    \n4.  [Create a Transform Rule](https://developers.cloudflare.com/rules/transform/request-header-modification/create-dashboard/):\n    \n    1.  Switch to the **Modify Request Header** view.\n        \n    2.  Select **Create Rule** and provide a name of your choice.\n        \n    3.  Under **When incoming requests match**, select **Custom filter expression** and set an expression that scopes the Rule to requests associated with the chosen custom domain. For example, use an exact match on the **Hostname** field.\n        \n    4.  Under Modify request header, select **Set static**, and then set the following fields:\n        \n        | **Field** | **Value** |\n        | --- | --- |\n        | Header name | `cname-api-key` |\n        | Value | The **cname-api-key** value recorded earlier. |\n        \n5.  Ensure that [Always Use HTTPS](https://developers.cloudflare.com/ssl/edge-certificates/additional-options/always-use-https/) is enabled and [encryption mode](https://developers.cloudflare.com/ssl/origin-configuration/ssl-modes/) is set, at least, to **Full** for your chosen custom domain.\n    \n\n## Configure Auth0\n\nCall the Auth0 Management API [Update custom domain configuration](https://auth0.com/docs/api/management/v2#!/Custom_Domains/patch_custom_domains_by_id) endpoint with the following payload in the body:\n\n```\n{\n  \"custom_client_ip_header\": \"true-client-ip\"\n}\n```\n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)",
  "title": "Configure Cloudflare as Reverse Proxy",
  "description": "Learn how to set up Cloudflare for use as the custom domain proxy for Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/migrate-private-cloud-custom-domains",
  "markdown": "# Migrate Private Cloud Custom Domains\n\nBeginning with Private Cloud release 1906, dedicated deployments will include the ability to fully utilize the [Auth0 Custom Domains](https://auth0.com/docs/customize/custom-domains) feature.\n\nExisting Private Cloud customers using custom domains are able to complete a migration of their Private Cloud custom domains to the Auth0 custom domains. New customers/deployments will automatically use the Auth0 custom domains features.\n\n| Feature | New Custom Domains | Legacy Custom Domains |\n| --- | --- | --- |\n| Use of custom domain in emails | Yes | No  |\n| Custom domain protection via API keys | Yes | No  |\n| Custom domain registration | Yes | Yes |\n| Token issuer used as custom domain | Yes | No  |\n| Auth0-managed certificates | Yes | No  |\n| Use of multiple domains | No  | Yes |\n\n## Requirements\n\n*   A new DNS domain dedicated to the custom domain's origin server hostname. This could be a subdomain of your existing Auth0 domain (i.e., if your domain name is `*.auth.mydomain.com`, the new subdomain would be `*.cd.auth.mydomain.com`).\n    \n*   A wildcard public SSL certificate for the new DNS domain.\n    \n*   A layer 4 network load balancer. This could be the existing one used by your Private Cloud deployment. Please note that if you are using a layer 7 load balancer, you must add a layer 4 load balancer.\n    \n*   A DNS record pointing to the layer 4 load balancer.\n    \n\n## Migration process\n\nCurrent Private Cloud customers using the existing Private Cloud custom domains must migrate to the Auth0 custom domains to fully benefit from the available features.\n\nThe custom domains migration process involves three phases, each of which requires several steps.\n\n### Communication phase\n\nBefore beginning the migration process, Auth0 will reach out to you to explain the migration process and discuss the following:\n\n*   The certificate management model you would like to use: Auth0 offers two certificate management models. To simplify the migration process, we suggest using one model for all of your tenants (though you can use a different certificate model for each tenant if necessary).\n    \n*   The type of load balancer you are using (i.e. network (layer 4) or application (layer 7)). If your dedicated deployment is AWS-hosted, we will need to confirm the type of load balancer you are using. If you are using an application load balancer, you will need to provision an additional network load balancer.\n    \n\nAllocating new DNS resources to meet stated requirements (if necessary)You will need to have ready the edge domain name and accompanying SSL certificate, the CNAME host name, and the email address to be used as the Let's Encrypt contact.\n\n### Infrastructure preparation phase\n\nAuth0 will prepare your environment for migration on your behalf. During this stage, you will need to:\n\n1.  Set up the network load balancer\n    \n2.  Set up your new DNS records\n    \n3.  Validate and verify that your set up is correct\n    \n\n### Migration phase\n\nThe goal of the migration phase is to create custom domains that have all the new functionality and to update all dependencies to function correctly with your newly-created domain names.\n\nThe first step is to create new domains using the Auth0 Custom Domains feature.\n\nOnce done, you may have additional configuration steps, depending on the Auth0 features you use.\n\n### Final configuration\n\nOnce you have completed all of the required modifications on your applications, a Managed Services Engineer will assist you in completing the migration process.\n\n## Learn more\n\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)",
  "title": "Migrate Private Cloud Custom Domains",
  "description": "Describes Auth0 Private Cloud custom domain migration.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-aws-cloudfront-for-use-as-reverse-proxy",
  "markdown": "# Configure AWS CloudFront as Reverse Proxy\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nYou can configure AWS CloudFront for use as the reverse proxy with custom domain names for your Auth0 tenant.\n\n1.  Log in to AWS, and navigate to [CloudFront](https://console.aws.amazon.com/cloudfront).\n    \n2.  Click **Create Distribution**.\n    \n3.  You can choose the delivery method for your content. Click **Get Started** under the **Web** section.\n    \n4.  Configure your distribution settings. Here are the values you'll need to change.\n    \n    | Setting | Value |\n    | --- | --- |\n    | Origin Domain Name | Set this to the **Origin Domain Name** value obtained from the Auth0 Dashboard during the Custom Domains setup process |\n    | Origin ID | A description for the origin. This value lets you distinguish between multiple origins in the same distribution and therefore must be unique. |\n    | Origin Protocol Policy | Set to `HTTPS Only` |\n    | Alternate Domain Names (CNAMEs) | Set to your custom domain name (the same one your configured in the Auth0 Dashboard) |\n    | SSL Certificate | Set to the SSL Certificate for your custom domain stored in AWS Certificate Manager (ACM) in the US East(N. Virginia) Region or in IAM. |\n    \n5.  Provide information on the **Origin Custom Headers** (the **Header Name** and **Value** fields appear only after you've provided an **Origin Domain Name**)\n    \n    | Setting | Value |\n    | --- | --- |\n    | Header Name | Set to `cname-api-key` |\n    | Value | Set to the CNAME API Key value that you were given immediately after you verified ownership of your domain name with Auth0 |\n    \n6.  Configure the **Default Cache Behavior Settings**. Here are the values you'll need to change\n    \n    | Setting | Value |\n    | --- | --- |\n    | Viewer Protocol Policy | Select **Redirect HTTP to HTTPS** |\n    | Allowed HTTP Methods | Select **GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE** |\n    | Cache and origin request settings | Select **Legacy cache settings** |\n    | Cache Based on Selected Request Headers | Select **Include the following headers** |\n    | Add Headers | Enter `User-Agent` and click **Add Custom >>** to add the custom header. Do the same for `Authorization`, `Origin`, `Referer`, `Accept-Language`, and `Accept` headers. |\n    | Forward Cookies | Select **All** |\n    | Query Strings | Select **All** |\n    \n7.  Scroll to the bottom of the page and click **Create Distribution**. You'll see your newly-created distribution in your CloudFront Distributions list. Note that the Status will reflect `In progress` until the distribution is Deployed.\n    \n8.  Add a new CNAME record to your DNS for your custom domain pointing to the CloudFront Domain Name for your Distribution. This can be found by clicking on your Distribution ID, under the General tab, Domain Name (for example, `e2zwy42nt1feu7.cloudfront.net`).\n    \n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)",
  "title": "Configure AWS CloudFront as Reverse Proxy",
  "description": "Learn how to configure AWS CloudFront for use as the custom domain proxy for Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/sessions/session-layers",
  "markdown": "# Session Layers\n\nThere are typically three session layers that can be created when your users log in:\n\n*   **Application Session Layer**: This layer is the session inside your application. Though your application uses Auth0 to authenticate users, your application also tracks that the user has logged in to your application; in a regular web application, for example, you achieve this by storing this information inside a cookie.\n    \n*   **Auth0 Session Layer**: Auth0 also maintains a session on the Authorization Server for the user and stores their user information inside a cookie. This layer is used so that the next time a user is redirected to Auth0 for login the user's information will be remembered. This session layer makes the SSO experience possible for inbound SSO implementations.\n    \n*   **Identity Provider Session Layer**: When users attempt to sign in using an identity providers such as Facebook or Google, and they already have a valid sign-in (with whichever provider they choose) they will not be prompted again to sign in though they may be asked to give permission to share their information with Auth0 and, in turn, your application.\n    \n\n### Session logout\n\nLogout in the context of Auth0 implementations is the act of terminating an authenticated session. It is a security best practice to terminate sessions when they’re no longer needed to avoid a potential takeover by unauthorized parties.\n\nAuth0 provides tools to help you give users the ability to log out; this includes options for providing different levels of logout and also determining where the user will land after the logout is complete.\n\n*   **Application Session Layer Logout**: Logging users out of your applications typically results in their application session being cleared, and this should be handled by your application: for the Application Session Layer, there is nothing within your Auth0 tenant that you need to use to facilitate session termination. This will require you to utilize whatever application session stack you are using to clear out any session related information. Note that some of the Auth0 SDKs do provide some support for application sessions; please check the documentation to see if there is any local SDK session removal that needs to be done.\n    \n*   **Auth0 Session Layer Logout**: You can log users out of the Auth0 session layer by redirecting them to the Auth0 Logout endpoint so Auth0 can clear the SSO cookie.\n    \n*   **Identity Provider Session Layer Logout**: It is not necessary to log the users out of this session layer, but you can use Auth0 to force the logout if required.\n    \n\n#### Redirect URLs\n\nLogging out of your Auth0 Session Layer will require you to redirect the user to `https://<{yourCNAME}` or `{yourTenant}.auth0.com>/oidc/logout` - typically performed via use of the appropriate method in the Auth0 SDK for your technology stack. This will clear your Auth0 session. You will also want to add a query parameter for that request called `id_token_hint` - this parameter should contain a URL that has been pre-registered and protects you against open redirect attacks.\n\nAuth0 only redirects to AllowListed URLs after logout and there are two places you can configure these. The first place you can set this is at your Auth0 tenant level where you can put the set of logout URLs that are shared between all applications. The second place is in the application settings: if you need different redirects for each application, you can allowlist the URLs in your application settings. This allows you to set logout URLs in an application-specific context.\n\n#### Session lifetime and session timeout\n\nYou can set the behavior in cases where a user doesn’t explicitly log out of your application. Auth0 provides [session lifetime](https://auth0.com/docs/manage-users/sessions/session-lifetime-limits) limits to deal with Auth0 session termination in this scenario.\n\n#### Federated logout\n\nYou can also log the users out of the identity provider session layer. While this is not recommended, for many providers, Auth0 provides this behavior by having you add the `federated` query parameter to the redirect to `/oidc/logout`. This redirects the user to their identity provider and logs them out there as well. To learn more about federated logout, review the article [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps).\n\n## Learn more\n\n*   [Session Lifetime Limits](https://auth0.com/docs/manage-users/sessions/session-lifetime-limits)",
  "title": "Session Layers",
  "description": "Describes layers created when users log in.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-azure-cdn-for-use-as-reverse-proxy",
  "markdown": "# Configure Azure CDN as Reverse Proxy\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nTo set up Azure CDN as a reverse proxy, an Azure CDN Premium plan is required.\n\n1.  [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates) if you haven't already. Make note of the **Origin Domain Name** and **cname-api-key** values since you'll need these later.\n    \n2.  Login to the [Azure Portal](https://portal.azure.com/).\n    \n3.  [Create a new Azure CDN Profile](https://docs.microsoft.com/en-us/azure/cdn/cdn-create-new-endpoint#create-a-new-cdn-profile).\n    \n4.  [Create a new Azure CDN endpoint](https://docs.microsoft.com/en-us/azure/cdn/cdn-create-new-endpoint#create-a-new-cdn-endpoint) using the CDN Profile you just created. For the CDN endpoint settings, use the following values:\n    \n    | Setting | Value |\n    | --- | --- |\n    | Name | We recommend naming your CDN endpoint like your custom domain name, replacing dots with dashes. For example: **login-mydomain-com.azureedge.net**. |\n    | Origin type | Select **Custom Origin** |\n    | Origin hostname | Enter `{yourTenant}.<CUSTOM_DOMAIN_ID>.edge.tenants.us.auth0.com`, making sure to replace `<CUSTOM_DOMAIN_ID>` with the custom domain ID from the **Origin Domain Name** you received from Auth0. If your tenants are not in the US region, use one of the following:<br><br>*   EU: `{yourTenant}.<CUSTOM_DOMAIN_ID>.edge.tenants.eu.auth0.com`<br>*   AU: `{yourTenant}.<CUSTOM_DOMAIN_ID>.edge.tenants.au.auth0.com`<br>*   JP: `{yourTenant}.<CUSTOM_DOMAIN_ID>.edge.tenants.jp.auth0.com` |\n    | Origin path | Leave blank. |\n    | Origin host header | Use the name you provided for the Origin hostname. |\n    | Protocol | Disable HTTP so that only HTTPS is enabled. |\n    \n5.  [Add your custom domain to your Azure CDN endpoint](https://docs.microsoft.com/en-us/azure/cdn/cdn-map-content-to-custom-domain).\n    \n6.  [Configure HTTPS for your Azure CDN custom domain](https://docs.microsoft.com/en-us/azure/cdn/cdn-custom-ssl?tabs=option-1-default-enable-https-with-a-cdn-managed-certificate). This process requires you to verify ownership of the domain. Once done, it may take up to 6 hours to deploy the certificate to all of the CDN pop locations.\n    \n7.  Set up the configuration for the custom domain communication with Auth0 using the Azure CDN Rules engine. (To learn more, see [Override HTTP behavior using the Azure CDN from Verizon Premium rules engine](https://docs.microsoft.com/en-us/azure/cdn/cdn-verizon-premium-rules-engine) in Microsoft documentation.) [Create a new Azure CDN Rule](https://docs.microsoft.com/en-us/azure/cdn/cdn-verizon-premium-rules-engine#tutorial) with the following settings:\n    \n    | Setting | Value |\n    | --- | --- |\n    | Name/Description | Auth0 Custom Domain |\n    | Type of requests | Select the **Edge CName** option, then select your custom domain name from the list. |\n    \n8.  Add the following **Features** to your Azure CDN Rule: We recommend creating another Azure CDN Rule to deny the usage of the **azureedge.net** CNAME.\n    \n    | Setting | Value |\n    | --- | --- |\n    | Bypass Cache | **Enabled** |\n    | Modify Client Request Header | Select **Override**, enter **cname-api-key** for the name, and enter the CNAME API Key provided by Auth0 as the value. |\n    \n9.  Once the Azure CDN Rule is approved, the status will change from Pending XML to Active XML. At this point, Azure CDN will be publishing the rules and certificates. When Azure finishes processing all changes, you can use your custom domain.\n    \n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)",
  "title": "Configure Azure CDN as Reverse Proxy",
  "description": "Learn how to set up Azure CDN for use as the custom domain proxy for Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains",
  "markdown": "# Troubleshoot Custom Domains\n\nSee the following video on common issues with custom domains and refer to the sections below for troubleshooting steps for specific scenarios.\n\n## Custom domain is still pending verification\n\nIt can take up to 48 hours for the DNS to be propagated.\n\n*   If you continue to see this error in the Dashboard, ensure that the CNAME record is properly configured in your domain management service. You can confirm the configuration of your CNAME record using:\n    \n    *   A tool like [Mxtoolbox](https://mxtoolbox.com/DNSLookup.aspx) or [Google](https://dns.google.com/)\n        \n    *   The `dig` command in your terminal\n        \n*   Ensure that the domain name is not already associated with an A record.\n    \n*   Ensure that no errors were made when typing or copying the CNAME record's domain name or value.\n    \n\nIf you have ensured the above and the custom domain is still pending verification, wait 4 hours before reverifying your domain. To avoid any interruptions to your service, do not recreate the custom domain when reverifying.\n\n## Cloudflare CNAME flattening\n\nCNAME flattening affects the Auth0 verification and certificate renewal processes due to the way it handles DNS records. Enabling CNAME flattening in Cloudfare after setting up a custom domain does **not** prevent certificate renewal.\n\nIf you need to enable CNAME flattening for all subdomains managed by Cloudfare and also configure a specific subdomain to be an Auth0 custom domain, consider delegating the subdomain for Auth0 to another DNS provider. To learn more, read [Delegating Subdomains Outside of Cloudflare](https://support.cloudflare.com/hc/en-us/articles/360021357131-Delegating-Subdomains-Outside-of-Cloudflare) in the Cloudflare documentation. This will enable you to use CNAME flattening for all subdomains except the one used for Auth0.\n\n## \"You should not be hitting this endpoint\"\n\nIf you see this error when configuring a custom domain, you must perform additional configurations, which varies depending on your setup. To learn more, see [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains).\n\n## \"Service not found\"\n\nIf your application issues an `/authorize` request with `audience=https://login.northwind.com/userinfo`, the server will return a `Service not found: https://login.northwind.com/userinfo` error. This is because even if you set a custom domain the API identifier for the `/userinfo` endpoint remains `https://{yourOriginalAuth0Domain}/userinfo`.\n\nSimilarly, using your custom domain in calls to the [Auth0 Management API](https://auth0.com/docs/api/management/v2) will error for the same reason.\n\nTo fix this your app should instead use `audience=https://{yourOriginalAuth0Domain}/userinfo`. You can also remove this `audience=[...]/userinfo` parameter altogether if your application is flagged as **OIDC-Conformant** in the **OAuth2** tab of the application's **Advanced Settings**.\n\nIf you are using Internet Explorer, you may see any of the following error messages:\n\n*   \"No verifier returned from client\"\n    \n*   \"Origin header required\"\n    \n*   \"Failed cross origin authentication\"\n    \n\nWhen both the Auth0 domain and the app domain are in the same trusted or local intranet zone, Internet Explorer does not treat the request as a cross-domain request and therefore does not send the cross-origins header.\n\nIf you see any of these errors and you are using Embedded Login, you can move one of the sites out of the trusted or local intranet zone. To do this:\n\n1.  Go to **Internet Options > Security**.\n    \n2.  Select the **Local Intranet Zone** tab and go to Sites > Advanced. Add your domain.\n    \n3.  Return to the **Security** tab, and make sure the proper zone has been selected.\n    \n4.  Click **Custom Level** and look for **Access data sources across domains** under the **Miscellaneous** section. Check the radio button next to **Enable**.\n    \n\nAlternatively, you can remove reliance on cross-origin authentication by implementing [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Configure Custom Domains with Auth0-Managed Certificates](https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates)\n*   [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)",
  "title": "Troubleshoot Custom Domains",
  "description": "Learn how to troubleshoot issues with custom domains.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/sessions/session-lifetime-limits",
  "markdown": "# Session Lifetime Limits\n\nSession lifetime limits determine how long the system should retain a login session. In Auth0, two settings can be configured for session lifetime:\n\n*   **Inactivity timeout**: Timeframe after which a user's session will expire if their session cookie hasn't interacted with the Authorization Server. Will be superseded by system limits if over 3 days for self-service plans or 100 days for enterprise plans.\n    \n*   **Require log in after**: Timeframe after which a user will be required to log in again, regardless of their activity. Will be superseded by system limits if over 30 days for self-service plans or 365 days for enterprise plans.\n    \n\nThese settings are configured on the tenant; you can configure them using either the [Auth0 Dashboard](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings) or the Management API.\n\nWhen a user performs a new standard login, it resets the login session. Here's an example:\n\n1.  You set the **Inactivity timeout** limit to 3 days and the **Require log in after** limit to 30 days.\n    \n2.  A user logs in and your entered values are set for their session.\n    \n    1.  If the user is active within the three-day **Inactivity timeout** timeframe, the session lifetime is extended for another three days. As long as the user is active within the next three days, their session lifetime will be extended for another three days, until the **Require log in after** limit is reached. At this point, the user will be required to log in again.\n        \n    2.  If the user is inactive for three days, they will automatically be logged out.\n        \n3.  While the user is logged in, you extend the existing session lifetime limits. The new settings will not take effect until the existing session ends, and the user logs in again.\n    \n4.  While the user is logged in, you reduce the existing lifetime limits. The new settings will take effect immediately upon the user's next activity. This allows you to shorten session lifetimes for security purposes.\n    \n\n### Application-specific logout URLs\n\nThere are two important things to consider when you use application-specific logout URLs:\n\n*   You **must** send `client_id` as a query parameter when calling the `/oidc/logout` endpoint and the `id_token_hint` URL must be in the application’s list of allowed logout URLs.\n    \n*   This will end the Auth0 Session for the entire tenant - i.e. for all defined applications, not just the one that matches the `client_id` supplied. Passing the `client_id` tells the /`logout` endpoint where to look for the logout URL white-list.\n    \n\nAfter the user logout occurs Auth0 will only redirect to a URL that is defined in this list.\n\nIf you redirect the user back to the application after logout and the application redirects to an identity provider that still has an authenticated session for that user, the user will be silently logged back into your application and it may appear that logout didn’t work. In these cases, we recommend that you have a specific logout landing page in your application so you can tell the user that they successfully logged out - and, if desired, you can also warn them that they may still be logged into their identity provider.\n\nIn the case where a user has not taken any actions that cause the Auth0 session to be updated, we recommend that you warn the user to choose to explicitly continue their session. The intent of this approach allows the session to go inactive if the user is no longer present but otherwise provides a means to trigger the silent token refresh so that they can continue their session without the need to be prompted again for credentials.\n\n*   **Inactivity Timer**: Add a rolling timer to the React SDK wrapper that aligns with the maximum idle lifetime of the Auth0 session. Each time a token is returned to the application, reset the timer.\n    \n*   **Timeout Modal**: When the timer hits 60 seconds from expiration, a timeout modal should render requesting the user to logout or continue their session.\n    \n    *   **Continue the session**: If the user chooses to continue their session, use the `getTokenSilently()` method to request a new token without redirecting the user from the page they are currently interacting with.\n        \n    *   **Logging out**: In the case, the user chooses to logout the `logout()` method should be called to assure the Auth0 session is ended as well.\n        \n    *   **Idle Timeout**: In the case that the idle timeout is reached no immediate action is necessary. To handle the fact that the user may still be active in another tab, the behavior **should not** be to log the user out.\n        \n    *   Other options include updating the modal with a login button, using the window.onfocus event to trigger `getTokenSilently()`, or redirecting the user to landing page.\n        \n\n## Learn more\n\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Update Access Token Lifetime](https://auth0.com/docs/secure/tokens/access-tokens/update-access-token-lifetime)\n*   [Update ID Token Lifetime](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime)\n*   [Check Login and Logout Issues](https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues)\n*   [Troubleshoot Invalid Token Errors](https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors)",
  "title": "Session Lifetime Limits",
  "description": "Describes limits a system will allow a session to last before termination.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/sessions/manage-multi-site-sessions",
  "markdown": "# Manage Multi-Site Sessions with Auth0 SDK\n\n## Short-lived sessions\n\nThis workflow shows how the auth0-spa-js SDK should be implemented to support multi-site session management. In this scenario, it is assumed that the tenant SSO Inactivity Timeout is set to 300 seconds, and the ID Token Expiration of each SPA application is set to 150 seconds. This is considered a \"short-lived\" session.\n\n### SDK features\n\n#### PKCE flow\n\nFor all methods of retrieving an ID Token or Access Token, the SDK manages all the intricacies of the Proof Key for Code Exchange workflow. No additional effort or configuration is needed for this to work.\n\n#### Deep linking\n\nTo improve the user experience the SDK includes an `appState` parameter for the `loginWithRedirect()` method. Details about the current app are packaged as part of the request to the Auth server that will be returned upon successful authentication. Allowing a seamless continuation of the user journey.\n\nIn the Quickstart, the `PrivateRoute` component sets a state parameter of `targetUrl` and the `onRedirectCallback` function of `index.js` unpacks this value to redirect the user when authentication is complete.\n\n#### Token storage\n\nTo keep the returned tokens stored in the safest manner possible all tokens are placed into a local cache. The ID and Access Tokens are stored as pairs with the audience and scope values being used to retrieve the tokens as needed.\n\nAdditionally the cache tokens are removed once either the ID Token or Access Token expires so that if a token is in the cache it can be assumed to stil be valid.\n\n#### Call APIs\n\nThe `getTokenSilently()` method is used to leverage the token cache first, and if none exists, will launch an invisible iframe to retrieve a new token. For this purpose all requests to APIs can use this method to construct the bearer token header without the need for additional logic to handle for expired tokens.\n\nIn the Quickstart, the `ExternalService` view makes a request to the express API using this feature.\n\n#### Warn users to continue their sessions\n\nIn the case where a user has not taken any actions that would cause the Auth0 session to be updated, Auth0 recommends that you raise a warning to the user to choose to explicitly continue their session.\n\nThe intent of this approach allows the session to go inactive if the user is no longer present, but otherwise provides a means to trigger the silent token refresh so that the can continue their session without the need to be prompted again for credentials.\n\nTo learn more about inactivity timers and timeout modals, read [Application-specific logout URLs](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings).\n\n### Example workflow\n\n1.  Initial Authentication\n    \n2.  Maintaining Auth0 Session\n    \n3.  Seamless SSO\n    \n4.  Prompting user to extend session\n    \n5.  User explicitly logs out of application\n    \n6.  User returns to initial app after logging out\n    \n\n#### Initial authentication\n\n1.  New tab is opened\n    \n2.  Requests to login\n    \n3.  User enters credentials\n    \n4.  SSO cookie (with expiration) is set\n    \n5.  Token exchange performed\n    \n\n![Diagram of Initial Authentication flow](https://images.ctfassets.net/cdy7uua7fh8z/2voC3vs36CJJlpDu4xl06Y/310fe5afe79ad7d083833baa2690dfa4/initial-authentication.png)\n\n#### Maintain Auth0 session\n\n1.  User requests data from protected resource\n    \n2.  `getTokenSilently()` called\n    \n3.  Resource retrieved\n    \n4.  User updates data from protected resource\n    \n5.  `getTokenSilently()` called\n    \n    1.  Iframe opened\n        \n    2.  Token exchange performed\n        \n6.  Resource is updated\n    \n\n![Diagram of maintaining a session](https://images.ctfassets.net/cdy7uua7fh8z/7CI29ouvhuJ4TFC1G2C5n8/4d2bd0c9372a6cc16e75fc76f438a0bd/maintain-auth0-session.png)\n\n#### Seamless SSO\n\n1.  User navigates to a private route\n    \n2.  Check with `isAuthenticated()`\n    \n3.  If false, `loginWithRedirect()`\n    \n\n![Diagram of seamless SSO flow for sessions](https://images.ctfassets.net/cdy7uua7fh8z/38heJlnN0letWMVhpTtXad/4d4127150fb818522ea29eea28ccc00e/seamless-sso.png)\n\n#### Prompt user to extend session\n\n1.  At 240 seconds prompt user with keep session alive with modal that lasts 60 seconds\n    \n2.  If they choose to maintain session, `getTokenSilently()`\n    \n\n![Diagram of prompting a user to maintain a session](https://images.ctfassets.net/cdy7uua7fh8z/6kH2G3oclCfSudwd0hJEUM/70651da37771c9945c5a34dcad409d9f/prompt-user-extend-session.png)\n\n#### User explicitly logs out of application\n\n1.  User chooses to logout\n    \n2.  `logout()` called\n    \n    1.  Token cache cleared\n        \n    2.  Call `/oidc/logout`\n        \n    3.  Clear SSO cookie & delete session data\n        \n    4.  Redirect user to logout page\n        \n\n![Diagram of a user logging out](https://images.ctfassets.net/cdy7uua7fh8z/4b55FKM2vZBoskXTPY4nxs/1a9e69437677f2cfac9a3d8e6bff7ffe/user-explicitly-logs-out-of-app.png)\n\n#### User returns to initial application after logging out\n\n1.  User requests data from protected resource\n    \n2.  `getTokenSilently()` called\n    \n3.  Application-dependent behavior\n    \n\n![Diagram of user returning to application after logging out](https://images.ctfassets.net/cdy7uua7fh8z/3geXGwsXkIgFkwopoGoLMx/01685b6b8e8473c6ce6f26e59b402cf3/user-returns-to-initial-app.png)\n\n## Long-lived sessions\n\nAuth0 supports long-lived sessions for enterprise plans. With long-lived sessions, you can configure session limits with up to 100 days of inactivity (idle timeout) and up to one year in total duration (absolute timeout). If you have quarterly, monthly, or other timelines, this allows you to reduce friction for end-users and provide access to low-risk content and capabilities. In addition, media companies can leverage long-lived sessions for improving user experiences through seamless access to content. You can also make the choices between long-lived sessions and password validation based on your requirements around user experience and security.\n\nWorkflow details would change in the case of a long-lived session where the application session would most likely be shorter than the [Single Sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on) session.\n\nTo learn more, read [Configure Session Lifetime Limits](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings) and [Update Access Token Lifetime](https://auth0.com/docs/secure/tokens/access-tokens/update-access-token-lifetime).\n\n## Learn more\n\n*   [Troubleshoot Invalid Token Errors](https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)",
  "title": "Manage Multi-Site Sessions with Auth0 SDK",
  "description": "Describes the workflow with the auth0-spa-js SDK to support multi-site session management.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings",
  "markdown": "# Configure Session Lifetime Settings\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"session_lifetime\": SESSION_LIFETIME_VALUE, \"idle_session_lifetime\": IDLE_SESSION_LIFETIME_VALUE }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"session_lifetime\\\": SESSION_LIFETIME_VALUE, \\\"idle_session_lifetime\\\": IDLE_SESSION_LIFETIME_VALUE }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{ \\\"session_lifetime\\\": SESSION_LIFETIME_VALUE, \\\"idle_session_lifetime\\\": IDLE_SESSION_LIFETIME_VALUE }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"session_lifetime\\\": SESSION_LIFETIME_VALUE, \\\"idle_session_lifetime\\\": IDLE_SESSION_LIFETIME_VALUE }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: '{ \"session_lifetime\": SESSION_LIFETIME_VALUE, \"idle_session_lifetime\": IDLE_SESSION_LIFETIME_VALUE }'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ \"session_lifetime\": SESSION_LIFETIME_VALUE, \"idle_session_lifetime\": IDLE_SESSION_LIFETIME_VALUE }\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"session_lifetime\\\": SESSION_LIFETIME_VALUE, \\\"idle_session_lifetime\\\": IDLE_SESSION_LIFETIME_VALUE }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"session_lifetime\\\": SESSION_LIFETIME_VALUE, \\\"idle_session_lifetime\\\": IDLE_SESSION_LIFETIME_VALUE }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"session_lifetime\\\": SESSION_LIFETIME_VALUE, \\\"idle_session_lifetime\\\": IDLE_SESSION_LIFETIME_VALUE }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\n\nlet postData = NSData(data: \"{ \"session_lifetime\": SESSION_LIFETIME_VALUE, \"idle_session_lifetime\": IDLE_SESSION_LIFETIME_VALUE }\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Configure Session Lifetime Settings",
  "description": "Describes how to configure session lengths and limits for a tenant using the Auth0 Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/sessions/manage-user-sessions-with-auth0-management-api",
  "markdown": "# Manage User Sessions with Auth0 Management API\n\nAuth0 uses [sessions](https://auth0.com/docs/manage-users/sessions) to maintain the authentication state of a user across requests.\n\n## Management API endpoints\n\nThe [Management API](https://auth0.com/docs/api/management/v2) provides out-of-band access to the internals of user sessions in the [Auth0 Session Layer](https://auth0.com/docs/manage-users/sessions/session-layers), and deletion methods to force session termination.\n\n### Session resource\n\nYou can view or delete a specific session with the following endpoints:\n\n| **Name** | **URL** | **Required scope(s)** |\n| --- | --- | --- |\n| Introspect a specific session by ID | `GET /api/v2/sessions/{sessionId}` | `read:sessions` |\n| Delete a specific session by ID | `DELETE /api/v2/sessions/{sessionId}` | `delete:sessions` |\n\n### User resource\n\nYou can list or delete all sessions for a given user with the following endpoints:\n\n| **Name** | **URL** | **Required scope(s)** |\n| --- | --- | --- |\n| List sessions details of a user | `GET /api/v2/users/{userId}/sessions` | `read:sessions` |\n| Delete all user sessions | `DELETE /api/v2/users/{userId}/sessions` | `delete:sessions` |\n\n## Session properties\n\nThe session endpoints return relevant information about the session and its history.\n\n| **Field** | **Description** |\n| --- | --- |\n| Session ID | The session ID is a persistent identifier of the session in the Auth0 tenant.<br><br>Note that the session ID corresponds to the `sid` claim already in ID Tokens and Logout Tokens and can be used to cross-reference these entities. |\n| Relevant Time | Session creation, authentication time, and expiry information. |\n| Device Information | The device property traces details related to the user agent (for example, browser) used in the interactions with this Auth0 session. |\n| Authentication Information | Contains summary information about the methods used to authenticate in this session. |\n\nFor detailed information about these fields, refer to the [Management API documentation](https://auth0.com/docs/api/management/v2).\n\n## OIDC Back-Channel Logout Initiators\n\nSession deletion events are connected to [OIDC Back-Channel Logout](https://auth0.com/docs/authenticate/login/logout/back-channel-logout) through the `session-deleted` initiator. To learn more, read [OIDC Back-Channel Logout Initiators](https://auth0.com/docs/authenticate/login/logout/back-channel-logout/oidc-back-channel-logout-initiators).\n\n## Sessions and refresh tokens\n\nSessions and refresh tokens collaborate to reduce the friction of user authentication while optimizing security. To learn more, read [Best Practices for Application Session Management on Auth0 Blog](https://auth0.com/blog/application-session-management-best-practices).\n\nRefresh tokens can remain active after a session has expired or been deleted, or after the user logs out. You can use the Management API to [manage refresh tokens](https://auth0.com/docs/secure/tokens/manage-refresh-tokens-with-auth0-management-api) independently or in collaboration with sessions.\n\n## Limitations\n\nDelete session operations run asynchronously, and are eventually consistent.\n\n## Learn more\n\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [OIDC Back-Channel Logout](https://auth0.com/docs/authenticate/login/logout/back-channel-logout)\n*   [OIDC Back-Channel Logout Initiators](https://auth0.com/docs/authenticate/login/logout/back-channel-logout/oidc-back-channel-logout-initiators)\n*   [Configure OIDC Back-Channel Logout](https://auth0.com/docs/authenticate/login/logout/back-channel-logout/configure-back-channel-logout)",
  "title": "Manage User Sessions with Auth0 Management API",
  "description": "Learn how to manage user sessions with the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/sessions/non-persistent-sessions",
  "markdown": "# Non-Persistent Sessions\n\nIn persistent sessions, users close a browser, but retain the session when re-opening the browser on the same device. To enhance the user experience and provide more secure access, non-persistent sessions invalidate a session cookie when the browser is closed.\n\n## Browser Limitations\n\nIn some cases, non-persistent sessions **cannot** be enforced by tenant settings. Examples include:\n\n*   The user has a session restore setting on the browser enabled; restoring the session also restores the session cookie.\n    \n*   The user closes a tab but not the browser window; the session cookie is not cleared until the session ends based on Idle or Absolute Expiration.\n    \n\n## Sessions\n\nSessions consist of a cookie on the browser and a session record on the server. In non-persistent sessions, cookies are not persisted, and a tenant timeout is set, so users don’t have to manually log out of a device. \n\nSession lifetime determines how long the system should keep the login session and is configured per tenant. The Absolute Expiration of a session is defined when the session is created. You can enable non-persisted settings for user sessions, or allow the session to continue even if the browser is closed. You can adjust the Absolute Expiration and non-persisted settings in the Dashboard or the Management API. To learn more, read [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings).\n\n## Cookies\n\nThe Auth0 platform uses three types of cookies: session, Multi-Factor Authentication, and device. All of these change to non-persistent once your Auth0 tenant is configured. The tenant timeout triggers the session expiration.\n\nWhen non-persistent sessions are enabled, the following cookies will be issued as session cookies when interacting with the authorization server:\n\n*   `auth0` / `auth0_compat`\n    \n*   `auth0-mf` / `auth0-mf_compat`\n    \n*   `did` / `did_compat`\n    \n\nTo learn more about cookies, read [Authentication API Cookies](https://auth0.com/docs/manage-users/cookies/authentication-api-cookies).\n\n## Tenant configuration\n\nYou can configure your tenant to handle sessions in one of two ways:\n\n*   Persistent Mode: session cookies persist when the browser is closed.\n    \n*   Non-Persistent Mode: session cookies do not persist. The browser retains session cookies until the browsing session is over. To learn more, read [HTTP State Management Mechanism on IETF Datatracker](https://datatracker.ietf.org/doc/rfc2109/).\n    \n    ![Auth0 Tenant Settings Advanced tab Log In Session Management](https://images.ctfassets.net/cdy7uua7fh8z/6vizfZo1O2vtufLmuaA6WB/5558dd4403bd87107db23808ae6c762a/dashboard-tenant-edit_view-advanced_log-in-session-management_non-persistent.png)\n\n| Settings | Description |\n| --- | --- |\n| Inactivity timeout | Timeframe (in minutes) after which a user's session will expire if they haven’t interacted with the Authorization Server. Will be superseded by system limits if over 4,320 minutes (3 days) for Essential or Professional or 144,000 minutes (100 days) for enterprise plans. |\n| Require log in after | Timeframe (in minutes) after which a user will be required to log in again, regardless of their activity. Will be superseded by system limits if over 43,200 minutes (30 days) for Developer or Developer Pro or 525,600 minutes (365 days) for enterprise plans. |\n\nTo configure these settings in the Dashboard:\n\n1.  Go to [Dashboard > Tenant Settings](https://manage.auth0.com/#/tenant), and select the **Advanced** view.\n    \n2.  Scroll to the **Log In Session Management** section, locate **Inactivity timeout** and **Require log in after**, enter the desired settings, and select **Save**.\n    \n\n## Management API\n\nYou can use the Management API to enable non-persistent sessions as well as set values for session lifetime, idle sessions lifetime, and properties for sessions cookies. To learn more, review the [Management API Tenant Update endpoint](https://auth0.com/docs/api/management/v2#!/Tenants/update_settings).",
  "title": "Non-Persistent Sessions",
  "description": "Describes non-persistent sessions available with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/actions-overview",
  "markdown": "# Understand How Auth0 Actions Work\n\nActions are secure, tenant-specific, [versioned](https://auth0.com/docs/customize/actions/manage-versions) functions written in Node.js that execute at certain points within the Auth0 platform. Actions are used to customize and extend Auth0's capabilities with custom logic.\n\nThe processes that can be extended in this way are called flows. Each flow is made up of one or more triggers and represents the logical pipeline through which information moves during a single point in the Auth0 journey. Multiple Actions can be added to a trigger, with each Action executing in the order in which it was placed. Some triggers are executed synchronously, blocking the flow in which they are involved, and some are executed asynchronously, as indicated in the table below.\n\nActions are a cornerstone to our overall extensibility product at Auth0. With Actions, you can add essential custom logic to your login and identity flows specific to your needs. Actions also allow you to connect external integrations that enhance your overall extensibility experience. For example, you can add an Action to your login flow to verify credentials such as a License or Passport using a Marketplace Partner who specializes in identity proofing.\n\n## What can you do with Actions?\n\nWhat an Action can do is determined by where it is executed within the Auth0 runtime environment.\n\n| Flow | Runs | Trigger(s) | Execution | Example Uses |\n| --- | --- | --- | --- | --- |\n| [Login](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) | As a user logs in. | post-login | Synchronous | *   Modify access and ID tokens<br>*   Call APIs to enrich user profiles or send notifications<br>*   Create authorization rules and make access decisions based on custom logic<br>*   Conditionally enable MFA<br>*   Redirect users to an external site |\n| [Machine to Machine](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow) | When an access token is issued via the Client Credentials Flow. | credentials-exchange | Synchronous | *   Prevent tokens from being issued<br>*   Add custom claims to the access token |\n| [Password Reset](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset) | After the user completes the first challenge, but before the user enters a new password. | post-challenge | Synchronous | *   Challenge a user with an additional MFA factor before allowing them to set a new password<br><br>*   Redirect the user to a third-party website/service, such as a custom MFA provider, before allowing them to set a new password |\n| [Pre User Registration](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow) | Before a user is added to a Database or Passwordless Connection. | pre-user-registration | Synchronous | *   Prevent creation of a user in Auth0<br>*   Add custom app\\_metadata or user\\_metadata to a newly created user |\n| [Post User Registration](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow) | After a user is added to a Database or Passwordless Connection. | post-user-registration | Asynchronous | *   Send a new user notification<br>*   Create a record in a CRM system |\n| [Post Change Password](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow) | After a password is changed for a Database Connection user. | post-change-password | Asynchronous | *   Send an email to a user to notify them that their password has been changed<br>*   Call an API to revoke a user’s sessions in other systems after their password has been change |\n| [Send Phone Message](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow) | To send a Phone or SMS message as part of a Custom MFA Provider. | send-phone-message | Synchronous | Use a custom provider for sending MFA Phone or SMS messages |\n\n## Key benefits of Actions\n\n### Improved developer experience\n\n*   When editing an Action within the Auth0 Dashboard, you will have access to rich type information and inline documentation about what is possible within each trigger, which makes it easy to discover what capabilities each Trigger supports.\n    \n*   An Action can be edited and tested without affecting the version that is currently serving production traffic.\n    \n*   If an issue is found within an Action, it can be rolled back to a previous version.\n    \n\n### Access to npm packages\n\nNearly all [public `npm` packages](https://www.npmjs.com/) are available to be used within Actions.\n\n### Observability\n\nWhen Actions are executed, Auth0 will capture key metrics about them and link them to [Auth0 Logs](https://auth0.com/docs/deploy-monitor/logs).\n\n### Multiple Actions on every trigger\n\nEvery Action trigger supports multiple independent Actions.\n\n## Get started\n\n*   [Write your first Action](https://auth0.com/docs/customize/actions/write-your-first-action)!\n    \n*   See the current [limitations of Actions](https://auth0.com/docs/customize/actions/limitations).\n    \n\n## Learn more\n\n*   [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action)\n*   [Explore Flows and Triggers](https://auth0.com/docs/customize/actions/flows-and-triggers)\n*   [Actions Limitations](https://auth0.com/docs/customize/actions/limitations)\n*   [Manage Versions](https://auth0.com/docs/customize/actions/manage-versions)\n*   [Migrate from Actions Beta to Final](https://auth0.com/docs/customize/actions/migrate/migrate-from-actions-beta-to-final)",
  "title": "Understand How Auth0 Actions Work",
  "description": "Describes how Auth0 Actions work and what you can accomplish with them.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers",
  "markdown": "# Explore Flows and Triggers\n\nThe processes which can be extended with Actions are called Flows. Each Flow is made up of one or more Triggers and represents the logical pipeline through which information moves during a single point in the Auth0 journey. Multiple Actions can be added to a Trigger, with each Action executing in the order in which it was placed. Some Triggers are executed synchronously, blocking the flow in which they are involved, and some are executed asynchronously.\n\nTo explore reference objects and blueprints for specific Actions for a trigger, select the trigger below, noting Auth0's definition of a [passwordless connection](https://auth0.com/docs/authenticate/passwordless).\n\n| Flow | Runs | Trigger(s) | Execution | Example Uses |\n| --- | --- | --- | --- | --- |\n| [Login](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) | As a user logs in. | post-login | Synchronous | *   Modify access and ID tokens<br>*   Call APIs to enrich user profiles or send notifications<br>*   Create authorization rules and make access decisions based on custom logic<br>*   Conditionally enable MFA<br>*   Redirect users to an external site |\n| [Machine to Machine](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow) | When an access token is issued via the Client Credentials Flow. | credentials-exchange | Synchronous | *   Prevent tokens from being issued<br>*   Add custom claims to the access token |\n| [Password Reset](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset) | After the user completes the first challenge, but before the user enters a new password. | post-challenge | Synchronous | *   Challenge a user with an additional MFA factor before allowing them to set a new password<br><br>*   Redirect the user to a third-party website/service, such as a custom MFA provider, before allowing them to set a new password |\n| [Pre User Registration](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow) | Before a user is added to a Database or Passwordless Connection. | pre-user-registration | Synchronous | *   Prevent creation of a user in Auth0<br>*   Add custom app\\_metadata or user\\_metadata to a newly created user |\n| [Post User Registration](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow) | After a user is added to a Database or Passwordless Connection. | post-user-registration | Asynchronous | *   Send a new user notification<br>*   Create a record in a CRM system |\n| [Post Change Password](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow) | After a password is changed for a Database Connection user. | post-change-password | Asynchronous | *   Send an email to a user to notify them that their password has been changed<br>*   Call an API to revoke a user’s sessions in other systems after their password has been change |\n| [Send Phone Message](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow) | To send a Phone or SMS message as part of a Custom MFA Provider. | send-phone-message | Synchronous | Use a custom provider for sending MFA Phone or SMS messages |\n\n## Learn more\n\n*   [Login Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow)\n*   [Machine to Machine Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow)\n*   [Pre User Registration Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow)\n*   [Post User Registration Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow)\n*   [Post Change Password Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow)\n*   [Send Phone Message Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow)",
  "title": "Explore Flows and Triggers",
  "description": "Learn about triggers, which are events that automatically invokes an Action when a specific operation, such as a user logging in, occurs at runtime.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/write-your-first-action",
  "markdown": "# Write Your First Action\n\nThis guide will walk you through how to create and deploy your first Action using the Auth0 Dashboard. When you finish, you should understand the basic functionality that you will use with all Actions and you will be familiar with the programming model. What you will learn constitutes the foundation of writing any Action, regardless of its purpose or the flow.\n\n## The goal: notify Slack on user login\n\nYou are creating an Action that sends a message to a Slack channel when a user logs in. While this tutorial will use the Post Login trigger, the information provided here is useful for triggers of any type.\n\nTo accomplish this task, you will do the following:\n\n*   [Create an Action](#create-an-action)\n    \n*   [Add a Secret](#add-a-secret)\n    \n*   [Add a dependency](#add-a-dependency)\n    \n*   [Save the Draft](#save-the-draft)\n    \n*   [Add custom logic](#add-custom-logic)\n    \n*   [Test an Action](#test-an-action)\n    \n*   [Deploy an Action](#deploy-the-action)\n    \n*   [Attach an Action to a Flow](#attach-the-action-to-a-flow)\n    \n*   [See the results of an Action in Tenant Logs](#observe-actions-in-tenant-logs)\n    \n\n## Prerequisites\n\nBecause this Action will be sending messages to a Slack channel, you need to [create an Incoming Webhook for a Slack Workspace](https://api.slack.com/messaging/webhooks). Once you have a Slack Webhook URL, you may continue with this guide.\n\n## Create an Action\n\nTo get an Action working in a specific flow, you need to create the Action and then add it to a flow.\n\n1.  Navigate to [Auth0 Dashboard > Actions > Library,](https://manage.auth0.com/#/actions/library) then select **Create Action** > **Build from scratch**.\n    \n2.  Enter a **Name** and select the **Login / Post Login** trigger since you’ll be adding an Action to the Login flow, then select **Create.**\n    \n    ![Create Action popup](https://images.ctfassets.net/cdy7uua7fh8z/4RIBysqB3a9aIYsAiLtVuk/735e9544ed356820bb67d2ebb18442cc/create-an-action.png)\n\nThe Actions Code Editor appears:\n\n![Actions Code Editor](https://images.ctfassets.net/cdy7uua7fh8z/12Q8OEuDI39eWuWsrVVwN0/afcf60398d133d2b66bc9a35614ccadd/Untitled.png)\n\n## Create an Action from a Template\n\nThe Actions Template gallery offers a variety of starter templates on their way to creating an Action. To create an Action from a Template:\n\n1.  Navigate to [Auth0 Dashboard > Actions > Library](https://manage.auth0.com/#/actions/library), then select **Create Action.**\n    \n2.  Select **Choose from template**.\n    \n3.  Select the template that you would like to use for building an Action.\n    \n4.  You should now see a read-only preview of the code within the template. To proceed, select **Use this template**.\n    \n5.  Enter a name, and select **Create**.\n    \n\n![Show screen for creating an action from a template.](https://images.ctfassets.net/cdy7uua7fh8z/2i6Hv4XxsSAzEXdIKGR8Qz/1c45a12bc39707ba7495bb0fd708f572/925f0c6d-59d4-4a88-a841-e3b912f21083.png)\n\n## Add a Secret\n\nEach Action can contain Secret values, which are suitable for holding sensitive information, such as Access Tokens and API Keys. Let’s store the Slack Webhook URL as a Secret.\n\n1.  Select the Key Icon from the code editor's left sidebar\n    \n2.  Select **Add Secret**.\n    \n3.  Give the Secret the following name: `SLACK_WEBHOOK_URL`.\n    \n4.  Paste in the Webhook URL provided by Slack and select **Create**.\n    \n    ![Create Secret popup](https://images.ctfassets.net/cdy7uua7fh8z/5lwzvBFff1gCisgDoAKGuq/f1f911ea8b0fb743b1c8681bb35d7c58/111.png)\n\nYou’ll see that the Secret has been added to the Action and you can use the new secret via intelligent code complete by typing `event.secrets`.\n\n![Actions Code Editor - Your Secret has been added in the Secrets section.](https://images.ctfassets.net/cdy7uua7fh8z/4FyFtKRSIYuigxE9U8TkEJ/9598b5909694631ca673f748abf2268a/Screen_Shot_2022-02-09_at_3.24.05_PM.png)\n\n## Add a dependency\n\nYou’ll be using the [`@slack/webhook` `npm` package](https://www.npmjs.com/package/@slack/webhook) to make it easy to send a message to Slack. You can use nearly any public `npm` package in an Action as long as it can be installed without relying on [native add-ons](https://www.npmjs.com/package/node-gyp).\n\nTo add the dependency:\n\n1.  Select the Dependency icon (cube icon) in the sidebar.\n    \n2.  For **Name**, enter `@slack/webhook`.\n    \n    ![Actions Add Module popup](https://images.ctfassets.net/cdy7uua7fh8z/6mf5DYukuVE4QPtGBepGfY/660952a8887390da0cb5f96550777c7a/add-dependency.png)\n    \n    By default, your Action will use the latest version of the dependency at the time the dependency was added.\n    \n3.  Select **Create**, and the Dependency should be added to the Action:\n    \n    ![Actions Code Editor: Your dependency has been added.](https://images.ctfassets.net/cdy7uua7fh8z/Jmzvgydo204pBLikzuDJy/1d9a614b4c92f27afbbdd2b2af3b3c0b/Screen_Shot_2022-02-23_at_11.28.41_AM.png)\n\n## Save the Draft\n\nSelect **Save Draft**. Your Action is saved, but it won’t be executed as part of any user flows yet. With Actions, you have the opportunity to create, edit, and test Actions before they affect any traffic in your Auth0 tenant. Once you’re happy with the behavior of the Action, you’ll deploy the Action and add it to a Flow later.\n\n## Add custom logic\n\nNow that the Action has been configured with a Secret and a dependency, let’s write some code!\n\nEvery Action has an event object that contains read-only, contextual information relevant to the associated trigger. If you start typing `event.` in the Editor, you should be presented with all the available properties of the event. To learn more about which information is available on each trigger, read [Explore Flows and Triggers](https://auth0.com/docs/customize/actions/flows-and-triggers).\n\nLet’s use our Action to notify Slack. Add this code to your action:\n\n```\nconst { IncomingWebhook } = require('@slack/webhook');\n\nexports.onExecutePostLogin = async (event, api) => {\n    const url = event.secrets.SLACK_WEBHOOK_URL;\n    const webhook = new IncomingWebhook(url);\n\n    // Send the notification\n    await webhook.send({ text: \"Logging In...\" });\n};\n```\n\nSelect **Save Draft** to save your Action.\n\n## Test the Action\n\nBefore you run this Action in your tenant with real user traffic, test it to ensure it behaves as expected.\n\n1.  Select the Test (triangle) icon in the sidebar. In the Payload section, you’ll see editable JSON data relevant to the trigger that you selected when you created the Action.\n    \n    ![Actions Code Editor: Test Runner panel](https://images.ctfassets.net/cdy7uua7fh8z/4MSu8EfpMLNJpcYtrwP7Jf/66480a0434c89eadb809012bca890037/Screen_Shot_2022-02-10_at_10.01.10_AM.png)\n2.  Select the **Run** button, and you should see a message appear in your Slack channel.\n    \n\n## Deploy the Action\n\nNow that we’re satisfied that the Action is working as expected, it’s time to deploy it.\n\nSelect **Deploy**. Deploying an Action takes a snapshot of the Action at that time and records it as an **Action Version**.\n\nSelect **Version History**, and you should see the Action recorded as Version 1:\n\n![Actions: Version History](https://images.ctfassets.net/cdy7uua7fh8z/53sn70cXoxUHibc3Bmk7Og/193af512ac2b58f3d60ab36ca5499d90/Screen_Shot_2022-02-10_at_10.02.47_AM.png)\n\nYou are now free to update your Action and save it without affecting Version 1 of your Action. Auth0 will only execute the currently deployed version of an Action, so until you deploy an action again, Version 1 will be executed by Auth0.\n\n## Attach the Action to a Flow\n\nThe final step in configuring a new Action so that it’s executed as part of your tenant’s traffic is to attach it to a Flow.\n\n1.  Navigate to [Auth0 Dashboard > Actions > Flows](https://manage.auth0.com/#/actions/flows) to see a list of the available Flows:\n    \n    ![Actions: Choose a flow](https://images.ctfassets.net/cdy7uua7fh8z/6Ussg76LTqVWEZer2tl0bE/669ae24462b9da37fac52afca1c7128f/dashboard-actions-choose-flow_my-slack-action_tutorial.png)\n2.  Select the [Login flow](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) and drag `my-slack-action` into the flow.\n    \n    ![Actions Flows: Login Flow](https://images.ctfassets.net/cdy7uua7fh8z/6hU7sKWtGzSx9Z8dhsXbvp/c404870e356ea5c745685c8ea071f2b9/dashboard-actions-login-flow_my-slack-action_tutorial.png)\n3.  Select **Apply**.\n    \n\nThe Action is now running for real user traffic within your tenant. If you’d like a more robust testing environment, consider [setting up multiple Auth0 environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n\n## Observe Actions in Tenant Logs\n\nNow that your Action is running as part of the Login flow, Auth0 captures information about each Action execution in the tenant logs. To view this, navigate to [Auth0 Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs), and select a **Successful Login** event.\n\nYou should see an **Action Details** view that contains information about any Actions that were executed as part of that flow.\n\n![Tenant Logs: Action Details view](https://images.ctfassets.net/cdy7uua7fh8z/61k82wmsXSb9M3wOExM4jH/3cc5d35a73d01c2c8d8802675d26cc1f/dashboard-actions-logs_my-slack-action_tutorial.png)\n\n## Next steps\n\nNow that you’ve written your first Action, check out [Explore Flows and Triggers](https://auth0.com/docs/customize/actions/flows-and-triggers) to learn how to perform some common tasks with Actions.",
  "title": "Write Your First Action",
  "description": "Learn how to write an Action, which includes choosing a flow, creating an Action and configuring it, and binding it to the flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/action-coding-guidelines",
  "markdown": "# Action Coding Guidelines\n\nActions code should be performant, secure, and clear, so debugging takes less time and effort. Follow our guidelines below to write Action code like a pro!\n\n## Actions basics\n\n*   Use the minimum number of HTTP requests possible and set a reasonable timeout (less than 10 seconds) to avoid accumulated requests during login.\n    \n*   Use [application metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata) to filter for specific applications to determine if an Action should be run.\n    \n*   Ensure that Actions, which provide verification or trigger MFA, cannot be bypassed unintentionally or maliciously.\n    \n*   Actions should never intentionally throw an error; if processes stop because of an error or condition, use the appropriate `api` method like `api.access.deny()`.\n    \n*   Use `event.request.hostname` for the domain used in Authentication API calls; this could be the default Auth0 tenant domain or a [custom domain](https://auth0.com/docs/customize/custom-domains).\n    \n\n## Coding basics\n\n*   Check for strict equals `===` with any incoming or stored data.\n    \n*   Use a `return` statement when the Action process should stop.\n    \n*   Run a code linter, like [ESLint](https://eslint.org/), and an analyzer, like [Semgrep](https://semgrep.dev/docs/getting-started/), to improve code quality and find issues automatically.\n    \n\n## Security basics\n\n*   Do not transmit unencrypted personally-identifiable information (PII) in plain sight, like in URLs or error messages.\n    \n*   Always use HTTPS URLs for redirects and API calls.\n    \n*   AllowList IP addresses when possible.\n    \n*   Watch for incoming data that can be tampered with (URL parameters, user agent, and so on).\n    \n\n## Defensive coding\n\n*   [Catch errors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#exception_handling_statements) and handle as necessary.\n    \n*   Use guard clauses and return early if the Action processing should not continue.\n    \n\n## Logging\n\n*   Never log sensitive data, secrets, or PII.\n    \n*   Stay under the maximum of 256 characters logged per Action.\n    \n\n## Dependencies\n\n*   Use trusted and maintained packages.\n    \n*   Check for outstanding CVEs using [`npm`'s audit feature](https://docs.npmjs.com/cli/v6/commands/npm-audit) or an automated dependency checker connected to a repository.\n    \n*   Use the latest version of a package when possible.\n    \n\n## User data\n\n*   Check if an email is verified with `event.user.email_verified` if it is being used in a sensitive or high-security context.\n    \n*   Different Connections provide different user profile data; the only guaranteed [user profile field](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure) is the `user_id`.\n    \n\n## Redirect Actions in the Login Flow\n\n*   The token returned by `api.redirect.encodeToken` is signed but not encrypted, so sensitive data or PII should not be included in the payload.\n    \n*   The Login Flow runs after a successful login, which includes:\n    \n    *   SSO (no login form shown)\n        \n    *   silent authentication (checking a session using `prompt=none` in the authorization URL)\n        \n    *   refresh token exchange (no user interaction)\n        \n    *   RO password grants (credentials gathered from an application and exchanged with the token endpoint)\n        \n*   Actions that redirect need to take the above cases into account and either deny access if interaction is required or intensionally allow bypassing, which puts the burden on the application requesting login.",
  "title": "Action Coding Guidelines",
  "description": "Write clear, concise, and secure Actions code with our coding guidelines.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/use-cases",
  "markdown": "# Action Use Cases\n\nThe following is a list of Actions for implementing a variety of functionality in Auth0.\n\n## User Profile and Identity",
  "title": "Action Use Cases",
  "description": "Explore a variety of examples of implementations using Actions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/limitations",
  "markdown": "# Actions Limitations\n\nThe following limitations exist when using Actions:\n\n*   Each Action should not exceed 100 kB. The larger the size, the more latency is introduced, which may have an impact on the performance of your system. This size limit limit does not include any `npm` modules that may be referenced as part of any `require` statements.\n    \n*   Each execution of a flow must complete in 20 seconds or less or the processing will end in an error. Limiting HTTP requests is the best way to keep within this time limit.\n    \n*   Each execution of a flow must complete in 20 seconds or less or the processing will end in an error. Limiting long-running processes, like outbound HTTP requests without a timeout, is necessary to keep within this time limit. An Action that [redirects users to an external page](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions) has a separate timeout before the redirect and after.\n    \n*   Calls made to the Auth0 Management API and User Metadata updates are [rate limited](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits).\n    \n*   Each Action may have a maximum of 10 `npm` modules.\n    \n*   Each tenant may have a maximum of 100 Actions (including both deployed and undeployed). When an Action is deleted, it no longer counts toward the limit.\n    \n*   Each Action may have a maximum of 50 associated versions (both draft and active). Once the limit is reached, every additional version that is added will result in the oldest version being deleted.\n    \n*   Each flow may have a maximum of 20 active bound Actions.\n    \n*   Each Action may have a maximum of 30 secrets.\n    \n*   Each secret key may have a maximum length of 128 characters, and each secret value may have a maximum length of 2048 characters.\n    \n*   A maximum of 256 characters may be persistently stored for `console.log()` outputs for each Action.\n    \n*   Each session may have a maximum of 32kB each of user metadata persistence and 32kB of app metadata persistence.\n    \n*   Execution logs are retained for 10 days.\n    \n*   HTTP calls to external services originate from [these IP addresses](https://auth0.com/docs/secure/security-guidance/data-security/allowlist).\n    \n*   We do not support Typescript in actions. Source files must be written in JavaScript before being deployed.\n    \n\n#### Cached data:\n\n*   Cached items persist for a maximum of 24 hours.\n    \n*   A maximum of 20 entries can be cached per Trigger.\n    \n*   Cache keys have a maximum size of 64 bytes and values have a maximum size of 2kB.\n    \n*   The cumulative size of cached keys and their values must not exceed 8kB.\n    \n*   Actions that perform an Execution that yields back (such as a redirect) may result in subsequent actions being scheduled on a separate instance with a different cache state. This can result in cached data being inconsistent from one Action to the next.\n    \n\n#### SAML attributes:\n\n*   A maximum of 100 SAML attributes can be changed or added by Actions.\n    \n*   SAML attribute names have a maximum size of 1kB.\n    \n*   SAML values have a maximum size of 2kB.\n    \n*   The total SAML assertions have a maximum size of 10kB.\n    \n\n#### SAML configuration:\n\n*   `audience` has a maximum size of 2kB\n    \n*   `recipient` has a maximum size of 2kB\n    \n*   `destination` has a maximum size of 2kB\n    \n*   `nameIdentifierFormat` has a maximum size of 0.5kB\n    \n*   `nameIdentifierProbes` has a maximum of 10 probes with a maximum size of 0.5kB each\n    \n*   `authnContextClassRef` has a maximum size of 0.5kB\n    \n*   `signingCert` has a maximum size of 4kB\n    \n*   `encryptionCert` has a maximum size of 4kB\n    \n*   `encryptionPublicKey` has a maximum size of 4kB\n    \n*   `cert` has a maximum size of 4kB\n    \n*   `key` has a maximum size of 4kB\n    \n\n**Account Linking (setPrimaryUser):**\n\n*   `primary_user_id` is limited to 128 characters\n    \n*   `setPrimaryUser` can be called once per transaction\n    \n*   Any userMetadata set in the same Action as `setPrimaryUser` is discarded and will be lost. Subsequent Actions within the same transaction will retain userMetadata on the new primary user.\n    \n*   `setPrimaryUser` can not be used in the same transaction where a Rule sets `context.primaryUser.`\n    \n\n**Actions does not currently support:**\n\n*   Retrieving External IdP tokens from the Identities array\n    \n\n## Learn more\n\n*   [Understand How Auth0 Actions Work](https://auth0.com/docs/customize/actions/actions-overview)",
  "title": "Actions Limitations",
  "description": "Learn about the limitations involved with using Auth0 Actions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/manage-versions",
  "markdown": "# Manage Versions\n\nWith the Actions version history, you can compare between drafted and deployed versions of Actions, and revert to previous versions when necessary.\n\n## Deploy Actions\n\nBefore an Action can be bound to a flow, the Action must be deployed.\n\n1.  Navigate to [Auth0 Dashboard > Actions > Custom Actions](https://manage.auth0.com/#/actions/library).\n    \n2.  Choose your Action.\n    \n3.  Select **Deploy**.\n    \n\nThe selected Action will be deployed and added to the collection of available actions for flows. Additionally, a new draft version of the deployed Action will be created for future editing. Because secrets and dependencies are tied to versions, any saved secrets or dependencies will be available to the new draft.\n\n## Revert Actions\n\nWhen necessary, you can revert to the last known good version of an Action.\n\n1.  Navigate to [Auth0 Dashboard > Actions > Custom Actions](https://manage.auth0.com/#/actions/library).\n    \n2.  Choose your Action.\n    \n3.  Select **Version History**.\n    \n4.  Select the version to which you want to revert, and click **Revert**. \n    \n\nA new copy of the selected version will be created and deployed. Additionally, a new draft version of the deployed Action will be created for future editing. Because secrets and dependencies are tied to versions, any saved secrets or dependencies will be available to the new draft.",
  "title": "Manage Versions",
  "description": "Learn about the Actions version history, which allows you to compare between drafted and deployed versions of Actions, and revert to previous versions when necessary.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/manage-dependencies",
  "markdown": "# Manage Dependencies\n\nActions allows you to use packages from the [`npm` registry](https://www.npmjs.com/). You can install and manage dependencies for your Actions using either the Actions Code Editor in the Auth0 Dashboard or the Auth0 Management API.\n\n## Add a dependency using the Actions Code Editor\n\nTo add a dependency on a package from the public `npm` registry:\n\n1.  Navigate to [Auth0 Dashboard > Actions > Library](https://manage.auth0.com/#/actions/library), and select your Action.\n    \n2.  Locate the Actions Code Editor, and select Modules (cube icon) in its sidebar.\n    \n3.  Select **Add Module**, and enter the name of the module. To use the latest available version of the package, you can leave the version field blank.\n    \n4.  In your Actions code, require the module. For example, if you added the Axios package, you would add the following line at the top of your code in the Actions Code Editor:\n    \n    ```\n    const axios = require('axios');\n    ```\n    \n\n## Add a dependency using the Auth0 Management API\n\nAlternatively, you can add a dependency using the Auth0 Management API's [Create Action endpoint](https://auth0.com/docs/api/management/v2#!/Actions/post_action). When calling the endpoint, specify the dependencies in the payload:\n\n```\ncurl -H \"Authorization: Bearer {managementApiToken}\" \\\n     -X POST  -H \"Content-Type: application/json\" \\\n     -d '{ \\\n            \"name\":\"my-action\", \\\n            \"supported_triggers\":[{\"id\":\"post-login\",\"version\":\"v2\"}], \\\n            \"code\":\"module.exports = () => {}\",\\\n            \"dependencies\": [{\\\n                \"name\":\"lodash\",\\\n                \"version\":\"4.17.21\"\\\n            }],\\\n            \"runtime\":\"node14\"\\\n        }' \\\n    https://{yourTenant}.com/api/v2/actions/actions\n```\n\n## Security considerations\n\nThird-party packages can contain vulnerabilities and malicious code, so we recommend auditing packages before using them in your Actions. We also recommend that you continuously monitor packages for vulnerabilities using software composition analysis tools.\n\n## Limitations for dependencies in Actions\n\n### No native module support\n\nNative modules cannot be used in Actions. When executing an Action that depends on a native module, the Action will error with a message containing `Compilation failed: Cannot find module`.\n\nTo check whether an `npm` package is native, navigate to the public Github repository for the `npm` package and review the languages the code uses in the sidebar. If the languages include C/C++, the package is likely native. Popular examples include `bcrypt` and `sqlite3`.\n\n### No private module or private registry support\n\nPrivate `npm` modules and private `npm` registries cannot be used with Actions. Actions uses the [public `npm` registry](https://registry.npmjs.org/).",
  "title": "Manage Dependencies",
  "description": "Learn how to install and manage dependencies inside of Auth0 Actions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/test-actions",
  "markdown": "# Test Actions\n\nDepending on where you are in your implementation, you have several different options available to test and debug Auth0 Actions.\n\nWe recommend that you test individual actions from the Auth0 Dashboard as you implement them. Once you are ready, you should verify that the end-to-end flow works as expected using tenant logs through the Auth0 Dashboard.\n\n## Test individual Actions\n\nYou can test individual Actions using the Actions Code Editor. The editor's test capability simulates a call to the Action using a sample payload based on the flow with which the Action is associated. To test an individual Action:\n\n1.  Navigate to [Auth0 Dashboard > Actions](https://manage.auth0.com/#/actions), and choose the Flow and Action that you would like to edit.\n    \n2.  Locate the Actions Code Editor, and select **Test** (the play icon) from its sidebar. Edit the payload in the Test sidebar to analyze the outcome of different payloads.\n    \n3.  Select **Run**.\n    \n\nThe test results show the steps that the Action took, console output, any errors that occurred, and useful statistics about the execution of the Action.\n\n![Screenshot of the testing module inside of the Action Code Editor](https://images.ctfassets.net/cdy7uua7fh8z/7I4CRM8SmRFiibjuk55L86/5f9c4a0cfb56f98d73e4003a8ba54180/test-action-code-editor.png)\n\n## Debug deployed Actions\n\nNow that you have tested your Action, it’s time to deploy it and observe its execution. Assuming you have deployed your Action and added it to a flow (to learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action)), you can debug your live Action in a few steps.\n\n### Verify end-to-end Login Flow\n\nFor a `post-login` Action, you can verify the end-to-end-login flow by executing a login attempt for your tenant:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Authentication Profile](https://manage.auth0.com/#/authentication-profiles), and select **Try**. A window containing a sample login will open.\n    \n2.  Proceed through the login flow. The login flow will execute any configured Actions.\n    \n\nOnce complete, you will be redirected to a page that either lists the user profile attributes that your applications will receive or shows an error message explaining what went wrong.\n\n### Analyze tenant logs\n\nWhenever a trigger executes that has an associated Action bound to its flow, your [tenant logs](https://auth0.com/docs/deploy-monitor/logs/view-log-events) will include Action execution details.\n\nIn the tenant logs list, you can see logs associated with Actions and choose to view them. In the example below, the log type of `Success Login` is associated with an Action on the `post-login` trigger of this tenant.\n\n![Screenshot of Tenant Log List in the Auth0 Dashboard, showing logs that are associated with Action execution.](https://images.ctfassets.net/cdy7uua7fh8z/4hIo2YJ8fr2tfMEWhaLyn4/03a6d0b67a119efb1d07e912d977e7e1/action-logs-list.png)\n\nSome examples of log types associated with Actions include:\n\nTo view detailed Action execution information, select the log that is associated with an Action execution, then select the **Action Details** view. In Action Details, you can see execution statistics, console output, and any errors that may have occurred.\n\n![Screenshot of individual log associated with Actions testing.](https://images.ctfassets.net/cdy7uua7fh8z/1WrsQvjZxI2WRMrtltandy/0bc92038a5bc7b6344a95ef271eff299/actions-log-detail.png)\n\n## Unit test Actions\n\n​You can unit test your Auth0 Actions by mocking the event and api passed into your Action function. Your Actions can live in version control or local directory, and you can use a tool like Jest to automatically test your Actions. In the following example, we use the [Login / Post Login](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) trigger and [Jest](https://jestjs.io/) to mock and test.\n\n**Action code:**\n\n```\n// action.js\n\nexports.onExecutePostLogin = async (event, api) => {\n  const namespace = \"https://my-app.example.com\";\n  if (event.authorization) {\n    api.idToken.setCustomClaim(`${namespace}/favorite_color`, \"pink\");\n  }\n};\n```\n\n**Test file code:**\n\n```\n// action.spec.js\n\nconst { onExecutePostLogin } = require(\"./action.js\");\ntest(\"sets favorite_color ID token claim to pink\", async () => {\n  const namespace = \"https://my-app.example.com\";\n  const mockFunction = jest.fn();\n  const mockApi = { idToken: { setCustomClaim: mockFunction } };\n  const mockEvent = {authorization: {}};\n\n  await onExecutePostLogin(mockEvent, mockApi);\n  expect(mockFunction).toBeCalledWith(\n    `${namespace}/favorite_color`,\n    \"pink\"\n  );\n});\n```\n\n## Best practices\n\nWhen building Actions on Auth0, [we recommend that you create a dedicated Auth0 tenant per environment](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments). Doing so allows you to isolate your production user base from your other environments, as well as configure different administrators per environment (for example, engineers might not have access to production configuration).",
  "title": "Test Actions",
  "description": "Learn how to test and debug Auth0 Actions",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/releases",
  "markdown": "# Releases\n\nFeatures and breaking changes released in Actions are listed below.\n\n## v3\n\n### Login Flow\n\nNew features and breaking changes were released to triggers in the Login Flow. To learn about these changes, read [Login Flow: Releases](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/releases).\n\n## v2 (GA)\n\n### Query and body parameters\n\nDirect access to the query and body parameters is available using the `event.request.query` and `event.request.body` objects. These are exposed regardless of whether the authorization was initiated via a `GET` or `POST` request. Many protocol-specific query or body parameters sent as part of an authorization request are now also available as first-class values on the `event.transaction` object. We recommend that you use `event.transaction` rather than `event.request.query` and `event.request.body` unless your use case is not supported. A complete mapping of these changes is below:\n\n| Pre-GA Property | GA Property |\n| --- | --- |\n| `event.actor.ip` | `event.request.ip` |\n| `event.actor.hostname` | `event.request.hostname` |\n| `event.actor.geoIp` | `event.request.geoip` |\n| `event.actor.language` | `event.request.language` |\n| `event.actor.method` | `event.request.method` |\n| `event.actor.userAgent` | `event.request.user_agent` |\n| `event.actor.body` | `event.request.body` |\n| `event.actor.query` | `event.request.query` |\n| `event.actor.query.audience` | `event.resource_server.identifier` |\n| `event.actor.query.scope` | `event.transaction.requested_scopes` |\n| `event.actor.query.acr_values` | `event.transaction.acr_values` |\n| `event.actor.query.ui_locales` | `event.transaction.ui_locales` |\n| `event.protocol` | `event.transaction.protocol` |\n| `context.secrets` | `event.secrets` |\n\n### User Profile properties\n\nIn general, the `event.user` object has had its properties changed from camel case to snake case in order to match the [Auth0 User Profile structure](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure). For example, `event.user.appMetadata` has been changed to `event.user.app_metadata`.\n\n### Performing side effects\n\nIn the pre-GA version of the post-login trigger, side effects were performed by returning an object from an Action. In Actions GA, an `api` object is provided to encapsulate these changes and provide better in-editor type hints and inline documentation.\n\nTo learn more about these changes and see code examples, read [Login Flow: Releases](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/releases).\n\n### Manipulating scopes\n\nAlthough we experimented with providing direct manipulation of ID and Access Token scopes during the Actions Beta, we do not support this functionality in Actions GA.",
  "title": "Releases",
  "description": "Learn about released versions of Actions, including breaking changes and new features.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/actions-templates",
  "markdown": "# Templates for Actions\n\nThe Actions Template gallery offers a variety of starter templates for creating an Action. These templates provide sample code covering various triggers and use cases, such as Multi-factor Authentication, Access Control, and Profile Enrichment.\n\n![Screenshot for Actions Templates on dashboard](https://images.ctfassets.net/cdy7uua7fh8z/6bEk4FvidgEL7VlkZ1woFa/5d4fbeae0ecb13eda8b65c0e6724cece/templates-screenshot.png)\n\nTemplates provide starter code that you can modify and use as a building block as part of a trigger. Once you select a template for your specific use case, you can then customize the code to fit the individual needs of your application.\n\nFor a step-by-step guide on using Actions Templates, see [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\n## Best Practices\n\n*   Ensure that the templates are custom for your specific environment. As the code is incomplete, you must personalize and complete the samples before importing them into a production environment.\n    \n*   Do not deploy a template without editing and completing it beforehand.\n    \n*   Actions Templates often contain tags in the comments, which should not be modified or deleted.\n    \n*   Always use the latest version of any `npm` package.\n    \n*   Actions Templates target the latest Node.js versions by default. After creating a template, you can modify it to support additional Node.js version(s) as necessary.\n    \n\nAlso please review all [Actions Coding Guidelines](https://auth0.com/docs/customize/actions/action-coding-guidelines) as they apply here as well.",
  "title": "Templates for Actions",
  "description": "The Actions Template gallery offers our customers a wide variety of starter templates on their way to creating an action",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/migrate",
  "markdown": "# Migrate to Actions\n\nTo take advantage of the features provided by Auth0 Actions, you may need to migrate current code from Rules, Hooks, and earlier versions of Actions.",
  "title": "Migrate to Actions",
  "description": "Learn how to migrate to Actions from Rules, Hooks, and earlier versions of Actions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/migrate/migrate-from-hooks-to-actions",
  "markdown": "# Migrate from Hooks to Actions\n\nWhen converting existing Hooks to Actions, you should associate the new Action with the Trigger that corresponds to the type of Hook. If you follow the steps below and use the mappings we identify within them, the functionality should be identical.\n\n## Plan your migration\n\nDeployed Actions run after active Hooks, so you can either convert Hooks one at a time in the Dashboard or all at once using the Management API.\n\nYou will need to convert code, and then activate the Action and deactivate the Hook. Activating the Action and deactivating the Hook can be done quickly in succession, but depending on the order, there might be a short period of time where either both or neither are running.\n\nBecause of this, we recommend migrating your pipeline step by step: convert pieces of your Hooks code to Action code, test in a staging environment, then go live with one piece at a time. Because active Hooks run before deployed Actions, you can keep some logic in Hooks as you build and test other logic in Actions.\n\n#### Tips when planning your migration\n\n*   Use flags to avoid duplicating expensive or one-time operations.\n    \n*   Make sure to run changes at a time when impact and traffic will be lowest.\n    \n*   Consider using the [Auth0 Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool) to script, test, and quickly implement the migration all at once or iteratively.\n    \n\n## Understand limitations\n\nWhile Actions can handle the vast majority of things that Hooks can, you should be aware of a few limitations before you start your migration .(Remember: you can have both Hooks and Actions running as you migrate.)\n\n*   Actions cannot persist data, like access tokens or API responses, across executions.\n    \n*   Actions are not provided with [an access token for the Management API](https://auth0.com/docs/customize/rules/use-management-api) or [access to the global `auth0` object](https://auth0.com/docs/best-practices/rules-best-practices/rules-environment-best-practices#global-object) as in Hooks.\n    \n\nFor the full list of limitations, see [Actions Limitations](https://auth0.com/docs/customize/actions/limitations).\n\n## Convert code\n\nTo convert a Hook to an Action, you must replace Hook-specific code with Actions code. This section covers the tasks you will need to perform to turn a functioning Hook into its equivalent Action.\n\n#### Tips when converting code\n\n*   In general, look for the read-only properties of objects passed into the Hooks function on the Actions `event` object.\n    \n*   Use the Actions Code Editor in the Auth0 Dashboard to write your code; it will help by highlighting errors and supplying auto-complete suggestions.\n    \n*   Before you go live, thoroughly [test your new Actions](https://auth0.com/docs/customize/actions/test-actions) in a [staging or test environment](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n    \n\n### Copy Hook code to a new Action\n\n1.  Log in to your production tenant, and copy the code from the Hook you want to convert.\n    \n2.  Switch to a non-production tenant, and navigate to [Auth0 Dashboard > Actions > Library](https://manage.auth0.com/#/select-tenant?path=/actions/library).\n    \n3.  Select **Build Custom**, then:\n    \n    *   Enter a **Name** for your Action that matches the name of the Hook you're converting.\n        \n    *   Locate **Trigger**, and select the appropriate trigger**:**\n        \n        | Type of Hook | Actions Trigger |\n        | --- | --- |\n        | Client Credentials Exchange | M2M/Client-Credentials |\n        | Pre-User-Registration | Pre User Registration |\n        | Post-User-Registration | Post User Registration |\n        | Post-Change-Password | Post Change Password |\n        | Send Phone Message | Send Phone Message |\n        \n    *   Locate **Runtime**, and select **Node 16.**\n        \n    *   Select **Create**.\n        \n4.  In the code block of the Actions Code Editor, paste the Hook code you want to convert below the exported function.\n    \n5.  Make the changes detailed in the rest of this article as you move the code into the function. You should also read about the `event` object associated with the new Actions Trigger; you'll see links to the relevant documentation when you get to the [Change how data is accessed](#change-how-data-is-accessed) section later in this guide.\n    \n\n### Change the function declaration\n\nHooks functions are exported using a default export, while Actions functions use named exports. Depending on the type of Hook you are converting, the named export will change. Mappings include:\n\n| Type of Hook | Named Export |\n| --- | --- |\n| Client Credentials Exchange | `onExecuteCredentialsExchange` |\n| Pre-User Registration | `onExecutePreUserRegistration` |\n| Post-User Registration | `onExecutePostUserRegistration` |\n| Post-Change Password | `onExecutePostChangePassword` |\n| Send Phone Message | `onExecuteSendPhoneMessage` |\n\n**Before**\n\n```\nmodule.exports = async function myHooksFunction(){}\n```\n\n**After**\n\n```\n// Client Credentials Exchange\nexports.onExecuteCredentialsExchange = async (event, api) => {}\n\n// Pre-User Registration\nexports.onExecutePreUserRegistration = async (event, api) => {}\n\n// Post-User Registration\nexports.onExecutePostUserRegistration = async (event) => {}\n\n// Post-Change Password\nexports.onExecutePostChangePassword = async (event) => {}\n\n// Send Phone Message\nexports.onExecuteSendPhoneMessage = async (event) => {}\n```\n\n### Convert dependencies\n\nHooks and Actions handle dependencies in a similar way. With both, dependencies are added separately via UI or Management API and included in the code. Also with both, you can require any package that is available in the `npm` Registry.\n\n1.  Search for `require` statements inside your Hook code.\n    \n2.  Remove version numbers, but make a note of them.\n    \n3.  Add the dependency by following the steps in the \"Add a Dependency\" section of [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action) (if the dependency is not a [core NodeJS module](https://github.com/nodejs/node/tree/master/lib); if the dependency is a core NodeJS module, you do not need to include it).\n    \n4.  Move the found `require` statements outside of the `function` declaration.\n    \n\n### Convert secrets\n\nHooks and Actions handle secrets in a similar way. With both, Secrets are added per Hook/Action via UI or Management API and included in the code.\n\nTo convert secrets from Hooks to Actions:\n\n1.  Save the values needed for the specific Action you are working on.\n    \n2.  Add a Secret for each value you need to access from inside the Action. To learn how, read the **Add a Secret** section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n    \n3.  Convert your code:\n    \n\n**Before**\n\n```\nasync function (user, context, cb) {\n    const { SECRET_NAME } = context.webtask.secrets;\n\n    // ... additional code\n}\n```\n\n**After**\n\n```\nasync (event, api) => {\n    const { SECRET_NAME } = event.secrets;\n\n\t// ... additional code\n};\n```\n\nAs with Hooks, Auth0 encrypts all secret values at rest.\n\n### Change how data is accessed\n\nWith Hooks, data about the user, client, request, and other contextual data are stored in multiple arguments passed into the Hook function. In Actions, this data has been reshaped and moved to the `event` object. Many of the properties moved over as-is, but some have been combined to increase clarity.\n\nDepending on the type of Hook you are converting, the `event` object will change:\n\n*   [Client Credentials Exchange - Actions Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow/event-object)\n    \n*   [Post-Change Password - Actions Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow/event-object)\n    \n*   [Post-User Registration - Actions Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow/event-object)\n    \n*   [Pre-User Registration - Actions Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow/event-object)\n    \n*   [Send Phone Message - Actions Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow/event-object)\n    \n\n**Before**\n\n```\nasync function (user, context, cb) {\n\tconst clientId = context.clientID;\n\tconst tenant = context.connection.tenant\n\n\t// ... additional code\n}\n```\n\n**After**\n\n```\nasync (event, api) => {\n\tconst clientId = event.client.client_id;\n\tconst tenant = event.tenant.id;\n\n\t// ... additional code\n};\n```\n\n### Convert callbacks\n\nWhen a Hook is finished processing, it must call the `callback()` function to complete its execution. Conversely, Actions do not use a callback mechanism; therefore, you will need to remove all instances of `callback()` from your Actions function.\n\nIf you were previously using the `callback()` function in a Client Credentials Exchange or Pre User Registration Hook to fail the request or update a user, you will still be able to do this in Actions through a new `api` interface.\n\n#### Client Credentials Exchange\n\nIf you were adding extra claims to the access token in a Client Credentials Exchange Hook:\n\n```\n// Client Credentials Exchange Hook\nmodule.exports = function(client, scope, audience, context, cb) {\n  var access_token = {};\n  access_token.scope = scope;\n\n  access_token['https://example.com/claim'] = 'bar';\n  cb(null, access_token);\n};\n```\n\nYou can now use the Actions [Client Credentials Exchange API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow/api-object):\n\n```\n// Client Credentials Exchange Action\nexports.onExecuteCredentialsExchange = async (event, api) => {\n  api.accessToken.setCustomClaim(\"https://example.com/claim\", 'bar');  \n};\n```\n\n#### Pre User Registration\n\nIf you were adding extra claims to the access token in a Pre User Registration Hook:\n\n```\n// Pre User Registration Hook\nmodule.exports = function (user, context, cb) {\n\tif (user.app_metadata.condition === \"success\") {\n      var response = {};\n      response.user = { user_metadata: { favorite_color: \"purple\" } };\n      // This Hook succeeded, proceed with the next Hook.\n\t  return callback(null, response);\n\t}\n\n\tif (user.app_metadata.condition === \"failure\") {\n\t\t// This Hook failed, stop the login with an error response.\n\t\treturn callback(new Error(\"Failure message\"));\n\t}\n\n\t// ... additional code\n};\n```\n\nYou can now use the [Pre User Registration API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow/api-object):\n\n```\n// Pre User Registration Action\nexports.onExecutePreUserRegistration = async (event, api) => {\n\tif (event.user.app_metadata.condition === \"success\") {\n\t\t// This Action succeeded, proceed with next Action.\n\t\tapi.user.setUserMetadata(\"favorite_color\", \"purple\");\n\t\treturn;\n\t}\n\n\tif (event.user.app_metadata.condition === \"failure\") {\n\t\t// This Action failed, stop the call with an error response.\n\t\treturn api.access.deny(\"Failure message\");\n\t}\n\n\t// ... additional code\n};\n```\n\n## Complete the migration\n\nOnce your new Actions code has been written and tested, you must activate the Action and deactivate the Hook. These two tasks can be done quickly in succession, but depending on the order, there might be a short period of time where either both or neither are running. Because active Hooks run before deployed Actions, you can keep some logic in Rules as you build and test other logic in Actions.",
  "title": "Migrate from Hooks to Actions",
  "description": "Learn how to migrate your existing Auth0 Hooks code to Auth0 Actions code.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/migrate/migrate-from-rules-to-actions",
  "markdown": "# Migrate from Rules to Actions\n\nWhen converting existing Rules to Actions, you should associate the new Action with the Post-Login (`post-login`) Trigger of the Login Flow. If you follow the steps below and keep your Actions in the same order as your original Rules, the functionality should be identical.\n\n## Plan your migration\n\nPost-Login Actions run after existing Rules, so you can either convert Rules one at a time in the Dashboard or all at once using the Management API.\n\nYou will need to convert code, and then activate the Action and deactivate the Rule. Activating the Action and deactivating the Rule can be done quickly in succession, but depending on the order, there might be a short period of time where either both or neither are running.\n\nBecause of this, we recommend migrating your pipeline step by step: convert pieces of your Rules code to Action code, test in a staging environment, then go live with one piece at a time. Because active Rules run before deployed Actions, if you start at the end of your Rules pipeline and work backwards, you can keep some logic in Rules as you build and test other logic in Actions.\n\n#### Tips when planning your migration\n\n*   Keep your Actions and Rules 1:1, so functionality can be turned off and on in blocks and tested.\n    \n*   Use flags in user metadata to avoid duplicating expensive or one-time operations.\n    \n*   Start at the end of your Rules pipeline and work backwards; because active Rules run before deployed Actions, you can keep some logic in Rules as you build and test other logic in Actions.\n    \n*   Make sure to run changes at a time when impact and traffic will be lowest.\n    \n*   Consider temporarily [customizing your login page](https://auth0.com/docs/customize) to halt logins if the cutover could cause invalid logins or gaps in protection.\n    \n*   Consider using the [Auth0 Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool) to script, test, and quickly implement the migration all at once or iteratively.\n    \n\n## Understand limitations\n\nWhile Actions can handle the vast majority of things that Rules can, you should be aware of a few limitations before you start your migration. (Remember: you can have both Rules and Actions running as you migrate.)\n\n*   Rules can add properties to the `user` and `context` objects, which are accessible in subsequent Rules. An individual Action cannot share data directly with another Action.\n    \n*   Actions cannot persist data, like access tokens or API responses, across executions.\n    \n*   Actions are not provided with [an access token for the Management API](https://auth0.com/docs/customize/rules/use-management-api) or [access to the global `auth0` object](https://auth0.com/docs/rules-best-practices/rules-environment-best-practices) as in Rules. To learn how Management API calls can still be made, read the [Convert Code](#convert-code) section.\n    \n\nFor the full list of limitations, see [Actions Limitations](https://auth0.com/docs/customize/actions/limitations).\n\n## Convert code\n\nTo convert a Rule to an Action, you must replace Rule-specific code with Actions code. This section covers the tasks you will need to perform to turn a functioning Rule into its equivalent Action.\n\n#### Tips when converting code\n\n*   In general, look for the read-only properties of Rules `user` and `context` objects on the Actions `event` object. Look for any side effects your Actions have on the system (like failing a login or updating user metadata) in the `api` object functions.\n    \n*   Use the Actions Code Editor in the Auth0 Dashboard to write your code; it will help by highlighting errors and supplying auto-complete suggestions.\n    \n*   Before you go live, thoroughly [test your new Actions](https://auth0.com/docs/customize/actions/test-actions) in a [staging or test environment](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n    \n\n### Copy Rule code to a new Action\n\n1.  Log in to your production tenant, and copy the code from the Rule you want to convert.\n    \n2.  Switch to a non-production tenant, and navigate to [Auth0 Dashboard > Actions > Library](https://manage.auth0.com/#/select-tenant?path=/actions/library).\n    \n3.  Select **Build Custom**, then:\n    \n    *   Enter a **Name** for your Action that matches the name of the Rule you're converting.\n        \n    *   Locate **Trigger**, and select **Login / Post Login**.\n        \n    *   Locate **Runtime**, and select **Node 16.**\n        \n    *   Select **Create**.\n        \n4.  In the code block of the Actions Code Editor, paste the Rule code you want to convert below the exported `onExecutePostLogin` function.\n    \n5.  Make the changes detailed in the rest of this article as you move the code into the function.\n    \n\n### Change the function declaration\n\nRules use a plain, declared function with `user`, `context`, and `callback` parameters, while Actions use a function exported to a specific name. Make the following change; for now, ignore any errors that appear.\n\n**Before**\n\n```\nasync function myRulesFunction(user, context, callback) {\n    // ... additional code\n}\n```\n\n**After**\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\t// ... additional code\n};\n```\n\n### Change how user data is accessed\n\nIn Rules, data about the user logging in is stored in the [`user` object](https://auth0.com/docs/customize/rules/user-object-in-rules). In Actions, this data is found in the `user` property of the [`event` object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object). The majority of existing properties are accessible in this new location.\n\n**Before**\n\n```\nfunction myRulesFunction(user, context, callback) {\n\tconst userEmail = user.email;\n\tconst userId = user.user_id;\n\n\t// This property could be undefined in Rules.\n\tconst userAppMetadata = user.app_metadata || {};\n\n\t// ... additional code\n}\n```\n\n**After**\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\tconst userEmail = event.user.email;\n\tconst userId = event.user.user_id;\n\n\t// This property will never be undefined in Actions.\n\tconst userAppMetadata = event.user.app_metadata;\n\n\t// ... additional code\n};\n```\n\n### Change how context data is accessed\n\nIn Rules, data about the current login session is stored in the [`context` object](https://auth0.com/docs/customize/rules/context-object). For Actions, this data has been reshaped and moved to the [`event` object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object). Many of the properties moved over as-is, but some have been combined to increase clarity.\n\n**Before**\n\n```\nfunction myRulesFunction(user, context, callback) {\n\tconst clientId = context.clientID;\n\tconst clientMetadata = context.clientMetadata || {};\n\n\tconst connectionId = context.connectionID;\n\tconst connectionMetadata = context.connectionMetadata || {};\n\n\tconst protocol = context.protocol;\n\n\tconst tenant = context.tenant;\n\n\t// ... additional code\n}\n```\n\n**After**\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\tconst clientId = event.client.client_id;\n\tconst clientMetadata = event.client.metadata;\n\n\tconst connectionId = event.connection.id;\n\tconst connectionMetadata = event.connection.metadata;\n\n\tconst protocol = event.transaction.protocol;\n\n\tconst tenant = event.tenant.id;\n\n\t// ... additional code\n};\n```\n\n### Convert dependencies\n\nRules include dependencies in a way that requires including the version number in a `require` statement. Actions use a more standard CommonJS syntax and require that the versions be indicated outside of the code editor.\n\nIn Rules, only specific versions of specific packages are allowed, and adding new packages and versions requires a request to Auth0. In Actions, you can require any package that is available in the `npm` Registry.\n\n1.  Search for `require` statements inside your Rule code.\n    \n2.  Remove version numbers, but make a note of them.\n    \n3.  Add the dependency by following the steps in the \"Add a Dependency\" section of [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action) (if the dependency is not a [core NodeJS module](https://github.com/nodejs/node/tree/master/lib); if the dependency is a core NodeJS module, you do not need to include it).\n    \n4.  Move the found `require` statements outside of the `function` declaration:\n    \n\n**Before**\n\n```\nfunction myRulesFunction(user, context, callback) {\n\tconst dependency = require(\"dependency@1.2.3\");\n\n\t// ... additional code\n}\n```\n\n**After**\n\n```\nconst dependency = require(\"dependency\"); // v1.2.3\nexports.onExecutePostLogin = async (event, api) => {\n\t// ... additional code\n};\n```\n\n### Convert callbacks\n\nWhen a Rule is finished processing, it must call the `callback()` function and pass in an error if the login fails. Conversely, Actions can return on success, or call an `api` method with a message if the login fails. All instances of `callback()` in a Rule should be removed or replaced with `api.access.deny()` for failure. In both Rules and Actions, if processing needs to stop for a specific condition, use a `return` statement.\n\n**Before**\n\n```\nfunction myRulesFunction(user, context, callback) {\n\tconst userAppMetadata = user.app_metadata || {};\n\tif (userAppMetadata.condition === \"success\") {\n\t\t// This Rule succeeded, proceed with next Rule.\n\t\treturn callback(null, user, context);\n\t}\n\n\tif (userAppMetadata.condition === \"failure\") {\n\t\t// This Rule failed, stop the login with an error response.\n\t\treturn callback(new Error(\"Failure message\"));\n\t}\n\n\t// ... additional code\n}\n```\n\n**After**\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\tif (event.user.app_metadata.condition === \"success\") {\n\t\t// This Action succeeded, proceed with next Action.\n\t\treturn;\n\t}\n\n\tif (event.user.app_metadata.condition === \"failure\") {\n\t\t// This Action failed, stop the login with an error response.\n\t\treturn api.access.deny(\"Failure message\");\n\t}\n\n\t// ... additional code\n};\n```\n\n### Change handling of secrets\n\nIn Rules, you set configuration values globally, which means that all Rules can access all secret values. (To learn more, read [Store Rule Configurations](https://auth0.com/docs/customize/rules/configuration).) In Actions, you set configuration values for each individual Action. You can't access an Action's secret value from outside the context of the Action.\n\nTo convert secrets from Rules to Actions:\n\n1.  Save the values needed for the specific Action you are working on.\n    \n2.  Add a Secret for each value you need to access from inside the Action. To learn how, read the **Add a Secret** section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n    \n3.  Convert your code:\n    \n\n**Before**\n\n```\nfunction myRulesFunction (user, context, callback) {\n  const { CLIENT_ID, CLIENT_SECRET } = configuration;\n\n  // ... additional code\n}\n```\n\n**After**\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { CLIENT_ID, CLIENT_SECRET } = event.secrets;\n\n  // ... additional code\n}\n```\n\nAs with Rules, Auth0 encrypts all secret values at rest.\n\n### Convert custom claims in tokens\n\nRules and Actions can both add custom claims to ID and access tokens. In Rules, this is a property of the `context` object, while Actions uses a method on the [`api` object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object).\n\n**Before**\n\n```\nfunction myRulesFunction(user, context, callback) {\n\tconst userAppMetadata = user.app_metadata || {};\n\tconst namespace = \"https://namespace/\";\n\n\tcontext.idToken[`${namespace}/emp_id`] = userAppMetadata.emp_id;\n\tcontext.accessToken[`${namespace}/emp_id`] = userAppMetadata.emp_id;\n\n\t// ... additional code\n}\n```\n\n**After**\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\tconst namespace = \"https://namespace/\";\n\n\tapi.idToken.setCustomClaim(\n\t\t`${namespace}/emp_id`, \n\t\tevent.user.app_metadata.emp_id\n\t); \t\t   \n\n\tapi.accessToken.setCustomClaim(\n\t\t`${namespace}/emp_id`, \n\t\tevent.user.app_metadata.emp_id\n\t);\n\n\t// ... additional code\n};\n```\n\n### Convert multi-factor triggering\n\nIn Rules, multi-factor authentication can be triggered by modifying the `multifactor` property of the [`context` object](https://auth0.com/docs/customize/rules/context-object). In Actions, this is done with a [method on the `api` object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object).\n\n**Before**\n\n```\nfunction myRulesFunction(user, context, callback) {\n\tif (user.app_metadata.needs_mfa === true) {\n\t\tcontext.multifactor = { \n\t\t\tprovider: \"any\", \n\t\t\tallowRememberBrowser: false,\n\t\t};\n\t}\n\n\t// ... additional code\n}\n```\n\n**After**\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\tif (event.user.app_metadata.needs_mfa === true) {\n\t\tapi.multifactor.enable(\"any\", { allowRememberBrowser: false });\n\t}\n\n\t// ... additional code\n};\n```\n\n### Convert user metadata updates\n\nUpdating the `user_metadata` and `app_metadata` properties in Rules requires a call to the Management API, which can lead to [rate limit](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits) errors. Actions, however, provides a way to indicate multiple user metadata changes but only call the Management API once.\n\n**Before**\n\n```\nfunction myRulesFunction(user, context, callback) {\n\tuser.app_metadata = user.app_metadata || {}; \n\tuser.app_metadata.roles = user.app_metadata.roles || [];\n\tuser.app_metadata.roles.push(\"administrator\"); \n\n\tauth0.users\n\t\t.updateAppMetadata(user.user_id, user.app_metadata) \n\t\t.then(() => callback(null, user, context))\n\t\t.catch((err) => callback(err));\n\n\t// ... additional code\n}\n```\n\nIf subsequent Rules need to update the user metadata, then they would have to call the Management API separately, making it more likely that you would hit the [rate limit](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits).\n\n**After**\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\tconst userRolesUpdated = event.user.app_metadata.roles || [];\n\tuserRolesUpdated.push(\"administrator\"); \n\n\t// Note the two different methods here. \n\tapi.user.setAppMetadata(\"roles\", userRolesUpdated);\n\tapi.user.setUserMetadata(\"hasRoles\", true);\n\n\t// ... additional code\n};\n```\n\nIf subsequent Actions needed to update the user metadata, then they would need to call `api.user.setUserMetadata` or `api.user.setAppMetadata`. In Actions, multiple calls to these functions across one or more Actions will result in a single Management API call once the flow is complete.\n\n### Convert other Management API calls\n\nIn general, we do not recommend calling the Management API from a high-traffic, critical path like Rules or Actions. Requests to all Auth0 APIs are [rate limited](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy), including calls from extensibility points, and calling an API for all logins could easily result in failed logins at high-traffic times.\n\nHowever, If the calls are necessary and are configured to avoid rate limits, it's possible to call the Management API from within Actions. As mentioned in the \"Understand limitations\" section earlier in this article, Actions are not provided with an access token for the Management API, so you will need to get an access token before activating your Action:\n\n1.  [Register a Machine-to-Machine application and authorize it for the Management API](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps).\n    \n2.  Save the **Client ID** and **Client Secret** in the Action.\n    \n3.  [Get an access token for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production).\n    \n4.  Call the Management API:\n    \n\n**Before**\n\n```\nfunction myRulesFunction(user, context, callback) {\n\tconst ManagementClient = require(\"auth0@2.9.1\").ManagementClient; \n\tconst managementClientInstance = new ManagementClient({\n\t\t// These come from built-in Rules globals\n\t\ttoken: auth0.accessToken, \n\t\tdomain: auth0.domain,\n\t}); \n\n\tmanagementClientInstance.users.assignRoles(\n\t\t{ id: user.user_id }, \n\t\t{ roles: [\"ROLE_ID_TO_ADD\"] }, \n\t\t(error, user) => {\n\t\t\tif (error) {\n\t\t\t\treturn callback(error);\n\t\t\t}\n\n\t\t\t// ... additional code\n\t\t}\n\t);\n}\n```\n\n**After**\n\n```\nconst auth0Sdk = require(\"auth0\");\nexports.onExecutePostLogin = async (event, api) => {\n\tconst ManagementClient = auth0Sdk.ManagementClient;\n\n\t// This will make an Authentication API call\n\tconst managementClientInstance = new ManagementClient({\n\t\t// These come from a machine-to-machine application\n\t\tdomain: event.secrets.M2M_DOMAIN,\n\t\tclientId: event.secrets.M2M_CLIENT_ID,\n\t\tclientSecret: event.secrets.M2M_CLIENT_SECRET,\n\t\tscope: \"update:users\"\n\t});\n\n\tmanagementClientInstance.users.assignRoles(\n\t\t{ id: event.user.user_id }, \n\t\t{ roles: [\"ROLE_ID_TO_ADD\"]}, \n\t\t(error, user) => {\n\t\t\tif (error) {\n\t\t\t\treturn api.access.deny(error.message);\n\t\t\t}\n\n\t\t\t// ... additional code\n\t\t}\n\t);\n};\n```\n\n### Convert redirects\n\nRules can redirect a user who is logging in to an external page, then wait for a response. In this case, all Rules before the redirection will run twice--once before the redirect and once on the response. The logic for the redirect and the response are typically contained in the same Rule.\n\nIn Actions, the Action pipeline is paused when the redirect happens and picks up once the user returns. Also, the exported redirect triggering function is separate from the redirect callback.\n\n**Before**\n\n```\nfunction myRulesFunction(user, context, callback) {\n    if (context.protocol === \"redirect-callback\") {\n        // User was redirected to the /continue endpoint\n        user.app_metadata.wasRedirected = true;\n        return callback(null, user, context);\n    } else if (\n        context.protocol === \"oauth2-password\" ||\n        context.protocol === \"oauth2-refresh-token\" ||\n        context.protocol === \"oauth2-resource-owner\"\n    ) {\n        // User cannot be redirected\n        return callback(null, user, context);\n    }\n    // User is logging in directly\n    if (!user.app_metadata.wasRedirected) {\n        context.redirect = {\n            url: \"https://example.com\",\n        };\n        callback(null, user, context);\n    }\n}\n```\n\n**After**\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n    if (!event.user.app_metadata.wasRedirected && api.redirect.canRedirect()) {\n        api.redirect.sendUserTo(\"https://example.com\");\n    }\n};\n\nexports.onContinuePostLogin = async (event, api) => {\n    api.user.setAppMetadata(\"wasRedirected\", true);\n};\n```\n\n## Complete the migration\n\nOnce your new Actions code has been written and tested, you must activate the Action and deactivate the Rule. These two tasks can be done quickly in succession, but depending on the order, there might be a short period of time where either both or neither are running. Because active Rules run before deployed Actions, if you start at the end of your Rules pipeline and work backwards, you can keep some logic in Rules as you build and test other logic in Actions.",
  "title": "Migrate from Rules to Actions",
  "description": "Learn how to migrate your existing Auth0 Rules code to Auth0 Actions code.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers",
  "markdown": "# Configure Phone Messaging Providers\n\nAuth0 allows you to configure your own phone messaging provider to help you manage, monitor, and troubleshoot your SMS and voice communications. You can only configure one phone provider for all SMS and voice communications per tenant.\n\nAuth0 currently supports the following phone messaging providers:\n\n*   [Twilio](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers/configure-twilio-as-a-phone-messaging-provider)\n    \n\n## Learn more\n\n*   [Configure Twilio as a Phone Messaging Provider](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers/configure-twilio-as-a-phone-messaging-provider)",
  "title": "Configure Phone Messaging Providers",
  "description": "Learn how to configure phone messaging providers in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/migrate/migrate-from-actions-beta-to-final",
  "markdown": "# Migrate from Actions Beta to Final\n\nAs part of our long-term vision for extensibility of Auth0 through custom code, we have refined and simplified the programming models that we introduced during the beta period of Actions. Authoring Actions will now be done in a more consistent and predictable way across Triggers. Event data has been aligned more closely with the [Auth0 Management API](https://auth0.com/docs/api/management/v2) and other facets of the Auth0 platform. Changing the behavior of the transaction via custom code now always happens by calling methods of a new `api` argument.\n\nMigrating an Action created during the period prior to [General Availability (GA)](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages#general-availability) should typically involve the following steps:\n\n1.  Adjust references to renamed and relocated event properties as outlined in the [Breaking changes](#breaking-changes) section.\n    \n2.  Instead of composing and returning an object describing the desired side-effects, update custom code to call the relevant `api` method as outlined in the [Performing side effects](#performing-side-effects) section.\n    \n3.  For Actions that need to handle redirect callbacks, use the newly-exposed dedicated function. If you used code that relied on `event.protocol === 'redirect-callback'`, review the [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions) page.\n    \n\n## Breaking changes\n\n### Query and body parameters\n\nDirect access to the query and body parameters is available using the `event.request.query` and `event.request.body` objects. These are exposed regardless of whether the authorization was initiated via a `GET` or `POST` request. Many protocol-specific query or body parameters sent as part of an authorization request are now also available as first-class values on the `event.transaction` object. We recommend that you use `event.transaction` rather than `event.request.query` and `event.request.body` unless your use case is not supported. A complete mapping of these changes is below:\n\n| Pre-GA Property | GA Property |\n| --- | --- |\n| `event.actor.ip` | `event.request.ip` |\n| `event.actor.hostname` | `event.request.hostname` |\n| `event.actor.geoIp` | `event.request.geoip` |\n| `event.actor.language` | `event.request.language` |\n| `event.actor.method` | `event.request.method` |\n| `event.actor.userAgent` | `event.request.user_agent` |\n| `event.actor.body` | `event.request.body` |\n| `event.actor.query` | `event.request.query` |\n| `event.actor.query.audience` | `event.resource_server.identifier` |\n| `event.actor.query.scope` | `event.transaction.requested_scopes` |\n| `event.actor.query.acr_values` | `event.transaction.acr_values` |\n| `event.actor.query.ui_locales` | `event.transaction.ui_locales` |\n| `event.protocol` | `event.transaction.protocol` |\n| `context.secrets` | `event.secrets` |\n\n### User Profile properties\n\nIn general, the `event.user` object has had its properties changed from camel case to snake case in order to match the [Auth0 User Profile structure](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure). For example, `event.user.appMetadata` has been changed to `event.user.app_metadata`.\n\n### Performing side effects\n\nIn the pre-GA version of the post-login trigger, side effects were performed by returning an object from an Action. In Actions GA, an `api` object is provided to encapsulate these changes and provide better in-editor type hints and inline documentation.\n\n#### Update user user\\_metadata\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    user: {\n      userMetadata: {\n        myParam: \"foo\"\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.user.setUserMetadata('myParam', 'foo');\n}\n```\n\n#### Update user app\\_metadata\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    user: {\n      appMetadata: {\n        myParam: \"foo\"\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.user.setAppMetadata('myParam', 'foo');\n}\n```\n\n### Deny a login\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  throw new Error(\"Access denied.\");\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.access.deny(\"Access denied.\");\n}\n```\n\n### Add Custom Claims to the Access Token\n\nPre-GA Trigger:\n\n```\nasync function myFunc(event, context) {\n  return {\n    accessToken: {\n      customClaims: {\n        'https://example.com/custom/claim': 'Custom claim value',\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function myFunc(event, api) {\n  api.accessToken.setCustomClaim('https://example.com/custom/claim', 'Custom claim value');\n}\n```\n\n### Add Custom Claims to the ID Token\n\nPre-GA Trigger:\n\n```\nasync function myFunc(event, context) {\n  return {\n    idToken: {\n      customClaims: {\n        'https://example.com/custom/claim': 'Custom claim value',\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function myFunc(event, api) {\n  api.idToken.setCustomClaim('https://example.com/custom/claim', 'Custom claim value');\n}\n```\n\n### Dynamically enable multi-factor authentication\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    command: {\n      type: \"multifactor\",\n      provider: \"any\"\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.multifactor.enable(\"duo\");\n}\n```\n\n### Redirect the user\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    command: {\n      type: \"redirect\",\n      url: \"https://my-app.example.com\"\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.redirect.sendUserTo(\"https://my-app.example.com\");\n}\n```\n\nTo ensure parameters are being sent securely and to avoid replay attacks, passing data via redirects has changed significantly in Actions GA. For more information, see [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions).\n\n### Manipulate scopes\n\nAlthough we experimented with providing direct manipulation of ID and Access Token scopes during the Actions Beta, we do not support this functionality in Actions GA.",
  "title": "Migrate from Actions Beta to Final",
  "description": "Learn about the ways we've improved the Actions programming model between the beta and general availability (GA)releases.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/phone-messages/customize-phone-templates",
  "markdown": "# Customize Phone Templates\n\n## Prerequisites\n\nBefore customizing your phone templates, configure your phone provider using a third-party service like Twilio. To learn more, read [Configure Phone Messaging Providers](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers).\n\n## Get started\n\nGo to the [Auth0 Dashboard](https://manage.auth0.com/#/phone). Under **Branding > Phone Templates,** Auth0 provides the following customizable phone templates:\n\n*   **Blocked Account**: Alerts the customer that their account has been blocked as a result of suspicious activity. \n    \n*   **Change Password**: Sends the customer their password change code. \n    \n*   **One Time Password - Enrollment**: Sends the customer the verification code for one-time password (OTP) enrollment.\n    \n*   **One Time Password - Verify**: Sends the customer the verification code for one-time password (OTP) verification.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/2vZXWLWSRKj5PTKZDX0XMs/a59ee6a9e3b6c153d43b70c877212c1c/image1.png)\n\nOnce you select a phone template, enable it by toggling the **Status**. Now, you can customize the **From** phone number and the **Text Message Template**.\n\n## From phone number\n\nThe default **From** phone number is the one you set while configuring your phone provider. To learn more, read [Configure Phone Messaging Providers](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers).\n\nTo set a custom **From** phone number for a phone template, enter the phone number from which customers will receive messages.\n\n**Note:** If you set up Twilio as your phone provider and selected [Messaging Services](https://www.twilio.com/docs/messaging/services) as the SMS source, you won’t be able to set a custom **From** phone number. Instead, Twilio chooses one of the phone numbers in your Messaging Service's sender pool based on your Twilio configuration. To learn more, read the Twilio [Messaging Services](https://www.twilio.com/docs/messaging/services) documentation.\n\n## Text Message Template \n\nIn the **Text Message Template** body, Auth0 enables you to dynamically generate content using the Liquid templating language. Using Liquid syntax, you can access a number of contextual variables that Auth0 replaces with the relevant values when rendering the phone messages. To learn more about Liquid, read [Liquid for Designers](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers) on GitHub.\n\nAuth0 exposes the same set of [contextual variables](https://auth0.com/docs/customize/email/email-templates#common-variables) that you can access using Liquid syntax for phone templates as it does for email templates. The markup rules for customizing phone templates using Liquid syntax are the same as those for customizing email templates. To learn how to use Liquid syntax to customize a phone template, read [Use Liquid Syntax in Email Templates](https://auth0.com/docs/customize/email/email-templates/use-liquid-syntax-in-email-templates).\n\n## Test phone template\n\nOnce you’ve finished customizing your phone template, click the **Try** button. Auth0 sends the phone message to a default app named after your tenant name. To test templates for different applications, create a sample user to go through the phone message flows.",
  "title": "Customize Phone Templates",
  "description": "Learn how to customize phone templates in the Auth0 Dashboard. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa",
  "markdown": "# Configure SMS and Voice Notifications for MFA\n\nIf you use SMS or voice as authentication factors, when an end user attempts to authenticate with your application, they are sent a code via SMS or voice, which they will have to enter to complete the transaction. This implies that they both know their login credentials and are in possession of the device that they have registered for MFA use.\n\nYou can configure the SMS and Voice factor using the Dashboard or the Management API to send messages through SMS, voice, or to let the end users choose how they want the code to be delivered. You can configure your delivery provider using Actions, configure your Twilio account, or if you want to send customers SMS only, configure Auth0's default message delivery service. You must use the Universal Login experience to enable voice notifications for MFA.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## How it works\n\nWhen SMS and Voice are enabled, users are given the option to enroll by getting the code sent by SMS or voice:\n\n![Configure SMS and Voice for MFA User Experience Voice](https://images.ctfassets.net/cdy7uua7fh8z/2Q4BViGl71sdrytUDgNJ10/024bb03106f4a782b35f756a5b560ed4/mfa-sms-voice.png)\n\nWhen you only enable SMS, the flow is simpler:\n\n![Configure SMS and Voice for MFA User Experience SMS](https://images.ctfassets.net/cdy7uua7fh8z/64PgR0CO1Wjfie2Hxy1Ptw/12be815583af4c7fc13156aefcaf1663/mfa-sms.png)\n\nAfter users are enrolled, the next time they authenticate they will get the voice or SMS message at their registered phone.\n\n## Use the Dashboard\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/multifactor-auth).\n    \n2.  Click **Phone Message** and enable the toggle switch at the top.\n    \n    ![Dashboard Security Multi-factor Auth Phone Message](https://images.ctfassets.net/cdy7uua7fh8z/6lKC5uyFVvK1R6UCySSHtK/06d3c1cb8634858072842322cfeaf4c1/dashboard-mfa_factor_phone-message.png)\n3.  Select your preferred message delivery provider.\n    \n4.  To allow users to authenticate with SMS and voice, you must enable the SMS and voice factors and select your preferred delivery method:\n    \n    1.  **Auth0**: You can't use this provider to send voice messages. Sends SMS messages using Auth0's internally-configured SMS delivery provider. It can be used for evaluation and testing purposes only, and there is a maximum of 100 messages per tenant during the entire tenant lifetime. New codes are not received after reaching the 100 message limit.\n        \n    2.  **Twilio**: Sends the messages using the [Twilio Programmable SMS API](https://www.twilio.com/sms) for SMS or [Twilio Programmable Voice API](https://www.twilio.com/voice) for voice. Use Twilio Life Credentials, not Test Credentials, which are only meant to send messages in a production environment.\n        \n    3.  **Custom**: Sends the messages by invoking an Action in the [Send Phone Message Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).\n        \n    \n    You can also choose to give users the option of getting SMS text messages, voice calls, or both.\n    \n\n### Twilio configuration\n\nIf you choose to deliver SMS via Twilio, follow these steps to configure your SMS factor.\n\n1.  Open an account with Twilio. You will need a [Twilio Account SID](https://www.twilio.com/help/faq/twilio-basics/what-is-an-application-sid) and a [Twilio Auth Token](https://www.twilio.com/help/faq/twilio-basics/what-is-the-auth-token-and-how-can-i-change-it). These are the Twilio API credentials that Auth0 will use to send an SMS to the user.\n    \n2.  You may also need to enable permissions for your geographic region for [SMS](https://support.twilio.com/hc/en-us/articles/223181108-How-International-SMS-Permissions-work) or [voice](https://www.twilio.com/console/voice/calls/geo-permissions). If you use voice, your account needs to have a Twilio phone number enabled to make voice calls. This can be an external phone number [verified with Twilio](https://support.twilio.com/hc/en-us/articles/223180048-Adding-a-Verified-Phone-Number-or-Caller-ID-with-Twilio) or you can purchase and set up a Twilio phone number from within your account.\n    \n3.  Configure the connection. Go to [Dashboard > Security - Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and choose **Phone Message**.\n    \n4.  Under **Choose your delivery provider**, choose **Twilio** and choose a delivery method.\n    \n5.  Enter your **Twilio Account SID** and **Twilio Auth Token** in the appropriate fields.\n    \n    ![Dashboard Security Multi-Factor Auth Twilio](https://images.ctfassets.net/cdy7uua7fh8z/7tKyyQPNyaQaXoCK7SrNeM/439a9ce71945ffa7616edb646a52ad0f/mfa-phone-twilio.png)\n6.  Choose your **SMS Source**.\n    \n    1.  If you choose **Use From**, you will need to enter the **From** phone number that users will see as the sender of the SMS. You may also configure this in Twilio.\n        \n    2.  If you choose **Use Messaging Services**, you will need to enter a [Messaging Service SID](https://www.twilio.com/docs/sms/services/services-send-messages).\n        \n    3.  If you are using voice, you always need to configure **From** even if you are using **Message Services** for SMS. Make sure the phone number is configured to send both SMS and voice messages.\n        \n7.  Click **Save**.\n    \n\n### Customize SMS or voice message templates\n\nYou can customize your SMS and voice message templates. To learn more, read [Customize SMS and Voice Messages](https://auth0.com/docs/customize/customize-sms-or-voice-messages).\n\n## Use the Management API\n\nYou can use the Management API to configure which message delivery methods are enabled by using the `/api/v2/guardian/factors/phone/message-types` endpoint. The `message_types` parameter is an array that can have `[\"sms\"]`, `[\"voice\"]`, or `[\"sms\", \"voice\"]`. You need a [Management API access token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) with the `update:guardian_factors` scope as a bearer token to call the API:\n\n*   [cURL](#ff97ffc433e44f02bc28867e1541921e_shell)\n*   [C#](#ff97ffc433e44f02bc28867e1541921e_csharp)\n*   [Go](#ff97ffc433e44f02bc28867e1541921e_go)\n*   [Java](#ff97ffc433e44f02bc28867e1541921e_java)\n*   [Node.JS](#ff97ffc433e44f02bc28867e1541921e_node)\n*   [Obj-C](#ff97ffc433e44f02bc28867e1541921e_objc)\n*   [...](#)\n\n```\ncurl --request PUT \\\n  --url 'https://{yourDomain}/api/v2/guardian/factors/phone/message-types' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"message_types\": [\"sms\", \"voice\"] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/guardian/factors/phone/message-types\");\nvar request = new RestRequest(Method.PUT);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"application/json\", \"{ \\\"message_types\\\": [\\\"sms\\\", \\\"voice\\\"] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/guardian/factors/phone/message-types\"\n\n\tpayload := strings.NewReader(\"{ \\\"message_types\\\": [\\\"sms\\\", \\\"voice\\\"] }\")\n\n\treq, _ := http.NewRequest(\"PUT\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.put(\"https://{yourDomain}/api/v2/guardian/factors/phone/message-types\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"message_types\\\": [\\\"sms\\\", \\\"voice\\\"] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PUT',\n  url: 'https://{yourDomain}/api/v2/guardian/factors/phone/message-types',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'\n  },\n  data: {message_types: ['sms', 'voice']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"message_types\": @[ @\"sms\", @\"voice\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/guardian/factors/phone/message-types\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PUT\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/guardian/factors/phone/message-types\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PUT\",\n  CURLOPT_POSTFIELDS => \"{ \\\"message_types\\\": [\\\"sms\\\", \\\"voice\\\"] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"message_types\\\": [\\\"sms\\\", \\\"voice\\\"] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\"\n    }\n\nconn.request(\"PUT\", \"/{yourDomain}/api/v2/guardian/factors/phone/message-types\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/guardian/factors/phone/message-types\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Put.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"message_types\\\": [\\\"sms\\\", \\\"voice\\\"] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"\n]\nlet parameters = [\"message_types\": [\"sms\", \"voice\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/guardian/factors/phone/message-types\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PUT\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Integrated SMS messaging providers\n\nAuth0 defaults to support for sending messages through Twilio. However, you can use a different SMS provider, and add specific logic before sending a message or send a different message depending on the user or the application. To do this, you configure SMS MFA to use one of our integrated [Actions](https://auth0.com/docs/customize/actions) in the [Send Phone Message Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).\n\nIntegrated SMS messaging providers include:\n\n*   [Amazon SNS](https://marketplace.auth0.com/integrations/amazon-sms-provider)\n    \n*   [ClickSend](https://marketplace.auth0.com/integrations/clicksend-sms)\n    \n*   [Esendex](https://marketplace.auth0.com/integrations/esendex-sms-provider)\n    \n*   [Infobip](https://marketplace.auth0.com/integrations/infobip-sms-provider)\n    \n*   [Mitto](https://marketplace.auth0.com/integrations/mitto-sms-provider)\n    \n*   [Telesign](https://marketplace.auth0.com/integrations/telesign-sms-provider)\n    \n*   [Vonage](https://marketplace.auth0.com/integrations/vonage-sms-provider)\n    \n\n## Custom phone providers\n\nYou can also configure custom phone providers using Actions. To see example code for a custom phone provider Action, read the \"Common use cases\" section of [Send Phone Message Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow).\n\n## Security considerations\n\nWhen using any phone messaging provider, be aware that attackers abusing the signup flow could cause you financial damage.\n\nAuth0 limits a single user to send up to 10 SMS or voice messages per hour, and OTP flows via email or authenticators are limited to five requests every five minutes. (The burst rate is 10 but only 1 voice message per hour will be sent for new requests.) To further protect your account, consider:\n\n*   Enabling [Brute Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection). Auth0 will block an IP if it attempts to do more than 50 signup requests per minute.\n    \n*   Enabling [Log Streaming](https://auth0.com/docs/customize/log-streams) and creating alerts using your favorite monitoring tool when you see spikes in the number of `gd_send_voice` or `gd_send_voice_failure` [log events](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes).\n    \n\nPhone Messaging providers have additional protections. If you are using Twilio, read the [Twilio's Anti-Fraud Developer Guide](https://www.twilio.com/docs/usage/anti-fraud-developer-guide). Consider the following options:\n\n*   Limit the countries that you will send messages for [SMS](https://support.twilio.com/hc/en-us/articles/223181108-How-International-SMS-Permissions-work) and [Voice](https://support.twilio.com/hc/en-us/articles/223180228-International-Voice-Dialing-Geographic-Permissions-Geo-Permissions-and-How-They-Work). This is particularly useful if there are countries with a higher risk of [toll fraud](https://www.twilio.com/learn/voice-and-video/toll-fraud) or more expensive calling rates in which you do not typically do business.\n    \n*   Enable Twilio [usage triggers](https://support.twilio.com/hc/en-us/articles/223132387-Protect-your-Twilio-project-from-Fraud-with-Usage-Triggers) to protect your account against fraud and coding mistakes.\n    \n\n## Learn more\n\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n*   [Attack Protection](https://auth0.com/docs/secure/attack-protection)\n*   [Log Streams](https://auth0.com/docs/customize/log-streams)",
  "title": "Configure SMS and Voice Notifications for MFA",
  "description": "Describes how to configure SMS and voice notifications for MFA.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/internationalization-and-localization/password-options-translation",
  "markdown": "# Customize Translation of Lock Password Options\n\nYou can customize the translation of the following Lock password features in your own code:\n\n*   Password Strength\n    \n*   Password History\n    \n*   Change Password widget\n    \n\nTo customize any of these features, you must include version 1.1 or higher of the Change Password widget library:\n\n`<script src=\"https://cdn.auth0.com/js/change-password-1.1.min.js\"></script>`\n\nTo translate the text of each of the Lock password features, include the following code, replacing all strings with text in the desired language:\n\n### Password Strength\n\n```\ndict: {\n    passwordStrength: {\n      containsAtLeast: \"Contain at least %d of the following %d types of characters:\",\n      identicalChars: \"No more than %d identical characters in a row (such as, \\\"%s\\\" not allowed)\",\n      nonEmpty: \"Non-empty password required\",\n      numbers: \"Numbers (such as 0-9)\",\n      lengthAtLeast: \"At least %d characters in length\",\n      lowerCase: \"Lower case letters (a-z)\",\n      shouldContain: \"Should contain:\",\n      specialCharacters: \"Special characters (such as !@#$%^&*)\",\n      upperCase: \"Upper case letters (A-Z)\"\n    }\n}\n```\n\n### Password History\n\n```\ndict: {\n  passwordHistoryError: \"Password has previously been used\"\n}\n```\n\n### Change Password widget\n\n```\ndict: {\n    passwordPlaceholder: \"your new password\",\n    passwordConfirmationPlaceholder: \"confirm your new password\",\n    passwordConfirmationMatchError: \"Please ensure the password and the confirmation are the same.\",\n    successMessage: \"Your password has been reset successfully.\",\n    configurationError: \"An error occurred. There appears to be a misconfiguration in the form.\",\n    networkError: \"The server cannot be reached, there is a problem with the network.\",\n    timeoutError: \"The server cannot be reached, please try again.\",\n    serverError: \"There was an error processing the password reset.\",\n    headerText: \"Enter a new password for<br />{email}\",\n    title: \"Change Password\",\n    weakPasswordError: \"Password is too weak.\"\n}\n```",
  "title": "Customize Translation of Lock Password Options",
  "description": "Learn how to customize the translation of Lock password options.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization",
  "markdown": "# Universal Login Internationalization\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer API2_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"enabled_locales\" : [ \"en\", \"es\"]}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer API2_ACCESS_TOKEN\");\nrequest.AddParameter(\"application/json\", \"{ \\\"enabled_locales\\\" : [ \\\"en\\\", \\\"es\\\"]}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{ \\\"enabled_locales\\\" : [ \\\"en\\\", \\\"es\\\"]}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n  .body(\"{ \\\"enabled_locales\\\" : [ \\\"en\\\", \\\"es\\\"]}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {'content-type': 'application/json', authorization: 'Bearer API2_ACCESS_TOKEN'},\n  data: {enabled_locales: ['en', 'es']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer API2_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"enabled_locales\": @[ @\"en\", @\"es\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"enabled_locales\\\" : [ \\\"en\\\", \\\"es\\\"]}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer API2_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"enabled_locales\\\" : [ \\\"en\\\", \\\"es\\\"]}\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer API2_ACCESS_TOKEN\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer API2_ACCESS_TOKEN'\nrequest.body = \"{ \\\"enabled_locales\\\" : [ \\\"en\\\", \\\"es\\\"]}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer API2_ACCESS_TOKEN\"\n]\nlet parameters = [\"enabled_locales\": [\"en\", \"es\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Universal Login Internationalization",
  "description": "Describes the languages you can choose to localize your login pages.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/intro-to-flows",
  "markdown": "# Introduction to Flows\n\nFlows are the visual representation of the server-side logic that occurs when a form is processed. Flows consist of a series of actions that you can add and configure as necessary. For every form created, you can create a new flow or share a flow among different forms.\n\n![Dashboard > Forms > Flows](https://images.ctfassets.net/cdy7uua7fh8z/6u6Huh5CbH3GEQJv3AH7cx/e49ea613b2c46a43c83c89ffecddbafe/Flows.png)\n\n### Add Flow nodes\n\nYou can add Flow nodes to add integrations and server-side logic to your form. \n\nTo add a Flow node to a form:\n\n1.  Go to the Form editor.\n    \n2.  On the bottom of the form editor, click on **Flow**.\n    \n3.  Link the new Flow node to the appropriate nodes. \n    \n4.  Select **Click to add a flow.**\n    \n5.  Select **Create a new flow**, name it, and select **Create**.\n    \n6.  Select **Publish** to save the form.\n    \n\n### Configure a Flow\n\nConfigure the Flow node to add integrations.\n\n1.  Select the **Flow node**.\n    \n2.  Select **Edit Flow** to open and configure the flow in a new tab.\n    \n3.  To add actions, click the **\\+** icon to select from a list of actions.\n    \n\n## Flow scenarios\n\nFlow scenarios let you add server-side logic to your Form, such as between a multi-step form, before form submission and after form submission.\n\nThese are the Flow scenarios:\n\n### Between a multi-step form\n\nThese flows run between form steps when the user clicks on a continue button.\n\n![Dashboard > Forms > Flows > Multi-step form flow scenario](https://images.ctfassets.net/cdy7uua7fh8z/6S1BKHFHZB2OykxKCjuaGG/bfd95ba0908c7f81bd6f125e5523007f/multi-step-flow.png)\n\n### Before form submission\n\nThese flows run after a user submits a form, but before the user receives a failure or success response.\n\n![Dashboard >  Forms > Flows > Before form submission flow scenario](https://images.ctfassets.net/cdy7uua7fh8z/3M37rXYrNiOvftVDBv6Xc9/68364133226249a8a9132a7b0bf9fb55/before-form-submission-flow.png)\n\n### After form submission\n\nThese flows run after the user successfully submits a form.\n\n![Dashboard > Forms > Flows > After form submission flow scenario](https://images.ctfassets.net/cdy7uua7fh8z/7dwh7lazWuGG4aItPSsCdM/bdf4629f3d0abcf7e4c5ca80402c353a/after-form-submissio-flow.png)",
  "title": "Introduction to Flows",
  "description": "Describes how to use Flows with Forms.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/nodes-and-components",
  "markdown": "# Nodes and components\n\nForms lets you add nodes and components, such as fields, blocks, and widgets for your users to interact with the form. You can then reference the data input, from components, in your forms and flows.\n\n## Form nodes\n\nThere are five types of form nodes: Start, Step, Flow, Router and Ending screen. These nodes have a very specific purpose for the structure of the form.\n\n![Dashboard >  Forms > Form Editor](https://images.ctfassets.net/cdy7uua7fh8z/5V4GsHxxC2cjxx1aODCxPd/309850c72bbce224e7a8d3f5af34114c/form-editor-preview.png)\n\n## Step node\n\nStep nodes are the visual representation of the form. They can contain any number of components, such as fields, blocks, and widgets where the user can fill in their data.\n\n![Dashboard > Foms > Step node](https://images.ctfassets.net/cdy7uua7fh8z/2tbkcXkVon0BawCvYgnvIz/e2ce566320af18a6b08702f04f763126/form-step-node.png)\n\n### Field components\n\nFields are UI components where users input their information in Forms.\n\n![Dashboard > Forms > Fields](https://images.ctfassets.net/cdy7uua7fh8z/6fuBdJcbDybzcVaiByUkoQ/2ad29c8dbbcc6ddf850f5efc004a75e0/forms-fields.png)\n\n#### Field settings\n\nFields have a number of default settings that you can configure to meet your requirements. \n\nThe default field settings are:\n\n| **Settings** | **Description** |\n| --- | --- |\n| ID  | The unique id |\n| Label | Display or hide a label |\n| Required | Input value is required |\n| Hint text | Display a hint text |\n| Placeholder text | Text visible to the user |\n| Default value | Default value visible to the user |\n| Transient | Enable or disable data mask |\n\n#### Field validation rules\n\n| **Settings** | **Description** |\n| --- | --- |\n| Min. length / Max. length | Require an input value length. |\n| Min. value / Max. value | Require a number value length. |\n\n#### Available fields in Forms\n\nThe available fields with their specific settings and data output types are:\n\n### Blocks components\n\nBlocks are UI components that add functionality to your forms but do not gather user information.\n\n![Dashboard > Forms > Components > Blocks](https://images.ctfassets.net/cdy7uua7fh8z/7IijftJnuwcevL4bdHiaKw/f0376ca75303bb58d0df87e6af75e347/forms-block.png)\n\n#### Available blocks in Forms\n\nThe available blocks are:\n\n### Widgets components\n\nWidgets are pre-built components, with third-party integrations, that add client-side and server-side logic to your forms.\n\n![Dashboard > Forms > Components > Widget](https://images.ctfassets.net/cdy7uua7fh8z/3J0IuWLP7utOPKSHc82IE9/a523afe0c240c63f714ef5fb102f8dab/forms-widget.png)\n\n#### Available widgets in Forms\n\nThe available widget is:\n\n## Router node\n\nRouter nodes let you add rules to create conditional logic jumps between nodes.\n\nBy default, a router node has a single pass-through rule named **Default Case** that connects to other nodes. You can add additional rules based on a set of conditions that a variable must meet to then connect to other nodes. To learn more, read [Router.](https://auth0.com/docs/customize/forms/routers)\n\n![Dashboard > Forms > Routers ](https://images.ctfassets.net/cdy7uua7fh8z/2IKI9sU9UPCVkMkHQ3G8lX/cb828f46a89f9a239419979b3e6c7d20/form-router-rules-example.png)\n\n## Flow node\n\nFlow nodes let you add and create custom logic and integration flows to your forms. To learn more, read [Flows.](https://auth0.com/docs/customize/forms/intro-to-flows)\n\n![Dashboard > Forms > Flow](https://images.ctfassets.net/cdy7uua7fh8z/4UGCrqzgyHTPryLoEuBwNt/e4a67be08a33b565ece89973028fa6ac/forms-flow-node.png)![Dashboard > Forms > Flow > Editor](https://images.ctfassets.net/cdy7uua7fh8z/4L1ixTcIVCmslts6M4wn7u/dc07046cfd41494f40285de5c102ff52/flow-editor-example.png)\n\n## Start node\n\nStart nodes are not visible to the user. It is where you can configure hidden field variables, such as user attributes when [rendering a form with an Action.](https://auth0.com/docs/customize/forms/render)\n\n![Dashboard > Forms > Start node](https://images.ctfassets.net/cdy7uua7fh8z/2GqFDPep4akUxucmMJyb5/2b50f07f50ee29501341dc54f686de07/form-start-node.png)\n\n## Ending screen node\n\nEvery form has an Ending screen node. By default this node resumes the authentication flow and this is where you can configure an After submission flow.\n\n![Dashboard > Forms > Ending screen node](https://images.ctfassets.net/cdy7uua7fh8z/0icbjPpDKsnmtInimJ548/ead65b5e89de57a3079127324acd314d/ending-screen-node.png)",
  "title": "Nodes and components",
  "description": "Learn about Form nodes and available components.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/variables",
  "markdown": "# Variables\n\nVariables allow you to access data contained in Forms and Flows to create custom business logic and automations.\n\nSome basic considerations to using variables are:\n\n*   Variables are surrounded by curly brackets `{{ variable }}`.\n    \n*   If a variable doesn't exist or can't be resolved, it has the same effect as an `undefined` variable.\n    \n*   You can use nullish operators to handle `null` or `undefined` variables, for example:`{{fields.foo ?? fields.bar}}`.\n    \n\n## Available variables\n\nYou can use different types of variables to reference and transform data you gather from customers with Forms and Flows.\n\n| **Variable** | **Syntax** | **Where** | **Description** |\n| --- | --- | --- | --- |\n| Context | `{{context.*}}` | Forms / Flows | Reference context data of the current transaction |\n| Form fields | `{{fields.*}}` | Forms / Flows | Reference data from your form fields and hidden fields |\n| Shared variables | `{{vars.*}}` | Forms / Flows | Reference data stored as shared variables |\n| Flow actions output | `{{actions.*}}` | Flows | Reference data from the output response of previous flow actions |\n| Helper functions | `{{functions.*}}` | Flows | Helper functions to transform data |\n\n### Context variables\n\nForms and flows automatically inherit context variables from the current transaction, this includes information about the [user](https://auth0.com/docs/api/management/v2/users/get-users-by-id), application and the tenant name.\n\nFor example:  `{{context.user.user_id}}` references the `user_id` of the `user` object.\n\n![Dashboard > Forms > Flows](https://images.ctfassets.net/cdy7uua7fh8z/3B8DRhXO2wGqeqSFb8KbQv/0a61cdbbb7f1d290950a2ddb9857aac3/Contex-variable.png)\n\n### Form fields variables\n\nField variables contain data collected from the user from input fields in the form and data from hidden fields. The data of each field varies depending on the field type. For example: `{{fields.first_name}}` references the input value of a field with the ID `first_name`.\n\n![Dashboard > Actions > Forms > Form](https://images.ctfassets.net/cdy7uua7fh8z/4D42A6ww4XvFxweoxh04Rd/016c2ed9d25bc2267ed3ed31bf8b2bf6/form-fields-variable.png)\n\n### Flow output actions variables\n\nWhen a flow action is executed, it generates an output object response that can be referenced in subsequent actions. For example: `{{actions.generate_otp.code}}` references the output code of the action with ID `generate_otp`.\n\n![Dashboard > Actions > Forms > Flows](https://images.ctfassets.net/cdy7uua7fh8z/6jYtEdYqSGXm3DDv0mxQ0o/2d48012629745e07137bf6ba42f4d829/flow-output-variable.png)\n\n### Shared variables\n\nYou can store variables to be shared with subsequent flows or even with form components in the same transaction. Shared variables are ephemeral and are associated with a specific form journey. Their values cannot be accessed outside of that journey. For example: `{{vars.external_id}}` references the value of a shared variable with ID `external_id`.\n\n![Dashboard > Actions > Forms > Flows](https://images.ctfassets.net/cdy7uua7fh8z/4571ExRTHL0KZKJKX9pNwj/abb631b8608a6356b0e5b3784cf8b02f/flow-shared-variable.png)\n\n### Helper functions\n\nHelper functions let you transform data and perform simple operations. For example: `{{functions.toString(fields.privacy_policies)}}` transform the value of the field with ID `privacy_policies` using the `toString()` function.\n\n![Dashboard > Actions > Forms > Flows](https://images.ctfassets.net/cdy7uua7fh8z/1gyox33XJEtdkT43NppblT/0e878cc5ae2bde11b4207e105bbac6c5/flow-helper-functions.png)\n\nThe available helper functions are:\n\n| Function | Description | Example |\n| --- | --- | --- |\n| random(min, max, \\[boolean\\]) | Returns a random number between the inclusive min and max | {{ functions.random(0, 6) }} // 4<br><br>{{ functions.random(0, 6, true) }} // 3.8523497... |\n| toNumber(value) | Converts value to a number | {{ functions.toNumber('123') }} // 123 |\n| toString(value) | Converts value to a string | {{ functions.toString(123) }} // '123' |\n| toBoolean(value) | Converts value to a boolean value | {{ functions.toBoolean(1) }} // true<br><br>{{ functions.toBoolean(0) }} // false |\n| toArray(value) | Converts value to an array | {{ functions.toArray('abc') }} // \\['abc'\\] |\n| length(value) | Returns the length of the parameter value | {{ functions.length('auth0') }} // 5 |\n| toTimestamp() | Returns the current UNIX timestamp | {{ functions.toTimestamp() }} // 1628761483 |\n| toTimestamp(date) | Returns the provided date in UNIX time | {{ functions.toTimestamp('2021-04-30T10:02:50.876Z') }} // 1619776970 |\n| mask(value) | Masks a value to avoid be exposed in Executions | {{ functions.mask('my\\_awesome\\_secret') }} // ███ |\n\n## Variables best practices\n\n### Use meaningful IDs\n\nWhen you add a Form field or a Flow action, the ID is automatically generated. \n\nUpdate the ID to a more descriptive value so you can identify the information it contains. For example, if you create a Form field that stores the user’s first name, update the ID to `first_name`.\n\n### Be mindful when updating existing IDs\n\nIf a variable is already in use and you need to modify the ID, identify where you have referenced it and update the ID accordingly to avoid undefined or empty values.\n\n### Check Flow executions\n\nIf you see an unexpected variable value, use the [**Executions**](https://auth0.com/docs/customize/forms/flow-execution-and-debugger) view to troubleshoot the variable.\n\nThe autocomplete menu helps you locate and properly reference existing variables.\n\n![Dashboard > Actions > Forms > Flows](https://images.ctfassets.net/cdy7uua7fh8z/3SKnDuaMzSImxZtDDAoZaz/9ea800fad29ef71d1ded3c72b87660a4/Autocomplete-flows.png)![Dashboard > Actions > Forms > Form](https://images.ctfassets.net/cdy7uua7fh8z/2kjRKozVgrd2a7UJXOANaN/ee5452d7210cd2f13b0e97763f11c82a/Autocomplete-forms.png)",
  "title": "Variables",
  "description": "Learn how to use variables in Forms for Actions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/render",
  "markdown": "# Render Forms using Actions\n\nOnce you create a form, you can render it with [Actions](https://auth0.com/docs/customize/actions) using the api.prompt.render() method:\n\n```\n// Example using the post-login trigger\n\nexports.onExecutePostLogin = async (event, api) => {\n  api.prompt.render(':form_id');\n}\n\nexports.onContinuePostLogin = async (event, api) => {\n  // Add your logic after completing the form\n}\n```\n\nReplace form\\_id with the ID of the Form. You can locate the ID in the URL of the Form, for example:  `ap_pUMG...` or select it from the Form editor **Embed** tab. In the [Actions Code editor](https://auth0.com/docs/customize/actions/write-your-first-action#create-an-action), you can define the business logic to decide when and how to render the Form.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\n  // Only render the form if user is missing company_name metadata\n  if (!event.user.user_metadata.company_name) {\n    api.prompt.render(':form_id');\n  }\n}\n\nexports.onContinuePostLogin = async (event, api) => {\n  // Add your logic after completing the form\n}\n```\n\nTo learn more about the event object and its contextual information, read [Action Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object).\n\n## Populate field and hidden field values\n\nThe `api.prompt.render()` method lets you add a second argument to populate fields and hidden fields values using the fields object.\n\nIn the example below, the field with the ID `first_name` will be populated with the value `Jane`. \n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  api.prompt.render(':form_id', {\n    fields: {\n      first_name: 'Jane',\n    }\n  });\n}\n\nexports.onContinuePostLogin = async (event, api) => {\n  // Add your logic after completing the form\n}\n```\n\nThe `api.prompt.render()` method passes the information to the form on the client-side. To ensure integrity of the data,  sign it with a [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens).\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const context_token = api.redirect.encodeToken({\n    secret: event.secrets.MY_SECRET_VALUE, // Use your own secret key with a long random value\n    expiresInSeconds: 60,\n    payload: {\n      user_id: event.user.user_id\n    }\n  });\n\n  api.prompt.render(':form_id', {\n    fields: {\n      context_token,\n    }\n  });\n}\n\nexports.onContinuePostLogin = async (event, api) => {\n  // Add your logic after completing the form\n}\n```\n\n## Restrictions and limitations\n\n*   You cannot [redirect](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions) a user and render a form in the same Action. If you need to use both, consider using different Actions.\n    \n*   You can only render one form per Action. If you need to render more than one form, you need to render the forms in different Actions.\n    \n*   The same form can not be rendered more than once across the same trigger. For example, if you have a `post-login` trigger with two Actions, you can not render the same form in both Actions, you need to create different Forms for each Action.\n    \n*   The `fields` property size limit is 24 KB.\n    \n*   The `api.prompt.render()` method is available in the [post-login Action triggers](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object).",
  "title": "Render Forms using Actions",
  "description": "Learn how you can render Forms using Actions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/routers",
  "markdown": "# Routers\n\nWith Router nodes, you can add rules to Forms to create conditional logic jumps that redirect users between nodes. For example, a rule condition can be defined for a specific user\\_metadata attribute to route  a user to a specific step node or flow node.\n\n*   The router node automatically adds a Default case rule. If no rule conditions are met, the journey continues to the linked node.  \n    \n*   Rules are evaluated in the order placed in the router. When a rule condition is met, the journey continues to the linked node, and no other rule conditions are evaluated.\n    \n*   You can add up to 10 rule conditions to the router node.\n    \n\n![Dashboard > Forms > Routers ](https://images.ctfassets.net/cdy7uua7fh8z/2IKI9sU9UPCVkMkHQ3G8lX/cb828f46a89f9a239419979b3e6c7d20/form-router-rules-example.png)\n\n## Add a router rule\n\nTo add a rule condition, follow these steps:\n\n1.  From the Form editor, select a Router node to open its settings.\n    \n2.  Select **\\+ New Rule**.\n    \n3.  Expand the newly created rule.\n    \n4.  To label the rule, add an **Alias**.\n    \n5.  Add a variable using the **+** icon.\n    \n6.  Select the rule operator for the variable.\n    \n7.  Add the value or variable the rule must meet.\n    \n8.  Link the new rule to the corresponding step or flow node.\n    \n9.  Select **Publish** to save.\n    \n\n## Available rule operators\n\nThe rule operators are:\n\n*   `is greater than`\n    \n*   `is greater or equal than`\n    \n*   `is less than`\n    \n*   `is less than or equal`\n    \n*   `is equal to`\n    \n*   `is different to`\n    \n*   `includes`\n    \n*   `does not include`\n    \n*   `starts with`\n    \n*   `ends with`\n    \n*   `exists`\n    \n*   `does not exist`\n    \n*   `is null`\n    \n*   `is not null`\n    \n*   `has not value`\n    \n*   `is true`\n    \n*   `is false`",
  "title": "Routers",
  "description": "Describes how to use Router nodes with Forms.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/vault",
  "markdown": "# Vault\n\nThe vault lets you securely store secrets or common settings (for example: API keys, access tokens, refresh tokens) to authenticate requests with external services or integrations as vault connections.\n\n## Create and modify vault connections\n\nCreate and modify vault connections from the vault page or from the flow editor when an action requires credentials.\n\n### Create vault connections from the vault page\n\nAdd a vault connection from the vault page by following these steps:\n\n1.  Open the Form editor by selecting **Auth0 Dashboard > Actions > Forms.**\n    \n2.  From the top left corner, **{tenantName} >** **Vault** to open the vault page.\n    \n    ![Dashboard > Forms > Vault](https://images.ctfassets.net/cdy7uua7fh8z/1sPNPKO6nuEDCuiYGRWSur/d85dc616170eaf2d7d5f321750863ccf/vault-connections-example.png)\n3.  Select **Add Vault Connection**.\n    \n4.  Select the desired action and **Continue**.\n    \n5.  Add a vault **Connection name** and select **Continue**.\n    \n6.  Enter the credentials. If you don't have the specific credentials, you can select **Create an empty connection** and add the credentials later. Empty connections have an orange icon indicating missing credentials.\n    \n7.  select **Add Vault Connection**.\n    \n\n### Create vault connections from the flow editor\n\nAdd a vault connection from a flow action, for example: Twilio by following these steps:\n\n1.  Open the Flow editor by selecting **Auth0 Dashboard > Actions > Forms > Flows**\n    \n2.  Select a flow and add a **Send SMS with Twilio** action.\n    \n3.  From the **Vault connection** setting of the action, select the **+** Icon.\n    \n    ![Dashboard > Forms > Vault ](https://images.ctfassets.net/cdy7uua7fh8z/1AsaznhRKxm5LZxPlcbfUw/10e5a8af700aab909f5b03fcd266da7e/twilio-vault-connection.png)\n4.  Add a vault **Connection name** and select **Continue**.\n    \n5.  Enter the credentials. If you don't have the specific credentials, you can select **Create an empty connection** and add the credentials later. Empty connections have an orange icon indicating missing credentials.\n    \n    ![Dashboard > Forms > Vault > Twilio connection settings](https://images.ctfassets.net/cdy7uua7fh8z/yobXanutPRCO3FWek8cOk/bc29e39fb8593cff35e2738234bfe6fe/twilio-vault-settings.png)\n6.  Select **Add Vault Connection.**",
  "title": "Vault",
  "description": "Describes how to use the Vault of Forms for Actions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/custom-messages-and-translation",
  "markdown": "# Custom Messages and Translation\n\nYou can  customize Form messages to provide your users with a unique Form experience. In addition, you can translate form components, errors, and other custom messages into other languages for a localized experience.\n\n## Messages\n\nThrough the Form editor, you can customize error messages and create other custom messages for your users.\n\n### Error messages\n\nYou can create custom error messages to replace the default error messages of your forms.\n\nTo create custom error messages, follow the steps below:\n\n1.  On the Auth0 Dashboard, navigate to **Actions > Forms**. \n    \n2.  Select **Messages** from the left menu of the Form editor. \n    \n3.  Select the **Errors** tab**.**\n    \n4.  Enter your custom error messages in the appropriate fields to replace the default messages.\n    \n5.  Select **Publish** to save. \n    \n\n### Custom messages\n\nYou can create custom messages to add to the default messages for an even further personalized Form experience. For example, you can add a custom message that displays to users when an action returns an error in a flow.\n\n#### Create custom messages\n\nTo create custom messages, follow the steps below:\n\n1.  From the left menu of the Form editor, select **Messages**.\n    \n2.  Select the **Custom** tab.Then, select **Add New Item**.\n    \n3.  To the left, add a unique key for your message**.** Then**, enter** your custom message in the field to the right. \n    \n4.  Select **Publish** to save. \n    \n\n![Dashboard > Forms > Custom messages and translations > Custom message](https://images.ctfassets.net/cdy7uua7fh8z/1upBOwWqntPPQF8fqGeN6T/a65674d05c823c5fbe703265558693e4/custom-message.png)\n\n#### Add custom messages to your forms\n\nTo reference your custom messages in your forms, use the function `{{t('custom_unique_key')}}` with the custom message unique key.\n\n![Dashboard > Forms > Custom messages and translations > Translation function](https://images.ctfassets.net/cdy7uua7fh8z/45p4V7w5gw7DQZyJ08ECSH/d040720d9aa19f6e97e21defcd428e55/translation-function.png)\n\n## Translations\n\nYou can use the Translations feature to create an international user experience of your forms. This feature leverages a user’s browser language to determine the appropriate language for your forms. By default, translations for some standard error messages are provided in Spanish. However, to promote a quality user experience, you can define the translations for your form components, errors, and custom messages in the language of your choice. \n\nTo enable translations, follow the steps below:\n\n1.  On the Auth0 Dashboard, navigate to **Actions > Forms**. \n    \n2.  Select **Translations** from the left menu of the Form editor. \n    \n3.  Check **Enable additional languages**.\n    \n4.  Select the desired languages from the **Additional languages** dropdown menu.\n    \n\n### Translate messages\n\nWith the language editor, you can define translations for your form components, errors, and other custom messages.\n\nTo define your translations, follow the steps below:\n\n1.  Select the desired language from the Select language dropdown menu.\n    \n2.  Select one of the following tabs to begin defining your translations: \n    \n    1.  **Components**\n        \n    2.  **Errors**\n        \n    3.  **Custom**\n        \n3.  For each available field, provide your translations as needed.\n    \n4.  Select **Publish** to save. \n    \n\n![Dashboard > Forms > Custom messages and translations > Translation message](https://images.ctfassets.net/cdy7uua7fh8z/5HY9FA6HZct2XNv5K4pCHY/c5977a7825e15285c3d77c2ca1e299a8/translation-message.png)",
  "title": "Custom Messages and Translation",
  "description": "Describes how to create custom messages and translations with Forms.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/internationalization-and-localization/lock-internationalization",
  "markdown": "# Lock Internationalization\n\nYou can change the language of Lock by using the `language` configuration option. This will pull the corresponding language file from the `i18n` directory in Lock.\n\n## Provided languages\n\nTake a look at the [i18n directory](https://github.com/auth0/lock/blob/master/src/i18n/) for language files.\n\n## Set language option\n\nTo use the following examples, you'll need to first include Lock in your page:\n\n`<script src=\"https://cdn.auth0.com/js/lock/11.14/lock.min.js\"></script>`\n\nNext define your `options` object and include the `language` option. The `language` option needs to be a string matching the name of the corresponding file in the `i18n` directory [within Lock](https://github.com/auth0/lock/tree/master/src/i18n). Then instantiate Lock.\n\nto configure this snippet with your account\n\n```\n// Select a supported language\nvar options = {\n  language: 'es'\n};\n\n// Initiating our Auth0Lock\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}',\n  options\n);\n```\n\nTranslation data for Lock comes from language files which have key-value pairs representing various translations. For some languages, certain values may be missing, in which case you will see a warning: `language does not have property <missing prop>`. We encourage you to submit a [pull request](https://github.com/auth0/lock/tree/master/src/i18n) to add these missing values. Alternatively, you may define the missing values in your Lock `options` (see below).\n\n## Replace dictionary terms\n\nYou can also customize your own specific dictionary items using the `languageDictionary` option. This is useful if you are using one of the supported languages, but change the specific wording of a few items. For example, you might re-word the `title` or change the way other labels display to the user while leaving the remaining text on the widget intact.\n\nto configure this snippet with your account\n\n```\n// Customize some languageDictionary attributes\nvar options = {\n  languageDictionary: {\n    emailInputPlaceholder: \"something@youremail.com\",\n    title: \"Log me in\"\n  },\n};\n\n// Initiating our Auth0Lock\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}',\n  options\n);\n```\n\nFor an example of available `languageDictionary` property names and how to structure a `language` file, see the [English dictionary file for Lock](https://github.com/auth0/lock/blob/master/src/i18n/en.js).\n\nThe `languageBaseUrl` option, which takes a string value (a URL), overrides the language source URL for Auth0's provided translations. By default, it uses the Auth0's CDN URL `https://cdn.auth0.com` because that is where the provided language translations are stored. By providing another value, you can use your own source for the language translations as needed for your applications. Your language source should be a JavaScript file.",
  "title": "Lock Internationalization",
  "description": "Lock v11 supports multiple languages, and allows for the addition of other custom language files, as well as for customizing the values of specific pieces of text that are displayed in the Lock widget.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/configure-progressive-profile-form",
  "markdown": "# Use Cases: Configure a progressive profile form using Forms\n\nForms for Actions allows you to create progressive profiling flows to decide when to prompt users to collect missing information, such as company name and job title, and store them as `user_metadata` attributes.\n\n![Dashboard > Actions > Forms > Form](https://images.ctfassets.net/cdy7uua7fh8z/xUx9YmnHvnAqL19JvNtNP/60dae88f893d4ebe8e3523421e960596/Progressive-profle-overview.png)\n\nThe sections below outline how you can create a progressive profile form using nodes and flows, along with steps for adding your form to a [Post Login Action](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow).\n\n## Create a form from scratch\n\nFollow these steps to create a form to gather information:\n\n1.  Open the Form editor by selecting **Auth0 Dashboard > Actions > Forms.**\n    \n2.  Select **Create Form** \\> **Start from scratch**.\n    \n\nBy default, a new form contains a Start node, a Step node, and an Ending screen node.\n\n![Dashboard > Forms > Use Cases > Form](https://images.ctfassets.net/cdy7uua7fh8z/2TZ9jSjgEcARFpULI6hz4R/a4319a1bd482f2ee5cc23100fdb2f42c/New-form-Forms-for-action-use-case.png)\n\n### Configure the Step node\n\nThe Step node is the graphical interface visible to users. Add [Fields](https://auth0.com/docs/customize/forms/nodes-and-components) to the Step node to collect the user's company name and job title values by following these steps:\n\n1.  Drag a **Rich text** field from the **Components menu** into the **Step** node.\n    \n    *   **Rich text**: Enter a custom message.\n        \n        *   **Example**: `Complete your profile! We need you to complete your profile to personalize your experience.`\n            \n    *   Select **Save**.\n        \n2.  Drag a **Text** field into the **Step** node.\n    \n    *   **ID**: Enter `company_name`.\n        \n    *   **Label**: Enable the checkbox.\n        \n    *   **Label**: Enter `Company name`.\n        \n    *   **Required**: Enable the checkbox.\n        \n    *   Select **Save**.\n        \n3.  Drag a **Text** field into the **Step** node.\n    \n    1.  **ID**: Enter `job_title`.\n        \n    2.  **Label**: Enter `Job title`.\n        \n    3.  **Label**: Enable the checkbox.\n        \n    4.  **Required**: Enable the checkbox.\n        \n    5.  Select **Save**.\n        \n4.  Select **Publish** to save.\n    \n\n![Dashboard > Actions > Forms > Form > Step node](https://images.ctfassets.net/cdy7uua7fh8z/6H1lRzwKyYioQyQJ9MtIoM/aa248e92fc028a68a5b92ff361a11644/progressive-profile-step.png)\n\n### Configure the flow node\n\nAdd a **Flow** node after the **Step** node to update the `user_metadata` and resume the authentication flow by following these steps:\n\n1.  Select **Flow** from the bottom of the Form editor.\n    \n2.  Remove the existing link between the **Step** and **Ending Screen** nodes.\n    \n3.  Select the new **Flow** > **Click to add a flow** > **Create a new flow.**\n    \n    *   Enter `Update user_metadata` in the **Name** field.\n        \n    *   Select **Create**.\n        \n    *   Select **Save**.\n        \n4.  Link the **Flow** node to the **Step** and **Ending Screen** nodes as pictured below.\n    \n5.  Select **Publish** to save.\n    \n\n![Dashboard > Actions > Forms > Form](https://images.ctfassets.net/cdy7uua7fh8z/5C91DaWn4LGtJT9BF87ssu/095171d0c452a287c44bfde12fd6d13f/link-nodes.png)\n\nAdd an Auth0 Update user action to the flow by following these steps:\n\n1.  Select the **Update user\\_metadata** flow, then select the **Edit Flow** to open the Flow editor in a new tab.\n    \n2.  Below the **Start** action, select the **+** icon to add an **Update user** action. Complete the fields below, then select **Save** to continue.\n    \n    *   **Connection**: Select from the dropdown the Vault connection to your M2M application.\n        \n    *   **User ID**: Enter `{{context.user.user_id}}`.\n        \n    *   **Body**: Copy and paste the following code to update the user\\_metadata with `job_title` and `company_name` properties.\n        \n        ```\n        {\n          \"user_metadata\": {\n            \"job_title\": \"{{fields.job_title}}\",\n            \"company_name\": \"{{fields.company_name}}\"\n          }\n        }\n        ```\n        \n    *   Select **Save**.\n        \n3.  Select **Publish** to save.\n    \n\n![Dashboard > Actions > Forms > Flows](https://images.ctfassets.net/cdy7uua7fh8z/65Jx4W5oIZJyyvA8z4HqIx/0661b1a8ca6361c54fc4fef07ba59f0b/update-user.png)\n\n### Retrieve the form render code\n\nRetrieve the form render code to visually render the form with a custom Post Login Action by following these steps:\n\n*   From the Form editor, select **<> Render**.\n    \n*   Select **Copy**.\n    \n\n![Dashboard > Actions > Forms > Form > Embed](https://images.ctfassets.net/cdy7uua7fh8z/2EIUzc539sq9lwoTKbjoJv/496a864c0fc44a782c9cadca119dbfb0/embed.png)\n\n## Create a Post Login Action\n\nCreate a post-login Action to render your form by following these steps:\n\n1.  Navigate to **Auth0 Dashboard > Actions > Flows > Login.**\n    \n2.  Select the **+** icon and select **Build from scratch**:\n    \n    *   **Name**: Enter `Render Progressive Profile Form`.\n        \n    *   **Trigger**: Select `Login / Post Login`.\n        \n    *   **Runtime**: Select the recommended version.\n        \n3.  Select **Create**.\n    \n\nTo configure the post-login Action:\n\n1.  Delete the existing code from the Code editor.\n    \n2.  Paste the form embed code into the Code editor.\n    \n3.  Edit the code to define the conditional logic that will render the form.\n    \n    ```\n    /**\n    * @param {Event} event - Details about the user and the context in which they are logging in.\n    * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n    */\n    exports.onExecutePostLogin = async (event, api) => {\n      const FORM_ID = 'REPLACE_WITH_YOUR_FORM_ID';\n    \n      if (\n        event.stats.logins_count > 2 &&\n        !event.user.user_metadata.company_name &&\n        !event.user.user_metadata.job_title\n      ) {\n        api.prompt.render(FORM_ID);\n      }\n    }\n    \n    exports.onContinuePostLogin = async (event, api) => { }\n    ```\n    \n4.  Select **Deploy.**\n    \n5.  Drag and Drop the **Render Progressive Profile Form** Action to the **Login** flow.\n    \n    ![Dashboard > Forms > Use Cases Progressive Profile Login Action](https://images.ctfassets.net/cdy7uua7fh8z/1QjjZdpTqTxx012UDN4xk9/99fba5ef4068a5688f1762eea7f42976/renderprogessiveprofile.png)\n6.  Select **Apply**.\n    \n\n### Test implementation\n\nTest the implementation by following these steps:\n\n1.  Log in with an existing user whose login count is greater than 2 and their `user_metadata` attributes `company_name` and `job_title` have no values.\n    \n2.  The post-login action in the Login flow will render the form and prompt for the information.\n    \n3.  Select **Auth0 Dashboard > User Management > Users,** locate the user and verify that the `user_metadata` attributes `company_name` and `job_title` contain information.",
  "title": "Use Cases: Configure a progressive profile form using Forms",
  "description": "Learn how to configure a progressive profile form using Forms for Actions",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/flow-execution-and-debugger",
  "markdown": "# Flow Execution and Debugger\n\nEach time a flow executes, Auth0 stores an entry that you can use to debug the execution. This is useful to understand why a flow execution error has occurred. For example: a flow can fail due to missing properties, typos, incorrect API keys, etc.\n\n## Review flow executions\n\nTo review an execution entry for a flow, follow the steps below:\n\n1.  Navigate to **Auth0 Dashboard > Actions > Forms**, then select **Flows**.\n    \n2.  Select a flow from the list. \n    \n3.  Select **Executions**.\n    \n\n![Dashboard > Actions > Forms > Flows > Execution](https://images.ctfassets.net/cdy7uua7fh8z/448jfjHtgCxfIeDOakuHyd/fba64deda0cf920f399de2190e94bdc9/Flows-execution.png)\n\nEvery execution entry has four properties:\n\n*   **Execution date**: The date of the flow execution.\n    \n*   **Execution ID**: The unique ID of the flow execution.\n    \n*   **Status**: The current stage of the flow execution. There are four possible execution statuses:\n    \n    *   **Running**: The execution is currently in progress.  \n        \n    *   **Failed**: The execution failed due to an internal error, such as missing required settings in a flow action.\n        \n    *   **Completed**: The execution finished without internal errors.\n        \n*   **View Details**: Opens the debug window of the execution.\n    \n\n![Dashboard > Actions >  Forms > Flows > Executions](https://images.ctfassets.net/cdy7uua7fh8z/1VqWEaVZg5lrXatXe9dbFB/dbcf7edca5aabdfc544f04cb18be4149/Flow-execution-details.png)\n\n## Debug flow executions\n\nTo help debug or troubleshoot a flow, you can review the flow’s input, output, and error data by accessing the **View Details** of the execution.\n\n![Dashboard > Actions > Forms > Form](https://images.ctfassets.net/cdy7uua7fh8z/5aeniTfHXplDyZfwCKBcgK/a2098a476edde76da10a527b0a606e95/Flow-error.png)\n\nTo debug an error that interrupts the flow execution, follow these steps:\n\n1.  Navigate to **Auth0 Dashboard > Actions > Forms**\n    \n2.  Locate the flow linked to the step node.\n    \n    ![Dashboard > Actions > Forms > Form](https://images.ctfassets.net/cdy7uua7fh8z/4LjULYyo0nhtNowm7J5okz/27ea3f8386bb5015d447c48facf6b90f/flow-error-linked.png)\n3.  Select **Edit Flow.**\n    \n4.  Select **Executions**.\n    \n5.  Select **View Details** of the Failed execution.\n    \n\nIn the example below, the `Update user` **Input** view shows a null value for the  `user_id` property.\n\n![Dashboard > Actions > Forms > Flow > Execution](https://images.ctfassets.net/cdy7uua7fh8z/6QNYKDqG9AIOEzQkP6Fnnr/db885e146179a0490eddd5ad6cb518dc/Flow-execution-failed.png)\n\nThe **Error** view indicates that the action’s schema validation failed due to a missing the required `user_id`. The flow returns an internal error that interrupts the flow execution.\n\n![Dashboard > Actions > Forms > Flow > Execution > Error](https://images.ctfassets.net/cdy7uua7fh8z/1kaKihtJtv8VvNAyTkW4cC/6b34bcecc8642d7d97aaf2c8dec51ebc/flow-execution-error-view.png)\n\nA review of the **Update user** action shows a syntax error in the `User ID` parameter, the correct syntax is `{{context.user.user_id}}`. Once the syntax is corrected, test the flow to confirm. To learn more about variable syntaxes, read [Variables](https://auth0.com/docs/customize/forms/variables).\n\n![Dashboard > Actions > Forms > Flows](https://images.ctfassets.net/cdy7uua7fh8z/4YLRVNbzK5LjJEQjFXIJXM/5003833784ce5b0d9f63730ed46ff047/Action-typo-error.png)",
  "title": "Flow Execution and Debugger",
  "description": "Describes how to review Flow executions and debug executions of Forms.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/configure-update-policy-form",
  "markdown": "# Use Cases: Configure an update policy form using Forms\n\nForms for Actions allows you to create custom privacy policies flows and store the consent under the `app_metadata` object.\n\n![Dashboard > Actions > Forms > Privacy policy use case](https://images.ctfassets.net/cdy7uua7fh8z/6i68dMvHDTijfRmSgN1x8Q/ad900e7d4c0fb34645921435472b8684/privavy-policy-form.png)\n\nThe sections below outline how you can create an Update Policy form using nodes and flows, along with steps for adding your form to a [Post Login](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) Action.\n\n## Create a form from scratch\n\nFollow these steps to create a form to gather information:\n\n1.  Open the Form editor by selecting **Auth0 Dashboard > Actions > Forms.**\n    \n2.  Select **Create Form** \\> **Start from scratch**.\n    \n\nBy default, a new form contains a Start node, a Step node, and an Ending screen node.\n\n![Dashboard > Forms > Use Cases > Form](https://images.ctfassets.net/cdy7uua7fh8z/2TZ9jSjgEcARFpULI6hz4R/a4319a1bd482f2ee5cc23100fdb2f42c/New-form-Forms-for-action-use-case.png)\n\n### Configure the Step node\n\nThe Step node is the graphical interface visible to users. Add [Fields](https://auth0.com/docs/customize/forms/nodes-and-components) to the Step node to collect the new agreement acceptance value by following these steps:\n\n1.  Drag a **Rich text** field from the **Components menu** into the **Step** node.\n    \n    *   **Rich text**: Enter a description of your privacy policies updates.\n        \n    *   Select **Save**.\n        \n2.  Drag a **Legal** field into the **Step** node.\n    \n    *   **ID**: Enter `privacy_policies`.\n        \n    *   **Required**: Enable the checkbox.\n        \n    *   **Legal**: Enter `I agree to the Privacy Policy`.\n        \n    *   Select **Save**.\n        \n3.  Select **Publish** to save.\n    \n\n![Dashboard > Actions > Forms > Use case privacy policy step node](https://images.ctfassets.net/cdy7uua7fh8z/59zFFjQjAnjogkc2QGIqqJ/0ad66b1b636544122aa4e65968b76c2c/privacy-policy-step-node.png)\n\n### Configure the Flow node\n\nAdd a **Flow** node after the **Step** node to update the `app_metadata` and resume the authentication flow by following these steps:\n\n1.  Select **Flow** from the bottom of the Form editor.\n    \n2.  Remove the existing link between the **Step** and **Ending Screen** nodes.\n    \n3.  Select the new **Flow** > **Click to add a flow** > **Create a new flow.**\n    \n    *   Enter `Update app_metadata` in the **Name** field.\n        \n    *   Select **Create**.\n        \n    *   Select **Save**.\n        \n4.  Link the **Flow** node to the **Step** and **Ending Screen** nodes as pictured below.\n    \n5.  Select **Publish** to save.\n    \n\n![Dashboard > Actions > Forms > Form](https://images.ctfassets.net/cdy7uua7fh8z/6YIkzm7SrpM9LW76AXuRzh/353c518fe82bbaa440836da1d83596d6/link-policies.png)\n\nAdd an Auth0 Update user action to the flow by following these steps:\n\n1.  Select the **Flow** **Update app\\_metadata** \\> **Edit flow** to open the Flow editor in a new tab.\n    \n2.  Below the Start Action, select the **+** icon to add an **Update user** action. Complete the fields below, then select **Save** to continue.\n    \n    *   **Connection**: Select from the dropdown the Vault connection to your M2M application.\n        \n    *   **User ID**: Enter `{{context.user.user_id}}`.\n        \n    *   **Body**: Copy and paste the following code to update the app\\_metadata with the privacy\\_policies and privacy\\_policies\\_timestamp properties.\n        \n        ```\n        {\n          \"app_metadata\": {\n            \"privacy_policies\": true,\n            \"privacy_policies_timestamp\": \"{{ functions.toTimestamp() }}\"\n          }\n        }\n        ```\n        \n    *   Select **Save**.\n        \n3.  Select **Publish** to save.\n    \n\n![Dashboard > Actions > Forms > User case privacy policy code](https://images.ctfassets.net/cdy7uua7fh8z/CvMNIwWrOUwaFW4X3G28p/1fb70ae57a20749d9ffaaba8dc0b7e26/update-user-privacy.png)\n\n## Retrieve the form render code\n\nRetrieve your form render code to visually render the form with a custom Post Login Action by following these steps:\n\n*   From the Form editor, select **<> Render**.\n    \n*   Select **Copy**.\n    \n\n![Dashboard > Actions > Forms > Form > Embed](https://images.ctfassets.net/cdy7uua7fh8z/2EIUzc539sq9lwoTKbjoJv/496a864c0fc44a782c9cadca119dbfb0/embed.png)\n\n## Create a Post Login Action\n\nCreate a post-login Action to render your form by following these steps:\n\n1.  Navigate to **Auth0 Dashboard > Actions > Flows > Login.**\n    \n2.  Select the **+** icon and Select **Build from scratch**:\n    \n    *   **Name**: Enter `Render Update Policy Form`.\n        \n    *   **Trigger**: Select `Login / Post Login`.\n        \n    *   **Runtime**: Select the recommended version.\n        \n3.  Select **Create**.\n    \n\nTo configure the post-login Action:\n\n1.  Delete the existing code from the Code editor.\n    \n2.  Paste the form render code into the Code editor.\n    \n3.  Edit the code to define the conditional logic that will render the form.\n    \n    ```\n    /**\n    * @param {Event} event - Details about the user and the context in which they are logging in.\n    * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n    */\n    exports.onExecutePostLogin = async (event, api) => {\n      const FORM_ID = 'REPLACE_WITH_YOUR_FORM_ID';\n    \n      if (event.user.app_metadata.privacy_policies !== true) {\n        api.prompt.render(FORM_ID);\n      }\n    }\n    \n    exports.onContinuePostLogin = async (event, api) => { }\n    ```\n    \n4.  Select **Deploy.**\n    \n5.  Drag and Drop the **Render Update Policy Form** Action to the **Login** flow.\n    \n    ![Dashboard > Forms > Use Case > Render update policy form login action](https://images.ctfassets.net/cdy7uua7fh8z/5TOwDgevZsBqd7yZynUYWU/41ca909dc3007aed4f40ff794a05efa5/postlogin.png)\n6.  Select **Apply.**\n    \n\n### Test implementation\n\nTest the implementation by following these steps:\n\n1.  Log in with an existing user whose app`_metadata` attribute `privacy_policies` does not have a value.\n    \n2.  The post-login Action in the Login flow will render the form and prompt for acceptance.\n    \n3.  Select **Auth0 Dashboard > User Management > Users,** locate the user and verify that the `app_metadata` attribute `privacy_policies` contains a `true` value and a timestamp.",
  "title": "Use Cases: Configure an update policy form using Forms",
  "description": "Configure an update policy form using Forms for Actions",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms/configure-additional-signup-steps",
  "markdown": "# Use Cases: Configure additional signup steps using Forms\n\nForms for Actions allows you to create additional steps in your signup or login flows and make them required before allowing users to access your application.\n\n![Dashboard > Actions > Forms > Use Case Custom Signup Form](https://images.ctfassets.net/cdy7uua7fh8z/ZOQNi6SrEC9OREcBbdiJ3/d79f84fb61acd5473bdf932527e26d58/custom-signup-form.png)\n\nThe sections below outline how to create additional signup steps forms using nodes and flows, along with steps for adding your form to a [Post Login](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) Action.\n\n## Create a form from scratch\n\nFollow these steps to create a form to gather information:\n\n1.  Open the Form editor by selecting **Auth0 Dashboard > Actions > Forms.**\n    \n2.  Select **Create Form** \\> **Start from scratch**.\n    \n\nBy default, a new form contains a Start node, a Step node, and an Ending screen node.\n\n![Dashboard > Forms > Use Cases > Form](https://images.ctfassets.net/cdy7uua7fh8z/2TZ9jSjgEcARFpULI6hz4R/a4319a1bd482f2ee5cc23100fdb2f42c/New-form-Forms-for-action-use-case.png)\n\n### Configure the Step node\n\nThe Step node is the graphical interface visible to users. Add [Fields](https://auth0.com/docs/customize/forms/nodes-and-components) to the Step node to collect the user's full name and job title values by following these steps:\n\n1.  Drag a **Rich text** field from the **Components menu** into the **Step** node.\n    \n    *   **Rich text**: Enter a custom message.\n        \n    *   Select **Save**.\n        \n2.  Drag a **Text** field into the **Step** node.\n    \n    *   **ID**: Enter `full_name`.\n        \n    *   **Label**: Enter `Full name`.\n        \n    *   **Label**: Enable the checkbox.\n        \n    *   **Required**: Enable the checkbox.\n        \n    *   Select **Save**.\n        \n3.  Drag a **Text** field into the **Step** node.\n    \n    *   **ID**: Enter `job_title`.\n        \n    *   **Label**: Enter `Job title.`\n        \n    *   **Label**: Enable the checkbox.\n        \n    *   **Required**: Enable the checkbox.\n        \n    *   Select **Save**.\n        \n4.  Select **Publish** to save.\n    \n\n![Dashboard > Actions > Forms > Use Case Custom Signup Steps Step node](https://images.ctfassets.net/cdy7uua7fh8z/6Kcn0ai9fsVsqHwZpTGByG/37cbf4ffee63a7010926b15f06dd20ac/custom-signup-step-node.png)\n\n### Configure the Flow node\n\nAdd a **Flow** node after the **Step** node to update the `user_metadata` and resume the authentication flow by following these steps:\n\n1.  Select **Flow** from the bottom of the Form editor.\n    \n2.  Remove the existing link between the **Step** and **Ending Screen** nodes.\n    \n3.  Select the new **Flow** > **Click to add a flow** > **Create a new flow.**\n    \n    *   Enter `Update user_metadata` in the **Name** field.\n        \n    *   Select **Create**.\n        \n    *   Select **Save**.\n        \n4.  Link the **Flow** node to the **Step** and **Ending Screen** nodes as pictured below.\n    \n5.  Select **Publish** to save.\n    \n\n![Dashboard > Actions > Forms > Use Case Custom Signup Step Update User metadata flow](https://images.ctfassets.net/cdy7uua7fh8z/4nTdYdA2Hu5vK65smkdvJg/db3294ebc25a7c2636be96362a3ea56e/custom-signup-step-flow.png)\n\nAdd an Auth0 Update user action to the flow by following these steps:\n\n1.  Select the **Flow** **Update user\\_metadata** \\> **Edit flow** to open the Flow editor in a new tab.\n    \n2.  Below the Start Action, select the **+** icon to add an **Update user** Action. Complete the fields below, then select **Save** to continue.\n    \n    *   **Connection**: Select from the dropdown the Vault connection to your M2M application.\n        \n    *   **User ID**: Enter `{{context.user.user_id}}`.\n        \n    *   **Body**: Copy and paste the following code to update the user\\_metadata with `full_name` and `job_title` properties.\n        \n        ```\n        {\n          \"user_metadata\": {\n            \"full_name\": \"{{fields.full_name}}\",\n            \"job_title\": \"{{fields.job_title}}\"\n          }\n        }\n        ```\n        \n    *   Select **Save**.\n        \n3.  Select Publish to save.\n    \n\n## Retrieve your form render code\n\nRetrieve your form render code to visually render the form with a custom Post Login Action by following these steps:\n\n*   From the Form editor, select **<> Render**.\n    \n*   Select **Copy**.\n    \n\n![Dashboard > Actions > Forms > Form > Embed](https://images.ctfassets.net/cdy7uua7fh8z/2EIUzc539sq9lwoTKbjoJv/496a864c0fc44a782c9cadca119dbfb0/embed.png)\n\n## Create a Post Login Action\n\nCreate a post-login Action to render your form by following these steps:\n\n1.  Navigate to **Auth0 Dashboard > Actions > Flows > Login.**\n    \n2.  Select the **+** icon and select **Build from scratch**:\n    \n    *   **Name**: Enter `Render Additional Signup Form`.\n        \n    *   **Trigger**: Select `Login / Post Login`.\n        \n    *   **Runtime**: Select the recommended version.\n        \n3.  Select **Create**.\n    \n\nTo configure the post-login Action:\n\n1.  Delete the existing code from the Code editor.\n    \n2.  Paste the form render code into the Code editor.\n    \n3.  Edit the code to define the conditional logic that will render the form.\n    \n    ```\n    /**\n    * @param {Event} event - Details about the user and the context in which they are logging in.\n    * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n    */\n    exports.onExecutePostLogin = async (event, api) => {\n      const FORM_ID = 'REPLACE_WITH_YOUR_FORM_ID';\n    \n      if (\n        !event.user.user_metadata.full_name &&\n        !event.user.user_metadata.job_title\n      ) {\n        api.prompt.render(FORM_ID);\n      }\n    }\n    \n    exports.onContinuePostLogin = async (event, api) => { }\n    ```\n    \n4.  Select **Deploy.**\n    \n5.  Drag and Drop the **Render Additional Signup Form** Action to the **Login** flow.\n    \n    ![Dashboard > Forms > Use Cases Custom Signup Steps Login Flow](https://images.ctfassets.net/cdy7uua7fh8z/1WBOicIOcH98hKj6Lq9HF2/4951e30a0cc08c7c5daa0116eaa17e11/Screenshot_2024-03-01_at_15.48.00.png)\n6.  Select **Apply**.\n    \n\n### Test implementation\n\nTest the implementation by following these steps:\n\n*   Sign up to an application with a new user.\n    \n*   The post-login Action in the Login flow will render the form and prompt for the information.\n    \n*   Select **Auth0 Dashboard > User Management > Users,** locate the new user, and verify that its attributes `full_name` and `job_title` contain the information from the additional signup step.",
  "title": "Use Cases: Configure additional signup steps using Forms",
  "description": "Learn how to configure additional signup steps using Forms for Actions",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/create-rules",
  "markdown": "# Create Rules\n\nYou can build your own rule(s) to support your specific functionality requirements. You can modify a pre-existing rule template or choose to start from scratch using one of our samples. Auth0 provides a number of pre-existing rules and rule templates to help you achieve your goal(s). To see a list, visit our [rules repository on GitHub](https://github.com/auth0/rules).\n\n## How rules work\n\nRules are JavaScript functions that execute when a user authenticates to your application. They run once the authentication process is complete, and you can use them to customize and extend Auth0's capabilities. For security reasons, your rules code executes isolated from the code of other Auth0 tenants in a sandbox. Rules also run during the token refresh flow. To learn more, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\nIn Auth0, the authentication transaction flow works as follows when you use rules:\n\n![Rules in the Authentication Flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/2gtBtkPChIyguA24x6enx2/ffbb8e21e86920ef9914f6fc126dc1df/flow.png)\n\n1.  An app initiates an authentication request to Auth0.\n    \n2.  Auth0 routes the request to an identity provider through a configured connection.\n    \n3.  The user authenticates successfully.\n    \n4.  The ID token and/or access token is passed through the rules pipeline, then sent to the application.\n    \n\n## Prerequisite\n\nIf you plan to use global variables in your rule, be sure to configure your rules variables first. To learn more, read [Configure Global Variables for Rules](https://auth0.com/docs/customize/rules/configure-global-variables-for-rules).\n\n## Use the Dashboard\n\n1.  Go to [Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules) and click **Create**.\n    \n    ![Dashboard - Auth Pipeline - Rules ](https://images.ctfassets.net/cdy7uua7fh8z/4OiSXzc5fYgPagHdOGbfvj/a589bdf811df66658fe21c509aed610c/Dashboard_-_Auth_Pipeline_-_Rules.png)\n2.  Select a rule template.\n    \n    ![Dashboard - Auth Pipeline - Rules - Template](https://images.ctfassets.net/cdy7uua7fh8z/6IydSSjg2oQrdSzErcTYtN/d17348a98c597a74b2989c298764b9e1/dashboard-rules-create_choose-template.png)\n3.  Name the rule, modify the script to suit your needs, and click **Save changes**.\n    \n    ![Dashboard - Auth Pipeline - Rules - Edit Rule](https://images.ctfassets.net/cdy7uua7fh8z/5CoC6cnazv2uT1iSq6OGsm/6cb30d9479971be771313da80acc4802/Dashboard_-_Auth_Pipeline_-_Rules_-_Edit_Rule.png)\n\n## Use the Management API\n\nMake a `POST` call to the [Create Rule endpoint](https://auth0.com/docs/api/management/v2#!/Rules/post_rules). Be sure to replace `MGMT_API_ACCESS_TOKEN`, `RULE_NAME`, `RULE_SCRIPT`, `RULE_ORDER`, and `RULE_ENABLED` placeholder values with your Management API Access Token, rule name, rule script, rule order number, and rule enabled value, respectively.\n\n*   [cURL](#7787cd611bdf4d1484e51efe784d783b_shell)\n*   [C#](#7787cd611bdf4d1484e51efe784d783b_csharp)\n*   [Go](#7787cd611bdf4d1484e51efe784d783b_go)\n*   [Java](#7787cd611bdf4d1484e51efe784d783b_java)\n*   [Node.JS](#7787cd611bdf4d1484e51efe784d783b_node)\n*   [Obj-C](#7787cd611bdf4d1484e51efe784d783b_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/rules' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"name\": \"RULE_NAME\", \"script\": \"RULE_SCRIPT\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/rules\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"name\\\": \\\"RULE_NAME\\\", \\\"script\\\": \\\"RULE_SCRIPT\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/rules\"\n\n\tpayload := strings.NewReader(\"{ \\\"name\\\": \\\"RULE_NAME\\\", \\\"script\\\": \\\"RULE_SCRIPT\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/rules\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"name\\\": \\\"RULE_NAME\\\", \\\"script\\\": \\\"RULE_SCRIPT\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/rules',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {name: 'RULE_NAME', script: 'RULE_SCRIPT'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"name\": @\"RULE_NAME\",\n                              @\"script\": @\"RULE_SCRIPT\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/rules\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/rules\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"name\\\": \\\"RULE_NAME\\\", \\\"script\\\": \\\"RULE_SCRIPT\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"name\\\": \\\"RULE_NAME\\\", \\\"script\\\": \\\"RULE_SCRIPT\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/rules\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/rules\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"name\\\": \\\"RULE_NAME\\\", \\\"script\\\": \\\"RULE_SCRIPT\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"name\": \"RULE_NAME\",\n  \"script\": \"RULE_SCRIPT\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/rules\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| **Value** | **Description** |\n| --- | --- |\n| `MGMT_API_ACCESS_TOKEN` | Access Token for the Management API with the scope `create:rules`. |\n| `RULE_NAME` | Name of the rule you would like to create. The rule name can only contain alphanumeric characters, spaces, and hyphens; it may not start or end with spaces or hyphens. |\n| `RULE_SCRIPT` | Script that contains the code for the rule. Should match what you would enter if you were creating a new rule using the Dashboard. |\n| `RULE_ORDER` (optional) | Integer that represents the order in which the rule should be executed in relation to other rules. Rules with lower numbers are executed before rules with higher numbers. If no order number is provided, the rule will execute last. |\n| `RULE_ENABLED` (optional) | Boolean that represents whether the rules is enabled (`true`) or disabled (`false`). |\n\n## Manage rate limits\n\nFor rules that call Auth0 APIs, you should always handle rate limiting by checking the `X-RateLimit-Remaining` header and acting appropriately when the number returned nears 0. You should also add logic to handle cases in which you exceed the provided rate limits and receive the HTTP Status Code 429 (Too Many Requests); in this case, if a retry is needed, it is best to allow for a back-off to avoid going into an infinite retry loop. To learn more about rate limits, read [Rate Limit Policy For Auth0 APIs](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy).\n\n## Available modules\n\nRules run in a JavaScript sandbox configured for a specific Node.js version.\n\nThe sandbox supports all versions of the JavaScript language (and associated syntax) for the configured Node.js version, and a large number of Node.js modules. For a list of supported sandbox modules, check out [Can I require: Auth0 Extensibility](https://auth0-extensions.github.io/canirequire/).\n\n## Learn more\n\n*   [Configure Global Variables for Rules](https://auth0.com/docs/customize/rules/configure-global-variables-for-rules)\n*   [Rules Environment Best Practices](https://auth0.com/docs/rules-best-practices/rules-environment-best-practices)",
  "title": "Create Rules",
  "description": "Learn how to create rules using the Auth Dashboard or the Management API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/configure-global-variables-for-rules",
  "markdown": "# Configure Global Variables for Rules\n\nYou can configure global variables for rules using Auth0's Dashboard. To learn more, see [Auth0 Rules](https://auth0.com/docs/customize/rules).\n\n1.  Go to [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules) and locate the **Settings** section.\n    \n    ![Dashboard - Auth Pipeline - Rules ](https://images.ctfassets.net/cdy7uua7fh8z/4OiSXzc5fYgPagHdOGbfvj/a589bdf811df66658fe21c509aed610c/Dashboard_-_Auth_Pipeline_-_Rules.png)\n2.  Enter a variable key/value pair, and select **+** **Add**.\n    \n    The entered value is now available to all rules via the global `configuration` object and can be referenced using the value in the **Code Snippet** column.\n    \n\n## Learn more\n\n*   [Create Rules](https://auth0.com/docs/customize/rules/create-rules)",
  "title": "Configure Global Variables for Rules",
  "description": "Describes how to configure global variables for rules using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/configuration",
  "markdown": "# Store Rule Configurations\n\nThe global `configuration` object is available in Rules for storing commonly used values, such as URLs. Sensitive information, such as credentials or API keys, should be stored through the `configuration` object and kept out of your Rules code.\n\n## Configure values\n\nYou can set configuration values in your [Rules Settings](https://manage.auth0.com/#/rules/) on the Dashboard.\n\nTo edit or change a configuration key's value, remove the existing configuration setting and replace it with the updated value. You need to have created at least one Rule to see the configuration area, otherwise, the Rules demo shows instead.\n\n![Dashboard - Auth Pipeline - Rules ](https://images.ctfassets.net/cdy7uua7fh8z/4OiSXzc5fYgPagHdOGbfvj/a589bdf811df66658fe21c509aed610c/Dashboard_-_Auth_Pipeline_-_Rules.png)\n\n## Use the configuration object\n\nAny configuration values you set can be accessed through the `configuration` object by key in your Rules code.\n\n```\nvar MY_API_KEY = configuration.MY_API_KEY;\n```\n\nThe following example is a Rule for sending a Slack message when a new user has signed up. The [Slack Webhook](https://api.slack.com/incoming-webhooks) is a `configuration` value set with the key `SLACK_HOOK_URL`.\n\n```\nfunction (user, context, callback) {\n  // short-circuit if the user signed up already or is using a Refresh Token\n  if (context.stats.loginsCount > 1 || context.protocol === 'oauth2-refresh-token') {\n    return callback(null, user, context);\n  }\n\n  // get your slack's hook url from: https://slack.com/services/10525858050\n  const SLACK_HOOK = configuration.SLACK_HOOK_URL;\n\n  const slack = require('slack-notify')(SLACK_HOOK);\n  const message = 'New User: ' + (user.name || user.email) + ' (' + user.email + ')';\n  const channel = '#some_channel';\n\n  slack.success({\n    text: message,\n    channel: channel\n  });\n\n  // don’t wait for the Slack API call to finish, return right away (the request will continue on the sandbox)`\n  callback(null, user, context);\n}\n```",
  "title": "Store Rule Configurations",
  "description": "Learn about the global configuration object in rules for storing commonly used values.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/use-management-api",
  "markdown": "# Use the Management API from within Rules\n\nFrom within any [Auth0 Rule](https://auth0.com/docs/customize/rules) you write, you can update a user's `app_metadata` or `user_metadata` using the `auth0` object, which is a specially-restricted instance of `ManagementClient` (defined in the [node-auth0](https://github.com/auth0/node-auth0) Node.js client library) and provides limited access to the [Auth0 Management API](https://auth0.com/docs/api/management/v2). To learn more, read [Rules Execution Best Practice](https://auth0.com/docs/rules-best-practices/rules-execution-best-practices).\n\nTo access additional Management API endpoints from inside Rules, you have to use another version of the library.\n\n## Access a newer version of the library\n\nYou can load a newer version of the Auth0 Node.js client library by requiring the specific version of the library. For up-to-date version information, check the [Auth0 Node repository](https://github.com/auth0/node-auth0) in Github.\n\nIn this example, we load version `2.9.1` of the library, then query the list of users and logs the users to the console (to be inspected with the [Real-time Webtask Logs Extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs)).\n\n```\nfunction (user, context, callback) {\n  var ManagementClient = require('auth0@2.9.1').ManagementClient;\n  var management = new ManagementClient({\n    token: auth0.accessToken,\n    domain: auth0.domain\n  });\n\n  management.getUsers(function (err, users) {\n    console.log(users);\n    callback(null, user, context);\n  });\n}\n```",
  "title": "Use the Management API from within Rules",
  "description": "Learn how to use the Management API from within rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/redirect-users",
  "markdown": "# Redirect Users from Within Rules\n\nYou can use [Auth0 Rules](https://auth0.com/docs/customize/rules) to redirect users before an authentication transaction is complete. This lets you implement custom authentication flows that require additional user interaction beyond the standard login form. Redirect rules are commonly used to do custom Multi-factor Authentication (MFA) in Auth0, but they can also be used for:\n\n*   Custom privacy policy acceptance, terms of service, and data disclosure forms.\n    \n*   Securely performing a one-time collection of additional required profile data.\n    \n*   Allowing remote Active Directory users to change their password.\n    \n*   Requiring users to provide additional verification when logging in from unknown locations.\n    \n*   Gathering more information about your users than they provided at initial signup.\n    \n\nYou can redirect a user **once** per authentication flow. If you have one rule that redirects a user, you **cannot** invoke a second rule to redirect the user at a later time.\n\nTo learn more, see [Multi-Factor Authentication in Auth0](https://auth0.com/docs/secure/multi-factor-authentication).\n\n## Start redirect and resume authentication\n\nSet the `context.redirect` property as follows:\n\n```\nfunction (user, context, callback) {\n  context.redirect = {\n    url: \"https://example.com/foo\"\n  };\n  return callback(null, user, context);\n}\n```\n\nOnce all rules have finished executing, Auth0 redirects the user to the URL specified in the `context.redirect.url` property. Auth0 also passes a `state` parameter in that URL. For example:\n\n```\nhttps://example.com/foo?state=abc123\n```\n\nYour redirect URL needs to extract the `state` parameter and send it back to Auth0 to resume the authentication transaction. State is an opaque value, used to prevent [Cross-Site Request Forgery (CSRF) attacks](https://auth0.com/docs/security/common-threats#cross-site-request-forgery).\n\nAfter the redirect, resume authentication by redirecting the user to the `/continue` endpoint and include the `state` parameter you received in the URL. If you do not send the original state back to the `/continue` endpoint, Auth0 will lose the context of the login transaction and the user will not be able to log in due to an `invalid_request` error.\n\nFor example:\n\n```\nhttps://{yourDomain}/continue?state={originalState}\n```\n\nIf you're using a custom domain:\n\n```\nhttps://{yourAuth0CustomDomain}/continue?state={originalState}\n```\n\n`THE_ORIGINAL_STATE` is the value that Auth0 generated and sent to the redirect URL. For example, if your rule redirected to `https://example.com/foo`, Auth0 would use a redirect URL similar to `https://example.com/foo?state=abc123`. So `abc123` would be the `THE_ORIGINAL_STATE`. To resume the authentication transaction, you would redirect to:\n\n```\nhttps://{yourDomain}/continue?state=abc123\n```\n\nWhen a user has been redirected to the `/continue` endpoint:\n\n*   **all rules will be run again**, however, the `context.redirect` will be ignored to allow authentication to continue.\n    \n*   any changes to the user object are made during the redirect, prior to calling the `/continue` endpoint. For example, updates through the Auth0 Management API are available after continuing the transaction.\n    \n\n## Validate resumed login\n\nTo distinguish between user-initiated logins and resumed login flows, check the `context.protocol` property:\n\n```\nfunction (user, context, callback) {\n    if (context.protocol === \"redirect-callback\") {\n        // User was redirected to the /continue endpoint\n    } else {\n        // User is logging in directly\n    }\n}\n```\n\n## Force password change example\n\nIn some cases, you may want to force users to change their passwords under specific conditions. You can write a rule that has the following behavior:\n\n1.  The user attempts to log in and needs to change their password.\n    \n2.  The user is redirected to an application-specific page with a JWT in the query string. This JWT ensures that only this user's password can be changed and **must be validated** by the application.\n    \n3.  The user changes their password in the application-specific page by having the application call the [Auth0 Management API](https://auth0.com/docs/api/v2#!/Users/patch_users_by_id)\n    \n4.  Once the user has successfully changed their password, the application extracts the `authorize_again` claim from the verified and decoded JWT, then proceeds to redirect the user to that URL allowing them to sign in with their new password.\n    \n\n```\nfunction(user, context, callback) {\n   /*\n   * Prerequisites:\n   * 1. Implement a `mustChangePassword` function\n   * 2. Set configuration variables for the following:\n   *    - CLIENT_ID\n   *    - CLIENT_SECRET\n   *    - ISSUER\n   */\n\n  const url = require('url@0.10.3');\n  const req = context.request;\n\n  function mustChangePassword() {\n    // TODO: implement function\n    return true;\n  }\n\n  if (mustChangePassword()) {\n    // User has initiated a login and is forced to change their password\n    // Send user's information and query params in a JWT to avoid tampering\n    function createToken(clientId, clientSecret, issuer, user) {\n      const options = {\n        expiresInMinutes: 5,\n        audience: clientId,\n        issuer: issuer\n      };\n      return jwt.sign(user, clientSecret, options);\n    }\n\n    const token = createToken(\n      configuration.CLIENT_ID,\n      configuration.CLIENT_SECRET,\n      configuration.ISSUER,\n      {\n        sub: user.user_id,\n        email: user.email,\n        authorize_again: url.format({\n          protocol: 'https',\n          hostname: auth0.com,\n          pathname: '/authorize',\n          query: req.query\n        })\n      }\n    );\n\n    context.redirect = {\n      url: `https://example.com/change-pw?token=${token}`\n    };\n  }\n\n  return callback(null, user, context);\n}\n```\n\n## Where to store data\n\nBeware of storing too much data in the Auth0 profile. This data is intended to be used for authentication and authorization purposes. The metadata and search capabilities of Auth0 are not designed for marketing research or anything else that requires heavy search or update frequency. Your system is likely to run into scalability and performance issues if you use Auth0 for this purpose. A better approach is to store data in an external system and store a pointer (the user ID) in Auth0 so that backend systems can fetch the data if needed. A simple rule to follow is to store only items that you plan to use in rules to add to tokens or make decisions.\n\n## Security considerations\n\nPassing information back and forth in the front channel opens up surface area for bad actors to attack. This should definitely be done only in conditions where you must take action in the rule (such as rejecting the authorization attempt with `UnauthorizedError`).\n\nIf, however, you need to communicate directly back to Auth0 and give it instructions for restricting access (you are implementing CAPTCHA checks or custom MFA), then you must have a way to securely tell Auth0 that the requirements of that operation were performed. Likewise, if you need to hand information to the application that you are redirecting to, then you must have a secure way to ensure that the information transferred has not been tampered with.\n\n### Ensure app is logging into the same user\n\nThe application is going to redirect the user back to the Auth0 tenant, so any data related to the user can be gathered through the ID token that is returned to the application. However, you may want to ensure that the application is logging into the same user that is being redirected from to ensure that there is no tampering of any sort in-between. Therefore you will likely want to send a token along with the request.\n\nThe token sent to the app should have the following requirements:\n\n| Token Element | Description |\n| --- | --- |\n| `sub` | The Auth0 `user_id` of the user. |\n| `iss` | An identifier that identifies the rule itself. |\n| `aud` | The application that is targeted for the redirect. |\n| `jti` | A randomly generated string that is stored for confirmation in the user object (in the rule code, set user.jti = uuid.v4(); and then add it as a jti to the token you create). user.jti will still be set when rules run again when /continue is called. This is inline with specifications. |\n| `exp` | Should be as short as possible to avoid re-use of the token. |\n| `other` | Any other custom claims information you need to pass. |\n| `signature` | Assuming that the application has a secure place to store a secret, you can use HS256 signed signatures. This greatly reduces the complexity of the solution and since the token being passed back will have to be signed as well, this is a requirement of this solution. You can use RS256, but it requires the creating of a certificate and updating that certificate when it expires. If you are not passing any information directly back to the rules, then you could use an SPA for this intermediate app and then may prefer RS256 so that the application doesn't have to store the info. It would require you to have a way to validate the token, either through an introspection endpoint or through a public JWKS endpoint. |\n\n### Pass information back to the rule\n\nIn most scenarios, even if you want to pass information from the rule to the application. The application will hopefully be able to safely store the information in whatever storage is necessary. Even if the idea is to update the app or user metadata in Auth0, that can be done using the management API and the user information will be updated as long as it has been completed before redirecting the user back to the `/continue` endpoint. Only if the rule itself must get information and that information is only relevant to this particular sign in session should you pass information back to the rule.\n\nWhen passing information back to the `/continue` endpoint, the token passed should have the following requirements:\n\n| Token Element | Description |\n| --- | --- |\n| `sub` | The Auth0 `user_id` of the user. |\n| `iss` | The application that is targeted for the redirect. |\n| `aud` | Some identifier that identifies the rule itself. |\n| `jti` | The same JTI that was stored in the token passed to the application (NOTE: it should match user.jti or fail). |\n| `exp` | Should be as short as possible to avoid reuse of the token. |\n| `other` | Any other custom claims information you need to pass. |\n| `signature` | Assuming that the application has a secure place to store a secret, you can use HS256 signed signatures. This greatly reduces the complexity of the solution and since the token being passed back will have to be signed as well, this is a requirement of this solution. You can use RS256, but it requires the creating of a certificate and updating that certificate when it expires. |\n\nIt should be sent using POST and then fetched at `context.request.body.token` (or something similar) rather than passing it as a query parameter. This is similar to the form-post method for authentication.\n\nIf you are not passing information back to the `/continue` endpoint, you may want to denylist the JTI unless your expiration times are short enough that replay attacks will be almost impossible.\n\n## Restrictions and limitations\n\nRedirect Rules won't work with:\n\n*   [Resource Owner endpoint](https://auth0.com/docs/api/authentication/reference#resource-owner)\n    \n*   [Password exchange](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n    \n*   [Refresh Token exchange](https://auth0.com/docs/secure/tokens/refresh-tokens)\n    \n\nYou can detect the above cases by checking `context.protocol`:\n\n*   For Password exchange: `context.protocol === 'oauth2-password'`\n    \n*   For Refresh Token exchange: `context.protocol === 'oauth2-refresh-token'`\n    \n*   For Resource Owner logins: `context.protocol === 'oauth2-resource-owner'`\n    \n\n### Session timeout\n\nRedirect rule sessions are normally valid for 3 days unless you have configured a shorter timeout in your **Login Session Management** settings. You can find these settings in your [tenant's advanced settings](https://manage.auth0.com/#/tenant/advanced).\n\n### Resource Owner endpoint\n\nIt is impossible to use redirect rules in the context where you are calling `/oauth/token` directly for the Resource Owner Password Grant. Since the user is not in a redirect flow to begin with, you can not redirect the user in a rule. If you attempt to set context.redirect you will get a failed login attempt with the error interaction\\_required.\n\n### Flows where prompt=none\n\nSince the goal of `prompt=none` is to avoid any scenario where the user will be required to enter input, any redirection will result in an `error=interaction_required`.\n\nSince rules run after an authentication session is created, you cannot use `prompt=none` if you have a redirect rule that is attempting to block access to tokens under certain conditions (custom MFA, CAPTCHA with login, etc.).\n\nYou cannot create a redirect flow that blocks token access and bypasses the redirect rule if `prompt=none` because after a failed attempt, a user can simply call again with `prompt=none` and get tokens because their authentication session has been created even though rules failed the first time.\n\n### Refresh tokens\n\nDue to the fact that using a refresh token requires a backchannel call to `/oauth/token`, this will also fail if you set `context.redirect`.\n\nIt is difficult to securely verify that any restrictions on login were carried out. There is not a consistent session ID in the context that could be used to collect information associated with the session such as this user passed MFA challenges. Therefore, you cannot use `prompt=none` at all.\n\nAnytime `context.redirect` is set in a rule, if `prompt=none` was passed, then the authorization fails with `error=interaction_required`, but since the user's session is created even if rules fail, we can't trust that a user passed all `context.redirect` challenges and therefore can't use `prompt=none` as a way to get tokens.\n\nIn this specific case, we recommend that you use refresh tokens exclusively, because you can ensure that a user passed challenges if those challenges are required to generate a refresh token.\n\n## Learn more\n\n*   [Redirect Users](https://auth0.com/docs/authenticate/login/redirect-users-after-login)\n*   [Understand How Progressive Profiling Works](https://auth0.com/docs/manage-users/user-accounts/user-profiles/progressive-profiling)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)",
  "title": "Redirect Users from Within Rules",
  "description": "Learn how to customize authentication flows by redirecting users using rules. Example areas that can be customized include MFA, privacy policy acceptance, and gathering user data.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/cache-resources",
  "markdown": "# Cache Expensive Resources in Rules\n\nIn Rules you can store expensive resources using the `global` object. The `global` object survives individual execution, so you can reuse things stored there instead of creating them every time a Rule is run. However, the Rules environment can be recycled at any time so your code **must** always check that `global` contains what you expect.\n\nThis example shows how to use the `global` object to keep a [](https://www.mongodb.com/)MongoDB connection:\n\n```\n//If the db object is there, use it.\nif (global.db){\n  return query(global.db, callback);\n}\n\n//If not, get the db (mongodb in this case)\nmongo('mongodb://user:pass@mymongoserver.com/my-db',  function (db){\n  global.db = db;\n  return query(db, callback);\n});\n\n//Do the actual work\nfunction query(db, cb){\n  // Do something with db\n  ...\n  return cb(null, user, context);\n}\n```\n\nTo learn more about using MongoDB, read [the MongoDB Manual](https://docs.mongodb.com/manual/).",
  "title": "Cache Expensive Resources in Rules",
  "description": "How to cache expensive resources in your Rules code.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/debug-rules",
  "markdown": "# Debug Rules\n\nTo debug any [Auth0 Rule](https://auth0.com/docs/rules) you have created, you can use `console.log` from within your rule code. You can see `console.log` output by using the [](#try-this-rule)**Save and Try**, viewing the logs available with the [Real-time Webtask Logs extension](#real-time-logs-extension), or for legacy clients, using the [Debug Rule CLI](#debug-rule-cli).\n\n![Dashboard - Auth Pipeline - Rules - Edit Rule](https://images.ctfassets.net/cdy7uua7fh8z/5CoC6cnazv2uT1iSq6OGsm/6cb30d9479971be771313da80acc4802/Dashboard_-_Auth_Pipeline_-_Rules_-_Edit_Rule.png)\n\n## Try this Rule\n\nIn the [Rules Editor](https://manage.auth0.com/#/rules/create), the **Save and Try** button lets you run a Rule in isolation with mock **user** and **context** objects. Clicking **TRY** will run the Rule with those two objects as input and will display any `console.log` output.\n\nThe **Try this rule script** feature functions outside a specific client context. When using this feature, you may run into issues if your Rule depends on data that would be provided when called from an actual application.\n\n![Auth0 Pipeline - Rules - Try this rule](https://images.ctfassets.net/cdy7uua7fh8z/4scLIFzI1isvJZ9UI6mHfR/eceb674d3a53ecbab1bd9835a5194012/Auth_Pipeline_-_Rules_-_Try.png)\n\n## Real-time logs extension\n\nThe [](https://auth0.com/docs/extensions/realtime-webtask-logs)Real-time Webtask Logs extension displays all logs in real-time for all custom code in your account, which includes all `console.log` output and exceptions. To learn more, read [Real-time Webtask Logs](https://auth0.com/docs/extensions/realtime-webtask-logs).\n\n## Debug Rule CLI\n\nIn the [Rules Editor](https://manage.auth0.com/#/rules/create), the **Save and Debug** option displays instructions for installing, configuring, and running the [webtask CLI](https://github.com/auth0/wt-cli) for debugging Rules. Paste these commands into a terminal to see the `console.log` output and any unhandled exceptions that occur during Rule execution.\n\nFor example:\n\n```\n~  npm install -g wt-cli\n  ~  wt init --container \"youraccount\" --url \"https://sandbox.it.auth0.com\" --token \"eyJhbGci...WMPGI\" -p \"youraccount-default-logs\"\n  ~  wt logs -p \"youraccount-default-logs\"\n  [18:45:38.179Z]  INFO wt: connected to streaming logs (container=youraccount)\n  [18:47:37.954Z]  INFO wt: webtask container assigned\n  [18:47:38.167Z]  INFO wt: ---- checking email_verified for some-user@mail.com! ----\n```\n\nThis debugging method works for Rules tried from the Dashboard and for those actually running during user authentication.",
  "title": "Debug Rules",
  "description": "Learn how to debug your Auth0 rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/context-object",
  "markdown": "# Context Object Properties in Rules\n\nThe `context` object stores contextual information about the current authentication transaction, such as the user's IP address, application, or location.\n\nIf you change token content using the context object within a rule, your changes will be available in tokens after all rules have finished running. If your application also requires multifactor authentication or user consent, the user will be prompted before changes in the token are available.\n\n## Properties\n\nThe following properties are available for the `context` object.\n\n| Property | Description |\n| --- | --- |\n| `context.tenant` | A string containing the name of the tenant. |\n| `context.clientID` | The client id of the application the user is logging in to. |\n| `context.clientName` | The name of the application (as defined on the dashboard). |\n| `context.clientMetadata` | An object for holding other application properties. Its keys and values are strings. |\n| `context.connectionID` | A string containing the connection's unique identifier. |\n| `context.connection` | The name of the connection used to authenticate the user (such as: `twitter` or `some-g-suite-domain`) |\n| `context.connectionStrategy` | The type of connection. For social connection `connectionStrategy` === `connection`. For enterprise connections, the strategy will be `waad` (Windows Azure AD), `ad` (Active Directory/LDAP), `auth0` (database connections), and so on. |\n| `context.connectionOptions` | An object representing the options defined on the connection. `connectionOptions.tenant_domain` is a string containing the domain being used for authentication when using an Enterprise connection.  <br>`connectionOptions.domain_aliases` is an array containing the optional domains registered as aliases in addition to the primary domain (specified in the `connectionOptions.tenant_domain` property). |\n| `context.connectionMetadata` | An object representing metadata defined on the connection. Its keys and values are strings. |\n| `context.samlConfiguration` | An object that controls the behavior of the SAML and WS-Fed endpoints. Useful for advanced claims mapping and token enrichment (only available for `samlp` and `wsfed` protocol). |\n| `context.protocol` | The authentication protocol. Possible values:<br><br>*   `oidc-basic-profile`: most used, web-based login<br>*   `oidc-implicit-profile`: used on mobile devices and single-page apps<br>*   `oauth2-device-code`: transaction using the [Device Authorization Flow](https://auth0.com/docs/authorization/flows/device-authorization-flow)<br>*   `oauth2-resource-owner`: user/password login typically used on database connections<br>*   `oauth2-resource-owner-jwt-bearer`: login using a bearer JWT signed with user's private key<br>*   `oauth2-password`: login using the password exchange<br>*   `oauth2-refresh-token`: refreshing a token using the Refresh Token exchange<br>*   `samlp`: SAML protocol used on SaaS apps<br>*   `wsfed`: WS-Federation used on Microsoft products like Office365<br>*   `wstrust-usernamemixed`: WS-trust user/password login used on CRM and Office365<br>*   `delegation`: when calling the [Delegation endpoint](https://auth0.com/docs/api/authentication#delegation)<br>*   `redirect-callback`: when a redirect rule is resumed |\n| `context.riskAssessment` | An object containing specific scores (low, medium, high, neutral) for high risk login attempt assessors. See [Customize Adaptive MFA with Rules](https://auth0.com/docs/login/mfa/adaptive-mfa/adaptive-mfa-rule-actions). |\n| `context.stats` | An object containing specific user stats, like `stats.loginsCount`. Note that any of the counter variables returned as part of the `stats` object do not increase during [silent authentication](https://auth0.com/docs/login/configure-silent-authentication) (as when `prompt=none`). There are also scenarios where the counter variables might increase yet a rule or set of rules do not execute, as in the case of a successful cross-origin authentication followed by a failed token request. |\n| `context.sso` | This object will contain information about the Single Sign-on (SSO) transaction (if available)<br><br>*   `with_auth0`: when a user signs in with SSO to an application where the `Use Auth0 instead of the IdP to do Single Sign-On` setting is enabled (only for legacy tenants).<br>*   `with_dbconn`: an SSO login for a user that logged in through a database connection.<br>*   `current_clients`: client IDs using SSO. |\n| `context.accessToken` | An object representing the options defined on the Access Token. You can use this object to [add custom namespaced claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims#add-custom-claims-to-a-token) to the Access Token. `context.accessToken.scope` can be used to [change the Access Token's returned scopes](https://auth0.com/docs/rules/examples#modify-scope-of-access-token). When provided, it is an array containing permissions in string format. Custom claims will be included in the Access Token after all rules have run. |\n| `context.idToken` | An object representing the options defined on the [ID Token](https://auth0.com/docs/security/tokens/id-tokens). Used to add custom [namespaced](https://auth0.com/docs/security/tokens/json-web-tokens/create-namespaced-custom-claims) claims to the ID Token. Custom claims will be included in the ID Token after all rules have run. |\n| `context.multifactor` | An object representing the multifactor settings used in [implementing contextual MFA](https://auth0.com/docs/mfa). |\n| `context.redirect` | The object used to [implement the redirection of a user from a rule](https://auth0.com/docs/rules/redirect-users#how-to-implement-a-redirect). |\n| `context.sessionID` | An internal identification for the authentication session. Value is kept only if `prompt=none` is used in the authorization request. Note that the session ID can change **after** rule execution on other flows, so the value available in `context.sessionID` might not match the new session ID that the user will receive. This makes this value only meaningful when `prompt=none` is used. |\n| `context.request` | An object containing useful information of the request. This can also be set to `undefined`. It has the following properties:<br><br>*   `userAgent`: the user-agent of the application that is trying to log in.<br>*   `ip`: the originating IP address of the user trying to log in. We expose IPv6 addresses in our public endpoints (e.g., travel0.us.auth0.com). If a request arrives from a machine that supports IPv6, then this will contain an IPv6 address. If you perform manual IP address manipulation, we suggest you use the [ipaddr.js@1.9.0 library](https://www.npmjs.com/package/ipaddr.js/v/1.9.0).<br>*   `hostname`: the hostname that is being used for the authentication flow.<br>*   `query`: an object containing the querystring properties of the login transaction sent by the application.<br>*   `body`: the body of the POST request on login transactions used on `oauth2-resource-owner`, `oauth2-resource-owner-jwt-bearer` or `wstrust-usernamemixed` protocols.<br>*   `geoip`: an object containing geographic IP information. It has the following properties:<br>    *   `country_code`: a two-character code for the country associated with the IP address.<br>    *   `country_code3`: a three-character code for the country associated with the IP address.<br>    *   `country_name`: the country name associated with the IP address.<br>    *   `city_name`: the city or town name associated with the IP address.<br>    *   `latitude`: the latitude associated with the IP address.<br>    *   `longitude`: the longitude associated with the IP address.<br>    *   `time_zone`: the timezone associated with the IP address.<br>    *   `continent_code`: a two-character code for the continent associated with the IP address.<br>    *   `subdivision_code`: the ISO 3166-2 code for the top-level subdivision/region.<br>    *   `subdivision_name`: The English name of this subdivision/region. |\n| `context.primaryUser` | The unique user id of the primary account for the user. Used to [link user accounts](https://auth0.com/docs/users/user-account-linking#automatic-account-linking) from various identity providers. |\n| `context.authentication` | An object containing information related to the authentication transaction with the following properties:<br><br>`methods`: an array of objects containing the authentication methods a user has completed during their session. For example, a user that has completed a password-based authentication followed by MFA may have the following methods:<br><br>```<br>[<br>  {<br>    \"name\": \"pwd\",<br>    \"timestamp\": 1434454643024<br>  },<br>  {<br>    \"name\": \"mfa\",<br>    \"timestamp\": 1534454643881<br>  }<br>]<br>```<br><br>Was this helpful?<br><br>/<br><br>  <br>The method objects will contain the following properties:<br><br>*   `name`: a string representing the name of the authentication method that has been completed. It can be one of the following values (additional values may be supported in the future):  <br>    *   `federated`: a social or enterprise connection was used to authenticate the user<br>    *   `pwd`: a database connection was used to authenticate the user<br>    *   `sms`: a Passwordless SMS connection was used to authenticate the user<br>    *   `email`: a Passwordless Email connection was used to authenticate the user<br>    *   `mfa`: the user completed a multi-factor authentication<br>*   `timestamp`: an integer indicating the time in seconds at which the authentication method took place in Unix Epoch time<br><br>You can see a sample use case of the `context.authentication.methods` property in the [Require MFA once per session Rule](https://github.com/auth0/rules/blob/master/src/rules/require-mfa-once-per-session.js). |\n| `context.authorization` | An object containing information related to the authorization transaction with the following properties:<br><br>*   `roles`: an array of strings containing the names of a user's assigned roles. You can see a sample use case using the `context.authorization.roles` property to add roles to tokens in [Sample Use Cases: Rules with Authorization](https://auth0.com/docs/authorization/authorization-policies/sample-use-cases-rules-with-authorization#add-user-roles-to-tokens). |\n| `context.organization` | Object containing information related to the organization. Includes the following properties:<br><br>*   `id`: String containing the ID of the organization with which the user is logging in.<br>*   `name`: String containing the name of the organization (as defined in the Auth0 Dashboard).<br>*   `metadata`: Dictionary of string key/value pairs containing other organization properties. |\n\n## Learn more\n\n*   [Debug Rules](https://auth0.com/docs/customize/rules/debug-rules)\n*   [User Object Properties in Rules](https://auth0.com/docs/customize/rules/user-object-in-rules)\n*   [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims)",
  "title": "Context Object Properties in Rules",
  "description": "Learn about the properties of the Rules context object, which stores information about users' IP addresses, applications, and location.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/user-object-in-rules",
  "markdown": "# User Object Properties in Rules\n\nThe `user` object stores information about the logged-in user, returned by the identity provider. It is generated when a user authenticates and before rules run. Because of the order of events when a user authenticates, changes made to a user's profile from within a rule will only be available in the current user object if you also save the changes to the user object from within the same rule.\n\nTo learn more about the authentication transaction flow, read the \"How rules work\" section in [Create Rules](https://auth0.com/docs/customize/rules/create-rules).\n\n## Properties\n\nThe following properties are available for the `user` object.\n\n| Property | Data Type | Description |\n| --- | --- | --- |\n| `user.app_metadata` | object | Custom fields that store info about a user that influences the user's access, such as support plan, security roles, or access control groups. Is \\`undefined\\` by default. For more info, see [Metadata](https://auth0.com/docs/users/metadata). |\n| `user.created_at` | date time | Timestamp indicating when the user profile was first created. |\n| `user.email` | text | (unique) User's email address. |\n| `user.email_verified` | boolean | Indicates whether the user has verified their email address. |\n| `user.family_name` | text | User's family name. |\n| `user.given_name` | text | User's given name. |\n| `user.identities` | array (object) | Contains info retrieved from the identity provider with which the user originally authenticates. Users may also [link their profile to multiple identity providers](https://auth0.com/docs/users/user-account-linking); those identities will then also appear in this array. The contents of an individual identity provider object varies by provider, but it will typically include the following:<br><br>*   `connection` (text): Name of the Auth0 connection used to authenticate the user.<br>*   `isSocial` (boolean): Indicates whether the connection is a social one.<br>*   `provider` (text): Name of the entity that is authenticating the user, such as Facebook, Google, SAML, or your own provider.<br>*   `user_id` (text): User's unique identifier for this connection/provider. The first user\\_id linked becomes the primary unique identifier for the user.<br>*   `profileData` (object): User information associated with the connection. When profiles are linked, it is populated with the associated user info for secondary accounts.<br><br>In some cases, it will also include an API Access Token to be used with the provider. |\n| `user.last_password_reset` | date time | Timestamp indicating the last time the user's password was reset/changed. At user creation, this field does not exist. This property is only available for Database connections. |\n| `user.multifactor` | array (text) | List of multi-factor authentication (MFA) providers with which the user is enrolled. This array is updated when the user enrolls in MFA and when an administrator resets a user's MFA enrollments. |\n| `user.name` | text | User's full name. |\n| `user.nickname` | text | User's nickname. |\n| `user.permissions` | text | Permissions assigned to the user's ID token if using the Authorization Extension. |\n| `user.phone_number` | text | User's phone number. Only valid for users with SMS connections. |\n| `user.phone_verified` | boolean | Indicates whether the user has verified their phone number. Only valid for users with SMS connections. |\n| `user.picture` | text | URL pointing to [the user's profile picture](https://auth0.com/docs/users/change-user-picture). |\n| `user.updated_at` | date time | Timestamp indicating when the user's profile was last updated/modified. Changes to `last_login` are considered updates, so most of the time, `updated_at` will match `last_login`. |\n| `user.user_id` | text | (unique) User's primary unique identifier. |\n| `user.user_metadata` | object | Custom fields that store info about a user that does not impact what they can or cannot access, such as work address, home address, or user preferences. For more info, see [Metadata](https://auth0.com/docs/users/metadata). |\n| `user.username` | text | (unique) User's username. |",
  "title": "User Object Properties in Rules",
  "description": "Describes the properties of the user object that stores information about the logged in user, returned by the identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules/raise-errors-from-rules",
  "markdown": "# Raise Errors from Rules\n\nThe Auth0 login page can’t display an error message from a rule. If you want users to see a custom message raised from a rule, your app must display that message.\n\nAny error resulting from a rule goes to your callback URL in the protocol’s standard response mode. For example, if your application requests authentication using OIDC/OAuth2, it receives a standard OAuth2 error with `error` and `error_description` result values.\n\nSuppose your callback URL is https://travel0.com/callback and you’re using the standard query response mode. You would receive this response:\n\n```\nhttps://travel0.com/callback?error=access_denied&error_description=[The message you wrote in the rule]\n```\n\nIt’s the role of your app to display the message to the user, such as:\n\n![Sample error message that reads ](https://images.ctfassets.net/cdy7uua7fh8z/7wBM0h29mAwFFbmeOVwVnR/e0ec360ad403d6cdf2f2ac701c621216/rules-login-error-from-rules.png)\n\n## Retry login after a rule error\n\nA likely next step is to request a new authorization. However, in most cases, Auth0 already knows who the user is and so doesn’t ask for login information. Instead, rules run immediately and the rule denies authorization again. This can become an endless loop.\n\nThe user needs an opportunity to provide new credentials. There are two ways your app can make the login page display again:\n\n*   Add a directive in the request to force the display of the login page:\n    \n    *   Use a `prompt=login` parameter to an OIDC/OAuth2 request.\n        \n    *   Use a `ForceAuthn=\"true\"` attribute in a SAML request.\n        \n\n—or—\n\n*   Log the user out of Auth0 before you send a new request.\n    \n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Rule Use Cases](https://auth0.com/docs/rules/use-cases)",
  "title": "Raise Errors from Rules",
  "description": "The Auth0 login page can’t display an error message from a rule. Learn what to do instead.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks/create-hooks",
  "markdown": "# Create Hooks\n\nYou can create multiple hooks using the Dashboard or Management API.\n\nYou can also import and export hooks using the Deploy Command-Line Interface (CLI) tool.\n\n## Use the Dashboard\n\n1.  Go to [Auth0 Dashboard > Auth Pipeline > Hooks](https://manage.auth0.com/#/hooks), and click **+Create**.\n    \n2.  Enter a descriptive name for your hook, select the extensibility point for which the hook should execute, and click **Create**.\n    \n3.  Locate the section for the extensibility point you selected, and click the pencil icon next to the hook you created.\n    \n4.  Update the hook using the Hook Editor, and click the disk icon to save.\n    \n\n## Use the Management API\n\nMake a `POST` call to the [Create a Hook endpoint](https://auth0.com/docs/api/management/v2/#!/Hooks/post_hooks). Be sure to replace `MGMT_API_ACCESS_TOKEN`, `HOOK_NAME`, `HOOK_SCRIPT`, and `EXTENSIBILITY_POINT_NAME` placeholder values with your Management API access token, Hook name, Hook script, and extensibility point name, respectively.\n\n*   [cURL](#a62c135e7e564294b15e54d0b3f242da_shell)\n*   [C#](#a62c135e7e564294b15e54d0b3f242da_csharp)\n*   [Go](#a62c135e7e564294b15e54d0b3f242da_go)\n*   [Java](#a62c135e7e564294b15e54d0b3f242da_java)\n*   [Node.JS](#a62c135e7e564294b15e54d0b3f242da_node)\n*   [Obj-C](#a62c135e7e564294b15e54d0b3f242da_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/hooks' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"name\": \"HOOK_NAME\", \"script\": \"HOOK_SCRIPT\", \"triggerId\": \"EXTENSIBILITY_POINT_NAME\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/hooks\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"triggerId\\\": \\\"EXTENSIBILITY_POINT_NAME\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/hooks\"\n\n\tpayload := strings.NewReader(\"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"triggerId\\\": \\\"EXTENSIBILITY_POINT_NAME\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/hooks\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"triggerId\\\": \\\"EXTENSIBILITY_POINT_NAME\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/hooks',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    name: 'HOOK_NAME',\n    script: 'HOOK_SCRIPT',\n    triggerId: 'EXTENSIBILITY_POINT_NAME'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"name\": @\"HOOK_NAME\",\n                              @\"script\": @\"HOOK_SCRIPT\",\n                              @\"triggerId\": @\"EXTENSIBILITY_POINT_NAME\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/hooks\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/hooks\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"triggerId\\\": \\\"EXTENSIBILITY_POINT_NAME\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"triggerId\\\": \\\"EXTENSIBILITY_POINT_NAME\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/hooks\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/hooks\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"triggerId\\\": \\\"EXTENSIBILITY_POINT_NAME\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"name\": \"HOOK_NAME\",\n  \"script\": \"HOOK_SCRIPT\",\n  \"triggerId\": \"EXTENSIBILITY_POINT_NAME\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/hooks\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| **Value** | **Description** |\n| --- | --- |\n| `MGMT_API_ACCESS_TOKEN` | Access Token for the Management API with the scope `create:hooks`. To learn more, read [Management API Access Tokens](https://auth0.com/docs/api/management/v2/tokens). |\n| `HOOK_NAME` | Name of the Hook to create. |\n| `HOOK_SCRIPT` | Script that contains the code for the Hook. Should match what you would enter if you were creating a new Hook using the Dashboard. |\n| `EXTENSIBILITY_POINT_NAME` | Name of the extensibility point for which the Hook should execute. Options include: `credentials-exchange`, `pre-user-registration`, `post-user-registration`, `post-change-password`. To learn more about extensibility points, read [Extensibiity Points](https://auth0.com/docs/hooks/extensibility-points). |\n\n#### Handle rate limits when calling APIs from within Hooks\n\nIf you call Auth0 APIs from within a Hook's script, you will need to handle rate limits. To do so, check the `X-RateLimit-Remaining` header and act appropriately when the number returned nears 0.\n\nAdditionally, add logic to handle cases in which you exceed the provided rate limits and receive the `429` HTTP Status Code (`Too Many Requests`). In this case, if a re-try is needed, it is best to allow for a back-off to avoid going into an infinite retry loop.\n\nTo learn more about Auth0 rate limiting for Hooks, read Rate Limits.\n\n## Learn more\n\n*   [Migrate from Hooks to Actions](https://auth0.com/docs/customize/actions/migrate/migrate-from-hooks-to-actions)",
  "title": "Create Hooks",
  "description": "Learn how to create Hooks using the Dashboard and Management API. Hooks may also be imported and exported using the Auth0 Deploy Command-Line Interface (CLI) tool.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks/update-hooks",
  "markdown": "# Update Hooks\n\nYou can update Hooks using the Dashboard or Management API.\n\nYou can also import and export hooks using the [Deploy Command-Line Interface (CLI) tool](https://auth0.com/docs/deploy-monitor/deploy-cli-tool).\n\n## Rename hooks using the Dashboard\n\n1.  Go to [Auth0 Dashboard > Auth Pipeline > Hooks](https://manage.auth0.com/#/) and click the gear icon next to the hook you want to rename.\n    \n2.  Click **Rename**.\n    \n3.  Type a new name for the Hook and click **Rename**.\n    \n    ![Auth0 Rename Hooks](https://images.ctfassets.net/cdy7uua7fh8z/2Xp8Z3uYGoGZrF5EGXLPLQ/6c68c77f97133b2066219a68540b1e73/Screen_Shot_2021-05-19_at_12.08.00_PM.png)\n\n## Update hook scripts using the Dashboard\n\n1.  Go to [Auth0 Dashboard > Auth Pipeline > Hooks](https://manage.auth0.com/#/) and click the pencil icon next to the hook you want to update.\n    \n    ![Auth0 Hooks select a Hook](https://images.ctfassets.net/cdy7uua7fh8z/2y2R713TkAvQWIMZPMd1zh/bf0a657261f2d090492660ea5962e0a3/dashboard-hooks-list.png)\n2.  Update the hook using the Hook Editor and click the disk icon to save.\n    \n    ![Auth0 Hook Editor](https://images.ctfassets.net/cdy7uua7fh8z/26u71QdXxZxg5zIH8SJQAg/e9bbd25b99d9b8fd44c281b6de83a5a3/dashboard-hooks-edit_menu.png)\n\n## Update hooks using the Management API\n\nMake a `PATCH` call to the [Update a Hook endpoint](https://auth0.com/docs/api/management/v2/#!/Hooks/patch_hooks_by_id). Be sure to replace `HOOK_ID` and `MGMT_API_ACCESS_TOKEN` placeholder values with your Hook ID and Management API Access Token, respectively.\n\n*   [cURL](#89a36c7e6c8844bdae983d5ce9999654_shell)\n*   [C#](#89a36c7e6c8844bdae983d5ce9999654_csharp)\n*   [Go](#89a36c7e6c8844bdae983d5ce9999654_go)\n*   [Java](#89a36c7e6c8844bdae983d5ce9999654_java)\n*   [Node.JS](#89a36c7e6c8844bdae983d5ce9999654_node)\n*   [Obj-C](#89a36c7e6c8844bdae983d5ce9999654_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/hooks/HOOK_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"name\": \"HOOK_NAME\", \"script\": \"HOOK_SCRIPT\", \"enabled\": \"true\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/hooks/HOOK_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"enabled\\\": \\\"true\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/hooks/HOOK_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"enabled\\\": \\\"true\\\" }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/hooks/HOOK_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"enabled\\\": \\\"true\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/hooks/HOOK_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {name: 'HOOK_NAME', script: 'HOOK_SCRIPT', enabled: 'true'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"name\": @\"HOOK_NAME\",\n                              @\"script\": @\"HOOK_SCRIPT\",\n                              @\"enabled\": @\"true\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/hooks/HOOK_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/hooks/HOOK_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"enabled\\\": \\\"true\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"enabled\\\": \\\"true\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/hooks/HOOK_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/hooks/HOOK_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"name\\\": \\\"HOOK_NAME\\\", \\\"script\\\": \\\"HOOK_SCRIPT\\\", \\\"enabled\\\": \\\"true\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"name\": \"HOOK_NAME\",\n  \"script\": \"HOOK_SCRIPT\",\n  \"enabled\": \"true\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/hooks/HOOK_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `HOOK_ID` | ID of the Hook to update. |\n| `MGMT_API_ACCESS_TOKEN` | Access Tokens for the Management API with the scope `update:hooks`. To learn more, read [Management API Access Tokens](https://auth0.com/docs/api/management/v2/tokens). |\n| `HOOK_NAME` | Name of the Hook to create. |\n| `HOOK_SCRIPT` | Script that contains the code for the Hook. Should match what you would enter if you were creating a new hook using the Dashboard. |\n\n#### Handle rate limits when calling APIs from within Hooks\n\nIf you call Auth0 APIs from within a Hook's script, you will need to handle rate limits. To do so, check the `X-RateLimit-Remaining` header and act appropriately when the number returned nears 0.\n\nAdditionally, add logic to handle cases in which you exceed the provided rate limits and receive the `429` HTTP Status Code (`Too Many Requests`). In this case, if a re-try is needed, it is best to allow for a back-off to avoid going into an infinite retry loop.",
  "title": "Update Hooks",
  "description": "Learn how to update Hooks using the Dashboard or Management API. Hooks may also be imported and exported using the Auth0 Deploy Command-Line Interface (CLI) tool.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks/view-logs-for-hooks",
  "markdown": "# View Logs for Hooks\n\nFrom the Dashboard, you can view real-time logging information for hooks (and also rules, actions, custom database scripts, and custom social connections).\n\n1.  Go to [Auth0 Dashboard > Auth Pipeline > Hooks](https://manage.auth0.com/#/) and select the pencil icon next to a Hook.\n    \n    ![Auth0 Hooks select a Hook](https://images.ctfassets.net/cdy7uua7fh8z/2y2R713TkAvQWIMZPMd1zh/bf0a657261f2d090492660ea5962e0a3/dashboard-hooks-list.png)\n2.  In the top right corner of the Hooks Editor, select the logs icon.\n    \n    ![Auth0 Hook Editor](https://images.ctfassets.net/cdy7uua7fh8z/26u71QdXxZxg5zIH8SJQAg/e9bbd25b99d9b8fd44c281b6de83a5a3/dashboard-hooks-edit_menu.png)",
  "title": "View Logs for Hooks",
  "description": "Learn how to view logs for hooks using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks/delete-hooks",
  "markdown": "# Delete Hooks\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/hooks/HOOK_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/hooks/HOOK_ID\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/hooks/HOOK_ID\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/hooks/HOOK_ID\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/hooks/HOOK_ID',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/hooks/HOOK_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/hooks/HOOK_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/hooks/HOOK_ID\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/hooks/HOOK_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/hooks/HOOK_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Delete Hooks",
  "description": "Learn how to delete Hooks using the Dashboard and Management API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks/view-hooks",
  "markdown": "# View Hooks\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/hooks' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/hooks\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/hooks\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/hooks\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/hooks',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/hooks\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/hooks\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/hooks\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/hooks\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/hooks\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "View Hooks",
  "description": "Learn how to view hooks using the Dashboard and Management API. Hooks may also be imported and exported using the Auth0 Deploy Command-Line Interface (CLI) tool.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/hooks/enable-disable-hooks",
  "markdown": "# Enable/Disable Hooks\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/hooks/HOOK_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"enabled\": \"true\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/hooks/HOOK_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"enabled\\\": \\\"true\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/hooks/HOOK_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"enabled\\\": \\\"true\\\" }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/hooks/HOOK_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"enabled\\\": \\\"true\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/hooks/HOOK_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {enabled: 'true'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"enabled\": @\"true\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/hooks/HOOK_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/hooks/HOOK_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"enabled\\\": \\\"true\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"enabled\\\": \\\"true\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/hooks/HOOK_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/hooks/HOOK_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"enabled\\\": \\\"true\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"enabled\": \"true\"] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/hooks/HOOK_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Enable/Disable Hooks",
  "description": "Learn how to enable and disable hooks using the Dashboard  and Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/hooks/hook-secrets",
  "markdown": "# Hook Secrets\n\nHooks feature integrated secret management to securely store secrets while making them conveniently available in code.\n\n## Manage Hook Secrets\n\nYou can create, update, delete, and view Hook Secrets from the Dashboard or Management API. To learn more, read:\n\n*   [Create Hook Secrets](https://auth0.com/docs/customize/hooks/hook-secrets/create-hook-secrets)\n    \n*   [Update Hook Secrets](https://auth0.com/docs/customize/hooks/hook-secrets/update-hook-secrets)\n    \n*   [Delete Hook Secrets](https://auth0.com/docs/customize/hooks/hook-secrets/delete-hook-secrets)\n    \n*   [View Hook Secrets](https://auth0.com/docs/customize/hooks/hook-secrets/view-hook-secrets)\n    \n\nHook Secrets can also be imported or exported using the [Deploy Command-Line Interface (CLI) tool.](https://auth0.com/docs/deploy-monitor/deploy-cli-tool)\n\n## Learn more\n\n*   [Auth0 Hooks](https://auth0.com/docs/customize/hooks)",
  "title": "Hook Secrets",
  "description": "Learn about integrated secret management used with Auth0 Hooks.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/authorization-extension",
  "markdown": "# Authorization Extension\n\nThe Authorization Extension provides support for user authorization via Groups, Roles, and Permissions. You can define the expected behavior during the login process, and your configuration settings will be captured in a rule that's executed during runtime. To learn more, read [Auth0 Rules](https://auth0.com/docs/customize/rules).\n\nWith the Authorization Extension, you can store authorization data like groups, roles, or permissions in the outgoing token issued by Auth0. Your application can then consume this information by inspecting the token and take appropriate actions based on the user's current authorization context.\n\nWith the Authorization Extension, roles and permissions are set on a per-application basis. If you need the same roles or permissions on another application, you'll have to create them separately. Conversely, the [Authorization Core](https://auth0.com/docs/manage-users/access-control/rbac) feature set provides much more flexibility with roles and permissions.\n\n## Prerequisites\n\nBefore you can use the extension, you'll need to:\n\n1.  [Install](https://auth0.com/docs/customize/extensions/authorization-extension/install-authorization-extension) the extension.\n    \n2.  [Configure](https://auth0.com/docs/customize/extensions/authorization-extension/configure-authorization-extension) how the extension will behave during the login transaction.\n    \n3.  [Set up](https://auth0.com/docs/customize/extensions/authorization-extension/set-up-authorization-extension-users) users, groups, roles, and permissions.\n    \n\n## Manage data\n\nYou can easily move data into or out of the extension using a JSON file. To learn more, read [Import and Export Authorization Extension Data](https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data).\n\n## Add functionality\n\nOnce the extension is up and running, you can add additional functionality to it.\n\n*   [Enable API access to the extension](https://auth0.com/docs/customize/extensions/authorization-extension/enable-api-access-to-authorization-extension): Learn how you can automate provisioning and query the authorization context of your users in real-time, using the extension's API.\n    \n*   [Explore Authorization Extension API endpoints](https://auth0.com/docs/api/authorization-extension): Learn about the Authorization Extension's API endpoints and how you can use them.\n    \n*   [Use Authorization Extension data in rules](https://auth0.com/docs/customize/extensions/authorization-extension/use-rules-with-the-authorization-extension): Learn how you can use rules to configure extra logic for your logins.\n    \n\n## Troubleshoot\n\nReview our tips for [troubleshooting](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension) page for commonly-encountered issues.\n\n## Upgrade from previous versions\n\n### Upgrade from version 2.6 or later\n\nUpgrades from version 2.6 or later do not have breaking changes and require no special action.\n\n### Upgrade from versions before 2.6\n\nAuthorization Extension 2.6 contains breaking changes that result from changed logic for storing and handling the API Key; these require you to perform additional steps upon upgrade, as detailed below. Failing to complete these steps will result in either an `InvalidApiKey` or `You are not allowed to access this application` error on rule execution. For more information, see the [GitHub changelog](https://github.com/auth0/auth0-authorization-extension/blob/master/CHANGELOG.md).\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select the **Installed Extensions** view.\n    \n2.  Locate **Auth0 Authorization**, select **Upgrade**, and confirm. Wait for the upgrade to complete.\n    \n\n#### Rotate the extension's API key\n\n1.  Select **Auth0 Authorization** to open the extension.\n    \n2.  From the dropdown menu in the top-right of the extension dashboard, select **Configuration**.\n    \n3.  Locate the **API Key** section, and select **Rotate**.\n    \n\n#### Republish the extension's rule\n\nSelect **Publish Rule**.\n\n#### Delete the old extension rule if it exists\n\n1.  Go to [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules).\n    \n2.  Locate the `auth0-authz` rule. If it does not exist, you are done; otherwise, continue with the following steps.\n    \n3.  Locate the `auth0-authorization-extension` rule and drag it into the position below the `auth0-authz` rule.\n    \n4.  Check that the `auth0-authz` rule:\n    \n    *   Was authored by the Authorization Extension and has not been modified manually\n        \n    *   Will not change the authorization flow in a way that will grant access or privileges to undesired users if it is removed\n        \n5.  If the above conditions are true, use the toggle to disable the `auth0-authz` rule. After verifying that everything works appropriately, you can decide whether to leave the rule disabled or remove it entirely.\n    \n\n## Learn more\n\n*   [Install Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/install-authorization-extension)\n*   [Configure Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/configure-authorization-extension)\n*   [Enable API Access to Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/enable-api-access-to-authorization-extension)\n*   [Import and Export Authorization Extension Data](https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data)\n*   [Use Rules with the Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/use-rules-with-the-authorization-extension)\n*   [Troubleshoot Authorization Extension](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension)",
  "title": "Authorization Extension",
  "description": "Learn how to use the Authorization Extension to control user authorization behavior during runtime.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/real-time-webtask-logs",
  "markdown": "# Real-time Webtask Logs Extension\n\nThe Real-time Webtask Logs extension displays all logs in real-time for the custom code in your account. This includes all `console.log` output and exceptions. `Console.logs` are helpful if you have issues with database scripts. You can view the results from your database scripts such as success messages, error messages, and `console.log()` statements.\n\nTo learn more, see [Real-time Auth0 Webtask Logs](https://github.com/auth0/auth0-extension-realtime-logs) in Auth0's Github repository.\n\n## Configure the extension\n\nTo install and configure this extension:\n\n1.  Navigate to the [Extensions](https://manage.auth0.com/#/extensions) page of the [Auth0 Dashboard](https://manage.auth0.com/#), and click the **Real-time Webtask Logs** box. The **Install Extension** window opens.\n    \n    ![Dashboard - Extensions - Realtime Webtask Logs - Install](https://images.ctfassets.net/cdy7uua7fh8z/78UOfoBBDaFYdGY3RSkKlv/cf0f52a9563c1b888b0c7ed15155ed15/dashboard-extensions-real-time-webtask-logs-install.png)\n2.  Click the **Install** button.\n    \n\n## Use the extension\n\nTo view your logs:\n\n1.  Navigate to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **Installed Extensions**.\n    \n2.  Select **Real-time Webtask Logs**.\n    \n    ![Dashboard - Extensions - Realtime Webtask Logs - View Realtime Logs](https://images.ctfassets.net/cdy7uua7fh8z/5l2chLavwbt07werCJeRUw/1c9bec05ebf7977e5740e563e36b04c6/view-realtime-logs.png)\n\nTo view the logs in fullscreen mode, click **Full Screen Mode**. To exit fullscreen mode, press the **Escape** key.\n\nTo clear all logs, click **Clear Console**.\n\n## Debug rules\n\nYou can use the Real-time Webtask Logs extension to debug any Rules in your implementation, including all `console.log` output and exceptions. To learn more, read [Auth0 Rules](https://auth0.com/docs/customize/rules).\n\nIn the following example, you will create a generic Hello World rule, run it, and use the Real-time Webtask Logs extension to see the results.\n\n1.  Navigate to [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules), and select **Create Rule**.\n    \n2.  Select the **Empty rule** template, paste the code below (or modify it as you like), and **Save Changes**.\n    \n    ```\n    function (user, context, callback) {\n      user.hello = 'world';\n      console.log('===> set \"hello\" for ' + user.name);\n      callback(null, user, context);\n    }\n    ```\n    \n3.  Open a new tab, navigate to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **Installed Extensions**.\n    \n4.  Select **Real-time Webtask Logs**. You are now viewing logs real-time and are ready to try your rule.\n    \n5.  Switch to your Rules tab, and click **Try This Rule**.\n    \n6.  Switch to your Real-time Webtask Logs tab to see the results.\n    \n    ![Dashboard - Extensions - Realtime Webtask Logs - View Rules Example](https://images.ctfassets.net/cdy7uua7fh8z/qa2qa4s8rpR1Il0A9CejV/e07294e593e42f16f687b9d0a94e24fc/view-rules-example.png)\n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)",
  "title": "Real-time Webtask Logs Extension",
  "description": "Learn how to configure and use the Auth0 Real-time Webtask Logs extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension",
  "markdown": "# Single Sign-On Dashboard Extension\n\nThe Single Sign-on (SSO) Dashboard is a web application designed to solve a problem familiar to many people. Organizations of all sizes maintain a variety of different applications to handle various business functions like accounting, HR, development, support, etc. Remembering usernames and passwords and login URLs for all of your applications can be cumbersome. With this extension, you can simplify the authentication experience by enabling SSO login for your users on multiple enterprise applications. It allows you to create a list of all the cloud services for which a user can authenticate with SSO logins.\n\nThe SSO Dashboard supports two types of users:\n\n*   **Users** who can log in to the dashboard to select an application to sign into with SSO.\n    \n*   **Admins** who can configure applications visible to the users.\n    \n\nTo configure this extension, do the following:\n\n1.  [Create an SSO Dashboard Application](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application)\n    \n2.  [Install the SSO Dashboard extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension)\n    \n3.  [Add Applications to the SSO Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard)\n    \n4.  [Update Applications on the SSO Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/update-applications-on-the-sso-dashboard)\n    \n\nYou can also [view this SSO Dashboard Extension on GitHub](https://github.com/auth0-extensions/auth0-sso-dashboard-extension).\n\n## Learn more\n\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)\n*   [Sessions](https://auth0.com/docs/manage-users/sessions)\n*   [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on)\n*   [Enable Single Sign-On for Tenants](https://auth0.com/docs/get-started/tenant-settings/enable-sso-for-legacy-tenants)\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
  "title": "Single Sign-On Dashboard Extension",
  "description": "Learn how to use the SSO Dashboard Extension to manage single sign-on login for your users on multiple enterprise applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/delegated-administration-extension",
  "markdown": "# Delegated Administration Extension v3\n\nThe Delegated Administration Extension (DAE) allows you to grant administrative permissions to a select group of people without providing access to any other area.\n\n## Configure the DAE\n\nTo configure the DAE, you must:\n\n1.  [Register the application with Auth0](#register-the-application-with-auth0)\n    \n2.  [Create a database connection](#create-a-database-connection)\n    \n3.  [Disable all other connections for the Auth0 Application](#disable-all-other-connections-for-the-auth0-application)\n    \n4.  [Create users for database connection](#create-user-for-the-database-connection)\n    \n5.  [Assign roles to users](#assign-roles-to-users)\n    \n6.  [Install and configure the extension](#install-and-configure-the-extension)\n    \n7.  [Use the extension](#use-the-extension)\n    \n\n### Register the application with Auth0\n\nCreate the Application that the Delegated Administration Extension will expose to those who should have administrative privileges for the Users page. To do this, [create a delegated admin application](https://auth0.com/docs/customize/extensions/delegated-administration-extension/create-delegated-admin-applications) in Auth0.\n\nWhen finished, note the application's **Client ID**.\n\n### Create a database connection\n\nIn this example, a database connection will serve as the source of your users who are allowed access to the Users area. To configure this, [create a database connection](https://auth0.com/docs/get-started/applications/set-up-database-connections).\n\nWhile setting up your connection:\n\n*   Use a fitting connection name, such as `HelpDesk`.\n    \n*   Enable the **Disable Sign Ups** toggle. For security purposes, this ensures that even users who have the link to the database connection cannot sign themselves up.\n    \n\n### Disable all other connections for the Auth0 application\n\nBy default, Auth0 enables all connections associated with your tenant when you create a new Application. For this example, disable all connections other than your newly-created database connection. This helps keep the application secure because no one can add themselves using one of your existing connections.\n\nTo configure this, [update application connections](https://auth0.com/docs/get-started/applications/update-application-connections).\n\n### Create users for the database connection\n\nTo continue, you must [create at least one user](https://auth0.com/docs/manage-users/user-accounts/create-users) and attach it to your connection.\n\n### Assign roles to users\n\nAuth0 grants access to the Delegated Administration Extension (DAE) for the user(s) attached to your connection based on their roles. These are DAE-specific roles:\n\n| This role... | Grants permission to... |\n| --- | --- |\n| `Delegated Admin - User` | Search for users, create users, open users, and execute actions on users (such as delete or block). |\n| `Delegated Admin - Administrator` | Do everything that the Delegated Admin - User can, plus see all logs in the tenant and configure Hooks. |\n| `Delegated Admin - Auditor` | Search for users and view user information, but not make changes. Action-based buttons are not visible to this role. |\n| `Delegated Admin - Operator` | Access user management and logs, but not the extension configuration section. |\n\nWhen working with roles, we recommend that you use the [Authorization Core](https://auth0.com/docs/manage-users/access-control/rbac) feature set:\n\n1.  [Create DAE roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/create-roles). The names of the roles you create must match the names of the pre-defined DAE roles above.\n    \n2.  [Assign DAE roles to a user manually](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-roles-to-users).\n    \n3.  Add user roles to the DAE namespace in the ID Token using [Actions](https://auth0.com/docs/customize/actions)**:**\n    \n    ```\n    exports.onExecutePostLogin = async (event, api) => {\n      const namespace = `https://{yourTenant}/auth0-delegated-admin`;\n      if (event.client.client_id === 'CLIENT_ID' && event.authorization) {\n        api.idToken.setCustomClaim(namespace, { \"roles\": event.authorization.roles });\n      }\n    };\n    ```\n    \n\nRemember to replace the `CLIENT_ID` placeholder with your delegated admin application's **Client ID**.\n\nTo learn more about creating Actions, read [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action)\n\n## Install and configure the extension\n\nNow that we've created and configured an application, a connection, and our user, we can [install and configure the Delegated Admin Extension](https://auth0.com/docs/customize/extensions/delegated-administration-extension/install-delegated-admin-extension) itself.\n\n## Use the extension\n\nOnce installed, you are ready to use the Delegated Admin Extension.\n\nNavigate to the extension using the appropriate login link for your region and your tenant's extensibility runtime.\n\n| Location | Name | Login Link |\n| --- | --- | --- |\n| Australia | AU  | `https://{yourTenant}.au.webtask.io/auth0-delegated-admin` |\n| Europe | EU  | `https://{yourTenant}.eu.webtask.io/auth0-delegated-admin` |\n| Europe | EU-2 | `https://{yourTenant}.eu.webtask.run/auth0-delegated-admin` |\n| Japan | JP-1 | `https://{yourTenant}.jp.webtask.run/auth0-delegated-admin` |\n| UK  | UK  | `https://{yourTenant}.uk.webtask.run/auth0-delegated-admin` |\n| USA | US-1 | `https://{yourTenant}.us.webtask.io/auth0-delegated-admin` |\n| USA | US-3 | `https://{yourTenant}.us.webtask.run/auth0-delegated-admin` |\n\nA new tab opens, displaying the login prompt.\n\n![Extensions - Delegated Admin - Login prompt](https://images.ctfassets.net/cdy7uua7fh8z/3vMz5sulIjCU3BHCfQDJyE/1fd90600422c7d6ae4ca909f37db6784/login-prompt.png)\n\nBecause (in this example) we disabled signups for the database connection while configuring it, the login screen does not display a **Sign Up** option. Once you provide valid credentials, Auth0 directs you to your custom **Delegated Administration Dashboard** page, which has the **Title** you provided at the top of the page and (if you provided a custom CSS file), your design.\n\n![Extensions - Delegated Admin - Standard dashboard](https://images.ctfassets.net/cdy7uua7fh8z/3TqngvmqfsSSajsAzP3M9N/e44325f2d60b05769ed2c7c395c26f25/standard-dashboard.png)\n\n#### Delegated Administration session timeout\n\nBy default, token expiration time is 10 hours. However, for security reasons, when using Delegated Administration, Auth0 doesn't save a token to cookies or `sessionStorage`. You must start a new session on each page reload.\n\n## Learn more\n\n*   [Delegated Administration: Extension Hooks](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-hooks)\n*   [Delegated Administration: Manage Users](https://auth0.com/docs/customize/extensions/delegated-administration-extension/delegated-administration-manage-users)",
  "title": "Delegated Administration Extension v3",
  "description": "Learn how to use the Delegated Administration Extension (DAE) to expose the Users section of the Auth0 Dashboard to a select group of users without allowing them access to the rest of the Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/ad-ldap-connector-health-monitor",
  "markdown": "# Auth0 AD/LDAP Connector Health Monitor Extension\n\nThe Auth0 AD/LDAP Connector Health Monitor exposes an API endpoint of your choice so that you can monitor your AD/LDAP connectors.\n\n## Configure the extension\n\nTo install and configure this extension:\n\n1.  Navigate to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **Auth0 AD/LDAP Connector Health Monitor**. The **Install Extension** window opens.\n    \n2.  Set the following configuration parameters, and select **Install**:\n    \n\n*   **Auth0\\_Domain**: The domain for your Auth0 application, which you can find in your [Auth0 Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n    \n*   **Auth0\\_Global\\_Client\\_ID**: The Global Client ID for your Auth0 application, which you can find in the **Global Application Information** section of your [Tenant Advanced Settings](https://manage.auth0.com/#/tenant/advanced).\n    \n*   **Auth0\\_Global\\_Client\\_Secret**: The Global Client Secret for your Auth0 application, which you can find in the **Global Application Information** section of your [Tenant Advanced Settings](https://manage.auth0.com/#/tenant/advanced).\n    \n\n## Use the extension\n\nTo access the URL to use with your monitoring service:\n\n1.  Navigate to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and click **Installed Extensions**.\n    \n2.  Select **Auth0 AD/LDAP Connector Health Monitor**. A new window with a JSON snippet similar to this opens:\n    \n    ```\n    {\n      \"message\": \"Use this url: 'https://sandbox.it.auth0.com/api/run/auth0user/auth0-ldap-conector-health-monitor?connection={MY-LDAP-CONNECTOR}' for monitoring your AD/LDAP connector.\"\n    }\n    ```\n    \n3.  Enter the ID of your LDAP connection. To get the ID, go to  [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), click the connection, and copy the value from the **Identifier** field.\n    \n    ![Auth0 - Extensions LDAP - Connection ID](https://images.ctfassets.net/cdy7uua7fh8z/6PAofLa601kTEBYajl6wm9/fd3259fd29ebd8dd94b9af3109a31468/image.png)\n\nOnce finished, the provided URL can be used with your monitoring service to monitor your AD/LDAP connectors.\n\n## Learn more\n\n*   [Troubleshoot AD/LDAP Connector](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-ad-ldap-connector)",
  "title": "Auth0 AD/LDAP Connector Health Monitor Extension",
  "description": "Learn how to install and use the Auth0 AD/LDAP Connector Health Monitor extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/user-import-export-extension",
  "markdown": "# User Import / Export Extension\n\nThe **User Import / Export Extension** allows you to:\n\n*   Bulk import your existing database users into Auth0\n    \n*   Search for and export some (or all) of your Auth0 database users\n    \n\nFor a list of user profile fields that can be imported and exported, see [User Profile Attributes](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure).\n\nYou must be a Dashboard Admin to use this extension.\n\n## Install the extension\n\nTo install this extension, go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **User Import / Export**.\n\nThe extension does not require any additional configuration before it can be installed, so select **Install** in the informational pop-up window to proceed.\n\n![Dashboard Extensions Users Import/Export Install Extension](https://images.ctfassets.net/cdy7uua7fh8z/6D9Z4RigtgFBZcd861KVlK/6e42ed005ee62b13b44b0fc91d302f6f/Screen_Shot_2021-05-18_at_9.07.39_PM.png)\n\n## Use the extension\n\nAfter you've installed your extension, you'll see it listed in your list of installed extensions. Click on **Import / Export Extension** to launch.\n\n![Dashboard Extensions Installed Extensions tab](https://images.ctfassets.net/cdy7uua7fh8z/7unxnXFjDkSQUvnyvrOyDn/14c456335df4f9334c4fa0020dca8860/Screen_Shot_2021-05-18_at_9.09.04_PM.png)\n\nYou'll be asked to grant permission for the extension to access your Auth0 account for the listed activities the first time you launch the extension.\"\n\n![Dashboard Extensions Authorize the Users Import/Export Extension](https://images.ctfassets.net/cdy7uua7fh8z/5CCKmxUv1HN5nDj9jL8qel/d7f02ccf3f4be166b00bbf217e14144f/Screen_Shot_2021-05-18_at_9.11.01_PM.png)\n\nClick the **check mark** to proceed.\n\nThere are two ways of using this extension:\n\n*   Bulk import your existing database users into Auth0\n    \n*   Search for and export some (or all) of your Auth0 database users\n    \n\nBoth use cases are explained in further detail below.\n\n### Import users\n\nBy default, any time you open the extension, you'll see the **User Import** screen (if you're on the export screen, you can return to this screen by click **Import** in the left-hand navigation bar).\n\n![Dashboard Extensions Users Import Export Import users from file](https://images.ctfassets.net/cdy7uua7fh8z/5JC6p1ZDDCYm9cCEtq0D7N/511c1241b1835772e7121eb5845f179f/import.png)\n\nTo import your users, drag and drop a valid JSON file ([schema and examples here](https://auth0.com/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples)) onto the area that says **Drop your file here, or click to select**. Alternatively, you can click on this area to browse your files and select the appropriate JSON file. The JSON file should contain the list of users that you are planning to import.\n\nSelect the database connection for which your users will be imported. Please make sure that the connection you choose has been enabled for at least one application.\n\nClick **Start Importing Users** to begin the import process.\n\nWhen done, you'll see the following **Completed** message.\n\n![Dashboard Extensions Users Import Export Import Complete](https://images.ctfassets.net/cdy7uua7fh8z/7hyE3DWBJuFuAulAAnZlfN/23303644d4c706f4c0937bd363bf6699/import-complete.png)\n\nOnce you've imported your users, you can manage them individually using [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n\n### Export users\n\nTo export your existing Auth0 users associated with database connections, select **Export**.\n\n![Dashboard Extensions Users Import Export Export Users page](https://images.ctfassets.net/cdy7uua7fh8z/5wUhbGMjVQKIE9vx2SBIA3/a952aee6cc6027234631334c7174c4a8/export-users.png)\n\nUnder **User Fields**, you can decide which user attributes or expressions should be included in the export. The user attribute can be a static value like `user.user_metadata.name`, or it can be a JavaScript expression like `user.user_metadata.name || user.name`. Expressions will be evaluated during the export runtime. The **column name** value is how the value will be represented in the export.\n\nYou can click the **Add Default Fields** button to automatically select the default fields and populate their column names (this is also a good way for you to visualize how parameters/expressions will appear).\n\nYou can remove extraneous attributes/expressions by clicking on its associated **trash can** icon.\n\nUnder **Settings**, you can:\n\n*   Configure how your exported users are listed by providing a **User Attribute** by which users should be sorted (as well as whether the users should be sorted in ascending or descending order)\n    \n*   Choose your **Export Format**; you can choose between JSON and CSV files\n    \n    ![Dashboard Extensions Users Import Export Settings Export Format](https://images.ctfassets.net/cdy7uua7fh8z/1HVpo1IevSRJbFvwrEKkzf/761fa914f6c33cdee147e07b2c43f7c7/settings.png)\n\nWhen you're ready, click **Export X Users** (where `X` is the number of users you're exporting).\n\nYou can download the file containing your users when the export is complete.\n\n![Dashboard Extensions Users Import Export Progress Indicator Export Complete](https://images.ctfassets.net/cdy7uua7fh8z/2vtH1VMbGBZq1gxxJkM8K7/5086119751b1e38d686c9266fcf6f71e/export-complete.png)\n\n## Update Users\n\nThe Auth0 Management API allows bulk user profile updates to `user_metadata` and `app_metadata` with the User Import/Export Extension.\n\n### Export users\n\nUsing the [export process above](https://auth0.com/docs/customize/extensions/user-import-export-extension#export-users), create a complete export file including all your user attributes.\n\nChoose the JSON format for your export.\n\nDownload the file containing your users when the export is complete.\n\n### Update your configuration\n\nMake a **copy** of the JSON file you downloaded in the previous step.\n\nOpen the copy of the JSON file in a text editor. Your user schema should be similar to the one below:\n\n```\n[\n   {\n      \"Id\":\"auth0|626737a9813c000069daf462\",\n      \"Nickname\":\"testuser1\",\n      \"Name\":\"testuser1@auth0.com\",\n      \"email\":\"testuser1@auth0.com\",\n      \"Connection\":\"Username-Password-Authentication\",\n      \"Created At\":\"2022-04-26T00:07:05.098Z\",\n      \"Updated At\":\"2022-07-06T14:54:19.214Z\"\n   },\n   {\n      \"Id\":\"auth0|62d1a1853bdcf11ff5dca672\",\n      \"Nickname\":\"testuser2\",\n      \"Name\":\"testuser2@auth0.com\",\n      \"email\":\"testuser2@auth0.com\",\n      \"Connection\":\"Username-Password-Authentication\",\n      \"Created At\":\"2022-07-15T17:19:01.531Z\",\n      \"Updated At\":\"2022-07-15T17:19:01.532Z\"\n   },\n   {\n      \"Id\":\"auth0|62d1a1a524f32a4185c9ce23\",\n      \"Nickname\":\"testuser3\",\n      \"Name\":\"testuser3@auth0.com\",\n      \"email\":\"testuser3@auth0.com\",\n      \"Connection\":\"Username-Password-Authentication\",\n      \"Created At\":\"2022-07-15T17:19:33.484Z\",\n      \"Updated At\":\"2022-07-15T17:19:33.484Z\"\n   }\n]\n```\n\nDo not change the user email address because it is the lookup key for users in the database.\n\nTo add an attribute, create a new field in each user schema and update with a value. In the example below, the \"Family Name\" attribute has a value of \"Smith\" with a comma after the new attribute value.\n\nYou can also add the `email_verified` attribute to multiple users and set the value to `true`.\n\n```\n{\n   \"Id\":\"auth0|626737a9813c000069daf462\",\n   \"Nickname\":\"testuser1\",\n   \"Family Name\":\"Smith\",\n   \"Name\":\"testuser1@auth0.com\",\n   \"email\":\"testuser1@auth0.com\",\n   \"email_verified\":true,\n   \"Connection\":\"Username-Password-Authentication\",\n   \"Created At\":\"2022-04-26T00:07:05.098Z\",\n   \"Updated At\":\"2022-07-06T14:54:19.214Z\"\n}\n```\n\nSave the changes to your user file.\n\n### Import updated user profile data\n\nThe `users-import` endpoint allows you to upload your updated user profile file and update several users in one job. Navigate to the [Create import users job endpoint](https://auth0.com/docs/api/management/v2/#!/Jobs/post_users_imports).\n\nAdd your user file to the users parameter and add the database connection ID of the database you want to update.\n\nThe upsert value should be `true` to update the already existing user information. To add your updates, select **Try** or use Postman to import the users.\n\nUse the `job_id` to verify the status with the `jobs` [endpoint](https://auth0.com/docs/api/management/v2/#!/Jobs/get_jobs_by_id).",
  "title": "User Import / Export Extension",
  "description": "Learn about the User Import/Export extension, which allows you to import and export users from or to any database you have configured in your account.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/azure-api-management",
  "markdown": "# Integrate with Azure API Management\n\nThe [Azure API Management](https://azure.microsoft.com/en-us/services/api-management/) service allows you to create new APIs or import existing API definitions and publish them for use by the approved audiences. Auth0 makes authorizing users of your API (using OAuth 2.0 standards) easy.\n\nIn this tutorial, you'll learn how to use Auth0 to authenticate and authorize users when they access a Basic Calculator API managed by Azure API Management.\n\n## Configure Auth0\n\n### Create an API\n\nYou'll need to create an API in Auth0 to represent the API managed by the Azure API Management Service. To learn more, read [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).\n\n1.  Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and select **Create API**.\n    \n2.  Set the following parameters:\n    \n    | **Field** | **Value** |\n    | --- | --- |\n    | **Name** | `Basic Calculator` |\n    | **Identifier** | `basic-calculator` |\n    | **Signing Algorithm** | `RS256` |\n    \n3.  Select **Create**.\n    \n\n### Create a Regular Web Application\n\nYou'll need to create a Regular Web Application (RWA) in Auth0 to communicate with the OAuth 2.0 authorization server in Azure:\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select the **Create Application** button.\n    \n2.  Enter a **Name** for your application, and select **Regular Web Applications** for the application type.\n    \n\n### Create and enable a connection\n\nYou'll need to create a connection in Auth0 and enable it for your application:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), and select **Create DB Connection**.\n    \n2.  Enter a **Name** for your connection. We suggest choosing a name that reflects the source of users (such as `Facebook` for a Connection that contains users using their Facebook credentials or `site-sign-ups` for a database connection where users sign up on your site).\n    \n3.  Select **Create**.\n    \n4.  Navigate to your connection's **Settings** page.\n    \n5.  Switch to the **Applications** view, where you'll see a list of all the applications on your tenant.\n    \n6.  Toggle the application you created previously to enable it for the connection.\n    \n\n### Create a user\n\nYou'll need to have at least one user on your connection to test authentication and authorization. If you do not have an existing set of users for the connection, you can create one manually:\n\n1.  Navigate to [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users), and select **Create User**.\n    \n2.  Enter an **Email** and **Password**, and select the connection you created in Step 3 for the **Connection** field.\n    \n3.  Select **Create**.\n    \n\n## Configure Azure\n\n### Create Azure API Management Service\n\nYou'll need to create an API Management Service instance in Azure to manage your API:\n\n1.  In the navigation bar, select **Create a resource**.\n    \n2.  Once redirected, select **Web** > **API Management**.\n    \n3.  Provide the following configuration variables:\n    \n    | **Parameter** | **Description** |\n    | --- | --- |\n    | **Name** | The name for your service (which will also be used to create the URL you need to access the service) |\n    | **Subscription** | The Azure subscription plan with which you'll use with the service |\n    | **Resource group** | The collection of [resources](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-portal) sharing a lifecycle, permissions, and policies. You can use an existing resource group or you can create a new one (you'll need to provide a name for the group if you create a new one) |\n    | **Location** | Choose the location that services your API instance |\n    | **Organization name** | The name of your organization |\n    | **Administrator email** | The email address of the person who will be administering this instance |\n    | **Pricing tier** | The pricing tier you want, which determines the number of calls you can make to your API, as well as the maximum amount of data transfer allowed. You must opt for the [Developer plan](https://azure.microsoft.com/en-us/pricing/details/api-management/) or higher; the Consumption plan does not offer sufficient functionality for this integration to work. |\n    \n4.  Select **Create** to begin provisioning your service (this may take up to 15 minutes to complete).\n    \n\n### Import the sample API\n\nFor this tutorial, we will be importing and using the Basic Calculator API provided by Microsoft. For detailed instructions, see [Import and Publish Your First API](https://docs.microsoft.com/en-us/azure/api-management/import-and-publish#go-to-your-api-management-instance) from Microsoft.\n\nWhen done, select **Create** to import your API. You'll be redirected to the summary page for your API when it's fully imported.\n\nTo use Auth0 to secure your Azure API, you'll need to register Auth0 as an OAuth 2.0 authorization server:\n\n1.  Find the **OAuth 2.0 + OpenID Connect** area of your API Management service instance near the navigation bar. Select **OAuth 2.0**, and then select **Add**.\n    \n2.  Go to the **Add OAuth2 service** configuration screen, and select the Authorization Code grant type.\n    \n3.  Set the following parameters:\n    \n    | **Parameter** | **Description** |\n    | --- | --- |\n    | **Display name** | Enter a descriptive name for your authorization server, such as `Auth0`. |\n    | **Id** | This field should auto-populate based on the display name you provide. |\n    | **Description** | Enter a description for your authorization server, such as `Auth0 API Authentication`. |\n    | **Client registration page URL** | Enter`https://placeholder.contoso.com` as a placeholder. |\n    | **Authorization code grant types** | Select `Authorization code`. |\n    | **Authorization endpoint URL** | Refer to your tenant's [OIDC Discovery endpoint](https://{yourdomain}/.well-known/openid-configuration) and append the `audience` parameter. For example: `https://{yourDomain}/authorize?audience={API_AUDIENCE}`. |\n    | **Authorization request method** | Default is `GET`. |\n    | **Token endpoint URL** | Refer to your tenant's [OIDC Discovery endpoint](https://{yourdomain}/.well-known/openid-configuration) . |\n    | **Client authentication methods** | Select `Basic`. |\n    | **Access Token sending method** | Select `Authorization header`. |\n    | **Default scope** | Specify a default scope , if required. |\n    \n4.  Under the **Client Credentials** section, enter your Auth0 applications client ID in the **Client ID** field and client secret in the **Client secret** field.\n    \n5.  Switch to the **Redirect URI** view, and copy the URI value in the **Authorization code flow grant** field.\n    \n6.  Select **Create**.\n    \n\n### Configure Azure API to use Auth0\n\nAfter you've created your OAuth 2.0 authorization server in Azure, you'll need to update your Azure API to use Auth0 for user authorization:\n\n1.  Under the **APIs** section in the navigation, select **APIs**.\n    \n2.  Select the Basic Calculator API, and go to the **Design** view.\n    \n3.  Switch to the **Settings** view.\n    \n4.  Navigate to the **Security** section, and select **OAuth 2.0** under **User Authorization**.\n    \n5.  Select the server you configured in the previous step for the **Authorization Server** field.\n    \n6.  Click **Save**.\n    \n\n## Set the Allowed Callback URL in Auth0\n\nAfter your Azure API is provisioned and configured to use Auth0 for user authorization, you'll need to update your Auth0 application:\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select your application, and switch to the **Settings** view.\n    \n3.  Enter the Redirect URI you copied previously into the **Allowed Callback URLs** field.\n    \n4.  Click **Save**.\n    \n\n## Test the integration\n\nIn to the Azure Portal, open up your instance of the API Management Service.\n\n1.  Select **Developer Console** to launch the developer-facing side of your APIs.\n    \n2.  Go to **APIs** > **Basic Calculator**. This opens up to the page where you can make a `GET` call that allows you to add two integers.\n    \n3.  Select **Try It**. This will bring up the page where you can provide the parameters for your call.\n    \n4.  Navigate to the **Authorization** section, and select **Authorization Code** (next to the **Auth0** field).\n    \n5.  A popup window will appear with the Auth0 login widget (if it doesn't, ensure that any pop-up blockers are disabled for your browser). Enter the credentials for the Auth0 user you created in Step 4, and log in.\n    \n6.  If you were able to successfully log in, a message will appear with the expiration date of the access token you can use to call your API.\n    \n7.  Navigate to the bottom, and select **Send**. If the request is successful, you'll see a message containing the `HTTP 200` response at the bottom of the page.\n    \n\n### Configure a JWT validation policy for Access Tokens\n\nIn the previous step, the user is prompted to sign in when they try to make a call from the Developer Console. The Developer Console attempts to obtain an Access Token on behalf of the user to be included in the API request. All Access Tokens will be passed to the API via the `Authorization` header.\n\nIf you want to validate the Access Token included with each request, you can do so by using the [Validate JWT](https://docs.microsoft.com/en-us/azure/api-management/api-management-access-restriction-policies#ValidateJWT) policy. Please refer to Microsoft's documentation on [setting an API Management policy](https://docs.microsoft.com/en-us/azure/api-management/set-edit-policies).",
  "title": "Integrate with Azure API Management",
  "description": "Using Auth0 as an OAuth 2.0 server to authenticate users wanting access to an API managed by the Azure API Management service",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/aws",
  "markdown": "# Integrate with Amazon Web Services and Products\n\nThere are many ways to integrate Auth0 with Amazon products and services depending on your specific needs.\n\n## Product integrations\n\nYou can read further on how to use the products below to use in addition to your Auth0 and AWS services:\n\n*   [CloudFront](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-aws-cloudfront-for-use-as-reverse-proxy): Use as a reverse proxy with your custom domain.\n    \n*   [Simple Email Service (SES)](https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider): Manage email communications with your users.\n    \n*   [EventBridge](https://marketplace.auth0.com/integrations/amazon-log-streaming): Stream logs to EventBridge.\n    \n*   [Cognito](https://auth0.com/docs/customize/integrations/aws/amazon-cognito): Use as a backend for your application.\n    \n\n## Identity and access management (IAM) integrations\n\nWe have several how-to articles to configure AWS to work with Auth0:\n\n*   [Secure AWS API Gateway endpoints using custom authorizers](https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-custom-authorizers): Accept Auth0-issued access tokens.\n    \n*   [Use AWS session tags with AWS APIs and resources](https://auth0.com/docs/customize/integrations/aws/session-tags): Tag resources and assign users key/value pairs for RBAC.\n    \n*   [Configure AWS for single sign-on](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso): Allow your users to log in to AWS using any supported identity provider.\n    \n*   [Add Amazon login to your app](https://auth0.com/docs/connections/social/amazon): Allow users to log in to your app using their Amazon profile.\n    \n\n## Learn more\n\n*   [Build Serverless Applications Using Token-Based Authentication with AWS API Gateway and Lambda](https://auth0.com/docs/customize/integrations/aws/aws-api-gateway-delegation)\n*   [Configure Amazon Web Services as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)",
  "title": "Integrate with Amazon Web Services and Products",
  "description": "List of Amazon products and services, including Amazon Web Services (AWS) for identity and access management (IAM) with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/apigee",
  "markdown": "# Secure Apigee with Auth0\n\nIf you are using Apigee Edge for developing and managing your backend service APIs, you can use Auth0 to secure access to your API proxies.\n\n## Prerequisites\n\nBefore you begin, you'll need to:\n\n1.  Have an Apigee Edge API proxy that needs to be secured. To learn more, read Apigee's [Get Started](https://docs.apigee.com/api-platform/get-started/get-started) article.\n    \n2.  [Sign up](https://auth0.com/signup) for an account with Auth0.\n    \n\nThe process of building your API proxy is outside the scope of this article. Instead, we will focus on securing an API proxy that you already have using Auth0.\n\n## Create a custom API\n\nFirst, [register your Apigee Edge API Proxy using the Dashboard](https://auth0.com/docs/get-started/auth0-overview/set-up-apis). Auth0 needs to recognize Apigee as an audience to make sure that any Access Tokens issued are issued with the correct audience. The user authenticates with Auth0 via the application, and the application specifies this audience value to make sure that the Access Token possesses the right scopes for the audience provided.\n\nYou'll need to do the following:\n\n1.  Provide a name for your API (e.g., `apigee`).\n    \n2.  Provide an identifier for your API: `urn:apigee:target:api`\n    \n3.  Choose a signing algorithm: `RS256` (default)\n    \n\nWhen you register your Apigee Edge API Proxy, Auth0 also creates a **Machine to Machine (M2M)** application on your behalf and names it to match the API you registered. You can use this application for testing; it is automatically configured to be authorized to call your API.\n\n## Note variables from the test application\n\nSwitch to the test application created when registering your API and make note of the variables that were set during the process of registering your API and creating the associated M2M application. You will need them for subsequent steps of this tutorial.\n\n1.  Navigate to the [Auth0 Dashboard > Applications](https://manage.auth0.com/#/applications)\\], and click the name of your test application.\n    \n2.  Scroll down and make note of the following variables:\n    \n    *   API audience\n        \n    *   Auth0 domain\n        \n    *   Client ID\n        \n    *   Allowed callback URL(s): The URLs to which the user can be redirected after authentication. You can specify multiple URLs by comma-separating them. (This is typically done to handle different environments where each needs its own redirects.)\n        \n\n## Implement the Client Credentials flow\n\nNow you're ready to implement the Client Credentials Flow to request the Access Tokens you can provide to Apigee Edge. Note that in this scenario, you will use the Client Credentials Flow because you are using Apigee with your backend service APIs, which represents a Machine-to-Machine (M2M) application; other scenarios may require the use of different flows.\n\nTo learn how to log in and get an Access Token that can be used to call Apigee Edge, see [Call API Using the Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow).\n\n## Validate the Access Token\n\nOnce you've requested and received an Access Token from Auth0, you'll be able to use it to call the API proxy you set up with Edge.\n\nWhen you [use your Access Token](https://docs.apigee.com/api-platform/security/oauth/using-access-tokens.html), the first thing Apigee Edge will do is [verify the token](https://docs.apigee.com/api-platform/security/oauth/using-access-tokens.html#addingaverifyaccesstokenpolicy).\n\nAuth0 Access Tokens are JSON Web Tokens (JWTs), so you can take advantage of Apigee Edge's Verify JWT policy to do this. To learn more, read Apigee's [Verify JWT policy signed with the RS256 algorithm](https://docs.apigee.com/api-platform/reference/policies/verify-jwt-policy#verify-a-jwt-signed-with-the-rs256-algorithm) article.\n\nApigee Edge will verify the token before anything else happens; if the token is rejected, then all processing will stop and Edge will return an error to the client.\n\n## Testing\n\nTo test your implementation, make an HTTP POST call to Apigee Edge with the Auth0-issued Access Token included in the header of the call. You can learn how by reviewing Apigee's [Calling the protected API](https://docs.apigee.com/api-platform/security/oauth/oauth-20-client-credentials-grant-type.html#callingtheprotectedapi) article.\n\nWhen you receive a successful response, extract the token and review it to verify the inclusion of required/requested user claims.",
  "title": "Secure Apigee with Auth0",
  "description": "Learn how to use Auth0 to secure access to API proxies developed and managed by Apigee Edge.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/google-cloud-endpoints",
  "markdown": "# Secure Google Cloud Endpoints with Auth0\n\n[Google Cloud Endpoints (GCE)](https://cloud.google.com/endpoints/) is an API management system providing features to help you create, maintain, and secure your APIs. GCE uses [OpenAPI](https://www.openapis.org/) to define your API's endpoints, input and output, errors, and security description.\n\nFor more information on the OpenAPI spec, see the [OpenAPI Specification](https://github.com/OAI/OpenAPI-Specification) repository on GitHub.\n\nThis tutorial will cover how to secure Google Cloud Endpoints with Auth0.\n\n## Prerequisites\n\nBefore you begin you'll need a deployed GCE API. If you haven't already created an API, complete the [Cloud Endpoints Quickstart](https://cloud.google.com/endpoints/docs/quickstart-endpoints) located in Google documentation.\n\nThe quickstart will walk you through creating a simple GCE API with a single endpoint, `/airportName`, that returns the name of an airport from its three-letter [IATA code](https://en.wikipedia.org/wiki/IATA_airport_code).\n\n*   [cURL](#82b1bb71d89a4bfe87d8bf444f0dbc08_shell)\n*   [C#](#82b1bb71d89a4bfe87d8bf444f0dbc08_csharp)\n*   [Go](#82b1bb71d89a4bfe87d8bf444f0dbc08_go)\n*   [Java](#82b1bb71d89a4bfe87d8bf444f0dbc08_java)\n*   [Node.JS](#82b1bb71d89a4bfe87d8bf444f0dbc08_node)\n*   [Obj-C](#82b1bb71d89a4bfe87d8bf444f0dbc08_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://%7ByourGceProject%7D.appspot.com/airportName',\n  params: {iataCode: 'SFO'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nconn.request(\"GET\", \"%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Define the API in Auth0\n\nGo to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and create a new API.\n\n![Dashboard - Create APIs - Integrations -Google Endpoints](https://images.ctfassets.net/cdy7uua7fh8z/7wUHnYBFp1jnbBurqoThpD/9f3cee86f7991ce704065d8a2079b47e/Dashboard_-_Create_APIs_-_Integrations_-Google_Endpoints.png)\n\nMake note of the **API Audience** identifier (`http://google_api` in the screenshot above) to use in the following step.\n\n## Update the API Configuration\n\nNext, we'll update the OpenAPI configuration file for the GCE API. For the sample API created during the quickstart this file is `openapi.yaml`.\n\n### Add Security Definitions\n\nOpen the configuration file and add a new `securityDefinitions` section. In this section, add a new definition (`auth0_jwt`) with the following fields:\n\n| Field | Description |\n| --- | --- |\n| `authorizationUrl` | The authorization URL, should be set to `\"https://{yourDomain}/authorize\"` |\n| `flow` | The flow used by the OAuth2 security scheme. Valid values are `\"implicit\"`, `\"password\"`, `\"application\"` or `\"accessCode\"`. |\n| `type` | The type of the security scheme. Valid values are `\"basic\"`, `\"apiKey\"` or `\"oauth2\"` |\n| `x-google-issuer` | The issuer of a credential, should be set to `\"https://{yourDomain}/\"` |\n| `x-google-jwks_uri` | The URI of the public key set to validate the JSON Web Token (JWT) signature. Set this to `\"https://{yourDomain}/.well-known/jwks.json\"` |\n| `x-google-audiences` | The API's identifier, make sure this value matches what you defined on the Auth0 dashboard for the API. |\n\nto configure this snippet with your account\n\n```\nsecurityDefinitions:\n  auth0_jwt:\n    authorizationUrl: \"https://{yourDomain}/authorize\"\n    flow: \"implicit\"\n    type: \"oauth2\"\n    x-google-issuer: \"https://{yourDomain}/\"\n    x-google-jwks_uri: \"https://{yourDomain}/.well-known/jwks.json\"\n    x-google-audiences: \"{yourApiIdentifier}\"\n```\n\n### Update the Endpoint\n\nNow, update the endpoint by adding a `security` field with the `securityDefinition` we created in the previous step.\n\n```\npaths:\n  \"/airportName\":\n    get:\n      description: \"Get the airport name for a given IATA code.\"\n      operationId: \"airportName\"\n      parameters:\n        -\n          name: iataCode\n          in: query\n          required: true\n          type: string\n      responses:\n        200:\n          description: \"Success.\"\n          schema:\n            type: string\n        400:\n          description: \"The IATA code is invalid or missing.\"\n      security:\n       - auth0_jwt: []\n```\n\nIn the above example, the `security` field tells the GCE proxy that our `/airportName` path expects to be secured with the `auth0-jwt` definition.\n\nAfter updating the OpenAPI configuration, it should look something like this:\n\nto configure this snippet with your account\n\n```\n---\nswagger: \"2.0\"\ninfo:\n  title: \"Airport Codes\"\n  description: \"Get the name of an airport from its three-letter IATA code.\"\n  version: \"1.0.0\"\nhost: \"{yourGceProject}.appspot.com\"\nschemes:\n  - \"https\"\npaths:\n  \"/airportName\":\n    get:\n      description: \"Get the airport name for a given IATA code.\"\n      operationId: \"airportName\"\n      parameters:\n        -\n          name: iataCode\n          in: query\n          required: true\n          type: string\n      responses:\n        200:\n          description: \"Success.\"\n          schema:\n            type: string\n        400:\n          description: \"The IATA code is invalid or missing.\"\n      security:\n       - auth0_jwt: []\nsecurityDefinitions:\n  auth0_jwt:\n    authorizationUrl: \"https://{yourDomain}/authorize\"\n    flow: \"implicit\"\n    type: \"oauth2\"\n    x-google-issuer: \"https://{yourDomain}/\"\n    x-google-jwks_uri: \"https://{yourDomain}/.well-known/jwks.json\"\n    x-google-audiences: \"{yourApiIdentifier}\"\n```\n\n### Redeploy the API\n\nNext, redeploy your GCE API to apply the configuration changes. If you followed along with the [Cloud Endpoints Quickstart](https://cloud.google.com/endpoints/docs/quickstart-endpoints) you can redeploy by entering the following in Google's Cloud Shell:\n\n```\ncd endpoints-quickstart/scripts\n./deploy_api.sh\n```\n\n## Test the API\n\nOnce you've redeployed, call the API again with no security.\n\n*   [cURL](#9e15fa2c186746b4814a7daf8f2dc084_shell)\n*   [C#](#9e15fa2c186746b4814a7daf8f2dc084_csharp)\n*   [Go](#9e15fa2c186746b4814a7daf8f2dc084_go)\n*   [Java](#9e15fa2c186746b4814a7daf8f2dc084_java)\n*   [Node.JS](#9e15fa2c186746b4814a7daf8f2dc084_node)\n*   [Obj-C](#9e15fa2c186746b4814a7daf8f2dc084_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://%7ByourGceProject%7D.appspot.com/airportName',\n  params: {iataCode: 'SFO'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nconn.request(\"GET\", \"%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou'll get the following response:\n\n```\n{\n \"code\": 16,\n \"message\": \"JWT validation failed: Missing or invalid credentials\",\n \"details\": [\n  {\n   \"@type\": \"type.googleapis.com/google.rpc.DebugInfo\",\n   \"stackEntries\": [],\n   \"detail\": \"auth\"\n  }\n ]\n}\n```\n\nWhich is exactly what we want!\n\nNow go to the **Test** page of your Google Endpoints API definition on the [Auth0 Dashboard](https://manage.auth0.com/#/apis), and copy the Access Token under the Response:\n\n![Dashboard - API - Integrations - Google Endpoints - Copy Token](https://images.ctfassets.net/cdy7uua7fh8z/4FXfoYMShSPVFo5W13j3p7/bb4d4ab14abfa34266fb5b8fe12a2e91/Dashboard_-_API_-_Integrations_-_Google_Endpoints_-_Copy_Token.png)\n\nPerform a `GET` request to your API with an Authorization Header of `Bearer {ACCESS_TOKEN}` to obtain authorized access:\n\n*   [cURL](#913a82fbed7b4196b9f4f10b4f99a32a_shell)\n*   [C#](#913a82fbed7b4196b9f4f10b4f99a32a_csharp)\n*   [Go](#913a82fbed7b4196b9f4f10b4f99a32a_go)\n*   [Java](#913a82fbed7b4196b9f4f10b4f99a32a_java)\n*   [Node.JS](#913a82fbed7b4196b9f4f10b4f99a32a_node)\n*   [Obj-C](#913a82fbed7b4196b9f4f10b4f99a32a_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO' \\\n  --header 'authorization: Bearer {accessToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {accessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {accessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")\n  .header(\"authorization\", \"Bearer {accessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://%7ByourGceProject%7D.appspot.com/airportName',\n  params: {iataCode: 'SFO'},\n  headers: {authorization: 'Bearer {accessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {accessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {accessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {accessToken}\" }\n\nconn.request(\"GET\", \"%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {accessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {accessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourGceProject%7D.appspot.com/airportName?iataCode=SFO\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nAnd that's it!",
  "title": "Secure Google Cloud Endpoints with Auth0",
  "description": "How to secure a Google Cloud Endpoints API with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/secure-a-cli-with-auth0",
  "markdown": "# Secure a CLI with Auth0\n\nThe three ways to secure a CLI with Auth0, in order of most secure to least secure, are:\n\n*   [Device Authorization Flow](#device-authorization-flow) for when the user can't open a browser\n    \n*   [Client Credentials Grant Flow](#client-credentials-grant-flow) for applications acting on their own behalf and not attributable to a user\n    \n*   [Resource Owner Password Grant Flow](#resource-owner-password-grant-flow) only for when you're trying to authenticate the CLI client itself, which is a very rare situation (otherwise not recommended)\n    \n\nWith input-constrained devices that connect to the internet, rather than authenticate the user directly, the device asks the user to go to a link on their computer or smartphone and authorize the device. This avoids a poor user experience for devices that do not have an easy way to enter text. To do this, device apps use the Device Authorization Flow (drafted in [](https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15)OAuth 2.0), in which they pass along their Client ID to initiate the authorization process and get a token.\n\nThe easiest way to implement the [](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)Device Authorization Flow is to follow the steps in [Call API Using Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/call-your-api-using-the-device-authorization-flow).\n\nTo learn more about the Device Authorization Flow in OAuth 2.0, you can review the Internet Engineering Task Force (IEFT) draft [OAuth 2.0 Authorization Grant](https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15). You can also review our article, [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow).\n\n## Client Credentials Grant Flow\n\nUse the Client Credentials Grant (CCG) flow when users and downstream identity providers aren't involved, and you want to authenticate based on distinct machines or devices.\n\nIf your identity provider supports sending credentials, then you should review our article, [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow). For details on how to implement this flow, refer to [Call API Using the Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow).\n\n## Resource Owner Password Grant Flow\n\nWe do not recommend using the Resource Owner Password Grant (ROPG) flow for native applications. In the IEFT article, [RFC 8252 OAuth 2.0 for Native Apps](https://tools.ietf.org/html/rfc8252), it is recommended that “OAuth 2.0 authorization request from native apps should ONLY be made through external user-agents, primarily the user’s browser”. For details, see [RFC 8252 Embedded User-Agents](https://tools.ietf.org/html/rfc8252#section-8.12).\n\nUsing Resource Owner Password Grant (ROPG) are less secure than the redirect-based options described above. ROPG is only for legacy. In the context of CLIs, it only makes sense for things like connection strings where you need to support legacy programs.\n\nIf you must use ROPG in your native app instead of Device Flow as we recommend, then you can use our [OIDC Compliant ROPG endpoint](https://auth0.com/docs/api/authentication#resource-owner-password).",
  "title": "Secure a CLI with Auth0",
  "description": "How to use Auth0 to secure a CLI.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/sso-integrations",
  "markdown": "# Single Sign-On Integrations\n\nSingle Sign-on (SSO) Integrations are client applications that enable the use of external services (e.g., [Dropbox](https://marketplace.auth0.com/integrations/dropbox-sso), [Slack](https://marketplace.auth0.com/integrations/slack-sso), or [Zoom](https://marketplace.auth0.com/integrations/zoom-sso)) for SSO. The integration allows your users to log in using Auth0's identity providers. To see the full list, explore [Auth0 Marketplace: SSO Integrations](https://marketplace.auth0.com/features/sso-integrations).\n\nFor more information on Auth0's available Connections, see [Auth0 Connections](https://auth0.com/docs/authenticate/identity-providers).",
  "title": "Single Sign-On Integrations",
  "description": "Overview of Auth0 Single Sign-on (SSO) Integrations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketing-tool-integrations",
  "markdown": "# Export User Data to Marketing Tools\n\nWas this article helpful?",
  "title": "Export User Data to Marketing Tools",
  "description": "Learn how to export Auth0 user data to marketing applications and services.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/sharepoint-2010-2013",
  "markdown": "# Integrate with SharePoint 2010/2013\n\nAuth0 can help to radically simplify the authentication process for SharePoint. In this tutorial, you'll learn how to add Single Sign-on (SSO) to Sharepoint using Auth0. Your users will be able to log in using any of our [Social Identity Providers](https://auth0.com/docs/connections/identity-providers-social) (Facebook, X, Github, and so on), [Enterprise Providers](https://auth0.com/docs/connections/identity-providers-enterprise) (LDAP, Active Directory, ADFS, and so on) or with a username and password.\n\n## Setup\n\n### 1\\. Adding the Integration to your account\n\nThe first thing you need to do is go to the [SSO Integrations](https://manage.auth0.com/#/externalapps/create) section in the Dashboard and choose **SharePoint** from the list of apps.\n\n### 2\\. Follow the Live Documentation\n\nOn the **Settings** tab you'll need to enter the URL of the SharePoint Web Application and the external URL (typically the internet endpoint in your Alternate Access Mappings).\n\nThe Live Documentation will first start with the installation of the Auth0 CmdLets for SharePoint:\n\n![SharePoint Management Shell - cmdlets installation](https://images.ctfassets.net/cdy7uua7fh8z/10GyFjDBJS0PoXITPeh30v/4304616303b13441c0b306be2291271f/sharepoint-cmdlets-installation.png)\n\nOnce these have been installed you'll be able to enable/disable Auth0 and the Claims Provider for the different Web Applications. You will need to enable authentication with Auth0:\n\n![SharePoint Management Shell - Auth0 install - Enable Authentication](https://images.ctfassets.net/cdy7uua7fh8z/e3WetoxFwzfQ2uo7Rhum4/f53189f6fd8247ba2f472dbc10abe5dc/sharepoint-auth-installation.png)\n\nAnd then install the Claims Provider, to make sure that the People Picker and permissions work correctly:\n\n![SharePoint Management Shell - install claims provider](https://images.ctfassets.net/cdy7uua7fh8z/2WYY6vJdeRqFZUS9LfgzK5/5b35393140b7c818fc811afd0ddc3220/sharepoint-cp-installation.png)\n\nOnce these scripts have been executed you'll complete the configuration in Central Administration:\n\n![SharePoint central admin - complete configuration](https://images.ctfassets.net/cdy7uua7fh8z/3VgxRGBz9YNbFaJP7Sgz8T/64673af31849333bf370c3f46b9687f1/sharepoint-central-admin.png)\n\nNote that the call to `Enable-Auth0` can be adapted to:\n\n*   Change the unique identifier for users (such as email or a user id)\n    \n*   Allow additional claims to be passed through to SharePoint\n    \n*   Enable or disable the default Windows Authentication\n    \n\nThe following example also adds the Role claim to the claims mapping and allows Windows Authentication:\n\n```\nEnable-Auth0\n  -auth0Domain:\"fabrikam.auth0.com\"\n  -clientId:\"bOFty3tWgpijnwMcltysNFqHgO1ziz1I\"\n  -webAppUrl:\"http://fabrikam-sp/\"\n  -identifierClaimType:\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n  -claims:@(\n    \"Email|http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n    \"Role|http://schemas.microsoft.com/ws/2008/06/identity/claims/role\", \"Client ID|http://schemas.auth0.com/clientID\",\n    \"Given Name|http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n    \"Surname|http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\", \"Picture|http://schemas.auth0.com/picture\")\n  -allowWindowsAuth\n```\n\n### 3\\. You now have Sharepoint configured\n\nYou have configured SharePoint to use Auth0 as the SSO broker. When your users visit your site they'll be presented with a login page showing all the connections enabled for that application.\n\nDepending on which claims have been mapped when installing the claims provider this additional information will also be available in the user's personal settings page:\n\n![SharePoint - user information](https://images.ctfassets.net/cdy7uua7fh8z/7h2QeT1ama9IqZ2kDr4KT/5f689e49311471736c74a3eb5468c390/sharepoint-user-info.png)![SharePoint central admin - complete configuration](https://images.ctfassets.net/cdy7uua7fh8z/3VgxRGBz9YNbFaJP7Sgz8T/64673af31849333bf370c3f46b9687f1/sharepoint-central-admin.png)\n\nNote that you can adapt the call to `Enable-Auth0` to:\n\n*   Change the unique identifier for users (such as email or a user id)\n    \n*   Allow additional claims to be passed through to SharePoint\n    \n*   Enable or disable the default Windows Authentication\n    \n\nThis example also adds the Role claim to the claims mapping and allows Windows Authentication:\n\n```\nEnable-Auth0\n  -auth0Domain:\"fabrikam.auth0.com\"\n  -clientId:\"bOFty3tWgpijnwMcltysNFqHgO1ziz1I\"\n  -webAppUrl:\"http://fabrikam-sp/\"\n  -identifierClaimType:\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n  -claims:@(\n    \"Email|http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n    \"Role|http://schemas.microsoft.com/ws/2008/06/identity/claims/role\", \"Client ID|http://schemas.auth0.com/clientID\",\n    \"Given Name|http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n    \"Surname|http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\", \"Picture|http://schemas.auth0.com/picture\")\n  -allowWindowsAuth\n```\n\nSharePoint will now use Auth0 as the SSO broker.\n\n## Customizing the Login Page\n\nYou can customize the login page by following [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) instructions.\n\nYou might wish to provide a way to let users authenticate with Sharepoint using Windows Authentication, bypassing Auth0. You can do that by customizing the login page, adding a link to the Windows Authentication endpoint (usually similar to `https://yoursharepointserver/_windows/default.aspx?ReturnUrl=/_layouts/15/Authenticate.aspx`).\n\nOn way of doing it is by using jQuery to modify the Lock widget and add a link to the Windows Authentication endpoint.\n\nYou need to add a reference to jQuery at the top of the `<body>` section of the customized login page.\n\n```\n<script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\"></script>\n```\n\nBefore calling `lock.show()`, add code to modify the HTML DOM that adds the link.\n\n```\n// construct Lock\n// var lock = ...\n[...]\n// One or more SharePoint client IDs here for which you want\n// a Windows Auth button\nvar sharepointClientIDs = ['your_sharepoint_client_id'];\n\nif (sharepointClientIDs.indexOf(config.clientID) >= 0) {\n  lock.on('signin ready', function() { \n    var getParameterByName = function(name) {\n      name = name.replace(/[\\[]/, \"\\\\\\[\").replace(/[\\]]/, \"\\\\\\]\");\n      var regexS = \"[\\\\?&]\" + name + \"=([^&#]*)\";\n      var regex = new RegExp(regexS);\n      var results = regex.exec(window.location.search);\n      if (results == null) return null;\n      else return results[1];\n    };\n    // get the host from the callback URL\n    var parser = document.createElement('a');\n    parser.href = config.callbackURL;\n    var host = parser.host;\n    var windowsAuthURL = \"https://\" + host + \"/_windows/default.aspx?ReturnUrl=/_layouts/15/Authenticate.aspx\";\n    var wctx = getParameterByName(\"wctx\");\n    if (wctx) {\n      windowsAuthURL += \"&Source=\" + wctx;\n    }\n\n    $('.auth0-lock-tabs-container') \n    .after('<div><p class=\"auth0-lock-alternative\" style=\"padding:5px 0;\">' + \n      '<a class=\"auth0-lock-alternative-link\" ' + \n      'href=\"/docs/'+ windowsAuthURL + '\">' + \n      'Login with Windows Authentication!!!</a>' + \n      '</p><p><span>or</span></p></div>').attr('href','https://nowhere');\n  });\n}\n\nlock.show();\n```\n\n## Troubleshooting\n\nWhen working with additional claims and authorization it can always be useful to view the claims for the current user. Microsoft Professional [Liam Clearly](https://www.helloitsliam.com/)'s article, [Claims Viewer Web Part](https://sharepointobservations.wordpress.com/2013/08/21/sharepoint-2013-and-adfs-2-0-test-with-claims-viewer-web-part/), can be used to troubleshoot any issues with the user's claims:\n\n### Logs in SP2010\n\nErrors and warnings are logged to SharePoint's Unified Logging Service and tools like the ULS Viewer can be used to troubleshoot any issues you might have when using the Claims Provider.\n\nTo read more about ULS View and retrieve specifications, see Microsoft documentation [ULS Viewer](http://www.microsoft.com/en-us/download/details.aspx?id=44020).\n\n### Logs in SP2013\n\nFor SharePoint 2013 we no longer use the Unified Logging Service for our logs, but we've moved to Event Tracing for Windows instead. This delivers more performance and gives you multiple ways of capturing all the logged events.\n\nTo view the logs in real-time you can download the Auth0 [Logs Processor](https://github.com/auth0/auth0-sharepoint/releases) from Github. Run this tool on your SharePoint Server(s) to see every call SharePoint is making to the Claims Provider:\n\n## Next Steps\n\nThe claims being passed through from Auth0 can also be used for authorization in SharePoint. For example, a user with the Role claim containing **Fabrikam HR** should have access or be a Contributor on a specific site.\n\nLet's take Azure AD as an example. In this Cloud Directory users can be part of groups and David is part of Fabrikam HR.\n\nWhen David logs in using his Azure AD account (and the Security Groups attribute is enabled for that connection) the group memberships will be stored in the `groups` attribute of the user's profile.\n\nIf we want to make these groups available as Roles in SharePoint we'll need to write a [Rule](https://manage.auth0.com/#/rules) that adds this to the SAML configuration. This rule will only run for the application named **Fabrikam Intranet (SharePoint)**.\n\n```\nfunction (user, context, callback) {\n  if (context.clientName === 'Fabrikam Intranet (SharePoint)') {\n    context.samlConfiguration.mappings = {\n        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier': 'user_id',\n        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress': 'email',\n        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name': 'name',\n        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname': 'given_name',\n        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname': 'family_name',\n        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn': 'upn',\n        'http://schemas.microsoft.com/ws/2008/06/identity/claims/role': 'groups'\n    };\n  }\n\n  callback(null, user, context);\n}\n```\n\nThis will add an additional outgoing claim `http://schemas.microsoft.com/ws/2008/06/identity/claims/role` containing the `groups` and which will be used by SharePoint for authorization.\n\nWhen installing the Claims Provider we need to allow the Role claim to be passed through to SharePoint, by adding it to the claims mapping list:\n\n```\nEnable-Auth0\n  -auth0Domain:\"fabrikam.auth0.com\"\n  ...\n  -claims:@(\n    \"Email|http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n    \"Role|http://schemas.microsoft.com/ws/2008/06/identity/claims/role\",\n    ...)\n  ...\n  -Verbose\n```\n\nBy default a user won't have access to the site.\n\nNow instead of adding that specific user to a SharePoint Group (eg: Contributors) we can now add a **Role** to a SharePoint Group. Here's a sample PowerShell script that shows how to add \"Fabrikam HR\" members to the Contributors group:\n\n```\n$webName = \"http://fabrikam-sp\"\n$groupName = \"Contributors\"\n$roleClaim = \"Fabrikam HR\"\n\n$sts = Get-SPTrustedIdentityTokenIssuer \"Auth0\"\n$claimPrincipal = New-SPClaimsPrincipal -ClaimValue $roleClaim -ClaimType \"http://schemas.microsoft.com/ws/2008/06/identity/claims/role\" -TrustedIdentityTokenIssuer $sts\n\n$web = Get-SPWeb $webName\n$user = New-SPUser -UserAlias $claimPrincipal.ToEncodedString() -Web $web\n\n$group = $web.SiteGroups[$groupName]\n$group.AddUser($user)\n```\n\nAfter adding this claim value to the Contributors group David will be able to access the site and edit its contents.\n\n### User Profile Synchronization\n\nBy default SharePoint is able to synchronize user profile information originating from Active Directory. Now with Auth0 users can come from different types of connections (from social to enterprise) which will require a different approach to synchronize user profiles.\n\nA first approach would be to create a timer job that runs every few hours, queries the Auth0 Users Endpoint and synchronizes the profile information for those users.\n\n```\nusing System;\n\nusing Microsoft.SharePoint;\nusing Microsoft.SharePoint.Administration;\n\nusing Microsoft.Office.Server;\nusing Microsoft.Office.Server.UserProfiles;\n\nnamespace UserProfileSync\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Call the Auth0 Management API - https://docs.auth0.com/api/v2\n\n            using (var site = new SPSite(\"http://servername\"))\n            {\n                var context = SPServiceContext.GetContext(site);\n                var profileManager = new UserProfileManager(context);\n\n                var accountName = \"i:05.t|auth0|john@example.org\";\n                var userProfile = profileManager.GetUserProfile(accountName);\n                userProfile[PropertyConstants.HomePhone].Value = \"+1 594 9392\";\n                userProfile.Commit();\n            }\n        }\n    }\n}\n```\n\nAlternatively this logic could also be implemented as an HttpModule which runs each time the user logs in:\n\n```\npublic class PersistUserClaimsHttpModule : IHttpModule\n{\n    private SPFederationAuthenticationModule FederationModule\n    {\n        get { return HttpContext.Current.ApplicationInstance.Modules[\"FederatedAuthentication\"] as SPFederationAuthenticationModule; }   \n    }\n\n    public void Init(HttpApplication context)\n    {\n        FederationModule.SecurityTokenValidated += OnFederationSecurityTokenValidated;\n    }\n\n    private void OnFederationSecurityTokenValidated(object sender, SecurityTokenValidatedEventArgs e)\n    {\n        // Use e.ClaimsPrincipal\n    }\n}\n```",
  "title": "Integrate with SharePoint 2010/2013",
  "description": "How to integrate with SharePoint 2010/2013, including set up, troubleshooting, accessing logs and next steps.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/cms",
  "markdown": "# CMS Identity Plugins\n\nAuth0 provides Content Management System Plugins/Extensions to integrate your CMS installation with your Auth0 account. These plugins enable Single Sign-on (SSO) for Enterprises, social login and user/password login through all your instances and platforms.\n\nLogin features are implemented through a new Login Widget (powered by Auth0) that enables:\n\n*   SSO with Enterprise Directories (LDAP, AD, Google Workspace, Office365 and SAML Provider)\n    \n*   Shared User/Password between multiple WordPress accounts for SSO\n    \n*   SSO with over 30 [Social Providers](https://auth0.com/docs/identityproviders)\n    \n*   User Management Dashboard\n    \n*   Optional Two Factor Authentication\n    \n*   SSO between WordPress and other applications\n    \n*   Reporting and Analytics\n    \n\n## WordPress Plugin\n\n*   [How does it work?](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/integrate-with-wordpress)\n    \n*   [Installation](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/install-login-by-auth0)\n    \n*   [Configuration](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/configure-login-by-auth0)\n    \n*   [Troubleshoot](https://auth0.com/docs/customize/integrations/cms/wordpress-plugin/troubleshoot-login-by-auth0)\n    \n\n## SharePoint\n\n*   [Github Source](https://github.com/auth0/auth0-sharepoint)",
  "title": "CMS Identity Plugins",
  "description": "Explains CMS Identity Plugins such as WordPress and Joomla",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/authenticating-and-authorizing-a-tessel-device-with-auth0",
  "markdown": "# Authenticating & Authorizing a Tessel device with Auth0\n\n```\nvar http = require('https');\nvar tessel = require('tessel');\n\ntessel.syncClock(function () {\n\n  var device_id = 'tessel-01';\n  var password = 'THE TESSEL PASSWORD';\n\n  authenticate(device_id, password, function(e,token){\n\n    if(e) return console.log(\"Error:\" + e);\n\n    getDeviceProfile(token.access_token, function(e, profile){\n      console.log(\"Device profile:\");\n      console.log(profile);\n    });\n  });\n\n  function getDeviceProfile(token, done){\n    request('{yourDomain}',\n          '/userinfo',\n          'GET',\n          {\n          \"Content-type\": \"application/json\",\n          \"Authorization\": \"Bearer \" + token\n        },\n        null,\n        function(e,response){\n          if(e) return done(e);\n          done(null, JSON.parse(response));\n        });\n  }\n\n  function authenticate(device_id, password, done)\n  {\n    request('{yourDomain}',\n          '/oauth/ro',\n          'POST',\n          {\n          \"Content-type\": \"application/json\",\n        },\n        JSON.stringify({\n            client_id:   '{yourClientId}',\n            username:    device_id,\n            password:    password,\n            connection:  'devices',\n            grant_type:  \"password\",\n            scope: 'openid'\n          }),\n          function(e,response){\n            if(e) return done(e);\n            done(null, JSON.parse(response));\n        });\n  }\n\n  function request(host, path, method, headers, body, done){\n    var options = {\n      hostname: host,\n      path: path,\n      method: method,\n      headers: headers\n    };\n\n    var req = http.request(options, function(res) {\n      res.setEncoding('utf8');\n\n      var response = \"\";\n\n      res.on('data', function (chunk) {\n        response += chunk;\n      });\n\n      res.on('end', function(){\n        done(null, response);\n        });\n    });\n\n    req.on('error', function(e) {\n      done(e);\n    });\n\n    if( body ) req.write(body);\n    req.end();\n  }\n});\n```",
  "title": "Authenticating & Authorizing a Tessel device with Auth0",
  "description": "How to authenticate and authorize a Tessel device with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/marketplace-partners",
  "markdown": "# Marketplace Partners\n\nAt Auth0, we consider **extensibility** to be one of our essential product capabilities. But while our endless options for integration are an excellent way to customize your own unique solution, it can sometimes be difficult and time-consuming for our customers to figure out how to implement them. Enter the [Auth0 Marketplace](https://marketplace.auth0.com/).\n\nWe built the Marketplace as a way to connect our customers with service providers and builders who implement these types of integrations regularly. Listing your integration with Auth0 promotes your company with our customers who are looking to do more with their authentication pipeline.\n\n## Plan your integration\n\nEach integration you build should have a clear and well-explained use case solving a specific customer problem. If multiple customer problems can be solved with integrations between Auth0 and your service, we can list multiple integrations.\n\nUse the pages below to learn more about integrating with Auth0.\n\n#### Defining your Integration Use Case\n\nOur customers need to understand what problem your integration will solve and how it will go about solving it.\n\n[Learn more about integration use cases](https://auth0.com/docs/customize/integrations/marketplace-partners/defining-an-integration-use-case)\n\n#### Introduction to Integration\n\nExplore Auth0 extensibility and all the different ways that Auth0 can be customized.\n\n[Learn more about integrating](https://auth0.com/docs/customize/integrations/marketplace-partners/introduction-to-integrating-with-auth0)\n\n## Build your integration\n\nIntegrations with Auth0 are built on one or more of our extensibility points. [Sign up for a free Auth0 tenant](https://auth0.com/signup), and use our documentation to get your service working with Auth0 and learn how to get listed in our Marketplace.\n\nWe have specific guidance for our most common integrations below. Please contact our partner account team using the link at the bottom of this page if you need an example that's not listed here.\n\n#### Actions\n\nActions Integrations are closed-source, self-contained functions written in JavaScript that execute at specific points in the Auth0 platform. \n\n[Learn how to build an Action Integration](https://auth0.com/docs/customize/integrations/marketplace-partners/actions-integrations-for-partners)\n\nSocial Connection Integrations are OAuth2 sources of identity that provide a profile to Auth0 after a user successfully logs in.\n\n[Learn how to build a Social Connection](https://auth0.com/docs/customize/integrations/marketplace-partners/social-connections-for-partners)\n\n#### SSO Integrations\n\nSSO Integrations use an Auth0 identity to log in, via SAML, to an external service.\n\n[Learn how to build an SSO Integration](https://auth0.com/docs/customize/integrations/marketplace-partners/sso-integrations-for-partners)\n\n## Get listed\n\nOnce you have an integration working, Auth0 will work with you to publish the integration in the [Auth0 Marketplace](http://marketplace.auth0.com/). When you submit your integration you must provide this information:\n\n1.  The business and marketing content for your Auth0 Marketplace listing. This includes your company's description and logo and describes what the integration does.\n    \n2.  The code and configuration you used for the integration. Partners typically submit the code using GitHub.\n    \n3.  An installation guide in Markdown format with instructions on how to configure your service to work with Auth0. Please follow our [Writing Tips for Installation Guides](https://auth0.com/docs/customize/integrations/marketplace-partners/writing-tips-for-installation-guides) when you create this document.\n    \n\nIf you're ready to become a partner and submit your integration to list in the Auth0 Marketplace, please fill out the [Auth0 Marketplace support center](https://autheco.atlassian.net/servicedesk/customer/portal/1). If you ware a new partner, you will need to Apply to become a Marketplace partner, after that you can fill out the \"Submit a new Integration\" form with the information described above.\n\nSee the integration types above for more information about the code, configuration, and documentation that should be included with each integration.\n\n## Additional resources\n\n*   [The Auth0 Marketplace](https://marketplace.auth0.com/)\n    \n*   [Introducing the Auth0 Marketplace](https://auth0.com/blog/introducing-auth0-marketplace/)\n    \n*   [Why and How We Built Auth0 Marketplace (video)](https://avocadolabs.dev/recordings/why-and-how-we-built-auth0-marketplace/)\n    \n*   [Become an Auth0 Partner](https://auth0.com/partners#form)",
  "title": "Marketplace Partners",
  "description": "Learn about integrating with Auth0 as part of the Auth0 Marketplace Community. For current and potential Marketplace Partners.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/connecting-provider-hosted-apps-to-sharepoint-online",
  "markdown": "# Connect Provider Hosted Apps to SharePoint Online\n\nAuth0 can help radically simplify the authentication process for SharePoint Apps. Auth0 will negotiate an Access Token you can the use to call SharePoint APIs.\n\nYou won't need any special libraries. You can use any of the SDKs supported by Auth0.\n\n## 1\\. Register your application in Auth0\n\nJust register a new application in Auth0 as you would normally do: **Applications > NEW**. Pick up any of the SDKs available for detailed instructions. Keep the `client_id` handy, as you will need it in the next step.\n\n## 2\\. Create a package for your application\n\nYou need to obtain a **Client ID** and a **Client Secret** for your application. There are many ways of registering your application depending on the expected usage.\n\n[Register SharePoint Add-ins (Microsoft Docs)](https://docs.microsoft.com/en-us/sharepoint/dev/sp-add-ins/register-sharepoint-add-ins) explains all different ways of registering your application in SharePoint. This step in the tutorial will use the simplest form: using self-registration in a specific tenant (yours).\n\n### Open SharePoint Online\n\nThe URL for the dashboard is `https://{your Office365 tenant}.sharepoint.com/_layouts/15/appregnew.aspx`\n\n### Generate a Client\\_Id and ClientSecret:\n\n![SharePoint - generate client id - generate client secret](https://images.ctfassets.net/cdy7uua7fh8z/2BLGIJdnfbknayoyF4U5wP/70e66c7d10a001e0eb7ffa7aaebfb035/90SvG.png)\n\n### Complete the information in the form:\n\nSince Auth0 is in between your app and the Office 365 infrastructure, you need to use this URL for the app:\n\n**App Domain**:\n\n{yourDomain}\n\n**Redirect URI**:\n\n[https://{yourDomain}/login/callback?SP\\_APP\\_TOKEN&connection=CONNECTION&client\\_id={yourClientId}&redirect\\_uri={https://yourApp/callback}](https://{yourdomain}/login/callback?SP_APP_TOKEN&connection=CONNECTION&client_id={yourClientId}&redirect_uri={https://yourApp/callback})\n\n*   `connection` is just the name you will use in Auth0's connections (such as \"sharepoint\").\n    \n*   `client_id` identifies your app in Auth0 (created in steps 1).\n    \n*   `redirect_uri` is the location in your actual app, where your users will land eventually after all negotiations complete. If you don't specify it, it will always be the app's callback URL defined in Auth0 (it could be localhost)\n    \n\n### Package the app and upload to SharePoint:\n\nComplete the information in your app manifest in Visual Studio:\n\n![SharePoint - Visual Studio - Application Manifest](https://images.ctfassets.net/cdy7uua7fh8z/36dscLHlLHZjJx1rLgrQ7N/8d64ec7a51f4e053627ecb5dfd3c7707/90SEc.png)\n\nNotice the `Query string` will be exactly like the `Redirect URI` you completed before. Then right-click on the project and select `Publish`:\n\nCreate a **Publishing Profile** (you will have to enter the same **Client Id** & **Client Secret** obtained in the SharePoint dashboard).\n\nClick on **Package** and upload the resulting file to SharePoint.\n\n## 3\\. Create the Connection in Auth0\n\nThe last step in the integration is to add a SharePoint connection in Auth0.\n\nYou will need:\n\n*   `Connection Name`. This is an arbitrary name. It has to match with what you entered in step 2.\n    \n*   `Client Id` & `Client Secret`. Also need to match what you entered in step 2.\n    \n*   `Test SharePoint Site Url`. This is the SP site URL used to test the connection. (such as when pressing the 'Try' button on the dashboard). This is never used at runtime because users will always follow the link to your site from within SharePoint.\n    \n\nUsers will install your app from the Office Marketplace. When they click on the link, they will be directed to Auth0, which will negotiate the Access Token for you, and finally to your app. Your app will receive a `User Profile` that will look like this:\n\n![Office Marketplace - Redirect -  User Profile Example](https://images.ctfassets.net/cdy7uua7fh8z/4piqwmx1ONWMd3kjTFMq4I/714545f5cda3ab1d1dd5c620bc96b083/8Xp6x.png)\n\nThe following properties will be included: `cacheKey`, `refresh_token`, `host`, and `site`. These will allow you to call back SharePoint APIs (such as lists).",
  "title": "Connect Provider Hosted Apps to SharePoint Online",
  "description": "How to connect provider hosted apps to SharePoint Online.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/migrate-office365-connections-to-windows-azure-ad",
  "markdown": "# Migrate Office365 Connections to Windows Azure AD\n\nOffice365 has been deprecated. You should migrate your Office365 Connections to Windows Azure AD Connections.\n\nSince early days, we supported authenticating users with Office365. Office365 has always used Windows Azure AD behind the scenes, but there wasn't a good UI to create an \"application\" in Windows Azure AD. That's why you had to create it in the Seller Dashboard. Moving forward Microsoft wants you to use Windows Azure AD and you can now easily create a directory associated with your Office365 account and the application.\n\n## How to migrate to Azure\n\n1.  Create a Windows Azure AD subscription (free)\n    \n2.  Create a Directory (that will be associated with your Office365 account) and an application. To learn more, read [Connect Your App to Microsoft Azure Active Directory](https://auth0.com/docs/waad-clientid).\n    \n\nIf you were using the `user_id` in your application, notice that it will change from `office365|....some-guid....` to `waad|...email....`.",
  "title": "Migrate Office365 Connections to Windows Azure AD",
  "description": "Details migrating Office365 connections to Windows Azure AD.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/office-365-custom-provisioning",
  "markdown": "# Office 365 Custom Provisioning\n\nThe default Office 365 setup includes Active Directory and DirSync/Azure AD Sync Services, which synchronize and provision AD users living in your Azure AD for SSO. In this configuration, Auth0 is the identity provider, we provide Single Sign-on (SSO) for these users.\n\nBut what if you want to allow contractors, partners or even customers to access your Office 365 environment (e.g., SharePoint)? In that case, the default approach is not optimal because these users would need to be created in your AD environment. Instead, you need to custom provision Azure AD users using [Auth0 Rules](https://auth0.com/docs/customize/rules).\n\nCustom provisioning allows you to create users in Azure AD (and effectively Office 365) just as they log in from any connection available in Auth0. (In this case, your rule takes over DirSync's task for any type of connection where DirSync would not work.) This configuration allows you to offer a variety of login options (including, Facebook, LinkedIn, Google Workspace) to your Office 365 environment.\n\n## Prerequisites\n\nBefore you can configure custom provisioning, you must:\n\n*   [Configure Office 365](https://marketplace.auth0.com/integrations/office-365-sso): Register a custom domain and configure Office 365 as a third-party application in Auth0.\n    \n\n## Configure Azure AD\n\nCustom provisioning uses the Azure AD Graph API to provision new users in Azure AD. To access the Azure AD Graph API, you must create an application within the Azure AD Directory that has been linked to the Office 365 subscription:\n\n1.  Log in to the [Azure Portal](https://portal.azure.com/).\n    \n2.  Choose [Azure Active Directory in the left navigation](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Overview).\n    \n3.  Select **App registrations** in the new menu.\n    \n4.  Click on **New application registration**.\n    \n5.  Fill the form:\n    \n    1.  Input a name for the application (such as `Auth0 Provisioning`)\n        \n    2.  Select **Web app / API** as the **Application type**.\n        \n    3.  Insert a sign-on URL. You can enter any valid URL; this won't really be used.\n        \n6.  The recently-created app will appear in the **App registrations** list. Select it.\n    \n7.  In the **Settings** blade (Microsoft call these sections \"blades\"), choose **Keys**.\n    \n8.  Input a **Description** (like `Auth0 Provision`), and choose a **Duration** for the new key. If you choose to issue a non-permanent key, take note of the expiration date and create a reminder to replace the key with a new one before it expires.\n    \n9.  Click to save the key, then copy the **App Key**. This key will be shown only once, and it's needed for the Auth0 rule.\n    \n    ![Integrations - Office 365 - Application key](https://images.ctfassets.net/cdy7uua7fh8z/57fQqQpavwumy5VBoqxFjG/2ad33b1fd2151f64ea9a7ae236b4a3c6/office-365-app-key.png)\n10.  Choose **Required permissions**, and click **Add** in the new blade.\n    \n11.  Select the **Microsoft Graph** API, then check `Read and write directory data` under **Application Permissions**.\n    \n12.  Back in the **Required permissions**, click on the **Grant Permissions** button, and then click **Yes** to grant the requested permissions.\n    \n\nThe following rule shows the provisioning process:\n\n1.  If the user comes from the AD connection, skip the provisioning process (because this will be handled by DirSync).\n    \n2.  If the user was already provisioned in Azure AD, just continue with the login transaction.\n    \n3.  Use the Azure AD Client ID and Key to get an Access Token for the Graph API.\n    \n4.  Create a user in Azure AD.\n    \n5.  Assign a license to the user.\n    \n6.  Continue with the login transaction.\n    \n\nThe username is generated with the `createAzureADUser` function, which by default, generates a username in the format `auth0-c3fb6eec-3afd-4d52-8e0a-d9f357dd19ab@fabrikamcorp.be`. You can change this to whatever you like; just make sure this value is unique for all your users.\n\nMake sure you set the correct values for the `AUTH0_OFFICE365_CLIENT_ID`, `AAD_CUSTOM_DOMAIN`, `AAD_DOMAIN`, `AAD_APPLICATION_ID` and `AAD_APPLICATION_API_KEY` values in your configuration object to make the values available in your rule code. To learn more, read [Store Configuration for Rules](https://auth0.com/docs/customize/rules/configuration).\n\nIn the code, you'll also see that the rule will wait about 15 seconds after the user is provisioned. This is because it takes a few seconds before the provisioned user is available for Office 365.\n\n```\nfunction (user, context, callback) {\n  // Require the Node.js packages that we are going to use.\n  // Check this website for a complete list of the packages available:\n  // https://auth0-extensions.github.io/canirequire/\n  var rp = require('request-promise');\n  var uuidv4 = require('uuid');\n\n  // The name of your Active Directory connection (if using one)\n  var AUTH0_AD_CONNECTION = 'Travel0AD';\n  // The client_id of your Office 365 SSO integration\n  // You can get it from the URL when editing the SSO integration,\n  // it will look like\n  // https://manage.auth0.com/#/externalapps/{the_client_id}/settings\n  var AUTH0_OFFICE365_CLIENT_ID = configuration.AUTH0_OFFICE365_CLIENT_ID;\n  // The main domain of our company.\n  var YOUR_COMPANY_DOMAIN = 'mycompanyurl.com';\n  // Your Azure AD domain.\n  var AAD_DOMAIN = configuration.AAD_DOMAIN;\n  // The Application ID generated while creating the Azure AD app.\n  var AAD_APPLICATION_ID = configuration.AAD_APPLICATION_ID;\n  // The generated API key for the Azure AD app.\n  var AAD_APPLICATION_API_KEY = configuration.AAD_APPLICATION_API_KEY;\n  // The location of the users that are going to access Microsoft products.\n  var AAD_USAGE_LOCATION = 'US';\n  // Azure AD doesn't recognize the user instantly, it needs a few seconds\n  var AAD_USER_CREATE_DELAY = 15000;\n  // The key that represents the license that we want to give the new user.\n  // Take a look in the following URL for a list of the existing licenses:\n  // https://gist.github.com/Lillecarl/3c4727e6dcd1334467e0\n  var OFFICE365_KEY = 'O365_BUSINESS';\n\n  // Only execute this rule for the Office 365 SSO integration.\n  if (context.clientID !== AUTH0_OFFICE365_CLIENT_ID) {\n    return callback(null, user, context);\n  }\n\n  // Skip custom provisioning for AD users.\n  if (context.connection === AUTH0_AD_CONNECTION) {\n    return callback(null, user, context);\n  }\n\n  // If the user is already provisioned on Microsoft AD, we skip\n  // the rest of this rule\n  user.app_metadata = user.app_metadata || {};\n  if (user.app_metadata.office365Provisioned) {\n    return connectWithUser();\n  }\n\n  // Global variables that we will use in the different steps while\n  // provisioning a new user.\n  var token;\n  var userPrincipalName;\n  var mailNickname = user.email.split('@')[0];\n  var uuid = uuidv4.v4();\n  var immutableId = new Buffer(uuid).toString('base64');\n  var userId;\n\n  // All the steps performed to provision new Microsoft AD users.\n  // The definition of each function are below.\n  getAzureADToken()\n    .then(createAzureADUser)\n    .then(getAvailableLicenses)\n    .then(assignOffice365License)\n    .then(saveUserMetadata)\n    .then(waitCreateDelay)\n    .then(connectWithUser)\n    .catch(callback);\n\n  // Requests an Access Token to interact with Windows Graph API.\n  function getAzureADToken() {\n    var options = {\n      method: 'POST',\n      url: 'https://login.windows.net/' + AAD_DOMAIN + '/oauth2/token?api-version=1.5',\n      headers: {\n        'Content-type': 'application/json',\n        },\n      json: true,\n      form: {\n        client_id: AAD_APPLICATION_ID,\n        client_secret: AAD_APPLICATION_API_KEY,\n        grant_type: 'client_credentials',\n        resource: 'https://graph.windows.net'\n      },\n    };\n\n    return rp(options);\n  }\n\n  // Gets the Access Token requested above and assembles a new request\n  // to provision the new Microsoft AD user.\n  function createAzureADUser(response) {\n    token = response.access_token;\n    userPrincipalName = 'auth0-' + uuid + '@' + YOUR_COMPANY_DOMAIN;\n\n    var options = {\n      url: 'https://graph.windows.net/' + AAD_DOMAIN + '/users?api-version=1.6',\n      headers: {\n        'Content-type': 'application/json',\n        'Authorization': 'Bearer ' + token\n      },\n      json: true,\n      body: {\n        accountEnabled: true,\n        displayName: user.nickname,\n        mailNickname: mailNickname,\n        userPrincipalName: userPrincipalName,\n        passwordProfile: {\n          password: immutableId,\n          forceChangePasswordNextLogin: false\n        },\n        immutableId: immutableId,\n        usageLocation: AAD_USAGE_LOCATION\n      },\n    };\n\n    return rp(options);\n  }\n\n  // After provisioning the user, we issue a request to get the list\n  // of available Microsoft products licenses.\n  function getAvailableLicenses(response) {\n    userId = response.objectId;\n    var options = {\n      url: 'https://graph.windows.net/' + AAD_DOMAIN + '/subscribedSkus?api-version=1.6',\n      json: true,\n      headers: {\n        'Content-type': 'application/json',\n        'Authorization': 'Bearer ' + token\n      }\n    };\n    return rp(options);\n  }\n\n  // With the licenses list, we iterate over it to get the id (skuId) of the\n  // license that we want to give to the new user (office 365 in this case).\n  // We also issue a new request to the Graph API to tie the user and the\n  // license together.\n  function assignOffice365License(response) {\n    var office365License;\n\n    for (var i = 0; i < response.value.length; i++) {\n      if (response.value[i].skuPartNumber === OFFICE365_KEY) {\n        office365License = response.value[i].skuId;\n        break;\n      }\n    }\n\n    var options = {\n      url: ' https://graph.windows.net/' + AAD_DOMAIN + '/users/' + userId + '/assignLicense?api-version=1.6',\n      headers: {\n        'Content-type': 'application/json',\n        'Authorization': 'Bearer ' + token\n      },\n      json: true,\n      body: {\n        'addLicenses': [\n          {\n            'disabledPlans': [],\n            'skuId': office365License\n          }\n        ],\n        'removeLicenses': []\n      }\n    };\n    return rp(options);\n  }\n\n  // After provisioning the user and giving a license to them, we record\n  // (on Auth) that this Google Workspace user has already been provisioned. We\n  // also record the user's principal username and immutableId to properly\n  // redirect them on future logins.\n  function saveUserMetadata() {\n    user.app_metadata = user.app_metadata || {};\n\n    user.app_metadata.office365Provisioned = true;\n    user.app_metadata.office365UPN = userPrincipalName;\n    user.app_metadata.office365ImmutableId = immutableId;\n\n    return auth0.users.updateAppMetadata(user.user_id, user.app_metadata);\n  }\n\n  // As mentioned, Windows Graph API needs around 10 seconds to finish\n  // provisioning new users (even though it returns ok straight away)\n  function waitCreateDelay() {\n    return new Promise(function (resolve) {\n      setTimeout(function() {\n        resolve();\n      }, AAD_USER_CREATE_DELAY);\n    });\n  }\n\n  // Adds the principal username and immutableId to the user object and ends\n  // the rule.\n  function connectWithUser() {\n    user.upn = user.app_metadata.office365UPN;\n    user.inmutableid = user.app_metadata.office365ImmutableId;\n      return callback(null, user, context);\n  }\n}\n```\n\n## User experience\n\nThe easiest way for your external users to authenticate is by using Identity Provider-initiated login.\n\nYou must redirect your users to the following URL (e.g., using a \"smart link\" like `https://office.travel0.com`):\n\n```\nhttps://{yourDomain}/login?client=AUTH0_OFFICE365_CLIENT_ID&protocol=wsfed&state=&redirect_uri=&\n```\n\nThis will show them the Auth0 login page after which they'll be redirected to Office 365. It will be important to explain external users that this is the only way they can authenticate, since the Office 365 login page does not support Home Realm Discover for these external users. This also means that, when they try to open a link, they'll need to visit the smart link first before the can access the link they tried to open.\n\n![Integrations - Office 365 - Different connections](https://images.ctfassets.net/cdy7uua7fh8z/37HoaM7uu4rNScJ2uZMzx9/22f0a556942f08b41cb63fb8d6d97c70/office-365-different-connections.png)\n\nIn this example, Travel0 enabled a few social accounts and a database connection for their Office 365 third-party application in Auth0.\n\n## Deep linking\n\nCertain implementations might require deep linking (for example, to SharePoint Online). In this case, a smart link needs to be constructed, which starts on the Office 365 login page:\n\n```\nhttps://login.microsoftonline.com/login.srf?wa=wsignin1.0&whr={yourCustomDomain}&wreply={deepLink}\n```\n\nThe first parameter, `{yourCustomDomain}`, should be the domain you've configured in Azure AD for <dfn data-key=\"single-sign-on\">Single Sign-on (SSO)</dfn> (e.g., `travel0.com`). By specifying this as the `whr`, Azure AD will know it needs to redirect to Auth0 instead of showing the login page.\n\nThe `DEEP_LINK` parameter should be an encoded URL within Office 365 (for example, a page in SharePoint Online or Exchange).\n\nExample URL:\n\n```\nhttps://login.microsoftonline.com/login.srf?wa=wsignin1.0&whr=travel0.com&wreply=https%3A%2F%2Ftravel0%2Esharepoint%2Ecom\n```",
  "title": "Office 365 Custom Provisioning",
  "description": "Learn how to set up Microsoft Office 365 custom provisioning.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/integrations/aws-api-gateway-custom-authorizers",
  "markdown": "# Secure AWS API Gateway Endpoints Using Custom Authorizers\n\nSecure [](https://aws.amazon.com/api-gateway/)AWS API Gateway endpoints using custom authorizers that accept Auth0-issued access tokens. To do this, you configure your API with [](https://aws.amazon.com/api-gateway/)API Gateway, create and configure your [](https://aws.amazon.com/lambda/)AWS Lambda functions (including the custom authorizers) to secure your API endpoints, and implement the authorization flow so that your users can retrieve the access tokens needed to gain access to your API from Auth0.\n\nTo learn more, visit [AWS Lambda Overview](https://aws.amazon.com/lambda/) once you log into your [AWS API Gateway](https://aws.amazon.com/api-gateway/).\n\nThe API Gateway extends the capabilities of Lambda by adding a service layer in front of your Lambda functions to extend security, manage input and output message transformations, and provide capabilities like throttling and auditing. A serverless approach simplifies your operational demands since concerns like scaling out and fault tolerance are now the responsibility of the compute service that is executing your code.\n\nThe custom authorizers will:\n\n*   Confirm that the access token has been passed via the `authorization` header of the request to access the API.\n    \n*   Verify the RS256 signature of the Access Token using a public key obtained via a [](https://auth0.com/docs/tokens/concepts/jwks)JWKS endpoint.\n    \n*   Ensure the access token has the required Issuer `iss` and audience `aud` claims.\n    \n\nUse the following steps to use custom authorizers:\n\n1.  [Create an Auth0 API](#create-an-auth0-api)\n    \n2.  [](https://auth0.com/docs/integrations/aws-api-gateway/part-2)[Import and deploy the AWS API Gateway API](#import-and-deploy-the-aws-api-gateway-api)\n    \n3.  [Create the custom authorizers](#create-the-custom-authorizers)\n    \n4.  [Secure the API using custom authorizers](#secure-the-api-using-custom-authorizers)\n    \n5.  [Test your deployment](#test-your-deployment)\n    \n\nTo read more about signing algorithms, read [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms). For more details on using JWKS, visit [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets).\n\n[According to Amazon](http://docs.aws.amazon.com/apigateway/latest/developerguide/use-custom-authorizer.html), an API Gateway custom authorizer is a \"Lambda function you provide to control access to your API using bearer token authentication strategies, such as OAuth or SAML.\"\n\nWhenever someone (or some program) attempts to call your API, API Gateway checks to see if there's a custom authorizer configured for the API.\n\nIf **there is a custom authorizer for the API**, API Gateway calls the custom authorizer and provides the authorization token extracted from the request header received.\n\nYou can use the custom authorizer to implement different types of authorization strategies, including [](https://auth0.com/docs/tokens/concepts/jwts)JWT verification, to return IAM policies authorizing the request. If the policy returned is invalid or if the permissions are denied, the API call fails.\n\nFor a valid policy, API caches the returned policy, associating it with the incoming token and using it for the current and subsequent requests. You can configure the amount of time for which the policy is cached. The default value is `300` seconds and the maximum length of caching is `3600` seconds (you can also set the value to 0 to disable caching).\n\nTo read more, visit [What is Amazon API Gateway?](http://docs.aws.amazon.com/apigateway/latest/developerguide/use-custom-authorizer.html) in the Amazon Developer's Guide. For more information on JWT verification, review our [JSON Web Token](https://auth0.com/docs/secure/tokens/json-web-tokens) article.\n\n## Prerequisite\n\nYou need to [sign up for an AWS account](https://portal.aws.amazon.com/gp/aws/developer/registration/index.html). This grants you access to the AWS features, including API Gateway and Lambda. All new members receive twelve months of free tier access to AWS.\n\n## Create an Auth0 API\n\nConfigure the APIs consumed by the applications that successfully authorize.\n\n1.  Go to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and select **Create API**.\n    \n2.  Enter values for the following fields, and select **Create**.\n    \n    | Field | Description |\n    | --- | --- |\n    | Name | A friendly name for your API. This is the name you'll see in your list of Auth0 APIs. |\n    | Identifier | A logical identifier for your API. We recommend formatting this identifier like a URL `https://your-api-gateway`. |\n    | Signing Algorithm | The algorithm you want Auth0 to use to sign the issued Access Tokens. To learn more, see [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms). |\n    \n\nTo see the details of your newly-created API, refer to the **Settings** view.\n\n![Dashboard - Create API - AWS API Gateway](https://images.ctfassets.net/cdy7uua7fh8z/4P1N7SSCXUF1SfyC8SXTiO/421e1cfb0515ae3271d72d1d0e7a203e/Dashboard_-_APIs_-_Create_API_Gateway.png)\n\nCreating an API also creates a Machine to Machine Application for use with the API. You can see this application listed as **Authorized** under the **Machine to Machine Application** view. Take note of the Client ID; you will need it in part 3 of this tutorial.\n\n## Import and deploy the AWS API Gateway API\n\nIn this step, you will:\n\n*   Import an API into API Gateway\n    \n*   Test an API import\n    \n*   Deploy an API for use with any front-end applications\n    \n*   Test an API deployment\n    \n\n### Import and configure the Pets API\n\n1.  Log in to your AWS account, and using the **Services** drop-down located in the top navigation bar, go to the **API Gateway** Console.\n    \n2.  If you've previously created an API, simply navigate to the API Gateway Console and click **Create API**. You'll be given the option to create the **Example API** on the **Create new API** form. If you've never created an API using API Gateway, you'll see the following screen. Click **Get Started** to proceed.\n    \n    ![AWS API Gateway - Get Started](https://images.ctfassets.net/cdy7uua7fh8z/3MX6jO6ZzTqEWNZaWps0j5/4b97df023e694e452d4f34f03d15d21c/aws-pt1-1.png)\n    \n    You'll see a pop-up message welcoming you to API Gateway. Click **OK** to proceed.\n    \n3.  On the **Create new API** form, you'll see that **Example API** is selected by default, and there's an example API defined in the editor. We'll use this API for the rest of our tutorial, so begin the API creation process by clicking **Import**.\n    \n    ![AWS API Gateway - Example API](https://images.ctfassets.net/cdy7uua7fh8z/8b4yGZNUwCNRYovU203Au/d010702b68635ef7e1864554c3a3826f/aws-pt1-4.png)\n    \n    When done, AWS displays a message indicating that your API created and populated with the provided data. Notice the API already has methods associated with it (namely, `GET` and `POST`). You can view the details of a method, modify its configuration, or test the method invocation by clicking the method name from the resource tree.\n    \n    ![AWS API Gateway - Resources Tree](https://images.ctfassets.net/cdy7uua7fh8z/1COXG4sI0DNSM4NIMEtma9/9cc6104e234ac25d1098fd92f1183bc1/aws-pt1-5a.png)\n\n### Test your API\n\nTo test your API, click **POST** under `/pets`. This brings up the **Method Execution** window that provides an overview of the `POST` method's structure and behaviors:\n\n*   **Method Request** and **Method Response**: the API's interface with the front-end\n    \n*   **Integration Request** and **Integration Response**: the API's interface with the back-end\n    \n\nWe can use this area to test the API.\n\n1.  Click **Test** (shown on the **Client** sliver located in the middle of the page). You'll be redirected to the `/pets - POST - Method Test` page. Scroll to the bottom of the page, and provide the following snippet as the **Request Body**:\n    \n    ```\n    {\"type\": \"dog\", \"price\": 249.99}\n    ```\n    \n    The request body indicates the attributes of the pet we want to add to the database, as well as the cost for the pet. ![AWS API Gateway - Request Body](https://images.ctfassets.net/cdy7uua7fh8z/5XKCxyYc5nBCsqln27HVLF/bcd9c16f9e3405fda8cc44f455cb819b/aws-pt1-5d.png)\n2.  Click **Test** to proceed. You'll see the results of the test at the right side of the page.\n    \n    ![AWS API Gateway - Test Results](https://images.ctfassets.net/cdy7uua7fh8z/2cwnpb0irU5DOVKCjcjnil/986f046738bc3b0f79145daa7b86ff3c/aws-pt1-5e.png)\n\n### Deploy the API\n\nThe test we just completed was done using the API Gateway console. To use the API with a different application, you'll need to deploy the API to a stage.\n\n1.  From the **Actions** menu, select **Deploy API**.\n    \n2.  Provide the following values, and click **Deploy**.\n    \n    | **Parameter** | **Value** |\n    | --- | --- |\n    | **Deployment stage** | Choose `[New Stage]` |\n    | **Stage name** | Provide a name for your stage |\n    | **Stage description** | Provide a description for your stage |\n    | **Deployment description** | Provide a description for your API deployment |\n    \n\n### Test the deployment\n\nWhen the API has successfully deployed, you'll be redirected to the **Test Stage Editor**. You can, at this point, test the API to see if it deployed correctly.\n\n1.  At the top of the **Test Stage Editor** window is a blue banner with your **Invoke URL**. This is the URL used to invoke the `GET` endpoint of your API. Click on the link to submit the `GET / method` request in a browser. This should result in the following success response:\n    \n    ![AWS API Gateway - Deploy Test Response](https://images.ctfassets.net/cdy7uua7fh8z/7d8340OcAtOF8GvBtihRBt/958eff065c665682ef53b9eedae77a8e/aws-pt1-8.png)\n2.  In the **Stages** page, expand the tree under **Test**. Click **GET** under `/pets/{petId}`.\n    \n    ![AWS API Gateway - Get Pet ID](https://images.ctfassets.net/cdy7uua7fh8z/2QzVCjIndpP9EQ4VUxVzZc/5c2afef3f8c83004b35636557c9ec59e/aws-pt1-9.png)\n3.  You'll see an **Invoke URL** displayed in the blue banner at the top of the window. The final portion, `{petID}`, stands for a path variable. Replace this variable with `1`, and navigate to the new URL using your browser. You should receive an HTTP 200 request with the following JSON payload:\n    \n    ```\n    {\n      \"id\": 1,\n      \"type\": \"dog\",\n      \"price\": 249.99\n    }\n    ```\n    \n\n## Create the custom authorizers\n\nNow that we have a fully functional API that's managed by API Gateway, secure this API so only those with the appropriate authorization may access the back-end behind the API.\n\nUse API Gateway's custom request authorizers to authorize your APIs using bearer token authorization strategies, such as OAuth 2.0 or SAML. For each incoming request, the following happens:\n\n1.  API Gateway checks for a properly-configured custom authorizer.\n    \n2.  API Gateway calls the custom authorizer (which is a Lambda function) with the authorization token.\n    \n3.  If the authorization token is valid, the custom authorizer returns the appropriate AWS Identity and Access Management (IAM) policies.\n    \n4.  API Gateway uses the policies returned in step 3 to authorize the request.\n    \n\n### Prepare the custom authorizer\n\nYou can [download a sample custom authorizer](https://github.com/auth0-samples/jwt-rsa-aws-custom-authorizer) that supports Auth0-issued tokens. Afterward, you'll need to customize the files so that the custom authorizer works for your environment.\n\n1.  Unzip the folder containing the sample files you downloaded above to the location of your choice, and navigate to the folder using the command line.\n    \n2.  Within the sample folder, run `npm install` to install the Node.js packages required for deployment; AWS requires that these files be included in the bundle you will upload to AWS during a later step.\n    \n3.  Configure your local environment with a `.env` file. You can copy the `.env.sample` file (while simultaneously renaming it `.env`) using `cp .env.sample .env`. Make the following changes:\n    \n    | **Parameter** | **Value** |\n    | --- | --- |\n    | **`TOKEN_ISSUER`** | The issuer of the token. If Auth0 is the token issuer, use `https://{yourDomain}/`. Be sure to include the trailing slash. |\n    | **`JWKS_URI`** | The URL of the JWKS endpoint. If Auth0 is the token issuer, use `https://{yourDomain}/.well-known/jwks.json` |\n    | **`AUDIENCE`** | The **identifier** value of the API you created in the Create an Auth0 API section above. |\n    \n    As an example, the text of your `.env` file should look something like this when complete:\n    \n    ```\n    JWKS_URI=https://{yourDomain}/.well-known/jwks.json\n    AUDIENCE=https://your-api-gateway\n    TOKEN_ISSUER=https://{yourDomain}/\n    ```\n    \n\n### Test the custom authorizer locally\n\nObtain a valid JWT access token. There are multiple ways you can get one and the method you choose depends on your application's type, trust level, or overall end-user experience. For more information, review [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens).\n\n1.  You can get a test token for your API by navigating to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), selecting your API, and selecting **Test**.\n    \n2.  Create a local `event.json` file containing the token. You can copy the sample file (run `cp event.json.sample event.json`). Replace `ACCESS_TOKEN` with your JWT token, and `methodArn` with the appropriate ARN value for the `GET` method of your API.\n    \n\nTo get the `methodArn`:\n\n1.  Using the API Gateway Console, open the **PetStore** API.\n    \n2.  In the left-hand navigation, select **Resources**.\n    \n3.  In the middle **Resources** panel, expand the resource tree. Underneath `/pets`, select **GET**.\n    \n4.  In the **Method Request** box, you'll see the **ARN**.\n    \n5.  Run the test using `npm test`.\n    \n\nThe test uses the [](https://www.npmjs.com/package/lambda-local)lambda-local package to test the custom authorizer using your token. If the test was successful, you'll see output similar to the following:\n\n```\nMessage\n------\n{\n    \"principalId\": \"C8npTEMVnBrILsBTI91MOh6dfuZbPVAU@clients\",\n    \"policyDocument\": {\n        \"Version\": \"2012-10-17\",\n        \"Statement\": [\n            {\n                \"Action\": \"execute-api:Invoke\",\n                \"Effect\": \"Allow\",\n                \"Resource\": \"arn:aws:execute-api:us-east-1:1234567890:apiId/stage/method/resourcePath\"\n            }\n        ]\n    },\n    \"context\": {\n        \"scope\": \"FULL_LIST_OF_SCOPES\"\n    }\n}\n```\n\nIf the value of `Effect` is `Allow`, your authorizer would've allowed the call to API Gateway.\n\nTo learn more, visit [Lambda-local](https://www.npmjs.com/package/lambda-local) at NPM.\n\n### Create the IAM role\n\nThe IAM role has the required permissions to call Lambda functions; before we can proceed with our custom authorizer, we'll need to create an IAM role that can call our custom authorizer whenever API Gateway receives a request for access.\n\n1.  Log in to AWS, and navigate to the [IAM Console](https://console.aws.amazon.com/iam). In the left-hand navigation, select **Roles**.\n    \n2.  Select **Create new role**.\n    \n3.  Under **AWS service**, select the **AWS Lambda** row, then **Next: Permissions**.\n    \n4.  On the **Attach permissions policy** screen, select the **AWSLambdaRole**. You can use the provided filter to narrow down the list of options. Select **Next: Tags**, then select **Next: Review** to proceed.\n    \n5.  On the **Review** screen, provide a **Role name**, such as `Auth0Integration`. Leave the rest of the fields as is. Select **Create role**.\n    \n6.  Once AWS has created your role, you'll be directed back to the **Roles** page of IAM. Select your new role.\n    \n7.  On the **Summary** page for the role you've just created, select the **Trust relationships** view.\n    \n8.  Select **Edit trust relationship**, and populate the **Policy Document** field with the following JSON snippet:\n    \n    ```\n    {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n        \"Effect\": \"Allow\",\n        \"Principal\": {\n            \"Service\": [\n            \"apigateway.amazonaws.com\",\n            \"lambda.amazonaws.com\"\n            ]\n        },\n        \"Action\": \"sts:AssumeRole\"\n        }\n    ]\n    }\n    ```\n    \n9.  Click **Update Trust Policy**.\n    \n10.  You'll be redirected back to the **Summary** page. Copy down the **Role ARN** value for later use.\n    \n    ![undefined](https://images.ctfassets.net/cdy7uua7fh8z/1ki5GDOZenh5WRgpbWwzC8/76f415684f08510b4206559032880a59/pt2-10.png)\n\n### Create the Lambda function and deploy the custom authorizer\n\nNow that you've configured your custom authorizer for your environment and tested it to see it works, deploy it to AWS.\n\n1.  Create a bundle that you can upload to AWS by running `npm run bundle`. This generates a `custom-authorizer.zip` bundle containing the source, configuration, and node modules required by AWS Lambda.\n    \n2.  Navigate to the [Lambda console](https://console.aws.amazon.com/lambda), and click **Create function**.\n    \n3.  On the **Select blueprint** page, click **Author from scratch** to create a blank function. Under **Basic information**, provide values for the following parameters:\n    \n    | **Parameter** | **Value** |\n    | --- | --- |\n    | **Name** | A name for your Lambda function, such as `jwtRsaCustomAuthorizer` |\n    | **Description** | A description for your Lambda function (optional) |\n    | **Runtime** | Select `Node.js 10.x` |\n    \n4.  Click **Create Function** to continue.\n    \n5.  On the **Configuration** page of your function, scroll down to the **Function Code** section.\n    \n6.  Select **Upload a .ZIP file** as the **Code entry type**.\n    \n7.  Click **Upload** and select the `custom-authorizer.zip` bundle you created earlier.\n    \n8.  Then, create the following three **Environment variables**. Note that this information is identical to that which is the `.env` file.\n    \n    | **Parameter** | **Value** |\n    | --- | --- |\n    | **`TOKEN_ISSUER`** | The issuer of the token. If Auth0 is the token issuer, use `https://{yourDomain}/` |\n    | **`JWKS_URI`** | The URL of the JWKS endpoint. If Auth0 is the token issuer, use `https://{yourDomain}/.well-known/jwks.json` |\n    | **`AUDIENCE`** | The **identifier** value of the API you created in step 1. |\n    \n9.  In the **Execution role** section, select **Use an existing role** then select the IAM role you created previously as the **Existing role**.\n    \n10.  Under **Basic settings**, set **Timeout** to **30** sec.\n    \n11.  Click **Save**.\n    \n12.  To test the Lambda function you just created, click **Test** in the top-right corner.\n    \n13.  Copy the contents of your `event.json` file into the **Configure test event** form. You can use the default \"Hello World\" event template.\n    \n14.  Click **Create**.\n    \n15.  Run your test by selecting it and clicking **Test**. If the test was successful, you'll see: \"Execution result: succeeded\". Expanding the output window should show a message similar to the one you received after your successful local test.\n    \n    ![undefined](https://images.ctfassets.net/cdy7uua7fh8z/8Xr9yXq8LwOChAbQkDZlJ/0905bbce96f257716a67376f17a0c975/pt2-19.png)\n\n### Configure API Gateway custom authorizer\n\n1.  Return to API Gateway Console and open the **PetStore** API we created earlier.\n    \n2.  Using the left-hand navigation, open **Authorizers** and select **Create New Authorizer**, then set the following parameters, and click **Create**.\n    \n    | **Parameter** | **Value** |\n    | --- | --- |\n    | **Name** | `jwt-rsa-custom-authorizer` |\n    | **Type** | Select **Lambda** |\n    | **Lambda Region** | Use the region for the Lambda function you created previously |\n    | **Lambda Function** | `jwtRsaCustomAuthorizer` |\n    | **Lambda Invoke Role** | The IAM Role ARN you copied above |\n    | **Lambda Event Payload** | Select **Token** |\n    | **Token Source** | `Authorization` |\n    | **Token Validation** | `^Bearer [-0-9a-zA-z\\.]*$` |\n    | **TTL (seconds)** | `3600` |\n    \n3.  After AWS creates the authorizer and the page refreshes, test your authorizer by clicking **Test** and providing the Auth0 token (`Bearer ey...`) you previously used. If the test was successful, you'll see a response similar to the following.\n    \n    ![undefined](https://images.ctfassets.net/cdy7uua7fh8z/5lx86XsQEJtxVikZJ4lC2C/c2a5c24a31b9cb4b6540267828bbd3a2/pt2-26.png)\n\n## Secure the API using custom authorizers\n\nTo learn how to secure your API's endpoints, see the Amazon API Gateway developer guide article: [Use API Gateway Lambda Authorizers](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html).\n\n### Configure API Gateway resources to use the custom authorizer\n\n1.  Log in to AWS, and navigate to the [API Gateway Console](http://console.aws.amazon.com/apigateway).\n    \n2.  Open the **PetStore** API we created in step 2 of this tutorial. Under the **Resource** tree in the center pane, select the **GET** method under the `/pets` resource.\n    \n    ![undefined](https://images.ctfassets.net/cdy7uua7fh8z/3Z9Gmy20NDr9Hb9Yk0piXF/0c7572fc188e13106d9340562580e5e0/pt3-2.png)\n3.  Select **Method Request**.\n    \n4.  Under **Settings**, click the **pencil** icon to the right of **Authorization** and choose the `jwt-rsa-custom-authorizer` custom authorizer you created in [](https://auth0.com/docs/integrations/aws-api-gateway/part-3)step 3.\n    \n5.  Click the **check mark** icon to save your choice of custom authorizer. Make sure the **API Key Required** field is set to `false`.\n    \n\n### Deploy the API\n\nTo make your changes public, deploy your API.\n\n1.  From the **Actions** menu, select **Deploy API**.\n    \n2.  Provide the following values, and click **Deploy**:\n    \n    | **Parameter** | **Value** |\n    | --- | --- |\n    | **Deployment stage** | Choose `[New Stage]` |\n    | **Stage name** | Provide a name for your stage |\n    | **Stage description** | Provide a description for your stage |\n    | **Deployment description** | Provide a description for your API deployment |\n    \n\nIf successful, you'll be redirected to the **Test Stage Editor**. Note the **Invoke URL** provided in the blue ribbon at the top because you need this to test your deployment.\n\n## Test your deployment\n\nTo test your deployment, make a `GET` call to the **Invoke URL** you noted in the previous step. If this test fails, check that you obtained the JWT access token correctly.\n\nFor details, see [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens).\n\n*   [cURL](#02d0324c159c4503acf1d5346a852ca4_shell)\n*   [C#](#02d0324c159c4503acf1d5346a852ca4_csharp)\n*   [Go](#02d0324c159c4503acf1d5346a852ca4_go)\n*   [Java](#02d0324c159c4503acf1d5346a852ca4_java)\n*   [Node.JS](#02d0324c159c4503acf1d5346a852ca4_node)\n*   [Obj-C](#02d0324c159c4503acf1d5346a852ca4_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://%7ByourInvokeUrl%7D/pets\n```\n\n```\nvar client = new RestClient(\"https://%7ByourInvokeUrl%7D/pets\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourInvokeUrl%7D/pets\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourInvokeUrl%7D/pets\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {method: 'GET', url: 'https://%7ByourInvokeUrl%7D/pets'};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourInvokeUrl%7D/pets\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourInvokeUrl%7D/pets\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nconn.request(\"GET\", \"%7ByourInvokeUrl%7D/pets\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourInvokeUrl%7D/pets\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourInvokeUrl%7D/pets\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Secure AWS API Gateway Endpoints Using Custom Authorizers",
  "description": "How to use secure AWS API Gateway using custom authorizers that accept Auth0-issued access tokens.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations/authenticate-devices-using-mqtt",
  "markdown": "# Authenticating & Authorizing Devices using MQTT with Auth0\n\n[](http://en.wikipedia.org/wiki/MQ_Telemetry_Transport)MQTT is a lightweight protocol often used for devices to communicate with other systems. It is designed for the **publish/subscribe** messaging pattern. You can read more about [MQTT](http://en.wikipedia.org/wiki/MQ_Telemetry_Transport) on Wikipedia.\n\nGenerally speaking there are 3 components:\n\n1.  A `publisher` of messages.\n    \n2.  A `subscriber` to messages.\n    \n3.  A `broker` that connects one and the other.\n    \n\nThere's a notion of `topics` (a.k.a. as `channels` or `subjects`) which messages are associated with. Topics are used to route messages between publishers and subscribers.\n\nThe MQTT protocol supports a basic authentication mechanism based on `usernames` & `passwords`. These credentials are sent with the `CONNECT` message.\n\nThis article shows an integration between nodejs based MQTT broker: [mosca](https://github.com/mcollina/mosca) and [Auth0](http://auth0.com/). In this example, Auth0 is used to **authenticate** `publishers` and `subscribers` to the broker, and then **authorize** routing of messages.\n\n![MQTT Data Flow Diagram](https://images.ctfassets.net/cdy7uua7fh8z/1BAQm0lXvF7A3VqIciOagV/776a17e3372964acc3ac67a71a026e06/2023-09-22_13-15-29.png)\n\n## Components of the solution\n\n### The Broker\n\n**mosca** is straightforward to host and can be embedded in other servers. For the purpose of this sample, we simply self-host a **mosca** server:\n\n```\nvar mosca = require('mosca')\nvar Auth0Mosca = require('auth0mosca');\n\nvar settings = {\n  port: 9999,\n};\n\n//'Thermostats' is a Database connection where all devices are registered.\nvar auth0 = new Auth0Mosca('https://eugeniop.auth0.com', '{Your Auth0 ClientID}', '{Your Auth0 Client Secret}','Thermostats');\n\n//Setup the Mosca server\nvar server = new mosca.Server(settings);\n\n//Wire up authentication & authorization to mosca\nserver.authenticate = auth0.authenticateWithCredentials();\nserver.authorizePublish = auth0.authorizePublish();\nserver.authorizeSubscribe = auth0.authorizeSubscribe();\n\nserver.on('ready', setup);\n\n// Fired when the mqtt server is ready\nfunction setup() {\n    console.log('Mosca server is up and running');\n}\n\nserver.on('clientConnected', function(client) {\n  console.log('New connection: ', client.id );\n});\n```\n\nThis creates a server listening for MQTT messages on port 9999. **mosca** allows you to override the 3 functions used to authenticate and authorize operations.\n\nIn this sample, we are using a very simple module `auth0mosca` to perform these functions. Auth0 is wired up to **mosca**.\n\n### The Auth0Mosca module\n\nThis little [module](https://www.npmjs.org/package/auth0mosca) provides the 4 functions used by **mosca**, `authenticateWithCredentials`, `authenticateWithJWT`, `authorizePublish` and `authorizeSubscribe`:\n\n```\nvar request = require('request');\nvar jwt = require('jsonwebtoken');\n\nfunction Auth0Mosca(auth0Namespace, clientId, clientSecret, connection)\n{\n  this.auth0Namespace = auth0Namespace;\n  this.connection = connection;\n  this.clientId = clientId;\n  this.clientSecret = clientSecret;\n}\n\nAuth0Mosca.prototype.authenticateWithJWT = function(){\n\n  var self = this;\n\n  return function(client, username, password, callback) {\n\n    if( username !== 'JWT' ) { return callback(\"Invalid Credentials\", false); }\n\n    // console.log('Password:'+password);\n\n    jwt.verify(password, self.clientSecret, function(err,profile){\n          if( err ) { return callback(\"Error getting UserInfo\", false); }\n          console.log(\"Authenticated client \" + profile.user_id);\n          console.log(profile.topics);\n          client.deviceProfile = profile;\n          return callback(null, true);\n        });\n  }\n}\n\nAuth0Mosca.prototype.authenticateWithCredentials = function(){\n\n  var self = this;\n\n  return function(client, username, password, callback) {\n    \n    var data = {\n        client_id:   self.clientId, // {client-name}\n        username:    username.toString(),\n        password:    password.toString(),\n        connection:  self.connection,\n        grant_type:  \"password\",\n        scope: 'openid name email' //Details: https:///scopes\n    };\n\n    request.post({\n        headers: {\n                \"Content-type\": \"application/json\"\n            },\n        url: self.auth0Namespace + '/oauth/ro',\n        body: JSON.stringify(data)\n      }, function(e,r,b){\n        if(e){\n          console.log('Error in Authentication');\n          return callback(e,false);\n        }\n        var r = JSON.parse(b);\n\n        if( r.error ) { return callback( r, false); }\n\n        jwt.verify(r.id_token, self.clientSecret, function(err,profile){\n          if( err ) { return callback(\"Error getting UserInfo\", false); }\n          client.deviceProfile = profile;\n          return callback(null, true);\n        });\n    });\n  }\n}\n\nAuth0Mosca.prototype.authorizePublish = function() {\n  return function (client, topic, payload, callback) {\n   callback(null, client.deviceProfile && client.deviceProfile.topics && client.deviceProfile.topics.indexOf(topic) > -1);\n  }\n}\n\nAuth0Mosca.prototype.authorizeSubscribe = function() {\n  return function(client, topic, callback) {\n  callback(null, client.deviceProfile && client.deviceProfile.topics && client.deviceProfile.topics.indexOf(topic) > -1);\n}\n\nmodule.exports = Auth0Mosca;\n```\n\n`authenticateWithCredentials` uses the [OAuth2 Resource Owner Password Credential Grant](https://auth0.com/docs/authenticate/protocols) to authenticate the broker and all connections to it. Each time a `publisher` or a `subscriber` send a **CONNECT** message to the broker the `authenticate` function is called. In it we call the Auth0 endpoint and forward the device's `username`/`password`. Auth0 validates this against its account store (that is the first `request.post` in the code). If successful, it validates and parses the JSON Web Token (JWT) to obtain the device profile and adds it to the `client` object that represents either the `subscriber` or the `publisher`. That's done in the `jwt.verify` call.\n\nBy convention, all devices connected to the broker have an account in Auth0.\n\nNotice that the Device Profile also has a property `topics`. This is an array with all topics this particular device is allowed to. In the screenshot above, `thermostat-1a` will be allowed publishing (or subscribing) to topics `temperature` and `config`.\n\nThe `authorizePublish` and `authorizeSubscribe` functions simply check that a particular requested topic is present in this list.\n\nThe `authenticateWithJWT` expects a JWT in the `password` field. The flow in this case is slightly different:\n\n1.  The publisher & subscriber will obtain a token\n    \n2.  They connect to `mosca` submitting the JWT\n    \n3.  `mosca` validates the JWT\n    \n4.  Messages are sent and re-transmitted to subscribers\n    \n\n![MQTT JSON Web Token Data Flow ](https://images.ctfassets.net/cdy7uua7fh8z/38KV0HggAdQDkLxqZuAOph/e134f43c290d432064f288e549a59789/2023-09-22_13-15-47.png)\n\nPublishers and subscribers will obtain the JWT through some means. Notice that the broker doesn't need to communicate with Auth0 anymore. JWTs are self-contained artifacts that can be validated with the secret used to sign them.\n\n### The Publisher\n\nFor this sample, the publisher is a simple nodejs program that uses the `mqtt` module, and adds the right credentials:\n\n```\nvar mqtt = require('mqtt')\n  , host = 'localhost'\n  , port = '9999';\n\nvar settings = {\n  keepalive: 1000,\n  protocolId: 'MQIsdp',\n  protocolVersion: 3,\n  clientId: 'Thermostat 1a',\n  username:'thermostat-1a',\n  password:'the password'\n}\n\n// client connection\nvar client = mqtt.createClient(port, host, settings);\n\nsetInterval(sendTemperature, 2000, client);\n\nfunction sendTemperature(client){\n  var t = {\n    T: Math.random() * 100,\n    Units: \"C\"\n  };\n\n  client.publish('temperature', JSON.stringify(t));\n}\n```\n\nOf course `username` & `password` here will have to match whatever is stored in Auth0.\n\n### The subscriber\n\nThe subscriber is very similar to the publisher:\n\n```\nvar mqtt = require('mqtt')\n  , host = 'localhost'\n  , port = '9999';\n\nvar settings = {\n  keepalive: 1000,\n  protocolId: 'MQIsdp',\n  protocolVersion: 3,\n  clientId: 'Reader-X1',\n  username:'reader-X1',\n  password:'the password'\n}\n\n// client connection\nvar client = mqtt.createClient(port, host, settings);\n\n\nclient.subscribe('temperature');\n\nclient.on('message', function(topic, message) {\n\n  if(topic ==='temperature')\n  {\n    console.log('New reading', message);\n  }\n});\n```\n\n## Summary\n\nThis shows how easy it is to use Auth0 in various scenarios. Auth0's user store is being used to manage devices. Of course much more sophisticated authorization rules could be written based on other conditions: time, location, device\\_id, and so on All these would be very simple to implement, either through additional profile attributes or through [](https://auth0.com/docs/rules)Rules. This also shows how the flexible Auth0 Profile can be extended to support arbitrary artifacts (such as `topics` in the example).\n\nTo learn more about Rules, you can review [Auth0 Rules](https://auth0.com/docs/rules).\n\nΙt is never a good idea to send credentials (`username`/`password`) over unsecured networks. There are other implementations that provide transport level security that would prevent message contents to be revealed. **mosca** supports TLS as an example. Likely a production deployment would favor this, unless all traffic happens in a closed network.\n\n### Acknowledgements\n\nMany thanks to [Matteo Collina](http://www.matteocollina.com/) for the review of this article, and for building the awesome **mosca**.",
  "title": "Authenticating & Authorizing Devices using MQTT with Auth0",
  "description": "How to authenticate and authorize devices using MQTT with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/extensions/log-export-extensions",
  "markdown": "# Create Custom Log Streams Using Webhooks\n\nWebhooks allow events to be delivered to an external web server. Auth0 offers several integrations that automatically push events to third-party log management and analysis systems. If however your third-party system isn't supported, you can set up a custom webhook integration.\n\n## Configure API endpoint\n\nYou'll build an API that serves a single route (such as `/api/logs`) that accepts `HTTP POST` requests.\n\n## Configure log stream\n\n1.  Go to [Dashboard > Monitoring > Streams](https://manage.auth0.com/#/log-streams) and click **Create Stream**.\n    \n    ![Dashboard Monitoring Streams](https://images.ctfassets.net/cdy7uua7fh8z/5ZY6sT68DabXNL9Dr4bhss/d14c4c42ff62634b1bd514e8b08aeda4/Log-Streaming2.png)\n2.  Select **Custom Webhook** and enter a unique name for your new stream.\n    \n    ![Dashboard Monitoring Streams Create New Custom Webhook](https://images.ctfassets.net/cdy7uua7fh8z/8gZAJmogSu5wk3ufzFqZf/d4d7fdc7d8550c65160b0b9441b05cf6/dashboard-monitoring-streams-new-custom-webhook.png)\n3.  Configure the following settings:\n    \n    ![Dashboard Monitoring Streams Custom Webhook Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/5vJVD09aqSF0xEZZFk6wh2/e6469041b2dd1e4f1b142961ca0a12ab/custom-webhook-settings.png)\n    \n    | **Setting** | **Description** |\n    | --- | --- |\n    | **Name** | A unique display name to distinguish this integration from other integrations. |\n    | **Payload URL** | The URL where the event payloads are sent as HTTP POST requests. |\n    | **Authorization Token** | (Optional) The value in the Authorization header of the request. |\n    | **Content Type** | The media type of the payload that will be delivered to the webhook. |\n    | **Content Format** | Receive data in JSON lines, arrays, or objects. |\n    | **Filter by Event Category** | List of log stream filters. |\n    | **Starting Cursor** | (Optional) Specific day and time to start the stream from. |\n    \n4.  Click **Save**.\n    \n\n## Test configuration\n\n1.  Switch to the **Health** view and confirm that the **Stream Status** is **Active.**\n    \n2.  Perform an action that creates a tenant log event, like a login, token exchange, or Auth0 Management API call.\n    \n3.  Confirm that the event was created in your tenant logs.\n    \n4.  Confirm that your API received an `HTTP POST` request with the event data.\n    \n5.  Go to the **Health** view and confirm that no errors occurred.\n    \n\n## Troubleshoot Webhooks\n\nIf your webhook isn't working, it can be difficult to troubleshoot and determine what is causing the issue. Webhooks are asynchronous, so testing them can involve you triggering the webhook, waiting, and then checking the response (assuming that you did receive a response).\n\nHowever, there are certainly alternatives to the inefficient process we detailed above. While full details of how to troubleshoot a particular webhook is outside the scope of this article, here are some steps you can take to debug:\n\n1.  Check [Auth0 Dashboard > Monitoring > Logs](https://auth0.com/docs/deploy-monitor/logs) for helpful messages.\n    \n2.  Analyze the requests your webhook is making using a tool like [Mockbin](http://mockbin.io/), [Beeceptor](https://beeceptor.com/), or (self-hosted) [RequestBin](https://github.com/Runscope/requestbin).\n    \n3.  Mock requests using cURL or [Postman](https://www.getpostman.com/).\n    \n4.  Test your webhook code locally using something like [localtunnel](https://github.com/localtunnel/localtunnel) or [ngrok](https://ngrok.com/).\n    \n5.  Use a tool like [Runscope](https://www.runscope.com/) or [Assertible](https://assertible.com/) to watch the whole execution flow.\n    \n\n## Learn more\n\n*   [Check Log Stream Health](https://auth0.com/docs/customize/log-streams/check-log-stream-health)\n*   [Filter Log Events](https://auth0.com/docs/deploy-monitor/logs/log-event-filters)\n*   [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes)",
  "title": "Create Custom Log Streams Using Webhooks",
  "description": "Learn how to configure a log stream using a custom webhook to stream log events to the URL of your choice.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/pre-deployment-checks/predeployment-tests",
  "markdown": "# Run Pre-Deployment Tests\n\nYou should run unit and integration tests before deploying Auth0 on a live application or service. Performing tests against Auth0 APIs may lead to your account being [rate limited](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy), so we recommend creating mock Auth0 APIs during testing. Depending on your development environment, your test tools may also provide mock API functionality. There are also numerous API mocking tools available, such as [MockServer](http://www.mock-server.com/) or [JSON Server](https://github.com/typicode/json-server), you can use to quickly create fake APIs for testing.\n\nIf you have an Enterprise subscription, you can request [load testing](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/load-testing-policy) against Auth0.\n\n## Performance tests\n\nIf you encounter issues while conducting performance tests, use the following methods to troubleshoot.\n\n### Auth0 Dashboard\n\nThe [Monitoring > Logs](https://manage.auth0.com/#/logs) section of the Dashboard stores data on:\n\n*   Actions taken in the Dashboard by administrators\n    \n*   Authentications made by your users\n    \n\nThere are also [extensions](https://auth0.com/docs/customize/extensions) that you can use for logging purposes, including exporting logs to third-party tools and gathering information on the use of custom code in your account.\n\n### Third-party test tools\n\nThere are a number of third-party test tools that you can use for performance testing against RESTful APIs. Here are some options you might consider (note that Auth0 does not endorse any particular product or tool):\n\n*   [Apache JMeter](http://jmeter.apache.org/)\n    \n*   [Artillery](https://artillery.io/)\n    \n*   [Micro Focus LoadRunner](https://www.radview.com/)\n    \n*   [Loader](https://loader.io/)\n    \n*   [RadView Webload](https://www.radview.com/)\n    \n*   [SmartBear LoadUI](https://smartbear.com/)\n    \n*   [Vegeta](https://github.com/tsenart/vegeta)\n    \n*   [Wrk](https://github.com/wg/wrk)\n    \n\nThese tools provide activity logs that help you identify anything that is concerning. If you need assistance with deciphering your log or identifying the potential issue, please contact Support.\n\n### HTTP archive files\n\nIf you discover an issue that you can reproduce, we recommend that you [create an HTTP archive (HAR) file](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files) and send it to our Support team for additional assistance.\n\n## Learn more\n\n*   [Professional Services: Implement](https://auth0.com/docs/get-started/professional-services/implement)\n*   [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)\n*   [Set Up AD/LDAP Connector Test Environment](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-test-environment)\n*   [Generate and Analyze HAR Files](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files)",
  "title": "Run Pre-Deployment Tests",
  "description": "Learn how to test your Auth0 implementation prior to deployment to production environments.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/pre-deployment-checks/pre-launch-tips",
  "markdown": "# Pre-Launch Tips\n\nHere is a list of tips our customers have found most useful when first getting started with Auth0 services:\n\n*   Check the URLs in your allowed callbacks, CORS and allowed redirect URLs for Logout to make sure they are correct, complete, and do not involve use of `file:///` or `localhost`. Minimize the use of wildcards and consider carefully the security ramifications of wildcards.\n    \n*   Separate production use from ongoing development work by [using separate tenants for prod, test and dev.](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments)\n    \n*   Configure your network correctly to allow traffic to and from our sets of public APIs (prod envs might have a different configuration than dev/staging).\n    \n*   Check the expiration date of certificates you have added to your configuration to make sure certificates uploaded during development cycles won’t expire during or shortly after launch.\n    \n*   Make sure any remote IDPs are running NTP so that the time will be properly synced.\n    \n*   The number of days of log data available varies by plan up to a max of 30 days. If you need log data for a longer retention period, you should configure one of our [log streaming solutions](https://marketplace.auth0.com/features/log-streaming). This will enable you to keep log data for longer periods. Be sure to set this up before you go live so you are sure to have log data when you need it.\n    \n*   Make sure your usage of our APIs remains within [allowed limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) and you have written your code to dynamically adjust to rate limit information returned in the header and to handle errors. If you anticipate rate limits being a problem for your application, discuss with us up-front to check if it would be possible to momentarily raise them until the traffic returns to normal. You should consider using a cache of user data in order to not have to query an API endpoint more than necessary.\n    \n*   If using [social connections](https://auth0.com/docs/identityproviders), make sure to obtain your own credentials from the provider and add them to the configuration of the social connection.\n    \n*   If using [custom DB connections](https://auth0.com/docs/connections/database/mysql), make sure all custom DB scripts are implemented and return a consistent user-profile with a unique user ID.\n    \n*   For sending emails, first make sure to [set up a custom email provider.](https://auth0.com/docs/customize/email/smtp-email-providers)\n    \n*   If you use our CDN for the Lock widget, make sure to pin to a specific version.\n    \n*   Make sure **external** components called from Actions, Rules, Hooks, and custom database connection scripts can handle the expected load.\n    \n*   Adequately protect any client secret values.\n    \n*   Check your [grant types](https://auth0.com/docs/get-started/applications/application-grant-types) for your applications. Make sure you have the right ones enabled and more importantly, disable any grant types that aren't needed.\n    \n*   If you make use of user\\_metadata, confirm that this is data that users should be able to change on their own (e.g., not “payment status”).\n    \n*   Review your [Attack Protection settings](https://manage.auth0.com/#/security/attack-protection) and read [Attack Protection](https://auth0.com/docs/secure/attack-protection) to understand how to unblock users that have been blocked.\n    \n*   Review your [Tenant Settings Admin section](https://manage.auth0.com/#/tenant/admins) to make sure that only appropriate admins have access to the Auth0 Dashboard. See [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access) for more information.\n    \n*   Make sure you have tested all core use cases for your application on all devices that might be used by the end-user population for your application. Be sure to test login, single sign-on (if supported), and log, as well as what happens if a user runs your application in multiple browser tabs.\n    \n*   Review your [list of rules](https://manage.auth0.com/#/rules) and make sure only the appropriate rules are turned on.\n    \n*   Review your rule code, any custom DB scripts, and any custom code in the login page to ensure that every call has adequate error trapping and handling. Also, review to make sure that return/callback statements are called correctly.\n    \n*   Configure your application name, support URL, and support email in the [Tenant Settings General](https://manage.auth0.com/#/tenant) section so when an error occurs your end users will be directed to an appropriate page.\n    \n*   Make sure that your application is [dynamically obtaining a management API token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n    \n*   Remove any `console.log` statements from your rules or custom DB scripts. Especially those that might leak user identifiable information such as email, username or password.\n    \n*   Do not use plain text secrets in rules or db-connections. They should be added in the configuration part of the interface. The configuration is encrypted and provided just in time. Do not log the configuration object.",
  "title": "Pre-Launch Tips",
  "description": "A list of helpful tips for when getting started with Auth0 services based on feedback and experience from others",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/pre-deployment-checks/how-to-run-production-checks",
  "markdown": "# Run Production Readiness Checks\n\nReview production check results for your tenant before you deploy your production environment.\n\n1.  Go to the Auth0 Management Dashboard and log in to your account.\n    \n2.  From the dropdown, select the tenant for which you want to run the Production Checks\n    \n3.  From the same dropdown, click **Run Readiness Check** to launch the interface\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/nHS8TrcMAsgUUWOv5gcNO/66d641136222fe6634b1d53f0a455ffd/Screenshot_2023-06-02_at_10.53.40_AM.jpeg)![Auth0 Support pre-deployment production checks](https://images.ctfassets.net/cdy7uua7fh8z/4EjetzpVocGQKy6HYVTHMw/b6eeefdaa52fac656d2dc7ea47ec466d/FullScreenReadinessCheck.png)\n\nOptional:\n\n1.  Select one or more [Applications](https://auth0.com/docs/get-started/applications) associated with this tenant for which you want checks to run by clicking **Filters.**\n    \n2.  Click **Apply**.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/n0YbLOV9gxaEFC7c6svFa/8e4b64839ad24edf8bcf9bbf05940a54/FiltersReadinessCheck.png)\n\nWhen the test is complete, your screen will automatically refresh to display your check results.\n\n## Production check results\n\nThere are three categories of check result fixes:\n\n*   [Critical fixes](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-check-required-fixes)\n    \n*   [Non-critical fixes](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-check-recommended-fixes)\n    \n*   [Best practices](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-checks-best-practices)\n    \n\nThe following are possible results for your check:\n\n*   Passed\n    \n*   Failed\n    \n*   Best practices\n    \n\nUnder each set of results, Auth0 tells you how many checks your application passed, as well as how many checks require review.\n\nIf your application **failed** for one or more checks, you'll see:\n\n*   The name of the check\n    \n*   Information on what the check is looking for\n    \n*   A **Configure** link to the appropriate area where you can make the required fixes so that your Application passes the check\n    \n*   Hyperlink to corresponding documentation\n    \n\nAll of the checks that your application **passed** are grouped together in the passed object of the results set. You can view the name of and information about the check, as well as review the associated documentation and use the hyperlink to go to the corresponding configuration area where you can make changes (if desired).\n\n## Learn more\n\n*   [Production Readiness Checks: Critical Fixes](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-check-required-fixes)\n*   [Production Readiness Checks: Non-Critical Fixes](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-check-recommended-fixes)\n*   [Production Readiness Checks: Best Practices](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-checks-best-practices)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)",
  "title": "Run Production Readiness Checks",
  "description": "Learn how to run the Auth0 Production Checks to ensure that your Applications are production-ready.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-checks-best-practices",
  "markdown": "# Production Readiness Checks: Best Practices\n\nThe following checks cannot be automated, so we recommend manually checking these areas prior to deployment to Production.\n\n| Check | Description |\n| --- | --- |\n| [Anomaly Detection](https://auth0.com/docs/anomaly-detection) | Review your account's [Anomaly Detection capability and configuration](https://manage.auth0.com/#/anomaly). |\n| Externalize [Configuration Parameters](https://auth0.com/docs/connections/database/mysql#4-add-configuration-parameters) | [Externalize, instead of hard code, all configuration parameters](https://manage.auth0.com/#/connections/database), such as credentials, connection strings, API keys, and so on, when developing Rules, Hooks, or custom database connections. |\n| [Restrict Delegation](https://auth0.com/docs/dashboard/reference/settings-application#advanced-settings) | If not using Delegation, set the Allowed Apps and APIs field of your Application Settings to the current Client ID. |\n| Single Sign-on (SSO) Timeout Values | Review the default [SSO cookie timeout values](https://manage.auth0.com/#/account/advanced) and ensure they align with your requirements. |\n| Tenants and Administrators | Review all tenants and tenant administrators to ensure they are correct. Decommission tenants that are no longer in use. Ensure that tenant administrators are limited to the necessary users. |\n| Verify Client IDs in App Code | Ensure that the Client IDs in your application code align with their Auth0 Application configurations. |\n| Allowlist Auth0 Public IPs | Allowlist Auth0 IPs if you're connecting to internal services or services behind a firewall when using Rules, Hooks, or custom databases. You can get a list of IP addresses in the tool tip when configuring any of these items. |\n\n## Learn more\n\n*   [Production Readiness Checks: Critical Fixes](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-check-required-fixes)\n*   [Production Readiness Checks: Non-Critical Fixes](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-check-recommended-fixes)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)",
  "title": "Production Readiness Checks: Best Practices",
  "description": "Checks to ensure that your Applications comply with Auth0 best practices",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-check-recommended-fixes",
  "markdown": "# Production Readiness Checks: Non-Critical Fixes\n\nThe following checks see if you've completed all recommendations (which are optional) for successful deployment to Production.",
  "title": "Production Readiness Checks: Non-Critical Fixes",
  "description": "Recommendations on how you can improve your Auth0 Application prior to production deployment",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/pre-deployment-checks/production-check-required-fixes",
  "markdown": "# Production Readiness Checks: Critical Fixes\n\nAll Actions are running a [recommended version of NodeJS](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations/migrate-actions-nodejs-16-to-nodejs-18) Set all [Actions](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations/migrate-actions-nodejs-16-to-nodejs-18) to a recommended version of NodeJS to take advantage of security patches and new features. [Allow ID Tokens for Management API v2 Authentication](https://auth0.com/docs/migrations/guides/calling-api-with-idtokens) is disabled The capabilities for using ID Tokens to authorize some of the Users and Device Credentials endpoints of the Management API are being deprecated. After completing migration to Access Tokens, make sure the [Allow ID Tokens for Management API v2 Authentication](https://manage.auth0.com/#/tenant/advanced) toggle is turned off. If you can't see this setting, then your tenant was created after this feature was deprecated, so it is already disabled by default. allowLegacyRoGrantTypes The legacy [oauth/ro endpoint](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migration-oauthro-oauthtoken) in tenant migration settings is being deprecated. After updating your applications to use supported endpoints, make sure you turn this endpoint off. allowOtherLegacyGrantTypes The legacy [oauth/access\\_token endpoint](https://auth0.com/docs/api/authentication#social-with-provider-s-access-token) in tenant migration settings is being depricated. After updating your applications to use supported endpoints, make sure you turn this endpoint off. allowLegacyTokenInfoEndpoint The legacy [tokeninfo endpoint](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations#tokeninfo-endpoint-validation) in tenant migration settings is being depricated. After updating your applications to use supported endpoints, make sure you turn this endpoint off. allowLegacyDelegationGrantTypes The legacy [delegation endpoint](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation) in tenant migration settings is being depricated. After updating your applications to use supported endpoints, make sure you turn this endpoint off. [Allowed Callback URLs](https://auth0.com/docs/protocols/oauth2/redirect-users) should not include Localhost Validates the [Application Allowed Callback URLs](https://manage.auth0.com/#/applications) do not point to `localhost`, `127.0.0.1`, and so on. [Allowed Origins (CORS)](https://auth0.com/docs/cross-origin-authentication) should not be Localhost Validates that the [Location URL](https://manage.auth0.com/#/applications) for the page does not point to `localhost`. [Allowed Web Origins](https://auth0.com/docs/dashboard/reference/settings-application) should not include `localhost` Validates that the [Allowed Web Origins URLs](https://manage.auth0.com/#/applications) do not point to `localhost`. [Email Provider](https://auth0.com/docs/email/providers) should be configured Verifies that the [custom email provider](https://manage.auth0.com/#/emails/provider) has been configured. Hooks are being deprecated and must be [migrated to Actions](https://auth0.com/docs/customize/actions/migrate/migrate-from-hooks-to-actions) Hooks are being deprecated. We strongly recommend that you begin using [Actions](https://auth0.com/docs/customize/actions/migrate/migrate-from-hooks-to-actions) and start the migration process. Existing Hooks will stay active until Nov 18, 2024. [Multi-Factor Auth](https://auth0.com/docs/mfa/guides/configure-sms) should be configured (Dependency: MFA is configured) If you are using MFA with the [Phone Message factor](https://manage.auth0.com/#/mfa), configure it with a Twilio or custom delivery provider to avoid rate limits of the default delivery provider. [Legacy User Profile](https://auth0.com/docs/guides/migration-legacy-flows#user-profiles) should be disabled The legacy authentication flows that allow ID Tokens and the `/userinfo` endpoint to include the complete user profile are being deprecated. After completing the migration to the new OIDC-conformant APIs, make sure the [Legacy User Profile](https://manage.auth0.com/#/account/advanced) toggle is turned off. Rules are being deprecated and must be [migrated to Actions](https://auth0.com/docs/customize/actions/migrate/migrate-from-rules-to-actions) Rules are being deprecated. We strongly recommend that you begin using [Actions](https://auth0.com/docs/customize/actions/migrate/migrate-from-rules-to-actions) and start the migration process. Existing Rules will stay active until Nov 18, 2024. [Social Connections](https://auth0.com/docs/connections/social/devkeys) should not use Auth0 Developer Keys Verifies that [Social Connections](https://manage.auth0.com/#/connections/social) are not using the default Auth0 developer keys. Support Email should be configured Ensures the [Support Email](https://manage.auth0.com/#/account) is configured in Tenant Settings. Support URL is configured Ensures the [Support URL](https://manage.auth0.com/#/account) is configured in Tenant Settings. Tenant Environment Tag should be configured Ensures the [tenant environment tag](https://support.auth0.com/tenants/public) is set appropriately to Production, Staging, or Development. Changes to this tag affect your tenant's rate limit. Tenant is set to use a recommended default [NodeJS version](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations/migrate-actions-nodejs-16-to-nodejs-18) Update your tenant to a [recommended version of NodeJS](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations/migrate-actions-nodejs-16-to-nodejs-18) to take advantage of security patches and new features. Tenant Login URI Ensures that [Tenant Login URI](https://manage.auth0.com/#/tenant/advanced) is configured in Tenant Settings. Use Custom Domain in Branded Email Templates Ensure your emails templates use a [custom domain](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains#use-custom-domains-in-emails). We strongly recommend customizing all user-facing emails to use your custom domain and company branding.",
  "title": "Production Readiness Checks: Critical Fixes",
  "description": "Fixes you must make to your Auth0 Application prior to production deployment",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/log-streams/check-log-stream-health",
  "markdown": "# Check Log Stream Health\n\nYou can troubleshoot potential issues with your stream by looking at the **Health** tab.\n\n1.  Go to [Dashboard > Monitoring > Streams](https://manage.auth0.com/#/log-streams).\n    \n2.  Locate the log stream you want to check in the list.\n    \n    Your log stream can have one of the following statuses:\n    \n    *   **Active**: Your stream is enabled with us, and we will attempt to deliver the next log events.\n        \n    *   **Paused**: You have requested that we stop delivery attempts for the stream. You can click **Resume Stream** to change the status back to **Active**.\n        \n    *   **Disabled**: We have disabled your stream because of successive errors. You can click **Restart Stream** to change the status back to **Active** and retry delivery for this stream.\n        \n3.  Select the more options menu (...) at the end of the stream, and click **Health** on the drop-down menu. To help diagnose issues with your stream, you can see the last ten errors we encountered while attempting to deliver logs to your stream within the last 5 days.\n    \n    ![Dashboard Log Streams List Health menu option](https://images.ctfassets.net/cdy7uua7fh8z/61tSLY5CZEOZiNbL8xbpsk/48996cf8a24e65a94254145c2c476b4a/dashboard-monitoring-streams-health.png)",
  "title": "Check Log Stream Health",
  "description": "Learn how to check the health of your log streaming configurations in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/log-streams/event-filters",
  "markdown": "# Log Stream Filters\n\nYou can filter your log streams so only select events and event categories are delivered. To configure a log stream's filter:\n\n1.  Go to [Dashboard > Monitoring > Streams](https://manage.auth0.com/#/log-streams).\n    \n2.  Select a log stream and go to the **Settings** tab.\n    \n3.  Enable or disable filters in the **Filter By Event Category** menu.\n    \n4.  Click **Save**.\n    \n\n## Authentication event filters\n\n| **Filter** | **Description** |\n| --- | --- |\n| Login - Failure | Failed login events |\n| Login - Notification | Login notification events |\n| Login - Success | Successful login events |\n| Logout - Failure | Failed logout events |\n| Logout - Success | Successful logout events |\n| Signup - Failure | Failed signup events |\n| Signup - Success | Successful signup events |\n| Silent Authentication - Failure | Failed silent authentication events |\n| Silent Authentication - Success | Successful silent authentication events |\n| Token Exchange - Failure | Failed token exchange events |\n| Token Exchange - Success | Successful token exchange events |\n\n### Login - Failure\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `f` | Failed login |\n| `fc` | Failed connector login |\n| `fco` | Origin is not in the application's Allowed Origins list |\n| `fcoa` | Failed cross-origin authentication |\n| `fens` | Failed native social login |\n| `fp` | Incorrect password |\n| `fu` | Invalid email or username |\n\n### Login - Notification\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `w` | Warnings during login |\n\n### Login - Success\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `s` | Successful login |\n| `scoa` | Successful cross-origin authentication |\n| `sens` | Successful native social login |\n\n### Logout - Failure\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `flo` | User logout failed |\n| `oidc_backchannel_logout_failed` | Failed OIDC back-channel logout request |\n\n### Logout - Success\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `oidc_backchannel_logout_succeeded` | Successful OIDC back-channel logout request |\n| `slo` | User successfully logged out |\n\n### Signup - Failure\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `fs` | User signup failed |\n\n### Signup - Success\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `ss` | Successful user signup |\n\n### Silent Authentication - Failure\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `fsa` | Failed silent authentication |\n\n### Silent Authentication - Success\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `ssa` | Successful silent authentication |\n\n### Token Exchange - Failure\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `feacft` | Failed exchange of Authorization Code for Access Token |\n| `feccft` | Failed exchange of Access Token for a Client Credentials Grant |\n| `fede` | Failed exchange of Device Code for Access Token |\n| `feoobft` | Failed exchange of Password and OOB Challenge for Access Token |\n| `feotpft` | Failed exchange of Password and OTP Challenge for Access Token |\n| `fepft` | Failed exchange of Password for Access Token |\n| `fepotpft` | Failed exchange of Passwordless OTP for Access Token |\n| `fercft` | Failed exchange of Password and MFA Recovery code for Access Token |\n| `ferrt` | Failed exchange of Rotating Refresh Token |\n| `fertft` | Failed exchange of Refresh Token for Access Token |\n\n### Token Exchange - Success\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `seacft` | Successful exchange of Authorization Code for Access Token |\n| `seccft` | Successful exchange of Access Token for a Client Credentials Grant |\n| `sede` | Successful exchange of Device Code for Access Token |\n| `seoobft` | Successful exchange of Password and OOB Challenge for Access Token |\n| `seotpft` | Successful exchange of Password and OTP Challenge for Access Token |\n| `sepft` | Successful exchange of Password for Access Token |\n| `sercft` | Successful exchange of Password and MFA Recovery code for Access Token |\n| `sertft` | Successful exchange of Refresh Token for Access Token |\n\n## Management API event filters\n\n| **Filter** | **Description** |\n| --- | --- |\n| Management API - Failure | Failed Management API events |\n| Management API - Success | Successful Management API events |\n\n### Management API - Failure\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `fapi` | Failed Management API operation |\n\n### Management API - Success\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `sapi` | Successful Management API operation |\n| `mgmt_api_read` | API GET operation returning secrets completed successfully |\n\n## System event filters\n\n| **Filter** | **Description** |\n| --- | --- |\n| System - Notification | System notification events |\n\n### System - Notification\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `admin_update_launch` | Auth0 Update Launched |\n| `api_limit` | The maximum number of requests to the Authentication or Management APIs in given time has reached |\n| `coff` | AD/LDAP Connector is offline |\n| `con` | AD/LDAP Connector is online and working |\n| `depnote` | Deprecation Notice |\n| `fcpro` | Failed to provision a AD/LDAP connector |\n| `fui` | Failed to import users |\n| `limit_delegation` | Rate limit exceeded to `/delegation` endpoint |\n| `limit_mu` | An IP address is blocked with 100 failed login attempts using different usernames, all with incorrect passwords in 24 hours, or 50 sign-up attempts per minute from the same IP address |\n| `limit_wc` | An IP address is blocked with 10 failed login attempts into a single account from the same IP address |\n| `sys_os_update_start` | Auth0 OS Update Started |\n| `sys_os_update_end` | Auth0 OS Update Ended |\n| `sys_update_start` | Auth0 Update Started |\n| `sys_update_end` | Auth0 Update Ended |\n\n## User/Behavioral event filters\n\n| **Filter** | **Description** |\n| --- | --- |\n| User/Behavioral - Failure | Failed user/behavioral events |\n| User/Behavioral - Notification | User/behavioral notification events |\n| User/Behavioral - Success | Successful user/behavioral events |\n\n### User/Behavioral - Failure\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `fce` | Failed to change user email |\n| `fcp` | Failed to change password |\n| `fcpn` | Failed to change phone number |\n| `fcpr` | Failed change password request |\n| `fcu` | Failed to change username |\n| `fd` | Failed to generate delegation token |\n| `fdeaz` | Device authorization request failed |\n| `fdecc` | User did not confirm device |\n| `fdu` | Failed user deletion |\n| `fn` | Failed to send email notification |\n| `fv` | Failed to send verification email |\n| `fvr` | Failed to process verification email request |\n\n### User/Behavioral - Notification\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `cs` | Passwordless login code has been sent |\n| `du` | User has been deleted |\n| `gd_enrollment_complete` | A first time MFA user has successfully enrolled using one of the factors |\n| `gd_start_enroll` | Multi-factor authentication enroll has started |\n| `gd_unenroll` | Device used for second factor authentication has been unenrolled |\n| `gd_update_device_account` | Device used for second factor authentication has been updated |\n| `ublkdu` | User block setup by anomaly detection has been released |\n\n### User/Behavioral - Success\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `sce` | Successfully changed user email |\n| `scp` | Successfully changed password |\n| `scpn` | Successfully changed phone number |\n| `scpr` | Successful change password request |\n| `scu` | Successfully changed username |\n| `sdu` | User successfully deleted |\n| `srrt` | Successfully revoked a Refresh Token |\n| `sui` | Successfully imported users |\n| `sv` | Successfully consumed email verification link |\n| `svr` | Successfully called verification email endpoint, verification email in queue. |\n\n## Other\n\nThis category contains unclassified events.\n\n### Miscellaneous\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `cls` | Passwordless login code or link has been sent |\n| `fpar` | Failed pushed authorization request (PAR) |\n| `resource_cleanup` | Resources exceeding defined limits have been removed |\n\n### Multi-factor authentication\n\nThe following unclassified events relate to multi-factor authentication (MFA):\n\n| **Event Code** | **Description** |\n| --- | --- |\n| `gd_auth_email_verification` | Email verification confirmed successfully |\n| `gd_auth_fail_email_verification` | Email verification failed |\n| `gd_auth_failed` | Mutli-factor authentication failed |\n| `gd_auth_rejected` | User rejected MFA request via push notification |\n| `gd_auth_succeed` | Multi-factor authentication succeeded |\n| `gd_recovery_failed` | User entered an invalid recovery code while attempting to authenticate |\n| `gd_recovery_succeed` | User successfully authenticated using a recovery code |\n| `gd_sent_email` | Email for MFA successfully sent |\n| `gd_send_email_failure` | Email for MFA failed to send |\n| `gd_send_email_verification` | Email verification successfully sent |\n| `gd_send_pn` | Push notification for MFA successfully sent |\n| `gd_send_pn_failure` | Push notification for MFA failed |\n| `gd_send_sms` | SMS for MFA successfully sent |\n| `gd_send_sms_failure` | SMS for MFA failed to send |\n| `gd_send_voice` | Voice call for MFA successfully sent |\n| `gd_send_voice_failure` | Voice call for MFA failed to send |\n| `gd_start_auth` | Second factor authentication event started for MFA |\n| `gd_start_enroll_failed` | Multi-factor authentication enrollment failed |\n| `gd_tenant_update` | MFA tenant settings have been updated |\n| `gd_webauthn_challenge_failed` | User failed to verify Webauthn factor |\n| `gd_webauthn_enrollment_failed` | Webauthn enrollment failed |\n| `mfar` | User prompted to complete MFA |",
  "title": "Log Stream Filters",
  "description": "Lists available event filters for log streams and the events included in each filter.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy/private-cloud-on-azure",
  "markdown": "# Private Cloud on Azure\n\nThe Private Cloud on Azure deployment option is a dedicated, managed instance of the Auth0 identity platform running on Microsoft Azure. It provides isolation, higher performance, separate development instances, various add-ons, and more.\n\n## Operational differences\n\nThe table below compares each deployment option for Private Cloud on Azure.\n\n| **Feature** | **Public Cloud** | **Private Cloud on Azure Basic** | **Private Cloud on Azure Performance** |\n| --- | --- | --- | --- |\n| Tenancy | Multi | Single | Single |\n| Requests per second (RPS) | 100 | 100 | 500 |\n| Service level agreement (SLA) | 99.99% | 99.99% | 99.99% |\n| Data residency | Public cloud regions only | Yes | Yes |\n| Dev environment | No  | No  | 1   |\n\n#### Data residency\n\nWith Private Cloud on Azure, you choose the region where your data is stored. Auth0 can provide a list of available regions that use three [availability zones](https://azure.microsoft.com/en-us/global-infrastructure/geographies/) for the deployment. A list of current regions where we offer private cloud deployments can be found in our Sub-processor Information posted to our [Trust & Compliance page](https://www.okta.com/trustandcompliance/). In most cases, Okta deploys backups in the same selected Azure region.\n\n### Maximum availability\n\nPrivate Cloud on Azure instances have a 99.99% service level agreement (SLA).\n\n### High demand apps\n\nIf your application requires a significantly high amount of requests per second (RPS), you may also wish to consider Private Cloud on Azure. See the [rate limits policies](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) for more information about the standard rate limits. The Private Cloud on Azure deployments have a rate limit of 100 RPS for Private Basic, and enhanced rate limits of 500 RPS, 1,500 RPS, 3,000 RPS, and 6,000 RPS for Private Performance options.\n\n## Additional dev environments\n\nPrivate Cloud on Azure Performance deployments include a fully-isolated and independently-updated instance for development and testing. You can add additional pre-production environments to meet your business requirements.\n\nGuaranteed requests per second (RPS) and SLA do not apply to non-production environments.\n\n## Limitations\n\n### Data Center Locations\n\nPrivate Cloud on Azure is fully deployable in the following regions:\n\n*   Australia\n    \n*   Brazil\n    \n*   Canada\n    \n*   France\n    \n*   Germany\n    \n*   India\n    \n*   Ireland\n    \n*   Japan\n    \n*   Netherlands\n    \n*   Norway\n    \n*   South Africa\n    \n*   South Korea\n    \n*   Sweden\n    \n*   Switzerland\n    \n*   United Arab Emirates\n    \n*   United Kingdom\n    \n*   USA\n    \n\n### Bursty Traffic \n\nOkta provides rate limits for orgs based on the traffic that they expect to have, and subject to the RPS tier purchased. If your org experiences higher traffic than what is expected, this unplanned usage may potentially have an impact on end users. The Private Cloud offering is designed to handle gradual increases in transaction rate (e.g. an increase from 100 RPS to 1000 RPS over a period of 10 minutes) without any service impact. However, sudden and severe bursts in traffic (e.g. 100 RPS to 1000RPS increase in a matter of seconds) could lead to service instability and (increased latency) while the solution adjusts to handle the new load.\n\n### Add-on limitations\n\nThe [Credential Guard add-on](https://auth0.com/docs/secure/attack-protection/breached-password-detection#detect-breaches-faster-with-credential-guard) for breached password detection and the [HIPAA compliance add-on](https://auth0.com/docs/secure/data-privacy-and-compliance#hipaa-and-hitech) are not currently available on Azure deployments.\n\n## Onboarding\n\nAfter choosing Private Cloud on Azure, an onboarding and deployment process will be followed to configure your environment(s).\n\n### Customer onboarding requirements\n\nUpon contract signing, we will ask you to provide key information regarding your onboarding requirements, which we will then validate.\n\n### Kickoff meeting\n\nOnce we validate your onboarding requirements, we will host a kickoff meeting with you to begin the implementation process. We strongly recommend that this meeting occur no later than five (5) days after the contract signing.\n\n### Implementation\n\nImmediately after the onboarding form validation, we will begin provisioning your environment.\n\nAt the end of this process, you're ready for the environment handover and your Private Cloud on Azure deployment is ready for use.\n\n## Updates\n\nPrivate Cloud on Azure deployments are updated every week automatically. You can set a specific day and time during the week, if required.\n\n## Testing\n\n### Load testing\n\nThis policy outlines the necessary requirements for Auth0 to perform load testing for Private Cloud on Azure customers who submit a request. You can file a load testing request via the [Support Center](https://support.auth0.com/). Under the Issue field, select **Private Cloud Support Incident**.\n\nIf you purchased a dedicated load testing environment, there is no limit to the frequency of load tests you can run. Standard environments are limited to two (2) per year, given proper load testing procedures.\n\nTo be considered for approval, the request must:\n\n*   Be filed at least two (2) weeks prior to the desired test date; in many cases, Auth0 encourages one (1) month of advance notice to ensure time for a thorough review and any required modifications.\n    \n*   Receive approval in writing before any testing is conducted.\n    \n*   Stay within our [published production rate limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy).\n    \n\nIf changes to infrastructure are requested, the cost will be determined based on your specific requirements.\n\n#### Testing capacity considerations\n\nYou should start with a low load and slowly increase until the environment has reached its peak. Should you require a load greater than what the environment can handle, the environment size should be increased.\n\nPrivate Cloud environments can be upsized via contract addendum; please contact your Account Executive and TAM to discuss this purchase.\n\n| Subscription | Load Test Capacity | Ramp up |\n| --- | --- | --- |\n| Private Cloud Performance 500 RPS (5x) | 325 RPS | 100 RPS/min |\n| Private Cloud Performance 1500 RPS (15x) | 975 RPS | 100 RPS/min |\n| Private Cloud Performance 3000 RPS (30x) | 1950 RPS | 100 RPS/min |\n| Private Cloud Performance 6000 RPS (60x) | 3900 RPS | 100 RPS/min |\n\nFor more information on load testing in Private Cloud, see [Environment request limits (Private Cloud Only)](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy#environment-request-limits-private-cloud-only-).\n\n#### High load notifications\n\nFor periods of anticipated high load, you must inform your account team no later than 14 days prior to the event. The notification provides the opportunity to adequately test scenarios (if possible) and aligns reactive support to the event.\n\n## Secure Outbound Networking\n\nSome Auth0 platform customizations, including [Actions](https://auth0.com/docs/customize/actions), [custom webhooks](https://auth0.com/docs/customize/log-streams/custom-log-streams), and [custom database action scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates), allow secure outbound connections from the Auth0 platform to your own services and establish network connectivity between your Private Cloud deployment and your own services.\n\nSecure outbound networking uses Azure Private Link by [establishing an endpoint service](https://learn.microsoft.com/en-us/azure/private-link/private-link-service-overview) in your Azure account. The underlying service can be an Azure-native service or a service running in a data center and must be in an Azure Virtual Network in the same Azure region as your Private Cloud deployment.\n\nAfter you configure your Private Cloud deployment to make your endpoint service available, provide Auth0 with your endpoint service information so we can integrate the service with your deployment and provide information on how to access it from your customization code.\n\nFor more info on setting up endpoint services with Private Link, contact Azure. To coordinate service onboarding with Auth0, contact Auth0's [Support Center](https://support.auth0.com/).\n\n### Penetration testing\n\nTo conduct a security test, please notify us in advance via the Auth0 Support Center. Auth0 requires at least one week (seven days) notice prior to your test's planned start date.\n\nIf the test is isolated to your infrastructure (that is, there will be no testing of Auth0 services), you do not need to notify Auth0.\n\nFor the information that we require, see our [Penetration Testing Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/penetration-testing-policy).\n\n## Certificate renewal process\n\nAuth0-managed certificates (in the format \\*.auth0app.com) are the responsibility of Auth0 to both obtain and apply. Auth0 will manage the process end-to-end and will prompt you with any action required.\n\nRenewal of Auth0-issued certificates for custom domains is managed by Auth0.\n\nRenewal of customer-managed certificates for [custom domains](https://auth0.com/docs/customize/custom-domains) (in the format \\*.<CustomerName>.com) is the customer’s responsibility to manage and obtain.\n\n## Reporting and monitoring\n\nAuth0 provides logs that are accessible via the Dashboard or the [log streaming endpoint](https://auth0.com/docs/customize/log-streams).\n\n## Support\n\nYou can reach out to the Auth0 [Support](https://support.auth0.com/) team with any questions or concerns you might have. To help expedite your request, please provide as much information as possible in the [Support ticket you open](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets).",
  "title": "Private Cloud on Azure",
  "description": "Learn about the Auth0 identity platform on Azure deployment option and its capabilities.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy/private-cloud",
  "markdown": "# Private Cloud on AWS\n\nThe Private Cloud on AWS deployment option is a dedicated, managed instance of the Auth0 identity platform running on Amazon Web Services. It provides isolation, higher performance, separate development instances, various add-ons, and more.\n\n## Operational differences\n\nThe table below compares each deployment option for Private Cloud on AWS.\n\n| **Feature** | **Public Cloud** | **Private Cloud Basic on AWS** | **Private Cloud Performance on AWS** |\n| --- | --- | --- | --- |\n| Tenancy | Multi | Single | Single |\n| Requests per second (Multiples of 100 RPS) | 100 RPS (1x) | 100 RPS (1x) | 500 RPS (5x)  <br>1,500 RPS (15x)  <br>3,000 RPS (30x)  <br>6,000 RPS (60x) |\n| Service level agreement (SLA) | 99.99% | 99.99% | 99.99% |\n| Data residency | Public cloud regions only | Yes | Yes |\n| Dev environment | No  | No  | 1   |\n\n### Data residency\n\nWith Private Cloud on AWS, you choose the region where your data is stored. Auth0 can provide a list of available regions that use multiple [availability zones](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/) for the deployment. A list of current regions where we offer private cloud deployments can be found in our Sub-processor Information posted to our [Trust & Compliance page](https://www.okta.com/trustandcompliance/). In most cases, Okta deploys backups in the same selected AWS region.\n\n### Maximum availability\n\nPrivate Cloud on AWS instances have a 99.99% service level agreement (SLA).\n\n### High demand apps\n\nIf your application requires a significantly high amount of requests per second (RPS), you may also wish to consider Private Cloud on AWS. See the [rate limits policies](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) for more information about the standard rate limits. The Private Cloud on AWS deployments have a rate limit of 100 RPS for Private Basic, and enhanced rate limits of 500 RPS, 1,500 RPS, 3,000 RPS, and 6,000 RPS for Private Performance options.\n\n## Additional dev environments\n\nPrivate Cloud on AWS Performance deployments include a fully-isolated and independently-updated instance for development and testing. You can add additional pre-production environments to meet your business requirements.\n\nGuaranteed requests per second (RPS) and SLA do not apply to non-production environments.\n\n## Limitations\n\n### Data Center Locations\n\nPrivate Cloud on AWS is fully deployable in the following regions:\n\n*   Australia\n    \n*   Bahrain\n    \n*   Brazil\n    \n*   Canada\n    \n*   France\n    \n*   Germany\n    \n*   Hong Kong\n    \n*   India\n    \n*   Indonesia\n    \n*   Ireland\n    \n*   Italy\n    \n*   Japan\n    \n*   Singapore\n    \n*   South Africa\n    \n*   South Korea\n    \n*   Sweden\n    \n*   United Kingdom\n    \n*   USA\n    \n\n### Bursty Traffic \n\nOkta provides rate limits for orgs based on the traffic that they expect to have, and subject to the RPS tier purchased. If your org experiences higher traffic than what is expected, this unplanned usage may potentially have an impact on end users.The Private Cloud offering is designed to handle gradual increases in transaction rate (e.g. an increase from 100 RPS to 1000 RPS over a period of 10 minutes) without any service impact. However, sudden and severe bursts in traffic (e.g. 100 RPS to 1000RPS increase in a matter of seconds) could lead to service instability and increased latency while the solution adjusts to handle the new load. \n\n## Onboarding\n\nAfter choosing Private Cloud on AWS, an onboarding and deployment process will be followed to configure your environment(s).\n\n### Customer onboarding requirements\n\nUpon contract signing, we will ask you to provide key information regarding your onboarding requirements, which we will then validate.\n\n### Kickoff meeting\n\nOnce we validate your onboarding requirements, we will host a kickoff meeting with you to begin the implementation process. We strongly recommend that this meeting occur no later than five (5) days after the contract signing.\n\n### Implementation\n\nImmediately after the onboarding form validation, we will begin provisioning your environment.\n\nAt the end of this process, you're ready for the environment handover and your Private Cloud on AWS deployment is ready for use.\n\n## Secure Outbound Networking\n\nSome Auth0 platform customizations—[Actions](https://auth0.com/docs/customize/actions), [custom webhooks](https://auth0.com/docs/customize/log-streams/custom-log-streams), and [custom database action scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates), for example—let you make outbound connections from the Auth0 platform to your own services. With Private Cloud on AWS, you can establish network connectivity between your Private Cloud deployment and your own services without exposing your data to the Internet.\n\nSecure outbound networking uses AWS PrivateLink. First, you share your service through PrivateLink by [establishing an endpoint service](https://docs.aws.amazon.com/vpc/latest/privatelink/create-endpoint-service.html) in your AWS account. The underlying service can be an AWS-native service or a service running in a data center. The service must be in a VPC in the same AWS region as your Private Cloud deployment.\n\nNext, we will configure your Private Cloud deployment to make your endpoint service available. Once you provide Auth0 with your endpoint service information, we will integrate the service with your deployment and provide information on how to access it from your customization code.\n\nFor more info on setting up endpoint services with PrivateLink, contact AWS. To coordinate service onboarding with Auth0, file a request to the [Support Center](https://support.auth0.com/).\n\n## Updates\n\nPrivate Cloud on AWS deployments are updated every week automatically. You can set a specific day and time during the week, if required.\n\n## Testing\n\n### Load testing\n\nThis policy outlines the necessary requirements for Auth0 to perform load testing for Private Cloud on AWS customers who submit a request. You can file a load testing request via the [Support Center](https://support.auth0.com/). Under the Issue field, select Private Cloud Support Incident.\n\nIf you purchased a dedicated load testing environment, there is no limit to the frequency of load tests you can run. Standard environments are limited to two (2) per year, given proper load testing procedures.\n\nTo be considered for approval, the request must:\n\n*   Be filed at least two (2) weeks prior to the desired test date; in many cases, Auth0 encourages one (1) month of advance notice to ensure time for a thorough review and any required modifications.\n    \n*   Receive approval in writing before any testing is conducted.\n    \n*   Stay within our [published production rate limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy).\n    \n\nIf changes to infrastructure are requested, the cost will be determined based on your specific requirements.\n\n#### Testing capacity considerations\n\nYou should start with a low load and slowly increase until the environment has reached its peak. Should you require a load greater than what the environment can handle, the environment size should be increased.\n\nPrivate Cloud environments can be upsized via contract addendum; please contact your Account Executive and TAM to discuss this purchase.\n\n| Subscription | Load Test Capacity | Ramp up |\n| --- | --- | --- |\n| Private Cloud Performance 500 RPS (5x) | 325 RPS | 100 RPS/min |\n| Private Cloud Performance 1500 RPS (15x) | 975 RPS | 100 RPS/min |\n| Private Cloud Performance 3000 RPS (30x) | 1950 RPS | 100 RPS/min |\n| Private Cloud Performance 6000 RPS (60x) | 3900 RPS | 100 RPS/min |\n\nFor more information on load testing in Private Cloud, see [Environment request limits (Private Cloud Only)](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy#environment-request-limits-private-cloud-only-).\n\n#### High load notifications\n\nFor periods of anticipated high load, you must inform your account team no later than 14 days prior to the event. The notification provides the opportunity to adequately test scenarios (if possible) and aligns reactive support to the event.\n\n### Penetration testing\n\nTo conduct a security test, please notify us in advance via the Auth0 Support Center. Auth0 requires at least one week (seven days) notice prior to your test's planned start date.\n\nIf the test is isolated to your infrastructure (that is, there will be no testing of Auth0 services), you do not need to notify Auth0.\n\nFor the information that we require, see our [Penetration Testing Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/penetration-testing-policy).\n\n### Failover testing\n\nThis policy outlines the necessary requirements for Okta to perform failover testing for Private Cloud customers on either the AWS or Azure Customer Identity Cloud (Auth0) platform with the required Geo Failover add-on. You may file a failover testing request via the [Support Center.](https://support.auth0.com/) Under the Issue field, select Private Cloud Support Incident.\n\nTo be considered for approval, the request must:\n\n*   Be filed at least two (2) weeks prior to the desired test date and time (in UTC). In many cases, Okta encourages one (1) month of advance notice to ensure time for a thorough review and any required modifications.\n    \n*   Fall under the limit of (2) failover tests per calendar year.\n    \n*   Receive approval in writing before any testing is conducted.\n    \n*   Specify windows (in UTC)  for both the failover and the fallback to the primary region, with an understanding that both windows will result in downtime of up to 15 minutes.\n    \n*   Designated point-of-contact specified with whom Okta will coordinate all testing logistics\n    \n\nPlease note that Okta reserves the right to suggest alternative windows for the failover and fallback to correspond to availability of Staff to perform the requested testing. Additionally, any service interruption that results as part of the failover or fallback procedures is exempt of any SLA provisions.\n\n## Certificate renewal process\n\nAuth0-managed certificates (in the format \\*.auth0app.com) are the responsibility of Auth0 to both obtain and apply. Auth0 will manage the process end-to-end and will prompt you with any action required.\n\nRenewal of Auth0-issued certificates for custom domains is managed by Auth0.\n\nRenewal of customer-managed certificates for [custom domains](https://auth0.com/docs/customize/custom-domains) (in the format \\*.<CustomerName>.com) is the customer’s responsibility to manage and obtain.\n\n## Reporting and monitoring\n\nAuth0 provides logs that are accessible via the Dashboard or the [log streaming endpoint](https://auth0.com/docs/customize/log-streams).\n\n## Support\n\nYou can reach out to the Auth0 [Support](https://support.auth0.com/) team with any questions or concerns you might have. To help expedite your request, please provide as much information as possible in the [Support ticket you open](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets).",
  "title": "Private Cloud on AWS",
  "description": "Learn about the Auth0 identity platform on AWS deployment option and its capabilities.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/log-streams/datadog-dashboard-templates",
  "markdown": "# Use Auth0 Dashboard Templates with Datadog\n\nAuth0 provides predefined templates that you can use to visualize the data from your Auth0 tenant in Datadog. Display visualizations to monitor the health of the login traffic for a tenant. Templates allow you to use recommended aggregations from Auth0, or to use them as a starting point to create your own custom visualizations.\n\n| Template | Purpose | Downloadable File |\n| --- | --- | --- |\n| Security Dashboard | Monitor tenant login traffic including login, account creation, and anomaly detection metrics. | [Auth0SecDashboard.json](https://cdn.auth0.com/website/docs/logs/streams/datadog/Auth0SecurityDashboard.json) |\n\nYou can also organize your visualization using the following features:\n\n*   Use Datadog time selection to choose the window for your visualization. \n    \n*   Use filters to narrow down data analysis using configurable parameters such as IP address, Country, User, and Client Application. \n    \n*   Use **Edit Widgets** to rearrange the tiles and visualizations, as well as create copies where you can inspect and add parameters to queries as needed.\n    \n\n## Prerequisites\n\n*   [Set up log streaming to Datadog](https://marketplace.auth0.com/integrations/datadog-log-streaming).\n    \n*   Download the desired dashboard template JSON file from Auth0.\n    \n\n## Upload dashboard templates in Datadog\n\n1.  Log into [Datadog](https://www.datadoghq.com/).\n    \n2.  Navigate to **Dashboards** on the left navigation bar.\n    \n3.  Select **Screenboard** as the dashboard type.\n    \n4.  On the blank canvas, in the upper right, select the gear icon and click **Import Dashboard JSON**.\n    \n5.  Upload the JSON file for the dashboard you wish to use (for example, `Auth0SecDashboard.json`).\n    \n\n## Security Dashboard visualizations\n\nOnce you have imported the Security Dashboard from Auth0, you can use the following visualizations to determine the health of your tenant or as a starting point to build your own visualizations and alerts in Datadog.\n\n![Datadog Security Dashboard](https://images.ctfassets.net/cdy7uua7fh8z/4wePsuSDxyqijm4GghGRiN/a298aab5e7ed837e33ec649c4168bd68/datadog-security-dashboard.png)\n\n| Visualization | Purpose |\n| --- | --- |\n| Login Success | Displays the number of successful login events for the tenant. |\n| Login Failures | Displays the number of failed login events for the tenant. Spikes in login failures may be a signal of anomalous traffic. |\n| Login Failures by Geolocation | Displays the number of failed login events for the tenant by geolocation. Unexpected traffic spikes in certain geographies may be a signal of anomalous traffic. |\n| Number of Unique IPs sending traffic | Displays the number of IP addresses that are sending traffic to the tenant. This number often follows predictable patterns, and strong variations may signal anomalous traffic. |\n| Top 5 IPs with failures | Displays the 5 IP addresses that have experienced the highest number of login errors. |\n| Account Creation Events in top countries | Displays the number of accounts created in the top countries. Variations in the predictable patterns and geographies may signal anomalous traffic. |\n| Account Creation Events by Platform | Displays the number of accounts created by platform, such as Windows, OSX, Android, or iOS. |\n| IPs with most accounts created | Displays the IP addresses from which the most number of accounts have been created. |\n| Anomaly Detection Events | Displays the number of anomaly detection events for the tenant, including the number of blocked IP addresses due to Brute Force Protection and Breached Password Detection. |\n| Log Stream | Displays raw events from the tenant log. |\n\n## Customize dashboard\n\nYou can customize your Datadog Auth0 security dashboard to add custom data widgets.\n\n1.  Navigate to your Auth0 security dashboard and go to the **Dashboards** item in the side navigation.\n    \n2.  Select the name of the dashboard you created from the list.\n    \n3.  Select a visualization and drag it to the main section of the page.\n    \n    ![Customize Datadog Auth0 Security Dashboard](https://images.ctfassets.net/cdy7uua7fh8z/5aerr3kQ1wqmmkDf0PVQer/6af8c1cbf05d474405e8822de4e650c7/Auth0_Datadog_Security_Dashboard_customization_.png)\n4.  Configure your data graph preferences.\n    \n\n## Learn more\n\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)\n*   [Configure Datadog as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-datadog)",
  "title": "Use Auth0 Dashboard Templates with Datadog",
  "description": "Describes how to import and use Auth0 dashboard templates to visualize the data from your Auth0 tenant in Datadog.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/log-streams/sumo-logic-dashboard",
  "markdown": "# Use Auth0 App for Sumo Logic\n\nYou can use the **Auth0 App for Sumo Logic** to visualize the data from your Auth0 tenant in a Sumo Logic dashboard. The dashboard allows you to monitor the health of the login traffic for a tenant. The app allows you to use recommended aggregations from Auth0, or to use them as a starting point to create your own custom visualizations.\n\n## Prerequisite\n\n[Set up log streaming to Sumo Logic](https://marketplace.auth0.com/integrations/sumo-logic-log-streaming).\n\n## Install the Auth0 App for Sumo Logic\n\n1.  Log in to [](https://www.datadoghq.com/)[](https://www.splunk.com/)[Sumo Logic](https://www.sumologic.com/).\n    \n2.  From the **App Catalog**, search for and select the Auth0 app.\n    \n3.  To install the app, complete the following fields:\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **App Name** | Retain the existing name or enter a name of your choice. |\n    | **Data Source** | Choose **Source Category** and select a category from the list, or choose **Enter a Custom Data Filter** and enter a custom source category beginning with an underscore. For example: **_sourceCategory=MyCategory_**. |\n    | **Advanced** | Select the **Location in Library** (default is Personal folder) or click **New Folder** to add a new folder. |\n    \n4.  Select **Add to Library**.\n    \n\nOnce an app is installed, it appears in your **Personal** folder or the folder you selected. From here, you can share it with your organization.\n\nPanels will fill automatically over time. Panels fill slowly fills with data matching the time range query and received since the panel was created.\n\n![Sumo Logic Dashboard with Auth0 streaming data](https://images.ctfassets.net/cdy7uua7fh8z/2BynHH8t2c8axVoRK0h1Et/715854ee4e6774c64973ef1ecd7e8390/sumo-logic-dashboard.png)\n\nThe dashboard is broken down into the following categories or panels:\n\n*   **Login Metrics**: See the count of actions such as successful logins and failed logins. \n    \n*   **Account Creation Metrics**: See the breakdowns of account creation by country, platform, IP, and other demographics.\n    \n*   **Security Metrics**: See anomaly detection events over time to detect and attack.\n    \n\n## Dashboard filters\n\nEach dashboard has a set of filters that you can apply to the entire dashboard. Click the funnel icon in the top dashboard menu bar to display a scrollable list of filters that are applied across the entire dashboard. \n\nEach panel also has a set of filters that are applied to the results for that panel only. Click the funnel icon in the top panel menu bar to display a list of panel-specific filters.\n\n## Customize dashboard\n\nYou can customize your Sumo Logic Auth0 security dashboard to add custom data widgets.\n\n1.  Navigate to your Auth0 security dashboard and select **add panel** in the top right corner.\n    \n2.  Select a panel type by clicking the icon. See [Sumo Logic help](https://help.sumologic.com/Visualizations-and-Alerts/Dashboard_(New)/Panels) for details.\n    \n3.  Enter logs query, metrics query, or multiple queries from the drop-down.\n    \n4.  To change the chart type, see [Sumo Logic help](https://help.sumologic.com/Visualizations-and-Alerts/Dashboard_(New)/Panels/01Modify_a_Chart) for the available options.\n    \n5.  Click **Add to Dashboard** on the top right to add the panel to your dashboard.\n    \n\n## Learn more\n\n*   [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes)\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)",
  "title": "Use Auth0 App for Sumo Logic",
  "description": "Describes how to use the Auth0 App for Sumo Logic to create a Sumo Logic Auth0 dashboard to visualize your tenant traffic.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/log-streams/splunk-dashboard",
  "markdown": "# Use Auth0 App for Splunk\n\n#### Before you start\n\nYou can use the **Auth0 App for Splunk** to visualize the data from your Auth0 tenant in a Splunk dashboard. The dashboard allows you to monitor the health of the login traffic for a tenant. The app allows you to use recommended aggregations from Auth0, or to use them as a starting point to create your own custom visualizations.\n\n## Install the Auth0 App for Splunk\n\n1.  Log into [Splunk](https://www.splunk.com/).\n    \n2.  Navigate to the [Auth0 App for Splunk](https://splunkbase.splunk.com/app/5193) app page.\n    \n3.  Select the green **Install** button.\n    \n4.  Enter your username and password, accept the terms and conditions, and select **Login and Install**.\n    \n5.  On the **Complete** widget that results, select the **Open the App** button. The Auth0 Dashboard with default filters applied appears.\n    \n    ![Auth0 App for Splunk Security Dashboard](https://images.ctfassets.net/cdy7uua7fh8z/3TezBl7S7ZL4mEScWVibPP/0d28f7ea7f1851a1817b5fd1a3861597/splunk-dashboard.png)\n\n## Dashboard filters\n\nThe following filters exist to allow you to drill down into the specifics of your traffic. You can enter `*****` to search across all values for that field.\n\n| Filter | Description |\n| --- | --- |\n| Time Range | A Splunk time input element that lets you choose the duration over which to view events. |\n| Index | The Splunk `index` you want to search within. While creating your `Http Event Collector Token`, if you specified a particular index, you may use this value from the dropdown. |\n| HTTP Source | The Splunk `source` name. |\n| IP  | The IP address whose traffic you want to inspect. This maps to `data.ip` in the log event. |\n| Client | The client whose traffic you want to inspect. This maps to `data.client_name` in the log event. |\n| Country | The country whose traffic you want to inspect. This is a field obtained using the `iplocation data.ip` search command in the query. It results in a `Country` field being added to each log event. |\n| Username | The email address whose login traffic you want to inspect. This maps to `data.user_name` in the log event. |\n\n## Customize dashboard\n\nYou can customize your Splunk Auth0 security dashboard to add custom data widgets.\n\n1.  Navigate to your Auth0 security dashboard and select **edit** in the top right corner.\n    \n2.  In the Edit Dashboard panel, select **add panel** and then choose a content type. For example line chart, event, or area chart.\n    \n3.  Enter the time range, content title, and search string for the data visualization.\n    \n4.  Select **Add to dashboard** to add your new data widget.\n    \n\n## Learn more\n\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)",
  "title": "Use Auth0 App for Splunk",
  "description": "Learn how to use the Auth0 App for Splunk to create a Splunk Auth0 dashboard to visualize your tenant traffic.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-add-on-features",
  "markdown": "# Private Cloud Add-on Features\n\nThe Private Cloud deployment option comes with two additional add-on features: Geo-failover and PCI compliance. If you have any questions about these features, please [contact Auth0 Sales](https://auth0.com/get-started?place=documentation%20post&type=link&text=contact%20auth0%20sales).\n\n## Private Cloud Geo-Failover\n\nGeo-failover is an active-passive failover configuration, which allows customers to specify a secondary failover region to use in the event of a major regional outage. In general, any region in the same cloud provider that is within 100ms latency can be selected as a failover region. In some cases, however, cloud providers prefer specific failover regions. The Auth0 onboarding team will work with you to select the best regions for your use case.\n\nAdditionally, a third \"tie break\" region is required for one of our data stores. This third region never receives live traffic but is required to elect a new leader in the event of a failover. Auth0 can also help you select the best option for this region.\n\nIf a regional failure is detected, Geo-failover triggers on the customer's behalf by Auth0. The entire process is automated once triggered. When confirmation the region is no longer experiencing issues is received, Auth0 will failback to the primary region.\n\n## PCI Compliance\n\nPCI Compliance is available as an add-on to customers who require it.",
  "title": "Private Cloud Add-on Features",
  "description": "Learn about add-on features that can complement your Auth0 Private Cloud deployment.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool/use-as-a-cli",
  "markdown": "# Use as a CLI\n\nThe Deploy CLI can be used as a standalone command line utility. Doing so provides a simple way to manage your Auth0 tenant configuration in CI/CD workflows.\n\nFor a comprehensive list of configuration settings, please read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\n## export command\n\nFetching configurations from Auth0 tenant to the local machine.\n\n### \\--output\\_folder, -o\n\nPath. Specifies the target directory for configuration files to be written to.\n\n### \\--config\\_file, -c\n\nPath. Specifies the user-defined configuration file (`config.json`). To learn more, read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\n### \\--format, -f\n\nOptions: `yaml` or `directory`. Determines the file format of the exported resource configuration files. To learn more, read [Available Resource Configuration Formats](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/available-resource-configuration-formats).\n\n### \\--export\\_ids, -e\n\nBoolean. When enabled, will export the identifier fields for each resource. Default: `false`.\n\n### \\--env\n\nBoolean. Indicates if the tool should ingest environment variables or not. Default: `true`.\n\n### \\--debug\n\nBoolean. Enables more verbose error logging; useful during troubleshooting. Default: `false`.\n\n### \\--proxy\\_url, -p\n\nA url for proxying requests. Only set this if you are behind a proxy.\n\n### Examples\n\n#### Fetching Auth0 tenant configuration in the YAML format\n\n`a0deploy export -c=config.json --format=yaml --output_folder=local`\n\n#### Fetching Auth0 tenant configuration in directory (JSON) format\n\n`a0deploy export -c=config.json --format=directory --output_folder=local`\n\n#### Fetching Auth0 tenant configurations with IDs of all assets\n\n`a0deploy export -c=config.json --format=yaml --output_folder=local --export_ids=true`\n\n## import command\n\nApplying configurations from local machine to Auth0 tenant.\n\n### \\--input\\_file, -i\n\nPath. Specifies the location of the resource configuration files. For YAML formats, this will point to the `tenant.yaml` file, for directory formats, this will point to the resource configuration directory.\n\n### \\--config\\_file, -c\n\nPath. Specifies the user-defined configuration file (`config.json`). To learn more, read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\n### \\--env\n\nBoolean. Indicates if the tool should ingest environment variables or not. Default: `true`.\n\n### \\--proxy\\_url, -p\n\nA url for proxying requests. Only set this if you are behind a proxy.\n\n### \\--debug\n\nBoolean. Enables more verbose error logging; useful during troubleshooting. Default: `false`.\n\n### Examples\n\n#### Deploying configuration for YAML formats\n\n`a0deploy import -c=config.json --input_file=local/tenant.yaml`\n\n#### Deploying configuration for directory format\n\n`a0deploy import -c=config.json --input_file=local`\n\n#### Deploying configuration with environment variables ignored\n\n`a0deploy import -c=config.json --input_file=local/tenant.yaml --env=false`",
  "title": "Use as a CLI",
  "description": "Learn how to the use the Auth0 Deploy CLI as a standalone command-line utility.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool/keyword-replacement",
  "markdown": "# Keyword Replacement\n\nThe Deploy CLI supports dynamic keyword replacement with environment-specific values. This enables a scalable multi-tenant workflow where all tenants share the same resource configuration files but inject subtly different values.\n\nTo use the keyword replacement, the `AUTH0_KEYWORD_REPLACEMENT_MAPPINGS` configuration property needs to contain the appropriate mappings. Then, in the resource configuration files, keywords can be injected through one of two ways:\n\n1.  `@@EXAMPLE_KEY@@`: Using the `@` symbols causes the tool to perform a `JSON.stringify` on your value before replacing it. So if your value is a string, the tool will add quotes; if your value is an array or object, the tool will add braces.\n    \n2.  `##EXAMPLE_KEY##`: Using the `#` symbol causes the tool to perform a literal replacement; it will not add quotes or braces.\n    \n\n## Example config.json\n\n```\n{\n  \"AUTH0_DOMAIN\": \"test-tenant.us.auth0.com\",\n  \"AUTH0_CLIENT_ID\": \"FOO\",\n  \"AUTH0_CLIENT_SECRET\": \"BAR\",\n  \"AUTH0_KEYWORD_REPLACE_MAPPINGS\": {\n    \"ENVIRONMENT\": \"dev\",\n    \"ALLOWED_LOGOUT_URLS\": [\"https://dev-test-site.com/logout\", \"localhost:3000/logout\"],\n    \"ALLOWED_ORIGINS\": [\"https://dev-test-site.com\", \"localhost:3000\"]\n  }\n}\n```\n\n## Example tenant.yaml\n\n```\ntenant:\n  friendly_name: \"##ENVIRONMENT## tenant\"\n  allowed_logout_urls: @@ALLOWED_LOGOUT_URLS@@\n  enabled_locales:\n    - en\nclients:\n  - name: Test App\n    allowed_origins: @@ALLOWED_ORIGINS@@\n    allowed_logout_urls: @@ALLOWED_LOGOUT_URLS@@\n```\n\n## Example tenant.json\n\n```\n{\n  \"friendly_name\": \"##ENVIRONMENT## tenant\",\n  \"allowed_logout_urls\": \"@@ALLOWED_LOGOUT_URLS@@\"\n}\n```\n\n## Array Concatenation\n\nYou may encounter situations where you would want to concatenate values onto a static array through keyword replacement. There is no special syntax to support this case, however, it is possible to achieve this by escaping double quotes in a single string that contains the appropriate values and injecting with the `##` keyword syntax. This technique works for both the [YAML and directory formats](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/available-resource-configuration-formats).\n\n### Example config.json\n\n```\n{\n  \"AUTH0_KEYWORD_REPLACE_MAPPINGS\": {\n    \"GLOBAL_WEB_ORIGINS\": \"\\\"http://local.me:8080\\\", \\\"http://localhost\\\", \\\"http://localhost:3000\\\"\"\n  }\n}\n```\n\n### Example tenant.yaml\n\n```\nclients:\n  - name: Test App\n    web_origins: [ \"http://production-app.com\", \"https://production-app.com\", ##GLOBAL_WEB_ORIGINS## ]\n```\n\n## Preserve Keywords on Export\n\nGenerally, the Deploy CLI works best when operating in a uni-directional workflow from your lower-level environments (ex: dev, test) up to your production environments. However, there will be times when it is necessary to export configuration from a higher-level environment onto your local configuration directory. By default, the remote values will overwrite your local values, **causing the deletion of your keyword markers**. However, keyword replacement preservation can be enabled through the `AUTH0_PRESERVE_KEYWORDS` boolean configuration property. By enabling this configuration, the Deploy CLI will attempt to preserve the keyword markers defined in your local configuration files during export.\n\nThe keyword preservation functionality will attempt to preserve as many keywords while also maintaining the accuracy of your resource configuration files. And it the majority of cases, it will work without any intervention by the user. However, some key limitations exist:\n\n*   In the case of a keyword-replaced configuration field with differing values between local and remote, the local configuration value will always be favored. This will cause **any out-of-band changes on remote to be wiped away** if a keyword replace marker exists anywhere in that field's value in the resource definition file; there is no \"intelligent\" reconciliation.\n    \n*   Arrays without a specific identifiers are not eligible for preservation. Ex: `[\"http://site.com/logout\", \"localhost:3000/logout\", \"##LOGOUT_URL##\"]`. This is because the ordering of these values are non-deterministic. Alternatively, to preserve these values, it is recommended to leverage the `@@ARRAY_REPLACE@@` keyword replace syntax with the entire value.\n    \n\nTo learn more about the history and technical challenges of of keyword preservation, refer to [RFC: Keyword Preservation During Export](https://github.com/auth0/auth0-deploy-cli/issues/688).",
  "title": "Keyword Replacement",
  "description": "Learn how to manage a multi-tenant workflow with the Auth0 Deploy CLI using keyword replacement.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool/incorporate-into-multi-environment-workflows",
  "markdown": "# Incorporate into Multi-environment Workflows\n\nThe Deploy CLI supports working within a multi-tenant, multi-environment context. When integrated into your CI/CD development workflows, can be used to propagate Auth0 changes from feature development all the way through production.\n\nIn general, the advised workflow is as follows:\n\n1.  Create a separate Auth0 tenant for each environment (development, staging, production).\n    \n2.  Create a single repository of resource configuration files for all environments.\n    \n3.  Add a step in your CI/CD pipeline when deploying to environments that applies the Auth0 resource configurations to the appropriate Auth0 tenant.\n    \n\n## Tenant to environment\n\nIt is recommended to have a separate Auth0 tenant/account for each environment you have. For example:\n\n| **Environment** | **Tenant** |\n| --- | --- |\n| Development | `travel0-dev` |\n| Testing | `travel0-uat` |\n| Staging | `travel0-stage` |\n| Production | `travel0-prod` |\n\n## Resource configuration repository\n\nWhen exported, your Auth0 tenant state will be represented as a set of resource configuration files, either in a [YAML or directory format](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/available-resource-configuration-formats). In a multi-environment context it is expected to have a single repository of resource configurations that is applied to all environments. In practice, this may exist as a directory in your project’s codebase or in a separate codebase altogether.\n\nYou should have at least one branch for each tenant in your repository, which allows you to make changes without deploying them. This way, changes will only deploy when you merge the working branch into the primary branch (such as `main` or `master`). With this setup, you can have a continuous integration task for each environment that automatically deploys changes to the targeted environment whenever the primary branch receives updates.\n\nYour workflow could potentially look something like this:\n\n1.  Make changes to development.\n    \n2.  Merge changes to testing (or uat).\n    \n3.  Test changes to uat. When ready, move and merge the changes to staging.\n    \n4.  Test staging. When ready, move and merge the changes to production.\n    \n\nAs a precaution, you may want to set your production environment to deploy only when triggered manually.\n\n## Unidirectional flow\n\nThe multi-environment workflow works best when changes are propagated “up” in a single direction. Changes to the resource configuration files should first be applied to the lowest level environment (such as development) and then incrementally applied up through all other environments until applied to production. This unidirectional practice ensures sufficient testing and approval for changes to your tenant. Once set, it is recommended to not apply configurations directly to production through other means such as the Auth0 Dashboard or Management API unless those changes are captured by a subsequent Deploy CLI export. Otherwise, those changes are subject to overwrite.\n\n## Environment-specific values\n\nWhile it is expected that all environments will share the same set of resource configuration files, environment-specific values can be expressed through separate tool configuration files and dynamic [Keyword Replacement](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/keyword-replacement).\n\n## Separate configuration files\n\nSpecifying a separate tool configuration file per environment can be used to keep the resource configuration files agnostic of the environment, but still support the needs of each environment. At a minimum, you will need to provide separate credentials for each environment, but it is also possible to exclude certain resources, enable deletion, and perform dynamic keyword replacement on a per-environment basis.\n\n### Example file structure\n\n```\nproject-root\n│\n└───auth0\n│   │   config-dev.json   # Dev env config file\n│   │   config-test.json  # Test env config file\n│   │   config-prod.json  # Prod env config file\n│   │   ... all other resource configuration files\n│\n└───src\n    │   ... your project code\n```\n\n## Dynamic values with keyword replacement\n\nOnce separate configuration files are adopted for each environment, keyword replacement through the `AUTH0_KEYWORD_REPLACE_MAPPINGS` configuration property can be used to express the dynamic replacement values depending on the environment. For example, you may find it necessary to have a separate set of allowed origins for your clients. To learn more, read [Keyword Replacement](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/keyword-replacement).\n\n### Example config-dev.json\n\n```\n{\n  \"AUTH0_DOMAIN\": \"travel0-dev.us.auth0.com\",\n  \"AUTH0_CLIENT_ID\": \"PdwQpGy62sHcsV6ufZNEVrV4GDlDhm74\",\n  \"AUTH0_ALLOW_DELETE\": true,\n  \"AUTH0_KEYWORD_REPLACE_MAPPINGS\": {\n    \"ENV\": \"dev\",\n    \"ALLOWED_ORIGINS\": [\"http://localhost:3000\", \"http://dev.travel0.com\"]\n  }\n}\n```\n\n### Example config-prod.json\n\n```\n{\n  \"AUTH0_DOMAIN\": \"travel0.us.auth0.com\",\n  \"AUTH0_CLIENT_ID\": \"vZCEFsDYzXc1x9IomB8dF185e4cdVah5\",\n  \"AUTH0_ALLOW_DELETE\": false,\n  \"AUTH0_KEYWORD_REPLACE_MAPPINGS\": {\n    \"ENV\": \"prod\",\n    \"ALLOWED_ORIGINS\": [\"http://travel0.com\"]\n  }\n}\n```",
  "title": "Incorporate into Multi-environment Workflows",
  "description": "Learn how to support multi-tenant, multi-environment workflows when using the Auth0 Deploy CLI.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool/authenticate-with-your-tenant",
  "markdown": "# Authenticate with your Tenant\n\nThere are three supported methods of authenticating the Auth0 Deploy CLI with your tenant.\n\n## Client credentials\n\n[Client credentials](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) authentication requires you provide a client ID and client secret pair directly to the application. This option is straightforward and enables the quickest path to setup for the tool.\n\nTo configure client credentials authentication, set the the following fields in your [configuration file](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli):\n\n| **Field** | **Value** |\n| --- | --- |\n| `AUTH0_CLIENT_ID` | Client ID of your Auth0 application. |\n| `AUTH0_CLIENT_SECRET` | Client secret of your Auth0 application. |\n\n## Private key JWT\n\n[Private key JWT](https://auth0.com/docs/get-started/applications/configure-private-key-jwt) authentication requires you configure a private key for the application and a public key for the remote tenant. This option is ideal if do not want to store credentials remotely on Auth0.\n\nTo configure private key JWT authentication, set the following fields in your [configuration file](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli):\n\n| **Field** | **Value** |\n| --- | --- |\n| `AUTH0_CLIENT_SIGNING_KEY_PATH` | Relative path to the JWT signing key certificate. |\n| `AUTH0_CLIENT_SIGNING_ALGORITHM` | Optional. JWT signing algorithm used for the certificate. |\n\n## Access token\n\n[Access token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production) authentication requires you provide an Auth0 Management API access token directly to the application. This option puts more responsibility on developers but can enable flexible and specific workflows when necessary.\n\nTo configure access token authentication, pass a Management API Auth0 access token through the `AUTH0_ACCESS_TOKEN` [environment variable](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).",
  "title": "Authenticate with your Tenant",
  "description": "Learn about the different methods of authenticating the Auth0 Deploy CLI with your tenant.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool/use-as-a-node-module",
  "markdown": "# Use as a Node Module\n\nThe Deploy CLI can not only be used as a standalone CLI, but as a node module. Doing so allows you to manage Auth0 resources within expressive node scripts.\n\nFor a comprehensive list of configuration settings, please read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\n## dump function\n\nFetches configurations from Auth0 tenant to the local machine.\n\n### Argument parameters\n\n#### format\n\nOptions: `yaml` or `directory`. Determines the file format of the exported resource configuration files. To learn more, read [Available Resource Configuration Formats](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/available-resource-configuration-formats).\n\n#### output\\_folder\n\nPath. Specifies the target directory for configuration files to be written to.\n\n#### config\n\nObject. Configures behavior of utility. To learn more, read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\n#### config\\_file\n\nPath. Specifies the user-defined configuration file (`config.json`). To learn more, read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\n#### export\\_ids\n\nBoolean. When enabled, will export the identifier fields for each resource. Default: `false`.\n\n#### env\n\nBoolean. Indicates if the tool should ingest environment variables or not. Default: `false`.\n\n#### proxy\\_url\n\nA url for proxying requests. Only set this if you are behind a proxy.\n\n### Example\n\n```\nimport { dump } from 'auth0-deploy-cli';\n\ndump({\n  output_folder: './local',\n  format: 'yaml',\n  config: {\n    AUTH0_DOMAIN: '<YOUR_AUTH0_TENANT_DOMAIN>',\n    AUTH0_CLIENT_ID: '<YOUR_AUTH0_CLIENT_ID>',\n    AUTH0_CLIENT_SECRET: '<YOUR_AUTH0_CLIENT_SECRET>',\n  },\n})\n  .then(() => {\n    console.log('Auth0 configuration export successful');\n  })\n  .catch((err) => {\n    console.log('Error during Auth0 configuration export:', err);\n  });\n```\n\n## deploy function\n\nApplies configurations from local machine to Auth0 tenant.\n\n### Argument parameters\n\n#### input\\_file\n\nPath. Specifies the location of the resource configuration files. For YAML formats, this will point to the `tenant.yaml` file. For directory formats, this will point to the resource configuration directory.\n\n#### config\n\nObject. Configures behavior of utility. To learn more, read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\n#### config\\_file\n\nPath. Specifies the user-defined configuration file (`config.json`). To learn more, read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\n#### export\\_ids\n\nBoolean. When enabled, will export the identifier fields for each resource. Default: `false`.\n\n#### env\n\nBoolean. Indicates if the tool should ingest environment variables or not. Default: `false`.\n\n#### proxy\\_url\n\nA url for proxying requests. Only set this if you are behind a proxy.\n\n### Example\n\n```\nimport { deploy } from 'auth0-deploy-cli';\n\ndeploy({\n  input_file: './local/tenant.yaml',\n  config: {\n    AUTH0_DOMAIN: '<YOUR_AUTH0_TENANT_DOMAIN>',\n    AUTH0_CLIENT_ID: '<YOUR_AUTH0_CLIENT_ID>',\n    AUTH0_CLIENT_SECRET: '<YOUR_AUTH0_CLIENT_SECRET>',\n  },\n})\n  .then(() => {\n    console.log('Auth0 configuration applied to tenant successful');\n  })\n  .catch((err) => {\n    console.log('Error when applying configuration to Auth0 tenant:', err);\n  });\n```",
  "title": "Use as a Node Module",
  "description": "Learn how to the use the Auth0 Deploy CLI as a node module.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool/exclude-resources-from-management",
  "markdown": "# Exclude Resources From Management\n\nIn some cases, you may find it useful to exclude resources from being managed. This could be because your tenant has a large number of a particular resource and it’s operationally burdensome to manage them, or your development workflow only pertains to a specific subset of resources and you’d like to omit all other resources for performance. Regardless, there are several options available for excluding resources when using the Deploy CLI.\n\n## Exclude entire resources by type\n\nFor more complex tenants, you may find yourself wanting to omit entire resource types. For example:\n\n*   Enterprise tenant with thousands of organizations, where managing all would be operationally burdensome.\n    \n*   CI/CD process only focuses on managing roles, and you want to exclude all others.\n    \n*   Feature development pertains to hook, and you want to temporarily exclude all others to optimize performance.\n    \n\nThis type of exclusion is expressed by passing an array of resource names into either the `AUTH0_EXCLUDED` or `AUTH0_INCLUDED_ONLY` configuration properties. The `AUTH0_EXCLUDED` configuration property excludes only the resource types provided to it. Inversely, the `AUTH0_INCLUDED_ONLY` property excludes all properties except the ones defined. Exclusion works bi-directionally, that is, both when export from Auth0 and importing to Auth0, regardless if resource configuration files exist or not.\n\nAll supported resource values for exclusion: `actions`, `attackProtection`, `branding`, `clientGrants`, `clients`, `connections`, `customDomains`, `databases`, `emailProvider`, `emailTemplates`, `guardianFactorProviders`, `guardianFactorTemplates`, `guardianFactors`, `guardianPhoneFactorMessageTypes`, `guardianPhoneFactorSelectedProvider`, `guardianPolicies`, `logStreams`, `migrations`, `organizations`, `pages`, `prompts`, `resourceServers`, `roles`, `tenant`, `triggers`.\n\n### Exclusion example\n\nThe following example shows how to exclude `clients`, `connections`, `databases`, and `organizations` from being managed by the Deploy CLI.\n\n```\n{\n  \"AUTH0_DOMAIN\": \"example-site.us.auth0.com\",\n  \"AUTH0_CLIENT_ID\": \"<YOUR_AUTH0_CLIENT_ID>\",\n  \"AUTH0_EXCLUDED\": [\"clients\", \"connections\", \"databases\", \"organizations\"]\n}\n```\n\n### Inclusion example\n\nThe following example shows how to specify to only manage `actions`, `clients` and `connections` by the Deploy CLI.\n\n```\n{\n  \"AUTH0_DOMAIN\": \"example-site.us.auth0.com\",\n  \"AUTH0_CLIENT_ID\": \"<YOUR_AUTH0_CLIENT_ID>\",\n  \"AUTH0_INCLUDED_ONLY\": [\"actions\", \"clients\", \"connections\"]\n}\n```\n\n## Exclude single resources by ID\n\nSome resource types support exclusions of the individual resource by ID. This is useful if you work in a multi-environment context and wish to omit a production-specific resource from your lower-level environments.\n\nThis method is supported for rules, clients, databases, connections and resource servers with the `AUTH0_EXCLUDED_RULES`, `AUTH0_EXCLUDED_CLIENTS`, `AUTH0_EXCLUDED_DATABASES`, `AUTH0_EXCLUDED_CONNECTIONS`, `AUTH0_EXCLUDED_RESOURCE_SERVERS` configuration values respectively.\n\n### Example\n\n```\n{\n  \"AUTH0_DOMAIN\": \"example-site.us.auth0.com\",\n  \"AUTH0_CLIENT_ID\": \"<YOUR_AUTH0_CLIENT_ID>\",\n  \"AUTH0_EXCLUDED_CLIENTS\": [\"PdmQpGy72sHksV6ueVNZVrV4GDlDDm76\"],\n  \"AUTH0_EXCLUDED_CONNECTIONS\": [\"con_O1H3KyRMFP1IWRq3\", \"con_9avEYuj19ihqKBOs\"]\n}\n```\n\n## Omission and empty states\n\nIn addition to excluding resources, which forcefully ignore configurations bi-directionally, the Auth0 Deploy  CLI supports two similar concepts: omission and empty states.\n\n### Omission\n\nResource configuration that is absent, either intentionally or unintentionally, will be skipped during import. For example, if your resource configuration were deleted, it would be skipped during import and would not alter the state of the remote tenant.\n\nThere is no concept of omission for exporting. Unless specifically excluded, all your tenant configurations will be written to resource configuration files.\n\n#### Example\n\n```\nroles: # roles configuration is not omitted\n  - name: Admin\n    description: Can read and write things\n    permissions: []\n  - name: Reader\n    description: Can only read things\n    permissions: []\n# The omission of all other configurations means they'll be skipped over\n```\n\n### Empty\n\nResource configuration that is explicitly defined as empty. For set-based configurations like hooks, organizations, and actions, setting these configurations to an empty set expresses an intentional emptying of those resources. This would signal a deletion, so long as the AUTH0\\_ALLOW\\_DELETE deletion configuration property is enabled. To learn more about this property, read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\nFor non-set-based resource configuration like tenant and branding, the concept of emptiness does not apply, and will not trigger any deletions or removals.\n\n#### Example of emptiness\n\n```\nhooks: [] # Empty hooks\nconnections: [] # Empty connections\ntenant: {} # Effectively a no-op, emptiness does not apply to non-set resource config\n```",
  "title": "Exclude Resources From Management",
  "description": "Learn how to exclude resources from being managed when using the Auth0 Deploy CLI.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli",
  "markdown": "# Configure the Deploy CLI\n\nConfiguring the Deploy’s CLI is essential for establishing Auth0 credentials as well as generally modifying the behavior of the tool to your specific needs. There are two ways the Deploy CLI can be configured:\n\n1.  Use the configuration file (`config.json`).\n    \n2.  Set environment variables.\n    \n\n## Configuration file\n\nA standalone JSON file can be used to configure Deploy CLI. This file will usually reside in the root directory of your project and should be named `config.json`.\n\n### Example\n\n```\n{\n  \"AUTH0_DOMAIN\": \"<YOUR_TENANT_DOMAIN>\",\n  \"AUTH0_CLIENT_ID\": \"<YOUR_CLIENT_ID>\",\n  \"AUTH0_ALLOW_DELETE\": false\n}\n```\n\n## Environment variables\n\nBy default, the Deploy CLI ingests environment variables, providing the ability to pass credentials and other configurations to the tool without needing to publish to the `config.json` file. Environment variables can either be used to augment the `config.json` file or replace it altogether depending on the project needs.\n\nNon-primitive configuration values like `AUTH0_KEYWORD_REPLACE_MAPPINGS` and `AUTH0_EXCLUDED` can also be passed in through environment variables so long as these values are properly serialized JSON.\n\nTo disable the consumption of environment variables for either the `import` or `export` commands, pass the `--env=false` argument.\n\n### Examples\n\n#### Deploying configuration for YAML formats without a config.json file\n\n```\n$ export AUTH0_DOMAIN=<YOUR_AUTH0_DOMAIN>\n$ export AUTH0_CLIENT_ID=<YOUR_CLIENT_ID>\n$ export AUTH0_CLIENT_SECRET=<YOUR_CLIENT_SECRET>\n$ a0deploy import --input_file=local/tenant.yaml\n```\n\n#### Disable environment variable ingestion\n\n```\n$ a0deploy export -c=config.json --format=yaml --output_folder=local --env=false\n```\n\n#### Non-primitive configuration values\n\n```\n$ export AUTH0_EXCLUDED='[\"actions\",\"organizations\"]'\n$ export AUTH0_KEYWORD_REPLACE_MAPPINGS='{\"ENVIRONMENT\":\"dev\"}'\n$ a0deploy export -c=config.json --format=yaml --output_folder=local\n```\n\n## Available Configuration Properties\n\n### AUTH0\\_DOMAIN\n\nString. The domain of the target Auth0 tenant.\n\n### AUTH0\\_CLIENT\\_ID\n\nString. The ID of the designated Auth0 application used to make API requests.\n\n### AUTH0\\_CLIENT\\_SECRET\n\nString. The secret of the designated Auth0 application used to make API requests.\n\n### AUTH0\\_ACCESS\\_TOKEN\n\nString. Short-lived access token for Management API from designated Auth0 application. Can be used in replacement to client ID and client secret combination.\n\n### AUTH0\\_CLIENT\\_SIGNING\\_KEY\\_PATH\n\nString. The path to the private key used by the client when facilitating Private Key JWT authentication. Path relative to the working directory. Also note `AUTH0_CLIENT_SIGNING_ALGORITHM` for specifying signing algorithm.\n\n### AUTH0\\_CLIENT\\_SIGNING\\_ALGORITHM\n\nString. Specifies the JWT signing algorithms used by the client when facilitating Private Key JWT authentication. Only used in combination with `AUTH0_CLIENT_SIGNING_KEY_PATH`.\n\nAccepted values: `RS256`, `RS384`, `PS256`.\n\n### AUTH0\\_ALLOW\\_DELETE\n\nBoolean. When enabled, will allow the tool to delete resources. Default: `false`.\n\n### AUTH0\\_EXCLUDED\n\nArray of strings. Excludes entire resource types from being managed, bi-directionally. To learn more, read [Exclude Resources from Management](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/exclude-resources-from-management).\n\nCannot be used simultaneously with [AUTH0\\_INCLUDED\\_ONLY](#auth0_included_only).\n\nPossible values: `actions`, `attackProtection`, `branding`, `clientGrants`, `clients`, `connections`, `customDomains`, `databases`, `emailProvider`, `emailTemplates`, `guardianFactorProviders`, `guardianFactorTemplates`, `guardianFactors`, `guardianPhoneFactorMessageTypes`, `guardianPhoneFactorSelectedProvider`, `guardianPolicies`, `logStreams`, `migrations`, `organizations`, `pages`, `prompts`, `resourceServers`, `roles`, `tenant`, `triggers`.\n\n#### Example\n\n```\n{\n  \"AUTH0_EXCLUDED\": [\"organizations\", \"connections\", \"hooks\"]\n}\n```\n\n### AUTH0\\_INCLUDED\\_ONLY\n\nArray of strings. Specifies which resource types to manage bi-directionally. To learn more, read [Exclude Resources from Management](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/exclude-resources-from-management).\n\nCannot be used simultaneously with [AUTH0\\_EXCLUDED](#auth0_excluded).\n\nPossible values: `actions`, `attackProtection`, `branding`, `clientGrants`, `clients`, `connections`, `customDomains`, `databases`, `emailProvider`, `emailTemplates`, `guardianFactorProviders`, `guardianFactorTemplates`, `guardianFactors`, `guardianPhoneFactorMessageTypes`, `guardianPhoneFactorSelectedProvider`, `guardianPolicies`, `logStreams`, `migrations`, `organizations`, `pages`, `prompts`, `resourceServers`, `roles`, `tenant`, `triggers`.\n\n#### Example\n\n```\n{\n  \"AUTH0_INCLUDED_ONLY\": [\"clients\", \"connections\", \"tenant\", \"branding\"]\n}\n```\n\n### AUTH0\\_KEYWORD\\_REPLACE\\_MAPPINGS\n\nMapping of specific keywords to facilities dynamic replacement. To learn more, read [Keyword Replacement](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/keyword-replacement).\n\n#### Example\n\n```\n{\n  \"ENVIRONMENT\": \"DEV\",\n  \"ALLOWED_ORIGINS\": [\"https://dev.test-site.com\", \"localhost\"]\n}\n```\n\n### AUTH0\\_PRESERVE\\_KEYWORDS\n\nBoolean. When enabled, will attempt to preserve keyword replacement markers in local resource files during export. Otherwise, the remote values will overwrite those manually-placed keyword markers.\n\nThis configuration requires the presence of local configuration files and defined keyword replace mappings via the `AUTH0_KEYWORD_REPLACE_MAPPINGS` configuration property.\n\nSee also: [Preserve Keywords on Export](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/keyword-replacement#preserve-keywords-on-export).\n\n### AUTH0\\_EXPORT\\_IDENTIFIERS\n\nBoolean. When enabled, will return identifiers of all resources. May be useful for certain debugging or record-keeping scenarios within a single-tenant context. Default: `false`.\n\n### EXCLUDED\\_PROPS\n\nProvides ability to exclude any unwanted properties from management.\n\n#### Example\n\n```\n{\n  \"connections\": [\"options.twilio_token\"]\n}\n```\n\n### AUTH0\\_AUDIENCE\n\nString. Separate value from audience value while retrieving an access token for the Management API. Useful when default Management API endpoints are not publicly exposed.\n\n### AUTH0\\_EXCLUDED\\_RULES\n\nArray of strings. Excludes the management of specific rules by ID. Note: This configuration may be subject to deprecation in the future. To learn more, read [Exclude Resources from Management](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/exclude-resources-from-management).\n\n### AUTH0\\_EXCLUDED\\_CLIENTS\n\nArray of strings. Excludes the management of specific clients by ID. Note: This configuration may be subject to deprecation in the future. To learn more, read [Exclude Resources from Management](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/exclude-resources-from-management).\n\n### AUTH0\\_EXCLUDED\\_DATABASES\n\nArray of strings. Excludes the management of specific databases by ID. Note: This configuration may be subject to deprecation in the future. To learn more, read [Exclude Resources from Management](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/exclude-resources-from-management).\n\n### AUTH0\\_EXCLUDED\\_CONNECTIONS\n\nArray of strings. Excludes the management of specific connections by ID. Note: This configuration may be subject to deprecation in the future. To learn more, read [Exclude Resources from Management](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/exclude-resources-from-management).\n\n### AUTH0\\_EXCLUDED\\_RESOURCE\\_SERVERS\n\nArray of strings. Excludes the management of specific resource servers by ID. Note: This configuration may be subject to deprecation in the future. To learn more, read [Exclude Resources from Management](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/exclude-resources-from-management).",
  "title": "Configure the Deploy CLI",
  "description": "Learn how to configure the Auth0 Deploy CLI to modify the tool for your needs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool/available-resource-configuration-formats",
  "markdown": "# Available Resource Configuration Formats\n\nAuth0 resource state is expressed in two available different configuration file formats: YAML and directory (JSON). When using the Deploy CLI’s `export` command, you will be prompted with the choice of one versus the other.\n\n## YAML\n\nThe YAML format is expressed mostly as a flat tenant.yaml file with supplemental code files for resources like actions and email templates. The single file makes tracking changes over time in version control more straightforward. Additionally, the single file eliminates a bit of ambiguity with directory and file names, which may not be immediately obvious.\n\n## Directory (JSON)\n\nThe directory format separates resource types into separate directories, with each single resource living inside a dedicated JSON file. This format allows for easier conceptual separation between each type of resource as well as the individual resources themselves. Also, the Deploy CLI closely mirrors the data shapes defined in the [Auth0 Management API](https://auth0.com/docs/api/management/v2), so referencing the JSON examples in the docs may be useful when using this format.\n\n## How to choose\n\nThe decision to select which format to use should be primarily made off of preference. Both formats are tenable solutions that achieve the same task, but with subtly different strengths and weaknesses described above. Be sure to evaluate each in the context of your context. Importantly, this choice is not permanent, and switching from one to the other with the `import` command is an option at your disposal.",
  "title": "Available Resource Configuration Formats",
  "description": "Learn about the available configuration formats when using the Auth0 Deploy CLI.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/rules-best-practices",
  "markdown": "# Rules Best Practices\n\nRules can be used in a variety of situations as part of the authentication pipeline where protocol-specific artifacts are generated:\n\n*   an ID Token in OpenID Connect (OIDC)\n    \n*   an Access Token in OAuth 2.0\n    \n*   an assertion in SAML\n    \n\nA new pipeline in which rules execute is created for each authentication request.\n\nAuth0 provides a number of pre-existing rules and rule templates to help you achieve your goal(s). To see a list, visit our [rules repository on GitHub](https://github.com/auth0/rules).\n\nYou may also want to build your own Rule(s) to support your specific functionality requirements. You can modify a pre-existing rule template or choose to start from scratch using one of our samples. Either way, there are a number of best practices that you’ll want to adopt to ensure that you achieve the best possible outcome.\n\n## Learn more\n\n*   [Rules Anatomy Best Practices](https://auth0.com/docs/rules-best-practices/rules-anatomy-best-practices)\n*   [Rules Environment Best Practices](https://auth0.com/docs/rules-best-practices/rules-environment-best-practices)\n*   [Rules Execution Best Practices](https://auth0.com/docs/rules-best-practices/rules-execution-best-practices)\n*   [Rules Security Best Practices](https://auth0.com/docs/rules-best-practices/rules-security-best-practices)\n*   [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)",
  "title": "Rules Best Practices",
  "description": "Learn about best practices for writing and managing Auth0 rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool/resource-specific-documentation",
  "markdown": "# Resource-specific Documentation\n\nIn general, the Deploy CLI resource configuration files closely match the payload schemas of the [Auth0 Management API](https://auth0.com/docs/api/management/v2), but there are some notable nuances to be aware of.\n\n## Client grants\n\nThe Deploy CLI's own client grant is intentionally not exported nor configurable by itself. This is done to prevent breaking changes, otherwise the tool could potentially revoke access or otherwise crash in the midst of an import. In a multi-tenant, multi-environment context, it is expect that new tenants will have a designated client already established for the Deploy CLI, as mentioned in [Getting Started](https://auth0.com/docs/deploy-monitor/deploy-cli-tool).\n\n## Prompts\n\nMultilingual custom text prompts follow a particular hierarchy. Under the root-level prompts resource property is a proprietary `customText` property that is used to bundle custom text translations with other prompts settings. Underneath `customText` is the two-character language code. Thirdly is the prompt ID, followed by the screen ID, followed by text ID.\n\n### Hierarchy\n\n```\nprompts:\n  customText:\n    <LANGUAGE>: # two character language code\n      <PROMPT_ID>: # prompt ID\n        <SCREEN_ID>: # prompt screen ID\n          <TEXT_ID>: 'Some text'\n```\n\n### Example\n\n```\nprompts:\n  identifier_first: true\n  universal_login_experience: classic\n  customText:\n    en:\n      login:\n        login:\n          description: Login description in english\n          buttonText: Button text\n      mfa:\n        mfa-detect-browser-capabilities:\n          pickAuthenticatorText: 'Try another method'\n          reloadButtonText: 'Reload'\n          noJSErrorTitle: 'JavaScript Required'\n        mfa-login-options:\n          pageTitle: 'Log in to ${clientName}'\n          authenticatorNamesSMS: 'SMS'\n```\n\n## Databases\n\nWhen managing database connections, the values of `options.customScripts` point to specific javascript files relative to the path of the output folder. Otherwise, the payload closely matches that of the [Auth0 Management API](https://auth0.com/docs/api/management/v2#!/Connections/post_connections).\n\n### YAML example\n\nFolder structure when in YAML mode:\n\n```\n./databases/\n    /Username-Password-Authentication\n        /change_password.js   \n        /create.js   \n        /delete.js   \n        /get_user.js   \n        /login.js   \n        /verify.js   \n./tenant.yaml\n```\n\n Contents of `tenant.yaml`:\n\n```\ndatabases:\n  - name: Username-Password-Authentication\n    # ...\n    options:\n      # ...\n      customScripts:\n        change_password: ./databases/Username-Password-Authentication/change_password.js\n        create: ./databases/Username-Password-Authentication/create.js\n        delete: ./databases/Username-Password-Authentication/delete.js\n        get_user: ./databases/Username-Password-Authentication/get_user.js\n        login: ./databases/Username-Password-Authentication/login.js\n        verify: ./databases/Username-Password-Authentication/verify.js\n```\n\n### Directory example\n\nFolder structure when in directory mode:\n\n```\n./database-connections/\n    ./Username-Password-Authentication/\n        ./change_password.js\n        ./create.js\n        ./database.json\n        ./delete.js\n        ./get_user.js\n        ./login.js\n        ./verify.js\n```\n\nContents of `database.json`:\n\n```\n{\n  \"options\": {\n    \"customScripts\": {\n      \"change_password\": \"./change_password.js\",\n      \"create\": \"./create.js\",\n      \"delete\": \"./delete.js\",\n      \"get_user\": \"./get_user.js\",\n      \"login\": \"./login.js\",\n      \"verify\": \"./verify.js\"\n    }\n  }\n}\n```\n\n## Universal Login\n\n### Pages\n\nWhen overriding the Universal Login with custom HTML, the error, login, multi-factor authentication, and password reset contents are organized in specific HTML pages.\n\n#### YAML example\n\nFolder structure when in YAML mode:\n\n```\n./pages/\n    /error_page.html\n    /guardian_multifactor.html\n    /login.html\n    /password_reset.html\n./tenant.yaml\n```\n\nContents of `tenant.yaml`:\n\n```\npages:\n  - name: error_page\n    html: ./pages/error_page.html\n    show_log_link: false\n    url: https://mycompany.org/error\n  - name: guardian_multifactor\n    enabled: true\n    html: ./pages/guardian_multifactor.html\n  - name: login\n    enabled: false\n    html: ./pages/login.html\n  - name: password_reset\n    enabled: true\n    html: ./pages/password_reset.html\n```\n\n#### Directory Example\n\nFolder structure when in directory mode:\n\n```\n./pages/\n    ./error_page.html\n    ./error_page.json\n    ./guardian_multifactor.html\n    ./guardian_multifactor.json\n    ./login.html\n    ./login.json\n    ./password_reset.html\n    ./password_reset.json\n```\n\nContents of `login.json`:\n\n```\n{\n  \"name\": \"login\",\n  \"enabled\": false,\n  \"html\": \"./login.html\"\n}\n```\n\nContents of `error_page.json`:\n\n```\n{\n  \"html\": \"./error_page.html\",\n  \"show_log_link\": false,\n  \"url\": \"https://mycompany.org/error\",\n  \"name\": \"error_page\"\n}\n```\n\nContents of `guardian_multifactor.json`:\n\n```\n{\n  \"enabled\": true,\n  \"html\": \"./guardian_multifactor.html\",\n  \"name\": \"guardian_multifactor\"\n}\n```\n\nContents of `password_reset.json`:\n\n```\n{\n  \"enabled\": true,\n  \"html\": \"./password_reset.html\",\n  \"name\": \"password_reset\"\n}\n```",
  "title": "Resource-specific Documentation",
  "description": "Learn about the specifics of resource documentation for the Auth0 Deploy CLI.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/monitor/check-auth0-status",
  "markdown": "# Check Auth0 Status\n\nGo to the [Auth0 Public Cloud Status](https://status.auth0.com/) page to check the service availability of the public cloud version of Auth0.\n\nSelect a **Region** from the dropdown menu to see the status of Core Services (such as User Authentication and Machine-to-Machine Authentication) and Supporting Services (such as MFA, Management API, Tenant Logs, and CDN).\n\nFor more information on available regions, refer to the [Region, locality, and sub-locality](https://auth0.com/docs/get-started/auth0-overview/create-tenants#region-locality-and-sub-locality) table in [Create Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants).\n\n## Subscribe to status updates\n\nSelect a **Region**, and then select **Subscribe to Updates** to get updates. You can choose from two options to view status:\n\n1.  Follow [@auth0status](https://twitter.com/auth0status) on X to get the latest status updates.\n    \n2.  Subscribe to the Auth0 Atom or RSS feed to get status updates that affect your tenant. Replace `{YOUR_TENANT_DOMAIN}` with your tenant's **Domain**. RSS feeds for Private Cloud are not currently supported.\n    \n\nTo find your tenant's **Domain**, go to [Auth0 Dashboard > Applications](https://manage.auth0.com/dashboard/#/applications), select an application, and then go to **Settings**. Your tenant's **Domain** is listed under **Basic Information**.\n\n## Check Auth0 status for Private Cloud\n\nGo to the [Auth0 Public Cloud Status](https://status.auth0.com/), and then select **Private Cloud Login**.\n\nOnce authenticated, you can see the status of any non-development environment (for example, `travel0-prod-1`) if it's available on the Auth0 Converged Platform.\n\nTo go back to the Auth0 Public Cloud Status page, select **Auth0 Public Cloud Status** from the top-right navigation.\n\n![Generic example of a private cloud authenticated status page experience](https://images.ctfassets.net/cdy7uua7fh8z/96ORa2wB8LuMh9nehPeZB/8afb82058ac82f027f82a5b870d5b479/Screen_Shot_2022-12-02_at_1.21.42_PM.png)",
  "title": "Check Auth0 Status",
  "description": "Learn how to check Auth0 public cloud service availability, incident reports, and historical uptime reports.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/monitor/check-external-services-status",
  "markdown": "# Check External Services Status\n\nWe recommend that you monitor any remote identity providers you use with your Auth0 connections to quickly isolate the source of the problem.\n\nIf you see potential issues with your Auth0 service, but [Auth0 Status](https://status.auth0.com/) doesn't indicate any problems, check the status of any external services that you use with Auth0, such as:\n\n*   [Amazon Web Services](https://status.aws.amazon.com/)\n    \n*   [Azure Active Directory](https://azure.microsoft.com/en-us/status/)\n    \n*   [Citrix](https://status.cloud.com/)\n    \n*   [Facebook](https://developers.facebook.com/status/)\n    \n*   [GitHub](https://status.github.com/)\n    \n*   [Google Cloud](https://status.cloud.google.com/)\n    \n*   [Google Workspace](https://www.google.com/appsstatus#hl=en&v=status)\n    \n*   [Heroku](https://status.heroku.com/)\n    \n*   [IBM](https://console.bluemix.net/status)\n    \n*   [Mandrill](http://status.mandrillapp.com/)\n    \n*   [Microsoft Azure](https://azure.microsoft.com/en-gb/status/)\n    \n*   [SAP](https://www.sap.com/about/cloud-trust-center/cloud-service-status.html)\n    \n*   [SendGrid](http://status.sendgrid.com/)\n    \n*   [SFDC](https://status.salesforce.com/)\n    \n*   [Slack](https://status.slack.com/)\n    \n*   [Twilio](https://status.twilio.com/)\n    \n*   [VM Ware](https://status.vmware-services.io/)\n    \n\nYour customers may have some of the same concerns, so you may want to document any monitoring pages or endpoints that they can view to help them troubleshoot and narrow down the location of an issue.",
  "title": "Check External Services Status",
  "description": "Learn how to check the status of services external to Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/monitor/monitor-using-scom",
  "markdown": "# Monitor Auth0 Using System Center Operations Manager\n\nYou can monitor Auth0 as a standard web application using System Center Operations Manager (SCOM) or any tool that supports synthetic transactions. We recommend adding a synthetic login transaction that includes the extensions your applications rely on (such as rules that execute custom code for integration with your company's other services).\n\n## Set up SCOM\n\n1.  Add a new SCOM instance using the **Add Monitoring Wizard**:\n    \n    | Field | Description |\n    | --- | --- |\n    | Name | Description name for the SCOM instance. |\n    | Description | Description of what this SCOM instance monitors. |\n    | Select destination management pack | Default Management Pack |\n    \n    When finished, click **Next** to continue.\n2.  Click **Add** to enter the URLs you want SCOM to monitor. When finished, click **Next** to continue.\n    \n3.  Click **Add** to set up a location from which you want to monitor.\n    \n4.  In the pop-up dialog, search for **Internal location - Agent**. Select the appropriate address, and click **Add**. Then click **Ok** to finish selecting the location. When finished, click **Next** to continue.\n    \n5.  Set the frequency with which SCOM collects data from each endpoint:\n    \n    | Data | Frequency |\n    | --- | --- |\n    | Test frequency | 60 seconds |\n    | Performance data collection interval | 60 seconds |\n    | Test time-out | 30 seconds |\n    | HTTP status code | Greater than or equals 400 |\n    \n6.  When finished, click **Next** to continue.\n    \n\n## Run SCOM tests\n\n1.  Click **Run Test** to test each endpoint and ensure that the connection settings provided are correct.\n    \n2.  Once you have finished configuring your SCOM instance, you can view activity through the **Monitoring** tab.\n    \n\n## Review test results\n\nClick **Web Application Status** to bring up the information SCOM has gathered.\n\n## Learn more\n\n*   [Check Auth0 Status](https://auth0.com/docs/deploy-monitor/monitor/check-auth0-status)\n*   [Monitor Applications](https://auth0.com/docs/deploy-monitor/monitor/monitor-applications)\n*   [Check External Services Status](https://auth0.com/docs/deploy-monitor/monitor/check-external-services-status)",
  "title": "Monitor Auth0 Using System Center Operations Manager",
  "description": "Describes how to monitor Auth0 as a standard web application using System Center Operations Manager (SCOM) or any tool that supports synthetic transactions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/support-channels",
  "markdown": "# Support Channels\n\nAuth0 offers the following support channels.\n\n## Auth0 status\n\nThe [Auth0 status page](https://status.auth0.com/) contains information on current production status and will be updated during an outage. After an outage, a root-cause analysis is performed and made available via the page.\n\nPlease check the status page before filing a ticket. If the status page contains a notification about an outage, our team will already be working on restoring service as quickly as possible. Once the issue is resolved, the status page will be updated to reflect that. There is a button on the page to subscribe to notifications of any changes. A root-cause analysis will be published to the status page once an investigation has been done.\n\n## Auth0 Support site\n\nThe [official Auth0 support site](https://support.auth0.com/) has a search function that answers many common questions about the product, including questions about the Auth0 Dashboard, command line interface, and APIs.\n\nAuth0's public [question and answer community](https://community.auth0.com/) offers support for **all** subscribers. All customers, even those on free tenants, can search through existing questions and post a new question if theirs hasn't been answered. There are no guaranteed response times for questions posted.\n\n## Auth0 security bulletins\n\nYou can see a list of Auth0 security bulletins that address security vulnerabilities of Auth0 software. Each bulletin contains a description of the vulnerability, how to identify if you are affected and what to do to fix it. See [Auth0 Security](https://auth0.com/docs/secure) for details.\n\n## Learn more\n\n*   [Premier Success Plans](https://auth0.com/docs/troubleshoot/customer-support/support-plans)",
  "title": " Support Channels",
  "description": "The different ways that Auth0 provides support",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/support-plans",
  "markdown": "# Premier Success Plans\n\n**Premier Success Plans Priority Levels**\n\nIn the event that a Service-affecting issue is detected by Okta or reported by Customer, Okta shall, in its reasonable discretion, categorize the Priority Level pursuant to the criteria below.\n\n| Priority level | Description | Examples |\n| --- | --- | --- |\n| 1   | A Service failure or severe degradation. Customer is unable to access any business resources. | Service is down and not accessible by Users; Service is slowed to such a degree that multiple Users cannot log in, resulting in consistent “page not found errors” or similar. |\n| 2   | A partial Service failure or mild degradation. Customer is able to access some but not all business resources. | Customer lacks write-access to the administrative feature of the Service (excluding regularly scheduled Service upgrades); Users can access the Service, but access is slow, sometimes resulting in “page not found” messages or similar, with access functioning as expected upon page refresh. |\n| 3   | Minor Service impact. Customer is able to access almost all business resources. | Non-critical individual third party applications such as “personal email” are not accessible by all Users; one User is not able to access a business application; Customer is unable to successfully integrate a new business application with the Service. |\n| 4   | Customer is able to access all business resources. Service feature enhancement request or how-to/product-functionality questions. | How-to questions and Service feature enhancement requests. |\n\n**Premier Success Plans Response Times and Support Hours**\n\nOkta will use reasonable efforts to adhere to the following response times pursuant to the Okta Premier Success Plan indicated on the Order Form. Okta may reduce case priority to a lower Priority Level at its discretion. For clarity, Response Time refers to the period of time from when a support case has been submitted by Customer and Okta’s initial response to Customer.\n\nIf Customer selects a Priority Level 1 case priority, Customer shall remain accessible (continuous 24x7 availability) for engagement and troubleshooting with Okta support from the time the case is submitted until the issue is mitigated.\n\n|     | Basic | Silver | Gold |\n| --- | --- | --- | --- |\n| Support Hours | 24x5\\* | 24x7 | 24x7 |\n| Priority Level 1 Response Time | 2 hours | 1 hour | 30 minutes |\n| Priority Level 2 Response Time | 12 hours | 2 hours | 1 hour |\n| Priority Level 3 Response Time | 24 hours | 8 hours | 4 hours |\n| Priority Level 4 Response Time | 24 hours | 24 hours | 24 hours |\n\n\\*Okta shall endeavor to meet 24x5 Support Hours (12:01am Monday until 11:59pm Friday local time) for Basic, but reserves the right to reduce Support Hours at its discretion.\n\n[Auth0 Enterprise and Premier Support](https://auth0.com/docs/troubleshoot/customer-support/auth0-enterprise-and-premier-support) are no longer offered to new customers or customers that have transitioned to a Premier Success Plan.\n\n## Learn more\n\n*   [Support Channels](https://auth0.com/docs/troubleshoot/customer-support/support-channels)\n*   [Responsible Disclosure Program Security Support Tickets](https://auth0.com/docs/troubleshoot/customer-support/responsible-disclosure-program-security-support-tickets)",
  "title": "Premier Success Plans",
  "description": "The different levels of Auth0 support",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/self-service-support",
  "markdown": "# Self Service Support\n\n#### Self Service Support Features\n\n*   Answer questions concerning usage issues related to CIC specific features, options and configurations\n    \n*   Provide initial and high-level suggestions regarding the appropriate usage, features, or solution configurations for the particular type of reporting, analysis, or functionality\n    \n*   Isolate, document, and find alternative solutions for reported Defects\n    \n*   Work with Okta Operations, Product, Software Development, and QA staff to submit Change Requests, Enhancement Requests, and provide Fixes for CIC as necessary\n    \n*   Address customer concerns with online or printed documentation, providing additional examples or explanation for concepts requiring clarification\n    \n*   Access to online release notes for Updates\n    \n*   Access to Okta’s online library of support webinars and knowledgebase\n    \n*   Access to Okta’s Customer Community forums to collaborate with fellow Okta customers\n    \n\n**Self Service Defect Severity Levels** \n\nOkta will assign Defects one of the four Severity Level priorities, depending upon the resulting impact caused by the Defect. Okta may re-assign a Severity Level prioritization to Customer in the trouble ticketing system, based on the descriptions below. Okta’s assignment will be consistent with the Severity Level descriptions below. Severity Level categories are as follows:\n\n| Severity Level | Description |\n| --- | --- |\n| 1 (urgent) | Emergency Issue; Defect resulting in full or partial system outage or a condition that makes CIC unusable or unavailable in production for all of Customer’s Users. |\n| 2 (high) | Significant Business Impact; Defect resulting in a condition where major functionality is impacted or significant performance degradation is experienced; issue is persistent and affects many Users and/or major functionality. |\n| 3 (normal) | Minor Feature / Function Issue / General Question; Defect results in a component of CIC not performing as expected or documented. An inquiry by Customer representatives regarding general technical issues/questions. |\n| 4 (low) | Minor Problem / Enhancement Request; Information requested on CIC capabilities, navigation, installation, or configuration; enhancement request. |\n\n**Self Service Defect Response** \n\nThe priority of a Defect will determine the timing and nature of the response as specified in the table below:\n\n| Defect Severity Level | Target Response Time (Self Service Support ) | Solution Definition (one or more of the following) |\n| --- | --- | --- |\n| 1 (urgent) | 3 business hours | • Issue is resolved  <br>• Workaround is provided  <br>• Fix is provided  <br>• Fix incorporated into future release |\n| 2 (high) | 12 business hours | • Issue is resolved  <br>• Workaround is provided  <br>• Fix is provided  <br>• Fix incorporated into future release |\n| 3 (medium) | 1 business day | • Issue is resolved  <br>• Workaround is provided  <br>• Fix incorporated into future release  <br>• Answer to question is provided |\n| 4 (low) | 2 business days | • Answer to question is provided  <br>• Enhancement request logged |\n\n**Support Hours**\n\nOkta’s Self Service Support hours for Defects is 6 AM to 6 PM Customer local time, Monday to Friday for all Severity Levels.",
  "title": "Self Service Support",
  "description": "Description of the Self-Service Support Plan for the Okta Customer Identity Cloud",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix",
  "markdown": "# Product Support Matrix\n\nAuth0 provides support in alignment with the [terms of service](https://auth0.com/terms) and [pricing and support plans](https://auth0.com/pricing/). These are the types of support provided by Auth0:\n\n| **Level** | **Description** |\n| --- | --- |\n| Supported | Auth0 has formally tested these items, may provide both new features and bug fixes (if applicable), and will provide customer support. |\n| Sustained | Auth0 may provide bug fixes (if applicable) for these items, and will provide customer support. |\n| Bug Fixes | Auth0 may provide bug fixes (if applicable) for these items, but will not provide customer support. |\n| Community | Auth0 will not provide customer support for these items, and all assistance will come from the general community. |\n| Partner | Auth0 will not provide customer support for these items, and all assistance will come from the partners who maintain them. |\n\n## Auth0 support coverage\n\nOfficial support provided by Auth0 is limited to the languages, platforms, versions, and technologies specifically listed. Anything that is not listed, or is listed as community-supported is not eligible for Auth0 support. If you have questions about unsupported items, you can post your question on the [Auth0 public forum](https://community.auth0.com/).\n\nFor community-supported items, ask for help by contacting the developers responsible for those items such as submitting issues on the GitHub repositories for the specific libraries or SDKs.\n\nAuth0 support is limited to the most recent version of the technologies listed (unless otherwise specified). If you are using an older version, you will be required to upgrade prior to seeking support.\n\n## Supported browsers\n\nAll listed browsers are the latest versions unless otherwise indicated.\n\n### Auth0 Dashboard desktop browsers\n\n| **Browser** | **Support Level** |\n| --- | --- |\n| Chrome | Supported |\n| Safari | Sustained |\n| Edge | Sustained |\n| Firefox | Sustained |\n\n### Authentication desktop browsers\n\n| **Browser** | **Support Level** |\n| --- | --- |\n| Chrome | Supported |\n| Safari | Sustained |\n| Internet Explorer (v10/11) | Sustained\\* |\n| Edge | Sustained |\n| Firefox | Sustained |\n\n### Authentication mobile browsers\n\n| **Browser** | **Support Level** |\n| --- | --- |\n| Safari iOS 10+ | Supported |\n| Chrome for Android 7.1.1+ | Supported |\n\n## Supported operating systems\n\nAll listed operating systems are the latest versions unless otherwise indicated. If you are using an older version, please upgrade prior to seeking support.\n\n### Auth0 Dashboard operating systems\n\n| **Operating System** | **Support Level** |\n| --- | --- |\n| Apple MacOS (with Chrome) | Supported |\n| Apple MacOS (with other browsers) | Sustained |\n| Linux Ubuntu | Sustained |\n| Microsoft Windows | Sustained |\n\n### Authentication supported operating systems\n\n| **Operating System** | **Support Level** |\n| --- | --- |\n| Apple MacOS (with Chrome) | Supported |\n| Apple MacOS (with other browsers) | Sustained |\n| Apple iOS 10+ | Supported |\n| Google Android 7.1.1+ | Supported |\n| Linux Ubuntu | Sustained |\n| Microsoft Windows | Sustained |\n\n## Supported Auth0 libraries and SDKs\n\n### Auth0 Lock widgets and libraries\n\n### Auth0 SDKs\n\n### Framework and Platform Integration SDKs\n\n### Content Management Systems Plugins\n\n## Quickstarts and samples\n\n### Native and mobile apps\n\n### SPAs\n\n### Regular web apps\n\n### Backends and APIs\n\n## Auth0 Marketplace\n\n| **Integration** | **Support Level** |\n| --- | --- |\n| Integrations maintained by Auth0 | Supported |\n| Third-party custom integrations | Partner |\n\n## Extensions\n\n| **Extension** | **Support Level** |\n| --- | --- |\n| Auth0 extensions published to the Dashboard | Sustained |\n| Custom extensions | Community |\n\nFeature requests should be made in the GitHub repository of each extension. Please note there is no commitment from Auth0 to implement requests.\n\n## Learn more\n\n*   [Product Lifecycle](https://auth0.com/docs/troubleshoot/product-lifecycle)",
  "title": "Product Support Matrix",
  "description": "Describes Auth0 features, platforms, and software configurations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/services-level-descriptions",
  "markdown": "# Service Levels\n\nHere is a summary of the key elements of Auth0’s Service Level Agreement (SLA) for both Enterprise Public Cloud and Enterprise Private Cloud deployments of the Auth0 platform. For full details, please see [Service Level Agreement for Auth0 Platform](https://www.okta.com/sites/default/files/2022-02/ServiceLevelAgreement-for-Auth0-Platform.pdf).\n\nThe average availability of certain core services of the Auth0 platform for each month will be at least 99.99%. If Auth0 fails to meet its availability service level during any given calendar month, you may request a service level credit within 5 business days of the event.\n\nAuth0 will provide you with credit as described in the table below. If any credits are not used upon the expiration of your subscription, then we will apply the credits to any other fees or expenses you owe us. If there are no such other fees or expenses then we will refund the credit amount.\n\n| **Availability Level** | **Service Level Credit** |\n| --- | --- |\n| 98.50% - 99.98% | 5% of the Monthly Subscription Fee\\* |\n| 97.00% - 98.49% | 10% of the Monthly Subscription Fee\\* |\n| < 97.00% | 20% of the Monthly Subscription Fee\\* |\n\n\\*Credits are applicable to the calendar month in which the service disruption occurred.\n\nIf you experience an event that you believe brings you below the aforementioned Availability Levels, please contact your Auth0 Technical Account Manager.\n\nIf you require a [Private instance](https://auth0.com/docs/deploy-monitor/deploy-private-cloud) of Auth0, please contact [Auth0 Sales](https://auth0.com/get-started?place=documentation%20post&type=link&text=contact%20auth0%20sales) for additional information.\n\nVisit the [Auth0 Status Page](https://status.auth0.com/) to read current and historical uptime information for the Public Cloud environment.",
  "title": "Service Levels",
  "description": "Describes the Auth0 service levels and service level agreements (SLAs). ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords",
  "markdown": "# Reset Account Passwords\n\nIf you need to change your password or you have forgotten the password to your Auth0 account, in most cases, you can set a new password from the Auth0 Dashboard. Password resets cause Auth0 sessions to expire.\n\n1.  On the Auth0 account login screen, enter the email address associated with your account and click **Continue,** then choose **Forgot password?** at the next screen.\n    \n2.  Confirm your email address and click **Continue** to submit. You will receive an email that provides further instructions on resetting your password.\n    \n3.  If your request was successfully received, you'll see \"Please check the email address \\[your email\\] for instructions to reset your password.\"\n    \n\nThere are some special password reset circumstances:\n\n*   If you've enabled MFA and need an MFA reset for your admin account, contact [Auth0 Support](https://support.auth0.com/).\n    \n*   If you're using a social or enterprise account to log in to Auth0, reset your password with the appropriate identity provider.\n    \n*   If you are an administrator trying to reset a user's password, there are two methods:\n    \n    *   Use the interactive password reset flow with Universal Login or the Authentication API where the user receives an email with a link that opens the Auth0 password reset page to enter a new password.\n        \n    *   Directly set the new password either using the Management API or the Dashboard.",
  "title": "Reset Account Passwords",
  "description": "Describes how to reset Auth0 account passwords.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/software-updates",
  "markdown": "# Software Updates\n\nDuring the subscription term, Auth0 will provide or install updates if and when they are made generally commercially available by Auth0 to its customers. There is no additional cost to you.\n\nFor pricing information on Auth0 subscription plans, read the [Pricing Page](https://auth0.com/pricing) or go to your [Tenant Settings](https://manage.auth0.com/#/tenant/billing/subscription).\n\n## Learn more\n\n*   [Product Lifecycle](https://auth0.com/docs/troubleshoot/product-lifecycle)\n*   [Customer Support](https://auth0.com/docs/troubleshoot/customer-support)\n*   [Support Channels](https://auth0.com/docs/troubleshoot/customer-support/support-channels)\n*   [Premier Success Plans](https://auth0.com/docs/troubleshoot/customer-support/support-plans)",
  "title": "Software Updates",
  "description": "Auth0 software update process",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/versioning-strategy",
  "markdown": "# Auth0 Versioning Strategy\n\nWe believe versioning is a crucial part of our offering and work to provide a consistent versioning scheme for our products we are able to help our users manage and predict how our changes will impact usage.\n\n## Semantic versioning\n\n[Semantic versioning](http://semver.org/) (also known as semver) is a versioning strategy whose main feature is making breaking changes discoverable. A version is composed of 3 numbers separated by dots: {major}.{minor}.{patch}. For instance, 2.12.5, 0.1.0 and 10.5.35 are valid semver numbers.\n\n*   The first number represents a **major change**: the library API has changed in a non-backwards compatible way. When the major part of a version is bumped, the public API of that library has changed. For example, code and functionality previously marked as deprecated is removed from the code base.\n    \n*   The second number represents a **minor change**: the library API has new functionality added or marked as deprecated while keeping backward compatibility. The new minor version is expected to be safe for use and we encourage customers to update. However, as it is impossible to know every way customers use a component, there is always a chance that changes might have impact on the current usage of the component. Therefore, we recommend verifying and testing before performing an update.\n    \n*   The third number, represents a **patch change**: A bug has been fixed and should not have any impact on the user facing API. This should be safe to update but testing is always encouraged.\n    \n\n## Production usage\n\nAuth0 provides links to our [Content Delivery Network (CDN)](https://en.wikipedia.org/wiki/Content_delivery_network) where we serve some of our libraries. The way you reference a component in your code will impact whether and when you automatically pick up changes. For instance, if you link to the major release from within a script, and there is a new minor, you will get the update as soon as it is released. We encourage this practice for development environments and experimenting with Auth0. Here are examples of embedding the source files:\n\n```\n<!-- major release -->\n<script src=\"https://cdn.auth0.com/example/1/library.js\"></script>\n\n<!-- minor release -->\n<script src=\"https://cdn.auth0.com/example/1.0/library.js\"></script>\n\n<!-- patch release (recommended for production) -->\n<script src=\"https://cdn.auth0.com/example/1.0.1/library.js\"></script>\n```\n\nWhen Auth0 components are deployed to production, we encourage our users to anchor to a full version and thoroughly test using that version. Although adding new features in a backwards compatible way shouldn’t break your code, the interactions with the component outcome could be hard to predict. Even trivial bug fixes may introduce changes in the assumptions you were making about the component which may no longer be true.\n\nEach Auth0 open source component that follows semver will have a tag matching a released version in its git repository. As some of the projects use [npm](https://npmjs.com/) tooling to release versions the tags will have a `v` letter as a prefix. For instance, version 5.2.3 tag will be v5.2.3.\n\n## Learn more\n\n*   [Product Support Matrix](https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix)",
  "title": "Auth0 Versioning Strategy",
  "description": "Understand how Auth0 versioning works.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies",
  "markdown": "# Auth0 Operational Policies\n\nAuth0 has established operational policies that govern the following areas.\n\n## Billing\n\nThis policy covers change of address, credit card issues, canceling subscriptions, refunds, invoicing, sales tax, scaling users, and tenant conversion. See [Billing Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/billing-policy) for details.\n\n## Data export and transfer\n\nIf you would like to export your data from Auth0, you can use the [Export/Import Extension](https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data) or the Management API. See [Export Data](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data) for details.\n\nAuth0 will not transfer data from one Auth0 tenant to another. This applies to both Public Cloud and Private Cloud customers. All data in your Auth0 tenant is always under your control and is available through the Management API at any time. If you want to stop using our service, you can export your data. See [Data Export and Transfer Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/data-export-and-transfer-policy) for details.\n\n## Endpoints\n\nSee [Public Cloud Service endpoints](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/public-cloud-service-endpoints) and [API Endpoints for Single Sign-On (SSO)](https://auth0.com/docs/authenticate/single-sign-on/api-endpoints-for-single-sign-on) for details.\n\n## Load and penetration testing\n\nOnly customers who have purchased an Enterprise subscription may conduct load testing. Customers with an Enterprise subscription may request one load test (with up to 2 repeats) per year against an Auth0 production tenant. Performance and load testing is only allowed with Auth0's prior written approval. Once approved, testing can only target tenants that we have approved. See [Load Testing Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/load-testing-policy) and [Penetration Testing Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/penetration-testing-policy) for details.\n\nTo conduct these tests, notify us in advance by submitting a [Support Ticket](https://support.auth0.com/). Auth0 requires at least 7 days' notice prior to your test's planned start date.\n\n## Migrations\n\nWe apply an iterative approach to product delivery, including an iterative [product release lifecycle](https://auth0.com/docs/troubleshoot/product-lifecycle) that allows us to introduce and improve upon new functionality.\n\nWhen building Auth0 products, we resolve to\n\n*   Deliver value to customers early and often, iterating based on their feedback.\n    \n*   Seek a deep understanding of our customers and consider them in every decision.\n    \n*   Relentlessly acquire and analyze data, so we can make better choices.\n    \n*   Visualize and design for current, idealized, and future versions of our whole product when adding features.\n    \n\nTo best serve these goals, we apply an iterative approach to product delivery, including an iterative product release lifecycle that allows us to introduce and improve upon new functionality.\n\n*   [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages)\n    \n*   [Migration Process](https://auth0.com/docs/troubleshoot/product-lifecycle/migration-process)\n    \n*   [Deprecations and Migrations](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations)\n    \n*   [Past Migrations](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations)\n    \n\n## Rate limits\n\nActions such as rapidly updating configuration settings, aggressive polling, or making highly concurrent API calls may result in your app being rate limited. See [Rate Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) for details.\n\n## Entity limits\n\nEntities in Auth0 are tenant configuration elements such as applications, connections, rules, and API resource servers. Auth0 limits the number of entities you can have depending on the platform for your subscription level group. See [Entity Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/entity-limit-policy) for details.\n\n## Sanitize HAR files\n\nIf you contact [Auth0 Support](https://support.auth0.com/), you may need to include a sanitized HAR file for troubleshooting help.\n\n## Tenant restoration\n\n**Before you delete your tenant, please review the following resources for alternative options:**\n\n*   [Update Tenant Administrator](https://auth0.com/docs/get-started/manage-dashboard-access) - for changing tenant ownership\n    \n*   [Delete or Reset Tenants](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant) - for resetting tenant configuration\n    \n\nIf you've already deleted your tenant and you require the use of a particular domain name, we recommend configuring a [custom domain name](https://auth0.com/docs/customize/custom-domains) for your new tenant.\n\n## Unsupported requests\n\nOur support team strives to assist you to the best of our ability. However, we are currently unable to grant the following requests:\n\n*   Transfer data from a non-production to a production account\n    \n*   Remove a tenant admin\n    \n*   Rename a tenant\n    \n*   Rename a connection\n    \n*   Re-use the name of a previously-deleted tenant\n    \n*   Migrate a tenant from one region to another (for example, from US to EU)\n    \n*   Ad hoc usage data reports\n    \n*   Restore any deleted or modified data or settings in tenants, including\n    \n    *   Database connections and their users and passwords\n        \n    *   Users, their profile information, metadata, and role memberships\n        \n    *   Roles and permissions\n        \n    *   Application\n        \n    *   SSO integrations\n        \n    *   APIs\n        \n    *   Connections\n        \n    *   Actions\n        \n    *   Rules\n        \n    *   Hooks\n        \n    *   Extensions\n        \n    *   Email templates\n        \n    *   Tenant logs once the [standard retention time](https://auth0.com/docs/deploy-monitor/logs/log-data-retention) has passed\n        \n\n## Learn more\n\n*   [Billing Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/billing-policy)\n*   [Data Export and Transfer Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/data-export-and-transfer-policy)\n*   [Rate Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy)\n*   [Entity Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/entity-limit-policy)\n*   [Auth0 Public Cloud Service Endpoints](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/public-cloud-service-endpoints)",
  "title": "Auth0 Operational Policies",
  "description": "Describes Auth0's established operational policies including billing, data export and transfer, load and penetration testing, rate limits, tenant restoration, and Dashboard authentication. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/auth0-enterprise-and-premier-support",
  "markdown": "# Auth0 Enterprise and Premier Support\n\nAuth0 Enterprise and Premier Support are no longer offered to new customers or customers that have transitioned to a Premier Success Plan.\n\n**Auth0 Enterprise and Premier Support Defect Severity Levels** \n\nOkta will assign Defects one of the four Severity Level priorities, depending upon the resulting impact caused by the Defect. Okta may re-assign a Severity Level prioritization to Customer in the trouble ticketing system, based on the descriptions below. Okta’s assignment will be consistent with the Severity Level descriptions below. Severity Level categories are as follows:\n\n| Severity Level | Description |\n| --- | --- |\n| 1 (urgent) | Emergency Issue; Defect resulting in full or partial system outage or a condition that makes CIC unusable or unavailable in production for all of Customer’s Users. |\n| 2 (high) | Significant Business Impact; Defect resulting in a condition where major functionality is impacted or significant performance degradation is experienced; issue is persistent and affects many Users and/or major functionality. |\n| 3 (normal) | Minor Feature / Function Issue / General Question; Defect results in a component of CIC not performing as expected or documented. An inquiry by Customer representatives regarding general technical issues/questions. |\n| 4 (low) | Minor Problem / Enhancement Request; Information requested on CIC capabilities, navigation, installation, or configuration; enhancement request. |\n\n**Auth0 Enterprise and Premier Support Defect Response** \n\nThe priority of a Defect will determine the timing and nature of the response as specified in the table below:\n\n| Defect Severity Level | Target Response Time (Enterprise) | Target Response Time (Premier) | Solution Definition (one or more of the following) |\n| --- | --- | --- | --- |\n| 1 (urgent) | 30 minutes | 30 minutes | • Issue is resolved  <br>• Workaround is provided  <br>• Fix is provided  <br>• Fix incorporated into future release |\n| 2 (high) | 2 hours | 1 hour | • Issue is resolved  <br>• Workaround is provided  <br>• Fix is provided  <br>• Fix incorporated into future release |\n| 3 (medium) | 12 hours | 8 hours | • Issue is resolved  <br>• Workaround is provided  <br>• Fix incorporated into future release  <br>• Answer to question is provided |\n| 4 (low) | 24 hours | 12 hours | • Answer to question is provided  <br>• Enhancement request logged |\n\n**Auth0 Enterprise and Premier Support Hours**\n\nOkta Support hours for Defects are specified in the table below and will based on the specific Support Program that the Customer has subscribed to, or as specified in the applicable Order Form:\n\n| Enterprise Support | Premier Support |\n| --- | --- |\n| 7 x 24 x 365 for Severity Level 1 Defects; and 24 hours a day, Monday to Friday Customer local time, for all other Severity Levels | 7 x 24 x 365 for all Severity Levels |",
  "title": "Auth0 Enterprise and Premier Support",
  "description": "Description of the Auth0 Enterprise and Premier Support plans",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/responsible-disclosure-program-security-support-tickets",
  "markdown": "# Responsible Disclosure Program Security Support Tickets\n\n##### Responsible Disclosure Program Security Support Tickets\n\n[Contact sales](https://auth0.com/get-started?place=header&type=button&text=talk%20to%20sales) Log in\n\n[\n\n###### Troubleshoot\n\n](https://auth0.com/docs/troubleshoot)\n\nGet Support\n\n*   [Customer Support](https://auth0.com/docs/troubleshoot/customer-support \"Customer Support\")\n*   [Premier Success Plans](https://auth0.com/docs/troubleshoot/customer-support/support-plans \"Premier Success Plans\")\n*   [Support Channels](https://auth0.com/docs/troubleshoot/customer-support/support-channels \" Support Channels\")\n*   [Self Service Support](https://auth0.com/docs/troubleshoot/customer-support/self-service-support \"Self Service Support\")\n*   [Product Support Matrix](https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix \"Product Support Matrix\")\n*   [Service Levels](https://auth0.com/docs/troubleshoot/customer-support/services-level-descriptions \"Service Levels\")\n*   [Open and Manage Support Tickets](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets \"Open and Manage Support Tickets\")\n*   [Manage Subscriptions](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions \"Manage Subscriptions\")\n*   [Reset Account Passwords](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords \"Reset Account Passwords\")\n*   [Software Updates](https://auth0.com/docs/troubleshoot/customer-support/software-updates \"Software Updates\")\n*   [Auth0 Versioning Strategy](https://auth0.com/docs/troubleshoot/customer-support/versioning-strategy \"Auth0 Versioning Strategy\")\n*   [Operational Policies](https://auth0.com/docs/troubleshoot/customer-support/operational-policies \"Operational Policies\")\n*   [Auth0 Changelog](https://auth0.com/changelog \"Auth0 Changelog\")\n*   [Responsible Disclosure Program Security Support Tickets](https://auth0.com/docs/troubleshoot/customer-support/responsible-disclosure-program-security-support-tickets \"Responsible Disclosure Program Security Support Tickets\")\n*   [Auth0 Enterprise and Premier Support](https://auth0.com/docs/troubleshoot/customer-support/auth0-enterprise-and-premier-support \"Auth0 Enterprise and Premier Support\")\n\nTroubleshoot\n\n*   [Commonplace Issues](https://auth0.com/docs/troubleshoot/basic-issues \"Commonplace Issues\")\n*   [Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues \"Authentication Issues\")\n*   [Integration and Extensibility Issues](https://auth0.com/docs/troubleshoot/integration-extensibility-issues \"Integration and Extensibility Issues\")\n*   [Troubleshooting Tools](https://auth0.com/docs/troubleshoot/troubleshooting-tools \"Troubleshooting Tools\")\n*   [Debugging Best Practices](https://auth0.com/docs/troubleshoot/debugging-best-practices \"Debugging Best Practices\")\n*   [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices \"Error Handling Best Practices\")\n*   [Performance Best Practices](https://auth0.com/docs/troubleshoot/performance-best-practices \"Performance Best Practices\")\n*   [General Usage and Operations Best Practices](https://auth0.com/docs/troubleshoot/general-usage-and-operations-best-practices \"General Usage and Operations Best Practices\")\n\nAuth0 Product Lifecycle\n\n*   [Product Lifecycle](https://auth0.com/docs/troubleshoot/product-lifecycle \"Product Lifecycle\")\n*   [Auth0 Community](https://community.auth0.com/ \"Auth0 Community\")\n*   [Auth0 Blog](https://auth0.com/blog/ \"Auth0 Blog\")\n\nAll customers, even those with free subscription plans, can report security concerns in Auth0's [Responsible Disclosure Program](https://auth0.com/responsible-disclosure-policy). For legal information, read [Legal Details](https://auth0.com/legal).\n\n## Learn more\n\n*   [Premier Success Plans](https://auth0.com/docs/troubleshoot/customer-support/support-plans)\n*   [Software Updates](https://auth0.com/docs/troubleshoot/customer-support/software-updates)\n*   [Support Channels](https://auth0.com/docs/troubleshoot/customer-support/support-channels)\n\nWas this article helpful?",
  "title": "Responsible Disclosure Program Security Support Tickets",
  "description": "All customers, even those with free subscription plans, can report security concerns in Auth0 Responsible Disclosure Program.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs/pii-in-logs",
  "markdown": "# Personally Identifiable Information in Auth0 Logs\n\nMany events in Auth0 tenant logs can contain personally identifiable information (PII). Authentication events trigger log entries that can include users' PII. And if you use the Auth0 Management API or the Dashboard to add users, Auth0 logs the user account details.\n\nThese fields in log entries can contain PII:\n\n*   Name\n    \n*   Phone number (used for multi-factor authentication)\n    \n*   Email address\n    \n*   IP address (which can reveal location)\n    \n*   Any custom user information you define\n    \n\nAt no point does Auth0 log access tokens from Auth0 or any identity provider. When authorization code exchanges occur, the logs show only a partial code (for example: `code: 31XXXXX`).\n\n## Learn more\n\n*   [Log Data Retention](https://auth0.com/docs/deploy-monitor/logs/log-data-retention)\n*   [Log Search Query Syntax](https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax)",
  "title": "Personally Identifiable Information in Auth0 Logs",
  "description": "Describes the potential personally identifiable information (PII) that Auth0 writes to tenant logs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs/prompt-details-in-tenant-logs",
  "markdown": "# Prompt Details in Tenant Logs\n\nAuth0 tenant logs provide transaction details for user authentication actions. Tenant logs capture information from the sign-in, login, and verification processes for review. You can review how the user authenticated, which credentials they provided, length of transaction, and connection status.\n\nBelow are the default values captured in tenant logs:\n\n| **Attribute** | **Description** |\n| --- | --- |\n| `completedAt` | Stage completion time, including user interaction time |\n| `elapsedTime` | Difference between `completedAt` and `initiatedAt` |\n| `flow` | Varies based on login experience (i.e., Universal or Classic) |\n| `initiatedAt` | Stage start time |\n| `name` | Name of the stage |\n\n## login\n\nThe login stage provides the following values:\n\n| **Attribute** | **Description** |\n| --- | --- |\n| `flow` | Able to take two values dependent on Universal or Classic Login |\n| `user_id` | Auth0 ID of the user authenticated in this stage |\n| `user_name` | Name of the user authenticated in this stage |\n\nAdditional fields with the following information:\n\n| **Attribute** | **Description** |\n| --- | --- |\n| `connection` | Connection used to authenticate the user |\n| `connection_id` | ID of the connection used to authenticate the user |\n| `strategy` | Strategy of the connection used to authenticate user |\n| `identity` | Users’ authenticated identity |\n\nValues for additional events in the login flow:\n\n| **Name** | **Universal Login Experience** | **Description** |\n| --- | --- | --- |\n| `federated-authenticate` | Universal | Federated connection used for authentication, social, legal, or enterprise |\n| `lock-password-authenticate` | Classic | User authenticated with a username and password |\n| `oauth1-authenticate` | Classic | User authenticated with an oauth1 federation |\n| `oauth2-authenticate` | Classic | User authenticated with an oauth2 federation |\n| `oidc-authenticate` | Classic | User authenticated with an oidc federation |\n| `prompt-authenticate` | Universal | User authenticated with a username and password |\n| `prompt-authenticate-password` | Universal | User authenticated with username and password in the `idfirst` flow |\n| `prompt-signup` | Universal | User signed up using a username and password |\n| `prompt-signup-password` | Universal | User signed up using username and password using the `idfirst` flow |\n| `saml-authenticate` | Classic | User authenticated with a SAML federation |\n| `wsfed-authenticate` | Classic | User authenticated with a WS-FED federation |\n\n## consent\n\nThe consent stage provides the following values:\n\n| **Attribute** | **Description** |\n| --- | --- |\n| `grantInfo` | The `{myApiIdentifier}` or identifier of the API granted permission by the user |\n| `audience` | Token audience |\n| `id` | User grant persisted in the database |\n| `scope` | Approved scope granted by the user |\n\n## login-email-verification\n\nThe email verification prompt provides the following values:\n\n| **Attribute** | **Description** |\n| --- | --- |\n| `login-email-verification` | Is included if the email verification prompt was presented |\n\n## redirect\n\nThe redirect stage provides the following values:\n\n| **Attribute** | **Description** |\n| --- | --- |\n| `URL` | URL the user was redirected to |\n\n## mfa\n\nMulti-factor authentication provides the following values:\n\n| **Attribute** | **Description** |\n| --- | --- |\n| `flow` | Can take two values depending if used with the Classic experience (`mfa`) or the Universal experience (`universal-mfa`). |\n| `performed_acr` | `acr` that will be included in the `id_token`. |\n| `performed_amr` | `amr` that will be included in the `id_token`. |\n| `provider` | Provider used to perform mfa. |",
  "title": "Prompt Details in Tenant Logs",
  "description": "Describes attributes and values from user prompts in Auth0 tenant logs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs/view-log-events",
  "markdown": "# View Log Events\n\nUse the Auth0 Dashboard to view all the events that occur in your tenants including user authentication and administrative actions such as adding and updating applications, connections, and rules. Administrative actions will show up in the logs as **API Operation** events.\n\n1.  Go to [Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs).\n    \n    ![Dashboard Monitoring Logs](https://images.ctfassets.net/cdy7uua7fh8z/2l9LfKEjrprVmHfWt80VX0/bb1b8d9927d5c83d0ba094907abe5fb6/dashboard-monitoring-logs.png)\n2.  The list displays the latest events. To perform a search, put your cursor in the search field, enter a query and press **Enter**. For example, to search all logs with connections that contain \"Pass,\" enter `connection:*pass*`. To learn more about the search query syntax and examples, read [Log Search Query Syntax](https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax).\n    \n3.  You can choose to filter your search by event types. Choose a filter from the drop-down list and click **Apply**. For example, you can choose the **Failed Login** to filter for failed user login events. To learn about log event filters and examples, read [Log Event Filters](https://auth0.com/docs/deploy-monitor/logs/log-event-filters).\n    \n    ![Dashboard Monitoring Logs Filters](https://images.ctfassets.net/cdy7uua7fh8z/3bfjw3WURyQRiNhj6f8VlJ/5c71550ff0a1d51f81b0c65a4d2cc22a/dashboard-monitoring-logs-filters.png)\n4.  You can choose a date range for your search. Click the drop-down next to the date field, choose a specific date or range, and click **Apply**.\n    \n    ![Dashboard Monitoring Logs Date Range](https://images.ctfassets.net/cdy7uua7fh8z/6V9SRyQ2GlSyObjmNjBg80/41a1fe9594dfe5a1fad3f5a7f1d3cf9f/dashboard-monitoring-logs-date-range.png)\n\n## Learn more\n\n*   [Log Data Retention](https://auth0.com/docs/deploy-monitor/logs/log-data-retention)\n*   [Filter Log Events](https://auth0.com/docs/deploy-monitor/logs/log-event-filters)\n*   [Log Search Query Syntax](https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax)\n*   [Export Log Events with Rules](https://auth0.com/docs/deploy-monitor/logs/export-log-events-with-rules)",
  "title": "View Log Events",
  "description": "Learn how to view log events in the Dashboard including user authentication and administrative actions such as adding and updating applications, connections, and rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs/retrieve-log-events-using-mgmt-api",
  "markdown": "# Retrieve Log Events Using the Management API\n\nYou can use the Management API to retrieve up to 100 log events per request using the [/get\\_logs](https://auth0.com/docs/api/management/v2/#!/Logs/get_logs) endpoint, which supports two types of consumption:\n\n*   **By checkpoint**: Recommended if you want to export log events to the external data analytics service.\n    \n*   **By search criteria**: Used by the Dashboard.\n    \n\nLogs stored by Auth0 are subject to a retention period that is based on your Auth0 subscription. To learn more, read [Log Data Retention](https://auth0.com/docs/deploy-monitor/logs/log-data-retention).\n\nYou can also use these endpoints to look for logs:\n\n*   `/api/v2/logs/{id}`: Retrieves the single log entry associated with the provided log ID.\n    \n*   `/api/v2/users/{user_id}/logs`: Retrieves log events for a specific user ID.\n    \n\n## Retrieve logs by checkpoint\n\nThis method allows you to retrieve log events newer than a given `log_id`. It is commonly used to send your Logs to an external system, such as Splunk, Datadog, Application Insights, Mixpanel, and more.\n\nTo search by checkpoint, use the following parameters:\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `from` | Log event ID to start retrieving logs. You can limit the amount of logs using the `take` parameter. |\n| `take` | The total amount of entries to retrieve when using the `from` parameter. |\n\nAny parameter other than `from` and `take` will be ignored. The logs are ordered by the `log_id`.\n\n#### Semantics\n\nRetrieving logs by checkpoint have the following semantics:\n\n*   All logs available to your role's permissions will be returned\n    \n*   The logs are ordered by the `log_id`, rather than event generation time, to prevent skipping past records due to Auth0 system delays\n    \n*   Pagination is unbounded, meaning there is no limit, in contrast to the `1,000` record limit when retrieving logs by search criteria\n    \n\nWhen retrieving logs by checkpoint, only the first request should be made manually. Each subsequent request should be made using the `next` relation URL inside of the `Link` header. This simplifies the work for integrating with the API, and allows Auth0 to make optimizations without impacting the customer experience.\n\n#### Example\n\nLet's assume your tenant name in the `us` is `acme`. To start retrieving records by checkpoint:\n\n1.  Grab the `log_id` from any log in your system. Example: `90020211201185132572079310688835925971249535794074878050`.\n    \n2.  Make a request to `https://TENANT_NAME.LOCALITY.auth0.com/api/v2/logs?from=LOG_ID&take=100` to request the next `100` logs newer than the given `LOG_ID`.\n    \n3.  The HTTP response will contain\n    \n    1.  A JSON array of `0` to `100` logs newer than the given `LOG_ID`\n        \n    2.  An HTTP `Link` header with a `next` relation\n        \n4.  If the result set is empty you will receive an empty array, and the `next` relation will match the same URL you used in the most recent request\n    \n\n## Retrieve logs by search criteria\n\nThis method allows you to retrieve log events that match the specified search criteria or, if no criteria is used, lists all events. To search by criteria use the following parameters:\n\n| Parameter | Description |\n| --- | --- |\n| `q` | Search criteria using Query String Syntax. |\n| `page` | The zero-based page number. |\n| `per_page` | The number of entries per page. |\n| `sort` | The field to use for sorting. Use `field:order`, where `order` is `1` for ascending and `-1` for descending. For example `date:-1`. |\n| `fields` | A comma-separated field list to include or exclude (depending on `include_fields`) from the result. Leave empty to retrieve all fields. |\n| `include_fields` | `true` if the fields specified are to be included in the result, `false` otherwise. Defaults to `true`. |\n\nTo see a list of fields and sort parameters that can be used in the search query, read [Log Search Query Syntax](https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax).\n\n## Limitations\n\nBesides the limitation of 100 log events per request to retrieve logs, you may only paginate through up to 1,000 search results.\n\nIf you get the error `414 Request-URI Too Large` this means that your query string is larger than the supported length. In this case, refine your search.\n\n#### Private Cloud search field limitations\n\nThe following fields are searchable only for Private Cloud:\n\n*   `user`\n    \n*   `connection`\n    \n*   `application`\n    \n*   `type`\n    \n*   `ip`\n    \n\nUse double quotes for exact searches (e.g., `application:\"test\"` will search for all log events specific to the application named `test`, but `application:test` will search log events for applications with \"test\" in their name.\n\n## Learn more\n\n*   [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes)\n*   [Log Search Query Syntax](https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax)\n*   [Log Data Retention](https://auth0.com/docs/deploy-monitor/logs/log-data-retention)",
  "title": "Retrieve Log Events Using the Management API",
  "description": "Learn how to retrieve log events using the Auth0 Management API get_logs endpoint by checkpoint or by search criteria.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs/log-event-filters",
  "markdown": "# Filter Log Events\n\nBlock Account IP blocked for >10 failed attempts to login to single account Blocked IP Address IP blocked for >100 failed login attempts or >50 signup attempts Breached password Attempted login with a leaked password Device Confirmation Canceled by User User did not confirm device Error sending MFA Push Notification Push notification for MFA failed Error sending MFA SMS SMS for MFA failed Failed API Operation Operation on API failed Failed Change Email Failed to change user email Failed Change Password Failed to change user password Failed Change Password Request Change password request failed Failed Change Phone Number Failed to change user phone number Failed Change Username Failed to change username Failed Connector Provisioning Failed to provision a AD/LDAP connector Failed Delegation Failed to generate delegation token Failed Exchange Token Exchange Failed Exchange Native Socal Login Failed Exchange Authorization Code for Access Token Failed Exchange Client Credentials for Access Token Failed Exchange Password for Access Token Failed Exchange Refresh Token for Access Token Failed Exchange Password and OOB Challenge for Access Token Failed Exchange Password and OTP Challenge for Access Token Failed Exchange Password and MFA Recovery code for Access Token Failed Exchange Device Code for Access Token Failed Login User failed to login Failed Login (invalid email/username) User failed to login due to invalid username Failed Login (wrong password) User failed to login due to invalid password Failed Logout User logout failed Failed OIDC Back-Channel Logout Request Back-Channel Logout request failed Failed Post Change Password Hook Post-change password hook failed Failed Post User Registration Hook Post user registration hook failed Failed Sending Notification Failed to send email notification Failed Signup Sign up failed Failed Silent Auth Silent authentication failed Failed User Deletion User deletion failed Failed Verification Email Failed to send verification email Failed Verification Email Request Failed to process verification email request Failed CORS Origin is not in the Allowed Origins list for the specified application Failed by Connector AD/LDAP Connector Failure Failed cross origin authentication Cross-origin authentication failed Failed device activation Failed to activate device Failed device authorization request Device authorization request failed MFA Enrollment start failed Multi-factor authentication enroll failed OTP Auth failed One-time password authentication failed OTP Auth rejected One-time password authentication rejected Rate Limit on API Maximum number of requests to the Authentication API in given time has been reached Recovery failed Multi-factor recovery code failed Second factor email failed Email for MFA failed Too Many Calls to /delegation Rate limt exceeded to /delegation endpoint Too Many Calls to /userinfo Rate limit exceeded to /userinfo endpoint Too Many Invalid Device Codes Rate limit exceeded for invalid device codes",
  "title": "Filter Log Events",
  "description": "Lists the log filters for errors, warnings, and success events. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes",
  "markdown": "# Log Event Type Codes\n\n`api_limit` Rate Limit on the Authentication or Management APIs The maximum number of requests to the Authentication or Management APIs in a given time has been reached. `appi` API Peak Performance initiated Increases the Elevated Public Authentication API Limits by the 100 RPS multiple purchased by the customer for up to 48 hours per month. For more information, see [Public performance rate limit policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy#public-performance). `cls` Code/Link Sent Passwordless login code/link has been sent `cs` Code Sent Passwordless login code has been sent `depnote` Deprecation Notice `f` Failed Login `fc` Failed by Connector `fce` Failed Change Email Failed to change user email `fco` Failed by CORS Origin is not in the Allowed Origins list for the specified application `fcoa` Failed cross-origin authentication `fcp` Failed Change Password `fcph` Failed Post Change Password Hook `fcpn` Failed Change Phone Number `fcpr` Failed Change Password Request `fcpro` Failed Connector Provisioning Failed to provision a AD/LDAP connector `fcu` Failed Change Username Failed to change username `fd` Failed Delegation Failed to generate delegation token `fdeac` Failed Device Activation Failed to activate device. `fdeaz` Failed Device Authorization Request Device authorization request failed. `fdecc` User Canceled Device Confirmation User did not confirm device. `fdu` Failed User Deletion `feacft` Failed Exchange Failed to exchange authorization code for Access Token `feccft` Failed Exchange Failed exchange of Access Token for a Client Credentials Grant `fede` Failed Exchange Failed to exchange Device Code for Access Token `fens` Failed Exchange Failed exchange for Native Social Login `feoobft` Failed Exchange Failed exchange of Password and OOB Challenge for Access Token `feotpft` Failed Exchange Failed exchange of Password and OTP Challenge for Access Token `fepft` Failed Exchange Failed exchange of Password for Access Token `fepotpft` Failed Exchange Failed exchange of Passwordless OTP for Access Token `fercft` Failed Exchange Failed Exchange of Password and MFA Recovery code for Access Token `fertft` Failed Exchange Failed Exchange of Refresh Token for Access Token. This could occur if the refresh token is revoked or expired. `ferrt` Failed Exchange Failed Exchange of Rotating Refresh Token. This could occur when reuse is detected. `fi` Failed invite accept Failed to accept a user invitation. This could happen if the user accepts an invitation using a different email address than provided in the invitation, or due to a system failure while provisioning the invitation. `flo` Failed Logout User logout failed `fn` Failed Sending Notification Failed to send email notification `fp` Failed Login (Incorrect Password) `fpar` Failed Pushed Authorization Request `fs` Failed Signup `fsa` Failed Silent Auth `fu` Failed Login (Invalid Email/Username) `fui` Failed users import Failed to import users `fv` Failed Verification Email Failed to send verification email `fvr` Failed Verification Email Request Failed to process verification email request `gd_auth_failed` MFA Auth failed Multi-factor authentication failed. This could happen due to a wrong code entered for SMS/Voice/Email/TOTP factors, or a system failure. `gd_auth_rejected` MFA Auth rejected A user rejected a Multi-factor authentication request via push-notification. `gd_auth_succeed` MFA Auth success Multi-factor authentication success. `gd_enrollment_complete` MFA enrollment complete A first time MFA user has successfully enrolled using one of the factors. `gd_otp_rate_limit_exceed` Too many failures A user sends more than 10 requests to their device within one hour.\n\nUsers can only send 10 OTP requests within an hour. If they exceed this limit, they must wait at least an hour to request another OTP. One additional attempt is allowed with the passage of each subsequent hour.\n\n**Note**: The request limit does not reset upon a successful login event. Users must wait an hour after their first request to send another OTP to their device.\n\n`gd_recovery_failed` Recovery failed A user enters a wrong recovery code when attempting to authenticate. `gd_recovery_rate_limit_exceed` Too many failures A user enters a wrong recovery code too many times. `gd_recovery_succeed` Recovery success A user successfully authenticates with a recovery code. `gd_send_email` Email Sent Email for MFA successfully sent. `gd_send_pn` Push notification sent Push notification for MFA successfully sent. `gd_send_pn_failure` Push notification sent Push notification for MFA failed. `gd_send_sms` SMS sent SMS for MFA successfully sent. `gd_send_sms_failure` SMS sent failures Attempt to send SMS for MFA failed. `gd_send_voice` Voice call made Voice call for MFA successfully made. `gd_send_voice_failure` Voice call failure Attempt to make Voice call for MFA failed. `gd_start_auth` Second factor started Second factor authentication event started for MFA. `gd_start_enroll` Enroll started Multi-factor authentication enroll has started. `gd_start_enroll_failed` Enrollment failed Push to start enrollement failed. `gd_tenant_update` Guardian tenant update `gd_unenroll` Unenroll device account Device used for second factor authentication has been unenrolled. `gd_update_device_account` Update device account Device used for second factor authentication has been updated. `gd_webauthn_challenge_failed` Enrollment challenge issued User failed to verify Webauthn factor. `gd_webauthn_enrollment_failed` Enroll failed WebAuthn factor enrollment failed. `limit_delegation` Too Many Calls to /delegation Rate limit exceeded to `/delegation` endpoint `limit_mu` Blocked IP Address An IP address is blocked because it attempted too many failed logins without a successful login. Or an IP address is blocked because it attempted too many sign-ups, whether successful or failed. For more information, see [Attack Protection](https://auth0.com/docs/configure/attack-protection). `limit_wc` Blocked Account An IP address is blocked because it reached the maximum failed login attempts into a single account. `limit_sul` Blocked Account A user is temporarily prevented from logging in because they reached the maximum logins per time period from the same IP address. For more information, see [Attack Protection](https://auth0.com/docs/configure/attack-protection). `mfar` MFA Required A user has been prompted for multi-factor authentication (MFA). When using Adaptive MFA, Auth0 includes details about the risk assessment. `mgmt_api_read` Management API read Operation API GET operation returning secrets completed successfully `oidc_backchannel_logout_failed` Failed OIDC Back-Channel Logout request Failed OIDC Back-Channel Logout request `oidc_backchannel_logout_succeeded` Successful OIDC Back-Channel Logout request Successful OIDC Back-Channel Logout request `pla` Pre-login assessment This log is generated before a login and helps in monitoring the behavior of bot detection without having to enable it. `pwd_leak` Breached password Someone behind the IP address `ip` attempted to login with a leaked password. `resource_cleanup` Refresh token excess warning Emitted when resources exceeding defined limits were removed. `s` Success Login Successful login event. `sapi` Success API Operation Successful management API write event. `sce` Success Change Email `scoa` Success cross-origin authentication `scp` Success Change Password `scpn` Success Change Phone Number `scpr` Success Change Password Request `scu` Success Change Username `sd` Success Delegation `sdu` Success User Deletion User successfully deleted `seacft` Success Exchange Successful exchange of authorization code for Access Token `seccft` Success Exchange Successful exchange of Access Token for a Client Credentials Grant `sede` Success Exchange Successful exchange of device code for Access Token `sens` Success Exchange Native Social Login `seoobft` Success Exchange Successful exchange of Password and OOB Challenge for Access Token `seotpft` Success Exchange Successful exchange of Password and OTP Challenge for Access Token `sepft` Success Exchange Successful exchange of Password for Access Token `sercft` Success Exchange Successful exchange of Password and MFA Recovery code for Access Token `sertft` Success Exchange Successful exchange of Refresh Token for Access Token `si` Successful invite accept Successfully accepted a user invitation `signup_pwd_leak` Breached password Someone behind the IP address `ip` attempted to signup with a leaked password. `srrt` Success Revocation Successfully revoked a Refresh Token `slo` Success Logout User successfully logged out `ss` Success Signup `ssa` Success Silent Auth `sui` Success users import Successfully imported users `sv` Success Verification Email Successfully consumed email verification link `svr` Success Verification Email Request Successfully called verification email endpoint. Verification email in queue to send. `ublkdu` User login block released User block setup by anomaly detection has been released `w` Warnings During Login Filters for logs of type `warning` during login `wum` Warning User Management Filters for logs of type `warning` during user management operations",
  "title": "Log Event Type Codes",
  "description": "Lists the event codes associated with log events. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax",
  "markdown": "# Log Search Query Syntax\n\nWhen searching for logs, you can create queries using a subset of [Lucene query syntax](http://www.lucenetutorial.com/lucene-query-syntax.html) to refine your search.\n\nThe query string is parsed into a series of terms and operators:\n\n*   A term can be a single word such as `jane` or `smith`.\n    \n*   A term can be a phrase surrounded by double quotes (`\"customer log\"`), which will match all words in the phrase in the same order.\n    \n*   A term without a field name will only match these selected fields fields.\n    \n*   Multiple terms can be grouped together with parentheses to form sub-queries.\n    \n*   All search fields are case sensitive.\n    \n*   Operators (`AND`, `OR`, `NOT`) work on all searchable fields.\n    \n\n## Searchable fields\n\nThe following fields are searchable and case sensitive:\n\n| **Field** | **Description** |\n| --- | --- |\n| `client_id` | Client ID related to the event. |\n| `client_name` | Client name related to the event. |\n| `connection` | Connection name related to the event. |\n| `connection_id` | Connection ID related to the event. |\n| `description` | Description of the event. |\n| `date` | Date the event occurred in YYYY-MM-DD format. |\n| `hostname` | Hostname used for the authentication flow. |\n| `ip` | IP address from where the request that caused the log entry originated. |\n| `log_id` | Log ID of the event. |\n| `organization_id` | Organization ID related to the event. |\n| `user_id` | User ID related to the event. |\n| `user_name` | User name related to the event. |\n| `user_agent` | User agent related to the event. |\n| `strategy` | Connection strategy related to the event. |\n| `strategy_type` | Connection strategy type related to the event. |\n| `type` | Type of the event. |\n\n## Fields searchable against bare terms\n\nIf a search term is entered without a field name, it will only be searched against the following fields:\n\n*   `client_name`\n    \n*   `connection`\n    \n*   `description`\n    \n*   `ip`\n    \n*   `log_id`\n    \n*   `type`\n    \n*   `user_name`\n    \n\n## Exact matching\n\nTo find exact matches, use double quotes: `description:\"Username invalid\"`.\n\nFor example, to find logs with the description `Username invalid`, use `q=description:\"Username invalid\"`.\n\n## Wildcards\n\nWildcard searches can be run on terms using the asterisk character (`*`) to replace zero or more characters: `user_name:john*`. They can be used for prefix matching, for example `user_name:j*`. For other uses of wildcards (for example, suffix matching), literals must have 3 characters or more. For example, `name:*usa` is allowed, but `name:*sa` is not.\n\nThe question mark character (`?`), is not supported.\n\nFor example, to find all logs for users whose usernames start with `john`, use `q=user_name:john*`.\n\n## Ranges\n\nYou can use ranges in your log search queries. For inclusive ranges use square brackets: `[min TO max]`, and for exclusive ranges use curly brackets: `{min TO max}`.\n\nCurly and square brackets can be combined in the same range expression. You can also use wildcards within ranges.\n\nAs an example, to find all logs from December 18, 2018 until the present, use `q=date:[2018-12-18 TO *]`.\n\nIf you'd like to search logs from the beginning of your retention period until, but not including, December 19, 2018, use `q=date:[* TO 2018-12-19}`.\n\n## Example queries\n\nBelow are some examples to show the kinds of queries you can make with the Management API.\n\n| Use Case | Query |\n| --- | --- |\n| Search all logs with connections that contains \"Pass\" | `connection:*pass*` |\n| Search all logs for users with a user name that contains \"fred\" | `user_name:*fred*` |\n| Search all logs with user id's matching exactly \"123\" | `user_id:\"123\"` |\n| Search for all logs with a type starting with \"s\" | `type:s*` |\n| Search for user names that start with \"jane\" and end with \"smith\" | `user_name:jane*smith` |\n| Search for all logs in December 2018 | `date:[2018-12 TO 2018-01-01}` |\n| Search for all logs from December 10, 2018 forward | `date:[2018-12-10 TO *]` |\n| Search for all logs from January 1, 2019 at 1AM, until, but not including January 1, 2019 at 12:23:45 | `date:[2019-01-01T01:00:00 TO 2019-01-01T12:23:45}` |\n\n## Limitations\n\n*   If you get the error `414 Request-URI Too Large` this means that your query string is larger than the supported length. In this case, refine your search.\n    \n*   Log fields are not tokenized , so `description:rule` will not match a description with value `Create a rule` nor `Update a rule`. Instead, use `description:*rule`. See wildcards and exact matching.\n    \n*   The `.raw` field extension is not supported. Fields match the whole value that is provided and are not tokenized.\n    \n\nWhen calling the `GET /api/v2/logs` or `GET /api/v2/users/{user_id}/logs` endpoints using the `include_totals` parameter, the result is a JSON object containing a summary of the results and the requested logs. The JSON object looks something like:\n\n```\n{\n  \"length\": 5,\n  \"limit\": 5,\n  \"logs\": [...],\n  \"start\": 0,\n  \"total\": 5\n}\n```\n\nWhen searching for logs, the **totals** field tells you how many logs are returned in the page (similar to what the **length** field returns).\n\n## Learn more\n\n*   [View Log Events](https://auth0.com/docs/deploy-monitor/logs/view-log-events)\n*   [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes)\n*   [Filter Log Events](https://auth0.com/docs/deploy-monitor/logs/log-event-filters)\n*   [Migrate to Tenant Log Search v3](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-tenant-log-search-v3)",
  "title": "Log Search Query Syntax",
  "description": "Describes search query syntax using a subset of the Lucene query syntax to refine Auth0 log searches.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs/export-log-events-with-rules",
  "markdown": "# Export Log Events with Rules\n\nYou can create an Auth0 rule to capture specific events, such as user signups, logins, and user location, then send that data to your preferred analytics service. Here are some links to services you can choose from:\n\n*   [MixPanel](http://mixpanel.com/)\n    \n*   [Firebase](http://firebase.com/)\n    \n*   [TowerData](https://www.towerdata.com/email-intelligence/email-enhancement)\n    \n*   [Parse](http://parse.com/)\n    \n*   [Splunk](https://www.splunk.com/)\n    \n*   [Keen](https://keen.io/)\n    \n*   [Segment](https://segment.com/)\n    \n\n## Rule examples\n\nHere are a few examples of rules. In most cases, before you run the rule, you will need to have a write key value that you obtain from the service and store it in the rule's global `configuration` object. The following examples require a write key value.\n\nFor more examples, see our [Auth0 Rules Repository](https://github.com/auth0/rules) on GitHub.\n\n### Keen\n\n[Keen](https://keen.io/) provides a service to capture and analyze events generated in your apps. In this example, the rule sends contextual information, such as IP address (to deduce location), user ID, and username. For this rule, we track the event type using the property `user.signedUp`. When the property is set to `true`, we assume the event is a login. Otherwise, we assume the event is a new signup, and set it to `true`. Thus, the next time the user logs in, the event will be recorded as a login.\n\n```\nfunction(user, context, callback) {\n\n  var request = require('request');\n\n  if(user.signedUp){\n    return callback(null, user, context);\n  }\n\n  var writeKey = configuration.KEENIO_WRITE_KEY;\n  var projectId = configuration.KEENIO_PROJECT_ID;\n  var eventCollection = 'signups';\n\n  var keenEvent = {\n    userId: user.user_id,\n    name: user.name,\n    ip: context.request.ip //Potentially any other properties in the user profile/context\n  };\n\n  request.post({\n      method: 'POST',\n      url: 'https://api.keen.io/3.0/projects/' + projectId + '/events/' + eventCollection,\n      headers: {\n        \"Authorization: \" + writeKey,\n        'Content-type': 'application/json'\n      },\n      body: JSON.stringify(keenEvent),\n      }, \n      function (e, r, body) {\n        if( e ) return callback(e,user,context);\n        //We assume everything went well\n        user.persistent.signedUp = true;\n        return callback(null, user, context);\n       });\n}\n```\n\n### Segment\n\n[Segment](https://segment.com/) provides a large number of analytics with a single API. In this example, the rule sends signup and login events to Segment. We will use [Segment's Node.js library](https://github.com/segmentio/analytics-node) to record the Auth0 data.\n\n```\nfunction(user, context, callback) {\n  var Analytics = require('analytics-node');\n  var analytics = new Analytics(configuration.WRITE_KEY, { flushAt: 1 });\n\n  // Note: Set { flushAt: 1 } and use analytics.flush to ensure\n  // the data is sent to Segment before the rule/Webtask terminates\n\n  // Identify your user\n  analytics.identify({\n      userId: user.user_id,\n      traits: {\n      email: user.email,\n      signed_up: user.created_at,\n      login_count: user.logins_count\n    },\n    \"context\": {\n      \"userAgent\": context.request.UserAgent,\n      \"ip\": context.request.ip\n    }\n  });\n  analytics.track({\n    userId: user.user_id,\n    event: 'Logged In',\n    properties: {\n      clientName: context.clientName,\n      clientID: context.clientID,\n      connection: context.connection\n    },\n    \"context\": {\n      \"userAgent\": context.request.UserAgent,\n      \"ip\": context.request.ip\n    }\n  });\n  analytics.flush(function(err, batch){\n    callback(null, user, context);\n  });\n}\n```\n\n### Splunk\n\n[Splunk](http://splunk.com/) provides a web interface for searching, monitoring, and examining data. In this example, the rule sends signup and login events to Splunk. We will use [Splunk's REST API](http://dev.splunk.com/view/rest-api-overview/SP-CAAADP8) to record the Auth0 data. Splunk's API supports basic and token-based auth. In this example, we use token-based auth.\n\nFor this rule, we track the event type using the property `user.app_metadata.signedUp` as in the Keen example above.\n\n```\nfunction (user, context, callback) {\n  const request = require('request');\n\n  user.app_metadata = user.app_metadata || {};\n  const endpoint = 'https://http-inputs-mysplunkcloud.example.com:443/services/collector'; // replace with your Splunk HEC endpoint;\n\n  //Add any interesting info to the event\n  const hec_event = {\n    event: {\n      message: user.app_metadata.signedUp ? 'Login' : 'Signup',\n      application: context.clientName,\n      clientIP: context.request.ip,\n      protocol: context.protocol,\n      userName: user.name,\n      userId: user.user_id\n    },\n    source: 'auth0',\n    sourcetype: 'auth0_activity'\n  };\n\n  request.post({\n    url: endpoint,\n    headers: {\n      'Authorization': 'Splunk ' + configuration.SPLUNK_HEC_TOKEN\n    },\n    strictSSL: true, // set to false if using a self-signed cert\n    json: hec_event\n  }, function(error, response, body) {\n    if (error) return callback(error);\n    if (response.statusCode !== 200) return callback(new Error('Invalid operation'));\n    user.app_metadata.signedUp = true;\n    auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n      .then(function () {\n        callback(null, user, context);\n      })\n      .catch(function (err) {\n        callback(err);\n      });\n  });\n\n}\n```\n\n## Learn more\n\n*   [Log Data Retention](https://auth0.com/docs/deploy-monitor/logs/log-data-retention)\n*   [Filter Log Events](https://auth0.com/docs/deploy-monitor/logs/log-event-filters)\n*   [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes)\n*   [Log Search Query Syntax](https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax)",
  "title": "Export Log Events with Rules",
  "description": "Learn how to create Auth0 rules to export specific log events to a third-party service, such as Keen, Segment, or Splunk..",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events",
  "markdown": "# Adaptive MFA Log Events\n\n```\n{\n  \"_id\": \"5ef3bb0a72487a0047c32959\",\n  \"date\": \"2020-06-24T20:43:54.159Z\",\n  \"type\": \"s\",\n  \"description\": \"Successful login\",\n  \"connection\": \"Username-Password-Authentication\",\n  \"connection_id\": \"con_16Tpc6YqlWZ4HCut\",\n  \"client_id\": \"9ZteveEZ8CqSLtCNXgvhoCJQ0jt2xSxe\",\n  \"client_name\": \"jwt.io\",\n  \"ip\": \"10.12.13.1\",\n  \"client_ip\": null,\n  \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:77.0) Gecko/20100101 Firefox/77.0\",\n  \"details\": {\n    \"prompts\": [\n      {\n        \"name\": \"prompt-authenticate\",\n        \"completedAt\": 1593031413909,\n        \"connection\": \"Username-Password-Authentication\",\n        \"strategy\": \"auth0\",\n        \"identity\": \"5ee10b1ca85332004e44ce3e\",\n        \"stats\": {\n          \"loginsCount\": 67\n        },\n        \"elapsedTime\": null\n      },\n      {\n        \"name\": \"login\",\n        \"flow\": \"universal-login\",\n        \"initiatedAt\": 1593031371948,\n        \"completedAt\": 1593031413953,\n        \"timers\": {\n          \"rules\": 443\n        },\n        \"user_id\": \"auth0|5ee10b1ca85332004e44ce3e\",\n        \"user_name\": \"user@josh.local.dev.auth0.com\",\n        \"elapsedTime\": 42005\n      },\n      {\n        \"name\": \"mfa\",\n        \"flow\": \"universal-mfa\",\n        \"initiatedAt\": 1593031414863,\n        \"completedAt\": 1593031433795,\n        \"performed_acr\": [\n          \"http://schemas.openid.net/pape/policies/2007/06/multi-factor\"\n        ],\n        \"performed_amr\": [\n          \"mfa\"\n        ],\n        \"provider\": \"guardian\",\n        \"elapsedTime\": 18932\n      }\n    ],\n    \"initiatedAt\": 1593031371938,\n    \"completedAt\": 1593031434151,\n    \"elapsedTime\": 62213,\n    \"session_id\": \"ulYRdsS1F4wIKLpUfQDfhyXgKVJqJaEv\",\n    \"riskAssessment\": {\n      \"confidence\": \"medium\",\n      \"assessments\": {\n        \"UntrustedIP\": {\n          \"confidence\": \"high\",\n          \"code\": \"ip_not_found\"\n        },\n        \"NewDevice\": {\n          \"confidence\": \"medium\",\n          \"code\": \"match_useragent\",\n          \"details\": {\n            \"device\": \"unknown\",\n            \"useragent\": \"known\",\n          }\n        },\n        \"ImpossibleTravel\": {\n          \"confidence\": \"low\",\n          \"code\": \"missing_geoip\"\n        }\n      }\n    },\n    \"stats\": {\n      \"loginsCount\": 67\n    }\n  },\n  \"hostname\": \"josh.local.dev.auth0.com\",\n  \"user_id\": \"auth0|5ee10b1ca85332004e44ce3e\",\n  \"user_name\": \"user@josh.local.dev.auth0.com\",\n  \"strategy\": \"auth0\",\n  \"strategy_type\": \"database\"\n}\n```",
  "title": "Adaptive MFA Log Events",
  "description": "Describes tenant log events that capture Adaptive Multi-Factor Authentication (MFA) activities in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/attack-protection/view-attack-protection-events",
  "markdown": "# View Attack Protection Log Events\n\nYour tenant logs contain useful data that you can use to build charts to look at the profile of the traffic going through your tenant. This is helpful when evaluating attack protection activity. For example, you can look for the following events to determine if you're under attack:\n\n*   Abnormal bursts in traffic to the login flow that result in errors (such as wrong username or password errors).\n    \n*   Abnormal bursts in traffic coming from IP locales that are not expected.\n    \n\nThese events tend to happen without much change to the rate of successful logins.\n\nYou can use your tenant log data `event` field to view tenant traffic data. We recommend building a daily histogram of failure events of the following types:\n\n| **Event Code** | **Event** |\n| --- | --- |\n| `f` | Failed login |\n| `fcoa` | Failed cross-origin authentication |\n| `feccft` | Failed exchange |\n| `fepft` | Failed exchange |\n| `fsa` | Failed silent authentication |\n| `fu` | Failed login (invalid email/username) |\n| `pla` | Pre-login assessment |\n| `sepft` | Success exchange |\n\nThese failure events depend on the flow you have set up with Auth0.\n\nThe following example shows a credential stuffing attack on 11/20, with a large surge of events of type `fu` which is a failed username (typical of a credential stuffing attack).\n\n![Example traffic failure trends graph](https://images.ctfassets.net/cdy7uua7fh8z/3fTdEeLJSvDT4JVs1Ebza2/a82830a32a08f6dc78c5c763cd2979e8/traffic-failure-trends.png)\n\n## Rate of errors in login flow\n\nLook for a surge or an abnormal number of errors for incorrect username or password. For example: Do you expect >30,000 errors per hour?\n\n| Event Code | Event |\n| --- | --- |\n| `s` | Login success |\n| `fu` | Failed login, invalid email/username |\n| `fp` | Failed login, incorrect password |\n\nHere's an example of what the data might look like.\n\n![Example graph of surge in login failures compared to normal traffic](https://images.ctfassets.net/cdy7uua7fh8z/5PQBhfw1B1yx8S2BnHSDTk/529d61308a4113a11868c7883163e101/login-flow-errors.png)\n\n## Rate of attack protection events\n\nLook for abnormally high traffic for attack protection events such as breached password detection or brute-force attacks for multiple accounts.\n\n| Event Code | Event |\n| --- | --- |\n| `limit_mu` | Blocked IP address |\n| `limit_wc` | Blocked account |\n| `pwd_leak` | Breached password during login |\n| `signup_pwd_leak` | Breached password during signup |\n\nHere's an example of what the data might look like.\n\n![Example graph of anomaly detection events](https://images.ctfassets.net/cdy7uua7fh8z/4hCSxSwOq5jmiwChEKnSuQ/ca58ac5ea43a3daf3b5d07af23cc687b/anomaly-detection-events.png)\n\n## Number of IPs producing errors and their locations\n\nLook for a high number of IPs from locales that do not make sense. For example: Do you expect traffic from 10,000 IPs from Russia every day? Observe `ip` address data in conjunction with `fu` event traffic to determine where the failure traffic is coming from.\n\nIP geolocation data isn't available in the tenant logs unless you're able to enrich it from another location. The IP locale is only available from Kibana where the logs are already enriched with the information.\n\nHere's an example of what the data might look like:\n\n![Example graph of failed access attempts by region](https://images.ctfassets.net/cdy7uua7fh8z/6fP5CSgHUpn66orFrhwh84/3b656bd3f2d4227d429ec0d4918bcbff/ips-location.png)\n\n## Learn more\n\n*   [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection)\n*   [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection)\n*   [Brute-Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection)\n*   [Logs](https://auth0.com/docs/deploy-monitor/logs)\n*   [Log Search Query Syntax](https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax)",
  "title": "View Attack Protection Log Events",
  "description": "Describes how to use tenant traffic log data to view attack protection events.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues/verify-platform",
  "markdown": "# Verify Platform\n\nEnsure that you are on current versions of your technology stack. If you're using an older version of a programming language or library consider updating to the current version.\n\n*   Check the [Auth0 support matrix](https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix) to see if the language or library versions you're using is supported.\n    \n*   If there's a problem in one environment (such as development) but not another (such as production), compare the versions of the technology stack across the two environments.\n    \n*   If not, upgrade your technology stack and browser to the latest versions and test again before creating a support request.\n    \n\n## Check the scope of the issue\n\nTesting on different browsers, platforms, locations, and users can help narrow down the source of a problem when it occurs. Perform the following tests and review the [logs in your Auth0 dashboard](https://manage.auth0.com/#/logs) after each test for more information.\n\n### Test with different browsers\n\n*   Does the issue happen with all browsers or just some?\n    \n*   Test in a new incognito or private browser session (no previous state).\n    \n*   Upgrade to the latest browser version and re-test.\n    \n*   Turn off browser plugins and re-test to see if a plug-in contributes to the issue.\n    \n\n### Test with different users\n\n*   Does the issue occur for all users or just some?\n    \n*   If some, is there a pattern? Such as location, connection, or role?\n    \n\n### Test with different connections (if possible)\n\n*   Does the issue happen with all connections or just one?\n    \n\n### Test with different client applications (if you have more than one)\n\n*   Does the issue happen with all clients or just one?\n    \n\n### Test across different environments\n\n*   Try the development, staging, and production environments of your application(s).\n    \n*   Try across different Auth0 tenants to see if any differences.\n    \n\n## Check if the issue is consistent or intermittent\n\n*   If the issue is consistent, note the steps to reliably duplicate the issue.\n    \n*   If the issue intermittent, note any pattern that might cause it.\n    \n*   Is this an issue with a new setup, or did it work before and is now broken?\n    \n    *   If it just broke, what changes were made?\n        \n    *   Does undoing the changes fix the issue?\n        \n\n## Issues that affect only one or a few users\n\n*   [Check the user's profile](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles), browser, or device for any issues.\n    \n*   Check to see if it happens in all browsers for the affected users (indicating a data issue) or just certain types of browsers (indicating a browser-specific issue).\n    \n*   Check to see if the browser has enabled JavaScript and cookies.\n    \n*   Check that the caps lock key is disabled.\n    \n*   If the user is using a mobile device, check to see if there's any software that might impact authentication and/or authorization (such as not running some type of required software).\n    \n*   Check to see if the user can access some of the application's key URLs, such as the identity provider's Single Sign-on (SSO) URL (indicating a network connectivity issue).\n    \n\n## Issues that occur after go-live (worked before, then stopped working)\n\n*   Check if any recent changes to your application or any APIs you call?\n    \n*   Check if any recent network changes (load balancer, firewall, proxy config changes).\n    \n*   Check if any recent infrastructure changes (e.g. credentials for LDAP or DB servers?)\n    \n*   Check for any patches or updates to applications, infrastructure, or technology stacks.\n    \n*   Check that all your servers are running NTP and have accurate time sync\n    \n*   Check if any of your certificates have expired.\n    \n*   Check with owners of any remote identity providers if anything changed.\n    \n    *   Check network connectivity to any remote identity providers.\n        \n*   Check notifications in Auth0 dashboard/migrations - any changes you overlooked?\n    \n*   Check Auth0 change log - any recent configuration changes related to your issue?\n    \n*   Check if any component in the technology stack has been updated or patched recently?\n    \n\n## Learn more\n\n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections)\n*   [Verify Domain](https://auth0.com/docs/troubleshoot/basic-issues/verify-domain)\n*   [Verify Rules](https://auth0.com/docs/troubleshoot/basic-issues/verify-rules)\n*   [Check Auth0 Status](https://auth0.com/docs/deploy-monitor/monitor/check-auth0-status)\n*   [Monitor Applications](https://auth0.com/docs/deploy-monitor/monitor/monitor-applications)",
  "title": "Verify Platform",
  "description": "Learn how to verify your platform to troubleshoot issues",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues/verify-rules",
  "markdown": "# Verify Rules\n\nFailures in a rule can often cause authentication issues. Perform the following checks to see if rules could be behind your issue.\n\n*   Turn rules off and see if the issue still occurs.\n    \n*   Check that your rules catch all possible errors that might be returned. Uncaught errors could cause failures.\n    \n*   Check that your rules are calling the `callback` function only once for each logical branch in your code.\n    \n*   Add `console.log()` statements to your rules to debug and check state. For example: `console.log(“output = “ + some_variable);`.\n    \n*   Click **Debug Rule** in the Dashboard to view the output from your `console.log` statements.\n    \n*   View the output in the Real-time Webtask Logs to get more information about your rules’ execution.\n    \n\n## Learn more\n\n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections)\n*   [Verify Platform](https://auth0.com/docs/troubleshoot/basic-issues/verify-platform)\n*   [Verify Domain](https://auth0.com/docs/troubleshoot/basic-issues/verify-domain)\n*   [Check Auth0 Status](https://auth0.com/docs/deploy-monitor/monitor/check-auth0-status)\n*   [Monitor Applications](https://auth0.com/docs/deploy-monitor/monitor/monitor-applications)",
  "title": "Verify Rules",
  "description": "Learn how to verify rules to troubleshoot issues",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues/verify-domain",
  "markdown": "# Verify Domain\n\nWas this article helpful?",
  "title": "Verify Domain",
  "description": "Learn how to verify your domain to troubleshoot issues",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues/search-logs-for-deprecation-errors",
  "markdown": "# Check for Deprecation Errors\n\nWhen Auth0 features are deprecated, there may be errors or notices in the tenant logs that show up to indicate that your applications are using the deprecated features. This guide will provide assistance with searching your logs for deprecation-related messages as well as explanations of potential causes and resolutions for particular items.\n\nThere are two different ways to search for warning messages showing usage of deprecated features: The Dashboard or the Management API. Note that in either case, the [log retention period](https://auth0.com/docs/deploy-monitor/logs/log-data-retention) is governed by the subscription level of your account.\n\n## Use the Dashboard\n\nIf your application uses a deprecated feature, a **Deprecation Notice** message will appear in the **Logs** section of the Dashboard. Deprecation notices are only shown once per hour (the first time the error occurs within that hour) rather than for each authentication transaction involving the deprecated feature.\n\n1.  Go to [Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs) and search for deprecation-related messages by entering `type:depnote` in the query box. A list of deprecation-related warning messages from your logs will appear, if any exist. The **Description** field provides information on the particular deprecated feature used.\n    \n2.  Click on the link in the **Type** column for each item to show additional information such as the client ID which identifies the client application using the deprecated feature.\n    \n3.  Click log entries and select the **Context Data** tab to show details about the item.\n    \n\n## Use the Management API\n\nYou can also use the Management API to search through logs for such messages by looking for `type:\"depnote\"`.\n\n1.  Go to the [Management API](https://auth0.com/docs/api/management/v2). If you have not already done so, [get an API token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production).\n    \n2.  On the left, go to [Logs > Search log events](https://auth0.com/docs/api/management/v2/#!/Logs/get_logs) and then scroll down to **Parameters**.\n    \n3.  In the **q** field enter: `type:\"depnote\"`.\n    \n4.  Click on the **TRY** button. The **Client ID** field in the results will indicate which application on your tenant is using the deprecated feature.\n    \n\n## Learn more\n\n*   [Log Data Retention](https://auth0.com/docs/deploy-monitor/logs/log-data-retention)\n*   [Logs](https://auth0.com/docs/deploy-monitor/logs)",
  "title": "Check for Deprecation Errors",
  "description": "Learn how to view errors and descriptions relating to deprecations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors",
  "markdown": "# Troubleshoot Invalid Token Errors\n\n## Parsing an HS256-Signed ID Token Without an access token\n\n**Error Message**: The ID token cannot be validated because it was signed using the HS256 algorithm and public applications (such as a browser) can’t store secrets.\n\n### Causes\n\nBeginning with **auth0.js version 9** and **Lock version 11**, when ID tokens are signed with HS256, they are discarded and a call to `/userinfo` is made to retrieve user information.\n\nCalling `/userinfo` requires an Access Token. If you don't ask for an access token when authenticating, you will receive the following error: `The id_token cannot be validated because it was signed with the HS256 algorithm and public applications (like a browser) can’t store secrets. Please read the associated doc for possible ways to fix this.`\n\n### Fixes\n\nThere are two ways to fix the error:\n\n1.  **(RECOMMENDED)** Change the application signature algorithm to RS256 instead of HS256.\n    \n2.  Change the value of your `responseType` parameter to `token id_token` (instead of the default), so that you receive an access token in the response.\n    \n\nTo change the application signature algorithm to RS256 instead of HS256:\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select the name of the application to view.\n    \n2.  Scroll to the bottom of the **Settings** page, and select **Show Advanced Settings**.\n    \n3.  Select the **OAuth** view, change the value of **JsonWebToken Signature Algorithm** to **RS256**, and select **Save Changes**.\n    \n\nIf you proceed with this option and you are using the ID token to call your APIs, be sure to change your server code so that it validates tokens using the RS256 algorithm instead of HS256. Note that using ID tokens to call APIs is not recommended.\n\nYou can decode, verify and generate JWTs using the [JWT Tool](https://jwt.io/).",
  "title": "Troubleshoot Invalid Token Errors",
  "description": "Describes how to troubleshoot invalid token errors.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors",
  "markdown": "# Deprecation Errors\n\nWhen Auth0 features are deprecated, there may be errors or notices in the tenant logs that show up to indicate that your applications are using the deprecated features. This guide will provide assistance with searching your logs for deprecation-related messages as well as explanations of potential causes and resolutions for particular items.\n\nThere are two different ways to search for warning messages showing usage of deprecated features: The Dashboard or the Management API. Note that in either case, the [log retention period](https://auth0.com/docs/deploy-monitor/logs) is governed by the subscription level of your account.\n\nSee [Search Logs for Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/search-logs-for-deprecation-errors) for details.\n\n## Deprecation log messages\n\n### Legacy Lock API\n\n**Log entry**: `up-idp-initiated`\n\n**Error Message:** \"Legacy Lock API: This feature is being deprecated. Please refer to our documentation to learn how to migrate your application.\"\n\n**Cause**: Tenant log entries regarding the Legacy Lock API may include the referrer and information about the SDK used.\n\n**Resolution**: Use this information to see if any of your applications use outdated libraries.\n\n### SSOdata endpoint\n\n**Log entry**: `ssodata`\n\n**Error Message:** \"SSOdata endpoint: This feature is being deprecated. Please refer to our documentation to learn how to migrate your application.\"\n\n**Cause**: Either calling the `/ssodata` endpoint directly or using old versions of embedded Lock or Auth0.js SDK to call a function which called the `/ssodata` endpoint.\n\n**Resolution**: [Migrate to Universal Login](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-embedded-login-to-universal-login)\n\n## Learn more\n\n*   [Verify Platform](https://auth0.com/docs/troubleshoot/basic-issues/verify-platform)\n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections)\n*   [Verify Domain](https://auth0.com/docs/troubleshoot/basic-issues/verify-domain)\n*   [Verify Rules](https://auth0.com/docs/troubleshoot/basic-issues/verify-rules)\n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages)",
  "title": "Deprecation Errors",
  "description": "Learn how to search logs for deprecation errors",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues/recover-administrative-access-to-a-tenant",
  "markdown": "# Recover Administrative Access to a Tenant\n\nIf you cannot access the administrator account for your tenant, you have options for recovery.\n\nIf an existing administrator leaves your organization without delegating access to another team member, try the steps below before contacting Auth0 support.\n\n1.  Check the email alias of the former admin. If you have access to the inbox, such as through Google Workspace, request a password reset for the user and reset the password for the tenant account.\n    \n2.  Check for another admin on the tenant. This admin can remove the previous employee account and add a new admin. Auth0 recommends you have multiple admins on a tenant.\n    \n\nIf you still cannot gain access to the tenant, create a support request with Auth0. Our support team will verify tenant ownership and grant access. To learn more, read [Open and Manage Support Tickets](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets).\n\n## Learn more\n\n*   [Create Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants)",
  "title": "Recover Administrative Access to a Tenant",
  "description": "Describes how to recover options for a lost administrator account",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls",
  "markdown": "# Check API Calls\n\n## Check Management API calls\n\n*   Do you have a [Management API Access Token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)?\n    \n*   Did the access token expire?\n    \n*   Did the access token contain the scopes needed for the call you made?\n    \n*   If a rule adjusts the scopes in the access token or checks whether specific users are allowed to have the scopes, have you checked the rule to make sure it is executing correctly?\n    \n*   Get the access token from a [HAR file](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files) and test it in the [Auth0 Management API Explorer](https://auth0.com/docs/api/management/v2) to see if it works there.\n    \n*   If you are calling the Auth0 Management API from an application that authenticates with [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow), note that rules are not executed in this context. For functionality similar to a Rule, an Action in the [Machine to Machine Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow) on the `credentials-exchange` trigger can be used in this context instead.\n    \n\n## Check other API calls\n\n*   Check in the HAR file if the access token contains correct scopes to call the API.\n    \n*   Check if the response to the `/authorize` endpoint call contains a scopes object. If so, check if the returned scopes are different from the requested scopes.\n    \n*   Make sure your API can [validate the Access Token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens). It should validate the audience, issuer, client (if any), signature algorithm, signature, claims and permissions.\n    \n*   If you experience errors with access token expiration, they could be caused by clock skew differences manifested across different systems or even different language libraries, such as Java and Node.js. This can be handled by running NTP on servers and configuring a clock skew tolerance in libraries used to validate tokens such as [jwt.verify](https://github.com/auth0/node-jsonwebtoken#jwtverifytoken-secretorpublickey-options-callback).\n    \n\n## Learn more\n\n*   [Calling an API](https://auth0.com/docs/videos/learn-identity-series/calling-an-api)\n*   [Call Your API Using the Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce)\n*   [Call Your API Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow)\n*   [Call Your API Using the Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow)\n*   [Call Your API Using the Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/call-your-api-using-the-device-authorization-flow)",
  "title": "Check API Calls",
  "description": "Learn how to check API calls to troubleshoot issues.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues",
  "markdown": "# Check Login and Logout Issues\n\nHere are things to check to help you narrow down when issues occur during login and logout.\n\n## Login Issues\n\n### Is the user prompted for login credentials?\n\n*   Does the HAR file show a call to the authorization server (`/authorize` endpoint)?\n    \n*   Is the connection enabled for the application?\n    \n*   Is the remote authorization service available?\n    \n*   If using the [Auth0 Universal Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login), try turning off customization and see if authentication works. If login works without your customizations, review your Universal Login Page customization code.\n    \n\n### Is an error message shown after entering credentials?\n\n*   Can you test login another way to ensure credentials are correct?\n    \n*   If password expiration is a possibility, check if password has expired.\n    \n*   Check your browser's developer tools or web inspector console for errors in the flow before returning to Auth0.\n    \n*   Check the HAR file - does it show a return to Auth0 (`/login/callback` endpoint)?\n    \n    *   If not, check that the identity provider has the correct callback URL for Auth0.\n        \n\n*   To test this, open a second tab in the same browser and go to the same URL. Are you prompted to log in again?\n    \n    *   If you're not prompted to log in, a session is there.\n        \n\n### Is a log entry created in your Auth0 Logs?\n\n*   If no log entry was created the authentication transaction did not complete or return to Auth0.\n    \n*   Check the response from the authorization server for error messages.\n    \n*   Check authorization server logs (if possible) for errors.\n    \n\n### Is an entry created in Auth0 user’s screen with all correct profile info?\n\n*   If not, check the response from authorization server in the HAR file. It may not be returning information about the user\n    \n*   If you're using rules, check your rules scripts for issues.\n    \n*   If you're using a custom database connection, check your database action scripts for issues.\n    \n*   If you're using LDAP, check the profile mapper script (`profileMapper.js`) for issues.\n    \n*   Check your social connection configurations for what profile information is requested.\n    \n\n### Does the HAR file show a token or assertion returned to application?\n\n*   Look in the [HAR file](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files) for the call to your application callback URL.\n    \n*   Find the ID Token (`id_token`) and check if it has the information needed by the application.\n    \n\n### If you decode the token or assertion does it have information you expect?\n\n*   View JWTs with [JWT.io](http://jwt.io/).\n    \n*   View SAML assertions with [SAMLTool.io](http://samltool.io/).\n    \n\n### If the logged in user cannot access another application with Single Sign-on\n\n1.  Is the user trying to login to the second application from the same browser as their initial login?\n    \n2.  Go to your [Tenant Settings > Advanced Settings](https://manage.auth0.com/#/tenant/advanced) and check the **Log In Session Management** settings. Was the second login attempt within the timeout periods?\n    \n3.  Check the value passed as the `prompt` parameter in `/authorize` call.\n    \n4.  Is the connection used to log in to the first application enabled for the second application?\n    \n5.  Did the second application receive all the necessary user profile information?\n    \n6.  If using a mobile device, you'll need to use a browser-based flow. For more information, see [Best Practices](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/mobile-device-login-flow-best-practices).\n    \n\n### Check application logs\n\n*   Do your application logs show any errors?\n    \n*   Did the application receive all the information it needs, such as groups or user profile attributes?\n    \n\n## Logout issues\n\n*   Did you add your logout redirect URLs to the allow list? If you are using a redirect URL in a logout call it must be registered in either the tenant or application settings.\n    \n*   If you need federated logout, did you append the `?federated` parameter to the logout call?\n    \n*   Make sure that the logout redirect URL is different from the login callback URL.\n    \n*   Make the logout redirect URL an anonymous page (not protected by login) so that redirects to the logout redirect URL do not immediately trigger a login, which may confuse users.",
  "title": "Check Login and Logout Issues",
  "description": "Learn how to check login and logout to troubleshoot issues",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-rbac-authorization",
  "markdown": "# Troubleshoot Role-Based Access Control and Authorization\n\nHere are some solutions to common issues experienced when implementing [role-based access control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac) using the Authorization Core feature set.\n\n## Role-based access control is enabled for my API, but the scopes claim is not showing what you say it should\n\n*   Make sure that you aren't setting `accessToken.scope` in a rule.\n    \n*   Remember that any configured [authorization rules](https://auth0.com/docs/manage-users/access-control/rules-for-authorization-policies) run after the RBAC-based authorization decisions are made, so they may override the default behavior.",
  "title": "Troubleshoot Role-Based Access Control and Authorization",
  "description": "Explore solutions to common issues experienced when implementing role-based access control (RBAC) using the Authorization Core feature set.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/self-change-password-errors",
  "markdown": "# Self Change Password Errors\n\nBelow you will find the errors codes and possible solutions to various errors that can occur with the self change password API.\n\n## Error Format\n\nError messages are returned in the standard format:\n\n## Error Codes\n\n### invalid\\_request\n\nThis error results when you supply invalid parameters. Error messages will describe the issue such as a required parameter or invalid format.\n\n### invalid\\_user\\_password\n\nThis error results from a bad `username`/`email` and `old_password` combination being sent. Retry the request with the correct username and `old_password`.\n\n### change\\_password\\_error\n\nThis error results from various conditions with the underlying identity provider. Generally, this happens when you are using a custom database and have not implemented the change password script.",
  "title": "Self Change Password Errors",
  "description": "Error messages for the self change password API",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors",
  "markdown": "# Troubleshoot SAML Errors\n\n## Invalid request - connection disabled\n\n### Cause\n\nThis message indicates that the application doesn't have an active connection associated.\n\n### Solution\n\n1.  Go to [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise).\n    \n2.  Click **SAML**.\n    \n3.  Click on the connection you want to check.\n    \n4.  Click the **Applications** tab.\n    \n5.  Enable at least one application (if you don't see any in the list, you will need to [create an application](https://auth0.com/docs/get-started/applications) before proceeding).\n    \n\n## IdP-Initiated Default App Not Configured\n\n### Cause\n\nThis error appears if you haven't provided the necessary information to support IdP\\-initiated login flows.\n\n### Solution\n\n1.  Go to [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise).\n    \n2.  Click **SAML**\n    \n3.  Click on the connection you want to check.\n    \n4.  Switch to the **IdP-Initiated SSO** tab.\n    \n5.  Select **Accept Requests** and select the **Default Application** and the **Response Protocol** used by that application, and (optionally) specify any additional parameters you want to be passed to the application.\n    \n6.  Click **Save Changes**.\n    \n\n#### Troubleshooting SP-initiated login\n\nIf you see this error when using a SP-initiated flow, one of the following is missing or empty:\n\n*   The `RelayState` parameter\n    \n*   The `InResponseTo` attribute in the SAML response\n    \n\nIf these are missing or empty, Auth0 treats the login as IdP-initiated. You can fix this error by checking your configuration to ensure that both fields are populated and returned appropriately.\n\n## Missing RelayState parameter\n\n### Cause\n\nThis error occurs when the identity provider doesn't return the `RelayState` parameter along with its response.\n\n### Solution\n\nWork with the identity provider to ensure that it returns the `RelayState` parameter.\n\n## Audience is Invalid\n\nThis error occurs if the value of the `audience` element from the identity provider's SAML response doesn't match the value expected by Auth0. Auth0 expects the value to be the Entity ID for the connection.\n\n### Solution\n\n1.  Go to [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise).\n    \n2.  Click **SAML**.\n    \n3.  Click on the connection you want to check.\n    \n4.  On the **Setup** tab, under the **Common Settings** section, your **Entity ID** is the second parameter provided. Make sure that the identity provider sends the correct `audience` value in the SAML response.\n    \n\n## Incorrect protocol specified\n\nThere is an incorrect response protocol on the **IdP-Initiated** tab. The response protocol is the one used between Auth0 and the Application (not the remote identity provider). For example, if you set this value to **SAML** when your application expects **OpenID Connect** or **WS-Fed** results in errors due to the incorrect configuration.\n\n### Solution\n\n1.  Go to [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise).\n    \n2.  Click **SAML**.\n    \n3.  Click on the connection you want to check.\n    \n4.  On the **Settings** tab, check the value you have set in the **Response Protocol** field.\n    \n\n## User isn't logged out from the IdP\n\nWhen ADFS is configured as SAML IdP, if the ADFS is relaying party trust `Name ID` attribute isn't mapped the logout flow fails. For example, with the federated parameter `v2/logout?federated&...` user isn't redirected to the ADFS SAML logout endpoint but redirects back to application callback URL directly. As a consequence, the user isn't logged out from the IdP in that case.\n\n### Solution\n\nAdd the `Name ID` attribute as a rule on the SAML Relaying Party Trust.",
  "title": "Troubleshoot SAML Errors",
  "description": "Describes how to troubleshoot common SAML related errors.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files",
  "markdown": "# Generate and Analyze HAR Files\n\nA [HAR](https://en.wikipedia.org/wiki/.har) (HTTP Archive) file is a JSON-formatted log of a web browser's interactions with a web server.\n\nA HAR file shows the sequence of redirects that happen during a login transaction, which makes it an excellent resource for debugging authentication issues. Including a HAR file in your [support requests](https://support.auth0.com/) can help accelerate the troubleshooting process.\n\n## Generate HAR files\n\nYou can generate a HAR file within most web browsers using the built-in developer or inspector tools.\n\n### Google Chrome\n\n1.  Close all **incognito** windows in Google Chrome.\n    \n2.  Open a **new incognito** window in Google Chrome.\n    \n3.  Go to **View > Developer > Developers Tools**.\n    \n4.  In the Developer Tools pane, choose the **Network** tab.\n    \n5.  Check the **Preserve Log** checkbox to record all interactions.\n    \n6.  Visit the page and complete the steps that trigger the issue.\n    \n7.  Choose the **Network** tab.\n    \n8.  Click the down arrow to export the HAR file.\n    \n9.  Save the HAR file.\n    \n\n### Safari\n\n1.  Ensure that **Show Develop menu in menu bar** checkbox is checked under **Safari > Preferences > Advanced**.\n    \n2.  Choose **File > Open New Private Window**.\n    \n3.  Choose **Show Web Inspector** in the **Developer** menu, then navigate to the **Network** tab.\n    \n4.  To the right of **All** near the top-left of the Web Inspector, click the **Filter button** and choose **Preserve Log.**\n    \n5.  Visit the web page where the issue occurs.\n    \n6.  Choose **Develop > Show Web Inspector**. The Web Inspector window appears.\n    \n7.  Complete the steps on the page that trigger the issue.\n    \n8.  Select the **Network** tab.\n    \n9.  Click **Export** on the upper right side of the pane.\n    \n10.  Save the HAR file.\n    \n\n### Firefox\n\n1.  Close all **private** windows in Firefox.\n    \n2.  Open a **new private** window in Firefox.\n    \n3.  Go to **Tools > Developer > Network** (**Ctrl + Shift + E**).\n    \n4.  Click the **Network** tab and choose **Persist Logs.**\n    \n5.  Visit the page and complete the steps that trigger the issue.\n    \n6.  Choose the **Network** tab and right click and then select **Save All As Har**.\n    \n7.  Save the HAR file.\n    \n\n### Microsoft Edge\n\n1.  Close all **InPrivate** windows in Microsoft Edge.\n    \n2.  Open a **new InPrivate** window (**Ctrl + Shift + N**).\n    \n3.  Go to **Settings and more** (the **...** icon) then choose **More Tools > Developer Tools**.\n    \n4.  Start a profiling session on the **Network** tab of the Developer Tools toolbar.\n    \n5.  Visit the page and complete the steps that trigger the issue.\n    \n6.  Select Export as HAR (**Ctrl + S**) and save the HAR file.\n    \n\n### Internet Explorer\n\n1.  Close all **InPrivate** windows in Internet Explorer.\n    \n2.  Open a **new InPrivate** window in Internet Explorer (**Ctrl + Shift + P**).\n    \n3.  Go to **Tools > F12 Developer Options > Network**.\n    \n4.  Ensure **Clear entries on navigate** is switched off.\n    \n5.  Visit the page and complete the steps that trigger the issue.\n    \n6.  Choose the **Network** tab and select **Export as HAR** (**Ctrl + S**).\n    \n7.  Save the HAR file.\n    \n\n## Analyze HAR files\n\nAuth0 does not use and does not endorse using any third-party application, tool, or software to analyze HAR files.\n\nAfter you have sanitized a HAR file, you can open it in a text-editor or browser to view the recorded events.\n\n## Learn more\n\n*   [Customer Support](https://auth0.com/docs/troubleshoot/customer-support)\n*   [Open and Manage Support Tickets](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets)",
  "title": "Generate and Analyze HAR Files",
  "description": "Learn how to troubleshoot with HAR files and steps to generate a HAR file.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension",
  "markdown": "# Troubleshoot Authorization Extension\n\nThe following issues are some you might see when setting up the Authorization Extension, as well as some tips to help you identify the cause.\n\n## The authentication results in a token contain group information but not roles or permissions information\n\nIf this happens, chances are that you created roles and permissions for one application, but your users are authenticating using another application. For example, let's say that you created all your roles/permissions against Website A. However, you also create another website application in Auth0 for Website B. Then, you use the `client_id` and `client_secret` for Website B, instead of those for Website A, in your app.\n\nAlternatively, you might see this if you click the **Try Connection** button in the Auth0 Dashboard on a Connection that contains one of your users. This will execute an authentication flow using the Auth0 global application, but this is not the same as the application you configured in the extension.\n\nThe supported application types for the Authorization extension are:\n\n*   Native apps\n    \n*   Single-page web apps\n    \n*   Regular web apps\n    \n\nApplications with no type assigned and machine to machine applications are not supported.\n\n## After upgrading to v2, users get an error upon login\n\nIf you see the error `You are not allowed to access this application`, most probably there is some conflict with the old rule. Turn off the persistence settings, delete the existing rule, re-enable the settings, and test again.\n\n## Learn more\n\n*   [Install Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/install-authorization-extension)\n*   [Configure Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/configure-authorization-extension)\n*   [Set Up Users in Authorization Extension Dashboard](https://auth0.com/docs/customize/extensions/authorization-extension/set-up-authorization-extension-users)\n*   [Enable API Access to Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/enable-api-access-to-authorization-extension)\n*   [Import and Export Authorization Extension Data](https://auth0.com/docs/customize/extensions/authorization-extension/import-and-export-authorization-extension-data)\n*   [Use Rules with the Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension/use-rules-with-the-authorization-extension)",
  "title": "Troubleshoot Authorization Extension",
  "description": "Learn how to troubleshoot the Authorization Extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-ad-ldap-connector",
  "markdown": "# Troubleshoot AD/LDAP Connector\n\nIf you are experiencing issues with your [AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector), read below to learn how to troubleshoot common issues.\n\n## Run the troubleshooting tool\n\nYou can run the troubleshooting tool in the AD/LDAP Connector Admin Console, or outside the Admin Console by executing the program manually.\n\nTo detect issues with certificates, set the `CONNECTIONS_API_V2_KEY` variable in the [AD/LDAP Connector configuration file](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-config-file-schema).\n\n### In the Admin Console\n\nYou can run the troubleshooting tool in the Admin Console.\n\n1.  Switch to the **Troubleshooting** view to read the logs.\n    \n    ![Troubleshoot AD/LDAP Connector Admin Console Troubleshooting Screen](https://images.ctfassets.net/cdy7uua7fh8z/3N6GgZVMaYUcY48GK8IKgU/92a469b9375dbcd9e3c35adaef6709d5/connector-admin-console-troubleshooter.png)\n2.  Select **Run** to detect the most common problems related to the AD/LDAP Connector.\n    \n\n### Outside the Admin Console\n\nYou can launch the troubleshooting tool outside of the Admin Console.\n\n#### Windows\n\nOn a Windows machine, run the provided command file to launch the troubleshooting tool.\n\n1.  Locate the AD/LDAP Connector folder (`AD LDAP Connector`).\n    \n2.  Run the `troubleshoot.cmd` file.\n    \n\nFor example: `C:\\Program Files (x86)\\Auth0\\AD LDAP Connector\\troubleshoot.cmd`.\n\n![Troubleshoot AD/LDAP Connector Troubleshooting Tool Screen](https://images.ctfassets.net/cdy7uua7fh8z/5LOU1ZyB69cPe8rVa9lVPd/c5c7419ae736a3992ddd2a436b26a3e0/connector-troubleshooter.png)\n\n#### Linux\n\nOn a Linux machine, run the provided Node.js program to launch the troubleshooting tool.\n\n1.  Open a new terminal window.\n    \n2.  Change the working directory to the AD/LDAP Connector folder (`AD LDAP Connector`).\n    \n3.  Run the `node troubleshoot.js` command.\n    \n\n## Installation and configuration issues\n\nAfter clicking **Save**, the AD/LDAP Connector Admin Console performs a series of tests to validate the provided information. The results of the tests are displayed under the **Configuration log** heading.\n\nThe Admin Console performs the following tests:\n\n*   **Test 1**: Attempts to establish a TCP connection to the LDAP server and port specified. If Test 1 fails, check basic network connectivity and firewall settings that might prevent such a connection.\n    \n*   **Test 2**: Attempts to perform an LDAP bind on the LDAP server and port specified and with the username and password provided. If Test 2 fails, check the LDAP connection string, search path, username, and password.\n    \n*   **Test 3**: Attempts to perform an LDAP search against the directory to check the privileges of the specified username. If Test 3 fails, check the privileges of the username in the target directory.\n    \n*   **Test 4**: Attempts to establish a connection to the Auth0 server. If Test 4 fails, check network connectivity and firewall settings that might prevent such a connection.\n    \n\n## Common issues and solutions\n\nDescriptions of several common issues and their solutions are listed below.\n\n### Authentication requests take too long to process\n\nBy default, the Auth0 AD/LDAP Connector imports a user’s group memberships from Active Directory and includes them on the `user` object.\n\nThis behavior requires the AD/LDAP Connector to perform additional queries against Active Directory, which can significantly increase the duration of the authentication process.\n\nIf you do not need groups to be returned on the user profile, Auth0 recommends that you explicitly disable the `GROUPS` variable in the [AD/LDAP Connector configuration file](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-config-file-schema).\n\n### Host CPU utilization is high\n\nIf the CPU utilization on the machine hosting the AD/LDAP Connector is consistently high (for example, sustained utilization above 60%), there are several mitigation strategies.\n\n#### Uninstall non-critical services\n\nUninstall any non-critical services on the host machine that may be consuming CPU cycles.\n\n#### Modify group import configuration\n\nIf you do not require groups to be returned on the user profile, disable group import as described in [Authentication requests take too long to process](#authentication-requests-take-too-long-to-process).\n\nIf you do require groups to be returned on the user profile, investigate the groups being returned on the Auth0 user profiles. Queries against nested and recursive groups can cause high CPU utilization. If possible, test with group import disabled to assess the impact of the group queries.\n\nTo mitigate the impact, fix any recursive or otherwise problematic group assignments in your AD/LDAP server, and/or increase the value of the `GROUPS_CACHE_SECONDS` variable in the [AD/LDAP Connector configuration file](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-config-file-schema).\n\n#### Evaluate volume of active users\n\nCheck if the number of active users using the AD/LDAP Connector has increased since you initially deployed it. You can evaluate this by using your own [monitoring solution](https://auth0.com/docs/customize/log-streams), or you can get an estimate from the [Auth0 active users report](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/monitor-subscription-usage).\n\nIf the number of active users has increased, and all steps above have already been followed, you may need to upgrade your host machine’s hardware specifications, or configure a [High Availability environment](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability).\n\n### Clock skew\n\nThe connector requires the clock on the server to be synchronized with the Auth0 service. The maximum allowed threshold is 5 seconds.\n\nIf you have a clock skew, you'll see output like this in the troubleshooter and connector logs:\n\n```\n12:18:55 - info: * Testing clock skew...\n12:18:55 - error: × Clock skew detected:\n12:18:55 - error: > Local time: 2020-05-04 12:18:55\n12:18:55 - error: > Auth0 time: 2020-05-04 12:19:10\n```\n\nMake sure the clock of your server is current. If the time is not correct, it will cause authentication requests to fail. This can be fixed by ensuring the system is properly configured to poll a sync server via the Network Time Protocol (NTP). In Windows environments, the NTP provider is usually the same domain controller. Make sure that your domain controller is synchronized with some external service.\n\nTo learn how to synchronize your Active Directory environment with an external time server, read [How to configure NTP server in Active Directory, Step by step on renanrodrigues.com](https://www.renanrodrigues.com/post/how-to-configure-ntp-server-in-active-directory-step-by-step).\n\nIf you are unsure if your server's clock is in sync with NTP, go to [https://nist.time.gov](https://nist.time.gov/) and compare the time on that page with the time in the server where the connector is running. You shouldn't notice more than a one (1) second difference between them.\n\n### No connection to Active Directory\n\nThe AD/LDAP Connector must be installed on a server that can reach your LDAP server. When firewalls and VPN connections are placed between the AD/LDAP Connector and the LDAP server, you may experience connectivity issues.\n\nIf you’re configuring a Windows Network with Active Directory, use the `nltest` command. For example, to test if a specific machine can reach the `fabrikam.local` domain, use `nltest /dsgetdc:fabrikam.local`.\n\nTo see to which domain the current server is connected to, use `nltest /dsgetdc:`.\n\nIf a domain does not exist or cannot be reached, `nltest` will return an error message: `Getting DC name failed: Status = 1355 0x54b ERROR_NO_SUCH_DOMAIN`.\n\n### UNABLE\\_TO\\_VERIFY\\_LEAF\\_SIGNATURE error message (Private Cloud)\n\nThis error applies to the AD/LDAP Connector in combination with Private Cloud.\n\nThis error message occurs when the AD/LDAP Connector fails to start when it can't validate the SSL certificate configured in the Private Cloud. This can happen when the Root Certificate (or any Intermediate Certificates) are missing in the machine's Certificate Store (Windows). In order to solve this, import the certificate chain in the **Local Machine > Trusted Root** certificate store on the machine where the AD/LDAP Connector is installed.\n\n### Connector behind a proxy\n\nIf the machine hosting the connector is behind a proxy, you can set an `HTTP_PROXY` system environment variable, or you can set the `HTTP_PROXY` variable in the [AD/LDAP Connector configuration file](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-config-file-schema). If using an authenticated proxy, the URL must be in the format `http://USERNAME:PASSWORD@SERVER_URL:PORT`.\n\nThe `HTTP_PROXY` URL must be the URL of the proxy itself and cannot point to a `.pac` (auto-config) file. If your proxy is configured through a `.pac` file, download the `.pac` file and find the proxy URL there.\n\nAn incorrectly configured proxy can result in several errors, such as `Auth0 servers not reachable` and `SELF_SIGNED_CERT_IN_CHAIN` errors.\n\nIf you have configured a proxy URL and restarted the AD/LDAP Connector, but are still seeing `SELF_SIGNED_CERT_IN_CHAIN` errors, make sure that your server is trusting the root certificate of the proxy. On a Windows machine, you can check this by opening `certmgr.msc` and looking for your proxy's certificate. To learn more, read [Proxy auto config (PAC) on Wikipedia](https://en.wikipedia.org/wiki/Proxy_auto-config).\n\n### No internet connectivity\n\nEnsure that your server can connect to your Auth0 tenant (`https://{yourDomain}`).\n\nTo verify this, open a browser and navigate to `https://{yourDomain}/test`.\n\n### Service account permissions\n\nThe Service account used to configure the AD/LDAP Connector must have `read` permissions on the AD/LDAP server, and must be capable of querying groups for users.\n\n### Kerberos issues\n\nTo enable verbose logging of Kerberos requests:\n\n1.  Add `DEBUG=kerberos-server` as a system environment variable.\n    \n2.  Restart the AD/LDAP Connector.\n    \n3.  Log in.\n    \n4.  Check the logs for more information.\n    \n\nIf you have Kerberos enabled, but your users are being prompted for username/password, verify that the IP address setting is properly configured. For more information, see [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos).\n\nThe AD/LDAP Connector uses two levels of configurable caching:\n\n1.  **Auth0 server**: Caches both the user’s credentials and their profile.\n    \n2.  **AD/LDAP Connector**: Caches a user’s group memberships.\n    \n\nThe configuration of these settings determines the immediacy that changes in your directory may be reflected in a user’s profile when they log in to your application(s). In some AD/LDAP installations, user attributes synchronization may take a few minutes.\n\n#### Caching on the Auth0 server\n\nThe Auth0 server caches the user’s last successfully authenticated profile, including a hash of their username and password. It is enabled by default, and can be disabled.\n\nThe purpose of this first-level cache is to maximize availability of authentication transactions when AD is unavailable, such as during a network outage. It is only activated if the AD/LDAP Connector or the AD/LDAP server(s) are unavailable.\n\nThe AD/LDAP Connector caches a user’s group memberships. This cache’s lifetime is determined by the `GROUPS_CACHE_SECONDS` variable in the [AD/LDAP Connector configuration file](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-config-file-schema), with a default value of 600 (seconds).\n\nThe purpose of this second-level cache is to minimize execution time. By default, the AD/LDAP Connector retrieves all group membership of a user recursively, which can be an expensive process in some AD/LDAP installations. This cache is deleted every time you restart the AD/LDAP Connector.\n\n### Connector restarts after \"auth0: Connection closed.\" message in the log\n\nTo avoid the requirement of an open inbound port in your servers, the AD/LDAP Connector creates a websocket connection to an available node in Auth0's server cluster and keeps it open to listen to incoming messages from Auth0.\n\nApproximately once per day (though the frequency may vary under certain circumstances), each server node terminates the connection to allow internal deployment processes to occur. The AD/LDAP Connector detects the closed connection and terminates the process, allowing the service stack to restart the process, create a new connection to an available node, and resume operations.\n\nTo avoid any downtime, enable the cache:\n\n1.  Go to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select the **Active Directory/LDAP** connection type.\n    \n2.  Select your AD/LDAP connection.\n    \n3.  Switch to the **Applications** view, and enable the connection for the desired application(s).\n    \n4.  Select **Save**.\n    \n\n### Receive \"postUrl is required\" error\n\nYou may encounter this error if you have not completed additional configuration for a [custom domain](https://auth0.com/docs/customize/custom-domains).\n\nIn order to use AD/LDAP connections with Kerberos support, you will need to update the **Ticket** endpoint to work with the custom domain:\n\n1.  Open the [AD/LDAP Connector configuration file](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-config-file-schema).\n    \n2.  Set the `PROVISIONING_TICKET` configuration variable to `https://{yourDomain}/p/ad/jUG0dN0R`.\n    \n3.  Restart the AD/LDAP Connector.\n    \n\n### Unable to verify issuer certificate locally\n\nIf you receive the `UNABLE_TO_GET_ISSUER_CERT_LOCALLY` error after configuring an AD/LDAP Connector, the Certificate Authority could be missing from your machine.\n\n*   If your tenant is in the public cloud environment, verify that you have the [ISRG Root X1 certificate](https://letsencrypt.org/certificates/#root-certificates) in your Trusted Store on the machine with the installed AD/LDAP Connector.\n    \n*   If you are on the converged platform environment, add the [ISRG Root X2 certificate](https://letsencrypt.org/certificates/#root-certificates) to the Trusted Store on the machine with the installed AD/LDAP Connector.\n    \n\nIf you are configuring a [High Availability environment](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability) and are encountering this error on an additional machine, verify that the Trusted Root Certificate Authorities on the additional machine matches the Trusted Root Certificate Authorities on the initial machine.\n\n## Contact Auth0 Support\n\nIf you are unable to resolve any of these issues on your own, contact [Auth0 Support](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets).\n\nTo help the Support team troubleshoot your issue, include the following items in your support ticket:\n\n1.  Description of the issue.\n    \n2.  An [export of your AD/LDAP configuration files](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/import-export-ad-ldap-connector-configs).\n    \n3.  A copy of the service log file(s):\n    \n    *   Windows: `C:\\Program Files (x86)\\Auth0\\AD LDAP Connector\\logs.log`\n        \n    *   Linux: `/var/log/auth0-adldap.log`\n        \n4.  The version number of your AD/LDAP Connector.\n    \n    ![Troubleshoot AD/LDAP Connector Console Screen](https://images.ctfassets.net/cdy7uua7fh8z/4TxfMbN76vRwaON9RKzt6F/81327d0c830082a0d78a89f005edfc87/adldap-connector-version.png)\n\n## Learn more\n\n*   [AD/LDAP Connector System Requirements](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-requirements)\n*   [Import and Export AD/LDAP Connector Configurations](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/import-export-ad-ldap-connector-configs)\n*   [Set Up AD/LDAP Connector Test Environment](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-test-environment)\n*   [Update AD/LDAP Connectors](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/update-ad-ldap-connectors)\n*   [AD/LDAP Connector Configuration File Schema](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-config-file-schema)\n*   [Monitor AD/LDAP Connector with System Center Operations Manager](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-scom)",
  "title": "Troubleshoot AD/LDAP Connector",
  "description": "Common issues and troubleshooting information for the AD/LDAP Connector.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-php/troubleshoot-auth0-php-library",
  "markdown": "# PHP: Troubleshooting your Auth0-PHP integration\n\nThe following is a list of issues you might see when using the Auth0 PHP library and how you might troubleshoot these issues.\n\n**I'm getting an \"Invalid State\" exception when trying to log in.**\n\n[State validation](https://auth0.com/docs/secure/attack-protection/state-parameters) was added in 5.1.0 for improved security. By default, this uses session storage and will happen automatically if you are using a combination of `Auth0::login()` and any method which calls `Auth0::exchange()` in your callback.\n\nIf your users encounter this error:- Ensure your application is not accidentally invoking `Auth0::login()` more than once, which could invalidate the state stored on the end user's device.- The end user is using a modern browser on their device and not blocking cookies.\n\n**I am getting** **`curl error 60: SSL certificate problem: self-signed certificate in certificate chain`** **on Windows**\n\nThis is a common issue with the latest PHP versions under **Windows OS** (it is related to an incompatibility between Windows and OpenSSL CA's database).\n\n1.  Download this CA database `https://curl.haxx.se/ca/cacert.pem` to `c:/cacert.pem`.\n    \n2.  Edit your php.ini and add `openssl.cafile=c:/cacert.pem`. (It should point to the file you downloaded.)\n    \n\n**My host does not allow using Composer**\n\nThe PHP SDK requires Composer for maintaining dependencies (external PHP libraries). If Composer is now allowed to be installed globally on your host, you can still install it locally to run on your user shell account. Instructions for this can be found on the Composer website: [https://getcomposer.org/doc/00-intro.md#locally](https://getcomposer.org/doc/00-intro.md#locally)\n\n## Learn more\n\n*   [PHP: Getting Started using Auth0-PHP](https://auth0.com/docs/libraries/auth0-php)\n*   [PHP: Logging in, out, and returning user profiles with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/auth0-php-basic-use)\n*   [PHP: Using the Authentication API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-authentication-api-with-auth0-php)\n*   [PHP: Using the Management API with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/using-the-management-api-with-auth0-php)\n*   [PHP: Validating JWTs (JSON Web Tokens) with Auth0-PHP](https://auth0.com/docs/libraries/auth0-php/validating-jwts-with-auth0-php)",
  "title": "PHP: Troubleshooting your Auth0-PHP integration",
  "description": "Troubleshooting commons issues with your PHP applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs/log-data-retention",
  "markdown": "# Log Data Retention\n\nYour Auth0 log retention period depends your subscription level.\n\n| **Plan** | **Log Retention** |\n| --- | --- |\n| Starter | 1 day |\n| B2C Essentials | 2 days |\n| B2C Professional | 10 days |\n| B2B Essentials | 10 days |\n| B2B Professional | 10 days |\n| Enterprise | 30 days |\n\n[Auth0 Support](https://support.auth0.com/) can help you integrate with external logging services if you need to retain logs beyond your retention time. This approach is also useful for aggregating logs across your organization.\n\nIn addition, you can use Auth0 log streaming to export log data. To learn more, navigate to [Log Streaming](https://marketplace.auth0.com/features/log-streaming) in Auth0 Marketplace.\n\n## Learn more\n\n*   [Log Streams](https://auth0.com/docs/customize/log-streams)",
  "title": "Log Data Retention",
  "description": "Describes how long log data is stored depending on your Auth0 plan.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling",
  "markdown": "# Troubleshoot Custom Databases\n\nYou can use return errors resulting from your custom database connection for troubleshooting purposes. We will also cover some basic troubleshooting steps for your scripts.\n\n## Types of errors\n\nYou may receive different types of errors from a database connection:\n\n| Error | Login Script | Description |\n| --- | --- | --- |\n| `new WrongUsernameOrPasswordError(<email or user_id>, <message>)` | Login | Occurs when the user's credentials are invalid. Passing no arguments or a falsey first argument will result in the error being logged as an `fu` event (invalid username/email) with an empty string for a `user_id`. Providing a truthy first argument will result in the error being logged as an `fp` event (the user exists, but the password is invalid) with a `user_id` value of `auth0\\|<first argument>`. To learn more, read [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes). |\n| `new ValidationError(<user_exists>, <message>)` | Create | Occurs when a user already exists in your database. |\n| `callback(<null>,<false>)` | Change Password | Occurs when the user's password was not updated. |\n| `callback(<null>)` | Get User | Occurs when the user is not found. |\n| `new UnauthorizedError(<message>)` | All Login Scripts | Occurs when something went wrong while trying to reach the database. Preferred way of communicating errors back from custom databases to front-end. |\n| `new Error(<message>)` | All Login Scripts | Occurs when something went wrong while trying to reach the database. |\n| `error code: auth0_idp_error; user already exists` | Create | Occurs in legacy identity store when you attempt to create a user that already exists in your legacy identity store or in Auth0. |\n| `error code: auth0_idp_error; user already exists` | Delete | Occurs in legacy identity store when you attempt to delete a user with custom database scripts. Error could also manifest as `Error! There was a problem deleting user@example.com` or `Sandbox Error: Please implement the Delete script for this database connection at https://manage.auth0.com/#/connections/database`. |\n\n## Return errors\n\nTo return an error, call the **callback** function while passing **error** as the first parameter:\n\nExample:\n\n```\ncallback(new ValidationError('email-too-long', 'Email is too long.'));\n```\n\n### Returning errors when using Lock\n\nIf you use Lock, you can [customize the error messages](https://auth0.com/docs/customize/login-pages/classic-login/customize-lock-error-messages) that will be displayed by adding them to the dictionary.\n\n## Troubleshooting errors\n\nTest the script using the **Try** button.\n\nIf you do not get the expected result or you receive an error, install the [Real-time Webtask Logs extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs), use `console.log()` statements in your script, and try the connection again. The output of `console.log()` will print to the Real-time Webtask Logs window.\n\nYou may experience errors using action scripts to import, create, or delete users. Use `console.logs` to verify the error is a result of using action scripts. To learn more, read [Custom Database Action Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates).",
  "title": "Troubleshoot Custom Databases",
  "description": "Describes how to handle errors and troubleshoot when using your database as an identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/anatomy",
  "markdown": "# Custom Database Connection Anatomy Best Practices\n\nYou typically use a custom database connection to provide access to your own legacy identity store for authentication (sometimes referred to as **legacy authentication**) or [perform user import through automatic migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) (often referred to as **trickle** or **lazy** migration). You can also use custom database connections to proxy access to an Auth0 tenant in scenarios where you use Auth0 multi-tenant architecture. To learn more, read [Multi-Tenant Applications Best Practices](https://auth0.com/docs/get-started/auth0-overview/create-tenants/multi-tenant-apps-best-practices).\n\nYou typically create and configure custom database connections using the Auth0 Dashboard. You create a database connection and then toggle **Use my own database** to enable editing of the database action scripts. A custom database connection can also be created and configured with the Auth0 Management API [Create a connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/post_connections) and the `auth0` strategy.\n\n![Auth0 Dashboard Authentication Database Connection Custom Database Settings Use Own Database Enabled](https://images.ctfassets.net/cdy7uua7fh8z/11HPAdVwJMmnWbzMVjHCJ8/c6583a1d8e3c02771fb81f2515f6e813/dashboard-connections-database-edit_view-custom-database_use-my-own-database.png)\n\nAs shown below, you use custom database connections as part of a login workflow to obtain user identity information from your own legacy identity store for authentication or user import.\n\n![Custom Database Connection Flow](https://images.ctfassets.net/cdy7uua7fh8z/1H2Ky1WyPlZ9zHZrEVlFhP/4e4856395fac6d6339c883c35d4b4ac0/custom-database-connections.png)\n\nIn addition to artifacts common for all database connection types, a custom database connection allows you to configure action scripts—custom code used when interfacing with legacy identity stores. The scripts you choose to configure depend on whether you are creating a connection for legacy authentication or for automatic migration.\n\nAction scripts can be implemented as anonymous functions; however, anonymous functions make it hard to debug when it comes to interpreting the call-stack generated as a result of any exceptional error conditions. For convenience, we recommend providing a function name for each action script. To see some recommended names, read [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution).\n\nIn a legacy authentication scenario, no new user record is created; the user remains in the legacy identity store and Auth0 uses the identity it contains when authenticating the user. Custom database connections are also used outside of the Universal Login workflow. For example, a connection's `changePassword` action script is called when a password change operation occurs for a user that resides in a legacy identity store.\n\n## Automatic migration\n\nDuring automatic migration, Auth0 creates a new user in an identity store (database) managed by Auth0. Auth0 uses the identity in the Auth0-managed identity store when authenticating the user. For this to occur, Auth0 first requires the user to be authenticated against the legacy identity store, and only if this succeeds will the new user be created in the Auth0 managed database. Auth0 creates the new user using the same ID and password that was supplied during authentication.\n\nUser creation in an automatic migration scenario typically occurs after the Login action script completes. We recommend that you do not attempt to delete users from a legacy identity store as an inline operation within the Login script, but instead as an independent process. This prevents accidental user deletion should an error condition occur during migration.\n\nWith automatic migration, users remain in the legacy identity store and can be deleted or archived if required. A side-effect can occur where a user is deleted from Auth0 but remains in the legacy data store. In this case, a login made by the deleted user could result in either the Login or Get User script executing and the user again migrating from the legacy identity store.\n\nWe recommend marking legacy store user identities as migrated before either Login or Get User scripts complete and prior to any eventual legacy store deletion to prevent the unintentional recreation of intentionally-deleted users.\n\n## Size\n\nWe recommend that the total size of any action script not exceed 100 KB. The larger the size, the more latency is introduced due to the packaging and transport process employed by the Auth0 platform, and this will have an impact on the performance of your system. Note that the 100 KB limit does not include any `npm` modules that may be referenced as part of any `require` statements.\n\n## Learn more\n\n*   [Custom Database Connection Security Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/connection-security)\n*   [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution)\n*   [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment)",
  "title": "Custom Database Connection Anatomy Best Practices",
  "description": "Learn about best practices for custom database connection anatomy.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles",
  "markdown": "# Check User Profiles\n\n1.  Is user profile information correct at the source (authorization server)?\n    \n2.  Generate and check the [HAR file](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files), look for an `id_token`.\n    \n3.  Decode the `id_token` at [JWT.io](https://jwt.io/) to see if it has the correct information.\n    \n4.  Check any custom database scripts or rule logic.\n    \n5.  Check if you called `/tokeninfo` endpoint and have a custom domain configured within Auth0. If so, you need to use `/userinfo` endpoint instead\n    \n6.  Check if you called `/userinfo` endpoint properly. You should pass an access token. You should call this endpoint with the default Auth0 domain even if the tenant has a custom domain enabled.\n    \n7.  Check if you specified the correct [scope](https://auth0.com/docs/get-started/apis/scopes) to get an Access Token.\n    \n\n## Learn more\n\n*   [User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles)\n*   [Normalized User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles)\n*   [User Profile Structure](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure)\n\nWas this article helpful?",
  "title": "Check User Profiles",
  "description": "Learn how to check user profiles to troubleshoot issues",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution",
  "markdown": "# Custom Database Action Script Execution Best Practices\n\nA custom database connection type allows you to configure action scripts, which contain custom code Auth0 uses to interface with your legacy identity store. Action scripts are a named JavaScript function that accepts a predefined set of parameters.\n\n## Webtask containers\n\nAction scripts execute within an individual Webtask container with an execution limit of approximately 20 seconds. After the functions execute, the container is recycled.\n\nWhen a container is recycled, it terminates the action script’s pending operations. This may result in an error condition being returned and a potential reset of the `global` object. For more information on the `global` object, read [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment).\n\n## Asynchronous features\n\nAsynchronous features of JavaScript, including [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) objects and [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function), are supported in action scripts.\n\nYou can use asynchronous features to execute non-blocking operations within an action script, but make sure that these operations do not exceed the execution limit of the Webtask container. When the Webtask container is recycled, it will terminate any pending operations, which may result in unexpected behavior or an error.\n\nIf you are making a call to an external service or API within your action script, set the function to time out after a reasonable duration, and [return an error](#error-handling) if the external service or API cannot be reached.\n\n### Examples\n\nAuth0 supports using [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) objects and [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) within action scripts.\n\n#### Promise object\n\nThis example uses the built-in JavaScript `fetch` method, which gets a resource from a network then returns a Promise object, written using [promise chains](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#chaining).\n\n```\nfunction login(userNameOrEmail, password, callback) {\n\tconst hashedPassword = hash(password);\n\tconst apiEndpoint = 'https://example.com/api/authenticate';\n\tconst options = {\n\t\tmethod: 'POST',\n\t\tbody: {\n\t\t\temail: userNameOrEmail,\n\t\t\tpassword: hashedPassword\n\t\t}\n\t};\n\n\tfetch(apiEndpoint, options) \n\t\t.then((response) => {\n\t\t\tif (!response.ok) {\n\t\t\t\treturn callback(new Error(`HTTP error! Status: ${response.status}`));\n\t\t\t}\n\n\t\t\treturn response.json();\n\t\t})\n\t\t.then((response) => {\n\t\t\tif (response.err) {\n\t\t\t\treturn callback(new Error(`Error authenticating user: ${err}`));\n\t\t\t}\n\n\t\t\tlet profile = {\n\t\t\t\temail: response.profileData.email,\n\t\t\t\tusername: response.profileData.username\n\t\t\t};\n\n\t\t\treturn callback(null, profile);\n\t\t})\n\t\t.catch((err) => {\n\t\t\treturn callback(new Error(`An error occurred: ${err}`));\n\t\t});\n  }\n```\n\n#### Async function\n\nThis example uses the built-in JavaScript `fetch` method, which gets a resource from a network then returns a Promise object, written using [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).\n\n```\nasync function login(userNameOrEmail, password, callback) {\n\tconst hashedPassword = hash(password);\n\tconst apiEndpoint = 'https://example.com/api/authenticate';\n\tconst options = {\n\t\tmethod: 'POST',\n\t\tbody: {\n\t\t\temail: userNameOrEmail,\n\t\t\tpassword: hashedPassword\n\t\t}\n\t};\n\n\tconst response = await fetch(apiEndpoint, options);\n\n\tif (!response.ok) {\n\t\treturn callback(new Error(`HTTP error! Status: ${response.status}`));\n\t}\n\n\tconst result = response.json();\n\n\tif (result.err) {\n\t\treturn callback(new Error(`Error authenticating user: ${err}`));\n\t}\n\n\tlet profile = {\n\t\temail: response.profileData.email,\n\t\tusername: response.profileData.username\n\t};\n\n\treturn callback(null, profile);\n}\n```\n\n## Callback function\n\nThe `callback` function signals the action script’s operation is complete and must be called exactly once. An action script should complete immediately after a call to the `callback` function, preferably by explicitly using the `return` statement.\n\n### Asynchronous processing\n\nIf an action script uses asynchronous processing, then the `callback` function must be called after all asynchronous operations complete.\n\n### Parameters\n\nIf the `callback` function is called with no parameters, it will be executed as if a `null` parameter had been provided.\n\n## Size\n\nThe total size of implementation for any action script must not exceed 100kB. This size limitation excludes imported `npm` modules. For more information on `npm` modules, read [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment).\n\nThe larger the size of a script, the more latency is introduced based on the packaging and transport process employed by the Webtask platform. The size impacts the performance of the system.\n\n## Anonymous functions\n\nAction scripts can be implemented as anonymous functions, but it is not recommended that you do so. Anonymous functions make it difficult to debug the action script and interpret the call-stack generated as a result of any exceptional error condition. To learn more about anonymous functions, read [IIFE on MDN Web Docs](https://developer.mozilla.org/en-US/docs/Glossary/IIFE).\n\n## Error handling\n\nPass an `Error` object to the `callback` function with a descriptive message of the error:\n\n```\nreturn callback(new Error('My custom error message'));\n```\n\n## Security\n\n### Database interface vs. API\n\nEnsure to secure all communications between Auth0 and your legacy identity store. If your legacy identity store does not already have an API implemented, it is highly recommended that you do so.\n\nIf your legacy identity store has an API available, you can [register the API](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) through Auth0, and [create an Action](https://auth0.com/docs/manage-users/access-control/sample-use-cases-actions-with-authorization#deny-access-to-anyone-calling-an-api) to restrict access from end users.\n\nIf your legacy identity store does not have an API available—and implementing one is not feasible—you can still communicate with your database directly. Make sure to [add Auth0 IP addresses to your firewall’s allow list](https://auth0.com/docs/secure/security-guidance/data-security/allowlist) to allow inbound traffic from Auth0.\n\n## Identity provider tokens\n\nIf the `user` object returns the `access_token` and `refresh_token` properties, Auth0 handles them differently from other types of user information. Auth0 stores them in the `user` object's `identities` property:\n\n```\n{\n    \"email\": \"you@example.com\",\n    \"updated_at\": \"2019-03-15T15:56:44.577Z\",\n    \"user_id\": \"auth0|some_unique_id\",\n    \"nickname\": \"a_nick_name\",\n    \"identities\": [ \n        {\n            \"user_id\": \"some_unique_id\",\n            \"access_token\": \"e1b5.................92ba\",\n            \"refresh_token\": \"a90c.................620b\",\n            \"provider\": \"auth0\", \"connection\": \"custom_db_name\",\n            \"isSocial\": false \n        }\n  ], \n  \"created_at\": \"2019-03-15T15:56:44.577Z\",\n  \"last_ip\": \"192.168.1.1\",\n  \"last_login\": \"2019-03-15T15:56:44.576Z\",\n  \"logins_count\": 3\n}\n```\n\nIf you want to retrieve either of these properties with the Auth0 Management API, include the `read:user_idp_tokens` scope when [requesting an Access Token](https://auth0.com/docs/secure/tokens/access-tokens/get-management-api-access-tokens-for-production).",
  "title": "Custom Database Action Script Execution Best Practices",
  "description": "Learn about best practices for custom database action script execution.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/rules-best-practices/rules-execution-best-practices",
  "markdown": "# Rules Execution Best Practices\n\nEach rule is executed as a JavaScript function called in the order defined. The next rule in order won’t execute until the previous rule has completed. In addition, the rule pipeline only executes for workflows that involve user credentials; the rule pipeline **does not** execute during the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow). For functionality similar to a rule, an [Action](https://auth0.com/docs/customize/actions) in the [Machine to Machine Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow) on the `credentials-exchange` trigger can be used instead.\n\nIn pipeline terms, a rule completes when the `callback` function supplied to the rule is called. Failure to call the function results in a stall of pipeline execution, and ultimately in an error being returned. Each rule must call the `callback` function **exactly** once.\n\nRule execution supports the asynchronous nature of JavaScript, and constructs such as [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) objects and the like can be used. Asynchronous processing effectively results in suspension of a pipeline pending completion of the asynchronous operation. An Auth0 serverless Webtask container typically has a circa 20-second execution limit, after which the container may be recycled. Recycling of a container due to this limit will prematurely terminate a pipeline—suspended or otherwise—ultimately resulting in an error in authentication being returned (as well as resulting in a potential reset of the `global` object).\n\nSetting `context.redirect` triggers a redirection once all rules have completed (the redirect is not forced at the point it is set). While all rules must complete within the execution limit of the Webtask container for the redirect to occur, the time taken as part of redirect processing can extend beyond that limit. We recommend that redirection back to Auth0 via the `/continue` endpoint should ideally occur within one hour. Redirection back to the `/continue` endpoint will also cause the creation of a new container in the context of the current pipeline, in which all rules will again be run.\n\nAsynchronous execution will result in a (JavaScript) callback being executed after the asynchronous operation is complete. This callback is typically fired at some point after the main (synchronous) body of a JavaScript function completes. If a rule is making use of asynchronous processing, then a call to the (Auth0) supplied `callback` function must be deferred to the point where asynchronous processing completes and must be the final thing called. As discussed above, the (Auth0) supplied `callback` function must be called exactly once; calling the function more than once within a rule will lead to unpredictable results and/or errors.\n\n## context object\n\nThe `context` object provides information about the context in which a rule is run (such as client identifier, connection name, session identifier, request context, protocol, etc). Using the context object, a rule can determine the reason for execution. For example, as illustrated in the sample fragment below, `context.clientID` as well as `context.protocol` can be used to implement conditional processing to determine when rule logic is executed. The sample also shows some best practices for exception handling, use of `npm` modules (for `Promise` style processing), and the `callback` object. To learn more, read [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment)`.`\n\n```\nswitch (context.protocol) {\n    case 'redirect-callback':\n      return callback(null, user, context);\n    \tbreak;\n\n    default: {\n      user.app_metadata = user.app_metadata || {};\n      switch(context.clientID) {\n        case configuration.PROFILE_CLIENT: {\n          user.user_metadata = user.user_metadata || {};\n          Promise.resolve(new\n            Promise(function (resolve, reject) {\n              switch (context.request.query.audience) {\n                case configuration.PROFILE_AUDIENCE: {\n                  switch (context.connection) {\n                      .\n                      .\n                  }\n                } break;\n              .\n              .\n            })\n          )\n          .then(function () {\n              .\n              .\n          })\n          .catch(function (error) {\n            return callback(new UnauthorizedError(\"unauthorized\"), user, context);\n          });\n        } break;\n\n        default:\n          return callback(null, user, context);\n          break;\n\n    } break;\n```\n\nWe highly recommend reviewing best practices when using contextual bypass logic for Multi-Factor Authentication checking. For example, **serious security flaws** can surface if use of MFA is predicated on `context.request.query.prompt === 'none'`. In addition, the content of the `context` object is **security sensitive**, so you should **not** directly pass the object to any external or third-party service.\n\n### Redirection\n\nIt may not be practical to collect information from a user as part of a login flow in situations where there are many applications and you want a centralized service to manage that, or if you are using a SPA and you want to prevent the user from getting an access token under certain conditions. In these cases, having a centralized way to collect information or provide a challenge to a user is necessary.\n\nAuth0 allows you to redirect the user to any URL where you can collect information from that user and then return the user to the `/continue` endpoint where they can complete the original /authorize request that triggered the redirect. This is a powerful capability, and depending on the use case, the impact of doing it wrong can be anywhere from innocuous to leaving a security vulnerability in the application. As such, it is important to ensure that this is done correctly.\n\nIn most use cases, a redirect rule is in use to prompt the user to make some change to their profile such as:\n\n*   Forcing a password change\n    \n*   Verifying their email\n    \n*   Adding information to their profile\n    \n\nWe recommend that the rule check for some flag or value in the user's `app_metadata`, then redirect to an application that does its own /authorize call to Auth0 and make any changes to the user's metadata and redirect the user back to Auth0. This works great for any profile changing redirects or anything that does not need to restrict the user from logging in.\n\nRedirect from rule allows you to implement custom authentication flows that require additional user interaction triggered by context.redirect. Redirect from rule can only be used when calling the `/authorize` endpoint.\n\nRedirection to your own hosted user interface is performed before a pipeline completes and can be triggered once per `context.clientID` context. Redirection should only use HTTPS when executed in a production environment, and additional parameters should be kept to a minimum to help mitigate common security threats. Preferably, the Auth0-supplied `state` is the only parameter supplied.\n\nOnce redirected, your own hosted user interface executes in a user authenticated context, and obtains authenticity artifacts by the virtue of Auth0 SSO. Obtaining these artifacts—e.g., an ID Token in OpenID Connect (OIDC), and/or an Access Token in OAuth 2.0—is achieved by using a `context.clientID` context **that is not** the one which triggered redirect. To do this, redirect to the `/authorize` endpoint. In the case of a SPA for example, use silent authentication. This creates a new pipeline that causes all rules to execute again, and you can use the `context` object within a rule to perform conditional processing.\n\nUpon completion of whatever processing is to be performed, pipeline execution continues by redirecting the user back to Auth0 via the `/continue` endpoint (and specifying the `state` supplied). This causes all rules to execute again within the current pipeline, and you can use the `context` object within a rule to perform conditional processing checks.\n\nBeware of storing too much data in the Auth0 profile. This data is intended to be used for authentication and authorization purposes. The metadata and search capabilities of Auth0 are not designed for marketing research or anything else that requires heavy search or update frequency. Your system is likely to run into scalability and performance issues if you use Auth0 for this purpose. A better approach is to store data in an external system and store a pointer (the user ID) in Auth0 so that backend systems can fetch the data if needed. A simple rule to follow is to store only items that you plan to use in rules to add to tokens or make decisions.\n\nPassing information back and forth in the front channel opens up surface area for bad actors to attack. This should definitely be done only in conditions where you must take action in the rule (such as rejecting the authorization attempt with `UnauthorizedError`).\n\n## user object\n\nThe `user` object provides access to a cached copy of the user account (user profile) record in Auth0. The object provides access to information regarding the user without the need to access the Auth0 Management API—access which is both rate limited and subject to latency.\n\nWhile the contents of the `user` object can be modified—for example, one rule could make a change which another rule could use to influence its execution—any changes made will not be persisted. There may be occasions when it becomes necessary to persist, say, updates to metadata associated with a user, and the `auth0` object can be used to perform such operations where required.\n\nUpdating a user via use of the `auth0` object ultimately results in a call to the Auth0 Management API. As the Auth0 Management API is both rate limited and subject to latency, caution should be exercised regarding when and how often updates are performed.\n\nThe `context` object contains the `primaryUser` property which refers to the user identifier of the primary user. This user identifier will typically be the same as `user_id` property in the root of the `user` object. The primary user is the user that is returned to the Auth0 engine when the rule pipeline completes, and the `user_id` is a unique value generated by Auth0 to uniquely identify the user within the Auth0 tenant. This `user_id` should be treated as an opaque value.\n\nThere are occasions when `primaryUser` must be updated as the primary user may change—i.e., the user returned to the Auth0 engine will be different from the user on rule pipeline entry. On such occasions, a rule must update `primaryUser` to reflect the new primary user identifier. Note that this change will not affect any subsequent rule executed in the current instance of the pipeline; the `user` object will remain unchanged.\n\n### Identities\n\nThe `user` object also contains a reference to the identities associated with the user account. The `identities` property is an array of objects, each of which contain properties associated with the respective identity as known to the identity provider (for example, the `provider` name, associated `connection` in Auth0, and the `profileData` obtained from the identity provider during the last authentication using that identity). Linking user accounts creates multiple entries in the array.\n\nEach identity in the `identities` array also contains a `user_id` property. This property is the identifier of the user as known to the identity provider. While the `user_id` property in the root of the `user` object may also include the identifier of the user as known to the identity provider, as a best practice, use of the `user_id` property in an array identity should be preferred. The `user_id` in the root of the user object should be treated as an opaque value and should not be parsed.\n\n### Metadata\n\nThe `user_metadata` property and the `app_metadata` property refer to the two different aspects of the metadata associated with a user. Both the `user_metadata` property and the `app_metadata` property provide access to cached copies of each.\n\nAuthorization-related attributes for a user—such as role(s), group(s), department, and job codes—should be stored in `app_metadata` and not `user_metadata`. This is because `user_metadata` can essentially be modified by a user, whereas `app_metadata` cannot.\n\nThere may be occasions when it becomes necessary to persist, say, updates to metadata associated with a user, and the `auth0` object can be used to perform such operations where required. When updating either metadata object, it is important to be judicious regarding what information is stored: in line with metadata best practice, be mindful of excessive use of metadata, which can result in increased latency due to excessive processing within the pipeline. To learn more, read [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data). Use of the `auth0` object also results in a call to the Auth0 Management API, so caution should be exercised regarding when and how often updates are performed since the Auth0 Management API is both rate limited and subject to latency.\n\n## callback function\n\nThe `callback` function supplied to a rule effectively acts as a signal to indicate completion of the rule. A rule should complete immediately following a call to the callback function, either implicitly or by explicitly executing a (JavaScript) `return` statement, and should refrain from any other operation.\n\nFailure to call the function will result in a stall of pipeline execution, and ultimately in an error condition being returned. Each rule then must call the `callback` function exactly once. Calling it once prevents the stall of the pipeline, but more could cause unpredictable results or errors.\n\n```\nfunction (user, context, callback) {\n  getRoles(user.user_id, (err, roles) => {\n    if (err) return callback(err);\n\n    context.idToken['https://example.com/roles'] = roles;\n\n    return callback(null, user, context);\n  });\n}\n```\n\nAs can be seen in the example above, the `callback` function can be called with up to three parameters. The first parameter is mandatory and provides an indication of the status of rule operation. The second and third parameters are optional and represent the user and the context to be supplied to the next rule in the pipeline. If these are specified, then it is a recommended best practice to pass the `user` and `context` object (respectively) as supplied to the rule.\n\nWhile it can be acceptable to modify certain contents of either the `user` or the `context` object for certain situations, as a recommended best practice you should refrain from passing a newly-created instance of either the `user` or the `context` object. Passing anything other than a `user` or `context` object will have unpredictable results and may lead to an exception or error condition.\n\nThe status parameter should be passed as either `null`, an instance of an `Error` object, or an instance of an `UnauthorizedError` object. Specifying null will permit the continuation of pipeline processing, while any of the other values will terminate the pipeline; an `UnauthorizedError` signals denial of access and allows information to be returned to the originator of the authentication operation regarding the reason why access is denied. Passing any other value for any of these parameters will have unpredictable results and may lead to an exception or error condition.\n\nAs authentication has already occurred, any early exit of the pipeline with an (authorization) error will not impact the authenticated session within the browser; subsequent redirects to /authorize will typically result in an automatic login. The early exit of the pipeline simply stops tokens et al from being generated. One option is for the application to redirect to the Authentication API's [Logout endpoint](https://auth0.com/docs/api/authentication#logout), if required, to force termination of the Auth0 session in the browser.\n\nAny call to the Logout endpoint could be interrupted, so explicit Auth0 session termination is not guaranteed. This is important, as any explicit condition that caused an `unauthorized` error must be re-checked in any subsequent rule pipeline execution, and it should not be possible to bypass these condition check(s) through any other conditions (such as `prompt===none`).\n\n## Learn more\n\n*   [Rules Anatomy Best Practices](https://auth0.com/docs/rules-best-practices/rules-anatomy-best-practices)\n*   [Rules Environment Best Practices](https://auth0.com/docs/rules-best-practices/rules-environment-best-practices)\n*   [Rules Security Best Practices](https://auth0.com/docs/rules-best-practices/rules-security-best-practices)\n*   [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)\n*   [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices)",
  "title": "Rules Execution Best Practices",
  "description": "Learn about best practices for executing Auth0 rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/rules-best-practices/rules-testing-best-practices",
  "markdown": "# Rules Testing Best Practices\n\nThe Auth0 Dashboard provides the facility to `TRY` a rule for the purpose of testing and debugging. This facility allows a mock `user` and `context` object to be defined, which is then passed to the rule as part of its execution. The resulting output from the rule (including any console logging) is displayed upon completion. While this provides an immediate at-a-glance way to unit test a rule, it is very much a manual approach, and one which is unable to leverage the use of automated testing tools such as [Mocha](https://mochajs.org/) or [rewire](https://www.npmjs.com/package/rewire).\n\nAs a best practice, and as part of the recommended support for the Software Development Life Cycle, you should use a separate test tenant in Auth0 to test any rule/rule changes before deploying to production.\n\n## Automation\n\nWith the help of a little boilerplate, however, it is possible to implement in a way that enables a rule to be deployed and executed in an Auth0 Tenant and, without modification, to be consumed in any Continuous Integration/Continuous Deployment (CI/CD) automated (unit) testing environment:\n\n```\nconst vm = require('vm');\n  const fs = require('fs');\n  var user = {\n      \"name\":        \"jdoe@foobar.com\",\n      \"email\":       \"jdoe@foobar.com\",\n      \"user_id\":     \"auth0|0123456789\",\n          .\n          .\n    };\n  var context = {\n      \"clientID\":            \"123456789\",\n      \"clientName\":          \"MyWebApp\",\n      \"connection\":          \"MyDbConn\",\n      \"connectionStrategy\":  \"auth0\",\n      \"protocol\":            \"oidc-basic-profile\",\n          .\n          .\n    };\n\n  global.configuration = {\n    DEBUG: true\n  };\n\n  vm.runInThisContext(\n      \"(()=>{return \" + fs.readFileSync('./rules/Normalized Profile Claims.js') + \" })();\", {\n        // filename for stack traces\n        filename: 'Normalized Profile Claims.js',\n        displayErrors: true\n      }\n  )(\n    user,\n    context,\n    function callback() {\n      console.log(\"Complete\");\n    }\n  );\n```\n\nAs shown in the example above, some relatively straightforward testing can be implemented (in an independent node module) by using the Node.js [VM](https://www.w3schools.com/nodejs/ref_vm.asp) to execute the rule to be tested. In this case, a rule named Normalized Profile Claims is read from a file, and some boilerplate is added around the rule (JavaScript) code prior to executing it (the boilerplate being in the strings that both prefix and suffix the filesystem call to [read the file](https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options) containing the rule code).\n\nThe options object passed on the call to `runInThisContext` provides information that can be used to assist with debugging in the case where any exceptional error condition(s) may arise. Please see the Node.js [documentation](https://node.readthedocs.io/en/stable/api/vm/) for further information regarding this function call.\n\nThe first two objects passed to the rule during testing represent the `user` and `context` objects, and these can be mocked in a fashion similar to that employed in the Auth0 Dashboard `TRY` functionality. The `callback` function, supplied as the third parameter, can be implemented to simulate pipeline continuation, subsequently performing execution of the next rule in order.\n\nThe `callback` function supplied can be used to ensure execution of the callback is performed at least once by having the (callback) function complete the test and/or provide an assertion. We also recommend providing implementation to also ensure that multiple execution of the callback is not performed by a rule.\n\nIn addition, the (Node.js) `global` object can be used to provide both the configuration object and also an instance of the `auth0` object if required. In the sample above, a global `configuration` object has been defined that aligns with recommended practices to assist with debugging (as described in the section above).\n\nThe sample above also makes use of the file system directory structure provided by Auth0 Deploy CLI—the tooling which can assist with rule deployment.",
  "title": "Rules Testing Best Practices",
  "description": "Learn about best practices for testing and debugging your Auth0 environment.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/rules-best-practices/rules-environment-best-practices",
  "markdown": "# Rules Environment Best Practices\n\nRules execute as a series of called JavaScript functions in an instance of an Auth0 serverless Webtask **container**. As part of this, a specific environment is provided, together with a number of artifacts supplied by both the container and the Auth0 authentication server (your Auth0 tenant) itself.\n\n## npm modules\n\nAuth0 serverless Webtask containers can make use of a wide range of [`npm`](https://www.npmjs.com/) modules; npm modules not only reduce the overall size of rule code implementation but also provide access to a wide range of pre-built functionality.\n\nBy default, a large list of publicly available npm modules are supported out-of-the-box. This list has been compiled and vetted for any potential security concerns. To see the list, read [Can I require: Auth0 Extensibility](https://auth0-extensions.github.io/canirequire/).\n\nIf you require an `npm` module that is not supported, you can [make a request at the Auth0 Support portal](https://support.auth0.com/) or through your Auth0 representative. Auth0 evaluates requests to determine suitability. There is currently no support in Auth0 for the use of `npm` modules from private repositories. New packages are typically added on a 2-week cycle when requested. Existing packages are rarely removed as this would cause breaking changes in rules. Keep in mind, Auth0 packages and versions are stored on an internal registry and are not in sync with `npm`.\n\nWhen using `npm` modules to access external services, keep API requests to a minimum, avoid excessive calls to paid services, and avoid potential security exposure by limiting what is sent. To learn more, read [Performance Best Practices](https://auth0.com/docs/troubleshoot/performance-best-practices).\n\nWhen requiring a module in a rule, if the version is not specified, the package manager uses the first version it finds on the internal list. A version may be specified to force the package manager to use a non-default version. This allows rule code to take advantage of fixes or features from the specified version that are not available in the default module version.\n\n## Environment variables\n\nAuth0 Rules support environment variables, accessed via the globally available configuration object. Configuration should be treated as read-only and should be used for storing sensitive information, such as credentials or API keys for external service access. This mitigates having security-sensitive values hard-coded in a rule. It can also be used to support Software Development Life Cycle (SDLC) best practice strategies you employ by allowing you to define variables that have tenant-specific values. This mitigates hard-code values in a rule which may change depending upon which tenant is executing it.\n\n### global object\n\nAuth0 serverless Webtask containers are provisioned from a pool that's associated with each Auth0 tenant. Each container instance makes available the `global` object, which can be accessed across all rules that execute within the container instance. The `global` object acts as a global variable and can be used to define information, or to even define functions, that can be used across all rules (that run in the container) irrespective of the pipeline instance:\n\n```\nglobal.tokenVerify = global.tokenVerify || function(token, secret) {\n      /* The 'jwt.verify' function is synchronous, however wrapping with a promise\n      * provides for better error management and integration within the logic\n      * flow.\n      */\n      return new Promise(function(resolve, reject) {\n      jwt.verify(\n    token,\n    secret,{\n    clockTolerance: 5},\n    function(err, decoded) {\n      if (err) {\n    reject(err);\n      } else {\n    resolve(decoded);\n      }\n      });\n    });\n    };\n```\n\nThe `global` object can also be used to cache expensive resources, such as an Access Token for a third-party (e.g., logging) API that provides non user-specific functionality or an Access Token to your own API defined in Auth0 and obtained by using Client Credentials flow.\n\nRules can run more than once when a pipeline is executed, and this depends on the context of operation. For each context in which a rule is run, an existing container instance is either provisioned from the Auth0 tenant pool or may be instantiated anew. For each instantiation of a new Webtask container, the `global` object is reset. Thus, any declaration within the `global` object should also include provision for initialization (as shown above), ideally with that declaration being made as early as possible (i.e., in a rule that runs early in the execution order).\n\n### auth0 object\n\nThe `auth0` object is a specially-restricted instance of [`ManagementClient`](https://github.com/auth0/node-auth0#management-api-client) (defined in the [node-auth0 Node.js client library](https://github.com/auth0/node-auth0)) and provides limited access to the Auth0 Management API. It is primarily used for updating metadata associated with the `user` object from within a rule.\n\nAs well as being restricted (i.e., supporting a limited number of `ManagementClient` methods for `user` access only), the Access Token associated with the `auth0` object has scopes limited to `read:users` and `update:users`. Typically, all of this is sufficient for the majority of operations we recommend being performed from within a rule. However, if you need access to the full range of supported methods, and/or access to additional scope(s), then you will need to employ an alternative means of access to the Management API.\n\nAlternative access to the Management API from within a rule is typically achieved by instantiating an independent instance of the `ManagementClient`. This will give you access to all current capabilities, including logic like automatic retries on `429` errors as a result of rate limiting policy. In addition, if you only require the default scopes, then you can even initialize the new instance using the Access Token associated with the `auth0` object.\n\nLike the `context` object, the `auth0` object contains security-sensitive information, so you should not pass it to any external or third-party service. Further, the Auth0 Management API is both rate limited and subject to latency, so you should be judicious regarding how often calls are made. Read more about `context` objects on the [Rules Execution Best Practices](https://auth0.com/docs/rules-best-practices/rules-execution-best-practices) page.\n\nUse the `auth0` object (and any other mechanisms for calling the Auth0 Management API) sparingly and use adequate exception and error handling to prevent unexpected interruption of pipeline execution.\n\n## Learn more\n\n*   [Rules Anatomy Best Practices](https://auth0.com/docs/rules-best-practices/rules-anatomy-best-practices)\n*   [Rules Execution Best Practices](https://auth0.com/docs/rules-best-practices/rules-execution-best-practices)\n*   [Rules Security Best Practices](https://auth0.com/docs/rules-best-practices/rules-security-best-practices)\n*   [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)\n*   [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices)",
  "title": "Rules Environment Best Practices",
  "description": "Learn about best practices for building Auth0 rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime",
  "markdown": "# Update ID Token Lifetime\n\nYou can change the ID token lifetime using the Auth0 Dashboard. By default, an ID token is valid for 36000 seconds (10 hours). If there are security concerns, you can shorten the time period before the token expires, keeping in mind that one of the purposes of the token is to improve user experience by caching user information.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click the name of the application to view.\n    \n2.  Scroll to **ID Token** and locate the **ID Token Expiration** field. Enter the appropriate ID token lifetime (in seconds) for the application.\n    \n    ![Dashboard Applications Applications Settings Tab ID Token](https://images.ctfassets.net/cdy7uua7fh8z/26uUwvRKsPoVQVkztB3pyf/b8bb8aa28f4df0054ee7c69d3ae8da4e/dashboard-applications-applications-settings-id-token.png)\n3.  Click **Save Changes**.\n    \n\n## Learn more\n\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)",
  "title": "Update ID Token Lifetime",
  "description": "Describes how to update the ID token lifetime for an application using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens",
  "markdown": "# Get ID Tokens\n\nTo get an ID token, you need to request them when authenticating users. Auth0 makes it easy for your app to authenticate users using:\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts): The easiest way to implement authentication, which can show you how to use [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login), the Lock widget, and Auth0's language and framework-specific SDKs. Our [Lock documentation](https://auth0.com/docs/libraries/lock) and [Auth0.js documentation](https://auth0.com/docs/libraries/auth0js) provide specifics about retrieving an ID token after authentication.\n    \n*   [Authentication API](https://auth0.com/docs/api/authentication): If you prefer to roll your own, you can call our API directly. First, you need to know [which flow to use](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use) before following the appropriate flow tutorial.\n    \n\n## Control ID token contents\n\nYou control which claims about the authenticated user are included in the ID token consumed by your application by including specific [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes) in the `scope` parameter when you request tokens while authenticating users.\n\nYou can also create [custom claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims), which are claims that you define, control, and add to a token using a rule. As with other JWTs, you should [validate an ID token](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens) before assuming that its contents can be trusted.\n\n## Renew ID tokens\n\nBy default, an ID token is valid for 36000 seconds (10 hours). If there are security concerns, you can [shorten the time period before the token expires](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime), but remember that one of the purposes of this token is to improve performance by caching user information.\n\nAfter an ID token has expired, you may want to renew your ID token. To renew the ID token, you can either re-authenticate the user using Auth0, or use a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n## Learn more\n\n*   [Validate ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens)\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Get ID Tokens",
  "description": "Describes how to request an ID token when authenticating users that includes claims about the user by including OIDC scopes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-the-deploy-cli-tool",
  "markdown": "# Troubleshoot Deploy CLI Tool\n\n## Warning log entries after a Google Apps connection is recreated\n\n**Symptoms**: you see warnings in the logs with messages like `Unable to get extended attributes: unauthorized` or `Unable to get groups: unauthorized`.\n\nWhen you first create a Google Apps connection and enable one of the checkboxes to get extended information about the user, you'll need to go through a consent flow by having a Google Apps administrator follow the link under the \"Setup instructions\" button next to the connection. After completing this flow, some token information is stored on the connection's `options` object that is used to retrieve extended information when a user logs in.\n\nIf you have a Google Apps connection, you'll need to ensure that the consent flow is completed before exporting the connection information using the CLI. By doing this, the necessary tokens will be included in the exported script and the administrator won't have to go through the consent flow every time the connection is recreated.\n\n## Learn more",
  "title": "Troubleshoot Deploy CLI Tool",
  "description": "Learn how to troubleshoot the Auth0 Deploy Command Line Interface (CLI) tool.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/prompts/patch-prompts",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/secure/application-credentials/generate-rsa-key-pair",
  "markdown": "# Generate RSA Key Pair\n\nWhen you register the public key with Auth0, you must provide the public key encoded in PEM format. You may provide this as an X.509 certificate encoded in PEM format. Auth0 enforces a minimum RSA key size of 2048 bits and a maximum key size of 4096 bits. We recommend using [OpenSSL](https://www.openssl.org/) to generate a 2048-bit RSA key pair.\n\n1\\. Generate a private key and a public key in PEM. You should safeguard the private key and never share it, not even with Auth0:\n\n`openssl genrsa -out test_key.pem 2048`\n\n2\\. Extract the public key in PEM format using the following command. This command extracts the public key details so it can be safely shared without revealing the details of the private key:\n\n`openssl rsa -in test_key.pem -outform PEM -pubout -out test_key.pem.pub`\n\nThe example below shows the contents of the `test_key.pem.pub` PEM file:\n\n```\n----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA53VzmIVVZZWyNm266l82 mnoDc9g/snXklax5kChEhqK/WnTUvuXP4Gd4THj8rchxgUGKXd4PF3SUcKyn/qPm Tet0idVHk2PwP//FOVgYo5Lb04js0pgZkbyB/WjuMp1w+yMuSn0NYAP7Q9U7DfTb jmox8OQt4tCB4m7UrJghGqT8jkPyZO/Ka6/XsyjTYPOUL3t3PD7JShVAgo1mAY6g Sr4SORywIiuHsg+59ad7MXGy78LirhtqAcDECKF7VZpxMuEjMLg3o2yzNUeWI2Mg IF+t0HbO1E387fvLcuSyai1yWbSr1PXyiB2aXyDpbD4u7d3ux4ahU2opH11lBqvx +wIDAQAB -----END PUBLIC KEY-----\n```\n\n3\\. Save the PEM file. You will need the key contents in other application configuration steps.\n\n## Learn more\n\n*   [Authenticate with Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)",
  "title": "Generate RSA Key Pair",
  "description": "Learn how to generate a RSA key pair. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login",
  "markdown": "# Configure Universal Login with Passwordless\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nUniversal Login is Auth0's implementation of the authentication flow, which is the key feature of an Authorization Server. Each time a user needs to prove their identity, your applications redirect to Universal Login and Auth0 guarantees the user's identity. You can choose to enable Passwordless authentication when you configure Universal Login in the Auth0 Dashboard.\n\nFirst, determine if you want users to use SMS, email, or WebAuthn for device biometrics as the Passwordless authentication method. It is not currently possible to support all three authentication methods in a single login flow.\n\n## Passwordless with email or SMS\n\nYou can configure Auth0 so users can authenticate with a magic link or one-time password (OTP) sent to their email, or an OTP sent to their phone number. To learn more, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\n## Passwordless with WebAuthn with device biometrics\n\nWhen using WebAuthn with Device Biometrics, users will be able to authenticate with their password, or with any of their devices that support WebAuthn with Device Biometrics.\n\nEach time they login from a new device, Auth0 will offer them the option to use biometrics instead of a password. To learn more, read [Passwordless with WebAuthn with Device Biometrics](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics).\n\n![Example of setting up a Face ID login for specific domain using WebAuthn](https://images.ctfassets.net/cdy7uua7fh8z/1JfsIYEo3O7xmTAxLRwNSs/2f2ba478ff32b0aa86f4f01cd6c0cf3b/2023-01-31_16-34-09.png)\n\n## Learn more\n\n*   [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms)\n*   [Configure WebAuthn with Device Biometrics for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics)",
  "title": "Configure Universal Login with Passwordless",
  "description": "Learn how to configure your login page to use passwordless authentication using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/attack-protection/bot-detection",
  "markdown": "# Bot Detection\n\nBot Detection mitigates scripted attacks by detecting when a request is likely coming from a bot. These types of attacks are sometimes called credential stuffing attacks or list validation attacks. Bot Detection provides support against certain attacks and adds very little friction to legitimate users. Auth Challenge is our default bot detection response, which provides a CAPTCHA-free user verification.\n\nTo learn more, read [Credential Stuffing Attacks: What Are They and How to Combat Them](https://auth0.com/resources/whitepapers/credential-stuffing-attacks).\n\nAuth0 uses a large amount of data and statistical models to identify patterns that signal when bursts of login, signup, or password reset traffic are likely from a bot or script. Users who attempt to log in, create accounts, or reset passwords from IP addresses that have a high likelihood of being part of a credential stuffing attack are required to complete an additional verification step. The triggers detect traffic relating to these attacks without adding unnecessary friction to legitimate users.\n\n![The login page with a success screen](https://images.ctfassets.net/cdy7uua7fh8z/7qq0mjypNbmtFgDD5CcJWT/b45d95ca2096cf277c40b7964920c6ab/2024-02-28_14-09-26.png)\n\n## Configure Bot Detection\n\nAuth0 enables Bot Detection by default for all connections.\n\nIf you do not configure **Response** settings with Bot Detection enabled, Bot Detection operates in [Monitoring](https://auth0.com/docs/secure/attack-protection#monitoring) mode. Monitoring mode records related events (with risk assessment information) in your tenant log for you to review. To learn more, read [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events).\n\nYou can configure Bot Detection in the [Auth0 Dashboard](https://manage.auth0.com/#).\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection) and select **Bot Detection**.\n    \n2.  In the **Detection** section, enable the toggle.\n    \n    ![Detection section of the Attack protection screen](https://images.ctfassets.net/cdy7uua7fh8z/3q0HlAm0m0aLilEOAhQ81h/d8626e6e7572a1eb026421d17799d2f0/Screenshot_2024-02-01_at_10.43.58_AM.png)\n3.  In the **Response** section, choose a bot detection response.\n    \n    ![Dashboard - Attack Protection - Bot Detection](https://images.ctfassets.net/cdy7uua7fh8z/3vuVvc01mfCPdc70AU9Oq1/0d5b1519818211ba49c17f5c9e1d1887/2024-05-06_15-47-06.png)\n    \n    When using Auth Challenge, the **Fail open** toggle is disabled by default.\n    \n4.  Select when you want to require CAPTCHA for password flows, passwordless flows, and password reset flows.\n    \n    ![Bot detection CAPTCHA flows image](https://images.ctfassets.net/cdy7uua7fh8z/3yb6jEGO2rL8cYQjtDxOk9/14156c7356b1a56851d4f944fb5e9689/Screenshot_2024-05-29_at_1.39.29_PM.png)\n    *   **Never**: Never require your users to complete a CAPTCHA to log in.\n        \n    *   **When Risky**: Only require your users to complete a CAPTCHA if the login matches your **Bot Detection Level** setting.\n        \n    *   **Always**: Always require your users to complete a CAPTCHA to log in.\n        \n5.  If you choose **When Risky** or **Always**, the **CAPTCHA Providers** field will appear in the **Response** section. Select **Auth Challenge** (provided by Auth0), **Simple CAPTCHA** (provided by Auth0), or one of the supported third-party provider integrations (requires external setup and registration).\n    \n    *   If you choose **Auth Challenge** or **Simple CAPTCHA**, you are done. If your login experience does not support JavaScript, you must select **Simple CAPTCHA**.\n        \n    *   If you choose one of our third-party provider integrations, enter the provider’s configuration details. To learn more, read [Configure third-party CAPTCHA provider integrations](https://auth0.com/docs/secure/attack-protection/bot-detection/configure-captcha).\n        \n6.  If you choose **When Risky**, the **Bot Detection Level** field will appear in the **Response** section. Select the security level that best fits your use case. For more information, read [Configure Bot Detection Level](https://auth0.com/docs/secure/attack-protection/bot-detection#configure-bot-detection-level).\n    \n7.  Select **Save**.\n    \n\n## Configure Bot Detection Level\n\nConfigure the **Bot Detection Level** setting to match your risk tolerance and business needs.\n\nThere are three settings to choose from:\n\n1.  **Low**: Triggers CAPTCHA when there is a high chance of bot activity, providing a relatively frictionless experience for real users.\n    \n2.  **Medium**: Default. Triggers CAPTCHA when there is a moderate chance of bot activity, providing a balance of security and experience for real users.\n    \n3.  **High**: Triggers CAPTCHA when there is a small chance of bot activity, providing more security but potentially more friction for real users.\n    \n\n![Auth0 Dashboard > Security > Attack Protection to access this slider](https://images.ctfassets.net/cdy7uua7fh8z/6HSMEXmDHVks6aUH0FUTPo/e7f0aedad84f0b022f854dbc5494df31/2023-07-24_15-28-04.png)\n\n## Allow trusted IP addresses to bypass Bot Detection\n\nYou can allow up to 100 discrete IP addresses and/or CIDR ranges (IPv4 or IPv6) to bypass Bot Detection by adding them to the **IP AllowList** field. Auth0 does not enforce blocking and does not send alerts for IP addresses or CIDR ranges on this list.\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection), and select **Bot Detection**.\n    \n2.  In the **IP AllowList** field, enter the IP addresses and/or CIDR ranges you want to bypass Bot Detection. Separate multiple addresses or ranges with commas.\n    \n\n## Restrictions and limitations\n\n### Flow limitations\n\nBot Detection works for web and mobile applications that use [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). For applications that do not use Universal Login, levels of support are limited, in particular for flows that cannot support a CAPTCHA or reCAPTCHA challenge.\n\nEnsure all of your login experiences are supported before you enable Bot Detection, or you may introduce errors into your application.\n\n| **Flow** | **Limitation** |\n| --- | --- |\n| Universal Login | Supported by default. |\n| Classic Login (no customizations) | Supported by default. |\n| Classic Login (Custom Login Page using **Lock** template) | Supported if using `lock.js` SDK version 12.4.0 or higher. |\n| Classic Login (Custom Login Page using **Custom Login Form** template) | Supported if using `auth0.js` SDK version 9.24 or higher, and you enhance your code to handle a CAPTCHA or reCAPTCHA challenge. |\n| Native applications | Supported if using one of the following SDKs:<br><br>*   `Auth0.swift` version 1.28.0+<br>*   `Auth0.Android` version 1.25.0+<br>*   `Lock.Swift` version 2.19.0+<br>*   `Lock.Android` version 2.22.0+ |\n| Regular Web or Native applications using Resource Owner Password Flow | Supported in a limited capacity. Bot Detection Response such as CAPTCHA requires an interactive flow and therefore is not supported. If the `requires_verification` error is returned by the SDK, you must trigger a web-based login flow for the user to complete authentication. |\n| Flows not hosted by Auth0 using `lock.js` or `auth0.js` SDK which perform cross-origin authentication (`co/authenticate` endpoint) | Not supported. |\n\n### Connection type limitations\n\nDepending on the types of connections you use, Bot Detection has the following limitations.\n\n| **Connection Type** | **Limitation** |\n| --- | --- |\n| Database | Supported if the login uses a compatible login flow as described in the Flow limitations table. |\n| Custom database | Supported if the login uses a compatible login flow as described in the Flow limitations table. |\n| Active Directory/LDAP | Supported if the login uses a compatible login flow as described in the Flow limitations table. |\n| Enterprise | Not supported. |\n| Social Login | Not supported. |\n| Passwordless | Supported if the login uses a compatible login flow as described in the Flow limitations table. |\n\n### Custom login page support\n\nIf you build a custom login page using Auth0.js, you can enable Bot Detection to render a CAPTCHA step in scenarios when a login request is determined by Auth0 to be high-risk.\n\nYour custom login form code must handle scenarios where the user is asked to pass a CAPTCHA step. To learn more, read [Add Bot Detection to Custom Login Pages](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-custom-login-pages).\n\n### Native application support\n\nIf you build native applications using an Auth0 SDK for the login flow, you can enable Bot Detection to render a CAPTCHA step in scenarios when a login request is determined by Auth0 to be high-risk.\n\nYour custom login form code must handle scenarios where the user is asked to pass a CAPTCHA step. To learn more, read [Add Bot Detection to Native Applications](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-native-apps).\n\n## Learn more\n\n*   [Configure Third-Party CAPTCHA Provider Integrations](https://auth0.com/docs/secure/attack-protection/bot-detection/configure-captcha)\n*   [Add Bot Detection to Custom Login Pages](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-custom-login-pages)\n*   [Add Bot Detection to Native Applications](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-native-apps)\n*   [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection)\n*   [Brute-Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection)\n*   [Suspicious IP Throttling](https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling)",
  "title": "Bot Detection",
  "description": "Describes how Auth0 detects attacks to protect against malicious attempts to access your application, alert you and your users of suspicious activity, and block further login attempts.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions",
  "markdown": "# Troubleshoot Extensions\n\nIf you see issues with an [](https://auth0.com/docs/customize/extensions)extensions, we recommend that you begin the troubleshooting process with the following two steps:\n\n1.  Reinstall the extension.\n    \n2.  Migrate to Node.js v12.\n    \n\nTo learn more about different extensions Auth0 offers, read [Auth0 Extension](https://auth0.com/docs/customize/extensions).\n\n## Reinstall the Extension\n\nOne of the first things you can do when running into issues with an extension is to reinstall it:\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions).\n    \n2.  On the **Installed Extensions** tab, delete the extension.\n    \n3.  Log out of the Auth0 Dashboard.\n    \n4.  Log back in to the Auth0 Dashboard.\n    \n5.  Reinstall and reconfigure the extension.\n    \n\n## Migrate to Node.js v12\n\nWe recommend changing your tenant's extensibility runtime from Node.js v8 to Node.js v12. Before updating, however, review the [migration guide](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-nodejs-12) for full details on what will be affected by this change.\n\nYou can change the Node.js runtime version by going to the **Extensibility** section in [Auth0 Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n\n## Contact Support\n\nIf you are still experiencing issues with your extension, and you need to [contact Auth0 support](https://support.auth0.com/), please be sure to **include errors logs and/or** [**real-time Webtask logs**](https://auth0.com/docs/customize/extensions/real-time-webtask-logs) **with your support ticket**. Errors and logs can help Auth0 support troubleshoot your issue faster.",
  "title": "Troubleshoot Extensions",
  "description": "Learn general troubleshooting steps for extensions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/attack-protection/breached-password-detection",
  "markdown": "# Breached Password Detection\n\nBreached password detection protects your applications from bad actors signing up or logging in with stolen credentials. Auth0 can both notify users and block at-risk accounts.\n\nAuth0 tracks large security breaches that occur on major third-party sites. If Auth0 identifies that any of your users’ credentials were part of a breach, the breached password detection security feature triggers. In response, Auth0 can:\n\n*   Block new users from signing up with stolen credentials. Entirely blocks the username/password combination.\n    \n*   Block anyone from logging in with stolen credentials. Entirely blocks the account and prevents bad actors from accessing your application. The user can’t log in until they change their password. \n    \n*   Send an email to the user when a login attempt happens. The email informs users about the risk and instructs them to change their password immediately. You can customize the message sent to users. To learn more, read [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails).\n    \n\n## Detect breaches faster with Credential Guard\n\nBreached password detection relies on breach data released to the public. Credential Guard is an additional Auth0 service you can add to breach password detection that screens for breaches to allow faster notification of compromised credentials.\n\n|     | **Breached Password Protection** | **Credential Guard** |\n| --- | --- | --- |\n| **Plans included** | B2B / B2C Professional and Enterprise | Part of Attack Protection add-on in Enterprise plan |\n| **Data collection method** | Web scanners and scrapers search for user credentials in published security breaches | Dedicated security team infiltrates criminal communities and gains access to breach data that isn’t otherwise available |\n| **Typical detection time** | Up to 7-13 months | 12-36 hours |\n| **Coverage** | English only | 200+ countries and territories |\n\nTo add Credential Guard to your Auth0 agreement, [contact us](https://auth0.com/get-started?place=header&type=button&text=talk%20to%20sales).\n\n## Configure breached password detection\n\nWhen enabled, you can customize breached password detection preferences, such as the detection method, response scenarios, and notifications.\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection) and select **Breached Password Detection**.\n    \n    ![The toggle for turning on breached password detection in Auth0](https://images.ctfassets.net/cdy7uua7fh8z/239K5la6duvT7ZwpAt2ED1/b7db9665f372f0cf37bb3405f906a366/Screen_Shot_2022-01-20_at_3.46.04_PM.png)\n2.  To turn on breached password detection, enable the switch at the top-right corner of the page.\n    \n    ![Configure breached password detection in Auth0](https://images.ctfassets.net/cdy7uua7fh8z/4xxqrdFGgd5toF8r6MZNvw/bce8ec201496ecfa538dc5c69e433653/2022-08-22_16-10-13.png)\n\n### Configure detection method\n\nBased on features available with your plan, you can configure the detection method used to identify compromised credentials.\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection) and select **Breached Password Detection**.\n    \n2.  In the **Detection** section, locate **Breached Password Detection Method**.\n    \n3.  If your agreement with Auth0 includes Credential Guard, select **As soon as possible based on data received from the dark web, with Credential Guard**.\n    \n4.  Otherwise, leave **When breach data is published** selected.\n    \n5.  Select **Save** to apply changes.\n    \n\n![Dashboard > Security > Attack Protection > Breached Password > Detection](https://images.ctfassets.net/cdy7uua7fh8z/5wb1JnQ0NetJ1kpbSMIm1V/6efa1366e2fc4e2f598915ef9ce885c8/breached-password-detection0.png)\n\n### Configure response scenarios\n\nYou can configure how Auth0 responds to different scenarios when users may provide compromised credentials.\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection) and select **Breached Password Detection**.\n    \n2.  Locate the **Response** section.\n    \n    ![Dashboard > Security > Attack Protection > Breached Password > Response](https://images.ctfassets.net/cdy7uua7fh8z/2E752PH9A6glc8BnYFdr3d/275f0bdeb1080ef0e8da6d1243c45e91/2022-08-22_16-10-45.png)\n3.  Enable the **Block compromised credentials for new accounts** toggle to block users from using compromised credentials during signup.\n    \n4.  Enable the **Block compromised user accounts** toggle to block users from using compromised credentials during login.\n    \n\n### Configure notifications\n\nYou can configure how Auth0 notifies users and admins about the use of compromised credentials.\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection) and select **Breached Password Detection**.\n    \n2.  Locate the **Notifications** section.\n    \n3.  Enable the **Send notifications to users with compromised credentials** toggle to send an email to a user when Auth0 detects their credentials may have been compromised.\n    \n4.  Enable the **Compromised user accounts** toggle to send an email to administrators when a user signs up with compromised credentials.\n    \n5.  Enable the **Compromised user accounts** toggle to send an email to administrators when a user logs in with compromised credentials.\n    \n6.  Choose the notification frequency: **Immediately**, **Daily**, **Weekly**, or **Monthly**.\n    \n7.  Select **Save**.\n    \n\n#### Customize email notifications to users\n\nYou can configure the notification Auth0 sends to your users when compromised credentials are used for login.\n\n1.  Navigate to [Dashboard > Branding > Email Templates](https://manage.auth0.com/#/templates). \n    \n2.  In the **Template** dropdown menu, select **Password Breach Alert**.\n    \n3.  Update the template accordingly. You can use any of the available [common variables](https://auth0.com/docs/customize/email/email-templates#common-variables) to customize the message.\n    \n\n## Verify detection configuration\n\nYou can verify your configuration by testing signup and login flows with an Auth0-provided breached password.\n\n### Signup flow\n\nVerify a user’s signup experience when Auth0 detects a breached password:\n\n1.  Go through your signup flow and try to register a new account with a test breached password (`Paaf213XXYYZZ` or `Paat739!!WWXXYYZZ`) or any password starting with `AUTH0-TEST-`.\n    \n2.  If **Block compromised credentials for new accounts** is enabled, you will receive an error message, preventing you from using the breached password.\n    \n3.  Navigate to [Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs).\n    \n4.  Search the logs for `type: \"signup_pwd_leak\"` to verify Auth0 blocked the signup.\n    \n\n### Login flow\n\nVerify a user's login experience when Auth0 detects a breached password:\n\n1.  Create a test user in [Dashboard > User Management > User](https://manage.auth0.com/#/users), and assign a test breached password (`Paaf213XXYYZZ` or `Paat739!!WWXXYYZZ`) or any password starting with `AUTH0-TEST-`.\n    \n2.  Go through your login flow and submit the identifier and password that you assigned.\n    \n3.  If **Block compromised user accounts** is enabled, the user will receive an error message, preventing them from logging in and advising to reset their password.\n    \n4.  Navigate to [Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs).\n    \n5.  Search the logs for `type: \"pwd_leak\"` to verify Auth0 blocked the login.\n    \n6.  Navigate to [Dashboard > User Management > User](https://manage.auth0.com/#/users) to delete the test user.\n    \n\n## Learn more\n\n*   [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection)\n*   [Brute-Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection)\n*   [Suspicious IP Throttling](https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling)\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)",
  "title": "Breached Password Detection",
  "description": "Understand why a user receives a breached password email and general web security tips.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-tenant",
  "markdown": "# Configure mTLS for a Tenant\n\n## Configure mTLS with Management API\n\nUse the [Auth0 Management API](https://auth0.com/docs/api/management/v2) to configure mTLS for a tenant:\n\n*   [Create a custom domain](#create-a-custom-domain)\n    \n*   [Patch an existing custom domain](#patch-an-existing-custom-domain)\n    \n*   [Verify the custom domain](#verify-the-custom-domain)\n    \n*   [Enable mTLS endpoint aliases](#enable-mtls-endpoint-aliases)\n    \n\n### Create a custom domain\n\nAt the tenant level, you must configure a [custom domain](https://auth0.com/docs/customize/custom-domains) to accept mTLS headers. Because the [customer edge](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge) is responsible for validating the client certificates, set the `type` as `self_managed_certs` in the POST request:\n\n```\ncurl --location --request POST 'https://$tenant/api/v2/custom-domains' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"domain\":\"string\",\n  \"type\":\"self_managed_certs\",\n  \"verification_method\":\"txt\", \n  \"tls_policy\":\"recommended\",\n  \"custom_client_ip_header\":\"true-client-ip\"\n}'\n```\n\nA successful request returns an identifier that is used to verify the custom domain. For more information, see the [Configure a new custom domain](https://auth0.com/docs/api/management/v2/custom-domains/post-custom-domains) API documentation.\n\n### Patch an existing custom domain\n\nYou can configure an existing custom domain to accept mTLS headers. However, you cannot update the `type` for an already existing custom domain.\n\nThe following POST request that configures an existing custom domain to accept mTLS headers:\n\n```\ncurl --location --request POST 'https://$tenant/api/v2/custom-domains/:id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"tls_policy\":\"recommended\",\n  \"custom_client_ip_header\":\"true-client-ip\"\n}'\n```\n\nFor more information, see the [Update custom domain configuration](https://auth0.com/docs/api/management/v2/custom-domains/patch-custom-domains-by-id) API documentation.\n\n### Verify the custom domain\n\nBefore Auth0 accepts requests to create and update the custom domain, it must first verify the domain. The following POST request verifies the custom domain:\n\n```\ncurl --location --request POST 'https://$tenant/api/v2/custom-domains/:id/verify'\n```\n\nCheck the `status` field to see its verification status. Once verification is complete, it may take up to 10 minutes before the custom domain can start accepting requests.\n\nWhen Auth0 verifies the custom domain for the first time, the response includes the `cname_api_key`, which you need to configure your edge/reverse proxy. This key must be kept secret and is used to validate the forwarded requests.\n\nFor more information, see the [Verify a custom domain](https://auth0.com/docs/api/management/v2/custom-domains/patch-custom-domains-by-id) API documentation.\n\n### Enable mTLS endpoint aliases\n\nWhen the mTLS handshake requests a client certificate from the client, the web browser presents users with a modal dialog to select a certificate. This introduces friction in the user experience and should be avoided for endpoints where mTLS is unnecessary such as the `/authorize` endpoint. As a result, customers that support mTLS and non-mTLS traffic on different domains should enable mTLS endpoint aliases.\n\nmTLS endpoint aliases indicate that clients should send mTLS traffic to the endpoints specified in the `mtls_endpoint_aliases` property of the OIDC discovery document. Clients will send non-mTLS traffic to the normal endpoints. For more information about the `mtls_endpoint_aliases` property, see [Call the resource server](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls#call-the-resource-server).\n\n#### Management API\n\nTo enable mTLS endpoint aliases using the [Management API](https://auth0.com/docs/api/management/v2), set the `enable_endpoint_aliases` property to `true` for your tenant:\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/tenants/settings' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"mtls\": {\n    \"enable_endpoint_aliases\": true\n  }\n}'\n```\n\nmTLS endpoint aliases add the `mtls.` prefix to the configured custom domain. For example, if the configured custom domain is `auth.saasapp.com`, the mTLS endpoint aliases will use the domain `mtls.auth.saasapp.com`. Depending on feedback, customers may be able to configure the mTLS endpoint aliases in the future.\n\nTo disable mTLS endpoint aliases, set the `enable_endpoint_aliases` value to `false`. For more information, see the [Update tenant settings](https://auth0.com/docs/api/management/v2/tenants/patch-settings) API documentation.\n\n#### Auth0 Dashboard\n\nTo enable mTLS endpoint aliases using the Auth0 Dashboard:\n\n1.  Navigate to [Auth0 Dashboard](https://auth0.com/docs/$manage_url/#) and select **Settings** from the side menu.\n    \n2.  Under Tenant Settings, select the **Advanced** tab.\n    \n3.  Find **Allow mTLS Endpoint Aliases** and toggle it on. This will route mTLS traffic to an endpoint called `mtls.<your custom domain>`**.**\n    \n\n![Auth0 Dashboard > Settings > Advanced > Allow mTLS endpoint aliases](https://images.ctfassets.net/cdy7uua7fh8z/4FnQEF7eNEgDT5OLcH46c2/745f4a40e5719884fea93d388fdfb587/Screenshot_2024-05-28_at_4.40.48_PM.png)\n\n## Learn more\n\n*   [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls)\n*   [Set up the Customer Edge](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge)\n*   [Configure mTLS for a Client](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client)",
  "title": "Configure mTLS for a Tenant",
  "description": "Describes how to configure mTLS for a tenant.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/attack-protection/brute-force-protection",
  "markdown": "# Brute-Force Protection\n\nBrute-force protection safeguards against a single IP address attacking a single user account. When a given IP address tries and fails multiple times to log in as the same user, brute-force protection:\n\n*   Blocks the suspicious IP address from logging in as that user.\n    \n*   Sends a [notification](#notifications) to the affected user.\n    \n\nIf an IP address is blocked due to brute-force protection, it remains blocked until one of these events occurs:\n\n*   An administrator [removes the block](https://auth0.com/docs/api/management/v2/#!/User_Blocks/get_user_blocks).\n    \n*   An administrator raises the **Brute Force Threshold** described below.\n    \n*   Thirty (30) days pass from the last failed login attempt.\n    \n*   The affected user selects the unblock link in the email notification (if configured).\n    \n*   The affected user changes their password (on all linked accounts).\n    \n\n## Configure brute-force protection\n\nAuth0 strongly recommends that you do not disable brute-force protection for the connection. If you disable it, you can enable it again using the Dashboard.\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection) and select **Brute-force Protection**. Enable the toggle at the top of the page if it is disabled.\n    \n    ![Dashboard Security Attack Protection Brute-force Protection](https://images.ctfassets.net/cdy7uua7fh8z/sEIc4abtu9NxcZsohSzxG/95499d90c7af136bf605003e33b9250e/Auth0_Dashboard_-_Brute-force_Protection.png)\n2.  In the **Detection** section:\n    \n    1.  Under **Brute Force Threshold**, select **Default** to use the standard limit of 10 maximum attempts, or select **Custom** to set the limit of maximum attempts to a value between 1 and 100.\n        \n    2.  Under **Manage IP Addresses**, enter the list of trusted IP addresses in the **IP AllowList** field. Brute-force protection will not be enforced for login attempts originating from these IP addresses.\n        \n3.  In the **Response** section:\n    \n    1.  Under **Block Settings**, enable the **Block Brute-force Logins** toggle to block attempts from suspicious IP addresses to safeguard against brute-force attacks that occur from a single IP address and target a single user account.\n        \n    2.  Under **Block Settings**, enable **Account Lockout** to trigger blocks irrespective of IP address. When this setting is enabled and a user consecutively attempts and fails to login, future attempts to log in from that user from any IP address will be blocked. You can adjust maximum attempts under **Brute Force Threshold**. By default, the Account Lockout toggle is disabled.\n        \n    3.  Under **Notifications**, enable the **Send notifications to the affected users** toggle to send an email notification to the user when their account has been blocked.\n        \n4.  Click **Save**.\n    \n\n## Notifications\n\nIf **Send notifications to the affected users** is enabled, Auth0 sends an SMS or email notification to a user when their account has been blocked.\n\n### SMS\n\nAuth0 sends an SMS to the user if they use a phone identifier in the login flow. SMS notifications are limited at a maximum of 1 per hour per identifier.\n\n### Email\n\nAuth0 sends an email to the user if they use a non-phone identifier in the login flow. Email notifications are limited at a maximum of 1 per hour per unique IP address.\n\nBy default, email notifications contain a link that allows the user to unblock their account. To learn more, read [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails).\n\n## Special use cases\n\nBecause brute-force protection depends on the IP address of the user, the following use cases require additional configuration:\n\n*   **ROPG on the backend**: Using this call does not get the IP address of the user; however, to make brute-force protection work correctly, you can configure your application and [send the IP address of the user as part of the request](https://auth0.com/docs/authorization/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection#configure-your-application-to-trust-the-ip-address).\n    \n*   **User authentication from the same IP address:** Users who are behind a proxy are more likely to reach set limits and trigger brute-force protection.\n    \n\nTo learn more, read [Avoid Common Issues with Resource Owner Password Flow and Attack Protection](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection).\n\n## Learn more\n\n*   [Flexible Identifiers and Attributes](https://auth0.com/docs/authenticate/database-connections/flexible-identifiers-and-attributes)\n*   [Activate and Configure Attributes for Flexible Identifiers](https://auth0.com/docs/authenticate/database-connections/activate-and-configure-attributes-for-flexible-identifiers)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)\n*   [User/Password Authentication Rate Limits](https://auth0.com/docs/support/policies/rate-limit-policy/database-connections-rate-limits)",
  "title": "Brute-Force Protection",
  "description": "Learn how to brute-force protection works in Auth0 and how to configure responses. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling",
  "markdown": "# Suspicious IP Throttling\n\nSuspicious IP Throttling blocks traffic from any IP address that rapidly attempts too many logins or signups. This helps protect your applications from high-velocity attacks that target multiple accounts.\n\nSuspicious IP throttling is enabled by default when you create your Auth0 tenant. When Auth0 detects a high number of signup attempts or failed login attempts from an IP address, it responds to subsequent attempts with the [HTTP 429 Too Many Requests status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429) until that IP address is no longer throttled.\n\n## Configure Suspicious IP Throttling\n\nYou can configure Suspicious IP Throttling in the [Auth0 Dashboard](https://manage.auth0.com/#) or with the [Auth0 Management API](https://auth0.com/docs/api/management/v2/attack-protection/patch-suspicious-ip-throttling).\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection), and select **Suspicious IP Throttling**.\n    \n2.  Select the toggle at the top of the page to enable or disable Suspicious IP Throttling.\n    \n\n![Auth0 suspicious IP throttling settings ](https://images.ctfassets.net/cdy7uua7fh8z/3CKuhfeU1nqDxrJJKAYR2k/2488411d3936efe2efcaf574b414538e/Screen_Shot_2021-09-23_at_2.00.09_PM.png)\n\n## Allow trusted IP addresses exceed throttling limits\n\nYou can make up to 100 discrete IP addresses and/or CIDR ranges (IPv4 or IPv6) exempt from Suspicious IP Throttling by adding them to the **IP AllowList**. Auth0 does not block or alert tenant administrators when these IP addresses exceed the throttling limits.\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection), and select **Suspicious IP Throttling**.\n    \n2.  In the **IP AllowList** field, enter the IP addresses and/or CIDR ranges you want to allow unlimited login and signup attempts. Separate multiple IP addresses and/or CIDR ranges with commas.\n    \n\n## Configure response\n\nBy default, Auth0 sends email to tenant administrators when an IP address is marked as suspicious.\n\nYou can configure how Auth0 responds to high-velocity login or signup attempts.\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection), and select **Suspicious IP Throttling.**\n    \n2.  Locate the **Response** section.\n    \n3.  In the **Block Settings** section, enable **Limit high-velocity traffic targeting too many accounts** to throttle traffic from IP addresses that exceed the login or signup threshold.\n    \n4.  In the **Notifications** section, enable **Send notification to account administrator** to automatically send an email to tenant administrators when an IP address exceeds the login or signup threshold.\n    \n5.  Select **Save**.\n    \n\n## Configure throttling limits and rates\n\nYou can customize how Auth0 throttles suspicious IP addresses. You can change:\n\n*   The maximum number of failed login and signup attempts allowed from a given IP address.\n    \n*   The rate at which throttled IP addresses allow new login and signup attempts.\n    \n\nFor more information on maximum attempts and throttling rate and how they work, read [How suspicious IP throttling works](#how-suspicious-ip-throttling-works).\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection), and select **Suspicious IP Throttling.**\n    \n    ![Suspicious IP throttling customization in the Auth0 dashboard](https://images.ctfassets.net/cdy7uua7fh8z/5yLYmDn0FvDB061WgTH2fk/0f3dce552a41aa5756a2eca788944965/Screen_Shot_2021-09-29_at_10.19.32_AM.png)\n2.  Locate the **Detection** section.\n    \n3.  Select **Custom** for **Suspicious IP Thresholds.**\n    \n4.  Configure the **Login Threshold** settings:\n    \n    *   **Maximum Attempts**: Enter the number of failed login attempts a single IP address can make in one day before Auth0 blocks the next attempt.\n        \n    *   **Throttling Rate**: Enter the rate at which to grant new login tokens.\n        \n5.  Configure the **Signup Threshold** settings:\n    \n    *   **Maximum Attempts**: Enter the number of signup attempts a single IP address can make in one minute before Auth0 blocks the next attempt.\n        \n    *   **Throttling Rate**: Enter the rate at which to grant new signup tokens.\n        \n6.  Select **Save**.\n    \n\n### How suspicious IP throttling works\n\nAuth0 counts and allows login and signup attempts separately. IP addresses suspended from further login attempts can still try to sign up. IP addresses suspended from further signup attempts can still try to log in. \n\n#### Login attempts\n\nAuth0 throttles an IP address that attempts and fails too many logins in a day. The login throttling rate determines how many login attempts Auth0 grants to an IP address evenly over 24 hours. For example, a throttling rate of 100 means that Auth0 grants a new attempt approximately every 15 minutes.\n\n#### Signup attempts\n\nAuth0 throttles an IP address that attempts too many total signups in a minute. For example, if an IP address makes 50 signup attempts, Auth0 blocks further attempts. Unlike logins, the signup attempts do not need to be failures.\n\nThe signup throttling rate determines how many signup attempts Auth0 grants to an IP address evenly over 24 hours. For example, a throttling rate of 72,000 means that Auth0 grants a new attempt approximately every second.\n\n#### Malformed requests and schema validation errors\n\nLogin and signup requests that do not follow the proper structure or formatting are not considered valid attempts, and therefore do not count toward your configured threshold.\n\nFor more information about login and signup requests, read [Auth0 Authentication API](https://auth0.com/docs/api/authentication).\n\n## Special cases\n\nBecause suspicious IP throttling depends on the IP address of the user, the following use cases require additional configuration:\n\n*   **Using the Resource Owner Password Grant from the backend of an application**: Using this call does not get the IP address of the user; however, to make suspicious IP throttling work correctly, you can configure your application to send the IP address of the user as part of the request. See [Avoid Common Issues with Resource Owner Password Flow and Attack Protection: Send the user's IP address from your server](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection).\n    \n*   **Authenticating a large number of users from the same IP address**: Users who are behind a proxy are more likely to reach set limits and trigger throttling. You can avoid erroneously triggering throttling by configuring an AllowList for the proxy's IP and CIDR range. See [Avoid Common Issues with Resource Owner Password Flow and Attack Protection: Configure your Application to trust the IP address](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection).\n    \n\n## Learn more\n\n*   [Brute-Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection)\n*   [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection)\n*   [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)\n*   [User/Password Authentication Rate Limits](https://auth0.com/docs/support/policies/rate-limit-policy/database-connections-rate-limits)",
  "title": "Suspicious IP Throttling",
  "description": "Learn how suspicious IP throttling works and how to configure it in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/data-security",
  "markdown": "# Data Security\n\nWas this article helpful?",
  "title": "Data Security",
  "description": "Learn about data security related to token and user data storage, Allow Lists and Deny Lists.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-center/metrics",
  "markdown": "# Metrics\n\nSecurity Center uses tenant log events to identify patterns that are usually an indicator of known attack types. We classify tenant log event patterns into categories: normal traffic, credential stuffing threats, signup attack threats, and MFA bypass threats.\n\n## Normal traffic\n\nWe use normal traffic to establish a benchmark against different threat types we may observe. Normal traffic includes all successful and failed events for a given hour, which includes the following event codes:\n\n| Event code | Event |\n| --- | --- |\n| `s` | Successful login |\n| `ss` | Successful signup |\n| `sepft` | Successful exchange of password for access token |\n| `f` | Failed user login |\n| `fu` | Failed user login due to invalid username |\n| `fp` | Failed user login due to invalid password |\n| `pwd_leak` | Attempted login with a leaked password |\n\n## Credential stuffing\n\nWe identify credential stuffing threats within a single hour with the following event codes:\n\n| Event code | Event |\n| --- | --- |\n| `f` | Failed user login |\n| `fu` | Failed user login due to invalid username |\n| `fp` | Failed user login due to invalid password |\n| `pwd_leak` | Attempted login with a leaked password |\n| `limit_wc` | IP blocked for >10 failed login attempts to a single account |\n| `limit_sul` | User blocked for >20 login per minute from the same IP address |\n| `limit_mu` | IP blocked for >100 failed login attempts or >50 signup attempts |\n\n## Signup attack\n\nWe identify signup attack threats within a single hour with the following event codes:\n\n| Event code | Event |\n| --- | --- |\n| `fs` | Failed signup |\n\n## MFA bypass\n\nWe identify MFA bypass threats within a single hour with the following event codes:\n\n| Event code | Event |\n| --- | --- |\n| `cs` | Sent code |\n| `cls` | Sent code/link |\n| `gd_send_pn` | Sent push notification |\n| `gd_send_sms` | Sent SMS |\n| `gd_auth_failed` | Failed OTP authentication |\n| `gd_auth_rejected` | Rejected OTP authentication |\n| `gd_otp_rate_limit_exceed` | Too many OTP authentication failures |\n| `gd_recovery_failed` | Failed recovery |\n| `gd_recovery_rate_limit_exceed` | Too many recovery failures |",
  "title": "Metrics",
  "description": "Learn about the tenant log events we use to identify patterns that are usually an indicator of known attack types.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/tips",
  "markdown": "# General Security Tips\n\nUsers can't usually prevent certain sites from experiencing security breaches, but there are some things they can do to help keep their accounts safe.\n\n### Check emails carefully\n\nCheck where an email is coming from and the links that they provide. Often phishing emails do not include a user's name but something generic such as \"Dear Customer\".\n\n### Reset passwords directly from sites\n\nAlways do a password reset through the actual site itself not via potentially false links in emails. Also, note that a secure website URL always starts with `https`.\n\nHere are some links for password resets on commonly-used sites:\n\n*   [Google](https://www.google.com/accounts/recovery/)\n    \n*   [Facebook](https://www.facebook.com/settings)\n    \n*   [Twitter](https://twitter.com/settings/password)\n    \n\n### Never enter personal or financial information in emails\n\nEmails in general are not very secure and are not a good way to communicate sensitive information. A trusted company/application would not ask for information in this way. Make sure not to enter confidential information through false links in emails.\n\n### Never download files from unreliable sources\n\nMost web browsers detect suspicious sites. An alert should appear when you try to access a malicious site. Never download files from suspicious emails or websites.\n\n### Do not reuse passwords\n\nWhen one site has a breach of user data, if a user uses the same credentials elsewhere, the information in other sites can also be accessed. The only way to prevent this is by not reusing passwords for multiple sites. The problem is that remembering countless passwords is frustrating and often impossible. One solution to this problem is the use of a password manager. There are many password managers available which can help users to use separate and secure passwords for each account, but at the same time not be responsible for remembering all of them.\n\n### Use strong passwords\n\nThe longer a password is, the harder it becomes to be guessed via brute force methods. Many sites allow the use of pass-phrases (a phrase or sentence instead of just a complicated word.) Try to make passwords long and use a mix of special characters, numbers, and upper- and lowercase letters.\n\n### Keep software current\n\nApplications release patches and updates when they find security vulnerabilities in their systems. Keeping applications, web browsers, and operating systems up to date can help prevent security breaches.\n\n### Check the security of your email inbox\n\nIf you use Gmail, Google offers the [Security Checkup](https://myaccount.google.com/security-checkup) tool to let you know if there are any security issues related to your inbox.\n\nYou can also use third-party tools, such as websites like [HaveIBeenPwned](https://haveibeenpwned.com/PwnedWebsites) to see if there might be security issues associated with your email address.\n\n## Learn more\n\n*   [Attack Protection](https://auth0.com/docs/secure/attack-protection)\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)",
  "title": "General Security Tips",
  "description": "Describes general security tips to prevent security breaches. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins",
  "markdown": "# Security Bulletins\n\nHere is a list of Auth0 security bulletins that address security vulnerabilities in Auth0 software. Each bulletin contains a description of the vulnerability, how to identify if you are affected, and what to do to fix it.\n\n| **Date** | **Bulletin number** | **Title** | **Affected software** |\n| --- | --- | --- | --- |\n| December 21, 2022 | [Auth0 Bulletin](https://auth0.com/docs/secure/security-guidance/security-bulletins/2022-12-21-jsonwebtoken) | Auth0 security bulletin for jsonwebtoken | [node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken) |\n| December 12, 2022 | [CVE-2022-23505](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2022-23505) | Security Update for passport-wsfed-saml2 Library | [passpord-wsfed-saml2](https://github.com/auth0/passport-wsfed-saml2) |\n| March 30, 2022 | [CVE-2022-24794](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2022-24794) | Security Update for Express OpenID Connect Library | [express-openid-connect](https://github.com/auth0/express-openid-connect) |\n| December 16, 2021 | [CVE-2021-43812](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2021-43812) | Security Update for Next.js Auth0 Library <=1.6.1 | [nextjs-auth0](https://github.com/auth0/nextjs-auth0) |\n| December 08, 2021 | [CVE-2021-41246](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2021-41246) | Security Update for Express OpenID Connect >= 2.3.0, <= 2.5.1 | [express-openid-connect](https://github.com/auth0/express-openid-connect) |\n| June 23, 2021 | [CVE-2021-32702](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2021-32702) | Security Update for Auth0 Next.js <= 1.4.1 | [nextjs-auth0](https://github.com/auth0/nextjs-auth0) |\n| June 4, 2021 | [CVE-2021-32641](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2021-32641) | Security Update for Auth0 Lock <= 11.30.0 | [Auth0 Lock](https://github.com/auth0/lock) |\n| November 05, 2020 | [CVE-2020-15259](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15259) | Auth0 Security Bulletin for ad-ldap-connector versions <= 5.0.12 | [AD/LDAP Connector](https://github.com/auth0/ad-ldap-connector) |\n| October 21, 2020 | [CVE-2020-15240](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15240) | Security Update for omniauth-auth0 JWT Validation | [omniauth-auth0](https://github.com/auth0/omniauth-auth0) |\n| August 16, 2020 | [CVE-2020-15119](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15119) | Security Update for Auth0 Lock <= 11.25.1 | [Auth0 Lock](https://github.com/auth0/lock) |\n| July 28, 2020 | [CVE-2020-15125](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15125) | Auth0 Security Bulletin for node-auth0 <= 2.27.0 | [node-auth0](https://github.com/auth0/node-auth0) |\n| June 30, 2020 | [CVE-2020-15084](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-15084) | Auth0 Security Bulletin for express-jwt versions < 6.0.0 | [express-jwt](https://github.com/auth0/express-jwt) |\n| April 09, 2020 | [CVE-2020-5263](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2020-5263) | Auth0 Security Bulletin for auth0.js versions <= 9.13.1 | Auth0.js |\n| March 31, 2020 | [Auth0 Bulletin](https://auth0.com/docs/secure/security-guidance/security-bulletins/2020-03-31-wpauth0) | Auth0 Security Bulletin for WordPress Plugin for Auth0 versions < 4.0.0 | WordPress Plugin for Auth0 |\n| January 31, 2020 | [CVE-2019-20173](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-20173) | Auth0 Security Bulletin for WordPress Plugin for Auth0 versions 3.11.0, 3.11.1 and 3.11.2 | WordPress Plugin for Auth0 |\n| January 30, 2020 | [CVE-2019-20174](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-20174) | Auth0 Security Bulletin for Auth0 Lock < 11.21.0 | Auth0 Lock |\n| October 04, 2019 | [CVE-2019-16929](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-16929) | Auth0 Security Bulletin for auth0.net between versions 5.8.0 and 6.5.3 inclusive | auth0.net |\n| September 05, 2019 | [Auth0 bulletin](https://auth0.com/docs/secure/security-guidance/security-bulletins/2019-09-05-scopes) | Auth0 Security Bulletin for assigning scopes based on email address | Custom code within Auth0 rules |\n| July 23, 2019 | [CVE-2019-13483](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-13483) | Security Bulletin for Passport-SharePoint < 0.4.0 | Passport-SharePoint |\n| February 15, 2019 | [CVE-2019-7644](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2019-7644) | Security Bulletin for Auth0-WCF-Service-JWT < 1.0.4 | Auth0-WCF-Service-JWT |\n| January 10, 2019 | [Auth0 bulletin](https://auth0.com/docs/secure/security-guidance/security-bulletins/2019-01-10-rules) | Auth0 Security Bulletin for Vulnerable Patterns in Custom Rule Code | Custom code within Auth0 Rules |\n| August 6, 2018 | [CVE-2018-15121](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-15121) | Security vulnerability in deprecated Auth0 middleware for ASP.NET | auth0-aspnet, auth0-aspnet-owin |\n| June 5, 2018 | [CVE-2018-11537](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-11537) | Security update for angular-jwt allowlist bypass | angular-jwt |\n| April 4, 2018 | [CVE-2018-6874](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-6874) | Security vulnerability for Auth0 authentication service | Auth0 Authentication Service |\n| April 4, 2018 | [CVE 2018-6873](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-6873) | Security vulnerability for Auth0 authentication service | Auth0 Authentication Service |\n| February 26, 2018 | [CVE 2018-7307](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2018-7307) | Security vulnerability for auth0.js < 9.3 | Auth0.js |\n| December 22, 2017 | [CVE 2017-16897](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2017-16897) | Security update for passport-wsfed-saml2 Passport strategy library | passport-wsfed-saml2 Passport strategy library |\n| December 4, 2017 | [CVE 2017-17068](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2017-17068) | Security update for auth0.js popup callback vulnerability | Auth0.js |",
  "title": "Security Bulletins",
  "description": "Lists Auth0 security bulletins.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/prevent-threats",
  "markdown": "# Prevent Common Cybersecurity Threats\n\nSome common cybersecurity threats include:\n\n*   Bucket brigade attacks\n    \n*   Replay attacks\n    \n*   Cross-site Request Forgery (CSRF or XSRF) attacks\n    \n*   Brute-force attacks\n    \n*   Suspicious IP throttling\n    \n*   Credential stuffing attacks\n    \n*   List validation attacks\n    \n\nAuth0 has [attack protection features](https://auth0.com/docs/secure/attack-protection) that can shield against certain types of attacks.\n\n## Bucket brigade attacks\n\nOne type of threat is a bucket brigade attack, sometimes called a \"man-in-the-middle\" attack, where the attacker gets between two parties. Each party thinks they are interacting over a private connection, but the interaction is actually being controlled by the third-party attacker. For this type of attack to succeed the attacker must create mutual authentication between both parties.\n\nUsually, bucket brigade attacks involve the attacker using a WiFi router to intercept a user's communication. The user connects to the attacker's router then visits a website and logs in with their confidential credentials. The attacker saves that user's login credentials for which they can then use to impersonate the user.\n\nSome bucket brigade attacks can also modify the data transmitted between the application and the server. Attacks can occur from new PC trial and preinstalled software, software update tools, and other software vulnerabilities. In a worst-case scenario, this could result in remote code execution, backdooring the system, installing malware, and so on. This could also lead to the compromise of other network assets.\n\nTo help defend against this type of attack it is important to use strong encryption and authentication between the application and the server. Using encryption the server authenticates the application's request by presenting a digital certificate, and only then can the connection be established. For example, HTTPS uses the secure sockets layer (SSL) capability of the browser to mask web traffic. To decrypt HTTPS, an attacker would have to obtain the keys used to encrypt the network traffic.\n\nWith the configuration of TLS on your servers, we suggest using the [Mozilla OpSec recommendations](https://wiki.mozilla.org/Security/Server_Side_TLS) which use TLSv1.2. Mozilla also provides an [SSL Configuration Generator](https://mozilla.github.io/server-side-tls/ssl-config-generator/), to use this first choose which platform your server is running and then choose the most modern configuration based on what your application base can support. The more modern configurations provide stronger ciphers to help prevent attacks.\n\n## Replay attacks\n\nReplay (or playback) attacks allow attackers to:\n\n*   Gain access to a network and information which would not have been easily accessible\n    \n*   Complete a duplicate transaction\n    \n\nThese are attacks on the security protocol using replays of data transmission from a different sender into the intended receiving system. The attacks fool the participants into believing they have successfully completed the data transmission.\n\nReplay attacks can be avoided by using session tokens. However, if these credentials are stolen from local storage (like during an XSS attack), there are ways to prevent someone from holding on to a valid token forever:\n\n*   Set a short expiration time for tokens\n    \n*   Provide a way to add tokens to the DenyList that have been used (and possibly even the users)\n    \n*   Use one-time passwords\n    \n\nThe [JWT](https://auth0.com/docs/secure/tokens/json-web-tokens) spec provides the `jti` field as a way to prevent replay attacks. Though Auth0 tokens currently don't return the `jti`, you can add tokens to the DenyList using the `jti` to prevent a token being used more than a specified number of times. In this way, you are implementing something similar to a nonce (think of the token's signature as the nonce). If a token gets stolen or it gets used more than the specified number of times, it should be added to the DenyList. This prevents a valid token from being used maliciously. Once the token expires, the attacker will no longer be able to impersonate the user.\n\nYou can also avoid replay attacks by using one-time passwords. With Auth0, you can use Passwordless Authentication, which relies on single-use codes and email links instead of traditional passwords. Auth0 also provides multi-factor authentication (MFA) which uses one-time passwords as a second-factor authentication which can be sent via push notifications and texts.\n\n## Cross-site Request Forgery\n\nA Cross-site Request Forgery (CSRF or XSRF) attack occurs when a malicious program causes a user's web browser to perform an unwanted action on a trusted site on which the user is currently authenticated. This type of attack specifically targets state-changing requests to initiate a type of action instead of getting user data because the attacker has no way to see the response of the forged request.\n\nOne way to verify the requests that are being sent is to utilize the OAuth 2.0 protocol [state parameter](https://auth0.com/docs/secure/attack-protection/state-parameters) to authenticate the response.\n\n## Learn more\n\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Attack Protection](https://auth0.com/docs/secure/attack-protection)\n*   [General Security Tips](https://auth0.com/docs/secure/security-guidance/tips)",
  "title": "Prevent Common Cybersecurity Threats",
  "description": "Describes different types of cyberattacks and what steps can be taken to prevent them.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance/data-processing",
  "markdown": "# Auth0 Data Processing\n\nThis document discusses what data Auth0 has, as well as how it processes this data.\n\n## Data Auth0 possesses\n\nAll of the data Auth0 has about an end user is located in the Auth0 user profile. The specific attributes contained in the user profile vary based on customer implementation and are based on a number of factors, such as connection type, user consent during the authentication flow, and whether you've augmented the user profiles with additional information.\n\n## When data is stored\n\nThe Auth0 user profile information is stored in Auth0 when you use a database connection. If a user logs in using any other type of connection (including custom database connections), Auth0 stores information provided by the external identity provider for future queries.\n\n## How data is used\n\nThe personal data stored in Auth0 is used only for the purposes of providing its services, namely authenticating users\n\n## What happens to data when an account is deleted\n\nWhen an end user's account is deleted, their user profile, included metadata, is removed. To learn more, read [Auth0 General Data Protection Regulation Compliance: Right to access, correct, and erase data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr).",
  "title": "Auth0 Data Processing",
  "description": "Describes how Auth0 processes data in its possession.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr",
  "markdown": "# Auth0 General Data Protection Regulation Compliance\n\nOn 27 April 2016, the European Parliament and the European Council adopted legislation known as General Data Protection Regulation (GDPR), which became enforceable **25 May 2018**. This legislation replaces European Privacy Directive 95/46/EC.\n\nGDPR is intended to unify and strengthen data privacy for individuals located in the European Union (EU). GDPR also extends the applicability of EU data privacy legislation to non-EU companies who store or process data on EU residents and increases the fines that may be levied against companies who are responsible for preventing breaches of personal data or who violate GDPR requirements.\n\nTo learn more about GDPR, read the [Complete Guide to GDPR Compliance on gdpr.eu](https://gdpr.eu/).\n\n## Definitions\n\nHere are the definitions used for Auth0's GDPR documentation:\n\n| Term | Definition |\n| --- | --- |\n| Subject | An individual/natural person |\n| Data Controller | The entity that collects and processes data on subjects ([read GDPR for exact definition](https://gdpr-info.eu/art-4-gdpr/)) |\n| Data Processor | The entity that processes data on behalf of a data controller ([read GDPR for exact definition](https://gdpr-info.eu/art-4-gdpr/)) |\n| Personal Data | Data that can be used to identify (directly or indirectly) a subject, particularly via reference to an identifier (such as a name, identification number, location data, or online identifier), or to the physical, physiological, genetic, mental, economic, cultural, or social identity of that person |\n| Sensitive Personal Data | Personal data that reveals racial or ethnic origin, political opinions, religious or philosophical beliefs, or trade-union membership; genetic data or biometric data |\n| Auth0 Subprocessors | Third party systems to which Auth0 provides personal data |\n\n### Applicability\n\nGDPR applies to a wide scope of territory including non-EU based services/companies that possess data on EU residents.\n\n### Notifications and consent\n\nBefore you collect personal data from your end users, you must obtain their consent to do so. When requesting consent, your notifications must:\n\n*   Be clear and easy to understand\n    \n*   State the purpose of the data involved and how it will be processed\n    \n\nYou must also:\n\n*   Explicitly request consent\n    \n*   Make it as easy for your end-user to revoke their consent as it is to grant consent\n    \n\n### Rights of individuals\n\nYour end users, as individuals, have the right to:\n\n*   See the data the company has about them\n    \n*   Know how their data will be processed or used\n    \n*   Be forgotten (the individual may ask the controller of their data to erase the data in question, cease disseminating the data, or halt further data processing)\n    \n*   Portability (the individual can ask for their data in a standard, machine-readable format and can transmit their data to another data controller)\n    \n*   Not be subjected to automatic decision making (a process typically called **profiling**)\n    \n\n### Privacy by design and privacy by default\n\nAs the data controller, you must design your app to abide by both privacy by design and privacy by default principles.\n\n**Privacy by design** means that each new implementation that uses personal data must take the protection of such data into consideration.\n\n**Privacy by default** means that the strictest privacy settings automatically apply once the end user acquires a new product or service (that is, without any manual change required on the part of the user).\n\n### Requirements for data processors and controllers\n\nAs the data controller, you must:\n\n*   Do due diligence to ensure that your data processors provide adequate protection of provided data\n    \n\nAuth0, as the data processor, must:\n\n*   Comply with instructions provided by data controllers\n    \n*   Maintain adequate documentation\n    \n*   Implement adequate security\n    \n*   Conduct data protection impact assessments\n    \n*   Appoint a data protection officer or establish a privacy office\n    \n*   Comply with rules on international data transfers\n    \n*   Agree to and sign a written data processing agreement that meets GDPR requirements\n    \n\n### Enforcement\n\n*   GDPR mandates that data controllers release notifications regarding data breaches within 72 hours of the incident\n    \n*   Fines for non-compliance are much higher and are determined using a tiered system\n    \n*   Supervisory authorities in the European Union have greater investigative powers\n    \n*   Organizations controlling data must appoint a Data Protection Officer, while organizations processing data should have a Data Privacy Office\n    \n\n## Roles and responsibilities under GDPR\n\nAuth0 customers are **data controllers**. Auth0 is a **data processor**.\n\n### Personal data handled by Auth0\n\nAuth0 handles end-user data present in user profiles, including metadata.\n\n### Data controller (customer) responsibilities\n\nUltimately, you, as the data controller, are responsible for GDPR compliance, which mostly consists of operational procedures and documentation.\n\nMore specifically, the customer is responsible for:\n\n*   End-user notification, consent, and withdrawal of consent\n    \n*   Deciding what data they expose to Auth0\n    \n*   Deciding what connections (where end user data and passwords reside) to use\n    \n*   Signing up and, if necessary, creating new users\n    \n*   Ensuring their users meet the age requirements and obtaining the appropriate consent if necessary (such as parental consent for children)\n    \n*   Implementing the mechanisms necessary for their end users to retrieve, review, correct, or remove personal data\n    \n*   Deleting user data after receiving right-to-be-forgotten requests\n    \n*   Providing data in standardized formats\n    \n*   Responding to their end users' privacy-related requests (DSAR)\n    \n*   Responding to communications from the European Union Data Privacy Authorities\n    \n*   Data breach notifications sent to supervisory authorities and end users (Auth0 will assist the customer and provide the necessary information if we are involved)\n    \n*   Selecting an EU tenant when setting up their Auth0 tenants\n    \n\nThe customer is the party that's responsible for the security of their data. Auth0 has no knowledge of how the customer processes data, configures their applications, and so on.\n\n### Data processor (Auth0) responsibilities\n\nAuth0 is responsible for:\n\n*   Following the data processor's instructions as explicated in the Subscription Agreement (SA) and Data Processing Addendum (DPA) (for enterprise customers) or Terms of Service (for self-service customers)\n    \n*   Notifying the customer if it receives requests from the customer's end users exercising their GDPR rights as subjects for data access, erasure, and so on\n    \n*   Notifying the customer if it receives requests from EU Data Privacy Authorities (unless prohibited by law enforcement)\n    \n*   Notifying the customer if it becomes aware of a confirmed security breach\n    \n*   Notifying the customer if any of its sub-processors notify Auth0 about a confirmed data breach that impacts Auth0 customer data (unless prohibited by law enforcement)\n    \n*   Providing a privacy policy, terms of service, security statement, data protection agreement, and so on, to provide info on its policies and practices\n    \n*   Providing information about its data processing, so that customer has info it needs to process data lawfully\n    \n*   Defining its services and features, how data is processed, and the rights and obligations of customers\n    \n*   Providing the means to enable customers to retrieve, review, correct, or delete customer data via the Auth0 Dashboard and the Auth0 Management API\n    \n*   Providing a mechanism for customers to display consent terms and a consent agreement checkbox on the Lock widget. Customers can also design custom signup and login forms if more elaborate consent schemes are needed\n    \n\n## Auth0 data processing\n\n### Data Auth0 possesses\n\nAll of the data Auth0 has about an end user is located in the Auth0 user profile. The specific attributes contained in the user profile vary based on customer implementation and are based on a number of factors, such as connection type, user consent during the authentication flow, and whether you've augmented the user profiles with additional information.\n\n### When Auth0 data is stored\n\nThe Auth0 user profile information is stored in Auth0 when you use a database connection. If a user logs in using any other type of connection (including custom database connections), Auth0 stores information provided by the external identity provider for future queries.\n\n### How Auth0 uses the data it stores\n\nThe personal data stored in Auth0 is used only for the purposes of providing its services, namely authenticating users\n\n### What happens to data when an end user's account is deleted\n\nWhen an end user's account is deleted, their user profile, included metadata, is removed.\n\nHere is a list of GDPR regulations and how Auth0 can help you comply with them.\n\n### Conditions for consent\n\nAccording to Article 7 of GDPR, you must:\n\n*   Ask users to consent on the processing of their personal data in a clear and easily accessible form\n    \n*   Be able to show that the user has consented, and\n    \n*   Provide an easy way to withdraw consent at any time\n    \n\nYou can use Auth0 to ask your users for consent upon signup (using either Lock or a custom form) and save this information at the user profile. You can later update this information using the Management API. To learn more, read [GDPR: Conditions for Consent](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-conditions-for-consent).\n\n### Right to access, correct, and erase data\n\nAccording to Articles 15, 16, 17, and 19 of GDPR, users have the right to:\n\n*   Get a copy of their personal data you are processing\n    \n*   Ask for rectifications if they are inaccurate, and\n    \n*   Ask you to delete their personal data\n    \n\nWith Auth0, you can access, edit, and delete user information, either manually or using our API. To learn more, read [GDPR: Right to Access, Correct, and Erase Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-right-to-access-correct-and-erase-data).\n\n### Data minimization\n\nAccording to Article 5 of GDPR:\n\n*   The personal data you collect must be limited to what is necessary for processing\n    \n*   Must be kept only as long as needed, and\n    \n*   Appropriate security must be ensured during data processing, including protection against unauthorised or unlawful processing and against accidental loss, destruction, or damage\n    \n\nThere are several Auth0 features than can help you achieve these goals, like account linking, user profile encryption, and more. To learn more, read [GDPR: Data Minimization](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-minimization).\n\n### Data portability\n\nAccording to Article 20 of GDPR, users have the right to receive the personal data concerning them in a structured, commonly used and machine-readable format.\n\nYou can export user data, stored in the Auth0 user store, either manually or programmatically. Raw data from Auth0 can be exported in JSON format (which is machine-readable). To learn more, read [GDPR: Data Portability](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-portability).\n\n### Protect and secure user data\n\nAccording to Article 32 of GDPR, you must implement appropriate measures to ensure a level of security, including (but not limited to):\n\n*   data encryption\n    \n*   ongoing confidentiality\n    \n*   data integrity, and\n    \n*   availability and resilience of processing systems and services\n    \n\nThere are several Auth0 features than can help you meet this requirement, like user profile encryption, brute-force protection, breached password detection, step-up authentication, and more. To learn more, read [GDPR: Protect and Secure User Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-protect-and-secure-user-data).\n\n## Security advice\n\nAuth0 recommends the following practices to help ensure the security of your end users data and minimize the probability of a data breach:\n\n*   Protect client secrets and keys\n    \n*   Protect Management Dashboard credentials, and require multi-factor authentication for access to the Dashboard\n    \n*   Review the list of administrators for the Dashboard on a regular basis and remove outdated entries\n    \n*   Review the list of connections and applications associated with your Auth0 tenants and remove outdated entries\n    \n*   Ensure that Dashboard administrators use corporate credentials that can be easily revoked if necessary, not personal credentials such as a personal email account\n    \n*   Remove accounts for terminated employees promptly\n    \n*   Ensure that administrators use devices with mandatory screen locking\n    \n*   Provide regular training to all Dashboard administrators and developers on security and privacy best practices\n    \n\nMake sure that you monitor any log streaming solution you use to send log data to logging tools with reporting capability.\n\n## Learn more\n\n*   [GDPR: Conditions for Consent](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-conditions-for-consent)\n*   [GDPR: Right to Access, Correct, and Erase Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-right-to-access-correct-and-erase-data)\n*   [GDPR: Data Minimization](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-minimization)\n*   [GDPR: Data Portability](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-data-portability)\n*   [GDPR: Protect and Secure User Data](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-protect-and-secure-user-data)",
  "title": "Auth0 General Data Protection Regulation Compliance",
  "description": "Describes how Auth0 complies with the EU's General Data Protection Regulation (GDPR).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/error-pages",
  "markdown": "# Default Auth0 Error Page\n\nIf your callback URL is valid, when an authorization error occurs, the Authorization Server returns the appropriate error and state parameters to your callback URL. In cases where your callback URL is invalid, your application will display the default generic Auth0 error page. Alternatively, you can customize the error pages. To learn more, read [](https://auth0.com/docs/authenticate/login/auth0-universal-login/error-pages)[Custom Error Pages](https://auth0.com/docs/customize/login-pages/custom-error-pages).\n\nTo find the default page name for the generic error page, see [Use Version Control to Manage Your Universal Login Pages](https://auth0.com/docs/customize/login-pages/classic-login/version-control).\n\n## Display\n\nThe generic error page displays the following information if you have configured the associated fields in your [Tenant Settings](https://manage.auth0.com/#/tenant/).\n\n| Field | Description |\n| --- | --- |\n| Friendly Name | Name of your company |\n| Logo URL | URL of your company logo |\n| Support Email | Email address of your company's support team |\n| Support URL | URL of your company's support page |\n\n## Parameters\n\nThe Authorization Server returns parameters appended to the URL as a query string.\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `client_id` | Identifier of the Auth0 application. |\n| `connection` | Connection used at the time of error. |\n| `lang` | Language set for use at the time of error. |\n| `error` | Error code of the error. |\n| `error_description` | Description of the error. |\n| `tracking` | Identifier used by Auth0 to find errors in internal logs. |\n\nParameters presented vary depending on the error type and are specific to the request. For example, if the request did not contain a `client_id` and resulted in an error, no client ID will be returned by the error page.\n\n## Learn more\n\n*   [Customize Error Pages](https://auth0.com/docs/customize/login-pages/custom-error-pages)\n*   [Brand: Emails and Error Pages](https://auth0.com/docs/videos/get-started-series/brand-emails-and-error-pages)",
  "title": "Default Auth0 Error Page",
  "description": "Describes the default Auth0 error page display information and parameters used for authorization error events.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/progressive-profiling",
  "markdown": "# Understand How Progressive Profiling Works\n\nProgressive profiling is the process of incrementally collecting additional information about your users as they engage with your website or application. You can gather detailed user information only when relevant to a user's activities.\n\nFor example, you could collect the user's name, email, and password during signup, then ask them for the name of their company and their job title the next time they log in.\n\nImplementing progressive profiling improves your users' experience by:\n\n*   Shortening registration forms.\n    \n*   Avoiding repetitive questions.\n    \n*   Collecting more relevant information.\n    \n*   Increasing conversion rates.\n    \n\n## How it works\n\nEvery time a user authenticates through Auth0, Auth0 updates their user profile. The data used to update their profile can come from different sources:\n\n*   Attributes supplied by the IdP.\n    \n*   Attributes created dynamically with [Auth0 Actions](https://auth0.com/docs/customize/actions).\n    \n*   Attributes returned from calling APIs such as [FullContact](https://www.fullcontact.com/) and [Clearbit](https://clearbit.com/).\n    \n*   Attributes managed by the application.\n    \n\n## Use action triggers\n\nWith the `post-login` action trigger, you can modify a user's `user_metadata` and `app_metadata` fields during the login flow. This is useful for tasks such as storing application-specific data on the user's profile, recording whether or not specific operations have occurred for a user, or caching the results of expensive operations on the user profile so they can be re-used for future logins. To learn more, read [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata).\n\n## Use the Management API\n\nYou can use the Auth0 Management API [Update a User](https://auth0.com/docs/api/management/v2/#!/Users/patch_users_by_id) endpoint to update the profile data of an authenticated user, including the `app_metadata` and `user_metadata` fields. To learn more, read [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api).\n\n## Use the Lock library\n\nYou can use the `additionalSignUpFields` option to add custom fields to user signup forms. When a user enters data into a custom field, Auth0 stores the value in their profile's `user_metadata` field. To learn more, read [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration#additionalsignupfields-array-).\n\n## Learn more\n\n*   [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata)\n*   [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata)",
  "title": "Understand How Progressive Profiling Works",
  "description": "Understand how progressive profiling can gather information about users over time as they engage with your website or application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/sample-user-profiles",
  "markdown": "# Sample User Profiles\n\n## Google User Profile\n\nThis is a sample user profile from a user that logged in through **Google**:\n\n```\n{\n  \"email\": \"johnfoo@gmail.com\",\n  \"email_verified\": true,\n  \"family_name\": \"Foo\",\n  \"gender\": \"male\",\n  \"given_name\": \"John\",\n  \"identities\": [\n    {\n      \"provider\": \"google-oauth2\",\n      \"user_id\": \"103547991597142817347\",\n      \"connection\": \"google-oauth2\",\n      \"isSocial\": true\n    }\n  ],\n  \"locale\": \"en\",\n  \"name\": \"John Foo\",\n  \"nickname\": \"FooJon\",\n  \"picture\": \"https://lh4.googleusercontent.com/-OdsbOXom9qE/AAAAAAAAAAI/AAAAAAAAADU/_j8SzYTOJ4I/photo.jpg\",\n  \"user_id\": \"google-oauth2|103547991597142817347\"\n}\n```\n\n## Microsoft Account User Profile\n\nThis is a sample profile from **Microsoft Account**:\n\n```\n{\n  \"email\": \"bobdoe@outlook.com\",\n  \"email_verified\": true,\n  \"emails\": [\n    \"bobdoe@outlook.com\",\n    \"bobdoe@outlook.com\"\n  ],\n  \"family_name\": \"Doe\",\n  \"given_name\": \"Bob\",\n  \"identities\": [\n    {\n      \"provider\": \"windowslive\",\n      \"user_id\": \"4cf0a30169d55031\",\n      \"connection\": \"windowslive\",\n      \"isSocial\": true\n    }\n  ],\n  \"locale\": \"en_US\",\n  \"name\": \"Bob Doe\",\n  \"nickname\": \"doebob@outlook.com\",\n  \"picture\": \"https://secure.gravatar.com/avatar/c89b2bb92df91508e14172097a5e17da?s=480&r=pg&d=https%3A%2F%2Fssl.gstatic.com%2Fs2%2Fprofiles%2Fimages%2Fsilhouette80.png\",\n  \"user_id\": \"windowslive|4cf0a30169d55031\"\n}\n```\n\n## Office 365 User Profile\n\nThis is a sample profile from **Office 365 (Microsoft Azure Active Directory)**:\n\n```\n{\n  \"email\": \"jeff@foo.onmicrosoft.com\",\n  \"family_name\": \"Jeff\",\n  \"given_name\": \"Beth\",\n  \"identities\": [\n    {\n      \"user_id\": \"10030000838D23AF@MicrosoftOnline.com\",\n      \"provider\": \"office365\",\n      \"connection\": \"foo-onmicrosoft\",\n      \"isSocial\": false\n    }\n  ],\n  \"name\": \"Jeff Beth\",\n  \"nickname\": \"jeff@auth0.onmicrosoft.com\",\n  \"picture\": \"https://secure.gravatar.com/avatar/a7f86ddd090d5a4cb833b97baab2aca1?s=480&r=pg&d=https%3A%2F%2Fssl.gstatic.com%2Fs2%2Fprofiles%2Fimages%2Fsilhouette80.png\",\n  \"tenantid\": \"75696069-df44-4310-9bcf-08b45e3007c9\",\n  \"upn\": \"jeff@foo.onmicrosoft.com\",\n  \"user_id\": \"office365|10030000838D23AF@MicrosoftOnline.com\"\n}\n```\n\n## ADFS User Profile\n\nThis is a sample profile from **ADFS (Active Directory Federation Services)**:\n\n```\n{\n  \"email\": \"john@fabrikam.com\",\n  \"family_name\": \"Fabrikam\",\n  \"email_verified\": false,\n  \"given_name\": \"John\",\n  \"identities\": [\n    {\n      \"user_id\": \"john@fabrikam.com\",\n      \"provider\": \"adfs\",\n      \"connection\": \"auth10.com\",\n      \"isSocial\": false\n    }\n  ],\n  \"issuer\": \"https://adfs.fabrikam.com\",\n  \"name\": \"John Fabrikam\",\n  \"nickname\": \"john\",\n  \"picture\": \"https://secure.gravatar.com/avatar/5426f6b9d63ad92d60e6fe9fdf83aa21?s=480&r=pg&d=https%3A%2F%2Fssl.gstatic.com%2Fs2%2Fprofiles%2Fimages%2Fsilhouette80.png\",\n  \"user_id\": \"adfs|john@fabrikam.com\"\n}\n```\n\nWas this article helpful?",
  "title": "Sample User Profiles",
  "description": "Examples of user profiles.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes",
  "markdown": "# User Profile Root Attributes\n\nAuth0's normalized user profile contains a number of root attributes (attributes stored at the first, or root, level of the object), some of which may be updated. To learn more about the user profile structure and its attributes, read [User Profile Structure.](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure)\n\nMethods for updating root attributes vary depending on connection type.\n\n## Auth0 as the identity provider\n\nWhen Auth0 is the Identity Provider (IdP), subscribers may:\n\n*   Set root attributes [on user sign-up](https://auth0.com/docs/api/management/guides/users/set-root-attributes-user-signup) (via the Management API or via public signup) or [on import](https://auth0.com/docs/api/management/guides/users/set-root-attributes-user-import)\n    \n*   [Update root attributes individually](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) via the Management API\n    \n\nAuth0 is the IdP for the following connection types:\n\n*   [Regular database connections](https://auth0.com/docs/connections/database)\n    \n*   [Custom database connections](https://auth0.com/docs/connections/database/custom-db) with import mode\n    \n*   [Passwordless connections](https://auth0.com/docs/connections/passwordless)\n    \n\n## Upstream identity providers\n\nWhen an upstream IdP (like Google or Facebook) is used, subscribers have two options:\n\n*   The upstream IdP sets the root attributes when users are first created and then automatically updates them with each subsequent login. This is the default behavior.\n    \n*   The upstream IdP sets the root attributes on user creation only and does not update them on subsequent logins, thereby allowing subscribers to [update root attributes individually](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) via the Management API. To enable this, you will need to [configure your connection sync with Auth0](https://auth0.com/docs/api/management/guides/connections/configure-connection-sync).\n    \n\nUpstream Identity Providers handle the following connection types:\n\n*   [Social connections](https://auth0.com/docs/connections#social)\n    \n*   [Enterprise connections](https://auth0.com/docs/connections#enterprise)\n    \n*   [Legal identity connections](https://auth0.com/docs/connections#legal-identities)",
  "title": "User Profile Root Attributes",
  "description": "Learn about root attributes available for the Auth0 normalized user profile and methods of updating them.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema",
  "markdown": "# Normalized User Profile Schema\n\nThe attributes that Auth0 maps to a common schema are listed below.\n\nFields that are always generated:\n\n*   `**name**`: the user's full name.\n    \n*   `**nickname**`: by default, the local part of the user's email.\n    \n*   `**picture**`: the URL of the [user's picture](https://auth0.com/docs/manage-users/user-accounts/change-user-picture). If unavailable, Auth0 uses the Gravatar image associated with the user's email address.\n    \n*   `**user_id**`: the user's unique identifier. This is unique per Connection, but the same for all apps that authenticate via that Connection.\n    \n\nBy default, a user's `name`, `nickname`, and `picture` attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable since they are updated from the identity provider each time a user logs in. If you want to be able to edit these attributes, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. Root attributes will then be available to be [edited individually](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) or [by bulk import](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) using the Management API.\n\nFields that are generated when the details are available:\n\n*   `**email**`: the user's email address.\n    \n*   `**email_verified**`: a boolean indicating if the user's email address has been verified.\n    \n*   `**given_name**`: the user's first name.\n    \n*   `**family_name**`: the user's last name.\n    \n\nWhen creating a user with the [Create a User Management API endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_users) you can submit the `given_name` and `family_name`. By default, a user's `given_name` and `family_name` attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable since they are updated from the identity provider each time a user logs in. If you want to be able to edit these attributes, you must [configure your connection sync with Auth0](https://auth0.com/docs/dashboard/guides/connections/configure-connection-sync) so that user attributes will be updated from the identity provider only on user profile creation. Root attributes will then be available to be [edited individually](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) or [by bulk import](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) using the Management API\n\nIf you are writing a login script for a [custom database](https://auth0.com/docs/connections/database/mysql) you are responsible for returning the information in the user profile. A unique and immutable `user_id` property is mandatory to correctly identify the user (see [Uniquely Identify Users](https://auth0.com/docs/manage-users/user-accounts/identify-users)).\n\n## Additional Attributes\n\nThe User Profile includes an array of identities. In the most common case (logging in with a single provider), the array contains only one element. If the user has multiple accounts linked, the array will have an element for each associated account. See [User Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking) for more information.\n\nThe `identities` array contains the following attributes:\n\n*   `connection`: the name of the connection.\n    \n*   `isSocial`: indicates if the provider is a Social provider.\n    \n*   `provider`: the provider of the connection.\n    \n*   `user_id`: the unique identifier of the user for this connection.\n    \n\nAuth0 passes all other properties supplied by the identity provider to your app, even if they are not mapped to the standard attributes listed above.",
  "title": "Normalized User Profile Schema",
  "description": "Normalized User Profile schema reference.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/verified-email-usage",
  "markdown": "# Use Verified Email in User Profiles\n\nThe `email_verified` field of a user profile indicates whether the user has verified their email address. Email verification is optional, but valid email addresses are required for certain actions, such as sending email communications, password reset/recovery links, and passwordless magic links to users.\n\nAn email is usually verified immediately after the user account is created or when the user logs in to the application for the first time. It's a good way to know that the person signing up actually owns the email at that moment.\n\nSince email verification happens once at that specific moment, we can't ensure that a person who logs in with the user account at a later time still owns the email address that was verified.\n\nIn case of federated identity providers, they sometimes report if the user has a verified email, and based on that, Auth0 sets the `email_verified` field in the user profile. This, however, transfers the responsibility to the identity provider to do it properly - something we can't ensure. We also don't know if the verified email from that provider is still owned by the user.\n\nFor all of these reasons, we need to be careful on what we can assume based on a verified email.\n\n## When does Auth0 set emails as verified?\n\nWhen users signup with email and password, they get a verification email with a link. When they click the link, Auth0 verifies their email. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nWhen users authenticate with a federated identity provider (e.g. a social or enterprise connection), the value of the `email_verified` field will match what the identity provider returns in the user profile. If they identity provider does not return any value, it will be set to `false`.\n\n## Verified Emails and Account Linking\n\nWhen you want to [link two user accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking), you need to make sure that the user still has access to both accounts. The only way to achieve that is to have users authenticate with both accounts before linking them.\n\nYou **should not automatically link accounts based on the user's emails**. Always prompt users to authenticate again before doing that. This will prevent scenarios like:\n\n*   John Doe, an employee of Travel0, signs up to a site using his corporate email `john.doe@travel0.com` and a password. Months later, John Doe leaves Travel0, and a new John Doe is hired, with the same email account. That person goes to the same website, and authenticates with his corporate identity provider (such as Google Workspace), and gets the account automatically linked to the other user.\n    \n*   Federated identity providers can make mistakes on how they handle email verification and can report that users own an email they do not.\n    \n\nOn the other hand, we recommend you to still check for the `email_verified` field before performing account linking, to mitigate scenarios like:\n\n*   An attacker creates a Google account `attacker@gmail.com`.\n    \n*   Attacker creates a new database users with the victim's email (e.g. `victim@hotmail.com`).\n    \n*   Attacker links both accounts.\n    \n*   Attacker sends a phishing attack to victim.\n    \n*   The victim tries to sign-up, they are told the user already exists and get offered to reset the password.\n    \n*   The user enters their password and logs into the attacker's account, which now has access to whatever data the victim enters in the application.\n    \n\nIn the same way that you can't fully trust the email, you can't fully trust the email domain either.\n\nIf your application needs to restrict access based on the user's employer, the fact that a user is logged in with an email from a specific corporate domain does not guarantee that it should be granted access.\n\nFor example:\n\n*   If your application allows customers to sign up for new accounts, and employees from different companies authenticate using their corporate credentials, a user that signs up with a `user@acme.com` account shouldn't be granted access to the same feature set that a user authenticating with acme.com's corporate directory.\n    \n*   If your application supports authenticating with Azure AD, and the directory supports guest users, you can get users from any domain logging-in from that Azure AD tenant. You should not give guest users the same access level as the rest of the users authenticating with that tenant.\n    \n\nAs a general recommendation, **you should not use the email's domain to make authorization decisions**. If you need to check if the user belongs to a specific organization, it's better to rely on the connection they used to authenticate, or in connection-specific attributes like the Azure AD's tenant id.\n\n## Learn more\n\n*   [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n*   [User-Initiated Account Linking: Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)",
  "title": "Use Verified Email in User Profiles",
  "description": "Outlines proper usage of the email_verified field in a user profile.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-android/auth0-android-login-logout-and-user-profiles",
  "markdown": "# Auth0.Android Login, Logout, and User Profiles\n\n## Add login to your Android application\n\nYou can log the user in using the `WebAuthProvider.login` method:\n\n```\nWebAuthProvider.login(account)\n  .withScheme(getString(R.string.com_auth0_scheme))\n  .withScope(\"openid profile email\")\n  .start(this, object : Callback<Credentials, AuthenticationException> {\n    override fun onFailure(exception: AuthenticationException) {\n       // Authentication failed\n     }\n\n      override fun onSuccess(credentials: Credentials) {\n         // Authentication succeeded\n       }\n  })\n```\n\nThe authentication result will be delivered to the `onSuccess` callback.\n\nSee the [Auth0.Android configuration](https://auth0.com/docs/libraries/auth0-android/auth0-android-configuration) for more options for the `WebAuthProvider` class.\n\n## Add logout to your Android application\n\nTo log the user out, call the `WebAuthProvider.logout` method. The result of logout will be supplied in the `onSuccess` callback.\n\nThis method removes the cookie that the browser set at authentication time, so it forces users to re-enter their credentials the next time they try to authenticate.\n\n```\nWebAuthProvider.logout(account)\n  .withScheme(\"demo\")\n  .start(this, object: Callback<Void?, AuthenticationException> {\n    override fun onSuccess(payload: Void?) {\n      // The user has been logged out!\n    }\n\n    override fun onFailure(error: AuthenticationException) {\n      // Something went wrong!\n    }\n  })\n```\n\n## Show the user's profile\n\nUse the `AuthenticationAPIClient` class to retrieve the user's profile from Auth0. This requires:\n\n*   The access token as received during the login phase\n    \n*   The `profile` scope to include when `WebAuthProvider.login` is called\n    \n*   The `email` scope (if you want to retrieve the user's email address)\n    \n\nThis sample demonstrates a function that retrieves the user's profile and displays it on screen:\n\n```\nvar client = AuthenticationAPIClient(account)\n\n// Use the received access token to call `userInfo` and get the profile from Auth0.\nclient.userInfo(accessToken)\n  .start(object : Callback<UserProfile, AuthenticationException> {\n      override fun onFailure(exception: AuthenticationException) {\n          // Something went wrong!\n      }\n\n      override fun onSuccess(profile: UserProfile) {\n        // We have the user's profile!\n        val email = profile.email\n        val name = profile.name\n      }\n})\n```",
  "title": "Auth0.Android Login, Logout, and User Profiles",
  "description": "Learn how to add login, log out and read the user profile using the Android SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0",
  "markdown": "# Configure Identity Provider Connection for User Profile Updates\n\nYou can update connection preferences for an upstream identity provider so you can control when updates to user profile root attributes are allowed using the Auth0 Dashboard or the Management API.\n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the name, nickname, given\\_name, family\\_name, or picture root attributes on the normalized user profile, you must configure your connection sync with Auth0 so that user attributes will be updated from the identity provider only on user profile creation.\n\nYou can edit [root attributes individually](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/update-root-attributes-for-users) or as a [bulk import](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/set-root-attributes-during-user-import) using the Management API.\n\n## Use the Dashboard\n\n1.  Go to [Auth0 Dashboard > Authentication](https://manage.auth0.com/#/connections), and select the type of connection: Database, Social, Enterprise, or Passwordless.\n    \n2.  Select the name of a connection to see its settings.\n    \n3.  Locate the **Advanced** section, toggle the **Sync user profile attributes at each login** switch to the desired setting, and select **Save**.\n    \n    ![Dashboard - Authentication - Settings - Sync User Profile Attributes](https://images.ctfassets.net/cdy7uua7fh8z/4V2iUSkyaOMlXtHEACoVuW/b12b6c62fcc60371bd75d224229a6614/dashboard-connections-social-create_enter-details.png)\n\n## Use the Management API\n\nBefore completing this step, you should first [retrieve the existing values of the connection's `options` object](https://auth0.com/docs/authenticate/identity-providers/retrieve-connection-options) to avoid overriding the current values. If you do not, parameters missing from the original object will be lost after you update.\n\nMake a `PATCH` call to the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). Make sure you include the original options values in the call to avoid overriding the current values. Also, be sure to replace `CONNECTION_ID`, `MGMT_API_ACCESS_TOKEN`, and `ATTRIBUTE_UPDATE_VALUE` placeholder values with your connection ID, Management API access token, and attribute update value, respectively.\n\n*   [cURL](#fbba7651386a4341a2d0b7040538c164_shell)\n*   [C#](#fbba7651386a4341a2d0b7040538c164_csharp)\n*   [Go](#fbba7651386a4341a2d0b7040538c164_go)\n*   [Java](#fbba7651386a4341a2d0b7040538c164_java)\n*   [Node.JS](#fbba7651386a4341a2d0b7040538c164_node)\n*   [Obj-C](#fbba7651386a4341a2d0b7040538c164_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{\"options\":{\"set_user_root_attributes\": \"ATTRIBUTE_UPDATE_VALUE\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\"\n\n\tpayload := strings.NewReader(\"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {options: {set_user_root_attributes: 'ATTRIBUTE_UPDATE_VALUE'}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"set_user_root_attributes\": @\"ATTRIBUTE_UPDATE_VALUE\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"options\": [\"set_user_root_attributes\": \"ATTRIBUTE_UPDATE_VALUE\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `CONNECTION_ID` | ID of the connection for which you want to allow updates to root attributes. |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/api/management/v2/tokens) with the scope `update:connections`. |\n| `ATTRIBUTE_UPDATE_VALUE` | Indicates when you want to allow updates to user profile root attributes. Valid values are `on_first_login` and `on_each_login`. Defaults to `on_each_login` for new connections. |\n\n## Learn more\n\n*   [Retrieve Connection Options](https://auth0.com/docs/authenticate/identity-providers/retrieve-connection-options)\n*   [Set Root Attributes During User Import](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/set-root-attributes-during-user-import)\n*   [Set Root Attributes During User Signup](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/set-root-attributes-during-user-sign-up)\n*   [Update Root Attributes for Users](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/update-root-attributes-for-users)\n*   [Promote Connections to Domain Level](https://auth0.com/docs/authenticate/identity-providers/promote-connections-to-domain-level)",
  "title": "Configure Identity Provider Connection for User Profile Updates",
  "description": "Learn how to update connection preferences for an upstream identity provider so you can control when user profile root attributes are updated.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/update-user-profiles-using-your-database",
  "markdown": "# Update User Profiles Using Your Database\n\nUpdate user profiles when [using your own database as an identity provider](https://auth0.com/docs/connections/database/custom-db) by doing the following tasks:\n\n*   Use the [Management API](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id).\n    \n*   Update the user in your database.\n    \n*   [Configure user migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) from your database to Auth0.\n    \n\n## Update users with the Management API\n\nWhen using your own database for authentication, you can use the [Management API](https://auth0.com/docs/api/management/v2) to update the following fields:\n\n*   `app_metadata`\n    \n*   `user_metadata`\n    \n*   `blocked`\n    \n\nIf you need to update other user fields, you will need to do it directly in your database.\n\n## Update users in your database\n\nYou can update user profiles in your database as you normally do, and Auth0 will update its cached user profile the next time that user logs in.\n\nThe user profile in the custom database can be implemented with any user profile structure, but you need to map it in the Login call to the Auth0 normalized user profile attributes as shown in the \"Login\" custom database template.\n\nAccess the custom database templates are accessed via Connections -> Database -> Custom Database. Be sure to turn on the \"Use my own database\" toggle to enable editing the scripts.\n\nSee the [User profile cache](#user-profile-cache) section below for a brief overview of how Auth0 caches user profiles.\n\n## Update users through migration\n\nIf you have [enabled user migration](https://auth0.com/docs/connections/database/migrating), and a user has already been migrated to the Auth0 database, then Auth0 will not query your database again for the user profile. Therefore, all changes made in the custom database for that user will never reflect in Auth0.\n\nOnce a user has been migrated, you will also be able to update fields, such as `name`, `nickname`, `given_name`, `family_name`, `picture`, `email`, and `email_verified` via the Management API.\n\nHowever, rules for updating other user fields will still apply as described in the [Normalized User Profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles).\n\n## User profile cache\n\nAuth0 caches the user profile received from a [database connection](https://auth0.com/docs/connections/database) before sending it to the client application. This cache is stored in the Auth0 database and is refreshed each time the user authenticates.\n\nThe cached values for the [Normalized User Profile](https://auth0.com/docs/users/normalized/auth0/normalized-user-profile-schema) fields are based on the values returned from the Login Script of your custom database connection.\n\nThe User Profile is cached for several reasons. First, caching allows you the option of implementing [Single Sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on) at the Auth0 layer to avoid going to the connection for every request. Additionally, this provides resilience if a connection is temporarily unavailable.\n\n## Learn more\n\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)",
  "title": "Update User Profiles Using Your Database",
  "description": "Learn how to update user profiles when using your own database as an identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules",
  "markdown": "# Manage Metadata with Rules\n\nYou can read, update, and delete metadata using [Auth0 Rules](https://auth0.com/docs/customize/rules). In the following sections, we will refer to this example where the user and their information is represented by the following JSON snippet:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\"\n    }\n  }\n}\n```\n\n## Read metadata\n\nYou can read metadata using rules with the Management API. You can also search for profile-related information in `user_metadata`, such as:\n\n*   `name`\n    \n*   `nickname`\n    \n*   `given_name`\n    \n*   `family_name`\n    \n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the `name`, `nickname`, `given_name`, `family_name`, or `picture` root attributes on the normalized user profile, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. These root attributes will then be available to be edited individually or by bulk imports\n\nAs an example, assume the following metadata is stored for a user with the email address `jane.doe@example.com`:\n\n```\n{\n    \"email\": \"jane.doe@example.com\",\n    \"user_metadata\": {\n        \"hobby\": \"surfing\"\n    },\n    \"app_metadata\": {\n        \"plan\": \"full\"\n    }\n}\n```\n\nUsing the example metadata above, you can refer to specific items from the dataset in [Auth0 Rules](https://auth0.com/docs/customize/rules) or via a call to the [Management API](https://auth0.com/docs/users/guides/manage-user-metadata) as follows:\n\n```\nconsole.log(user.email); // \"jane.doe@example.com\"\nconsole.log(user.user_metadata.hobby); // \"surfing\"\nconsole.log(user.app_metadata.plan); // \"full\"\n```\n\nAny valid JSON snippet can be used as metadata, but note that `user.app_metadata` is `Undefined` by default.\n\nTo read the available metadata, you will need to access the correct user property.\n\n### Read app metadata\n\nYou can make a decision based on the user's roles:\n\n```\nfunction(user, context, callback){\n  user.app_metadata = user.app_metadata || {};\n  if (user.app_metadata.roles.indexOf('writer')){\n    // code to be executed\n  }\n  ...\n}\n```\n\n### Read user metadata\n\nYou can base decisions on specific preferences, such as a color preference:\n\n```\nfunction(user, context, callback){\n  user.user_metadata = user.user_metadata || {};\n  if (user.user_metadata.preferences.color === 'black'){\n    // code to be executed\n  }\n  ...\n}\n```\n\n### Read application metadata (clientMetadata)\n\nApplication metadata (`clientMetadata`) is an optional, top-level property of the `context` object. Existing applications will have no value for this property.\n\n```\nfunction(user, context, callback){\n  context.clientMetadata = context.clientMetadata || {};\n  if (context.clientMetadata.usersuppliedkey1 === 'black'){\n    // this code would not be executed for the user\n  }\n  ...\n}\n```\n\n## Update metadata\n\n### Update app metadata\n\nTo add an administrative role to the user:\n\n```\nfunction(user, context, callback){\n  user.app_metadata = user.app_metadata || {};\n  // update the app_metadata that will be part of the response\n  user.app_metadata.roles = user.app_metadata.roles || [];\n  user.app_metadata.roles.push('administrator');\n\n  // persist the app_metadata update\n  auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile details:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\", \"administrator\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\"\n    }\n  }\n}\n```\n\n### Update user metadata\n\nTo add the user's `fontSize` preference to the user profile:\n\n```\nfunction(user, context, callback){\n  user.user_metadata = user.user_metadata || {};\n  // update the user_metadata that will be part of the response\n  user.user_metadata.preferences = user.user_metadata.preferences || {};\n  user.user_metadata.preferences.fontSize = 12;\n\n  // persist the user_metadata update\n  auth0.users.updateUserMetadata(user.user_id, user.user_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile details:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\",\n      \"fontSize\": 12\n    }\n  }\n}\n```\n\n### Update app and user metadata simultaneously\n\nTo reduce the rule's processing time, you may update both the `app_metadata` and `user_metadata` in the same rule:\n\n```\nfunction(user, context, callback){\n\n  var q = require('q');\n\n  user.app_metadata = user.app_metadata || {};\n  user.user_metadata = user.user_metadata || {};\n  // update the user_metadata that will be part of the response\n  user.user_metadata.preferences = user.user_metadata.preferences || {};\n  user.user_metadata.preferences.fontSize = 12;\n\n  // update the app_metadata that will be part of the response\n  user.app_metadata.roles = user.app_metadata.roles || [];\n  user.app_metadata.roles.push('admin');\n\n  // persist the app_metadata update\n  var appMetadataPromise  = auth0.users.updateAppMetadata(user.user_id, user.app_metadata);\n\n  // persist the user_metadata update\n  var userMetadataPromise = auth0.users.updateUserMetadata(user.user_id, user.user_metadata);\n\n  // using q library to wait for all promises to complete\n  q.all([userMetadataPromise, appMetadataPromise])\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile details:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\", \"admin\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\",\n      \"fontSize\": 12\n    }\n  }\n}\n```\n\n## Delete metadata\n\n### Delete app metadata properties and values\n\nTo delete a property, set the property's value to `null`.\n\n#### Delete user's roles example\n\nTo delete the user's roles, use the following sample rule:\n\n```\nfunction(user, context, callback){\n  user.app_metadata = user.app_metadata || {};\n  // update the app_metadata that will be part of the response\n  user.app_metadata.roles = null;\n\n  // persist the app_metadata update\n  auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": { },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\"\n    }\n  }\n}\n```\n\n#### Delete single property value example\n\nTo delete a single value of a property, remove that specific value. For example, to remove the `writer` role from the user profile:\n\n```\nfunction(user, context, callback){\n  user.app_metadata = user.app_metadata || {};\n  user.app_metadata.roles = user.app_metadata.roles || [];\n\n  var index = user.app_metadata.roles.indexOf('writer');\n\n  if (index !== -1){\n    // update the app_metadata that will be part of the response\n    user.app_metadata.roles.splice(index, 1);\n  }\n\n  // persist the app_metadata update\n  auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile:\n\n```\n{\n  \"user_id\": \"google-oauth2|1234\",\n  \"email\": \"john.doe@gmail.com\",\n  \"app_metadata\": {\n    \"roles\": [ ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\"\n    }\n  }\n}\n```\n\nNote that the `roles` property still exists but does not contain any value.\n\n### Delete user metadata properties and values\n\nTo delete the user's color preference:\n\n```\nfunction(user, context, callback){\n  user.user_metadata = user.user_metadata || {};\n  // update the user_metadata that will be part of the response\n  user.user_metadata.preferences = user.user_metadata.preferences || {};\n  delete user.user_metadata.preferences.color;\n\n  // persist the user_metadata update\n  auth0.users.updateUserMetadata(user.user_id, user.user_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n  });\n}\n```\n\nThis results in the following JSON representation of the user profile details:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": { }\n  }\n}\n```\n\n## Learn more\n\n*   [Use the Management API from within Rules](https://auth0.com/docs/customize/rules/use-management-api)\n*   [Context Object Properties in Rules](https://auth0.com/docs/customize/rules/context-object)\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)",
  "title": "Manage Metadata with Rules",
  "description": "Learn how to manage with app metadata, user metadata, and client metadata using Rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/tenants/patch-settings",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/clients/get-clients-by-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/tenants/tenant-settings-route",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/authenticate/login/logout/back-channel-logout",
  "markdown": "# OIDC Back-Channel Logout\n\nAuth0 supports the [OpenID Connect Back-Channel Logout 1.0 specification](https://openid.net/specs/openid-connect-backchannel-1_0.html#Backchannel) in all tenants with an Enterprise plan subscription.\n\nThis specification leverages the session ID (`sid`) included in ID tokens and the Logout Tokens to coordinate session termination via back-channel communication. Different session IDs represent individual sessions of a user agent or device in your tenant. Logout Tokens identify the end-user and session to logout.\n\n## Back-channel communications\n\nTo use Back-Channel Logout, an application must expose a Back-Channel Logout URI, reachable from the tenant server, where the application expects to receive the requests with the Logout Token. When an application receives this request, it is compelled to clear the local session state matching the claims in the token.\n\n### Tokens in OIDC Back-Channel Logout communications\n\nApplications cannot rely on session cookies to determine which session to terminate when communications are performed via the back-channel. Rather, the service depends on a shared session identifier (`sid`) on ID and Logout Tokens.\n\nWhen end-users successfully authenticate with Auth0 during login, the authorization server assigns an access, ID, and Logout Token. The ID and Logout Token contain the claims your application needs in the Back-Channel Logout workflow. To learn more about claims, read [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims).\n\n![Workflow for back-channel logout](https://images.ctfassets.net/cdy7uua7fh8z/5jQ5HogFNeD9tqUGEJuJHE/663f1f52b285f7019fd1157f5a26caf0/2023-09-29_09-32-00.png)\n\n1.  Login - During user authentication, the Auth0 tenant adds the `sid` to the ID token.\n    \n2.  Login - The application stores the received session identifier in its own session store and associates it with the application-specific session.\n    \n3.  Logout - The IdP calls the pre-registered logout callback URL and posts the Logout Token to this endpoint. The token contains the `user_id` (`sub`) and the `sid` along with other parameters.\n    \n4.  Logout - The application’s backend needs to validate the Logout Token as per OIDC spec and extract the `sid`. Then the backend can use this token to find the session associated with the identifier and terminate it as necessary.\n    \n\n### How it works\n\nThe sample use case demonstrates how Back-Channel Logout works with more than one application:\n\n![Back-channel logout multiple app use case](https://images.ctfassets.net/cdy7uua7fh8z/54mbNobsvLec0A2tz0DXUG/99ce79c9e93ffe526472d6250373778c/2023-06-20_09-39-12.png)\n\n1.  During application configuration, Application A registers a Back-Channel Logout URI with Auth0.\n    \n2.  During application configuration, Application B registers a Back-Channel Logout URI with Auth0.\n    \n3.  During end-user login, a user authenticates with Auth0 to access Application A.\n    \n4.  Auth0 sends an ID token with `sid` to Application A. To learn more, read [ID Token Structure](https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure).\n    \n5.  User authenticates with Auth0 to access Application B.\n    \n6.  Auth0 sends an ID token with the same `sid` to Application B. Your application should store the session information.\n    \n7.  During logout, Application A or other entities initiate logout on the front-channel.\n    \n8.  Auth0 terminates the Auth0 session layer via session cookie.\n    \n9.  Auth0 calls Application A’s Back-Channel Logout URI and posts the Logout Token.\n    \n10.  Application A validates the Logout Token and terminates the session.\n    \n11.  Auth0 calls Application B’s Back-Channel Logout URI and posts the Logout Token.\n    \n12.  Application B validates the Logout Token and terminates the session.\n    \n\n#### Sample token\n\nYour application must be able to parse and validate JWTs to use as Logout Tokens with Auth0. To learn more, read [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens). \n\nOnce your application validates and decodes your token, the contents are similar to the example below:\n\n```\n{\n  \"iss\": \"https://artex-dev.eu.auth0.com/\",\n  \"sub\": \"auth0|602e93db83fa6f00749a23e6\",\n  \"aud\": \"TuhNLv7ulXD3RfyLlSMbOvszzwJJFPpO\",\n  \"iat\": 1698160928,\n  \"exp\": 1698161048,\n  \"jti\": \"44a91215-dfb4-4dfe-a1eb-fcafa911deba\",\n  \"events\": {\n    \"http://schemas.openid.net/event/backchannel-logout\": {}\n  },\n  \"trace_id\": \"81b336a94a4a5707\",\n  \"sid\": \"375UIp_ID5mCTClIeBEHpXfGwq51tF_L\"\n}\n```\n\n### Auth0 SDKs\n\nA full example and production code is already included under the **Back-Channel Logout Example** section of our [express-openid-connect SDK](https://github.com/auth0/express-openid-connect/blob/master/EXAMPLES.md#11-back-channel-logout).\n\n## Implementation examples\n\n### Session storage\n\nThe session storage example is built in Node (Express) and based on the [Express OpenID Connect Web App Sample](https://github.com/auth0-samples/auth0-express-webapp-sample/tree/master/01-Login).\n\nIn your application sessions tab, expose the route you configured to receive the Logout Token. Validate the token and terminate the user session.\n\n**routes/index.js**\n\n```\nconst express = require('express');\nconst router = express.Router();\nconst { requiresAuth } = require('express-openid-connect');\n\n// middleware to validate the logout token\nconst requiresValidLogoutToken = require('../middlewares/validateLogoutToken');\n\n// helper function to delete user sessions\nconst deleteUserSessions = require('../utils/sessions');\n\n// new route to receive backchannel logout tokens\n// must be configured in the Application -> Sessions tab \n// in the Auth0 Management Dashboard\nrouter.post(\n  '/backchannel-logout',\n  requiresValidLogoutToken,\n  function (req, res, next) {\n    // at this point the logout token is valid, checked by requiresValidLogoutToken middleware\n    // you can access it from the request object: req.logoutToken\n\n    // delete user session so the user gets logged out\n    deleteUserSessions(\n      req.app.locals.sessionStore,\n      req.logoutToken.sub,\n      req.logoutToken.sid\n    );\n\n    res.sendStatus(200);\n  }\n);\n\nrouter.get('/', function (req, res, next) {\n  res.render('index', {\n    title: 'Auth0 Webapp sample Nodejs',\n    isAuthenticated: req.oidc.isAuthenticated(),\n    headline: process.env.APP_NAME,\n    backgroundColor: process.env.BACKGROUND_COLOR,\n    baseURL: process.env.BASE_URL,\n  });\n});\n\nrouter.get('/profile', requiresAuth(), function (req, res, next) {\n  res.render('profile', {\n    userProfile: JSON.stringify(req.oidc.user, null, 2),\n    title: 'Profile page',\n    headline: process.env.APP_NAME,\n    backgroundColor: process.env.BACKGROUND_COLOR,\n    baseURL: process.env.BASE_URL,\n  });\n});\n\nmodule.exports = router;\n```\n\n**middlewares/validateLogoutToken.js**\n\n```\n// This middleware validates the logout token as defined here:\n// https://openid.net/specs/openid-connect-backchannel-1_0.html#Validation\n\nconst jose = require('jose');\n\nasync function requiresValidLogoutToken(req, res, next) {\n\n  // get remote key set for token verification\n  const JWKS = jose.createRemoteJWKSet(\n    new URL(process.env.ISSUER_BASE_URL + '/.well-known/jwks.json')\n  );\n\n  const logoutToken = req.body.logout_token;\n\n  if (!logoutToken) {\n    res.status(400).send('Need logout token');\n  }\n\n  try {\n    const { payload, protectedHeader } = await jose.jwtVerify(\n      logoutToken,\n      JWKS,\n      {\n        issuer: process.env.ISSUER_BASE_URL + '/',\n        audience: process.env.CLIENT_ID,\n        typ: 'JWT',\n        maxTokenAge: '2 minutes',\n      }\n    );\n\n    // Verify that the Logout token contains a sub claim, a sid claim, or both\n    if (!payload.sub && !payload.sid) {\n      res\n        .status(400)\n        .send(\n          'Error: Logout token must contain either sub claim or sid claim, or both'\n        );\n    }\n\n    // Verify that the logout token contains an events claim\n    // whose value is a JSON object containing the member name http://schemas.openid.net/event/backchannel-logout\n    if (!payload.events['http://schemas.openid.net/event/backchannel-logout']) {\n      res\n        .status(400)\n        .send(\n          'Error: Logout token must contain events claim with correct schema'\n        );\n    }\n\n    // Verify that the Logout token does not contain a nonce claim.\n    if (payload.nonce) {\n      res\n        .status(400)\n        .send('Error: Logout token must not contain a nonce claim');\n    }\n\n    // attach valid logout token to request object\n    req.logoutToken = payload;\n\n    // token is valid, call next middleware\n    next();\n  } catch (error) {\n    res.status(400).send(`Error:  ${error.message}`);\n  }\n}\n\nmodule.exports = requiresValidLogoutToken;\n```\n\n### Logout token store\n\nA common approach for token storage is to define a logout store as an alternative to the session store model. Your application(s) keeps a collection of Logout Tokens in the persistence level. \n\nWherever the application wants to check its authentication status, it queries the Logout Token store to find if its session is still active. The logout store flushes obsolete information regularly to keep only the necessary information.\n\n![Logout Token Store](https://images.ctfassets.net/cdy7uua7fh8z/2zTtcie1d0fjiSuxZ4huyV/dbcf45fb68a045bd1b1918315f8025f7/image__21_.png)\n\n## Security considerations\n\nBack-Channel Logout Tokens are delivered over the internet, therefore the callback endpoints receiving them must follow the best practices to ensure reliable and secure operation. The recommendations list below is not exhaustive and you must always consider the specific deployment and operational situations to adapt accordingly. In the list below, any apps that handle the Back-Channel Logout Tokens are referenced as “apps”.\n\n*   Apps must have the ability to store the session ID (`sid` claim) received during user login in order to retrieve them later when receiving a Back-Channel Logout token.\n    \n*   Apps must verify any received tokens as per [JWT validation best practices](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens).\n    \n*   Apps must accept tokens issued only by trusted tenants. A malicious actor can attempt to send tokens issued by other Auth0 tenants - such attempts must be rejected.\n    \n*   Apps must accept tokens only when they contain a `sid` value (session ID) that the app recognizes. Tokens containing an invalid session ID (being it expired or unrecognized) must be rejected.\n    \n*   Apps must expose the callback endpoints only via TLS. Unencrypted communication channels are not recommended.\n    \n*   Apps are recommended to accept requests only from the published list of [outbound IP addresses](https://auth0.com/docs/secure/security-guidance/data-security/allowlist).\n    \n*   Apps are recommended to follow the general best practices in terms of monitoring, logging and rate limiting - however details of these are outside of scope of this document.\n    \n*   Apps are recommended to regularly clean stale or expired sessions.\n    \n*   Any changes in the endpoint address must be synchronised with the tenant configuration in order to ensure the Logout Tokens are always delivered to the correct Back-Channel Logout Callback URL.\n    \n\n## Learn more\n\n*   [Configure OIDC Back-Channel Logout](https://auth0.com/docs/authenticate/login/logout/back-channel-logout/configure-back-channel-logout)\n*   [Check Login and Logout Issues](https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)",
  "title": "OIDC Back-Channel Logout",
  "description": "Describes Auth0's OIDC Back-Channel Logout feature.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps",
  "markdown": "# Log Users Out of Identity Providers\n\nSome providers allow you to force a user to log out of their identity provider. Auth0 often accomplishes this by adding the `federated` query string parameter to the redirect at the `/oidc/logout` endpoint.\n\nTo do this, add a `federated` query string parameter to the logout URL:\n\n`https://{yourDomain}/oidc/logout?federated`\n\n## Federated logout support\n\nThe following identity providers support federated logout:\n\n*   Evernote\n    \n*   Facebook\n    \n*   Fitbit\n    \n*   GitHub\n    \n*   Google\n    \n    *   Apps\n        \n    *   OAuth 2.0\n        \n*   Microsoft\n    \n    *   Active Directory Federation Services\n        \n    *   Office 365\n        \n    *   Windows Azure Active Directory\n        \n    *   Windows Live\n        \n*   Salesforce/Salesforce Sandbox\n    \n*   X\n    \n*   Yahoo\n    \n*   Yammer\n    \n\n## Clear application session\n\nThe Auth0 Logout endpoint logs you out from Auth0 and, optionally, from your identity provider. It does not log you out of your application! This is something that you must implement on your side. You need to log out the user from your application by clearing their session.\n\n## Alternative logout\n\nTo add federated logout to the [alternative logout endpoint](https://auth0.com/docs/api/authentication#logout), add the `federated` query string parameter to the logout URL:\n\n`https://{yourDomain}/v2/logout?federated`\n\n### Alternative logout limitations\n\n*   No validation is performed on any URL provided as a value to the `returnTo` parameter, nor any query string or hash information provided as part of the URL.\n    \n*   The behavior of federated logouts with social providers is inconsistent. Each provider will handle the returnTo parameter differently and for some, it will not work. Please check your social provider's settings to determine how it will behave.\n    \n*   If you are working with social identity providers such as Google or Facebook, you must set your Client ID and Secret for these providers in the Dashboard for the logout to function properly.\n    \n*   If you are an Auth0 Enterprise user, you will typically have SSO enabled for multiple applications, for example, SharePoint, a few .NET applications, a few Java applications, Zendesk, etc. In this case, it's very common that when users sign out, this needs to happen for all of their applications.\n    \n\n## Learn more\n\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)",
  "title": "Log Users Out of Identity Providers",
  "description": "Describes how to force a user to log out of their identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-1",
  "markdown": "# Solution Overview (Mobile Apps + API)\n\nIn order to ensure that only authorized users and applications are allowed access to the Timesheets API, ExampleCo has decided to make use of the [OAuth 2.0 authorization framework](https://tools.ietf.org/html/rfc6749). The framework provides the flexibility the company wants since the different grants can allow them to easily authorize the various types of applications which need to communicate with the Timesheets API.\n\nAn API is a way to expose functionality of your application to other applications. An application can make a request by sending a message to an endpoint on an API and receive information as a response.\n\nAn API endpoint can be secured or not. In our case, since the timesheets are sensitive information that affect reviews and payments, it is important to ensure that only authorized users and applications can call the endpoints on our API. When a client application wants to access protected endpoints on an API, it needs to present an Access Token as proof that it has the required permissions for making the call to the endpoint.\n\nAn Access Token is obtained by authenticating the user with an Authorization Server and the user can then, in turn, authorize the application to access the API on their behalf.\n\n#### What is an Access Token?\n\nAn Access Token (also referred to as `access_token`) is an opaque string representing an authorization issued to the application. It may denote an identifier used to retrieve the authorization information or may self-contain the authorization information (for example, the user's identity, permissions, and so forth) in a verifiable manner.\n\nIt is quite common for Access Tokens to be implemented as [JSON Web Tokens](https://auth0.com/docs/tokens/concepts/jwts).\n\nFor more information on Auth0 Access Tokens refer to [Access Token](https://auth0.com/docs/tokens/concepts/access-tokens).\n\nAn API can enforce fine-grained control over who can access the various endpoints exposed by the API. These permissions are expressed as scopes.\n\nWhen a user authorizes a client application, the application can also indicate which permissions it requires. The user is then allowed to review and grant these permissions. These permissions are then included in the Access Token as part of the `scope` claim.\n\nSubsequently, when the client passes along the Access Token when making requests to the API, the API can inspect the `scope` claim to ensure that the required permissions were granted in order to call the particular API endpoint.\n\n#### What are Scopes?\n\nEach Access Token may include a list of the permissions that have been granted to the client. When a client authenticates with Auth0, it will specify the list of scopes (or permissions) it is requesting. If those scopes are authorized, then the Access Token will contain a list of authorized scopes.\n\nFor example, the timesheet API may accept four different levels of authorization: reading timesheets (scope `read:timesheets`), creating timesheets (scope `create:timesheets`), deleting timesheets (scope `delete:timesheets`) and approving timesheets (scope `approve:timesheets`).\n\nWhen a client asks the API to create a new timesheet entry, then the Access Token should contain the `create:timesheets` scope. In a similar fashion, in order to delete existing timesheets, the Access Token should contain the `delete:timesheets` scope.\n\nFor more information on scopes refer to [Scopes](https://auth0.com/docs/scopes).\n\nBy using the OAuth 2.0 authorization framework, you can give your own applications or third-party applications limited access to your APIs on behalf of the application itself. Using Auth0, you can easily support different flows in your own APIs without worrying about the OAuth 2.0/OpenID Connect (OIDC) specification, or the many other technical aspects of API authorization.\n\n#### OAuth roles\n\nIn any OAuth 2.0 flow we can identify the following roles:\n\n*   **Resource Owner**: the entity that can grant access to a protected resource. Typically this is the end-user.\n    \n*   **Resource Server**: the server hosting the protected resources. This is the API you want to access.\n    \n*   **Client**: an application requesting access to a protected resource on behalf of the Resource Owner.\n    \n*   **Authorization Server**: the server that authenticates the Resource Owner, and issues Access Tokens after getting proper authorization. In this case, Auth0.\n    \n\nUsing [different grants types (or flows)](https://auth0.com/docs/api-auth/which-oauth-flow-to-use), these participants will interact to grant to the client apps limited access to the APIs you are building. As a result, the client app will obtain an Access Token that can be used to call the API on behalf of the user.\n\n## Proof Key for Code Exchange (PKCE)\n\nOAuth 2 provides several grant types for different use cases. In this particular use case, we want to access the API from a mobile application, which will use the [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) to do so.\n\nThe [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) has some security issues when implemented on native applications. For instance, a malicious attacker can intercept the `authorization_code` returned by Auth0 and exchange it for an [Access Token](https://auth0.com/docs/secure/tokens/access-tokens) (and possibly a [Refresh Token](https://auth0.com/docs/secure/tokens/refresh-tokens)).\n\nThe Proof Key for Code Exchange (PKCE) (defined in [RFC 7636](https://tools.ietf.org/html/rfc7636)) is a technique used to mitigate this authorization code interception attack.\n\nWith PKCE, the Application creates, for every authorization request, a cryptographically random key called `code_verifier` and its transformed value called `code_challenge`, which is sent to Auth0 to get the `authorization_code`. When the Application receives the `authorization_code`, it will send the code and the `code_verifier` to Auth0's token endpoint to exchange them for the requested tokens.\n\n![Diagram - Microsite - Auth Code with PKCE](https://images.ctfassets.net/cdy7uua7fh8z/7pd2I8RXINIihsTyuGxvMb/cdbad014a576df5a15d53f84a5d97a55/authorization-code-grant-pkce.png)\n\n1.  The native app initiates the flow and redirects the user to Auth0 (specifically to the [/authorize endpoint](https://auth0.com/docs/api/authentication#authorization-code-grant-pkce-)), sending the `code_challenge` and `code_challenge_method` parameters.\n    \n2.  Auth0 redirects the user to the native app with an `authorization_code` in the query string.\n    \n3.  The native app sends the `authorization_code` and `code_verifier` together with the `redirect_uri` and the `client_id` to Auth0. This is done using the [/oauth/token endpoint](https://auth0.com/docs/api/authentication?http#authorization-code-pkce-).\n    \n4.  Auth0 validates this information and returns an Access Token (and optionally a Refresh Token).\n    \n5.  The native app can use the Access Token to call the API on behalf of the user.\n    \n\n## Authorization Extension\n\nThe [Auth0 Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension) allows you to provide authorization support in your application, by assigning Roles, Groups and Permissions to Users.\n\nThe Authorization Extension creates a [Rule](https://auth0.com/docs/customize/rules) which will augment the User profile during the authentication flow with the Roles, Groups and Permissions assigned to the user. You can then use this information to ensure that the Access Token issued to a user only contains scopes which are allowed according to the permissions defined in the Authorization Extension.\n\nPREVIOUS TUTORIAL [Introduction](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api)\n\nNEXT TUTORIAL [2\\. Auth0 Configuration](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-2)",
  "title": "Solution Overview (Mobile Apps + API)",
  "description": "Solutions Overview for the Mobile + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production",
  "markdown": "# Get Management API Access Tokens for Production\n\nTo make scheduled frequent calls for a production environment, you have to build a process at your backend that will provide you with a token automatically (and thus simulate a non-expiring token).\n\n## Prerequisites\n\n*   [Register Machine-to-Machine Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps).\n    \n\n## Get access tokens\n\nTo ask Auth0 for a Management API v2 token, perform a `POST` operation to the `https://{yourDomain}/oauth/token` endpoint, using the credentials of the Machine-to-Machine Application you created in the prerequisite step.\n\nThe payload should be in the following format:\n\n*   [cURL](#db090eb774e64ade9c808fe56ea6d9dd_shell)\n*   [C#](#db090eb774e64ade9c808fe56ea6d9dd_csharp)\n*   [Go](#db090eb774e64ade9c808fe56ea6d9dd_go)\n*   [Java](#db090eb774e64ade9c808fe56ea6d9dd_java)\n*   [Node.JS](#db090eb774e64ade9c808fe56ea6d9dd_node)\n*   [Obj-C](#db090eb774e64ade9c808fe56ea6d9dd_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'audience=https://{yourDomain}/api/v2/'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    audience: 'https://{yourDomain}/api/v2/'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=https://{yourDomain}/api/v2/\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=https://{yourDomain}/api/v2/\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nRemember to update `` `{yourClientSecret}` `` with the client secret in the [Settings tab of your Application](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\nThe request parameters are:\n\n| **Request Parameter** | **Description** |\n| --- | --- |\n| **grant\\_type** | Denotes which [OAuth 2.0 flow](https://auth0.com/docs/protocols/oauth2#grant-types) you want to run. For machine to machine communication use the value `client_credentials`. |\n| **client\\_id** | This is the value of the **Client ID** field of the Machine-to-Machine Application you created. You can find it on the [Settings tab of your Application](https://manage.auth0.com/#/applications/{yourClientId}/settings). |\n| **client\\_secret** | This is the value of the **Client Secret** field of the Machine-to-Machine Application you created. You can find it at the [Settings tab of your Application](https://manage.auth0.com/#/applications/{yourClientId}/settings). |\n| **audience** | This is the value of the **Identifier** field of the `Auth0 Management API`. You can find it at the [Settings tab of the API](https://manage.auth0.com/#/apis). |\n\nThe response will contain a [signed JWT](https://auth0.com/docs/secure/tokens/json-web-tokens), an expiration time, the scopes granted, and the token type.\n\n```\n{\n  \"access_token\": \"eyJ...Ggg\",\n  \"expires_in\": 86400,\n  \"scope\": \"read:clients create:clients read:client_keys\",\n  \"token_type\": \"Bearer\"\n}\n```\n\nFrom the above, we can see that our Access Token will expire in 24 hours (86400 seconds), it has been authorized to read and create applications, and it is a [Bearer Access Token](https://tools.ietf.org/html/rfc6750).\n\n### Use Auth0's Node.js client library\n\nAs an alternative to making HTTP calls, you can use the [node-auth0](https://www.npmjs.com/package/auth0) library to automatically [obtain tokens for the Management API](https://www.npmjs.com/package/auth0#user-content-management-api-client).\n\n## Use access tokens\n\nTo use this token, include it in the `Authorization` header of your request.\n\n*   [cURL](#ce0247c43d2049118245ee3c8412d354_shell)\n*   [C#](#ce0247c43d2049118245ee3c8412d354_csharp)\n*   [Go](#ce0247c43d2049118245ee3c8412d354_go)\n*   [Java](#ce0247c43d2049118245ee3c8412d354_java)\n*   [Node.JS](#ce0247c43d2049118245ee3c8412d354_node)\n*   [Obj-C](#ce0247c43d2049118245ee3c8412d354_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url http:///%7BmgmtApiEndpoint%7D \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"http:///%7BmgmtApiEndpoint%7D\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http:///%7BmgmtApiEndpoint%7D\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"http:///%7BmgmtApiEndpoint%7D\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'http:///%7BmgmtApiEndpoint%7D',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer {yourMgmtApiAccessToken}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http:///%7BmgmtApiEndpoint%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"http:///%7BmgmtApiEndpoint%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\"\n    }\n\nconn.request(\"POST\", \"%7BmgmtApiEndpoint%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http:///%7BmgmtApiEndpoint%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http:///%7BmgmtApiEndpoint%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor example, in order to [Get all applications](https://auth0.com/docs/api/management/v2#!/Clients/get_clients) use the following:\n\n*   [cURL](#818b4877174e4652a801fa98f99a25ad_shell)\n*   [C#](#818b4877174e4652a801fa98f99a25ad_csharp)\n*   [Go](#818b4877174e4652a801fa98f99a25ad_go)\n*   [Java](#818b4877174e4652a801fa98f99a25ad_java)\n*   [Node.JS](#818b4877174e4652a801fa98f99a25ad_node)\n*   [Obj-C](#818b4877174e4652a801fa98f99a25ad_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/clients' \\\n  --header 'authorization: Bearer {yourAccessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/clients\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/clients',\n  headers: {'content-type': 'application/json', authorization: 'Bearer {yourAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourAccessToken}\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/clients\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourAccessToken}\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Example: Python implementation\n\nThis python script gets a Management API v2 Access Token, uses it to call the [Get all applications](https://auth0.com/docs/api/management/v2#!/Clients/get_clients) endpoint, and prints the response in the console.\n\nBefore you run it make sure that the following variables hold valid values:\n\n*   `AUDIENCE`: The **Identifier** of the `Auth0 Management API`. You can find it at the [Settings tab of the API](https://manage.auth0.com/#/apis).\n    \n*   `DOMAIN`: The **Domain** of the Machine-to-Machine Application you created.\n    \n*   `CLIENT_ID`: The **Client ID** of the Machine to Machine Application you created.\n    \n*   `CLIENT_SECRET`: The **Client Secret** of the Machine-to-Machine Application you created.\n    \n\n```\ndef main():\n  import json, requests\n  from requests.exceptions import RequestException, HTTPError, URLRequired\n\n  # Configuration Values\n  domain = 'YOUR_DOMAIN'\n  audience = f'https://{domain}/api/v2/'\n  client_id = 'YOUR_CLIENT_ID'\n  client_secret = 'YOUR_CLIENT_SECRET'\n  grant_type = \"client_credentials\" # OAuth 2.0 flow to use\n\n  # Get an Access Token from Auth0\n  base_url = f\"https://{domain}\"\n  payload =  { \n    'grant_type': grant_type,\n    'client_id': client_id,\n    'client_secret': client_secret,\n    'audience': audience\n  }\n  response = requests.post(f'{base_url}/oauth/token', data=payload)\n  oauth = response.json()\n  access_token = oauth.get('access_token')\n\n  # Add the token to the Authorization header of the request\n  headers = {\n    'Authorization': f'Bearer {access_token}',\n    'Content-Type': 'application/json'\n  }\n\n  # Get all Applications using the token\n  try:\n    res = requests.get(f'{base_url}/api/v2/clients', headers=headers)\n    print(res.json())\n  except HTTPError as e:\n    print(f'HTTPError: {str(e.code)} {str(e.reason)}')\n  except URLRequired as e:\n    print(f'URLRequired: {str(e.reason)}')\n  except RequestException as e:\n    print(f'RequestException: {e}')\n  except Exception as e:\n    print(f'Generic Exception: {e}')\n\n# Standard boilerplate to call the main() function.\nif __name__ == '__main__':\n  main()\n```\n\n## Learn more\n\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n*   [Get Management API Access Tokens for Single-Page Applications](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-tokens-for-single-page-applications)\n*   [Applications in Auth0](https://auth0.com/docs/get-started/applications)",
  "title": "Get Management API Access Tokens for Production",
  "description": "Learn how to get Access Tokens to make scheduled frequent calls to the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-4",
  "markdown": "# Conclusion (Mobile Apps + API)\n\nIn this document we covered a simple scenario: an API, used by a mobile application to allow employees to capture their timesheets.\n\nWe learned about the Authorization Code Grant with PKCE, what an Access Token is, how to configure an API in Auth0, how to configure a mobile application to communicate securely with this API, how to define and secure our API endpoints, how to use the provided libraries to validate the Access Token and how to retrieve a new one from Auth0.\n\nWe started by describing the business case and the requirements and went on explaining how each requirement can be met and the thought process behind each choice that was made.\n\nWe used Node.js for the API implementation and Android for the mobile application. Hopefully though after going through this document you are able to build this using the technologies you prefer.\n\nDon't forget to check back for new business cases and more complex architecture scenarios!",
  "title": "Conclusion (Mobile Apps + API)",
  "description": "Conclusion for the Mobile + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/get-management-api-access-tokens-for-production",
  "markdown": "# Get Management API Access Tokens for Production\n\nTo make scheduled frequent calls for a production environment, you have to build a process at your backend that will provide you with a token automatically (and thus simulate a non-expiring token).\n\n## Prerequisites\n\n*   [Register Machine-to-Machine Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps).\n    \n\n## Get access tokens\n\nTo ask Auth0 for a Management API v2 token, perform a `POST` operation to the `https://{yourDomain}/oauth/token` endpoint, using the credentials of the Machine-to-Machine Application you created in the prerequisite step.\n\nThe payload should be in the following format:\n\n*   [cURL](#db090eb774e64ade9c808fe56ea6d9dd_shell)\n*   [C#](#db090eb774e64ade9c808fe56ea6d9dd_csharp)\n*   [Go](#db090eb774e64ade9c808fe56ea6d9dd_go)\n*   [Java](#db090eb774e64ade9c808fe56ea6d9dd_java)\n*   [Node.JS](#db090eb774e64ade9c808fe56ea6d9dd_node)\n*   [Obj-C](#db090eb774e64ade9c808fe56ea6d9dd_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'audience=https://{yourDomain}/api/v2/'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    audience: 'https://{yourDomain}/api/v2/'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=https://{yourDomain}/api/v2/\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2F{yourDomain}%2Fapi%2Fv2%2F\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=https://{yourDomain}/api/v2/\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nRemember to update `` `{yourClientSecret}` `` with the client secret in the [Settings tab of your Application](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\nThe request parameters are:\n\n| **Request Parameter** | **Description** |\n| --- | --- |\n| **grant\\_type** | Denotes which [OAuth 2.0 flow](https://auth0.com/docs/protocols/oauth2#grant-types) you want to run. For machine to machine communication use the value `client_credentials`. |\n| **client\\_id** | This is the value of the **Client ID** field of the Machine-to-Machine Application you created. You can find it on the [Settings tab of your Application](https://manage.auth0.com/#/applications/{yourClientId}/settings). |\n| **client\\_secret** | This is the value of the **Client Secret** field of the Machine-to-Machine Application you created. You can find it at the [Settings tab of your Application](https://manage.auth0.com/#/applications/{yourClientId}/settings). |\n| **audience** | This is the value of the **Identifier** field of the `Auth0 Management API`. You can find it at the [Settings tab of the API](https://manage.auth0.com/#/apis). |\n\nThe response will contain a [signed JWT](https://auth0.com/docs/secure/tokens/json-web-tokens), an expiration time, the scopes granted, and the token type.\n\n```\n{\n  \"access_token\": \"eyJ...Ggg\",\n  \"expires_in\": 86400,\n  \"scope\": \"read:clients create:clients read:client_keys\",\n  \"token_type\": \"Bearer\"\n}\n```\n\nFrom the above, we can see that our Access Token will expire in 24 hours (86400 seconds), it has been authorized to read and create applications, and it is a [Bearer Access Token](https://tools.ietf.org/html/rfc6750).\n\n### Use Auth0's Node.js client library\n\nAs an alternative to making HTTP calls, you can use the [node-auth0](https://www.npmjs.com/package/auth0) library to automatically [obtain tokens for the Management API](https://www.npmjs.com/package/auth0#user-content-management-api-client).\n\n## Use access tokens\n\nTo use this token, include it in the `Authorization` header of your request.\n\n*   [cURL](#ce0247c43d2049118245ee3c8412d354_shell)\n*   [C#](#ce0247c43d2049118245ee3c8412d354_csharp)\n*   [Go](#ce0247c43d2049118245ee3c8412d354_go)\n*   [Java](#ce0247c43d2049118245ee3c8412d354_java)\n*   [Node.JS](#ce0247c43d2049118245ee3c8412d354_node)\n*   [Obj-C](#ce0247c43d2049118245ee3c8412d354_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url http:///%7BmgmtApiEndpoint%7D \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"http:///%7BmgmtApiEndpoint%7D\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http:///%7BmgmtApiEndpoint%7D\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"http:///%7BmgmtApiEndpoint%7D\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'http:///%7BmgmtApiEndpoint%7D',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer {yourMgmtApiAccessToken}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http:///%7BmgmtApiEndpoint%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"http:///%7BmgmtApiEndpoint%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\"\n    }\n\nconn.request(\"POST\", \"%7BmgmtApiEndpoint%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http:///%7BmgmtApiEndpoint%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http:///%7BmgmtApiEndpoint%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor example, in order to [Get all applications](https://auth0.com/docs/api/management/v2#!/Clients/get_clients) use the following:\n\n*   [cURL](#818b4877174e4652a801fa98f99a25ad_shell)\n*   [C#](#818b4877174e4652a801fa98f99a25ad_csharp)\n*   [Go](#818b4877174e4652a801fa98f99a25ad_go)\n*   [Java](#818b4877174e4652a801fa98f99a25ad_java)\n*   [Node.JS](#818b4877174e4652a801fa98f99a25ad_node)\n*   [Obj-C](#818b4877174e4652a801fa98f99a25ad_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/clients' \\\n  --header 'authorization: Bearer {yourAccessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/clients\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/clients',\n  headers: {'content-type': 'application/json', authorization: 'Bearer {yourAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourAccessToken}\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/clients\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourAccessToken}\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Example: Python implementation\n\nThis python script gets a Management API v2 Access Token, uses it to call the [Get all applications](https://auth0.com/docs/api/management/v2#!/Clients/get_clients) endpoint, and prints the response in the console.\n\nBefore you run it make sure that the following variables hold valid values:\n\n*   `AUDIENCE`: The **Identifier** of the `Auth0 Management API`. You can find it at the [Settings tab of the API](https://manage.auth0.com/#/apis).\n    \n*   `DOMAIN`: The **Domain** of the Machine-to-Machine Application you created.\n    \n*   `CLIENT_ID`: The **Client ID** of the Machine to Machine Application you created.\n    \n*   `CLIENT_SECRET`: The **Client Secret** of the Machine-to-Machine Application you created.\n    \n\n```\ndef main():\n  import json, requests\n  from requests.exceptions import RequestException, HTTPError, URLRequired\n\n  # Configuration Values\n  domain = 'YOUR_DOMAIN'\n  audience = f'https://{domain}/api/v2/'\n  client_id = 'YOUR_CLIENT_ID'\n  client_secret = 'YOUR_CLIENT_SECRET'\n  grant_type = \"client_credentials\" # OAuth 2.0 flow to use\n\n  # Get an Access Token from Auth0\n  base_url = f\"https://{domain}\"\n  payload =  { \n    'grant_type': grant_type,\n    'client_id': client_id,\n    'client_secret': client_secret,\n    'audience': audience\n  }\n  response = requests.post(f'{base_url}/oauth/token', data=payload)\n  oauth = response.json()\n  access_token = oauth.get('access_token')\n\n  # Add the token to the Authorization header of the request\n  headers = {\n    'Authorization': f'Bearer {access_token}',\n    'Content-Type': 'application/json'\n  }\n\n  # Get all Applications using the token\n  try:\n    res = requests.get(f'{base_url}/api/v2/clients', headers=headers)\n    print(res.json())\n  except HTTPError as e:\n    print(f'HTTPError: {str(e.code)} {str(e.reason)}')\n  except URLRequired as e:\n    print(f'URLRequired: {str(e.reason)}')\n  except RequestException as e:\n    print(f'RequestException: {e}')\n  except Exception as e:\n    print(f'Generic Exception: {e}')\n\n# Standard boilerplate to call the main() function.\nif __name__ == '__main__':\n  main()\n```\n\n## Learn more\n\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n*   [Get Management API Access Tokens for Single-Page Applications](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-tokens-for-single-page-applications)\n*   [Applications in Auth0](https://auth0.com/docs/get-started/applications)",
  "title": "Get Management API Access Tokens for Production",
  "description": "Learn how to get Access Tokens to make scheduled frequent calls to the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-3",
  "markdown": "# API and Mobile Configuration (Mobile Apps + API)\n\nIn this section we will see how we can implement an API for our scenario.\n\n## Define the API endpoints\n\nFirst we need to define the endpoints of our API.\n\n#### What is an API endpoint?\n\nAn **API endpoint** is a unique URL that represents an object. To interact with this object, you need to point your application to its URL. For example, if you had an API that could return either orders or customers, you might configure two endpoints: `/orders` and `/customers`. Your application would interact with these endpoints using different HTTP methods; for example, `POST /orders` could create a new order or `GET /orders` could retrieve the dataset of one or more orders.\n\nFor this implementation we will only define two endpoints; one for retrieving a list of all timesheets for an employee, and another which will allow an employee to create a new timesheet entry.\n\nAn `HTTP GET` request to the `/timesheets` endpoint will allow a user to retrieve their timesheets, and an `HTTP POST` request to the `/timesheets` endpoint will allow a user to add a new timesheet.\n\nSee the implementation in [Node.js](https://auth0.com/docs/architecture-scenarios/application/mobile-api/api-implementation-nodejs#1-define-the-api-endpoints)\n\n### Secure the Endpoints\n\nWhen an API receives a request with a bearer Access Token as part of the header, the first thing to do is to validate the token. This consists of a series of steps, and if any of these fails then the request must be rejected with a `Missing or invalid token` error message to the calling app.\n\nThe validations that the API should perform are:\n\n*   Check that the JWT is well formed\n    \n*   Check the signature\n    \n*   Validate the standard claims\n    \n\nPart of the validation process is to also check the Client permissions (scopes), but we will address this separately in the next paragraph of this document.\n\nFor more information on validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n\nSee the implementation in [Node.js](https://auth0.com/docs/architecture-scenarios/application/mobile-api/api-implementation-nodejs#2-secure-the-api-endpoints)\n\n### Check the Client's Permissions\n\nBy now we have verified that the JWT is valid. The last step is to verify that the client has the permissions required to access the protected resources.\n\nTo do so, the API needs to check the [scopes](https://auth0.com/docs/scopes) of the decoded JWT. This claim is part of the payload and it is a space-separated list of strings.\n\nSee the implementation in [Node.js](https://auth0.com/docs/architecture-scenarios/application/mobile-api/api-implementation-nodejs#3-check-the-client-permissions)\n\n### Determine user identity\n\nFor both endpoints (retrieving the list of timesheets, and adding a new timesheet) we will need to determine the identity of the user.\n\nFor retrieving the list of timesheets this is to ensure that we only return the timesheets belonging to the user making the request, and for adding a new timesheet this is to ensure that the timesheet is associated with the user making the request.\n\nOne of the standard JWT claims is the `sub` claim which identifies the principal that is the subject to the claim. In the case of the Implicit Grant flow this claim will contain the user's identity, which will be the unique identifier for the Auth0 user. You can use this to associate any information in external systems with a particular user.\n\nYou can also use a custom claim to add another attribute of the user - such as their email address - to the Access Token and use that to uniquely identify the user.\n\nSee the implementation in [Node.js](https://auth0.com/docs/architecture-scenarios/application/mobile-api/api-implementation-nodejs#4-determine-the-user-identity)\n\n## Implement the Mobile App\n\nIn this section we will see how we can implement a mobile application for our scenario.\n\n[See the implementation in Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#1-set-up-the-application)\n\nTo authorize the user we will implement the [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/guides/auth-code-pkce/call-api-auth-code-pkce). The mobile application should first send the user to the [authorization URL](https://auth0.com/docs/api/authentication#authorization-code-grant-pkce-) along with the `code_challenge` and the method used to generate it:\n\n```\nhttps://{yourDomain}/authorize?\n    audience=API_AUDIENCE&\n    scope=SCOPE&\n    response_type=code&\n    client_id=YOUR_CLIENT_ID&\n    code_challenge=CODE_CHALLENGE&\n    code_challenge_method=S256&\n    redirect_uri=https://YOUR_APP/callback\n```\n\nThe `GET` request to the authorization URL should include the following values:\n\n| Parameter | Description |\n| --- | --- |\n| **client\\_id** | The value of your Auth0 Client Id. You can retrieve it from the Settings of your Application at the [Auth0 Dashboard](https://manage.auth0.com/#/applications). |\n| **audience** | The value of your API Identifier. You can retrieve it from the Settings of your API at the [Auth0 Dashboard](https://manage.auth0.com/#/apis). |\n| **scope** | The [scopes](https://auth0.com/docs/scopes) which determine the claims to be returned in the ID Token and Access Token. For example, a scope of `openid` will return an ID Token in the response. In our example mobile app, we use the following scopes: `create:timesheets read:timesheets openid profile email offline_access`. These scopes allow the mobile app to call the API, obtain a Refresh Token, and return the user's `name`, `picture`, and `email` claims in the ID Token. |\n| **response\\_type** | Indicates the Authentication Flow to use. For a mobile application using PKCE, this should be set to `code`. |\n| **code\\_challenge** | The generated code challenge from the code verifier. You can find instructions on generating a code challenge [here](https://auth0.com/docs/flows/guides/auth-code-pkce/call-api-auth-code-pkce#authorize-the-user#create-a-code-verifier). |\n| **code\\_challenge\\_method** | Method used to generate the challenge. Auth0 supports only `S256`. |\n| **redirect\\_uri** | The URL which Auth0 will redirect the browser to after authorization has been granted by the user. The Authorization Code will be available in the code URL parameter. This URL must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications). |\n\n[See the implementation in Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#2-authorize-the-user)\n\n### Get the Credentials\n\nAfter a successful request to the authorization URL, you should receive the following response:\n\n```\nHTTP/1.1 302 Found\nLocation: https://{yourDomain}/callback?code=AUTHORIZATION_CODE\n```\n\nNext you can exchange the `authorization_code` from the response for an Access Token that can be used to call your API. Perform a `POST` request to the [Token URL](https://auth0.com/docs/api/authentication#authorization-code-pkce-) including the following data:\n\n*   [cURL](#4d512c763be143819356d5d9cc43dceb_shell)\n*   [C#](#4d512c763be143819356d5d9cc43dceb_csharp)\n*   [Go](#4d512c763be143819356d5d9cc43dceb_go)\n*   [Java](#4d512c763be143819356d5d9cc43dceb_java)\n*   [Node.JS](#4d512c763be143819356d5d9cc43dceb_node)\n*   [Obj-C](#4d512c763be143819356d5d9cc43dceb_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data code_verified=YOUR_GENERATED_CODE_VERIFIER \\\n  --data code=YOUR_AUTHORIZATION_CODE \\\n  --data 'redirect_uri=https://{https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    code_verified: 'YOUR_GENERATED_CODE_VERIFIER',\n    code: 'YOUR_AUTHORIZATION_CODE',\n    redirect_uri: 'https://{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code_verified=YOUR_GENERATED_CODE_VERIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code=YOUR_AUTHORIZATION_CODE\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri=https://{https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code_verified=YOUR_GENERATED_CODE_VERIFIER\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code=YOUR_AUTHORIZATION_CODE\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri=https://{https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Parameter | Description |\n| --- | --- |\n| **grant\\_type** | This must be set to `authorization_code`. |\n| **client\\_id** | The value of your Auth0 Client Id. You can retrieve it from the Settings of your Application at the [Auth0 Dashboard](https://manage.auth0.com/#/applications). |\n| **code\\_verifier** | Cryptographically random key that was used to generate the `code_challenge` passed to [authorization URL](https://auth0.com/docs/api/authentication#authorization-code-grant-pkce-) (`/authorize`). |\n| **code** | The `authorization_code` received from the previous authorize call. |\n| **redirect\\_uri** | The URL must match the `redirect_uri` passed in the previous section to `/authorize`. |\n\nThe response from the Token URL will contain:\n\n```\n{\n  \"access_token\": \"eyJz93a...k4laUWw\",\n  \"refresh_token\": \"GEbRxBN...edjnXbL\",\n  \"id_token\": \"eyJ0XAi...4faeEoQ\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n*   **access\\_token**: An Access Token for the API, specified by the `audience`.\n    \n*   **refresh\\_token**: A [Refresh Token](https://auth0.com/docs/tokens/concepts/refresh-tokens) will only be present if you included the `offline_access` scope AND enabled **Allow Offline Access** for your API in the Dashboard.\n    \n*   **id\\_token**: An ID Token JWT containing user profile information.\n    \n*   **token\\_type**: A string containing the type of token, this will always be a Bearer token.\n    \n*   **expires\\_in**: The amount of seconds until the Access Token expires.\n    \n\nYou will need to store the above credentials in local storage for use in calling your API and retrieving the user profile.\n\n[See the implementation in Android](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#store-credentials).\n\n### Get the User Profile\n\nTo retrieve the [User Profile](https://auth0.com/docs/api/authentication?http#user-profile), your mobile application can decode the [ID Token](https://auth0.com/docs/tokens/concepts/id-tokens) using one of the [JWT libraries](https://jwt.io/#libraries-io). This is done by [verifying the signature](https://auth0.com/docs/tokens/guides/validate-id-token#verify-the-signature) and [verifying the claims](https://auth0.com/docs/tokens/guides/validate-id-token#verify-the-claims) of the token. After validating the ID Token, you can access its payload containing the user information:\n\n```\n{\n  \"email_verified\": false,\n  \"email\": \"test.account@userinfo.com\",\n  \"clientID\": \"q2hnj2iu...\",\n  \"updated_at\": \"2016-12-05T15:15:40.545Z\",\n  \"name\": \"test.account@userinfo.com\",\n  \"picture\": \"https://s.gravatar.com/avatar/dummy.png\",\n  \"user_id\": \"auth0|58454...\",\n  \"nickname\": \"test.account\",\n  \"created_at\": \"2016-12-05T11:16:59.640Z\",\n  \"sub\": \"auth0|58454...\"\n}\n```\n\n[See the implementation in Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#3-get-the-user-profile)\n\n### Display UI Elements Conditionally Based on Scope\n\nBased on the `scope` of the user, you may want to show or hide certain UI elements. To determine the scope issued to a user, you will need to inspect the `scope` which was granted when the user was authenticated. This will be a string containing all the scopes, so you therefore need to inspect this string to see whether it contains the required `scope` and based on that make a decision whether to display a particular UI element.\n\n[See the implementation in Android](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#4-display-ui-elements-conditionally-based-on-scope)\n\n### Call the API\n\nTo access secured resources from your API, the authenticated user's Access Token needs to be included in requests that are sent to it. This is accomplished by sending the Access Token in an `Authorization` header using the `Bearer` scheme.\n\n[See the implementation in Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#5-call-the-api)\n\n### Renew the Token\n\nTo refresh your Access Token, perform a `POST` request to the `/oauth/token` endpoint using the Refresh Token from your authorization result.\n\nA [Refresh Token](https://auth0.com/docs/tokens/concepts/refresh-tokens) will only be present if you included the `offline_access` scope in the previous authorization request and enabled **Allow Offline Access** for your API in the Dashboard.\n\nYour request should include:\n\n*   [cURL](#e73623912c5b44758ce0d90cb28d7432_shell)\n*   [C#](#e73623912c5b44758ce0d90cb28d7432_csharp)\n*   [Go](#e73623912c5b44758ce0d90cb28d7432_go)\n*   [Java](#e73623912c5b44758ce0d90cb28d7432_java)\n*   [Node.JS](#e73623912c5b44758ce0d90cb28d7432_node)\n*   [Obj-C](#e73623912c5b44758ce0d90cb28d7432_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"undefined\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSData(data: \"undefined\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Parameter | Description |\n| --- | --- |\n| **grant\\_type** | This must be set to `refresh_token`. |\n| **client\\_id** | The value of your Auth0 Client Id. You can retrieve it from the Settings of your Application at the [Auth0 Dashboard](https://manage.auth0.com/#/applications). |\n| **refresh\\_token** | the Refresh Token to use, from the previous authentication result. |\n\nThe response will include the new Access Token:\n\n```\n{\n  \"access_token\": \"eyJz93a...k4laUWw\",\n  \"refresh_token\": \"GEbRxBN...edjnXbL\",\n  \"id_token\": \"eyJ0XAi...4faeEoQ\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n[See the implementation in Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#store-the-credentials)",
  "title": "API and Mobile Configuration (Mobile Apps + API)",
  "description": "API and Mobile Configuration for the Mobile + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-react",
  "markdown": "# Auth0 React SDK for Single Page Apps\n\nThe Auth0 React SDK (auth0-react.js) is a JavaScript library for implementing authentication and authorization in React apps with Auth0. It provides a custom React hook and other Higher Order Components so you can secure React apps using best practices while writing less code.\n\nThe Auth0 React SDK handles grant and protocol details, token expiration and renewal, as well as token storage and caching. Under the hood, it implements [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) and the [Authorization Code Grant Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n\nThe library is [hosted on GitHub](https://github.com/auth0/auth0-react) where you can [read more about the API](https://auth0.github.io/auth0-react/).\n\n## Installation\n\nYou have a few options for using auth0-react.js in your project.\n\n*   From [npm](https://npmjs.org/):\n    \n    `npm install @auth0/auth0-react`\n    \n*   From [yarn](https://yarnpkg.com/): `yarn add @auth0/auth0-react`\n    \n\n## Getting started\n\nFirst, you'll need to wrap your application in a single `Auth0Provider` component. This will provide the React Context to components that are placed inside your application.\n\n```\nimport React from 'react';\n    import ReactDOM from 'react-dom';\n    import { Auth0Provider } from '@auth0/auth0-react';\n    import App from './App';\n    ReactDOM.render(\n      <Auth0Provider\n        domain=\"{yourDomain}\"\n        clientId=\"{yourClientId}\"\n        authorizationParams={{\n          redirect_uri: window.location.origin\n        }}\n    >\n      <App />\n    </Auth0Provider>,\n    document.getElementById('app')\n );\n```\n\n## isLoading and error\n\nWait for the SDK to initialize and handle any errors with the `isLoading` and `error` states.\n\n```\nimport React from 'react';\nimport { useAuth0 } from '@auth0/auth0-react';\nfunction Wrapper({ children }) {\n  const {\n    isLoading,\n    error,\n  } = useAuth0();\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n  if (error) {\n    return <div>Oops... {error.message}</div>;\n  }\n  return <>{children}</>;\n}\nexport default Wrapper;\n```\n\n## Login\n\nUse `loginWithRedirect` or `loginWithPopup` to log your users in.\n\n```\nimport React from 'react';\nimport { useAuth0 } from '@auth0/auth0-react';\n\nfunction LoginButton() {\n  const {\n    isAuthenticated,\n    loginWithRedirect,\n  } = useAuth0();\n\n  return !isAuthenticated && (\n    <button onClick={loginWithRedirect}>Log in</button>\n  );\n}\n\nexport default LoginButton;\n```\n\n## Logout\n\nUse `logout` to log your users out. Make sure `returnTo` is specified in \"Allowed Logout URLs\" in your Auth0 Dashboard.\n\n```\nimport React from 'react';\nimport { useAuth0 } from '@auth0/auth0-react';\n\nfunction LogoutButton() {\n  const {\n    isAuthenticated,\n    logout,\n  } = useAuth0();\n\n  return isAuthenticated && (\n    <button onClick={() => {\n      logout({ \n        logoutParams: {\n          returnTo: window.location.origin\n        }\n      });\n    }}>Log out</button>\n  );\n}\n\nexport default LogoutButton;\n```\n\n## User\n\nAccess user profile information with the `user` value.\n\n```\nimport React from 'react';\nimport { useAuth0 } from '@auth0/auth0-react';\n\nfunction Profile() {\n  const { user } = useAuth0();\n\n  return <div>Hello {user.name}</div>;\n}\n\nexport default Profile;\n```\n\n## Use with a class component\n\nUse the `withAuth0` Higher Order Component to add the `auth0` property to class components instead of using the hook.\n\n```\nimport React, { Component } from 'react';\nimport { withAuth0 } from '@auth0/auth0-react';\n\nclass Profile extends Component {\n  render() {\n    const { user } = this.props.auth0;\n    return <div>Hello {user.name}</div>;\n  }\n}\n\nexport default withAuth0(Profile);\n```\n\n## Protect a route\n\nProtect a route component using the `withAuthenticationRequired` higher order component. Visits to this route when unauthenticated will redirect the user to the login page and back to this page after login.\n\n```\nimport React from 'react';\nimport { withAuthenticationRequired } from '@auth0/auth0-react';\n\nconst PrivateRoute = () => (<div>Private</div>);\n\nexport default withAuthenticationRequired(PrivateRoute, {\n  // Show a message while the user waits to be redirected to the login page.\n  onRedirecting: () => (<div>Redirecting you to the login page...</div>)\n});\n```\n\n**Note** If you are using a custom router, you will need to supply the `Auth0Provider` with a custom `onRedirectCallback` method to perform the action that returns the user to the protected page. See examples for [react-router](https://github.com/auth0/auth0-react/blob/master/EXAMPLES.md#1-protecting-a-route-in-a-react-router-dom-app), [Gatsby](https://github.com/auth0/auth0-react/blob/master/EXAMPLES.md#2-protecting-a-route-in-a-gatsby-app) and [Next.js](https://github.com/auth0/auth0-react/blob/master/EXAMPLES.md#3-protecting-a-route-in-a-nextjs-app-in-spa-mode).\n\n## Call an API\n\nTo call a protected API with an Access Token, be sure to specify the `audience` and `scope` of your [access token](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens), either in `Auth0Provider` or `getAccessTokenSilently`. Then use it to call a protected API by passing it in the `Authorization` header of your request.\n\n```\nimport React, { useEffect, useState } from 'react';\nimport { useAuth0 } from '@auth0/auth0-react';\n\nconst Posts = () => {\n  const { getAccessTokenSilently } = useAuth0();\n  const [posts, setPosts] = useState(null);\n\n  useEffect(() => {\n    (async () => {\n      try {\n        const token = await getAccessTokenSilently({\n          authorizationParams: {\n            audience: 'https://api.example.com/', // Value in Identifier field for the API being called.\n            scope: 'read:posts', // Scope that exists for the API being called. You can create these through the Auth0 Management API or through the Auth0 Dashboard in the Permissions view of your API.\n          }\n        });\n        const response = await fetch('https://api.example.com/posts', {\n          headers: {\n            Authorization: `Bearer ${token}`,\n          },\n        });\n        setPosts(await response.json());\n      } catch (e) {\n        console.error(e);\n      }\n    })();\n  }, [getAccessTokenSilently]);\n\n  if (!posts) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <ul>\n      {posts.map((post, index) => {\n        return <li key={index}>{post}</li>;\n      })}\n    </ul>\n  );\n};\n\nexport default Posts;\n```",
  "title": "Auth0 React SDK for Single Page Apps",
  "description": "Describes the Auth0 SDK for React Single Page Apps",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/api-implementation-nodejs",
  "markdown": "# Node.js API Implementation (Mobile Apps + API)\n\nThis document is part of the Mobile + API Architecture Scenario and it explains how to implement the API in Node.js. The full source code for the Node.js API implementation can be found in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets/tree/master/timesheets-api/node).\n\nPlease refer to the scenario for information on the implemented solution.\n\n/\n\nCheck the app permissions",
  "title": "Node.js API Implementation (Mobile Apps + API)",
  "description": "The Node.js implementation of the API for the Mobile + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/02-using",
  "markdown": "# Auth0 ASP.NET Core Web API SDK Quickstarts: Using your API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [ASP.NET Core Web API](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi)\n*   [Using your API](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/02-using)\n\nThis tutorial will show you how to use your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Calling the API From Your Application\n\nYou can call the API from your application by passing an Access Token in the `Authorization` header of your HTTP request as a Bearer token.\n\n*   [cURL](#6191e625a2b54c82afbbf68f7bffd855_shell)\n*   [C#](#6191e625a2b54c82afbbf68f7bffd855_csharp)\n*   [Go](#6191e625a2b54c82afbbf68f7bffd855_go)\n*   [Java](#6191e625a2b54c82afbbf68f7bffd855_java)\n*   [Node.JS](#6191e625a2b54c82afbbf68f7bffd855_node)\n*   [Obj-C](#6191e625a2b54c82afbbf68f7bffd855_objc)\n*   [...](#)\n    *   [PHP](#6191e625a2b54c82afbbf68f7bffd855_php)\n    *   [Python](#6191e625a2b54c82afbbf68f7bffd855_python)\n    *   [Ruby](#6191e625a2b54c82afbbf68f7bffd855_ruby)\n    *   [Swift](#6191e625a2b54c82afbbf68f7bffd855_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Obtaining an Access Token\n\nIf you are calling the API from a Single-Page Application or a Mobile/Native application, after the authorization flow is completed, you will get an Access Token. How you get the token and how you make the call to the API will be dependent on the type of application you are developing and the framework you are using. For more information refer to the relevant application Quickstarts which contain detailed instructions:\n\n*   [Single-Page Applications](https://auth0.com/docs/quickstart/spa)\n*   [Mobile / Native Application](https://auth0.com/docs/quickstart/native)\n\nIf you are calling the API from a command-line tool or another service, where there isn't a user entering their credentials, you need to use the [OAuth Client Credentials flow](https://auth0.com/docs/api/authentication#client-credentials). To do that, register a [Machine to Machine Application](https://manage.auth0.com/#/applications), and then subsequently use the **Client ID** and **Client Secret** of this application when making the request below and pass those along in the `client_id` and `client_secret` parameters respectively. Also include the Audience for the API you want to call.\n\n*   [cURL](#7eb77031e6a94596a8f385f7d5467f97_shell)\n*   [C#](#7eb77031e6a94596a8f385f7d5467f97_csharp)\n*   [Go](#7eb77031e6a94596a8f385f7d5467f97_go)\n*   [Java](#7eb77031e6a94596a8f385f7d5467f97_java)\n*   [Node.JS](#7eb77031e6a94596a8f385f7d5467f97_node)\n*   [Obj-C](#7eb77031e6a94596a8f385f7d5467f97_objc)\n*   [...](#)\n    *   [PHP](#7eb77031e6a94596a8f385f7d5467f97_php)\n    *   [Python](#7eb77031e6a94596a8f385f7d5467f97_python)\n    *   [Ruby](#7eb77031e6a94596a8f385f7d5467f97_ruby)\n    *   [Swift](#7eb77031e6a94596a8f385f7d5467f97_swift)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor testing purposes, you can also get an Access Token from the **Test** tab in your [API settings](https://manage.auth0.com/#/apis).\n\n## Test Your API\n\n**1\\. Calling the secure endpoint**\n\nYou can make a request to the `/api/private` endpoint without passing any Access Token:\n\n*   [cURL](#d3d7ab43404d499ebd1a82fb6250eace_shell)\n*   [C#](#d3d7ab43404d499ebd1a82fb6250eace_csharp)\n*   [Go](#d3d7ab43404d499ebd1a82fb6250eace_go)\n*   [Java](#d3d7ab43404d499ebd1a82fb6250eace_java)\n*   [Node.JS](#d3d7ab43404d499ebd1a82fb6250eace_node)\n*   [Obj-C](#d3d7ab43404d499ebd1a82fb6250eace_objc)\n*   [...](#)\n    *   [PHP](#d3d7ab43404d499ebd1a82fb6250eace_php)\n    *   [Python](#d3d7ab43404d499ebd1a82fb6250eace_python)\n    *   [Ruby](#d3d7ab43404d499ebd1a82fb6250eace_ruby)\n    *   [Swift](#d3d7ab43404d499ebd1a82fb6250eace_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {method: 'GET', url: 'http://localhost:3010/api/private'};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nconn.request(\"GET\", \"/api/private\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe API will return a 401 HTTP (Unauthorized) status code:\n\n![Response for unauthorized API request](https://auth0.com/docs/media/articles/server-apis/using/private-unauthorized.png)\n\nOnce again, make the same request but this time pass along the Access Token as a Bearer token in the **Authorization** header of the request:\n\n*   [cURL](#134483fdb7b44c9d832be15c56b4bbd0_shell)\n*   [C#](#134483fdb7b44c9d832be15c56b4bbd0_csharp)\n*   [Go](#134483fdb7b44c9d832be15c56b4bbd0_go)\n*   [Java](#134483fdb7b44c9d832be15c56b4bbd0_java)\n*   [Node.JS](#134483fdb7b44c9d832be15c56b4bbd0_node)\n*   [Obj-C](#134483fdb7b44c9d832be15c56b4bbd0_objc)\n*   [...](#)\n    *   [PHP](#134483fdb7b44c9d832be15c56b4bbd0_php)\n    *   [Python](#134483fdb7b44c9d832be15c56b4bbd0_python)\n    *   [Ruby](#134483fdb7b44c9d832be15c56b4bbd0_ruby)\n    *   [Swift](#134483fdb7b44c9d832be15c56b4bbd0_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis time the API will return a successful response:\n\n![Response for authorized API request](https://auth0.com/docs/media/articles/server-apis/using/private.png)\n\n**2\\. Testing the scoped endpoint**\n\nTo test the endpoint that requires a scope, pass the Access Token containing the correct scope as a Bearer token in the Authorization header:\n\n*   [cURL](#d454d5e9cea84a6596dbd6944504aadf_shell)\n*   [C#](#d454d5e9cea84a6596dbd6944504aadf_csharp)\n*   [Go](#d454d5e9cea84a6596dbd6944504aadf_go)\n*   [Java](#d454d5e9cea84a6596dbd6944504aadf_java)\n*   [Node.JS](#d454d5e9cea84a6596dbd6944504aadf_node)\n*   [Obj-C](#d454d5e9cea84a6596dbd6944504aadf_objc)\n*   [...](#)\n    *   [PHP](#d454d5e9cea84a6596dbd6944504aadf_php)\n    *   [Python](#d454d5e9cea84a6596dbd6944504aadf_python)\n    *   [Ruby](#d454d5e9cea84a6596dbd6944504aadf_ruby)\n    *   [Swift](#d454d5e9cea84a6596dbd6944504aadf_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private-scoped \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private-scoped\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private-scoped\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private-scoped\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private-scoped',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private-scoped\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private-scoped\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private-scoped\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private-scoped\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private-scoped\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the required scope is present, the API call is successful:\n\n![Response for scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped.png)\n\nIf the required scope is not present, the API returns a 403 HTTP Status (Forbidden):\n\n![Response for forbidden scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped-forbidden.png)",
  "title": "Auth0 ASP.NET Core Web API SDK Quickstarts: Using your API",
  "description": "This tutorial will show you how to use your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/incident-response-using-logs",
  "markdown": "# Incident Response: Using Logs\n\nReviewing logs to assess the impact of an attack is a crucial step in your incident response plan. On this page you'll see how to access logs on the Auth0 Dashboard and some examples of log search queries to find indicators of an attack and review account activity.\n\n## Check Auth0 logs\n\n1.  [Login to the Auth0 Dashboard](https://manage.auth0.com/#)\n    \n2.  The Logs page is located under **Monitoring** in the menu on the left.\n    \n3.  On the Logs page, you’ll see a search bar along with a filter selection and date picker.\n    \n\n![Dashboard Monitoring Logs](https://images.ctfassets.net/cdy7uua7fh8z/2l9LfKEjrprVmHfWt80VX0/bb1b8d9927d5c83d0ba094907abe5fb6/dashboard-monitoring-logs.png)\n\nSelect a log event from the list to see a **Summary** of the event along with further **Details** including the raw JSON.\n\n### Log structure\n\nEach log event has the following fields:\n\n| Field | Description |\n| --- | --- |\n| `date` | Timestamp when this event occurred. |\n| `log_id` | The id of the log event |\n| `type` | The log event type |\n| `description` | The description of the event. |\n| `connection` | The connection name related to the event. |\n| `connection_id` | The connection id related to the event. |\n| `client_id` | The client id related to the event |\n| `client_name` | The name of the client related to the event. |\n| `ip` | The IP address from where the request that caused the log event originated. |\n| `user_agent` | The user agent that is related to the event. |\n| `details` | An object containing further information for this log event. |\n| `user_id` | The user id related to the event. |\n| `user_name` | The user name related to the event. |\n| `strategy` | The connection strategy related to the event. |\n| `strategy_type` | The connection strategy type related to the event. |\n\n### Example of failed login log event\n\nHere is an example log event for a failed login due to an incorrect password:\n\n```\n{\n  \"date\": \"2020-10-27T19:39:54.699Z\",\n  \"type\": \"fp\",\n  \"description\": \"Wrong email or password.\",\n  \"connection\": \"Username-Password-Authentication\",\n  \"connection_id\": \"con_ABC123\",\n  \"client_id\": \"ABCDEFG123456789\",\n  \"client_name\": \"All Applications\",\n  \"ip\": \"99.xxx.xxx.xxx\",\n  \"user_agent\": \"Chrome 86.0.4240 / Mac OS X 10.15.6\",\n  \"details\": {\n    \"error\": {\n      \"message\": \"Wrong email or password.\"\n    }\n  },\n  \"user_id\": \"auth0|ABC123\",\n  \"user_name\": \"test@test.com\",\n  \"strategy\": \"auth0\",\n  \"strategy_type\": \"database\",\n  \"log_id\": \"123456789\",\n  \"_id\": \"123456789\",\n  \"isMobile\": false\n}\n```\n\n## Indicators of an attack\n\nIdentifying an attack early on may be difficult, but here are some things to look for in your logs along with example search queries:\n\n*   High numbers of failed logins with invalid usernames or login attempts for non-existent users.\n    \n    *   `type:\"fu\"`\n        \n    *   `description:\"missing username parameter\"`\n        \n    *   `description:\"Wrong email or password\"`\n        \n*   Large number of accounts reaching the failed login attempts limit.\n    \n    *   `type:\"limit_wc\"`\n        \n*   A high number of login attempts using a leaked password.\n    \n    *   `type:\"pwd_leak\"`\n        \n\nDuring your investigation take note of IP addresses, applications being targeted, and connections or identity providers used.\n\n## Identify compromised user accounts\n\nTo identify user accounts that may have been compromised you can search for:\n\n*   Successful login events from a suspicious IP address:\n    \n    *   `type:\"s\" AND ip:\"99.xxx.xxx.xxx\"`\n        \n\n## Check compromised user account activity\n\nAfter identifying a compromised user account you'll want to check the account's activity:\n\n*   Search for other log events with the same `user_id`: `user_id:\"auth0|ABC123\"`\n    \n*   Check the `client_name` or `client_id` log event fields to see which applications were accessed. Make a note of when access occurred.\n    \n*   Check for administration access or Auth0 configuration changes\n    \n*   Search for recent Management API calls: `type:\"sapi\"`\n    \n\n## Delete or block users from the dashboard\n\n1.  Go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n    \n2.  Search for the user to delete or block.\n    \n3.  Click the \"**...**\" button on the far right of the user.\n    \n4.  Select **Block** or **Delete** and confirm.",
  "title": "Incident Response: Using Logs",
  "description": "How to use Auth0 logs as part of your incident response plan.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/mobile-implementation-android",
  "markdown": "# Android Mobile Application Implementation (Mobile Apps + API)\n\nThis document is part of the Mobile + API Architecture Scenario and it explains how to implement the mobile application in Android. Please refer to the scenario for information on the implemented solution.\n\n## 1\\. Set Up the Application\n\nDownload a sample project specific to this tutorial to get started.\n\n*   Android Studio 2.3\n*   Android SDK 25\n*   Emulator - Nexus 5X - Android 6.0\n\nShow requirements\n\n### Set the Dependencies\n\nFor this implementation, we will use the following dependencies within the app’s `build.gradle` file:\n\n*   [Auth0.Android](https://github.com/auth0/Auth0.Android): this package enables integration with Auth0 to authenticate users.\n    \n*   [OkHttp](http://square.github.io/okhttp/): this package provides an HTTP application to make requests to the Node.JS API.\n    \n*   [JWTDecode.Android](https://github.com/auth0/JWTDecode.Android): this package will assist with decoding JWTs.\n    \n*   AppCompat: this package lets us use the toolbar widget for navigation in our activities.\n    \n\n```\ndependencies {\n    compile 'com.squareup.okhttp:okhttp:2.7.5'\n    compile 'com.auth0.android:auth0:1.10.0'\n    compile 'com.auth0.android:jwtdecode:1.1.1'\n    compile 'com.android.support:appcompat-v7:25.3.1'\n    testCompile 'junit:junit:4.12'\n}\n```\n\n### Update the Manifest\n\nOpen the application's `AndroidManifest.xml` and add the internet permission:\n\n```\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\nWe’ll also update the application details to utilize the Toolbar widget:\n\n```\n<application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\">\n    </application>\n```\n\n### Set Configuration Values\n\nSet your Auth0 Client ID, Auth0 Domain, and API’s url in the `strings.xml` resource located in `/res/values/strings.xml`:\n\n```\n<resources>\n    <string name=\"app_name\">ExampleCo Timesheets</string>\n    <string name=\"login\">Log in</string>\n    <string name=\"auth0_client_id\">...</string>\n    <string name=\"auth0_domain\">...</string>\n    <string name=\"api_url\">http://10.0.2.2:8080/timesheets</string>\n</resources>\n```\n\nFor this implementation, create directories for activities, models, and utils in the application package.\n\n*   `activities/`: this package will contain the `LoginActivity.java`, `TimeSheetActivity.java`, `FormActivity.java`, and `UserActivity.java`.\n    \n*   `models/`: this package will contain the `TimeSheet.java` and `User.java` data models.\n    \n*   `utils/`: this package will contain the `UserProfileManager.java`, `TimeSheetAdapter.java`, and `ImageTask.java`\n    \n\n### Update the Manifest\n\nOpen the app's `AndroidManifest.xml` and add the `LoginActivity`:\n\n```\n<activity\n            android:name=\"com.auth0.samples.activities.LoginActivity\"\n            android:launchMode=\"singleTask\">\n\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n\n                <data\n                    android:host=\"@string/auth0_domain\"\n                    android:pathPrefix=\"/android/com.auth0.samples/callback\"\n                    android:scheme=\"demo\" />\n            </intent-filter>\n</activity>\n```\n\n### Create the Login Activity\n\nThe `LoginActivity` will handle user authorization and be the initial screen users see. We'll create a `login()` method to initialize a `WebAuthProvider` and start authentication. Ensure you provide the correct scheme, audience, and scope to the `WebAuthProvider`. For this implementation we will use:\n\n*   **scheme**: `demo`\n    \n*   **audience**: `https://api.exampleco.com/timesheet`s (the Node.JS API)\n    \n*   **response\\_type**: `code`\n    \n*   **scope**: `create:timesheets read:timesheets openid profile email offline_access`. These scopes will enable us to `POST` and `GET` to the Node.JS API, as well as retrieve the user profile and a Refresh Token.\n    \n\n```\nprivate void login() {\n        Auth0 auth0 = new Auth0(getString(R.string.auth0_client_id), getString(R.string.auth0_domain));\n        auth0.setOIDCConformant(true);\n\n        WebAuthProvider.init(auth0)\n                .withScheme(\"demo\")\n                .withAudience(\"https://api.exampleco.com/timesheets\")\n                .withResponseType(ResponseType.CODE)\n                .withScope(\"create:timesheets read:timesheets openid profile email offline_access\")\n                .start(\n                    // ...\n                );\n}\n```\n\nIn the `login()` method, upon successful authentication we'll redirect the user to the `TimeSheetActivity`.\n\n```\npackage com.auth0.samples.activities;\n\nimport android.app.Activity;\nimport android.app.Dialog;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.Toast;\n\nimport com.auth0.android.Auth0;\nimport com.auth0.android.authentication.AuthenticationException;\nimport com.auth0.android.jwt.JWT;\nimport com.auth0.android.provider.AuthCallback;\nimport com.auth0.android.provider.ResponseType;\nimport com.auth0.android.provider.WebAuthProvider;\nimport com.auth0.android.result.Credentials;\nimport com.auth0.samples.R;\nimport com.auth0.samples.models.User;\nimport com.auth0.samples.utils.CredentialsManager;\nimport com.auth0.samples.utils.UserProfileManager;\n\npublic class LoginActivity extends Activity {\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.login_activity);\n        Button loginWithTokenButton = (Button) findViewById(R.id.loginButton);\n        loginWithTokenButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                login();\n            }\n        });\n    }\n\n    @Override\n    protected void onNewIntent(Intent intent) {\n        if (WebAuthProvider.resume(intent)) {\n            return;\n        }\n        super.onNewIntent(intent);\n    }\n\n    private void login() {\n        Auth0 auth0 = new Auth0(getString(R.string.auth0_client_id), getString(R.string.auth0_domain));\n        auth0.setOIDCConformant(true);\n\n        WebAuthProvider.init(auth0)\n                .withScheme(\"demo\")\n                .withAudience(\"https://api.exampleco.com/timesheets\")\n                .withResponseType(ResponseType.CODE)\n                .withScope(\"create:timesheets read:timesheets openid profile email\")\n                .start(LoginActivity.this, new AuthCallback() {\n                    @Override\n                    public void onFailure(@NonNull final Dialog dialog) {\n                        runOnUiThread(new Runnable() {\n                            @Override\n                            public void run() {\n                                dialog.show();\n                            }\n                        });\n                    }\n\n                    @Override\n                    public void onFailure(final AuthenticationException exception) {\n                        runOnUiThread(new Runnable() {\n                            @Override\n                            public void run() {\n                                Toast.makeText(LoginActivity.this, \"Error: \" + exception.getMessage(), Toast.LENGTH_SHORT).show();\n                            }\n                        });\n                    }\n\n                    @Override\n                    public void onSuccess(@NonNull final Credentials credentials) {\n                        runOnUiThread(new Runnable() {\n                            @Override\n                            public void run() {\n                                Toast.makeText(LoginActivity.this, \"Log In - Success\", Toast.LENGTH_SHORT).show();\n                            }\n                        });\n                        startActivity(new Intent(LoginActivity.this, TimeSheetActivity.class));\n                    }\n                });\n    }\n}\n```\n\n### Store the Credentials\n\nTo store the credentials received after login, we’ll use the `CredentialsManager` from the Auth0.Android library and [SharedPreferences](https://developer.android.com/reference/android/content/SharedPreferences.html) for storage.\n\nBefore initializing the `WebAuthProvider` in the `login()` method, we can create the `CredentialsManager`. Passing an `AuthenticationAPIClient` to the `CredentialsManager` enables it to refresh the Access Tokens if they are expired.\n\n```\nprivate void login() {\n        Auth0 auth0 = new Auth0(getString(R.string.auth0_client_id), getString(R.string.auth0_domain));\n        auth0.setOIDCConformant(true);\n\n        AuthenticationAPIClient authAPIClient = new AuthenticationAPIClient(auth0);\n        SharedPreferencesStorage sharedPrefStorage = new SharedPreferencesStorage(this);\n        final CredentialsManager credentialsManager = new CredentialsManager(authAPIClient, sharedPrefStorage);\n\n        WebAuthProvider.init(auth0)\n        // ...\n    }\n```\n\nNow update the `login()` method so that credentials are stored via the `CredentialsManager` after a successful authentication.\n\n```\n// ...\n@Override\npublic void onSuccess(@NonNull final Credentials credentials) {\n    runOnUiThread(new Runnable() {\n        @Override\n        public void run() {\n            Toast.makeText(LoginActivity.this, \"Log In - Success\", Toast.LENGTH_SHORT).show();\n        }\n    });\n\n    credentialsManager.saveCredentials(credentials);\n    startActivity(new Intent(LoginActivity.this, TimeSheetActivity.class));\n// ...\n}\n```\n\n## 3\\. Get the User Profile\n\n### Create the User Model\n\nCreate a simple User model that will be utilized by the `UserProfileManager` and `UserActivity`.\n\n```\npackage com.auth0.samples.models;\n\npublic class User {\n    private String email;\n    private String name;\n    private String pictureURL;\n\n    public User(String email, String name, String pictureURL) {\n        this.email = email;\n        this.name = name;\n        this.pictureURL = pictureURL;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPictureURL() {\n        return pictureURL;\n    }\n}\n```\n\n### Store the User Profile\n\nTo handle storing user profile information we'll create a manager class `UserProfileManager`. The `UserProfileManager` will use [SharedPreferences](https://developer.android.com/reference/android/content/SharedPreferences.html) to store data.\n\n```\npackage com.auth0.samples.utils;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\n\nimport com.auth0.android.result.UserProfile;\nimport com.auth0.samples.models.User;\n\npublic class UserProfileManager {\n\n    private static final String PREFERENCES_NAME = \"auth0_user_profile\";\n    private static final String EMAIL = \"email\";\n    private static final String NAME = \"name\";\n    private static final String PICTURE_URL = \"picture_url\";\n\n    public static void saveUserInfo(Context context, User userInfo) {\n        SharedPreferences sp = context.getSharedPreferences(\n                PREFERENCES_NAME, Context.MODE_PRIVATE);\n\n        sp.edit()\n                .putString(EMAIL, userInfo.getEmail())\n                .putString(NAME, userInfo.getName())\n                .putString(PICTURE_URL, userInfo.getPictureURL())\n                .apply();\n    }\n\n    public static User getUserInfo(Context context) {\n        SharedPreferences sp = context.getSharedPreferences(\n                PREFERENCES_NAME, Context.MODE_PRIVATE);\n\n        return new User(\n                sp.getString(EMAIL, null),\n                sp.getString(NAME, null),\n                sp.getString(PICTURE_URL, null)\n        );\n    }\n\n    public static void deleteUserInfo(Context context) {\n        SharedPreferences sp = context.getSharedPreferences(\n                PREFERENCES_NAME, Context.MODE_PRIVATE);\n\n        sp.edit()\n                .putString(EMAIL, null)\n                .putString(NAME, null)\n                .putString(PICTURE_URL, null)\n                .apply();\n    }\n}\n```\n\nNext, update the `login()` method in the `LoginActivity` to retrieve the ID Token and get the user profile from the token with the JWTDecode.Android library. Then store the user profile with the `UserProfileManager`.\n\n```\n// ...\n@Override\npublic void onSuccess(@NonNull final Credentials credentials) {\n    runOnUiThread(new Runnable() {\n        @Override\n        public void run() {\n            Toast.makeText(LoginActivity.this, \"Log In - Success\", Toast.LENGTH_SHORT).show();\n        }\n    });\n\n    credentialsManager.saveCredentials(credentials);\n    JWT jwt = new JWT(credentials.getIdToken());\n    User user = new User(\n            jwt.getClaim(\"email\").asString(),\n            jwt.getClaim(\"name\").asString(),\n            jwt.getClaim(\"picture\").asString()\n    );\n    UserProfileManager.saveUserInfo(LoginActivity.this, user);\n\n    startActivity(new Intent(LoginActivity.this, TimeSheetActivity.class));\n}\n// ...\n```\n\n## 4\\. Display UI Elements Conditionally Based on Scope\n\nTo determine whether a user has permissions to perform certain actions, we can look at the `scope` that was granted to the user during the authentication process. The `scope` will contain a string with all the scopes granted to a user, so to determine whether a particular scope was granted, we simply need to look whether the string of scopes contain the substring for that particular scope.\n\n### Store the Scope\n\nFirst, we can update the `User` class to store the granted scopes, and then provide a helper method, `hasScope()` which can be used to determine whether the granted scopes contain a particular scope:\n\n```\npublic class User {\n    private String email;\n    private String name;\n    private String pictureURL;\n    private String grantedScope;\n\n    public User(String email, String name, String pictureURL, String grantedScope) {\n        this.email = email;\n        this.name = name;\n        this.pictureURL = pictureURL;\n        this.grantedScope = grantedScope;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getGrantedScope() { \n        return grantedScope; \n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPictureURL() {\n        return pictureURL;\n    }\n\n    public Boolean hasScope(String scope) {\n        return grantedScope.contains(scope);\n    }\n}\n```\n\nAlso remember to update the `UserProfileManager` to store the extra field:\n\n```\npublic class UserProfileManager {\n\n    private static final String PREFERENCES_NAME = \"auth0_user_profile\";\n    private static final String EMAIL = \"email\";\n    private static final String NAME = \"name\";\n    private static final String PICTURE_URL = \"picture_url\";\n    private static final String SCOPE = \"scope\";\n\n    public static void saveUserInfo(Context context, User userInfo) {\n        SharedPreferences sp = context.getSharedPreferences(\n                PREFERENCES_NAME, Context.MODE_PRIVATE);\n\n        sp.edit()\n                .putString(EMAIL, userInfo.getEmail())\n                .putString(NAME, userInfo.getName())\n                .putString(PICTURE_URL, userInfo.getPictureURL())\n                .putString(SCOPE, userInfo.getGrantedScope())\n                .apply();\n    }\n\n    public static User getUserInfo(Context context) {\n        SharedPreferences sp = context.getSharedPreferences(\n                PREFERENCES_NAME, Context.MODE_PRIVATE);\n\n        return new User(\n                sp.getString(EMAIL, null),\n                sp.getString(NAME, null),\n                sp.getString(PICTURE_URL, null),\n                sp.getString(SCOPE, null)\n        );\n    }\n\n    public static void deleteUserInfo(Context context) {\n        SharedPreferences sp = context.getSharedPreferences(\n                PREFERENCES_NAME, Context.MODE_PRIVATE);\n\n        sp.edit()\n                .putString(EMAIL, null)\n                .putString(NAME, null)\n                .putString(PICTURE_URL, null)\n                .putString(SCOPE, null)\n                .apply();\n    }\n}\n```\n\nNext, update the `LoginActivity` to pass along the `scope` so it can be stored in the `User` object:\n\n```\n// ...\n@Override\npublic void onSuccess(@NonNull final Credentials credentials) {\n    runOnUiThread(new Runnable() {\n        @Override\n        public void run() {\n            Toast.makeText(LoginActivity.this, \"Log In - Success\", Toast.LENGTH_SHORT).show();\n        }\n    });\n\n    credentialsManager.saveCredentials(credentials);\n    JWT jwt = new JWT(credentials.getIdToken());\n    String scopes = credentials.getScope();\n    User user = new User(\n            jwt.getClaim(\"email\").asString(),\n            jwt.getClaim(\"name\").asString(),\n            jwt.getClaim(\"picture\").asString(),\n            credentials.getScope()\n    );\n    UserProfileManager.saveUserInfo(LoginActivity.this, user);\n\n    startActivity(new Intent(LoginActivity.this, TimeSheetActivity.class));\n}\n// ...\n```\n\nNow, we can display certain UI elements based on whether the user was granted a particular scope. As an example, we have an approval menu item which should only be visible to users who have been granted the `approve:timesheets` scope.\n\nBelow you can see the code from the `BaseActivity` class which checks whether a user has the `approve:timesheets` scope, and based on that will set the visibility of the menu item which displays the approval activity:\n\n```\n// ...\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n    Boolean canApprove = UserProfileManager.getUserInfo(this).hasScope(\"approve:timesheets\");\n    MenuInflater inflater = getMenuInflater();\n    inflater.inflate(R.menu.actions, menu);\n    MenuItem item = menu.findItem(R.id.action_approve);\n    item.setVisible(canApprove);\n    return super.onCreateOptionsMenu(menu);\n}\n// ...\n```\n\n## 5\\. Call the API\n\n### Update the Manifest\n\nOpen the app's `AndroidManifest.xml` and add the `TimeSheetActivity`:\n\n```\n<activity android:name=\"com.auth0.samples.activities.TimeSheetActivity\" />\n```\n\n### Create the Timesheets Activity Layouts\n\nNext create `timesheet_activity.xml`, the layout for the `TimeSheetsActivity`:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <android.support.v7.widget.Toolbar\n        android:id=\"@+id/navToolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:background=\"?attr/colorPrimary\"\n        android:elevation=\"4dp\"\n        android:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\"\n        app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\"/>\n\n    <ListView\n        android:id=\"@+id/timesheetList\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n</LinearLayout>\n```\n\nThe `ListView` widget will contain individual entries which are represented by the `item_entry.xml` layout:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\" android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView\n        android:id=\"@+id/tvUserID\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"UserID\"\n        android:textStyle=\"bold\" />\n    <TextView\n        android:id=\"@+id/tvDate\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Date\" />\n\n    <TextView\n        android:id=\"@+id/tvProjectName\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Project\"\n        android:textStyle=\"italic\" />\n    <TextView\n        android:id=\"@+id/tvHours\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hours\" />\n</LinearLayout>\n```\n\nAnd for the Toolbar navigation on the `TimeSheetActivity`, we’ll create the `timesheet_action_menu.xml` menu resource (`/res/menu/`):\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_profile\"\n        android:title=\"Profile\"\n        app:showAsAction=\"always\" />\n    <item\n        android:id=\"@+id/action_new\"\n        android:title=\"New Timesheet\"\n        app:showAsAction=\"always\" />\n</menu>\n```\n\n### Create the Timesheet Model\n\nCreate a model for working with timesheet data in our views:\n\n```\npackage com.auth0.samples.models;\n\nimport java.util.Date;\n\n/**\n * Created by ej on 7/9/17.\n */\n\npublic class TimeSheet {\n    private String userID;\n    private String projectName;\n    private String date;\n    private double hours;\n    private int ID;\n\n    public TimeSheet(String gUserID, String gProjectName, String gDate, double gHours, int gID) {\n        this.userID = gUserID;\n        this.projectName = gProjectName;\n        this.date = gDate;\n        this.hours = gHours;\n        this.ID = gID;\n    }\n\n    public String getUserID() {\n        return userID;\n    }\n\n    public String getProjectName() {\n        return projectName;\n    }\n\n    public String getDateString() {\n        return date;\n    }\n\n    public double getHours() {\n        return hours;\n    }\n\n    public int getID() {\n        return ID;\n    }\n}\n```\n\n### Create the Timesheet Adapter\n\nThe `TimeSheetAdapter` is a utility class which will take an array of timesheet entries and apply them to the `ListView` on the `TimeSheetActivity`.\n\n```\npackage com.auth0.samples.utils;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.TextView;\nimport com.auth0.samples.R;\nimport com.auth0.samples.models.TimeSheet;\nimport java.util.ArrayList;\n\npublic class TimeSheetAdapter extends ArrayAdapter<TimeSheet> {\n\n    public TimeSheetAdapter(Context context, ArrayList<TimeSheet> timesheets) {\n        super(context, 0, timesheets);\n    }\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n\n        TimeSheet timesheet = getItem(position);\n\n        if (convertView == null) {\n            convertView = LayoutInflater.from(getContext()).inflate(R.layout.item_entry, parent, false);\n        }\n\n        TextView tvUserID = (TextView) convertView.findViewById(R.id.tvUserID);\n        TextView tvDate = (TextView) convertView.findViewById(R.id.tvDate);\n        TextView tvProjectName = (TextView) convertView.findViewById(R.id.tvProjectName);\n        TextView tvHours = (TextView) convertView.findViewById(R.id.tvHours);\n\n        tvUserID.setText(timesheet.getUserID());\n        tvDate.setText(timesheet.getDateString());\n        tvProjectName.setText(timesheet.getProjectName());\n        tvHours.setText(Double.toString(timesheet.getHours()));\n\n        return convertView;\n    }\n}\n```\n\n### Create the Timesheet Activity\n\nThe `TimeSheetActivity` displays the timesheet entries for the logged in user which are stored on the server.\n\n*   The `@string/api_url` is set to `http://10.0.2.2:8080/timesheets` so the Android Emulator can connect to the Node.JS API running on `http://localhost:8080`.\n    \n*   The `callAPI()` method retrieves timesheets from the Node.JS API.\n    \n*   The `processResults()` method takes the JSON response from `callAPI()` and converts it `TimeSheet` objects.\n    \n*   The `onCreateOptionsMenu(`) and `onOptionsItemSelected(`) methods handle the Toolbar widget navigation functionality.\n    \n\n```\npackage com.auth0.samples.activities;\n\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.widget.ListView;\nimport android.widget.Toast;\n\nimport com.auth0.android.Auth0;\nimport com.auth0.android.authentication.AuthenticationAPIClient;\nimport com.auth0.android.authentication.storage.CredentialsManager;\nimport com.auth0.android.authentication.storage.CredentialsManagerException;\nimport com.auth0.android.authentication.storage.SharedPreferencesStorage;\nimport com.auth0.android.callback.BaseCallback;\nimport com.auth0.android.result.Credentials;\nimport com.auth0.samples.R;\nimport com.auth0.samples.utils.TimeSheetAdapter;\nimport com.auth0.samples.models.TimeSheet;\nimport com.squareup.okhttp.Callback;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\n\npublic class TimeSheetActivity extends AppCompatActivity {\n\n    private ArrayList<TimeSheet> timesheets = new ArrayList<>();\n\n    private String accessToken;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.timesheet_activity);\n        Toolbar navToolbar = (Toolbar) findViewById(R.id.navToolbar);\n        setSupportActionBar(navToolbar);\n\n        Auth0 auth0 = new Auth0(getString(R.string.auth0_client_id), getString(R.string.auth0_domain));\n        auth0.setOIDCConformant(true);\n\n        AuthenticationAPIClient authAPIClient = new AuthenticationAPIClient(auth0);\n        SharedPreferencesStorage sharedPrefStorage = new SharedPreferencesStorage(this);\n\n        CredentialsManager credentialsManager = new CredentialsManager(authAPIClient, sharedPrefStorage);\n        credentialsManager.getCredentials(new BaseCallback<Credentials, CredentialsManagerException>() {\n            @Override\n            public void onSuccess(Credentials payload) {\n                accessToken = payload.getAccessToken();\n                callAPI();\n            }\n\n            @Override\n            public void onFailure(CredentialsManagerException error) {\n                Toast.makeText(TimeSheetActivity.this, \"Error: \" + error.getMessage(), Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n\n    private void callAPI() {\n        final Request.Builder reqBuilder = new Request.Builder()\n                .get()\n                .url(getString(R.string.api_url))\n                .addHeader(\"Authorization\", \"Bearer \" + accessToken);\n\n        OkHttpClient client = new OkHttpClient();\n        Request request = reqBuilder.build();\n        client.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(Request request, IOException e) {\n                Log.e(\"API\", \"Error: \", e);\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        Toast.makeText(TimeSheetActivity.this, \"An error occurred\", Toast.LENGTH_SHORT).show();\n                    }\n                });\n            }\n\n            @Override\n            public void onResponse(final Response response) throws IOException {\n                timesheets = processResults(response);\n                final TimeSheetAdapter adapter = new TimeSheetAdapter(TimeSheetActivity.this, timesheets);\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (response.isSuccessful()) {\n                            ListView listView = (ListView) findViewById(R.id.timesheetList);\n                            listView.setAdapter(adapter);\n                            adapter.addAll(timesheets);\n                        } else {\n                            Toast.makeText(TimeSheetActivity.this, \"API call failed.\", Toast.LENGTH_SHORT).show();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    private ArrayList<TimeSheet> processResults (Response response) {\n        ArrayList<TimeSheet> timesheets = new ArrayList<>();\n        try {\n            String jsonData = response.body().string();\n            if (response.isSuccessful()) {\n                JSONArray timesheetJSONArray = new JSONArray(jsonData);\n                for (int i = 0; i < timesheetJSONArray.length(); i++) {\n                    JSONObject timesheetJSON = timesheetJSONArray.getJSONObject(i);\n                    String userID = timesheetJSON.getString(\"user_id\");\n                    String projectName = timesheetJSON.getString(\"project\");\n                    String dateStr = timesheetJSON.getString(\"date\");\n                    Double hours = timesheetJSON.getDouble(\"hours\");\n                    int id = timesheetJSON.getInt(\"id\");\n\n                    TimeSheet timesheet = new TimeSheet(userID, projectName, dateStr, hours, id);\n                    timesheets.add(timesheet);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n        return timesheets;\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.timesheet_action_menu, menu);\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.action_new:\n                startActivity(new Intent(TimeSheetActivity.this, FormActivity.class));\n                break;\n            case R.id.action_profile:\n                startActivity(new Intent(TimeSheetActivity.this, UserActivity.class));\n                break;\n            default:\n                return super.onOptionsItemSelected(item);\n        }\n        return true;\n    }\n}\n```\n\n## 6\\. View the User Profile\n\nTo display the logged in user’s profile we’ll create the `UserActivity`, a corresponding `user_activity.xml` layout, and the `user_action_menu.xml` for the Toolbar navigation. The view will display the user’s name, email, and profile picture.\n\n### Update the Manifest\n\nOpen the app's `AndroidManifest.xml` and add the `UserActivity`:\n\n```\n<activity android:name=\"com.auth0.samples.activities.UserActivity\" />\n```\n\n#### Create the User Activity Layouts\n\nNext create `user_activity.xml`, the layout for the `UserActivity`, with an `ImageView` for the profile picture and `TextViews` for the user's name and email.\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <android.support.v7.widget.Toolbar\n        android:id=\"@+id/navToolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:background=\"?attr/colorPrimary\"\n        android:elevation=\"4dp\"\n        android:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\"\n        app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\"/>\n\n    <ImageView\n        android:id=\"@+id/ivPicture\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        app:srcCompat=\"@android:color/darker_gray\" />\n\n    <TextView\n        android:id=\"@+id/tvName\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Name\"\n        android:textSize=\"24sp\" />\n\n    <TextView\n        android:id=\"@+id/tvEmail\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Email\"\n        android:textSize=\"24sp\" />\n</LinearLayout>\n```\n\nAnd create the `user_actions_menu.xml` for the `UserActivity` Toolbar:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_view\"\n        android:title=\"View Timesheets\"\n        app:showAsAction=\"always\" />\n    <item\n        android:id=\"@+id/action_new\"\n        android:title=\"New Timesheet\"\n        app:showAsAction=\"always\" />\n</menu>\n```\n\n### Load the Profile Picture from URL\n\nIn order to load the user profile picture from the URL, create a task which extends `AsyncTask` and executes in the background.\n\n```\npackage com.auth0.samples.utils;\n\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.os.AsyncTask;\nimport android.util.Log;\nimport android.widget.ImageView;\n\nimport java.io.InputStream;\nimport java.net.URL;\n\npublic class ImageTask extends AsyncTask<String, Void, Bitmap> {\n\n    private ImageView bmImage;\n\n    public ImageTask(ImageView bmImage) {\n        this.bmImage = bmImage;\n    }\n\n    protected Bitmap doInBackground(String... urls) {\n        String urldisplay = urls[0];\n        Bitmap mIcon11 = null;\n\n        try {\n            InputStream in = new URL(urldisplay).openStream();\n            mIcon11 = BitmapFactory.decodeStream(in);\n        } catch (Exception e) {\n            Log.e(\"Error\", e.getMessage());\n            e.printStackTrace();\n        }\n        return mIcon11;\n    }\n\n    protected void onPostExecute(Bitmap result) {\n        bmImage.setImageBitmap(result);\n    }\n}\n```\n\n### Create the User Activity\n\nIn the `onCreate()` method we'll retrieve the user information from the `UserProfileManager` and set the values in the view. As before, the `onCreateOptionsMenu()` and `onOptionsItemSelected()` methods handle the Toolbar widget navigation functionality.\n\n```\npackage com.auth0.samples.activities;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport com.auth0.samples.R;\nimport com.auth0.samples.utils.ImageTask;\nimport com.auth0.samples.utils.UserProfileManager;\n\npublic class UserActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.user_activity);\n        Toolbar navToolbar = (Toolbar) findViewById(R.id.navToolbar);\n        setSupportActionBar(navToolbar);\n\n        TextView tvName = (TextView) findViewById(R.id.tvName);\n        TextView tvEmail = (TextView) findViewById(R.id.tvEmail);\n\n        tvName.setText(UserProfileManager.getUserInfo(this).getName());\n        tvEmail.setText(UserProfileManager.getUserInfo(this).getEmail());\n\n        new ImageTask((ImageView) findViewById(R.id.ivPicture))\n                .execute(UserProfileManager.getUserInfo(this).getPictureURL());\n\n                UserProfileManager.getUserInfo(this).getName();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu items for use in the action bar\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.user_action_menu, menu);\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.action_new:\n                startActivity(new Intent(UserActivity.this, FormActivity.class));\n                break;\n            case R.id.action_view:\n                startActivity(new Intent(UserActivity.this, TimeSheetActivity.class));\n                break;\n            default:\n                // If we got here, the user's action was not recognized.\n                // Invoke the superclass to handle it.\n                return super.onOptionsItemSelected(item);\n\n        }\n        return true;\n    }\n}\n```\n\n## 7\\. Form for New Timesheets\n\nNext create the `FormActivity` and layout to handle creating new timesheet entries.\n\n### Update the Manifest\n\nOpen the app's `AndroidManifest.xml` and add the `FormActivity`:\n\n```\n<activity android:name=\"com.auth0.samples.activities.FormActivity\" />\n```\n\n### Create the Form Activity Layouts\n\nCreate the `form_activity.xml` layout with `EditText` for the project name and hours worked inputs, and a `DatePicker` for the day worked.\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/mainForm\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    android:weightSum=\"1\">\n\n    <android.support.v7.widget.Toolbar\n        android:id=\"@+id/navToolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:background=\"?attr/colorPrimary\"\n        android:elevation=\"4dp\"\n        android:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\"\n        app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\"/>\n\n    <EditText\n        android:id=\"@+id/editProjectName\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:ems=\"10\"\n        android:hint=\"Project Name\"\n        android:inputType=\"textPersonName\" />\n\n    <EditText\n        android:id=\"@+id/editHours\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:ems=\"10\"\n        android:hint=\"Hours Worked\"\n        android:inputType=\"number|numberDecimal\" />\n\n    <DatePicker\n        android:id=\"@+id/datePicker\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"191dp\"\n        android:layout_weight=\"0.93\" />\n\n    <Button\n        android:id=\"@+id/submitTimeSheetButton\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Submit\" />\n</LinearLayout>\n```\n\nAnd create the `form_actions_menu.xml` for the `FormActivity` Toolbar:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_profile\"\n        android:title=\"Profile\"\n        app:showAsAction=\"always\" />\n    <item\n        android:id=\"@+id/action_view\"\n        android:title=\"View Timesheets\"\n        app:showAsAction=\"always\" />\n</menu>\n```\n\n### Create the Form Activity\n\n*   The `@string/api_url` is set to `http://10.0.2.2:8080/timesheets` so the Android Emulator can connect to the Node.JS API running on `http://localhost:8080`.\n    \n*   The `onCreate()` method initializes the form and collects the input for the `postAPI()` method when the submit button is pressed.\n    \n*   The `postAPI()` method will send the user input retrieved from the form to the Node.JS API in JSON format.\n    \n*   The `clearForm()` method clears the input forms.\n    \n*   The `onCreateOptionsMenu()` and `onOptionsItemSelected()` methods handle the Toolbar widget navigation functionality.\n    \n\n```\npackage com.auth0.samples.activities;\n\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.DatePicker;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\nimport com.auth0.android.Auth0;\nimport com.auth0.android.authentication.AuthenticationAPIClient;\nimport com.auth0.android.authentication.storage.CredentialsManager;\nimport com.auth0.android.authentication.storage.CredentialsManagerException;\nimport com.auth0.android.authentication.storage.SharedPreferencesStorage;\nimport com.auth0.android.callback.BaseCallback;\nimport com.auth0.android.result.Credentials;\nimport com.auth0.samples.R;\nimport com.squareup.okhttp.Callback;\nimport com.squareup.okhttp.MediaType;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.RequestBody;\nimport com.squareup.okhttp.Response;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class FormActivity extends AppCompatActivity {\n\n    private static final MediaType MEDIA_TYPE_JSON = MediaType.parse(\"application/json; charset=utf-8\");\n\n    private String accessToken;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.form_activity);\n        Toolbar navToolbar = (Toolbar) findViewById(R.id.navToolbar);\n        setSupportActionBar(navToolbar);\n\n        Auth0 auth0 = new Auth0(getString(R.string.auth0_client_id), getString(R.string.auth0_domain));\n        auth0.setOIDCConformant(true);\n\n        AuthenticationAPIClient authAPIClient = new AuthenticationAPIClient(auth0);\n        SharedPreferencesStorage sharedPrefStorage = new SharedPreferencesStorage(this);\n\n        CredentialsManager credentialsManager = new CredentialsManager(authAPIClient, sharedPrefStorage);\n        credentialsManager.getCredentials(new BaseCallback<Credentials, CredentialsManagerException>() {\n            @Override\n            public void onSuccess(Credentials payload) {\n                accessToken = payload.getAccessToken();\n            }\n\n            @Override\n            public void onFailure(CredentialsManagerException error) {\n                Toast.makeText(FormActivity.this, \"Error: \" + error.getMessage(), Toast.LENGTH_SHORT).show();\n            }\n        });\n\n        Button submitTimeSheetButton = (Button) findViewById(R.id.submitTimeSheetButton);\n        final EditText editProjectName = (EditText) findViewById(R.id.editProjectName);\n        final EditText editHours = (EditText) findViewById(R.id.editHours);\n        final DatePicker datePicker = (DatePicker) findViewById(R.id.datePicker);\n\n        submitTimeSheetButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                int day = datePicker.getDayOfMonth();\n                int month = datePicker.getMonth();\n                int year =  datePicker.getYear();\n\n                Calendar calendar = Calendar.getInstance();\n                calendar.set(year, month, day);\n\n                postAPI(\n                        editProjectName.getText().toString(),\n                        calendar.getTime(),\n                        editHours.getText().toString()\n                );\n            }\n        });\n    }\n\n    private void postAPI(String projectName, Date date, String hours) {\n\n        JSONObject postBody = new JSONObject();\n        try {\n            postBody.put(\"project\", projectName);\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n        try {\n            postBody.put(\"date\", date);\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n        try {\n            postBody.put(\"hours\", hours);\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n        String postStr = postBody.toString();\n\n        final Request.Builder reqBuilder = new Request.Builder()\n                .post(RequestBody.create(MEDIA_TYPE_JSON, postStr))\n                .url(getString(R.string.api_url))\n                .addHeader(\"Authorization\", \"Bearer \" + accessToken);\n\n        OkHttpClient client = new OkHttpClient();\n        Request request = reqBuilder.build();\n\n        client.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(Request request, IOException e) {\n                Log.e(\"API\", \"Error: \", e);\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        Toast.makeText(FormActivity.this, \"An error occurred\", Toast.LENGTH_SHORT).show();\n                    }\n                });\n            }\n\n            @Override\n            public void onResponse(final Response response) throws IOException {\n                final String resBody = response.body().string();\n\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (response.isSuccessful()) {\n                            clearForm((ViewGroup) findViewById(R.id.mainForm));\n                            Intent intent = new Intent(FormActivity.this, TimeSheetActivity.class);\n                            FormActivity.this.startActivity(intent);\n                        } else {\n                            Toast.makeText(FormActivity.this, \"Timesheet creation failed.\", Toast.LENGTH_SHORT).show();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    private void clearForm(ViewGroup group) {\n        for (int i = 0, count = group.getChildCount(); i < count; ++i) {\n            View view = group.getChildAt(i);\n            if (view instanceof EditText) {\n                ((EditText)view).setText(\"\");\n            }\n\n            if(view instanceof ViewGroup && (((ViewGroup)view).getChildCount() > 0))\n                clearForm((ViewGroup)view);\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.form_action_menu, menu);\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.action_view:\n                startActivity(new Intent(FormActivity.this, TimeSheetActivity.class));\n                break;\n            case R.id.action_profile:\n                startActivity(new Intent(FormActivity.this, UserActivity.class));\n                break;\n            default:\n                return super.onOptionsItemSelected(item);\n\n        }\n        return true;\n    }\n}\n```\n\n## Test the App\n\nBefore continuing, ensure you have [implemented the Node.JS API](https://auth0.com/docs/architecture-scenarios/application/mobile-api/api-implementation-nodejs).\n\n1.  Start the API by navigating to the API's directory in your terminal and entering the `node server` command.\n    \n2.  Open the mobile app in Android Studio and press the **Run** button.\n    \n3.  Select the Nexus 5X API 23 virtual device.\n    \n4.  Once the emulator has loaded the mobile app, you can login user then, create and view timesheet entries from the running Node.JS API.\n    \n\nThat's it! You are done!",
  "title": "Android Mobile Application Implementation (Mobile Apps + API)",
  "description": "The Android implementation of the API for the Mobile + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/03-troubleshooting",
  "markdown": "# Auth0 ASP.NET Core Web API SDK Quickstarts: Troubleshooting\n\nThis document will help you troubleshoot your configuration if you get 401 (Unauthorized) response from your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nIf the configuration of your JSON Web Token (JWT) middleware does not match the JWT that was passed to the API, you get a 401 (Unauthorized) response from your API.\n\nThis document will help you troubleshoot your JWT middleware configuration.\n\n## Check the Token Validation\n\nThere are 5 criteria for validating a JWT token.\n\n1.  **Is the token formed properly?** Check if the structure of the token matches the structure of a JSON Web Token. Read more about the [JSON Web Token structure](https://auth0.com/docs/jwt#what-is-the-json-web-token-structure-).\n    \n2.  **Has the token been tampered with?** The last part of a JWT is the signature. The signature is used to verify that the token was signed by the sender and not altered in any way.\n    \n3.  **Has the token been received in its validity period?** JWTs are only valid for a specified time, defined in the `exp` claim.\n    \n4.  **Is the token coming from the intended Authority?** Check the following two criteria:\n    \n    *   **Signature verification**: Check if the JWT is correctly signed with the key issued by the issuing authority.\n        \n    *   **Issuer value**: The Issuer is defined in the `iss` claim. Check if this claim matches up with what your application expects.\n        \n5.  **Is the token intended for the current application?** Check if the `aud` claim of the JWT matches with what your application expects.\n    \n\n## Inspect a Token\n\nYou can inspect a JWT with the [JWT.io](https://jwt.io/) website. Use the debugger on the website to check if your JWT is well formed. You can also inspect values of the various claims.\n\nThe screenshot below shows the following information:\n\n*   The token is signed with the RS256 algorithm\n*   The issuer of the token is `https://jerrie.auth0.com/`\n*   The audience of the token is `https://rs256.test.api`\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-rs256.png)\n\nCheck if the values of the JWT token match exactly the values in your JWT middleware registration. This includes the trailing slash for the Issuer.\n\n```\nvar options = new JwtBearerOptions\n{\n    Audience = \"https://rs256.test.api\",\n    Authority = \"https://jerrie.auth0.com/\"\n};\napp.UseJwtBearerAuthentication(options);\n```\n\nIf your token is signed with the HS256 algorithm, the debugger view is different.\n\nThe screenshot below shows the following information:\n\n*   The token is signed with the HS256 algorithm\n*   The issuer of the token is `https://jerrie.auth0.com/`\n*   The audience of the token is `https://hs256.test.api`\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-hs256.png)\n\nIf your token is signed with the HS256 algorithm, the middleware needs to be configured in the following way:\n\n```\nvar options = new JwtBearerOptions\n{\n    TokenValidationParameters =\n    {\n        ValidIssuer = \"https://jerrie.auth0.com/\",\n        ValidAudience = \"https://hs256.test.api\",\n        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\"your api secret\"))\n    }\n};\napp.UseJwtBearerAuthentication(options);\n```\n\n## Debug Configuration Issues Using Log Files\n\nTo debug potential configuration issues, inspect the log files for your application. For more information, refer to the [Logging in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging) document.\n\nIn this example, we run the application from the command line and inspect the console log output.\n\n### 1\\. Are you passing the JWT in the Authorization header?\n\nCheck if you are passing the JWT as a Bearer token in the `Authorization` header of the HTTP request.\n\nIf you are not passing the token, you will see the following warning:\n\n![Not specifying an Authorization Header](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/troubleshoot-no-authorization-header.png)\n\nLook for the following warning message:\n\n```\nAuthorization failed for the request at filter 'Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter'\n```\n\nTo resolve this issue, make sure you are passing the JWT as the Bearer token in the `Authorization` header of the HTTP request.\n\n### 2\\. Did you configure the JWT middleware for the correct signing algorithm?\n\nMake sure that the [signing algorithm](https://auth0.com/docs/tokens/concepts/signing-algorithms) you used to sign your token matches the signing algorithm configured in your middleware.\n\nThe following screenshots show two messages:\n\n*   A warning message: \"Authorization failed...\"\n*   A message with more information\n\nThe following example shows that the JWT is signed with the HS256 algorithm and the middleware is configured to expect RS256 tokens:\n\n![Wrong Signature Configured](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/troubleshoot-wrong-signature-rs256.png)\n\nLook for the following warning message:\n\n```\nSystem.ArgumentException: IDX10634: Unable to create the SignatureProvider.\n\nSignatureAlgorithm: 'HS256', SecurityKey: 'Microsoft.IdentityModel.Tokens.RsaSecurityKey' is not supported.\n```\n\nThe following example shows that the JWT is signed with the RS256 algorithm and the middleware is configured to expect HS256 tokens:\n\n![Wrong Signature Configured](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/troubleshoot-wrong-signature-hs256.png)\n\nLook for the following warning message:\n\n```\nBearer was not authenticated. Failure message: IDX10501: Signature validation failed. Unable to match 'kid': 'NTF...'\n```\n\nTo resolve this issue, make sure that the algorithm for the JWT matches with the configuration of your middleware.\n\n### 3\\. Has your token expired?\n\nEach JSON Web Token is valid until the time defined in the `exp` claim runs out. If you send an expired token, the token will be rejected:\n\n![Token Expired](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/troubleshoot-token-expired.png)\n\nLook for the following error message:\n\n```\nIDX10223: Lifetime validation failed. The token is expired\n```\n\nTo resolve this issue, check if the token you are sending has not expired.\n\n### 4\\. Did you configure the correct issuer?\n\nThe Issuer specified in your token must match exactly with your JWT middleware configuration.\n\n![Issuer Validation Failed](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/troubleshoot-issuer-validation-failed.png)\n\nLook for the following warning message:\n\n```\nIDX10205: Issuer validation failed.\n```\n\nTo resolve this issue, make sure that you specify the correct issuer for your JWT middleware.\n\nFor HS256 signed tokens, specify the correct value for the `ValidIssuer` property of `TokenValidationParameters`.\n\n### 5\\. Does the audience match your JWT middleware configuration?\n\nCheck if the audience specified in your token matches your JWT middleware configuration.\n\n![Audience Validation Failed](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/troubleshoot-audience-validation-failed.png)\n\nLook for the following error message:\n\n```\nIDX10214: Audience validation failed\n```\n\nTo resolve this issue, make sure you specify the correct audience for your JWT middleware. Depending on how your JWT middleware was configured, do the following:\n\n*   Set the correct `Audience` property of `JwtBearerOptions`\n*   Set the `ValidAudience` property of `TokenValidationParameters`",
  "title": "Auth0 ASP.NET Core Web API SDK Quickstarts: Troubleshooting",
  "description": "This document will help you troubleshoot your configuration if you get 401 (Unauthorized) response from your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing",
  "markdown": "# Get Management API Access Tokens for Testing\n\nThe first time you get a test token for the Management API is when you complete the configuration in the Auth0 Dashboard. You won't have to do this again unless you create a new tenant. We recommend that you create a test token exclusively for authorizing access to the Management API instead of reusing another one you might have.\n\n## Prerequisites\n\n*   [Create Machine-to-Machine Applications for Testing](https://auth0.com/docs/get-started/apis/create-m2m-app-test)\n    \n\n## Get Access Tokens Manually\n\n1.  On your Auth0 Dashboard, navigate to **Applications > APIs >** [Auth0 Management API](https://manage.auth0.com/#/apis/management/explorer). Select the **API Explorer** tab and locate an auto-generated token in the **Token** section.\n    \n2.  Select the **Copy** icon to the right of the token. You can now make authorized calls to the [Management API](https://auth0.com/docs/api/management/v2) using this token.\n    \n    ![APIs - Management API access tokens - Testing - Copy token](https://images.ctfassets.net/cdy7uua7fh8z/3Y4I9YJR77j73FCYDiegnC/44f32f76d27357bc39aad9ee7c4d5561/management-api-access-token.png)\n3.  Optionally set the expiration time. By default, the token has an expiration time of 86400 seconds, which is 24 hours. After that period, the token expires and can no longer be used. To change the expiration time, update **Token Expiration (Seconds)** and click **Update & Regenerate Token**.\n    \n\n## Use Access Tokens for Testing\n\nYou can use the Access Token you just created for testing purposes to manually call an endpoint through the [Management API Explorer](https://auth0.com/docs/api/management/v2).\n\n1.  Visit the [Management API Explorer](https://auth0.com/docs/api/management/v2#!), and select the **Set API Token** button.\n    \n2.  Complete the **API Token** field. Additional information then displays on the popup, such as the scopes granted to the application.\n    \n3.  Select **Set Token** to save your token and close the popup. Notice that the Set API Token button now displays as **Authorized**.\n    \n4.  To begin testing, navigate to an endpoint you wish to call and enter any required or optional parameters in the fields to the right. Then, select **Test Endpoint**.\n    \n    ![APIs - Management API access tokens - Testing - Set token](https://images.ctfassets.net/cdy7uua7fh8z/4GWcJnm3NcxK7ngamrorZB/6ac652093de36117c034353be38657c9/Management_API_Explorer.png)\n\n## Learn more\n\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Applications in Auth0](https://auth0.com/docs/get-started/applications)",
  "title": "Get Management API Access Tokens for Testing",
  "description": "Learn how to get an Access Token manually for testing purposes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/webapi-owin/03-troubleshooting",
  "markdown": "# Auth0 ASP.NET Web API (OWIN) SDK Quickstarts: Troubleshooting\n\nThis document will help you troubleshoot your configuration if you get a 401 (Unauthorized) response from your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nIf you configured the JWT middleware correctly, you will be able to get proper responses from your API when you make requests. However, in the case where you get a 401 (Unauthorized) response from your API, it is because the configuration of your JWT middleware does not match with the JWT which was passed.\n\nThis document will help you troubleshoot your JWT middleware configuration.\n\n## How does a token get validated?\n\nIn terms of validating a JWT, there are various things to consider:\n\n1.  **Is the token well-formed?** In other words, is this token conforming to the structure of a JSON Web Token (JWT)? To get more information on the structure of a JWT, please refer to [this section on the structure of a JWT](https://auth0.com/docs/jwt#what-is-the-json-web-token-structure-)\n    \n2.  **Has the token been tampered with?** The last part of a JWT is the signature. The signature is used to verify that the token was in fact signed by the sender and not altered in any way.\n    \n3.  **Has the token been received in its validity period?** JWTs are only valid for a specified time period (as expressed in the `exp` claim).\n    \n4.  **Is the token coming from the intended Authority?** This consists of 2 parts\n    \n    *   **Signature Verification**: Can we confirm that the JWT is correctly signed using the key issued by the issuing authority?\n        \n    *   **Issuer Value**: The Issuer is defined in the `iss` claim. Once again does this claim match up with what your application expects?\n        \n5.  **Is the token intended for the current application?** So does the `aud` claim of the JWT match with what your application is expecting?\n    \n\n## Inspecting a token\n\nA quick way to inspect a JWT is by using the [JWT.io](https://jwt.io/) website. It has a handy debugger which allows you to quickly check that a JWT is well-formed, and also inspect the values of the various claims.\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-rs256.png)\n\nIn the screenshot above you can see that the token was signed using the **RS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://quickstarts/api**.\n\nSo in other words these values in your JWT middleware registration must match **exactly** - including the trailing slash for the Issuer, such as\n\n```\nvar keyResolver = new OpenIdConnectSigningKeyResolver(\"https://jerrie.auth0.com/\");\napp.UseJwtBearerAuthentication(\n    new JwtBearerAuthenticationOptions\n    {\n        AuthenticationMode = AuthenticationMode.Active,\n        TokenValidationParameters = new TokenValidationParameters()\n        {\n            ValidAudience = \"https://quickstarts/api\",\n            ValidIssuer = \"https://jerrie.auth0.com/\",\n            IssuerSigningKeyResolver = (token, securityToken, kid, parameters) => keyResolver.GetSigningKey(kid)\n        }\n    });\n```\n\nFor a token signed using HS256, the debugger view will look a little different:\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-hs256.png)\n\nIn the screenshot above you can see that the token was signed using the **HS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://quickstarts/api/hs256**.\n\nIn this case, the middleware needs to be configured as follows:\n\n```\napp.UseJwtBearerAuthentication(\n    new JwtBearerAuthenticationOptions\n    {\n        AuthenticationMode = AuthenticationMode.Active,\n        AllowedAudiences = new[] { \"https://quickstarts/api/hs256\" },\n        IssuerSecurityKeyProviders = new IIssuerSecurityKeyProvider[]\n        {\n            new SymmetricKeyIssuerSecurityKeyProvider(\"https://jerrie.auth0.com/\",\n              Encoding.UTF8.GetBytes(\"your api secret\"))\n        }\n    });\n```\n\n## Using the log files to debug configuration issues\n\nIn order to inspect the log message which are generated by the OWIN middleware, you need to set the logging level to Verbose. So in your `web.config` file, add the following:\n\n```\n<system.diagnostics>\n  <switches>\n    <add name=\"Microsoft.Owin\" value=\"Verbose\" />\n  </switches>\n</system.diagnostics>\n```\n\nThis will log all OWIN log messages to the Output window in Visual Studio when running your application in Debug Mode.\n\n### 1\\. Are you actually passing the JWT in the Authorization header?\n\nThe first thing is to ensure that you actually pass along the JWT as a Bearer token in the Authorization header of the request. If you get a 401 (Unauthorized) response from your Web API, but you do not see any other error messages being logged to the Output Window, then most likely you are simply not sending the JWT in the Authorization header of the request.\n\nTo resolve this issue, ensure that you send the JWT as a bearer token in the Authorization header.\n\n## 2\\. Did you configure the JWT middleware for the correct signing algorithm?\n\nAnother common mistake is that your tokens are signed using the HS256 [signing algorithm](https://auth0.com/docs/tokens/concepts/signing-algorithms), but your middleware is configured for RS256 - or vice versa.\n\nIn the following screenshot, you can see that we get an error message that the signature validation failed. This is because the JWT middleware was configured to handle tokens signed using RS256, but instead, a token was sent which was signed using HS256.\n\n![Wrong Signature Configured](https://auth0.com/docs/media/articles/server-apis/webapi-owin/troubleshoot-wrong-signature-rs256.png)\n\nThe relevant error message to look for is the following:\n\n```\nIDX10503: Signature validation failed. Keys tried: 'null'.\n```\n\nIn the case where you configured your middleware for HS256, but you are sending an RS256 signed token the error message will be different:\n\n![Wrong Signature Configured](https://auth0.com/docs/media/articles/server-apis/webapi-owin/troubleshoot-wrong-signature-hs256.png)\n\nIn this case, the relevant error message to look for is the following:\n\n```\nIDX10500: Signature validation failed. Unable to resolve SecurityKeyIdentifier...\n```\n\nTo resolve this issue, be sure that the signature algorithm with which the JWT was signed matches how your middleware is configured.\n\n## 3\\. Has your token expired?\n\nEach JSON Web Token is only valid until the time specified in the `exp` claim. If you and send a token which has expired, the token will be rejected:\n\n![Token Expired](https://auth0.com/docs/media/articles/server-apis/webapi-owin/troubleshoot-token-expired.png)\n\nThe error message to look for is the following:\n\n```\nExpired bearer token received\n```\n\nThe resolve this issue, be sure to send a token which has not expired.\n\n### exp\n\nThe value of the `exp` claim is a numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time. If you want to see the actual date/time for the value, you can visit [EpochConverter](http://www.epochconverter.com/).\n\n## 4\\. Did you configure the correct Issuer?\n\nThe Issuer specified in your token must match exactly with what is configured in your JWT middleware.\n\n![Issuer Validation Failed](https://auth0.com/docs/media/articles/server-apis/webapi-owin/troubleshoot-issuer-validation-failed.png)\n\nThe error message to look for is the following:\n\n```\nIDX10205: Issuer validation failed.\n```\n\nThe resolve this issue, ensure that you specify the correct issuer for your JWT middleware. If your middleware is configured for RS256 signed tokens, this means ensuring that you have specified the correct value for the `TokenValidationParameters.ValidIssuer` property of the `JwtBearerAuthenticationOptions` parameter passed when calling `app.UseJwtBearerAuthentication(...)`.\n\nIf your middleware is configured for HS256 signed tokens, this means ensuring that you have passed the correct value to the constructor of `SymmetricKeyIssuerSecurityTokenProvider` which was configured as one of the `IssuerSecurityTokenProviders` for the `JwtBearerAuthenticationOptions`.\n\n## 5\\. Does the audience match?\n\nThe audience specified in your token must match exactly with what is configured in your JWT middleware.\n\n![Audience Validation Failed](https://auth0.com/docs/media/articles/server-apis/webapi-owin/troubleshoot-audience-validation-failed.png)\n\nThe error message to look for is the following:\n\n```\nIDX10214: Audience validation failed.\n```\n\nThe resolve this issue, ensure that you specify the correct audience for your JWT middleware. If your middleware is configured for RS256 signed tokens, this means ensuring that you have specified the correct value for the `ValidAudience` property of the `TokenValidationParameters`\n\nIf your middleware is configured for HS256 signed tokens, this means ensuring that you have added the correct audience to the list of `AllowedAudiences` for the `JwtBearerAuthenticationOptions`.",
  "title": "Auth0 ASP.NET Web API (OWIN) SDK Quickstarts: Troubleshooting",
  "description": "This document will help you troubleshoot your configuration if you get a 401 (Unauthorized) response from your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens",
  "markdown": "# Validate JSON Web Tokens\n\nAuth0 uses JSON Web Token (JWT) for secure data transmission, authentication, and authorization. Tokens should be parsed and validated in regular web, native, and single-page applications to make sure the token isn’t compromised and the signature is authentic. Tokens should be verified to decrease security risks if the token has been, for example, tampered with, misused, or has expired. JWT validation checks the structure, claims, and signature to assure the least amount of risk.\n\nThe JWT token signature is generated using a Signing Algorithm. While tokens can use multiple signing algorithms, Auth0 supports RS256, RSA encryption with SHA-256 hash function or HS256, HMAC message authentication code (MAC) with SHA-256. To learn more about Auth0’s recommended algorithm, read [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms).\n\nWhen validating a JWT, generally, the current hash value and the original hash value are parsed, or decoded, then compared to verify the token signature is authentic. All of our [backend API quickstarts](https://auth0.com/docs/quickstart/backend) use SDKs that perform JWT validation and parsing for you.\n\n## Parse and validate\n\nIf you are not using one of our SDKs that perform JWT validation and parsing for you, you can parse and validate a JWT by:\n\n*   Using any existing middleware for your web framework.\n    \n*   Choosing a third-party library from JWT.io.\n    \n*   Manually implementing the checks described in [specification RFC 7519 > 7.2 Validating a JWT](https://tools.ietf.org/html/rfc7519#section-7.2).\n    \n\nWe strongly recommend that you use middleware or one of the existing open source third-party libraries to parse and validate JWTs. At [JWT.io](https://jwt.io/#libraries-io), you can find libraries for various platforms and languages, such as .NET, Python, Java, Ruby, Objective-C, Swift, and PHP.\n\n## Middleware\n\nMany web frameworks, such as [ASP.NET Core](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi), include JWT middleware that handles JWT validation. Typically, this is the best route to take because the middleware integrates well with the framework's overall authentication mechanisms.\n\n## Third-party libraries\n\nIf you choose a third-party library, choose a library that supports the signing algorithm you selected when you registered your application or API with Auth0. Also, be aware that not all libraries validate all JWT claims. At JWT.io, you can see which validations each library supports (look for the green check marks).\n\nMost third-party libraries implement one method to verify a JWT and build in various arguments to allow you to customize the verification. For example, if you are using Node.js and the [node-jsonwebtoken library](https://github.com/auth0/node-jsonwebtoken), then you would call the [jwt.verify()](https://github.com/auth0/node-jsonwebtoken#jwtverifytoken-secretorpublickey-options-callback) method. This method supports an `algorithms` argument to allow you to customize your allowed algorithms (make sure you disallow `none`), a `secretOrPublicKey` argument that you populate with either the secret or the RSA public key (depending on selected signing algorithm), and other input arguments that allow you to customize claim validation. If parsing fails, then the library returns a [JsonWebTokenError error](https://github.com/auth0/node-jsonwebtoken#jsonwebtokenerror) with the message `jwt malformed`, after which you **must** reject the associated request.\n\nGeneral recommendations for using third-party libraries: \n\n*   For obtaining claims from JWT, use the `verify()` method to validate the claims and the signature. Avoid using the `decode()` method to validate a token, especially if it's coming from a public client.\n    \n*   Carefully follow all instructions on how to use the chosen library. The library could rely on default values or settings that could create security risks.\n    \n\n## Manually implement checks\n\nWe discourage doing manual JWT validation since it might be easy to improperly implement and miss some important details that will lead to serious security vulnerabilities. Most JWT libraries take care of JWT validation for you. Visit JWT.io to find a JWT library for your platform and programming language.\n\nFor instructions on how to manually validate a JWT, see [RFC 7519](https://tools.ietf.org/html/rfc7519#section-7.2). All Auth0-issued JWTs have a JSON Web Signature (JWS), meaning they are signed rather than encrypted.\n\n## Verify RS256-signed tokens\n\nTo visually verify RS256-signed tokens:\n\n1.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Go to the **Settings** view, and open **Advanced Settings**.\n    \n3.  Go to the **Certificates** view, locate the **Signed Certificate** field, and copy the **Public Key**.\n    \n4.  Navigate to the [JWT.io](https://jwt.io/) website, locate the **Algorithm** dropdown, and select **RS256**.\n    \n5.  Locate the **Verify Signature** section, and paste the Public Key you previously copied in place of the content in the field that begins with `-----BEGIN PUBLIC KEY-----`.\n    \n\nTo verify the signature of a token from one of your applications:\n\nWe recommend that you get the Public Key from your tenant's JWKS here: `https://{yourDomain}/.well-known/jwks.json`\n\n## Learn more\n\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [Validate ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens)\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Validate JSON Web Tokens",
  "description": "Describes how to parse and validate a JSON web token (JWT).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-1",
  "markdown": "# Solution Overview (Web Apps + SSO)\n\nIn this section, we'll cover the solution we're implementing, including details on identity management, protocols to use, and the authentication flow required.\n\n## Identity Management\n\nExampleCo decided to use Auth0 as their Identity as a Service (IDaaS) provider. The reasoning behind this decision was that the company did not want to commit resources on training, implementation and maintenance of identity and access management. Furthermore, the company plans on building into this solution in the future, possibly adding a mobile native app and an API to push approved timesheets to their internal systems. Auth0 provides the flexibility to incorporate such changes in their architecture with minimum effort.\n\n## Which protocol to use\n\nThe next decision has to do with which protocol to use, OAuth 2.0 with OpenID Connect (OIDC) or SAML.\n\n**OpenID Connect** is an authentication protocol, based on the OAuth 2.0 family of specifications. It uses simple JSON identity tokens (JWT) delivered via the OAuth 2.0 protocol.\n\n### OAuth vs OpenID Connect (OIDC)\n\nOAuth 2.0 and OpenID Connect (OIDC) are often mistaken for the same thing, but this is not exact. **OAuth 2.0** is a protocol that lets you authorize one website (the consumer or application) to access your data from another website (the resource server or provider). For example, you want to authorize a website to access some files from your Dropbox account. The website will redirect you to Dropbox which will ask you whether it should provide access to your files. If you agree the website will be authorized to access your files from Dropbox. At the core, OAuth 2.0 is about resource access and sharing. **OpenID Connect**, on the other hand, is a simple identity layer built on top of the OAuth 2.0 protocol. It gives you one login for multiple sites. Each time you need to log in to a website using OIDC, you are redirected to your OpenID site where you login, and then taken back to the website. At the core, OIDC is concerned with user authentication.\n\n**SAML** is an XML-based protocol, that provides both authentication and authorization between trusted parties.\n\nCompared to SAML, OpenID Connect is lighter weight and simpler to deal with. SAML is proven, powerful and flexible, but for the requirements of this app, that flexibility and power is not required. Identity federation (one of the most compelling reasons for adopting SAML) is not required here either, And if it ever became a requirement, it can be easily handled by Auth0, in the same way it deals with AD (that uses LDAP).\n\nFor these reasons, ExampleCo will use OpenID Connect for their implementation.\n\n## Authentication Flow\n\nOpenID Connect supports more than one flow for authentication. Since our scenario involves a regular web app we will use the Authorization Code Flow.\n\nThe flow goes as follows:\n\n1.  The web app (called the Client in OIDC terms) initiates the authentication request by redirecting the user-agent (browser) to Auth0 (the Authorization Server in OIDC terms).\n    \n2.  Auth0 authenticates the user (via the user-agent). The first time the user goes through this flow a consent page will be shown where the permissions that will be given to the Application are listed (for example, post messages, list contacts). The user logs in to the service (unless they are already logged in) and authorizes the application access.\n    \n3.  Assuming the user grants access, Auth0 redirects the user-agent back to the Application, along with an authorization code in the query string.\n    \n4.  The Application sends the authorization code to Auth0, along with the application credentials (client\\_id and client\\_secret), and asks for a token.\n    \n5.  Auth0 authenticates the Application (using the client\\_id and client\\_secret) and validates the authorization code. If valid, Auth0 responds back with an ID Token.\n    \n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/5qO4QJH0YW34apsypLXnIk/e27a8cf1469c00d948cc476b11b54300/authz-code-flow.png)\n\n### Form Post Response Mode\n\nAnother option is to use the **OAuth 2.0 Form Post Response Mode** with `response_type=id_token&response_mode=form_post`. Due to the `response_type=id_token` request parameter, the response contains the ID Token directly, instead of the authorization code, while the `response_mode=form_post` encodes the ID Token with the rest of the Authorization Response parameters as HTML form values that are auto-submitted in the User Agent. This way you can have an optimized authentication flow (no need to exchange the code for an ID Token), however you have to make sure that it is supported by the technology you are using to implement your app (ASP .NET Core middleware does support it). For more details refer to the [OAuth 2.0 Form Post Response Mode specification](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html).\n\nThe **ID Token** (usually referred to as `id_token` in code samples) is a **JSON Web Token (JWT)** that contains identity data. It is consumed by the application and used to get user information like the user's name, email, and so forth, typically used for UI display.\n\n### More on tokens\n\nTokens are alphanumeric strings used in token-based authentication. They allow users to authenticate with a username and password once and get a token in return which they can use from that point on. They have a limited lifetime duration.\n\n**JSON Web Tokens (JWTs)** are tokens that conform to the [JSON Web Token Standard](https://tools.ietf.org/html/rfc7519) and contain information about an identity in the form of claims. They are self-contained in that it is not necessary for the recipient to call a server to validate the token. JWTs can be signed using a secret (with the **HMAC** algorithm) or a public/private key pair using **RSA**. You can find more information on JWT [here](https://auth0.com/docs/tokens/concepts/jwts).\n\nThe ID Token, which is a JWT, conforms to an industry standard (IETF [RFC 7519](https://tools.ietf.org/html/rfc7519)) and contains three parts: A header, a body and a signature.\n\n*   The header contains the type of token and the hash algorithm used on the contents of the token.\n*   The body, also called the payload, contains identity claims about a user. There are some claims with registered names, for things like the issuer of the token, the subject of the token (who the claims are about), and the time of issuance. Any number of additional claims with other names can be added, though care must be taken to keep the JWT within the browser size limitations for URLs.\n*   The signature is used by the recipient of a JWT to validate the integrity of the information conveyed in the JWT.\n\n### How to validate an ID Token\n\nThe validation of an ID Token requires several steps:\n\n1.  If the ID Token is encrypted, decrypt it using the keys and algorithms that the Application specified.\n    \n2.  The Issuer Identifier for the OpenID Provider must match the value of the `iss` (issuer) claim.\n    \n3.  The `aud` (audience) claim should contain the Application's `client_id` value. The ID Token must be rejected if the ID Token does not list the Application as a valid audience, or if it contains additional audiences not trusted by the Application.\n    \n4.  If the ID Token contains multiple audiences, the Application should verify that an `azp` claim is present.\n    \n5.  If an `azp` (authorized party) claim is present, the Application should verify that its `client_id` is the claim value.\n    \n6.  The Application must validate the signature of ID Tokens according to JWS using the algorithm specified in the JWT `alg` header parameter. The Application must use the keys provided by the Issuer.\n    \n7.  The `alg` value should be the default of `RS256` or the algorithm sent by the Application in the `id_token_signed_response_alg` parameter during registration.\n    \n8.  If the JWT `alg` header parameter uses a MAC based algorithm such as `HS256`, `HS384`, or `HS512`, the octets of the UTF-8 representation of the `client_secret` corresponding to the `client_id` contained in the `aud` (audience) claim are used as the key to validate the signature. For MAC based algorithms, the behavior is unspecified if the `aud` is multi-valued or if an `azp` value is present that is different than the `aud` value.\n    \n9.  The current time must be before the time represented by the `exp` claim.\n    \n10.  The `iat` claim can be used to reject tokens that were issued too far away from the current time, limiting the amount of time that nonces need to be stored to prevent attacks. The acceptable range is Application specific.\n    \n11.  If a `nonce` value was sent in the Authentication Request, a `nonce` claim must be present and its value checked to verify that it is the same value as the one that was sent in the Authentication Request. The Application should check the `nonce` value for replay attacks. The precise method for detecting replay attacks is Application specific.\n    \n12.  If the `acr` claim was requested, the Application should check that the asserted claim value is appropriate.\n    \n13.  If the `auth_time` claim was requested, either through a specific request for this claim or by using the `max_age` parameter, the Application should check the `auth_time` claim value and request re-authentication if it determines too much time has elapsed since the last End-User authentication.",
  "title": "Solution Overview (Web Apps + SSO)",
  "description": "Regular web app scenario solution overview.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/django/03-troubleshooting",
  "markdown": "# Auth0 Django API SDK Quickstarts: Troubleshooting\n\nThis document will help you troubleshoot your configuration if you get unexpected responses from your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nIf you configured JWT validation correctly, you will be able to get proper responses from your API when you make requests. However, in the case where you get a 401 (Unauthorized) response from your API, it is because the configuration of your JWT middleware does not match with the JWT which was passed.\n\nThis document will help you troubleshoot your JWT middleware configuration.\n\n## How Does a Token Get Validated?\n\nIn terms of validating a JWT, there are various things to consider:\n\n1.  **Is the token well-formed?** In other words, is this token conforming to the structure of a JSON Web Token (JWT)? To get more information on the structure of a JWT, please refer to [this section on the structure of a JWT](https://auth0.com/docs/jwt#what-is-the-json-web-token-structure-)\n    \n2.  **Has the token been tampered with?** The last part of a JWT is the signature. The signature is used to verify that the token was in fact signed by the sender and not altered in any way.\n    \n3.  **Has the token been received in its validity period?** JWTs are only valid for a specified time period (as expressed in the `exp` claim).\n    \n4.  **Is the token coming from the intended Authority?** This consists of 2 parts\n    \n    *   **Signature Verification**: Can we confirm that the JWT is correctly signed using the key issued by the issuing authority?\n        \n    *   **Issuer Value**: The Issuer is defined in the `iss` claim. Once again does this claim match up with what your application expects?\n        \n5.  **Is the token intended for the current application?** So does the `aud` claim of the JWT match with what your application is expecting?\n    \n\n## Inspecting a Token\n\nA quick way to inspect a JWT is by using the [JWT.io](https://jwt.io/) website. It has a handy debugger which allows you to quickly check that a JWT is well-formed, and also inspect the values of the various claims.\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-rs256.png)\n\nIn the screenshot above you can see that the token was signed using the **RS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://rs256.test.api**.\n\nSo, in other words, these values in your JWT validation configuration registration must match **exactly** - including the trailing slash for the Issuer, such as\n\n```\naudience = \"https://rs256.test.api\",\ndomain = \"https://jerrie.auth0.com/\"\n};\n```\n\nFor a token signed using HS256, the debugger view will look a little different:\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-hs256.png)\n\nIn the screenshot above you can see that the token was signed using the **HS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://hs256.test.api**.",
  "title": "Auth0 Django API SDK Quickstarts: Troubleshooting",
  "description": "This document will help you troubleshoot your configuration if you get unexpected responses from your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/add-member-roles",
  "markdown": "# Add Roles to Organization Members\n\n```\ncurl --request POST \\\n  --url https://your_auth0_domain/api/v2/organizations/ORG_ID/members/USER_ID/roles \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"roles\": [ \"ROLE_ID\", \"ROLE_ID\", \"ROLE_ID\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://your_auth0_domain/api/v2/organizations/ORG_ID/members/USER_ID/roles\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://your_auth0_domain/api/v2/organizations/ORG_ID/members/USER_ID/roles\"\n\n\tpayload := strings.NewReader(\"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://your_auth0_domain/api/v2/organizations/ORG_ID/members/USER_ID/roles\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://your_auth0_domain/api/v2/organizations/ORG_ID/members/USER_ID/roles',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {roles: ['ROLE_ID', 'ROLE_ID', 'ROLE_ID']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"roles\": @[ @\"ROLE_ID\", @\"ROLE_ID\", @\"ROLE_ID\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://your_auth0_domain/api/v2/organizations/ORG_ID/members/USER_ID/roles\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://your_auth0_domain/api/v2/organizations/ORG_ID/members/USER_ID/roles\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"your_auth0_domain\")\n\npayload = \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/api/v2/organizations/ORG_ID/members/USER_ID/roles\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://your_auth0_domain/api/v2/organizations/ORG_ID/members/USER_ID/roles\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"roles\": [\"ROLE_ID\", \"ROLE_ID\", \"ROLE_ID\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://your_auth0_domain/api/v2/organizations/ORG_ID/members/USER_ID/roles\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Add Roles to Organization Members",
  "description": "Learn how to add roles to Organization members using the Auth0 Dashboard or Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-2",
  "markdown": "# Auth0 Configuration (Web Apps + SSO)\n\nIn this section we will review all the configurations we need to apply using the [Auth0 Dashboard](https://manage.auth0.com/#).\n\n## Application\n\nThe Auth0 configuration part starts with registering the timesheets app at the Auth0 dashboard as an **application**. An application is making protected resource requests on behalf of the resource owner (end-user).\n\nThe main characteristics of an application in Auth0 are:\n\n*   **Name**: The canonical name of the application. This is used to identify the application at the portal, emails, logs, and more.\n    \n*   **Client ID** (read-only): The unique identifier for the application. This is the ID used in the application when setting up authentication with Auth0. It is an auto-generated alphanumeric string.\n    \n*   **Client secret** (read-only): A string used to sign and validate tokens which will be used in the different authentication flows. It is auto-generated and it must be kept confidential.\n    \n*   **Domain**: The domain name assigned to the Auth0 account. The format of the domain is `{account-name}.auth0.com` or `{account-name}.{location}.auth0.com`, for example `ExampleCo.auth0.com`.\n    \n*   **Callback URL**: The URL where the user is redirected after they authenticate.\n    \n\n### Create an Application\n\nExampleCo's scenario involves only one application: the timesheets web app. Hence we have to configure one Application at Auth0 side.\n\nTo register a database connection, go to the [dashboard](https://manage.auth0.com/#) and in the side navigation select [Applications](https://manage.auth0.com/#/applications).\n\nClick on the button **\\+ Create Application**. You will be prompted for the name and the type of the application. We will name our application `Timesheet-App` and select `Regular Web Applications` as the application type.\n\n![Dashboard - Applications - Create Application](https://images.ctfassets.net/cdy7uua7fh8z/2xSOsGL6qUAN8DfJ2KnMwp/a5f512f8d7ad3a04d5aa842d8a25718e/dashboard-applications-list.png)\n\nWhen you click **Create** you will be navigated to the [Quick Start view](https://manage.auth0.com/#/applications/YOUR_CLIENT_ID/quickstart). Here you can pick the technology you plan on using to build your app and the relevant how-to quickstart will be displayed.\n\nThe other available views are:\n\n*   [Settings](https://manage.auth0.com/#/applications/YOUR_CLIENT_ID/settings)\n    \n*   [Addons](https://manage.auth0.com/#/applications/YOUR_CLIENT_ID/addons)\n    \n*   [Connections](https://manage.auth0.com/#/applications/YOUR_CLIENT_ID/connections)\n    \n\n### Configure Callback URLs\n\nThe **Allowed Callback URLs** field contains the URL(s) where Auth0 will redirect to after the user has authenticated in order for the OpenID Connect (OIDC) to complete the authentication process. You can specify multiple valid URLs by comma-separating them. You can use the star symbol as a wildcard for subdomains, for example `*.google.com`. Make sure to specify the protocol, `http://` or `https://`, otherwise the callback may fail in some cases.\n\nThe Callback URL for our sample project is `http://localhost:5000/signin-auth0`. Go ahead and set this value to the **Allowed Callback URLs** field if you plan on using our sample, otherwise add the URL you chose to deploy your application to.\n\n## Connections\n\nThe next step is to configure the identity providers that will be used for authentication at the web app. Each identity provides maps to a **connection** in Auth0. Each application needs at least one connection, and each connection can be used for more than one application.\n\nExampleCo needs to configure two connections: one Active Directory connection for the internal employees, and one Database connection for external parties.\n\n### Supported identity providers\n\nAuth0 supports a vast variety of protocols and identity providers:\n\n*   Social: Allow your users to log in using Google, Facebook, LinkedIn, Github, and many more.\n*   Enterprise: Allow your users to log in using Active Directory, ADFS, LDAP, SAML-P, and many more.\n*   Database connections: Create your own user store by configuring a new database connection, and authenticate your users using email/username and password. The credentials can be securely stored either in the Auth0 user store, or in your own database.\n*   Passwordless authentication: Allow your users to login without the need to remember a password and use an authentication channel like SMS or email.\n\n### Create a database connection\n\nTo register a database connection, go to the [dashboard](https://manage.auth0.com/#) and in the side navigation select [Connections > Database](https://manage.auth0.com/#/connections/database).\n\nClick on the button **\\+ Create DB Connection**. You will be prompted for the name of the connection. We will name our connection `Timesheet-Users`.\n\n![Create Database Connection](https://images.ctfassets.net/cdy7uua7fh8z/4FnhfkFnaNRY4zp5KoMA5Z/9d6b1f0b022d9a2590073b316b587f74/create-database-connection.png)\n\nWhen you click **Save** you will be navigated to the Settings page for the new connection. Ensure that you enable your application to use this connection at the Applications Using This Connection section.\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/UYX5B2lnhMIEKfhfMq7jx/142d645257a318332012970eec703cc5/enable-client-db.png)\n\nFor more information on database connections refer to [Database Identity Providers](https://auth0.com/docs/authenticate/database-connections).\n\n### Create an Active Directory / LDAP Connection\n\nNext you need to configure your Active Directory / LDAP connection. Go to the [Auth0 dashboard](https://manage.auth0.com/#) and in the side navigation, select [Connections > Enterprise](https://manage.auth0.com/#/connections/enterprise).\n\nThere you need to create the AD / LDAP connection and install the AD Connector. You can find details in these documents:\n\n*   [How to connect your Active Directory with Auth0](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap)\n    \n*   [How to install the Active Directory/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector)\n    \n\nOnce you have configured the connection and the connector, be sure to enable your application to use this AD / LDAP connection:\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/40OZGjNxhfJUWiq0fMxIMy/8d1263ea0b55a3534bf008ee8262c831/enable-client-ad.png)\n\n### Kerberos support\n\nThe AD/LDAP connector supports Kerberos to make it easer for your users to authenticate when they are on a domain-joined machine within the corporate network. To activate Kerberos on an Active Directory you have to simply enable the option in the dashboard. After enabling Kerberos you'll also be able to configure the **IP Ranges**. When users originate from these IP address ranges this information will be exposed in the SSO endpoint which means client-side SDKs like auth0.js and the Lock will be able to detect Kerberos support and allow Integrated Windows Authentication. [More information](https://auth0.com/docs/connector/kerberos)\n\nNow that we have designed our solution and discussed the configurations needed on Auth0 side, we can proceed with integrating Auth0 with our timesheets web app.",
  "title": "Auth0 Configuration (Web Apps + SSO)",
  "description": "Regular web app scenario configuration for Auth0",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-3",
  "markdown": "# Application Implementation (Web Apps + SSO)\n\nLet's walk through the implementation of our regular web application. We used ASP .NET Core for the implementation, you can find the code in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-webapp-oidc).\n\nThe sample contains an application which uses Active Directory integration to authenticate company employees and an Auth0 database connection for external contractors. Authorization is implemented using rules and claims as we will see in detail in this paragraph.\n\n## User Login\n\nAuth0 provides a Lock widget which serves as a login component for your application, meaning that you do not have to implement your own login screen. The Lock widget seamlessly integrates with all of the connections you configure inside your Auth0 dashboard, whether they be database, social or enterprise connections.\n\nThere are a number of different ways in which you can implement a Login screen using a web application and Auth0:\n\n*   **Hosted Lock**: Use an instance of the Lock widget which is hosted on the Auth0 infrastructure.\n    \n*   **Embedded Lock**: Embed the Lock widget inside a web page of your application. You have some customization options for the actual Lock widget and full control over the rest of the HTML on the page.\n    \n*   **Custom UI**: Develop a completely custom web page for the login screen. The custom HTML form will post back to your server which will, in turn, authenticate the user using the Authentication API. For more information on when to use a Custom UI, refer to [Customize Classic Login Pages with Lock or SDK](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk).\n    \n\nThe recommended best practice is to use Hosted Lock because it is the most secure option and the easiest way to enable users to log in to your application.\n\n### Automate Home Realm Discovery (HRD)\n\nBy default, Lock will display all the connections available for login. Selecting the appropriate Identity Providers from multiple options is called Home Realm Discovery (HRD). In our case, the options are either authenticating with Active Directory (for company employees) or using email/password for our database connection (external contractors).\n\nYou may however want to avoid that first step, where the user needs to choose the Identity Provider (IdP), and have the system identify it instead of asking every time. Lock offers you the following options:\n\n*   **Identify the IdP programmatically**: When you initiate an authentication transaction with Auth0 you can optionally send a `connection` parameter. This value maps directly with any connection defined in your dashboard. When using the Hosted version of Lock by calling the `/authorize` endpoint, you can pass along a `connection` query string parameter containing the name of the connection. Alternatively, if you are using Embedded Lock, this is as simple as writing `auth0.show({connections: ['{yourConnection}']});`.\n    \n    *   There are multiple practical ways of getting the `connection` value. One of them is to use **vanity URLs**: for example, company employees will use `https://internal.yoursite.com`, while external contractors will use `https://external.yoursite.com`.\n        \n*   **Use email domains**: Lock can use email domains as a way of routing authentication requests. Enterprise connections in Auth0 can be mapped to `domains`. If a connection has this setup, then the password textbox gets disabled automatically when typing an email with a mapped domain. Note that you can associate multiple domains to a single connection.\n    \n\nFor additional information on this topic refer to [Select from Multiple Connection Options](https://auth0.com/docs/libraries/lock/selecting-from-multiple-connection-options).\n\n## Session Management\n\nWhen talking about managing sessions, there are typically three layers of sessions we need to consider:\n\n*   **Application Session**: The first is the session inside the application. Even though your application uses Auth0 to authenticate users, you will still need to keep track of the fact that the user has logged in to your application. In a normal web application this is achieved by storing information inside a cookie.\n    \n*   **Auth0 session**: Next, Auth0 will also keep a session and store the user's information inside a cookie. Next time when a user is redirected to the Auth0 Lock screen, the user's information will be remembered.\n    \n*   **Identity Provider session**: The last layer is the Identity Provider, for example Facebook or Google. When you allow users to sign in with any of these providers, and they are already signed into the provider, they will not be prompted to sign in. They may simply be required to give permissions to share their information with Auth0 and in turn your application.\n    \n\nWhen developing a web application, you will therefore need to keep track of the fact that the user has logged in to your Web application. You can do this by making use of a cookie-based session to keep track of the fact that the user has signed in, and also store any of the user related information or tokens.\n\n### How do I control the duration of the user's local application session? Can I drive that from Auth0?\n\nThe web app has full control over the user's local application session. How this is done usually depends on the web stack being used (for example, ASP.NET). Regardless, all approaches ultimately use one or more cookies to control the session. The developer can choose to use the expiration of the JWT ID Token returned by Auth0 to control their session duration or ignore it completely. Some developers store the ID Token itself in session state and end the user's session when it has expired.\n\nThe reason why you would use the expiration of the token to determine the expiration of the local session is because it gives you centralized control of the duration of a user session from the Auth0 Dashboard.\n\nThe login flow is as follows:\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/4bqozVk6fF4JrWRP1BJK7Y/1403eb1c0efb12552307358a26c6e7f7/login-flow.png)\n\n1.  **Initiate OIDC Authentication Flow**: The user's browser will send a request to Auth0 to initiate the OIDC flow.\n    \n2.  **Set SSO Cookie**: Auth0 will set a cookie to store the user's information.\n    \n3.  **Code exchange and return ID Token**: Auth0 will make a request back to the web server and return the code. The web server will exchange the code for an ID Token.\n    \n4.  **Set auth cookie and send response**: The web server will send a response back to the browser and set the application authentication cookie to store the user's session information.\n    \n5.  **Auth cookie sent with every subsequent request**: The application authentication cookie will be sent on every subsequent request as proof that the user is authenticated.\n    \n\n### How does Auth0's SSO session impact the application's session?\n\nAuth0 manages its own single-sign-on session. Applications can choose to honor or ignore that SSO session when it comes to maintaining their own local session. The Lock widget even has a special feature where it can detect if an Auth0 SSO session exists and ask the user if they wish to log in again as that same user.\n\n![Lock Widget SSO](https://auth0.com/docs/media/articles/architecture-scenarios/web-app-sso/sso-login.png)\n\nIf they do so, they are signed in without having to re-enter their credentials with the actual IDP. Even though the user didn't authenticate, the application still performs an authentication flow with Auth0 and obtains a new ID Token, which can be used to then manage the new local application session.\n\n**See the implementation in** [**ASP.NET Core**](https://auth0.com/docs/architecture-scenarios/application/web-app-sso/implementation-aspnetcore#configure-the-cookie-and-oidc-middleware).\n\n## User Logout\n\nWhen logging the user out, you will once again need to think about the three layers of sessions which we spoke about before:\n\n*   **Application Session**: You need to log out the user from your Web Application, by clearing their session.\n    \n*   **Auth0 session**: You need to log out the user from Auth0. To do this you redirect the user to `https://{yourDomain}/v2/logout`. Redirecting the user to this URL clears all single sign-on cookies set by Auth0 for the user.\n    \n*   **Identity Provider session**: Although this is not common practice, you can force the user to log out from the Identity Provider used, for example Facebook or Google. To do this add a `federated` query string parameter to the logout URL: `https://{yourDomain}/v2/logout?federated`.\n    \n\nTo redirect a user after logout, add a `returnTo` query string parameter with the target URL as the value: `https://{yourDomain}/v2/logout?returnTo=http://www.example.com`. Note, that you will need to add the `returnTo` URL as an **Allowed Logout URLs**. For more information on how to implement this refer to: [Logout](https://auth0.com/docs/authenticate/login/logout).\n\nThe logout flow (not including federated logout) is as follows:\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/5t5iXTeGMUzyKHhqOAGRmp/d51797c6513686ea758f0613d01b55d4/logout-flow.png)\n\n1.  **Initiate Logout Flow**: The logout flow will be initiated from the browser, for example by the user clicking a **Logout** link. A request will be made to the web server.\n    \n2.  **Clear user’s local session**: The user's Application Session / Cookie will be cleared.\n    \n3.  **Redirect browser to Auth0 Logout**: The user's browser will be redirected to the Auth0 Logout URL.\n    \n4.  **Clear SSO Cookie**: Auth0 will clear the user's SSO Cookie.\n    \n5.  **Redirect to post-logout URL**: Auth0 will return a redirect response and redirect the user's browser to the `returnTo` query string parameter.\n    \n\n**See the implementation in** [**ASP.NET Core**](https://auth0.com/docs/architecture-scenarios/application/web-app-sso/implementation-aspnetcore#implement-the-logout).\n\n## Access Control\n\nAuthorization refers to the process of determining what actions a user can perform inside your application.\n\nYou can either implement authorization directly inside your application, independently of Auth0, or use one of the available ways to retrieve the user authorization levels, put them as authorization claims inside the ID Token and validate these claims inside your application, once you retrieve the token, to control access.\n\nThere are various ways in which you can retrieve and set the user authorization claims when using Auth0:\n\n*   By configuring and using the [Auth0 Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension).\n    \n*   By using Active Directory groups. These can be used in combination with the Authorization Extension by mapping Active Directory Groups to Groups you define using the Authorization extension.\n    \n*   Add metadata to the user's profile by making use of [rules](https://auth0.com/docs/customize/rules).\n    \n*   By calling an external services from inside a rule.\n    \n\nSince in our case the company has already Active Directory set up, we will enforce access control using the Authorization Extension in combination with Active Directory groups.\n\n#### Authorization extension\n\nAt this point in time the authorization extension is primarily designed to enforce coarse-grained authorization, for example to control access to an application based on a user's group membership. It is not necessarily designed to control fine-grained access (such as whether a user can perform a specific action inside the application), even though this is how we are utilizing it in this instance.\n\nAll users will implicitly be regular users, but timesheet administrators will be assigned to an `Admin` group which will allow them to approve timesheets. The Authorization Extension allows for mapping groups to existing group membership.\n\nAll timesheet administrators will be assigned to the `Timesheet Administrators` group on Active Directory, which will be automatically mapped to the `Admin` group inside the Timesheet Application.\n\nWhen you install the Authorization Extension, it creates a rule in the background, which does the following:\n\n1.  Determine the user's group membership.\n    \n2.  Store the user's group membership info as part of the `app_metadata`.\n    \n3.  Add the user's group membership to the outgoing token.\n    \n4.  Verify that the user has been granted access to the current application.\n    \n\nTo install the Authorization extension navigate to the [Extensions](https://manage.auth0.com/#/extensions) view of your Auth0 Dashboard, and select and install the Auth0 Authorization extension.\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/0hIE2vdPTHo1Gp7IIgzOA/71ccc3636db4eca0ccff6f3ce7e20946/install-authz-ext.png)\n\nOnce installed, you will see the app listed under Installed Extensions.\n\nWhen you click on the link to open the extension for the first time, you will be prompted to provide permission for the extension to access your Auth0 account. If you do so, you will be redirected to the Authorization Dashboard.\n\nOnce on the Authorization Dashboard, navigate to Groups in the navigation menu, and create a new group called Admin.\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/6zOF0mCrLV2rwdpxn9JD1e/5d6e227c4a96260856afd8f94c4212d9/create-admin-group.png)\n\nAfter the group has been added you can click on the new group to go to the group management section. Go to the Group Mappings tab and add a new group mapping which will map all Active Directory users in the `Timesheet Admins` groups to the `Admin` group you just created.\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/RaMHHJ1G9LoO5xoz3BJnN/b01c93948b1a54b599f1eb106bd8ef26/add-group-mapping.png)\n\nOnce you click **Save** you can see the new mapping listed.\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/1whRHGlsRhGhA6vcrsElsv/093716ca939c843729c3022c810ee6a7/view-group-mapping.png)\n\nWith the mapping configured you only need to maintain membership to the `Timesheet Admins` group in Active Directory, and those users will be automatically mapped to the `Admin` group inside our application.\n\nFor more information refer to the [Authorization Extension documentation](https://auth0.com/docs/customize/extensions/authorization-extension).\n\n### Enforce permissions in your application\n\nWhen you installed the Authorization Extension, it also created an Auth0 rule which will add an `authorization` claim with all the authorization related settings for a particular user. The groups for a user will be added as a sub-claim of the `authorization` claim called `groups` and all the groups a user belongs to will be added as an array to this claim. This is an example of what JSON payload of a ID Token may look like with the groups listed:\n\n```\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"authorization\": {\n    \"groups\": [\"Admin\"]\n  }\n}\n```\n\nIn your application you will therefore need to decode the ID Token returned when a user is authenticated, and extract the groups which a user belongs to from the `authorization` claim. You can then store these groups, along with other user information inside the user's session, and subsequently query these to determine whether a user has permissions to perform a certain action based on their group membership.",
  "title": "Application Implementation (Web Apps + SSO)",
  "description": "Regular web app scenario application implementation",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-4",
  "markdown": "# Conclusion (Web Apps + SSO)\n\nIn this tutorial we covered a simple scenario: a regular web app, hosted in the cloud, using Auth0 for authentication, while utilizing the existing Active Directory user store. We learned what OpenID Connect (OIDC) offers and why it was preferable for this business case, how the Authentication Flow works, what an ID Token is and how to validate and manipulate it, how to configure applications and connections on Auth0 dashboard, how to implement user login and logout using Lock, and how session management and access control works.\n\nWe started by describing the business case and the requirements and went on explaining how each requirement can be met and the thought process behind each choice that was made.\n\nWe used ASP .NET Core for the sample web app implementation, hopefully though after going through this document you are able to build such a web app using the framework you prefer.",
  "title": "Conclusion (Web Apps + SSO)",
  "description": "Regular web app scenario conclusion",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/implementation-aspnetcore",
  "markdown": "# ASP.NET Core Implementation (Web Apps + SSO)\n\nFull source code for the ASP.NET Core implementation can be found in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-webapp-oidc).\n\n## Configure the Cookie and OIDC Middleware\n\nFor the purposes this guide we will be using a simple hosted login. You can use the standard cookie and OIDC middleware which is available with ASP.NET Core, so ensure that you install the NuGet packages.\n\n```\nInstall-Package Microsoft.AspNetCore.Authentication.Cookies\nInstall-Package Microsoft.AspNetCore.Authentication.OpenIdConnect\n```\n\nThen configure the cookie and OIDC middleware inside your application's middleware pipeline.\n\n```\npublic class Startup\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        // Add authentication services\n        services.AddAuthentication(\n            options => options.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme);\n\n        // Code omitted for brevity...\n    }\n\n    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory, IOptions<Auth0Settings> auth0Settings)\n    {\n        // Code omitted for brevity...\n\n        // Add the cookie middleware\n        app.UseCookieAuthentication(new CookieAuthenticationOptions\n        {\n            AutomaticAuthenticate = true,\n            AutomaticChallenge = true\n        });\n\n        // Add the OIDC middleware\n        app.UseOpenIdConnectAuthentication(new OpenIdConnectOptions(\"Auth0\")\n        {\n            // Set the authority to your Auth0 domain\n            Authority = \"https://{yourDomain}/\",\n\n            // Configure the Auth0 Client ID and Client Secret\n            ClientId = {yourClientId},\n            ClientSecret = YOUR_CLIENT_SECRET,\n\n            // Do not automatically authenticate and challenge\n            AutomaticAuthenticate = false,\n            AutomaticChallenge = false,\n\n            // Set response type to code\n            ResponseType = \"code\",\n\n            CallbackPath = new PathString(\"/signin-auth0\"),\n\n            // Configure the Claims Issuer to be Auth0\n            ClaimsIssuer = \"Auth0\"\n        });\n\n        // Code omitted for brevity...\n    }\n}\n```\n\nAs you can see in the code above, we have configured two different types of authentication middleware.\n\nThe first is the cookie middleware which was registered with the call to `UseCookieAuthentication`. The second is the OIDC middleware which is done with the call to `UseOpenIdConnectAuthentication`.\n\nOnce the user has signed in to Auth0 using the OIDC middleware, their information will automatically be stored inside a session cookie. All you need to do is to configure the middleware as above and it will take care of managing the user session.\n\nThe OpenID Connect (OIDC) middleware will also extract all the claims from the ID Token, which is sent from Auth0 once the user has authenticated, and add them as claims on the `ClaimsIdentity`.\n\n## Implement the Logout\n\nYou can control both the application session and the Auth0 session using the `SignOutAsync` method of the `AuthenticationManager` class, and passing along the authentication scheme from which you want to sign out.\n\nAs an example to sign out of the cookie middleware, and thereby clearing the authentication cookie for your application, you can make the following call:\n\n```\nawait HttpContext.Authentication.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);\n```\n\nSimilarly you can log the user out from Auth0 by making a call to the `SignOutAsync` method and passing along `Auth0` as the authentication scheme to sign out of.\n\n```\nawait HttpContext.Authentication.SignOutAsync(\"Auth0\");\n```\n\nFor the above to work you will however also need to add extra configuration when registering the OIDC middleware by handling the `OnRedirectToIdentityProviderForSignOut` event. Inside the event you will need to redirect to the [Auth0 logout endpoint](https://auth0.com/docs/api/authentication/reference#logout) which will clear the Auth0 cookie.\n\n```\napp.UseOpenIdConnectAuthentication(new OpenIdConnectOptions(\"Auth0\")\n{\n    // Some code omitted for brevity\n    Events = new OpenIdConnectEvents\n    {\n        OnRedirectToIdentityProviderForSignOut = context =>\n        {\n            context.Response.Redirect($\"https://{auth0Settings.Value.Domain}/v2/logout?client_id={auth0Settings.Value.ClientId}&returnTo={context.Request.Scheme}://{context.Request.Host}/\");\n            context.HandleResponse();\n\n            return Task.FromResult(0);\n        }\n    }\n});\n```\n\nYou will also need to ensure that you add your application's URL to the **Allowed Logout URLs** for your application inside the Auth0 dashboard. For more information refer to [Logout](https://auth0.com/docs/logout).\n\n## Implement Admin permissions\n\nThe easiest way to integrate the groups into an ASP.NET Core application is to use the built-in [Role-based Authorization](https://docs.asp.net/en/latest/security/authorization/roles.html) available in ASP.NET Core. In order to achieve this we will need to add a Claim of type\n\n```\nhttp://schemas.microsoft.com/ws/2008/06/identity/claims/role\n```\n\nfor each of the groups a user is assigned to.\n\nOnce the claims has been added we can easily ensure that a specific action is available only to `Admin` users by decorating the claim with the `[Authorize(Roles = \"Admin\")]` attribute. You can also check whether a user is in a specific role from code by making a call to `User.IsInRole(\"Admin\")` from inside your controller.\n\nThe ASP.NET OIDC middleware will automatically add all claims returned in the JWT as claims to the `ClaimsIdentity`. We would therefore need to extract the information from the `authorization` claim, deserialize the JSON body of the claim, and for each of the groups add a `http://schemas.microsoft.com/ws/2008/06/identity/claims/role` claim to the `ClaimsIdentity`.\n\n```\napp.UseOpenIdConnectAuthentication(new OpenIdConnectOptions(\"Auth0\")\n{\n    // Some configuration omitted for brevity\n\n    Events = new OpenIdConnectEvents\n    {\n        OnTicketReceived = context =>\n        {\n            var options = context.Options as OpenIdConnectOptions;\n\n            // Get the ClaimsIdentity\n            var identity = context.Principal.Identity as ClaimsIdentity;\n            if (identity != null)\n            {\n                // Add the groups as roles\n                var authzClaim = context.Principal.FindFirst(c => c.Type == \"authorization\");\n                if (authzClaim != null)\n                {\n                    var authorization = JsonConvert.DeserializeObject<Auth0Authorization>(authzClaim.Value);\n                    if (authorization != null)\n                    {\n                        foreach (var group in authorization.Groups)\n                        {\n                            identity.AddClaim(new Claim(ClaimTypes.Role, group, ClaimValueTypes.String, options.Authority));\n                        }\n                    }\n                }\n            }\n\n            return Task.FromResult(0);\n        }\n    }\n});\n```\n\nAnd subsequently we can add an action which allows Administrators to approve timesheets:\n\n```\n[Authorize(Roles = \"Admin\")]\npublic IActionResult TimesheetApproval()\n{          \n    return View();\n}\n```",
  "title": "ASP.NET Core Implementation (Web Apps + SSO)",
  "description": "The ASP.NET Core implementation for the Single Sign-on (SSO) for Regular Web Apps architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/tenant-settings/signing-keys/revoke-signing-keys",
  "markdown": "# Revoke Signing Keys\n\n```\ncurl --request PUT \\\n  --url 'https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke\");\nvar request = new RestRequest(Method.PUT);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke\"\n\n\treq, _ := http.NewRequest(\"PUT\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.put(\"https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PUT',\n  url: 'https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PUT\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PUT\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"PUT\", \"/{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Put.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D/revoke\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PUT\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Revoke Signing Keys",
  "description": "Learn how to revoke your tenant's application signing key using the Auth0 Dashboard or Management API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/tenant-settings/signing-keys/rotate-signing-keys",
  "markdown": "# Rotate Signing Keys\n\nYou can manually rotate a signing key periodically to change the JSON web key (JWK) key used by applications and APIs to validate tokens. If your application or API **does not** allow for this key change, and it attempts to use an expired signing key to verify a token, the authentication request will fail.\n\nAlthough Auth0 signs with only one signing key at a time, your tenant's OpenID Connect (OIDC) discovery document always contains multiple keys. The OIDC discovery document will always include both the current key and the next key, and it may also include the previous key if the previous key has not yet been revoked. To provide a seamless experience in case of an emergency, your application should be able to use any of the keys specified in the document. To learn more about OpenID Connect discovery documents, read [Locate JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets).\n\nYou can rotate your tenant's application signing key using the Auth0 Dashboard or the Auth0 Management API.\n\n## Use the Dashboard\n\n1.  Go to [Dashboard > Settings > Signing Keys](https://manage.auth0.com/#/tenant/signing_keys).\n    \n    ![Dashboard Tenant Settings Signing Keys tab](https://images.ctfassets.net/cdy7uua7fh8z/7r8t3EGctFmvkCgPrU0i2R/f79ac74dac5cded37b39bd8a8b80951d/dashboard-tenant-settings-signing-keys.png)\n2.  Under **Rotation Settings**, locate **Rotate Signing Key**, and select **Rotate Key**.\n    \n3.  Click **Rotate** to confirm.\n    \n    ![Dashboard Settings Signing Keys Tab Rotate Confirm](https://images.ctfassets.net/cdy7uua7fh8z/6Ofp24mgt8ZrvaxF2wLA5N/1cd61bffea774c53adc09419e9064759/dashboard-tenant-settings-signing-keys-rotation-confirm.png)\n\n## Use the Management API\n\n1.  To get a list of the signing keys, make a `GET` call to the [Get all Application Signing Keys](https://auth0.com/docs/api/management/v2#!/Keys/get_signing_keys) endpoint.\n    \n2.  To rotate the signing key, make a `POST` call to the [Rotate the Application Signing Key](https://auth0.com/docs/api/management/v2#!/Keys/post_signing_keys) endpoint. Be sure to replace the `MGMT_API_ACCESS_TOKEN` placeholder value with your Management API access token.\n    \n    *   [cURL](#966d77dd171643d68d44a06462eed114_shell)\n    *   [C#](#966d77dd171643d68d44a06462eed114_csharp)\n    *   [Go](#966d77dd171643d68d44a06462eed114_go)\n    *   [Java](#966d77dd171643d68d44a06462eed114_java)\n    *   [Node.JS](#966d77dd171643d68d44a06462eed114_node)\n    *   [Obj-C](#966d77dd171643d68d44a06462eed114_objc)\n    *   [...](#)\n    \n    ```\n    curl --request POST \\\n      --url 'https://{yourDomain}/api/v2/keys/signing/rotate' \\\n      --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n    ```\n    \n    ```\n    var client = new RestClient(\"https://{yourDomain}/api/v2/keys/signing/rotate\");\n    var request = new RestRequest(Method.POST);\n    request.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\n    IRestResponse response = client.Execute(request);\n    ```\n    \n    ```\n    package main\n    \n    import (\n    \t\"fmt\"\n    \t\"net/http\"\n    \t\"io/ioutil\"\n    )\n    \n    func main() {\n    \n    \turl := \"https://{yourDomain}/api/v2/keys/signing/rotate\"\n    \n    \treq, _ := http.NewRequest(\"POST\", url, nil)\n    \n    \treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n    \n    \tres, _ := http.DefaultClient.Do(req)\n    \n    \tdefer res.Body.Close()\n    \tbody, _ := ioutil.ReadAll(res.Body)\n    \n    \tfmt.Println(res)\n    \tfmt.Println(string(body))\n    \n    }\n    ```\n    \n    ```\n    HttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/keys/signing/rotate\")\n      .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n      .asString();\n    ```\n    \n    ```\n    var axios = require(\"axios\").default;\n    \n    var options = {\n      method: 'POST',\n      url: 'https://{yourDomain}/api/v2/keys/signing/rotate',\n      headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n    };\n    \n    axios.request(options).then(function (response) {\n      console.log(response.data);\n    }).catch(function (error) {\n      console.error(error);\n    });\n    ```\n    \n    ```\n    #import <Foundation/Foundation.h>\n    \n    NSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n    \n    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/keys/signing/rotate\"]\n                                                           cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                       timeoutInterval:10.0];\n    [request setHTTPMethod:@\"POST\"];\n    [request setAllHTTPHeaderFields:headers];\n    \n    NSURLSession *session = [NSURLSession sharedSession];\n    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                    if (error) {\n                                                        NSLog(@\"%@\", error);\n                                                    } else {\n                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                        NSLog(@\"%@\", httpResponse);\n                                                    }\n                                                }];\n    [dataTask resume];\n    ```\n    \n    ```\n    $curl = curl_init();\n    \n    curl_setopt_array($curl, [\n      CURLOPT_URL => \"https://{yourDomain}/api/v2/keys/signing/rotate\",\n      CURLOPT_RETURNTRANSFER => true,\n      CURLOPT_ENCODING => \"\",\n      CURLOPT_MAXREDIRS => 10,\n      CURLOPT_TIMEOUT => 30,\n      CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n      CURLOPT_CUSTOMREQUEST => \"POST\",\n      CURLOPT_HTTPHEADER => [\n        \"authorization: Bearer {yourMgmtApiAccessToken}\"\n      ],\n    ]);\n    \n    $response = curl_exec($curl);\n    $err = curl_error($curl);\n    \n    curl_close($curl);\n    \n    if ($err) {\n      echo \"cURL Error #:\" . $err;\n    } else {\n      echo $response;\n    }\n    ```\n    \n    ```\n    import http.client\n    \n    conn = http.client.HTTPSConnection(\"\")\n    \n    headers = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n    \n    conn.request(\"POST\", \"/{yourDomain}/api/v2/keys/signing/rotate\", headers=headers)\n    \n    res = conn.getresponse()\n    data = res.read()\n    \n    print(data.decode(\"utf-8\"))\n    ```\n    \n    ```\n    require 'uri'\n    require 'net/http'\n    require 'openssl'\n    \n    url = URI(\"https://{yourDomain}/api/v2/keys/signing/rotate\")\n    \n    http = Net::HTTP.new(url.host, url.port)\n    http.use_ssl = true\n    http.verify_mode = OpenSSL::SSL::VERIFY_NONE\n    \n    request = Net::HTTP::Post.new(url)\n    request[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n    \n    response = http.request(request)\n    puts response.read_body\n    ```\n    \n    ```\n    import Foundation\n    \n    let headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n    \n    let request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/keys/signing/rotate\")! as URL,\n                                            cachePolicy: .useProtocolCachePolicy,\n                                        timeoutInterval: 10.0)\n    request.httpMethod = \"POST\"\n    request.allHTTPHeaderFields = headers\n    \n    let session = URLSession.shared\n    let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n      if (error != nil) {\n        print(error)\n      } else {\n        let httpResponse = response as? HTTPURLResponse\n        print(httpResponse)\n      }\n    })\n    \n    dataTask.resume()\n    ```\n    \n\n## Key rotation impact\n\n### APIs and API gateways accepting access tokens\n\nMost middleware and API gateways leverage the JSON web key set (JWKS) endpoint to retrieve the current and future signing keys at a certain interval. If your middleware and/or API gateways **do not** support this endpoint and require you to manually configure a `*.cer` file, you will need to coordinate the signing key rotation in Auth0 with the reconfiguration of your middleware and gateways.\n\n### Regular web applications\n\nWhen rotating the signing key in Auth0, you will need to coordinate the reconfiguration of your applications which leverage WS-Fed or SAML. This typically happens when you upload the new public certificate or reconfigure the application by entering the WS-Fed/SAML metadata URL. This will change the JWKS key, which is used by applications to validate tokens, make sure your implementation does not assume JWKS keys don’t change.\n\n## Learn more\n\n*   [Revoke Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys/revoke-signing-keys)\n*   [Locate JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets)\n*   [Change Application Signing Algorithms](https://auth0.com/docs/get-started/applications/change-application-signing-algorithms)\n*   [View Signing Certificates](https://auth0.com/docs/get-started/tenant-settings/signing-keys/view-signing-certificates)",
  "title": "Rotate Signing Keys",
  "description": "Learn how to rotate your tenant's application or API signing key using the Auth0 Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/webapi-owin/02-using",
  "markdown": "# Auth0 ASP.NET Web API (OWIN) SDK Quickstarts: Using your API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [ASP.NET Web API (OWIN)](https://auth0.com/docs/quickstart/backend/webapi-owin)\n*   [Using your API](https://auth0.com/docs/quickstart/backend/webapi-owin/02-using)\n\nThis tutorial will show you how to use your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Calling the API From Your Application\n\nYou can call the API from your application by passing an Access Token in the `Authorization` header of your HTTP request as a Bearer token.\n\n*   [cURL](#9f78da9cadd04a57807c66dc9bd859db_shell)\n*   [C#](#9f78da9cadd04a57807c66dc9bd859db_csharp)\n*   [Go](#9f78da9cadd04a57807c66dc9bd859db_go)\n*   [Java](#9f78da9cadd04a57807c66dc9bd859db_java)\n*   [Node.JS](#9f78da9cadd04a57807c66dc9bd859db_node)\n*   [Obj-C](#9f78da9cadd04a57807c66dc9bd859db_objc)\n*   [...](#)\n    *   [PHP](#9f78da9cadd04a57807c66dc9bd859db_php)\n    *   [Python](#9f78da9cadd04a57807c66dc9bd859db_python)\n    *   [Ruby](#9f78da9cadd04a57807c66dc9bd859db_ruby)\n    *   [Swift](#9f78da9cadd04a57807c66dc9bd859db_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Obtaining an Access Token\n\nIf you are calling the API from a Single-Page Application or a Mobile/Native application, after the authorization flow is completed, you will get an Access Token. How you get the token and how you make the call to the API will be dependent on the type of application you are developing and the framework you are using. For more information refer to the relevant application Quickstarts which contain detailed instructions:\n\n*   [Single-Page Applications](https://auth0.com/docs/quickstart/spa)\n*   [Mobile / Native Application](https://auth0.com/docs/quickstart/native)\n\nIf you are calling the API from a command-line tool or another service, where there isn't a user entering their credentials, you need to use the [OAuth Client Credentials flow](https://auth0.com/docs/api/authentication#client-credentials). To do that, register a [Machine to Machine Application](https://manage.auth0.com/#/applications), and then subsequently use the **Client ID** and **Client Secret** of this application when making the request below and pass those along in the `client_id` and `client_secret` parameters respectively. Also include the Audience for the API you want to call.\n\n*   [cURL](#9088c1256ffa4f25a8a4088087214bd9_shell)\n*   [C#](#9088c1256ffa4f25a8a4088087214bd9_csharp)\n*   [Go](#9088c1256ffa4f25a8a4088087214bd9_go)\n*   [Java](#9088c1256ffa4f25a8a4088087214bd9_java)\n*   [Node.JS](#9088c1256ffa4f25a8a4088087214bd9_node)\n*   [Obj-C](#9088c1256ffa4f25a8a4088087214bd9_objc)\n*   [...](#)\n    *   [PHP](#9088c1256ffa4f25a8a4088087214bd9_php)\n    *   [Python](#9088c1256ffa4f25a8a4088087214bd9_python)\n    *   [Ruby](#9088c1256ffa4f25a8a4088087214bd9_ruby)\n    *   [Swift](#9088c1256ffa4f25a8a4088087214bd9_swift)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor testing purposes, you can also get an Access Token from the **Test** tab in your [API settings](https://manage.auth0.com/#/apis).\n\n## Test Your API\n\n**1\\. Calling the secure endpoint**\n\nYou can make a request to the `/api/private` endpoint without passing any Access Token:\n\n*   [cURL](#edcf6ea433ab41ffa76b94b9426b3590_shell)\n*   [C#](#edcf6ea433ab41ffa76b94b9426b3590_csharp)\n*   [Go](#edcf6ea433ab41ffa76b94b9426b3590_go)\n*   [Java](#edcf6ea433ab41ffa76b94b9426b3590_java)\n*   [Node.JS](#edcf6ea433ab41ffa76b94b9426b3590_node)\n*   [Obj-C](#edcf6ea433ab41ffa76b94b9426b3590_objc)\n*   [...](#)\n    *   [PHP](#edcf6ea433ab41ffa76b94b9426b3590_php)\n    *   [Python](#edcf6ea433ab41ffa76b94b9426b3590_python)\n    *   [Ruby](#edcf6ea433ab41ffa76b94b9426b3590_ruby)\n    *   [Swift](#edcf6ea433ab41ffa76b94b9426b3590_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {method: 'GET', url: 'http://localhost:3010/api/private'};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nconn.request(\"GET\", \"/api/private\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe API will return a 401 HTTP (Unauthorized) status code:\n\n![Response for unauthorized API request](https://auth0.com/docs/media/articles/server-apis/using/private-unauthorized.png)\n\nOnce again, make the same request but this time pass along the Access Token as a Bearer token in the **Authorization** header of the request:\n\n*   [cURL](#18f101ba124e4e198411b4986ec4883d_shell)\n*   [C#](#18f101ba124e4e198411b4986ec4883d_csharp)\n*   [Go](#18f101ba124e4e198411b4986ec4883d_go)\n*   [Java](#18f101ba124e4e198411b4986ec4883d_java)\n*   [Node.JS](#18f101ba124e4e198411b4986ec4883d_node)\n*   [Obj-C](#18f101ba124e4e198411b4986ec4883d_objc)\n*   [...](#)\n    *   [PHP](#18f101ba124e4e198411b4986ec4883d_php)\n    *   [Python](#18f101ba124e4e198411b4986ec4883d_python)\n    *   [Ruby](#18f101ba124e4e198411b4986ec4883d_ruby)\n    *   [Swift](#18f101ba124e4e198411b4986ec4883d_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis time the API will return a successful response:\n\n![Response for authorized API request](https://auth0.com/docs/media/articles/server-apis/using/private.png)\n\n**2\\. Testing the scoped endpoint**\n\nTo test the endpoint that requires a scope, pass the Access Token containing the correct scope as a Bearer token in the Authorization header:\n\n*   [cURL](#5db4f80f39564d528b32867354b52343_shell)\n*   [C#](#5db4f80f39564d528b32867354b52343_csharp)\n*   [Go](#5db4f80f39564d528b32867354b52343_go)\n*   [Java](#5db4f80f39564d528b32867354b52343_java)\n*   [Node.JS](#5db4f80f39564d528b32867354b52343_node)\n*   [Obj-C](#5db4f80f39564d528b32867354b52343_objc)\n*   [...](#)\n    *   [PHP](#5db4f80f39564d528b32867354b52343_php)\n    *   [Python](#5db4f80f39564d528b32867354b52343_python)\n    *   [Ruby](#5db4f80f39564d528b32867354b52343_ruby)\n    *   [Swift](#5db4f80f39564d528b32867354b52343_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private-scoped \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private-scoped\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private-scoped\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private-scoped\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private-scoped',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private-scoped\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private-scoped\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private-scoped\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private-scoped\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private-scoped\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the required scope is present, the API call is successful:\n\n![Response for scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped.png)\n\nIf the required scope is not present, the API returns a 403 HTTP Status (Forbidden):\n\n![Response for forbidden scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped-forbidden.png)",
  "title": "Auth0 ASP.NET Web API (OWIN) SDK Quickstarts: Using your API",
  "description": "This tutorial will show you how to use your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/django/02-using",
  "markdown": "# Auth0 Django API SDK Quickstarts: Using your API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Django API](https://auth0.com/docs/quickstart/backend/django)\n*   [Using your API](https://auth0.com/docs/quickstart/backend/django/02-using)\n\nThis tutorial will show you how to use your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Calling the API From Your Application\n\nYou can call the API from your application by passing an Access Token in the `Authorization` header of your HTTP request as a Bearer token.\n\n*   [cURL](#3ab34e1173964694b21c06d0da809886_shell)\n*   [C#](#3ab34e1173964694b21c06d0da809886_csharp)\n*   [Go](#3ab34e1173964694b21c06d0da809886_go)\n*   [Java](#3ab34e1173964694b21c06d0da809886_java)\n*   [Node.JS](#3ab34e1173964694b21c06d0da809886_node)\n*   [Obj-C](#3ab34e1173964694b21c06d0da809886_objc)\n*   [...](#)\n    *   [PHP](#3ab34e1173964694b21c06d0da809886_php)\n    *   [Python](#3ab34e1173964694b21c06d0da809886_python)\n    *   [Ruby](#3ab34e1173964694b21c06d0da809886_ruby)\n    *   [Swift](#3ab34e1173964694b21c06d0da809886_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Obtaining an Access Token\n\nIf you are calling the API from a Single-Page Application or a Mobile/Native application, after the authorization flow is completed, you will get an Access Token. How you get the token and how you make the call to the API will be dependent on the type of application you are developing and the framework you are using. For more information refer to the relevant application Quickstarts which contain detailed instructions:\n\n*   [Single-Page Applications](https://auth0.com/docs/quickstart/spa)\n*   [Mobile / Native Application](https://auth0.com/docs/quickstart/native)\n\nIf you are calling the API from a command-line tool or another service, where there isn't a user entering their credentials, you need to use the [OAuth Client Credentials flow](https://auth0.com/docs/api/authentication#client-credentials). To do that, register a [Machine to Machine Application](https://manage.auth0.com/#/applications), and then subsequently use the **Client ID** and **Client Secret** of this application when making the request below and pass those along in the `client_id` and `client_secret` parameters respectively. Also include the Audience for the API you want to call.\n\n*   [cURL](#877709cc7272452f981643b6597cea75_shell)\n*   [C#](#877709cc7272452f981643b6597cea75_csharp)\n*   [Go](#877709cc7272452f981643b6597cea75_go)\n*   [Java](#877709cc7272452f981643b6597cea75_java)\n*   [Node.JS](#877709cc7272452f981643b6597cea75_node)\n*   [Obj-C](#877709cc7272452f981643b6597cea75_objc)\n*   [...](#)\n    *   [PHP](#877709cc7272452f981643b6597cea75_php)\n    *   [Python](#877709cc7272452f981643b6597cea75_python)\n    *   [Ruby](#877709cc7272452f981643b6597cea75_ruby)\n    *   [Swift](#877709cc7272452f981643b6597cea75_swift)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor testing purposes, you can also get an Access Token from the **Test** tab in your [API settings](https://manage.auth0.com/#/apis).\n\n## Test Your API\n\n**1\\. Calling the secure endpoint**\n\nYou can make a request to the `/api/private` endpoint without passing any Access Token:\n\n*   [cURL](#db22105261fc464e8c808ef23176be05_shell)\n*   [C#](#db22105261fc464e8c808ef23176be05_csharp)\n*   [Go](#db22105261fc464e8c808ef23176be05_go)\n*   [Java](#db22105261fc464e8c808ef23176be05_java)\n*   [Node.JS](#db22105261fc464e8c808ef23176be05_node)\n*   [Obj-C](#db22105261fc464e8c808ef23176be05_objc)\n*   [...](#)\n    *   [PHP](#db22105261fc464e8c808ef23176be05_php)\n    *   [Python](#db22105261fc464e8c808ef23176be05_python)\n    *   [Ruby](#db22105261fc464e8c808ef23176be05_ruby)\n    *   [Swift](#db22105261fc464e8c808ef23176be05_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {method: 'GET', url: 'http://localhost:3010/api/private'};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nconn.request(\"GET\", \"/api/private\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe API will return a 401 HTTP (Unauthorized) status code:\n\n![Response for unauthorized API request](https://auth0.com/docs/media/articles/server-apis/using/private-unauthorized.png)\n\nOnce again, make the same request but this time pass along the Access Token as a Bearer token in the **Authorization** header of the request:\n\n*   [cURL](#1c2804777eee46d396b78b80d3dd0151_shell)\n*   [C#](#1c2804777eee46d396b78b80d3dd0151_csharp)\n*   [Go](#1c2804777eee46d396b78b80d3dd0151_go)\n*   [Java](#1c2804777eee46d396b78b80d3dd0151_java)\n*   [Node.JS](#1c2804777eee46d396b78b80d3dd0151_node)\n*   [Obj-C](#1c2804777eee46d396b78b80d3dd0151_objc)\n*   [...](#)\n    *   [PHP](#1c2804777eee46d396b78b80d3dd0151_php)\n    *   [Python](#1c2804777eee46d396b78b80d3dd0151_python)\n    *   [Ruby](#1c2804777eee46d396b78b80d3dd0151_ruby)\n    *   [Swift](#1c2804777eee46d396b78b80d3dd0151_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis time the API will return a successful response:\n\n![Response for authorized API request](https://auth0.com/docs/media/articles/server-apis/using/private.png)\n\n**2\\. Testing the scoped endpoint**\n\nTo test the endpoint that requires a scope, pass the Access Token containing the correct scope as a Bearer token in the Authorization header:\n\n*   [cURL](#8c3b896c268845fabdafd64ab20d2c06_shell)\n*   [C#](#8c3b896c268845fabdafd64ab20d2c06_csharp)\n*   [Go](#8c3b896c268845fabdafd64ab20d2c06_go)\n*   [Java](#8c3b896c268845fabdafd64ab20d2c06_java)\n*   [Node.JS](#8c3b896c268845fabdafd64ab20d2c06_node)\n*   [Obj-C](#8c3b896c268845fabdafd64ab20d2c06_objc)\n*   [...](#)\n    *   [PHP](#8c3b896c268845fabdafd64ab20d2c06_php)\n    *   [Python](#8c3b896c268845fabdafd64ab20d2c06_python)\n    *   [Ruby](#8c3b896c268845fabdafd64ab20d2c06_ruby)\n    *   [Swift](#8c3b896c268845fabdafd64ab20d2c06_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private-scoped \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private-scoped\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private-scoped\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private-scoped\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private-scoped',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private-scoped\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private-scoped\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private-scoped\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private-scoped\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private-scoped\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the required scope is present, the API call is successful:\n\n![Response for scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped.png)\n\nIf the required scope is not present, the API returns a 403 HTTP Status (Forbidden):\n\n![Response for forbidden scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped-forbidden.png)",
  "title": "Auth0 Django API SDK Quickstarts: Using your API",
  "description": "This tutorial will show you how to use your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions",
  "markdown": "# Handle Declined Authorization Permissions\n\nWhen your users are authorizing your application, some providers (such as Facebook) allow the user to select the attributes they wish to share.\n\nBy default, this selection is made only when the user authorizes the app for the first time. If your user chooses to not allow certain attributes (such as their email) that are required by your application, the user will not be able to access your application.\n\nIn such instances, your user will need to be re-prompted to grant permission to the required attribute(s) to login.\n\n## Re-prompt for permissions\n\nBy setting the **prompt=consent** parameter when calling the [/authorize](https://auth0.com/docs/api/authentication/reference#social) endpoint of the [Authorization API](https://auth0.com/docs/api/authentication), your user will be prompted again to grant permissions for your application.\n\nThis parameter can also be set using Lock as an [Authentication Parameter](https://auth0.com/docs/libraries/lock/lock-authentication-parameters) with **prompt: 'consent'**.\n\nAlternatively, you can set this with [Auth0.js](https://github.com/auth0/auth0.js) using **prompt: 'consent'**.\n\n## Keep reading\n\n*   [Learn more about handling declined Facebook permissions](https://developers.facebook.com/docs/facebook-login/handling-declined-permissions)\n    \n*   [Learn more about GitHub scopes](https://developer.github.com/v3/oauth/#scopes)",
  "title": "Handle Declined Authorization Permissions",
  "description": "Learn how to re-prompt the user to grant permissions for your application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims",
  "markdown": "# Sample Use Cases: Scopes and Claims\n\nIn these examples, we use the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) to authenticate a user and request the necessary permissions (scopes) and tokens. For details on the request parameters or to learn how to fully implement this flow, read our tutorial: [Add Login to Regular Web Applications](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow).\n\n## Authenticate a user and request standard claims\n\nIn this example, we want to authenticate a user and get user details that will allow us to personalize our user interface. To do this, we need to get an ID token that contains the user's name, nickname, profile picture, and email information.\n\n1.  Initiate the authentication flow by sending the user to the authorization URL:\n    \n    ```\n    https://{yourDomain}/authorize?\n      response_type=code&\n      client_id={yourClientId}&\n      redirect_uri={https://yourApp/callback}&\n      scope=openid%20profile%20email&\n      state=YOUR_STATE_VALUE\n    ```\n    \n    Notice that in this example:\n    *   The `response_type` parameter includes one value:\n        \n        *   `code`: because we are using the regular web app flow, our initial request is for an authorization code; when we request our tokens using this code, we will receive the ID Token we need for authentication.\n            \n    *   The `scope` parameter includes three values; the requested OIDC scopes:\n        \n        *   `openid`: to indicate that the application intends to use OIDC to verify the user's identity.\n            \n        *   `profile`: to get `name`, `nickname`, and `picture`.\n            \n        *   `email`: to get `email` and `email_verified`.\n            \n2.  After the user consents (if necessary) and Auth0 redirects back to your app, [request tokens](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow).\n    \n3.  Extract the ID token from the response and [decode it](https://auth0.com/docs/secure/tokens/id-tokens). You should see the following claims:\n    \n    ```\n    {\n      \"name\": \"John Doe\",\n      \"nickname\": \"john.doe\",\n      \"picture\": \"https://myawesomeavatar.com/avatar.png\",\n      \"updated_at\": \"2017-03-30T15:13:40.474Z\",\n      \"email\": \"john.doe@test.com\",\n      \"email_verified\": false,\n      \"iss\": \"https://{yourDomain}/\",\n      \"sub\": \"auth0|USER-ID\",\n      \"aud\": \"{yourClientId}\",\n      \"exp\": 1490922820,\n      \"iat\": 1490886820,\n      \"nonce\": \"crypto-value\",\n      \"at_hash\": \"IoS3ZGppJKUn3Bta_LgE2A\"\n    }\n    ```\n    \n    Your app can now retrieve the user attributes and use them to personalize your UI.\n\n## Request custom API access\n\nIn this example, we request a custom scope for a calendar API that will authorize the calling application to read appointments for the user. To do this, we want to get an access token containing the proper scope to read appointments from the API. Note that requesting an access token is not dependent on requesting an ID token.\n\nBefore using a custom API, you need to know what scopes are available for the API you are calling. If the custom API is under your control, you need to register both your application and API with Auth0 and [define the scopes for your API using the Auth0 Dashboard](https://auth0.com/docs/get-started/apis/scopes/api-scopes). You can also use defined permissions to [customize the consent prompt](https://auth0.com/docs/customize/login-pages/customize-consent-prompts) for your users.\n\n1.  Initiate the authorization flow by sending the user to the authorization URL:\n    \n    ```\n    https://{yourDomain}/authorize?\n      response_type=code&\n      client_id={yourClientId}&\n      redirect_uri={https://yourApp/callback}& \n      scope=read:appointments&\n      audience=YOUR_API_AUDIENCE&\n      state=YOUR_STATE_VALUE\n    ```\n    \n    Notice that in this example:\n    *   The `response_type` parameter still includes one value:\n        \n        *   `code`: because we are using the regular web app flow, our initial request is for an authorization code; when we request our tokens using this code, we will receive the Access Token that we can use to call our API.\n            \n    *   the `scope` parameter includes one value; the requested API scope:\n        \n        *   `read:appointments`: to allow us to read the user's appointments from the API.\n            \n    *   The `audience` parameter is new and includes one value:\n        \n        *   The unique identifier of the API from which we want to read the user's appointments.\n            \n2.  As in the previous example, after the user consents (if necessary) and Auth0 redirects back to your app, [request tokens](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow).\n    \n3.  Extract the access token from the response, and call the API using the access token as credentials.\n    \n\n## Authenticate a user and request standard claims and custom API access\n\nIn this example, we combine our previous two examples to authenticate a user, request standard claims, and also request a custom scope for a calendar API that will allow the calling application to read appointments for the user. To do this, get two tokens:\n\n*   ID token that contains:\n    \n    *   User name\n        \n    *   Nickname\n        \n    *   Profile picture\n        \n    *   Email information\n        \n*   Access token that contains the proper scope to read appointments from the API. Note that requesting an access token is not dependent on requesting an ID token.\n    \n\nBefore using a custom API, you need to know what scopes are available for the API you are calling. If the custom API is under your control, you need to register both your application and API with Auth0 and [define the scopes for your API using the Auth0 Dashboard](https://auth0.com/docs/get-started/apis/scopes/api-scopes). You can also use defined permissions to [customize the consent prompt](https://auth0.com/docs/customize/login-pages/customize-consent-prompts) for your users.\n\n1.  Initiate the authentication flow by sending the user to the authorization URL:\n    \n    ```\n    https://{yourDomain}/authorize?\n      response_type=code&\n      client_id={yourClientId}&\n      redirect_uri={https://yourApp/callback}& \n      scope=openid%20profile%20email%20read:appointments&\n      audience=YOUR_API_AUDIENCE&\n      state=YOUR_STATE_VALUE\n    ```\n    \n    Notice that in this example:\n    *   The `response_type` parameter still includes one value:\n        \n        *   `code`: because we are using the regular web app flow, our initial request is for an authorization code; when we request our tokens using this code, we will receive both the ID token we need for authentication and the access token that we can use to call our API.\n            \n    *   The `scope` parameter is used for both OIDC scopes and API scopes, so now includes four values:\n        \n        *   `openid`: to indicate that the application intends to use OIDC to verify the user's identity.\n            \n        *   `profile`: to get `name`, `nickname`, and `picture`.\n            \n        *   `email`: to get `email` and `email_verified`.\n            \n        *   `read:appointments`: to allow us to read the user's appointments from the API.\n            \n    *   the `audience` parameter includes one value:\n        \n        *   The unique identifier of the API from which we want to read the user's appointments\n            \n2.  As in the previous examples, after the user consents (if necessary) and Auth0 redirects back to your app, request tokens.\n    \n3.  Extract the ID token from the response, decode it, and retrieve the user attributes and use them to personalize your UI.\n    \n4.  Extract the access token from the response, and call the API using the access token as credentials.\n    \n\n## Add custom claims to a token\n\nIn this example, we add a user's favorite color and preferred contact method to the ID Token. To do this, we create an [Action](https://auth0.com/docs/customize/actions) to customize the ID token by adding these [claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims). Once added, we will also be able to obtain the custom claims when calling the `/userinfo` endpoint (though the Action will run only during the authentication process).\n\nSuppose that:\n\n*   At some point, the user selected a `preferred_contact` method of `email` and a `favorite_color` of `red`, and we saved it as part of the user's `user_metadata`.\n    \n*   We've used the [Management API](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) or the Dashboard to set application-specific information for this user.\n    \n\nIn this case, the Auth0-stored [normalized user profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles) is:\n\n```\n{\n  \"email\": \"jane@example.com\",\n  \"email_verified\": true,\n  \"user_id\": \"custom|123\",\n  \"favorite_color\": \"blue\",\n  \"user_metadata\": {\n    \"preferred_contact\": \"email\"\n  }\n}\n```\n\nFor this profile, Auth0 would normally return the following ID Token claims to your application:\n\n```\n{\n  \"email\": \"jane@example.com\",\n  \"email_verified\": true,\n  \"iss\": \"https://my-domain.auth0.com/\",\n  \"sub\": \"custom|123\",\n  \"aud\": \"my_client_id\",\n  \"iat\": 1311280970,\n  \"exp\": 1311281970\n}\n```\n\nNotice that in this example:\n\n*   The `sub` claim contains the value of the `user_id` property.\n    \n*   Neither the `favorite_color` nor `user_metadata` properties are present because OpenID Connect (OIDC) does not define standard claims that represent `favorite_color` or `user_metadata`.\n    \n\nTo receive the custom data, we'll need to [create a new Action](https://auth0.com/docs/customize/actions/write-your-first-action) to customize the token with a [custom claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims) that represent these properties from the user profile.\n\n1.  Navigate to [Auth0 Dashboard > Actions > Library](https://manage.auth0.com/#/actions/library), and select **Build Custom**.\n    \n2.  Enter a descriptive **Name** for your Action (for example, `Add user metadata to tokens`), select the `Login / Post Login` trigger because you’ll be adding the Action to the Login flow, then select **Create**.\n    \n3.  Locate the Actions Code Editor, copy the following JavaScript code into it, and select **Save Draft** to save your changes:\n    \n    ```\n    exports.onExecutePostLogin = async (event, api) => {\n      const namespace = 'https://myapp.example.com';\n      const { favorite_color, preferred_contact } = event.user.user_metadata;\n    \n      if (event.authorization) {\n        // Set claims \n        api.idToken.setCustomClaim(`${namespace}/favorite_color`, favorite_color);\n        api.idToken.setCustomClaim(`${namespace}/preferred_contact`, preferred_contact);\n      }\n    };\n    ```\n    \n4.  From the Actions Code Editor sidebar, select Test (play icon), then select **Run** to [test your code](https://auth0.com/docs/customize/actions/test-actions).\n    \n5.  When you’re ready for the Action to go live, select **Deploy**.\n    \n\nFinally, add the Action you created to the [Login Flow](https://manage.auth0.com/#/actions/flows/login/). To learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\nWith this Action enabled, Auth0 will include the `favorite_color` and `preferred_contac`t custom claims in the ID Token:\n\n```\n{\n  \"email\": \"jane@example.com\",\n  \"email_verified\": true,\n  \"iss\": \"https://my-domain.auth0.com/\",\n  \"sub\": \"custom|123\",\n  \"aud\": \"my_client_id\",\n  \"iat\": 1311280970,\n  \"exp\": 1311281970,\n  \"https://myapp.example.com/favorite_color\": \"red\",\n  \"https://myapp.example.com/preferred_contact\": \"email\"\n}\n```\n\nWhen creating your Action, make sure to set some logic that determines when to include additional claims. Injecting custom claims into every ID Token that is issued is not ideal.\n\nThis example shows custom claims being added to an ID Token, which uses the `api.idToken.setCustomClaims` method. To add these claims to an Access Token, use the `api.accessToken.setCustomClaim` method.\n\nTo learn more about the event object for the trigger, read [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object). To learn more about tokens, read [Tokens](https://auth0.com/docs/secure/tokens).\n\n## Learn more\n\n*   [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes)\n*   [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims)\n*   [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes)\n*   [Configure Logical API for Multiple APIs](https://auth0.com/docs/get-started/apis/set-logical-api)",
  "title": "Sample Use Cases: Scopes and Claims",
  "description": "Learn how to use scopes and claims with applications and APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/tiktok",
  "markdown": "# Create a Custom Social Connection with TikTok\n\n## Configure TikTok\n\nYou can use TikTok as a social login to your application. Access and configure your TikTok developer account using the following steps:\n\n1.  In TikTok developer, select **Manage apps**.\n    \n2.  Select **Connect an app**.\n    \n3.  Under the **Configuration** section, add an application icon, application name, and description.\n    \n4.  Under **Platforms**, choose your application type:\n    \n    1.  For Web applications, add a valid URL.\n        \n    2.  For Android, add the Android package name, Play Store URL, and application signature(s).\n        \n    3.  For iOS, add the App Store URL and Bundle ID.\n        \n5.  Under the Product menu, select **Add Product**.\n    \n6.  Select the **Login Kit**.\n    \n7.  Then, select the **TikTok API**.\n    \n8.  In the Product section, add the URL of your Terms of Service page, the URL of your Privacy Policy page, and your redirect domain to the Login Kit. The redirect domain is your Auth0 domain found in [Dashboard > Applications > Applications](http://manage.auth0.com/#/applications) under the **Settings** tab. For example: `dev-test-1.us.auth0.com`.\n    \n9.  Select **Save Changes**. Then, select **Submit for review**.\n    \n10.  Wait until your application status moves from `Staging` to `Production`. It could take up to several hours for TikTok to review your application and update the status.\n    \n\n## Configure Auth0\n\nYou must create a custom connection to associate your TikTok instance with Auth0.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Social](http://manage.auth0.com/#/social).\n    \n2.  Choose **Create Connection**.\n    \n3.  Scroll to the bottom of the list and choose **Create Custom**.\n    \n4.  Enter the following to create a **New Custom Social Connection**:\n    \n    1.  Name: TikTok\n        \n    2.  Authorization URL: TikTok’s Authorization URL `https://www.tiktok.com/auth/authorize/`\n        \n    3.  Token URL: This will eventually be your proxy. Use a placeholder URL: `https://example.com`\n        \n    4.  Scope: `user.info.basic`\n        \n    5.  Client ID: Client key assigned to you by TikTok\n        \n    6.  Client Secret: Client secret assigned to you by TikTok\n        \n5.  Configure the [Fetch User Profile Script](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/oauth2#fetch-user-profile-script) to fetch profile information from [TikTok's user\\_info endpoint](https://developers.tiktok.com/doc/tiktok-api-v2-get-user-info/). Map attributes to Auth0’s normalized user profile.\n    \n\n```\nfunction fetchUserProfile(accessToken, context, cb) {\n  const axios = require('axios@0.22.0');\n  const userInfoEndpoint = 'https://open.tiktokapis.com/v2/user/info?fields=union_id';\n  const headers = { 'Authorization': 'Bearer ' + accessToken };\n\n  axios\n    .get(userInfoEndpoint, { headers })\n    .then(res => {\n      if (res.status !== 200) {\n        return cb(new Error(res.data));\n      }\n\n      const profile = {\n        user_id: res.data.user.union_id,\n      };\n\n      cb(null, profile);\n    })\n    .catch(err => cb(err));\n}\n```\n\n6\\. Click **Create**.\n\n7\\. Navigate to the application you want to use with the TikTok connection under [Dashboard > Applications > Applications](http://manage.auth0.com/#/applications).\n\n8\\. Under the **Connections** tab, toggle on the TikTok option.\n\n## Pass customs parameters to TikTok with the Management API\n\nSince TikTok uses a `client_key` parameter instead of `client_id`, you must use the Management API to pass the `client_key` parameter during authentication.\n\nTo use the Management API, you need to generate an access token.\n\n1.  Navigate to Auth0 [Dashboard > Applications > APIs](http://manage.auth0.com/#/apis) and select the **Auth0 Management API**.\n    \n2.  Select the **API Explorer** tab.\n    \n3.  Select **Create & Authorize Test Application.**\n    \n    ![Screenshot of Create & Authorize Test Application for TikTok](https://images.ctfassets.net/cdy7uua7fh8z/6S8RzEMC4lV9bS7XCPWRMY/697d0270b3623a70d4406985361a9b1b/image3.png)\n4.  Copy the provided token.\n    \n5.  Navigate to the [Auth0 Management API Explorer](https://auth0.com/docs/api/management/v2). You may need to open an incognito window.\n    \n6.  Select **Set API Token** in the top, left-hand corner.\n    \n    ![Screenshot of Set API Token for TikTok](https://images.ctfassets.net/cdy7uua7fh8z/6994KjTIdvDNrye8ghN4og/a6d1eb83bce4a5b38f8ebce7188ee2ca/image2.png)\n7.  Paste the token and select **Set Token**.\n    \n\nYou should now be able to configure your Auth0 tenant with the Management API.\n\n### Configure the \\`client\\_key\\` field\n\n1.  Use the [Get a connection](https://auth0.com/docs/api/management/v2#!/Connections/get_connections_by_id) method to retrieve the \\`options\\` object values. The following is a sample response object:\n    \n\n```\n{\n  \"options\": {\n    \"client_id\": \"\",\n    \"client_secret\": \"\",\n    \"scope\": \"user.info.basic\"\n  }\n}\n```\n\n2\\. Add the `upstream_params` object with the `client_key` field:\n\n```\n{\n  \"options\": {\n    \"client_id\": \"\",\n    \"client_secret\": \"\",\n    \"scope\": \"user.info.basic\",\n    \"upstream_params\": { \n      \"client_key\": { \"value\": \"<Client Key from TikTok>\" } \n    }\n  }\n}\n```\n\n3\\. Use the [Update a connection](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) method with the `options` object as the body. Auth0 will send the `client_key=<value>` parameter to [TikTok's authorization endpoint](https://developers.tiktok.com/doc/login-kit-web/).\n\n## Access token request\n\nYou cannot pass custom parameters in a request to the Authentication API's [`/token`](https://developers.tiktok.com/doc/login-kit-manage-user-access-tokens/) endpoint to gain an access or ID token. You must proxy the request to the token endpoint and append the `client_key` parameter programmatically with proxy endpoints in your environment.\n\n### Deploy TikTok integration proxy\n\n1.  Use the sample code from the [GitHub](https://github.com/tylerkeesling/tiktok-access-token-proxy) repository and follow the instructions in the README to install dependencies and start the development server.\n    \n    1.  The example server has one `POST` route, `/proxy/token`. The server should be running on `http://localhost:3333`. \n        \n2.  Copy the proxy endpoint to be used in your TikTok Developer setup. The proxy endpoint should be something similar to: [`https://405a-104-129-13b-250.ngrok.io/proxy/token`](https://405a-104-129-13b-250.ngrok.io/proxy/token).\n    \n3.  In TikTok Developer, navigate back to the social connection configuration. Update the Token URL that you set to `https://example.com` and enter the proxy URL.\n    \n\nOnce the configuration is saved, your users should be able to log in with TikTok.",
  "title": "Create a Custom Social Connection with TikTok",
  "description": "Learn how to create a custom social connection with TikTok ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-1",
  "markdown": "# Solution Overview (SPAs + API)\n\nIn order to ensure that only authorized users and applications are allowed access to the Timesheets API, ExampleCo has decided to make use of the [OAuth 2.0 authorization framework](https://tools.ietf.org/html/rfc6749). The framework provides the flexibility the company wants since the different grants can allow them to easily authorize the various types of applications which need to communicate with the Timesheets API.\n\nAn API is a way to expose functionality of your application to other applications. An application can make a request by sending a message to an endpoint on an API and receive information as a response.\n\nAn API endpoint can be secured or not. In our case, since the timesheets are sensitive information that affect reviews and payments, it is important to ensure that only authorized users and applications can call the endpoints on our API. When a client application wants to access protected endpoints on an API, it needs to present an Access Token as proof that it has the required permissions for making the call to the endpoint.\n\nAn Access Token is obtained by authenticating the user with an Authorization Server and the user can then, in turn, authorize the application to access the API on their behalf.\n\n#### What is an Access Token?\n\nAn Access Token (also referred to as `access_token`) is an opaque string representing an authorization issued to the application. It may denote an identifier used to retrieve the authorization information or may self-contain the authorization information (for example, the user's identity, permissions, and so forth) in a verifiable manner.\n\nIt is quite common for Access Tokens to be implemented as [JSON Web Tokens](https://auth0.com/docs/tokens/concepts/jwts).\n\nFor more information on Auth0 Access Tokens refer to [Access Token](https://auth0.com/docs/tokens/concepts/access-tokens).\n\nAn API can enforce fine-grained control over who can access the various endpoints exposed by the API. These permissions are expressed as scopes.\n\nWhen a user authorizes a client application, the application can also indicate which permissions it requires. The user is then allowed to review and grant these permissions. These permissions are then included in the Access Token as part of the `scope` claim.\n\nSubsequently, when the client passes along the Access Token when making requests to the API, the API can inspect the `scope` claim to ensure that the required permissions were granted in order to call the particular API endpoint.\n\n#### What are Scopes?\n\nEach Access Token may include a list of the permissions that have been granted to the client. When a client authenticates with Auth0, it will specify the list of scopes (or permissions) it is requesting. If those scopes are authorized, then the Access Token will contain a list of authorized scopes.\n\nFor example, the timesheet API may accept four different levels of authorization: reading timesheets (scope `read:timesheets`), creating timesheets (scope `create:timesheets`), deleting timesheets (scope `delete:timesheets`) and approving timesheets (scope `approve:timesheets`).\n\nWhen a client asks the API to create a new timesheet entry, then the Access Token should contain the `create:timesheets` scope. In a similar fashion, in order to delete existing timesheets, the Access Token should contain the `delete:timesheets` scope.\n\nFor more information on scopes refer to [Scopes](https://auth0.com/docs/scopes).\n\nBy using the OAuth 2.0 authorization framework, you can give your own applications or third-party applications limited access to your APIs on behalf of the application itself. Using Auth0, you can easily support different flows in your own APIs without worrying about the OAuth 2.0/OpenID Connect (OIDC) specification, or the many other technical aspects of API authorization.\n\n#### OAuth roles\n\nIn any OAuth 2.0 flow we can identify the following roles:\n\n*   **Resource Owner**: the entity that can grant access to a protected resource. Typically this is the end-user.\n    \n*   **Resource Server**: the server hosting the protected resources. This is the API you want to access.\n    \n*   **Client**: an application requesting access to a protected resource on behalf of the Resource Owner.\n    \n*   **Authorization Server**: the server that authenticates the Resource Owner, and issues Access Tokens after getting proper authorization. In this case, Auth0.\n    \n\nUsing [different grants types (or flows)](https://auth0.com/docs/api-auth/which-oauth-flow-to-use), these participants will interact to grant to the client apps limited access to the APIs you are building. As a result, the client app will obtain an Access Token that can be used to call the API on behalf of the user.\n\n## Implicit Grant\n\nOAuth 2.0 provides several **grant types** for different use cases. In this particular use case, we want to access the API from a [client-side app](https://auth0.com/docs/quickstart/spa).\n\nThe SPA will use the [Implicit Flow (Implicit Grant)](https://auth0.com/docs/flows/concepts/implicit) to do so.\n\nThe Implicit Grant (defined in [RFC 6749, section 4.1](https://tools.ietf.org/html/rfc6749#section-4.2)) is similar to the grant used in the [Authorization Code Flow](https://auth0.com/docs/flows/concepts/auth-code), but the main difference is that the application receives an Access Token directly, without the need for an `authorization_code`. This happens because the application, which is typically a JavaScript app running within a browser, is less trusted than a web app running on the server, hence cannot be trusted with the `client_secret` (which is required in the Authorization Code Grant).\n\nOnce the user authenticates, the application receives the ID Token and Access Token in the hash fragment of the URI. The application can now use the ID Token to obtain information about the user, and Access Token to call the API on behalf of the user.\n\n![Diagram - Microsite - Implicit Grant](https://images.ctfassets.net/cdy7uua7fh8z/2qt25H8agpipvMYQngZu0X/1870c664d33eb127d07953e2b9cf5321/implicit-grant.png)\n\n1.  The app initiates the flow and redirects the browser to Auth0 (specifically to the [/authorize endpoint](https://auth0.com/docs/api/authentication#implicit-grant)), so the user can authenticate.\n    \n2.  Auth0 authenticates the user. The first time the user goes through this flow, and if the application is a third party application, a consent page will be shown where the permissions, that will be given to the Client, are listed (for example, post messages, list contacts, and so forth).\n    \n3.  Auth0 redirects the user to the app with an Access Token (and optionally an ID Token) in the hash fragment of the URI. The app can now extract the tokens from the hash fragment.\n    \n4.  The app can use the Access Token to call the API on behalf of the user.\n    \n\n## Authorization Extension\n\nThe [Auth0 Authorization Extension](https://auth0.com/docs/extensions/authorization-extension) allows you to configure Roles, Groups, and Permissions, and assign them to Users.\n\n*   The Permissions are actions that someone can do. For ExampleCo's business needs, we will configure four Permissions: read, create, delete and approve timesheets.\n    \n*   The Roles are collections of Permissions. ExampleCo's timesheets app will be used by two kinds of users (employees and managers), with different permissions each, so we will configure two Roles: employee and manager.\n    \n\nSince this covers our business case we will not create any Groups.\n\nThe Authorization Extension will create a [Rule](https://auth0.com/docs/rules) which will read the Roles, Groups, and Permissions assigned to a user and add this information to the [User profile](https://auth0.com/docs/rules/current#rule-syntax) during the authentication flow. We can use this information to ensure that the Access Token issued to a user only contains scopes which are allowed. We can later on proceed to customize our app, like disabling the Approve Timesheets functionality if the user does not have the required permission to do so.",
  "title": "Solution Overview (SPAs + API)",
  "description": "Solution overview for the SPA + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-2",
  "markdown": "# Auth0 Configuration (SPAs + API)\n\nIn this section we will review all the configurations we need to apply at the [Auth0 Dashboard](https://manage.auth0.com/#).\n\n## Create the API\n\nNavigate to the [APIs section](https://manage.auth0.com/#/apis) of the dashboard, and click the **Create API** button.\n\nYou will be asked to supply the following details for your API:\n\n*   **Name**: a friendly name for the API. Does not affect any functionality.\n    \n*   **Identifier**: a unique identifier for the API. We recommend using a URL but note that this doesn't have to be a publicly available URL, Auth0 will not call your API at all. This value cannot be modified afterwards.\n    \n*   **Signing Algorithm**: the algorithm to sign the tokens with. The available values are `HS256` and `RS256`. When selecting RS256 the token will be signed with the tenant's private key. To learn more about signing algorithms, see [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms).\n    \n\n![Dashboard - Applications - APIs - Create API - Popup](https://images.ctfassets.net/cdy7uua7fh8z/4kIH4BQc4vDel2zhJ6lwCE/6812a7ec36119cde0fbe10801e4c0394/dashboard-apis-create_create-popup_default-empty.png)\n\nFill in the required information and click the **Create** button.\n\n## Configure the Scopes\n\nOnce the application has been created you will need to configure the Scopes which applications can request during authorization.\n\nIn the settings for your API, go to the Permissions tab. In this section you can add the scopes for our business case: `read:timesheets`, `create:timesheets`, `delete:timesheets`, and `approve:timesheets`.\n\n![Dashboard - Applications - APIs - Permissions](https://images.ctfassets.net/cdy7uua7fh8z/xxMOKezob6gNHJ0CcKhcg/4a8d4bcffc6a641ae3d0fa1416687390/dashboard-apis-edit_view-permissions.png)\n\n## Create the Application\n\nThere are four application types in Auth0:\n\n*   **Native App** (used by mobile or desktop apps),\n    \n*   **Single-Page Web App**,\n    \n*   **Regular Web App** and\n    \n*   **Machine to Machine App** (used by CLIs, Daemons, or services running on your backend).\n    \n\nFor this scenario we want to create a new Application for our SPA, hence we will use Single-Page Application as the application type.\n\nTo create a new Application, navigate to the [dashboard](https://manage.auth0.com/#) and click on the [Applications](https://manage.auth0.com/#/applications) menu option on the left. Click the **\\+ Create Application** button.\n\nSet a name for your Application (we will use `Timesheets SPA`) and select `Single-Page Web App` as the type.\n\nClick **Create**.\n\n![Dashboard - Applications - Create Application - SPA](https://images.ctfassets.net/cdy7uua7fh8z/Txo1qMBEJEjsi7p0q3NqS/4778c79b7779cb00344dadb02e61f208/dashboard-applications-create_create-popup-spa_default.png)\n\nThat's it for now. When we are done with the SPA implementation we will revisit the dashboard and this Application's settings to make some changes in its configuration.\n\nYou will need to ensure that the Authorization Extension is installed for your tenant. You can refer to the [Authorization Extension documentation](https://auth0.com/docs/customize/extensions/authorization-extension) for details on how to do this.\n\n### Define Permissions\n\nYou will now define the required Permissions, according to the scopes you have already defined: `read:timesheets`, `create:timesheets`, `delete:timesheets`, and `approve:timesheets`.\n\nIn the Authorization Extension, click the **Permissions** tab, and then click on the **Create Permission** button.\n\nIn the dialog, capture the details for each permission.\n\nEnsure that the name of the permission is exactly the same as the corresponding scope:\n\n![Dashboard - Extensions - Authorization Extension - Create Permission](https://images.ctfassets.net/cdy7uua7fh8z/6G4X14X3A73IDRwOrkmttq/e0c20c44a32e0b39a6d8fb72731ffbaf/create-permission.png)\n\nProceed to create the permissions for all the remaining scopes:\n\n![Dashboard - Extensions - Authorization Extension - Permissions](https://images.ctfassets.net/cdy7uua7fh8z/7xXKToJucvrQudC33Bp7dC/a99f933fc75ad55e55a8916c81812d42/permissions.png)\n\n### Define Roles\n\nNext let's configure the two Roles: employee and manager.\n\nHead over to the **Roles** tab, click the **Create Role** button, and select the **Timesheets SPA** application.\n\nSet the **Name** and **Description** to `Employee`, and select the `delete:timesheets`, `create:timesheets` and `read:timesheets` permissions. Click on **Save**.\n\nNext, follow the same process to create a `Manager` role, and ensure that you have selected all the permissions.\n\n### Assign Users to Roles\n\nYou need to assign all users to either the `Manager` or the `Employee` role.\n\nYou can do this by going to the **Users** tab in the Authorization Extension and selecting a user.\n\nOn the user information screen, go to the **Roles** tab. Click **Add Role to User**, and select the appropriate role.\n\n![Dashboard - Extensions - Authorization Extension - Add User to Role](https://images.ctfassets.net/cdy7uua7fh8z/46pOmEIjr5ct2KJfd4jb2/d5ebf5a3705fe965f0ce55b12cd2b343/add-user-role.png)\n\n### Configuring the Authorization Extension\n\nYou will also need to ensure that the Rule for the Authorization Extension is published.\n\nTo do so, click on your user avatar in the top right of the Authorization Extension, and select **Configuration**.\n\n![Dashboard - Extensions - Authorization Extension - Navigate to Configuration](https://images.ctfassets.net/cdy7uua7fh8z/2OdiLzYMcrlS7Sh84qEmom/8e29123022cf3137cd04162b94b6582d/select-configuration.png)\n\nMake sure that **Permissions** are enabled and then click **Publish Rule**.\n\n### Create a Rule to validate token scopes\n\nThe final step in this process is to create a Rule to check if the scopes contained in an Access Token are valid based on the permissions assigned to the user. Any scopes which are not valid for a user should be removed from the Access Token.\n\nIn your Auth0 Dashboard, go to the **Rules** tab. You should see the Rule created by the Authorization Extension. Click on the **Create Rule** button and select the **Empty Rule** template. You can give the Rule a name, such as **Access Token Scopes**, and then specify the following code for the Rule:\n\n```\nfunction (user, context, callback) {\n  var permissions = user.permissions || [];\n  var requestedScopes = context.request.body.scope || context.request.query.scope;\n  var filteredScopes = requestedScopes.split(' ').filter( function(x) {\n    return x.indexOf(':') < 0;\n  });\n\n  var allScopes = filteredScopes.concat(permissions);\n  context.accessToken.scope = allScopes.join(' ');\n\n  callback(null, user, context);\n}\n```\n\nThe code above will ensure that all Access Tokens will only contain the properly-formatted scopes (e.g., `action:area` or `delete:timesheets`) which are valid according to a user's permissions. Once you are done you can click on the **Save** button.\n\nRules execute in the order they are displayed on the Rules page, so ensure that the new rule you created is positioned below the rule for the Authorization Extension, so it executes after the Authorization Extension rule.",
  "title": "Auth0 Configuration (SPAs + API)",
  "description": "Auth0 Configuration for the SPA + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-3",
  "markdown": "# API and SPA Configuration (SPAs + API)\n\nIn this section we will see how we can implement an API for our scenario.\n\n## Define the API endpoints\n\nFirst we need to define the endpoints of our API.\n\n#### What is an API endpoint?\n\nAn **API endpoint** is a unique URL that represents an object. To interact with this object, you need to point your application to its URL. For example, if you had an API that could return either orders or customers, you might configure two endpoints: `/orders` and `/customers`. Your application would interact with these endpoints using different HTTP methods; for example, `POST /orders` could create a new order or `GET /orders` could retrieve the dataset of one or more orders.\n\nFor this implementation we will only define 2 endpoints; one for retrieving a list of all timesheets for an employee, and another which will allow an employee to create a new timesheet entry.\n\nAn `HTTP GET` request to the `/timesheets` endpoint will allow a user to retrieve their timesheets, and an `HTTP POST` request to the `/timesheets` endpoint will allow a user to add a new timesheet.\n\n**See the implementation in** [**Node.js**](https://auth0.com/docs/architecture-scenarios/application/spa-api/api-implementation-nodejs#1-define-the-api-endpoints).\n\n### Secure the Endpoints\n\nWhen an API receives a request with a bearer Access Token as part of the header, the first thing to do is to validate the token. This consists of a series of steps, and if any of these fails then the request must be rejected with a `Missing or invalid token` error message to the calling app.\n\nThe validations that the API should perform are:\n\n*   Check that the JWT is well formed\n    \n*   Check the signature\n    \n*   Validate the standard claims\n    \n\nPart of the validation process is to also check the Application permissions (scopes), but we will address this separately in the next paragraph of this document.\n\nFor more information on validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n\n**See the implementation in** [**Node.js**](https://auth0.com/docs/architecture-scenarios/application/spa-api/api-implementation-nodejs#2-secure-the-api-endpoints).\n\n### Check the Application's Permissions\n\nBy now we have verified that the JWT is valid. The last step is to verify that the application has the permissions required to access the protected resources.\n\nTo do so, the API needs to check the [scopes](https://auth0.com/docs/scopes) of the decoded JWT. This claim is part of the payload and it is a space-separated list of strings.\n\n**See the implementation in** [**Node.js**](https://auth0.com/docs/architecture-scenarios/application/spa-api/api-implementation-nodejs#3-check-the-client-permissions).\n\n### Determine user identity\n\nFor both endpoints (retrieving the list of timesheets, and adding a new timesheet) we will need to determine the identity of the user.\n\nFor retrieving the list of timesheets this is to ensure that we only return the timesheets belonging to the user making the request, and for adding a new timesheet this is to ensure that the timesheet is associated with the user making the request.\n\nOne of the standard JWT claims is the `sub` claim which identifies the principal that is the subject to the claim. In the case of the Implicit Grant flow this claim will contain the user's identity, which will be the unique identifier for the Auth0 user. You can use this to associate any information in external systems with a particular user.\n\nYou can also use a custom claim to add another attribute of the user - such as their email address - to the Access Token and use that to uniquely identify the user.\n\n**See the implementation in** [**Node.js**](https://auth0.com/docs/architecture-scenarios/application/spa-api/api-implementation-nodejs#4-determine-the-user-identity).\n\n## Implement the SPA\n\nIn this section we will see how we can implement a SPA for our scenario.\n\nTo authorize the user we will be using the [auth0.js library](https://auth0.com/docs/libraries/auth0js). You can initialize a new instance of the Auth0 application as follows:\n\n```\nvar auth0 = new auth0.WebAuth({\n  clientID: '{yourClientId}',\n  domain: '{yourDomain}',\n  responseType: 'token id_token',\n  audience: 'YOUR_API_IDENTIFIER',\n  redirectUri: '{https://yourApp/callback}',\n  scope: 'openid profile read:timesheets create:timesheets'\n});\n```\n\nYou need to pass the following configuration values:\n\n*   **clientID**: The value of your Auth0 Client Id. You can retrieve it from the Settings of your Application at the [Dashboard](https://manage.auth0.com/#/applications%7D).\n    \n*   **domain**: The value of your Auth0 Domain. You can retrieve it from the Settings of your Application at the [Dashboard](https://manage.auth0.com/#/applications%7D).\n    \n*   **responseType**: Indicates the Authentication Flow to use. For a SPA which uses the **Implicit Flow**, this should be set to `token id_token`. The `token` part, triggers the flow to return an Access Token in the URL fragment, while the `id_token` part, triggers the flow to return an ID Token as well.\n    \n*   **audience**: The value of your API Identifier. You can retrieve it from the [Settings of your API](https://manage.auth0.com/#/apis%7D) at the Dashboard.\n    \n*   **redirectUri**: The URL to which Auth0 should redirect to after the user has authenticated.\n    \n*   **scope**: The [scopes](https://auth0.com/docs/scopes) which determine the information to be returned in the ID Token and Access Token. A scope of `openid profile` will return all the user profile information in the ID Token. You also need to request the scopes required to call the API, in this case the `read:timesheets create:timesheets` scopes. This will ensure that the Access Token has these scopes.\n    \n\nTo initiate the authentication flow you can call the `authorize()` method:\n\nAfter the authentication, Auth0 will redirect back to the **redirectUri** you specified when configuring the new instance of the Auth0 application. At this point you will need to call the `parseHash()` method which parses a URL hash fragment to extract the result of an Auth0 authentication response.\n\nThe contents of the authResult object returned by parseHash depend upon which authentication parameters were used. It may include the following:\n\n*   **idToken**: An ID Token JWT containing user profile information\n    \n*   **accessToken**: An Access Token for the API, specified by the **audience**.\n    \n*   **expiresIn**: A string containing the expiration time (in seconds) of the Access Token.\n    \n\nDetermine where best to [store the tokens](https://auth0.com/docs/tokens/concepts/token-storage). If your single-page app has a backend server at all, then tokens should be handled server-side using the [Authorization Code Flow](https://auth0.com/docs/flows/concepts/auth-code) or [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce).\n\nIf you have a single-page app (SPA) with no corresponding backend server, your SPA should request new tokens on login and store them in memory without any persistence. To make API calls, your SPA would then use the in-memory copy of the token.\n\nFor an example of how to handle sessions in SPAs, check out the [Handle Authentication Tokens](https://auth0.com/docs/quickstart/spa/vanillajs#handle-authentication-tokens) section of the [JavaScript Single-Page App Quickstart](https://auth0.com/docs/quickstart/spa/vanillajs).\n\n**See the implementation in** [**Angular 2**](https://auth0.com/docs/architecture-scenarios/application/spa-api/spa-implementation-angular2#2-authorize-the-user).\n\n### Get the User Profile\n\n#### Extract info from the token\n\nThis section shows how to retrieve the user info using the Access Token and the [/userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info). To avoid this API call, you can just decode the ID Token [using a library](https://jwt.io/#libraries-io) (make sure you validate it first). If you need additional user information consider using [our Management API](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) from your backend.\n\nThe `client.userInfo` method can be called passing the returned `authResult.accessToken` in order to retrieve the user's profile information. It will make a request to the [/userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info) and return the `user` object, which contains the user's information, similar to the example below:\n\n```\n{\n    \"email_verified\": \"false\",\n    \"email\": \"test@example.com\",\n    \"clientID\": \"AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH\",\n    \"updated_at\": \"2017-02-07T20:50:33.563Z\",\n    \"name\": \"tester9@example.com\",\n    \"picture\": \"https://gravatar.com/avatar/example.png\",\n    \"user_id\": \"auth0|123456789012345678901234\",\n    \"nickname\": \"tester9\",\n    \"created_at\": \"2017-01-20T20:06:05.008Z\",\n    \"sub\": \"auth0|123456789012345678901234\"\n}\n```\n\nYou can access any of these properties in the callback function passed when calling the `userInfo` function:\n\n```\nconst accessToken = authResult.accessToken;\n\nauth0.client.userInfo(accessToken, (err, profile) => {\n  if (profile) {\n    // Get the user’s nickname and profile image\n    var nickname = profile.nickname;\n    var picture = profile.picture;\n  }\n});\n```\n\n**See the implementation in** [**Angular 2**](https://auth0.com/docs/architecture-scenarios/application/spa-api/spa-implementation-angular2#3-get-the-user-profile).\n\n### Display UI Elements Conditionally Based on Scope\n\nBased on the `scope` of the user, you may want to show or hide certain UI elements. To determine the scope issued to a user, you will need to store the scope which was initially requested during the authorization process. When a user is authorized, the `scope` will also be returned in the `authResult`.\n\nIf the `scope` in the `authResult` is empty, then all the scopes which was requested was granted. If the `scope` in the `authResult` is not empty, it means a different set of scopes were granted, and you should use the ones in `authResult.scope`.\n\n**See the implementation in** [**Angular 2**](https://auth0.com/docs/architecture-scenarios/application/spa-api/spa-implementation-angular2#4-display-ui-elements-conditionally-based-on-scope).\n\n### Call the API\n\nTo access secured resources from your API, the authenticated user's Access Token needs to be included in requests that are sent to it. This is accomplished by sending the Access Token in an `Authorization` header using the `Bearer` scheme.\n\n**See the implementation in** [**Angular 2**](https://auth0.com/docs/architecture-scenarios/application/spa-api/spa-implementation-angular2#5-call-the-api).\n\n### Renew the Access Token\n\nAs a security measure, it is recommended that the lifetime of a user's Access Token be kept short. When you create an API in the Auth0 dashboard, the default lifetime is `7200` seconds (2 hours), but this can be controlled on a per-API basis.\n\nOnce expired, an Access Token can no longer be used to access an API. In order to obtain access again, a new Access Token needs to be obtained.\n\nObtaining a new Access Token can be done by repeating the authentication flow, used to obtain the initial Access Token. In a SPA this is not ideal, as you may not want to redirect the user away from their current task to complete the authentication flow again.\n\nIn cases like this you can make use of [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication). Silent authentication lets you perform an authentication flow where Auth0 will only reply with redirects, and never with a login page. This does however require that the user was already logged in via [Single Sign-on (SSO)](https://auth0.com/docs/sso).\n\n**See the implementation in** [**Angular 2**](https://auth0.com/docs/architecture-scenarios/application/spa-api/spa-implementation-angular2#6-renew-the-access-token).",
  "title": "API and SPA Configuration (SPAs + API)",
  "description": "API and SPA Configuration for the SPA + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-4",
  "markdown": "# Conclusion (SPAs + API)\n\nIn this document we covered a simple scenario involving an API used by a Single-Page Application (SPA) to allow employees to capture their timesheets.\n\nWe learned about the Implicit Grant, what an Access Token is, how to configure an API in Auth0, how to configure a SPA application to communicate securely with this API, how to define and secure our API endpoints, how to use the provided libraries to validate the Access Token and how to retrieve a new one from Auth0.\n\nWe started by describing the business case and the requirements and went on explaining how each requirement can be met and the thought process behind each choice that was made.\n\nWe used Node.js for the API implementation and Angular for the SPA. Hopefully though after going through this document you are able to build this using the technologies you prefer.",
  "title": "Conclusion (SPAs + API)",
  "description": "Conclusion for the SPA + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/spa-api/api-implementation-nodejs",
  "markdown": "# Node.js API Implementation (SPAs + API)\n\nThis document is part of the SPA + API Architecture Scenario and it explains how to implement the API in Node.js. Please refer to the scenario for information on the implemented solution.\n\nThe full source code for the Node.js API implementation can be found in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets/tree/master/timesheets-api/node).\n\n## 1\\. Define the API endpoints\n\nWe will use the [Express web application framework](http://expressjs.com/) to build our Node.js API.\n\n### Create a package.json File\n\nCreate a folder for your API, navigate into it and run `npm init`. This will setup your `package.json` file.\n\nYou can leave the default settings or change them as you see fit.\n\nOur sample's `package.json` looks like the following:\n\n```\n{\n  \"name\": \"timesheets-api\",\n  \"version\": \"1.0.0\",\n  \"description\": \"API used to add timesheet entries for employees and contractors\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/auth0-samples/auth0-pnp-timesheets.git\"\n  },\n  \"author\": \"Auth0\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/auth0-samples/auth0-pnp-timesheets/issues\"\n  },\n  \"homepage\": \"https://github.com/auth0-samples/auth0-pnp-timesheets#readme\"\n}\n```\n\n### Install the Dependencies\n\nNext, we need to set our dependencies. We will use the following modules:\n\n*   **express**: This module adds the [Express web application framework](https://expressjs.com/).\n    \n*   **cors**: This module adds support for enabling [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) which is required since the API will be called from a Single-Page Application running on a different domain inside a web browser.\n    \n*   **jwks-rsa**: This library retrieves RSA signing keys from a JWKS (JSON Web Key Set) endpoint. Using `expressJwtSecret` we can generate a secret provider that will provide the right signing key to `express-jwt` based on the `kid` in the JWT header. For more information refer to the [node-jwks-rsa GitHub repository](https://github.com/auth0/node-jwks-rsa).\n    \n*   **express-jwt**: This module lets you authenticate HTTP requests using JWT tokens in your Node.js applications. It provides several functions that make working with JWTs easier. For more information refer to the [express-jwt GitHub repository](https://github.com/auth0/express-jwt).\n    \n*   **body-parser**: This is a Node.js body parsing middleware. It extracts the entire body portion of an incoming request stream and exposes it on `req.body` as something easier to interface with.For more information and several alternatives refer to the body-parser GitHub repository.\n    \n\nTo install these dependencies run the following:\n\n```\nnpm install express cors express-jwt jwks-rsa body-parser express-jwt-authz --save\n```\n\n### Implement the Endpoints\n\nNavigate to your API directory and create a `server.js` file. Your code needs to:\n\n*   Get the dependencies.\n    \n*   Implement the endpoint(s).\n    \n*   Launch the API server.\n    \n\nThis is our sample implementation:\n\n```\nconst express = require('express');\nconst app = express();\nconst { expressjwt: jwt } = require('express-jwt');\nconst jwksRsa = require('jwks-rsa');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\n\n// Enable CORS\napp.use(cors());\n\n// Enable the use of request body parsing middleware\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({\n  extended: true\n}));\n\n// Create timesheets API endpoint\napp.post('/timesheets', function(req, res){\n  res.status(201).send({message: \"This is the POST /timesheets endpoint\"});\n})\n\n// Launch the API Server at localhost:8080\napp.listen(8080);\n```\n\nLaunch your API server using `node server` and make an HTTP POST request to `localhost:8080/timesheets`. You should see a JSON response with the message `This is the POST /timesheets endpoint`.\n\nSo now we have our endpoint but anyone can call it. Continue to the next paragraph to see how we can fix this.\n\n## 2\\. Secure the API endpoints\n\nIn order to validate our token we will use the `jwt` function, provided by the [express-jwt middleware](https://github.com/auth0/express-jwt#usage), and the `jwks-rsa` to retrieve our secret. The libraries do the following:\n\n1.  `express-jwt` will decode the token and pass the request, the header and the payload to `jwksRsa.expressJwtSecret`.\n    \n2.  `jwks-rsa` will then download all signing keys from the JWKS endpoint and see if a one of the signing keys matches the `kid` in the header of the JWT. If none of the signing keys match the incoming `kid`, an error will be thrown. If we have a match, we will pass the right signing key to `express-jwt`.\n    \n3.  `express-jwt` will the continue its own logic to validate the signature of the token, the expiration, `audience` and the `issuer`.\n    \n\nThe steps we will follow in our code are:\n\n*   Create the middleware function to validate the Access Token.\n    \n*   Enable the use of the middleware in our routes.\n    \n\nYou can also write some code to actually save the timesheet to a database. This is our sample implementation (some code is omitted for brevity):\n\n```\n// set dependencies - code omitted\n\n// Enable CORS - code omitted\n\n// Create middleware for checking the JWT\nconst checkJwt = jwt({\n  // Dynamically provide a signing key based on the kid in the header and the signing keys provided by the JWKS endpoint\n  secret: jwksRsa.expressJwtSecret({\n    cache: true,\n    rateLimit: true,\n    jwksRequestsPerMinute: 5,\n    jwksUri: `https://{yourDomain}/.well-known/jwks.json`\n  }),\n\n  // Validate the audience and the issuer\n  audience: '{YOUR_API_IDENTIFIER}', //replace with your API's audience, available at Dashboard > APIs\n  issuer: 'https://{yourDomain}/',\n  algorithms: [ 'RS256' ]\n});\n\n// Enable the use of request body parsing middleware - code omitted\n\n// create timesheets API endpoint - code omitted\napp.post('/timesheets', checkJwt, function(req, res){\n  var timesheet = req.body;\n\n  // Save the timesheet to the database...\n\n  //send the response\n  res.status(201).send(timesheet);\n});\n// launch the API Server at localhost:8080 - code omitted\n```\n\nIf we launch our server now and do an HTTP POST to `localhost:8080/timesheets` we should get the error message `Missing or invalid token` (which is perfectly fine since we didn’t send an Access Token in our request).\n\nIn order to test the working scenario as well we need to:\n\n*   Get an Access Token. For details on how to do so refer to: [Get an Access Token](https://auth0.com/docs/architecture-scenarios/application/server-api#get-an-access-token).\n    \n*   Invoke the API while adding an `Authorization` header to our request with the value `Bearer ACCESS_TOKEN` (where `ACCESS_TOKEN` is the value of the token we retrieved in the first step).\n    \n\n## 3\\. Check the application permissions\n\nIn this step we will add to our implementation the ability to check if the application has permissions (or `scope`) to use our endpoint in order to create a timesheet. In particular we want to ensure that the token has the correct scope, which is `batch:upload`.\n\nIn order to do this we will make use of the `express-jwt-authz` Node.js package, so go ahead and add that to your project:\n\n```\nnpm install express-jwt-authz --save\n```\n\nNow it is as simple as adding a call to `jwtAuthz(...)` to your middleware to ensure that the JWT contain a particular scope in order to execute a particular endpoint.\n\nWe will add an additional dependency. The **express-jwt-authz** library, which is used in conjunction with express-jwt, validates the [JWT](https://auth0.com/docs/tokens/concepts/jwts) and ensures it bears the correct permissions to call the desired endpoint. For more information refer to the [express-jwt-authz GitHub repository](https://github.com/auth0/express-jwt-authz).\n\nThis is our sample implementation (some code is omitted for brevity):\n\n```\n// set dependencies - some code omitted\nconst jwtAuthz = require('express-jwt-authz');\n\n// Enable CORS - code omitted\n\n// Create middleware for checking the JWT - code omitted\n\n// Enable the use of request body parsing middleware - code omitted\n\n// create timesheets API endpoint\napp.post('/timesheets', checkJwt, jwtAuthz(['create:timesheets'], { customUserKey: 'auth' }), function(req, res){\n  var timesheet = req.body;\n\n  // Save the timesheet to the database...\n\n  //send the response\n  res.status(201).send(timesheet);\n})\n\n// launch the API Server at localhost:8080 - code omitted\n```\n\nIf we invoke our API with a token that does not include this scope we should get the error message Forbidden with the HTTP status code `403`. You can test this by removing this scope from your API.\n\n## 4\\. Determine the User Identity\n\nThe `express-jwt` middleware which is used to validate the JWT, also sets the `req.auth` with the information contained in the JWT. If you want to use the `sub` claim to identify the user uniquely, you can simply use `req.auth.sub`.\n\nIn the case of the timesheets application however, we want to use the email address of the user as the unique identifier.\n\nThe first thing we need to do is to write a rule which will add the email address of the user to the Access Token. Go to the [Rules section](https://manage.auth0.com/#/rules%7D) of the Dashboard and click on the **Create Rule** button.\n\nYou can give the rule a descriptive name, for example `Add email to Access Token`, and then use the following code for the rule:\n\n```\nfunction (user, context, callback) {\n  const namespace = 'https://api.exampleco.com/';\n  context.accessToken[namespace + 'email'] = user.email;\n  callback(null, user, context);\n}\n```\n\nThe `namespace` is used to ensure the claim has a unique name and does not clash with the names of any of the standard OIDC claims. However, Auth0 supports namespaced and non-namespaced custom claims. For more info on custom claims, see [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\nNext, inside your API, you can retrieve the value of the claim from `req.auth`, and use that as the unique user identity which you can associate with timesheet entries.\n\n```\napp.get('/timesheets', checkJwt, jwtAuthz(['read:timesheets'], { customUserKey: 'auth' }), function(req, res) {\n  var timesheet = req.body;\n\n  // Associate the timesheet entry with the current user\n  var userId = req.auth['https://api.exampleco.com/email'];\n  timesheet.user_id = userId;\n\n  // Save the timesheet to the database...\n\n  //send the response\n  res.status(201).send(timesheet);\n});\n```",
  "title": "Node.js API Implementation  (SPAs + API)",
  "description": "The Node.js implementation of the API for the SPA + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/spa-api/spa-implementation-angular2",
  "markdown": "# SPA Angular 2 Implementation (SPAs + API)\n\nThis document is part of the SPA + API Architecture Scenario and it explains how to implement the SPA in Angular 2. Please refer to the scenario for information on the implemented solution.\n\nThe full source code for the Angular 2 implementation of the SPA can be found in [this GitHub repository](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets/tree/master/timesheets-spa/angular).\n\n## 1\\. Configuration\n\nYour application will require certain configuration information. Before carrying on with the rest of the implementation, create an `AuthConfig` interface which will contain various configuration values. Place this interface in a file called `auth0-variables.ts`.\n\n```\ninterface AuthConfig {\n  clientID: string;\n  domain: string;\n  callbackURL: string;\n  apiUrl: string;\n}\n\nexport const AUTH_CONFIG: AuthConfig = {\n  clientID: '',\n  domain: '',\n  callbackURL: 'http://localhost:4200/callback',\n  apiUrl: ''\n};\n```\n\n### Create an Authorization Service\n\nThe best way to manage and coordinate the tasks necessary for user authentication is to create a reusable service. With the service in place, you'll be able to call its methods throughout your application. An instance of the `WebAuth` object from [auth0.js](https://auth0.com/docs/libraries/auth0js) can be created in the service.\n\n```\nimport { Injectable } from '@angular/core';\nimport { AUTH_CONFIG } from './auth0-variables';\nimport { Router } from '@angular/router';\nimport 'rxjs/add/operator/filter';\nimport auth0 from 'auth0-js';\n\n@Injectable()\nexport class AuthService {\n\n  userProfile: any;\n  requestedScopes: string = 'openid profile read:timesheets create:timesheets';\n\n  auth0 = new auth0.WebAuth({\n    clientID: AUTH_CONFIG.clientID,\n    domain: AUTH_CONFIG.domain,\n    responseType: 'token id_token',\n    audience: AUTH_CONFIG.apiUrl,\n    redirectUri: AUTH_CONFIG.callbackURL,\n    scope: this.requestedScopes\n  });\n\n  constructor(public router: Router) {}\n\n  public login(): void {\n    this.auth0.authorize();\n  }\n\n  public handleAuthentication(): void {\n    this.auth0.parseHash((err, authResult) => {\n      if (authResult && authResult.accessToken && authResult.idToken) {\n        window.location.hash = '';\n        this.setSession(authResult);\n        this.router.navigate(['/home']);\n      } else if (err) {\n        this.router.navigate(['/home']);\n        console.log(err);\n        alert('Error: <%= \"${err.error}\" %>. Check the console for further details.');\n      }\n    });\n  }\n\n  private setSession(authResult): void {\n    // Set the time that the Access Token will expire at\n    const expiresAt = JSON.stringify((authResult.expiresIn * 1000) + new Date().getTime());\n\n    // If there is a value on the scope param from the authResult,\n    // use it to set scopes in the session for the user. Otherwise\n    // use the scopes as requested. If no scopes were requested,\n    // set it to nothing\n    const scopes = authResult.scope || this.requestedScopes || '';\n\n    localStorage.setItem('access_token', authResult.accessToken);\n    localStorage.setItem('id_token', authResult.idToken);\n    localStorage.setItem('expires_at', expiresAt);\n    localStorage.setItem('scopes', JSON.stringify(scopes));\n  }\n\n  public logout(): void {\n    // Remove tokens and expiry time from localStorage\n    localStorage.removeItem('access_token');\n    localStorage.removeItem('id_token');\n    localStorage.removeItem('expires_at');\n    localStorage.removeItem('scopes');\n    // Go back to the home route\n    this.router.navigate(['/']);\n  }\n\n  public isAuthenticated(): boolean {\n    // Check whether the current time is past the\n    // Access Token's expiry time\n    const expiresAt = JSON.parse(localStorage.getItem('expires_at'));\n    return new Date().getTime() < expiresAt;\n  }\n\n  public userHasScopes(scopes: Array<string>): boolean {\n    const grantedScopes = JSON.parse(localStorage.getItem('scopes')).split(' ');\n    return scopes.every(scope => grantedScopes.includes(scope));\n  }\n}\n```\n\nThe service includes several methods for handling authentication.\n\n*   **login**: calls `authorize` from auth0.js which initiates Universal Login\n    \n*   **handleAuthentication**: looks for an authentication result in the URL hash and processes it with the `parseHash` method from auth0.js\n    \n*   **setSession**: sets the user's Access Token, ID Token, and a time at which the Access Token will expire\n    \n*   **logout**: removes the user's tokens from browser storage isAuthenticated: checks whether the expiry time for the Access Token has passed\n    \n\n### Process the Authentication Result\n\nWhen a user authenticates via Universal Login and is then redirected back to your application, their authentication information will be contained in a URL hash fragment. The `handleAuthentication` method in the `AuthService` is responsible for processing the hash.\n\nCall `handleAuthentication` in your app's root component so that the authentication hash fragment can be processed when the app first loads after the user is redirected back to it.\n\n```\n// src/app/app.component.ts\n\nimport { Component } from '@angular/core';\nimport { AuthService } from './auth/auth.service';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\n\nexport class AppComponent {\n\n  constructor(public auth: AuthService) {\n    auth.handleAuthentication();\n  }\n}\n```\n\n### Add the Callback Component\n\nUsing Universal Login means that users are taken away from your application to a page hosted by Auth0. After they successfully authenticate, they are returned to your application where a client-side session is set for them.\n\nYou can choose to have users return to any URL in your application that you like; however, it is recommended that you create a dedicated callback route to serve as a central location that the user will be returned to upon successful authentication. Having a single callback route is beneficial for two main reasons:\n\n*   It prevents the need to allowlist multiple (and sometimes unknown) callback URLs\n    \n*   It serves as a place to show a loading indicator while your application sets the user's client-side session\n    \n\nCreate a component named `CallbackComponent` and populate it with a loading indicator.\n\n```\n<!-- app/callback/callback.html -->\n\n<div class=\"loading\">\n  <img src=\"/docs/assets/loading.svg\" alt=\"loading\">\n</div>\n```\n\nThis example assumes some kind of loading spinner is available in an `assets` directory. See the downloadable sample for a demonstration.\n\nAfter authentication, users will be taken to the `/callback` route for a brief time where they will be shown a loading indicator. During this time, their client-side session will be set, after which they will be redirected to the `/home` route.\n\n## 3\\. Get the User Profile\n\n#### Extract info from the token\n\nThis section shows how to retrieve the user info using the Access Token and the [/userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info). Alternatively, you can just decode the ID Token [using a library](https://jwt.io/#libraries-io) (make sure you validate it first). The output will be the same. If you need additional user information consider using the [our Management API](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id).\n\nTo obtain the user's profile, update the existing `AuthService` class. Add a `getProfile` function which will extract the user's Access Token from local storage, and then pass that call the `userInfo` function to retrieve the user's information.\n\n```\n// Existing code from the AuthService class is omitted in this code sample for brevity\n@Injectable()\nexport class AuthService {\n  public getProfile(cb): void {\n    const accessToken = localStorage.getItem('access_token');\n    if (!accessToken) {\n      throw new Error('Access Token must exist to fetch profile');\n    }\n\n    const self = this;\n    this.auth0.client.userInfo(accessToken, (err, profile) => {\n      if (profile) {\n        self.userProfile = profile;\n      }\n      cb(err, profile);\n    });\n  }\n}\n```\n\nYou can now simply call this function from any service where you want to retrieve and display information about the user.\n\nFor example you may choose to create a new component to display the user's profile information:\n\n```\nimport { Component, OnInit } from '@angular/core';\nimport { AuthService } from './../auth/auth.service';\n\n@Component({\n  selector: 'app-profile',\n  templateUrl: './profile.component.html',\n  styleUrls: ['./profile.component.css']\n})\nexport class ProfileComponent implements OnInit {\n\n  profile: any;\n\n  constructor(public auth: AuthService) { }\n\n  ngOnInit() {\n    if (this.auth.userProfile) {\n      this.profile = this.auth.userProfile;\n    } else {\n      this.auth.getProfile((err, profile) => {\n        this.profile = profile;\n      });\n    }\n  }\n}\n```\n\nThe template for this component looks as follows:\n\n```\n<div class=\"panel panel-default profile-area\">\n  <div class=\"panel-heading\">\n    <h3>Profile</h3>\n  </div>\n  <div class=\"panel-body\">\n    <img src=\"/docs/{{profile?.picture}}\" class=\"avatar\" alt=\"avatar\">\n    <div>\n      <label><i class=\"glyphicon glyphicon-user\"></i> Nickname</label>\n      <h3 class=\"nickname\">{{ profile?.nickname }}</h3>\n    </div>\n    <pre class=\"full-profile\">{{ profile | json }}</pre>\n  </div>\n</div>\n```\n\n## 4\\. Display UI Elements Conditionally Based on Scope\n\nDuring the authorization process we already stored the actual scopes which a user was granted in the local storage. If the `scope` returned in the `authResult` is not empty, it means that a user was issued a different set of scopes than what was initially requested, and we should therefore use `authResult.scope` to determine the scopes granted to the user.\n\nIf the `scope` returned in `authResult` is issued is empty, it means the user was granted all the scopes that were requested, and we can therefore use the requested scopes to determine the scopes granted to the user.\n\nHere is the code we wrote earlier for the `setSession` function that does that check:\n\n```\nprivate setSession(authResult): void {\n  // Set the time that the Access Token will expire at\n  const expiresAt = JSON.stringify((authResult.expiresIn * 1000) + new Date().getTime());\n\n  // If there is a value on the `scope` param from the authResult,\n  // use it to set scopes in the session for the user. Otherwise\n  // use the scopes as requested. If no scopes were requested,\n  // set it to nothing\n  const scopes = authResult.scope || this.requestedScopes || '';\n\n  localStorage.setItem('access_token', authResult.accessToken);\n  localStorage.setItem('id_token', authResult.idToken);\n  localStorage.setItem('expires_at', expiresAt);\n  localStorage.setItem('scopes', JSON.stringify(scopes));\n  this.scheduleRenewal();\n}\n```\n\nNext we need to add a function to the `AuthService` class which we can call to determine if a user was granted a specific scope:\n\n```\n@Injectable()\nexport class AuthService {\n  // some code omitted for brevity\n\n  public userHasScopes(scopes: Array<string>): boolean {\n    const grantedScopes = JSON.parse(localStorage.getItem('scopes')).split(' ');\n    return scopes.every(scope => grantedScopes.includes(scope));\n  }\n}\n```\n\nYou can call this method to determine whether we should display a specific UI element, or not. As an example we only want to display the **Approve Timesheets** link if the user has the `approve:timesheets` scope. Note in the code below that we added a call to the `userHasScopes` function to determine whether that link should be displayed or not.\n\n```\n<nav class=\"navbar navbar-default\">\n  <div class=\"container-fluid\">\n    <div class=\"navbar-header\">\n      <a class=\"navbar-brand\" href=\"#\">Timesheet System</a>\n    </div>\n    <div class=\"navbar-collapse collapse\">\n      <ul class=\"nav navbar-nav\">\n        <li><a routerLink=\"/\">Home</a></li>\n        <li><a *ngIf=\"auth.isAuthenticated()\" routerLink=\"/profile\">My Profile</a></li>\n        <li><a *ngIf=\"auth.isAuthenticated()\" routerLink=\"/timesheets\">My Timesheets</a></li>\n        <li><a *ngIf=\"auth.isAuthenticated() && auth.userHasScopes(['approve:timesheets'])\" routerLink=\"/approval\">Approve Timesheets</a></li>\n      </ul>\n      <ul class=\"nav navbar-nav navbar-right\">\n        <li><a *ngIf=\"!auth.isAuthenticated()\" href=\"/docs/javascript:void(0)\" (click)=\"auth.login()\">Log In</a></li>\n        <li><a *ngIf=\"auth.isAuthenticated()\" href=\"/docs/javascript:void(0)\" (click)=\"auth.logout()\">Log Out</a></li>\n      </ul>\n    </div>\n  </div>\n</nav>\n\n<main class=\"container\">\n  <router-outlet></router-outlet>\n</main>\n```\n\n### Protect a route\n\nWe should also protect a route to not allow a route to be navigated to if a user has not been granted the correct scopes. For this we can add a new `ScopeGuardService` service class:\n\n```\nimport { Injectable } from '@angular/core';\nimport { Router, CanActivate, ActivatedRouteSnapshot } from '@angular/router';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class ScopeGuardService implements CanActivate {\n\n  constructor(public auth: AuthService, public router: Router) {}\n\n  canActivate(route: ActivatedRouteSnapshot): boolean {\n\n    const scopes = (route.data as any).expectedScopes;\n\n    if (!this.auth.isAuthenticated() || !this.auth.userHasScopes(scopes)) {\n      this.router.navigate(['']);\n      return false;\n    }\n    return true;\n  }\n\n}\n```\n\nAnd then use that when we configure the routes to determine whether a route can be activated. Notice the use of the new `ScopeGuardService` in the definition for the `approval` route below:\n\n```\n// app.routes.ts\n\nimport { Routes, CanActivate } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { ProfileComponent } from './profile/profile.component';\nimport { CallbackComponent } from './callback/callback.component';\nimport { AuthGuardService as AuthGuard } from './auth/auth-guard.service';\nimport { ScopeGuardService as ScopeGuard } from './auth/scope-guard.service';\nimport { TimesheetListComponent } from './timesheet-list/timesheet-list.component';\nimport { TimesheetAddComponent } from './timesheet-add/timesheet-add.component';\nimport { ApprovalComponent } from './approval/approval.component';\n\nexport const ROUTES: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'profile', component: ProfileComponent, canActivate: [AuthGuard] },\n  { path: 'callback', component: CallbackComponent },\n  { path: 'timesheets/add', component: TimesheetAddComponent, canActivate: [AuthGuard] },\n  { path: 'timesheets', component: TimesheetListComponent, canActivate: [AuthGuard] },\n  { path: 'approval', component: ApprovalComponent, canActivate: [ScopeGuard], data: { expectedScopes: ['approve:timesheets']} },\n  { path: '**', redirectTo: '' }\n];\n```\n\n## 5\\. Call the API\n\nThe [angular2-jwt](https://github.com/auth0/angular2-jwt) module can be used to automatically attach JSON Web Tokens to requests made to your API. It does this by providing an `AuthHttp` class which is a wrapper over Angular's `Http` class.\n\nInstall `angular2-jwt`:\n\n```\n# installation with npm\nnpm install --save angular2-jwt\n\n# installation with yarn\nyarn add angular2-jwt\n```\n\nCreate a factory function with some configuration values for `angular2-jwt` and add it to the `providers` array in your application's `@NgModule`. The factory function should have a `tokenGetter` function which fetches the `access_token` from local storage.\n\n```\nimport { Http, RequestOptions } from '@angular/http';\nimport { AuthHttp, AuthConfig } from 'angular2-jwt';\n\nexport function authHttpServiceFactory(http: Http, options: RequestOptions) {\n  return new AuthHttp(new AuthConfig({\n    tokenGetter: (() => localStorage.getItem('access_token'))\n  }), http, options);\n}\n\n@NgModule({\n  declarations: [...],\n  imports: [...],\n  providers: [\n    AuthService,\n    {\n      provide: AuthHttp,\n      useFactory: authHttpServiceFactory,\n      deps: [Http, RequestOptions]\n    }\n  ],\n  bootstrap: [...]\n})\n```\n\nAfter `angular2-jwt` is configured, you can use the `AuthHttp` class to make secure calls to your API from anywhere in the application. To do so, inject `AuthHttp` in any component or service where it is needed and use it just as you would use Angular's regular `Http` class.\n\n```\nimport { Injectable } from '@angular/core';\nimport { Http } from '@angular/http';\nimport { AuthHttp } from 'angular2-jwt';\nimport 'rxjs/add/operator/map';\nimport { NewTimesheetModel } from '../models/new-timesheet-model';\n\n@Injectable()\nexport class TimesheetsService {\n\n  constructor(public authHttp: AuthHttp) { }\n\n  addTimesheet(model: NewTimesheetModel) {\n    return this.authHttp.post('http://localhost:8080/timesheets', JSON.stringify(model));\n  }\n\n  getAllTimesheets() {\n    return this.authHttp.get('http://localhost:8080/timesheets')\n      .map(res => res.json())\n  }\n}\n```\n\n## 6\\. Renew the Access Token\n\nRenewing the user's Access Token requires to update the Angular SPA. Add a method to the `AuthService` which calls the `checkSession` method from auth0.js. If the renewal is successful, use the existing `setSession` method to set the new tokens in local storage.\n\n```\npublic renewToken() {\n  this.auth0.checkSession({\n    audience: AUTH_CONFIG.apiUrl\n  }, (err, result) => {\n    if (!err) {\n      this.setSession(result);\n    }\n  });\n}\n```\n\nIn the `AuthService` class, add a method called `scheduleRenewal` to set up a time at which authentication should be silently renewed. In the sample below this is set up to happen 30 seconds before the actual token expires. Also add a method called `unscheduleRenewal` which will unsubscribe from the Observable.\n\n```\npublic scheduleRenewal() {\n  if (!this.isAuthenticated()) return;\n\n  const expiresAt = JSON.parse(window.localStorage.getItem('expires_at'));\n\n  const source = Observable.of(expiresAt).flatMap(\n    expiresAt => {\n\n      const now = Date.now();\n\n      // Use the delay in a timer to\n      // run the refresh at the proper time\n      var refreshAt = expiresAt - (1000 * 30); // Refresh 30 seconds before expiry\n      return Observable.timer(Math.max(1, refreshAt - now));\n    });\n\n  // Once the delay time from above is\n  // reached, get a new JWT and schedule\n  // additional refreshes\n  this.refreshSubscription = source.subscribe(() => {\n    this.renewToken();\n  });\n}\n\npublic unscheduleRenewal() {\n  if (!this.refreshSubscription) return;\n  this.refreshSubscription.unsubscribe();\n}\n```\n\nFinally you need to initiate the schedule renewal. This can be done by calling `scheduleRenewal` inside your `AppComponent` which will happen when the page is loaded. This will occur after every authentication flow, either when the user explicitly logs in, or when the silent authentication happens.\n\n### Refresh Token Rotation\n\nRecent advancements in user privacy controls in browsers adversely impact the user experience by preventing access to third-party cookies. Auth0 recommends using [Refresh Token Rotation](https://auth0.com/docs/tokens/concepts/refresh-token-rotation), which provides a secure method for using refresh tokens in SPAs while providing end-users with seamless access to resources without the disruption in UX caused by browser privacy technology like ITP.",
  "title": "SPA Angular 2 Implementation (SPAs + API)",
  "description": "The Angular 2 implementation of the SPA for the SPA + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-android/auth0-android-configuration",
  "markdown": "# Auth0.Android Configuration Options\n\nAuth0.Android can be configured with a variety of options, listed below.\n\n## withConnection\n\nThe `withConnection` option lets you specify a connection that you want to authenticate with.\n\n```\nWebAuthProvider.login(account)\n                .withConnection(\"twitter\")\n                .start(this, callback)\n```\n\n## withScope\n\nUsing scopes can lets you return specific claims for specific fields in your request. Adding parameters to `withScope` lets you add more scopes. See [Scopes](https://auth0.com/docs/get-started/apis/scopes) for details.\n\n```\nWebAuthProvider.login(account)\n                .withScope(\"openid profile email\")\n                .start(this, callback)\n```\n\nThe default scope is `openid profile email`.\n\n## withConnectionScope\n\nThere may be times when you need to authenticate with particular connection scopes, or permissions, from the authentication provider in question. See [Adding Scopes for an External IDP](https://auth0.com/docs/connections/adding-scopes-for-an-external-idp). However, if you need specific access for a particular situation in your app, you can do pass parameters to `withConnectionScope`. You can find a full list of the available parameters in that connection's settings on the [Dashboard](https://manage.auth0.com/#), or from the authentication providers's documentation. The scope requested here is added on top of the ones specified in the connection's settings in the Dashboard.\n\n```\nWebAuthProvider.login(account)\n                .withConnectionScope(\"email\", \"profile\", \"calendar:read\")\n                .start(this, callback)\n```\n\n## withParameters\n\nTo send additional parameters on the authentication, use `withParameters.`\n\n```\nval parameters = mapOf(\"param1\" to \"value1\")\n\nWebAuthProvider.login(account)\n                .withParameters(parameters)\n                .start(this, callback)\n```\n\nTo send custom headers to the authorization endpoint, use `withHeaders.`\n\n```\nval headers = mapOf(\"header1\" to \"value1\")\n\nWebAuthProvider.login(account)\n                .withHeaders(headers)\n                .start(this, callback)\n```\n\n## withScheme\n\nIf you are not using Android \"App Links\" or you want to use a different scheme for the redirect URI, use `withScheme`. Update the `auth0Scheme` Manifest Placeholder in the `app/build.gradle` file and the AllowList **Allowed Callback URLs** on the [Dashboard](https://manage.auth0.com/#) in the Application's settings to match the chosen scheme.\n\n```\nWebAuthProvider.login(account)\n                .withScheme(\"myapp\")\n                .start(this, callback)\n```\n\n## withAudience\n\nTo provide an audience, use `withAudience`.\n\n```\nWebAuthProvider.login(account)\n                .withAudience(\"https://YOUR_DOMAIN/userinfo\")\n                .start(this, callback)\n```",
  "title": "Auth0.Android Configuration Options",
  "description": "How to configure Auth0.Android to meet your application's needs",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-android/auth0-android-database-authentication",
  "markdown": "# Auth0.Android Database Authentication\n\n## Log in with a database connection\n\nTo log in with a database connection, call `login` with the user's **email**, **password**, and the **connection** you want to authenticate with. The response is a `Credentials` object.\n\n```\nauthentication\n    .login(\"username@domain.com\", \"a secret password\", \"my-database-connection\")\n    .start(object: Callback<Credentials, AuthenticationException> {\n        override fun onSuccess(payload: Credentials) {\n            // Logged in!\n        }\n\n        override fun onFailure(error: AuthenticationException) {\n            // Error!\n        }\n    })\n```\n\nThe default scope is `openid profile email`.\n\n## Sign up with a database connection\n\nTo sign up with a database connection, call the `signUp` method, passing the user's email, password, and connection name.\n\n```\nauthentication\n    .signUp(\"username@domain.com\", \"a secret password\", \"my-database-connection\")\n    .start(object: Callback<Credentials, AuthenticationException> {\n        override fun onSuccess(result: Credentials) {\n            // Signed Up & Logged in!\n        }\n\n        override fun onFailure(error: AuthenticationException) {\n            // Error!\n        }\n    });\n```",
  "title": "Auth0.Android Database Authentication",
  "description": "How to use Auth0.Android with database connections",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-android/auth0-android-passwordless",
  "markdown": "# Auth0.Android Passwordless Authentication\n\nPasswordless can occur over email or SMS, either by sending the user a code or sending a link that contains a code. All methods of Passwordless authentication require two steps: requesting the code and inputting the code for verification.\n\n## Set up the Android SDK\n\nFirst, [set up the Android SDK](https://auth0.com/docs/libraries/auth0-android) so that you can use the Passwordless methods below.\n\n## Configure Auth0 and the Android SDK\n\nTo use the Passwordless API from a Native client, enable the Passwordless OTP grant for your application in **Dashboard > Applications > (YOUR APPLICATION) > Settings > Advanced Settings > Grant Types**.\n\n## Request the code\n\nThis example requests the code by calling `passwordlessWithEmail` with the user's email, `PasswordlessType.CODE`, and the name of the connection as parameters. On success, you may want to notify the user that their code is on the way, and perhaps route them to where they will input that code.\n\n```\nauthentication\n    .passwordlessWithEmail(\"username@domain.com\", PasswordlessType.CODE, \"my-passwordless-connection\")\n    .start(object: Callback<Void?, AuthenticationException>() {\n        override fun onSuccess(result: Void?) {\n            // Code sent!\n        }\n\n        override fun onFailure(error: AuthenticationException) {\n            // Error!\n        }\n    })\n```\n\nYou can use the `passwordlessWithSms` method to send the code using SMS.\n\n## Input the code\n\nOnce the user has a code, they can input it. Call the `loginWithEmail` method and pass in the user's email, the code they received, and the name of the connection in question. Upon success, you receive a `Credentials` object in the response.\n\n```\nauthentication\n    .loginWithEmail(\"username@domain.com\", \"123456\", \"my-passwordless-connection\")\n    .start(object: Callback<Credentials, AuthenticationException>() {\n        override fun onSuccess(result: Credentials) {\n            // Logged in!\n        }\n\n        override fun onFailure(error: AuthenticationException) {\n            // Error!\n        }\n    })\n```\n\nYou can use the `loginWithSms` method to send the code received by SMS and authenticate the user.\n\nThe default scope used is `openid profile email`.",
  "title": "Auth0.Android Passwordless Authentication",
  "description": "How to use Auth0.Android with passwordless connections",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-android/auth0-android-save-and-renew-tokens",
  "markdown": "# Auth0.Android Save and Renew Tokens\n\nWhen an authentication is performed with the `offline_access` scope included, it returns a refresh token that can be used to request a new user token, without forcing the user to perform authentication again.\n\n## Credentials Manager\n\n[Auth0.Android](https://github.com/auth0/Auth0.Android) provides a utility class to streamline the process of storing and renewing credentials. You can access the `accessToken` or `idToken` properties from the [Credentials](https://github.com/auth0/Auth0.Android/blob/master/auth0/src/main/java/com/auth0/android/result/Credentials.java) instance. This is the preferred method to manage user credentials.\n\nCredential Managers are included as part of the Auth0.Android SDK. If this is not yet part of your dependencies, follow the instructions in [Auth0.Android](https://auth0.com/docs/libraries/auth0-android).\n\nThere are two classes you can use to manage credentials:\n\n*   `CredentialsManager` stores data in plain text.\n    \n*   `SecureCredentialsManager` encrypts the data before storing it, using a combination of RSA and AES algorithms along with [Android KeyStore](https://developer.android.com/reference/java/security/KeyStore.html).\n    \n\n## Using the CredentialsManager class\n\n### Set up the CredentialsManager\n\nCreate a new instance by passing an `AuthenticationAPIClient` and a `Storage` implementation.\n\n```\nval auth0 = Auth0(this)\nval apiClient = AuthenticationAPIClient(auth0)\nval manager = CredentialsManager(apiClient, SharedPreferencesStorage(this))\n```\n\n### Current state of the authentication\n\nStored credentials are considered valid if they have not expired or can be refreshed. Check if a user has already logged in.\n\n```\nval loggedIn = manager.hasValidCredentials()\n```\n\nTo log the user out of your application, remove the stored credentials and direct them to the login screen.\n\n```\nmanager.clearCredentials()\n```\n\n### Retrieving credentials\n\nBecause the credentials may need to be refreshed against Auth0 Servers, this method is asynchronous. Pass a callback implementation where you want to receive the credentials. Credentials returned by this method upon success are always valid.\n\n```\nmanager.getCredentials(object: Callback<Credentials, CredentialsManagerException>() {\n    override fun onSuccess(credentials: Credentials) {\n        // Use credentials\n    }\n\n    override fun onFailure(error: CredentialsManagerException) {\n        // No credentials were previously saved or they couldn't be refreshed\n    }\n})\n```\n\nIf the `accessToken` has expired, the manager automatically uses the `refreshToken` and renews the credentials for you. New credentials will be stored for future access.\n\n### Save new credentials\n\nYou can save the credentials obtained during authentication in the manager.\n\n```\nmanager.saveCredentials(credentials)\n```\n\n## Using the SecureCredentialsManager class\n\n### Set up the SecureCredentialsManager\n\nCreate a new instance by passing a valid android `Context`, an `AuthenticationAPIClient` and a `Storage` implementation.\n\n```\nval auth0 = Auth0(this)\nval apiClient = AuthenticationAPIClient(auth0)\nval manager = SecureCredentialsManager(this, apiClient, SharedPreferencesStorage(this))\n```\n\nThe methods to obtain, save, check for existence, and clear the credentials are the same as described in the section above.\n\n### Pre-authenticate the user\n\nThis class provides optional functionality for additional authentication using the device's configured lock screen.\n\nCall the method below to enable the authentication. Pass a valid `Activity` context, a request code, and two optional strings to use as title and description for the lock screen.\n\nAlso define a request code constant so that the request code coming from the activity result can be matched up.\n\n```\ncompanion object {\n  const val RC_UNLOCK_AUTHENTICATION = 123\n}\n\n// Called from an Activity\nval available = manager.requireAuthentication(this, RC_UNLOCK_AUTHENTICATION, getString(R.string.unlock_authentication_title), getString(R.string.unlock_authentication_description))\n```\n\nIf the feature is enabled, the manager will prompt the user to authenticate using the configured lock screen. The result of this call will be obtained in the `onActivityResult` method of the activity passed before as first parameter. If the feature was not enabled, lock screen authentication will be skipped.\n\nAfter checking that the received request code matches the one used in the configuration step, redirect the received parameters to the manager to finish the authentication. The credentials will yield to the original callback.\n\n```\noverride fun onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == RC_UNLOCK_AUTHENTICATION && manager.checkAuthenticationResult(requestCode, resultCode)) {\n        return\n    }\n\n    super.onActivityResult(requestCode, resultCode, data)\n}\n```\n\n### Handling usage exceptions\n\nIf an unexpected event occurs while trying to save or retrieve the Credentials, a `CredentialsManagerException` will be thrown. These are some of the failure scenarios you can expect:\n\n*   The Credentials to be stored are invalid (for example, some of the following fields are not defined: `access_token`, `id_token` or `expires_at`).\n    \n*   The stored Credentials have expired but there is no refresh token available to renew them automatically.\n    \n*   The device's lock screen security settings have changed (for example the security PIN code changed). Even when `hasCredentials` returns true, the encryption keys will be deemed invalid. Until `saveCredentials` is called again, it won't be possible to decrypt any previously existing content because they previously used keys are not the same as the new ones.\n    \n*   The device is not compatible with some of the cryptography algorithms required by the `SecureCredentialsManager` class. This is considered a catastrophic event and is the only exception that will prevent you from using this implementation. This scenario happens when the OEM has modified the Android ROM of the device, removing some of the algorithms officially included in every Android distribution. Nevertheless, you can check if this is the case in the exception instance itself by calling the `isDeviceIncompatible` method. By doing so you can decide the fallback implementation for storing the credentials, such as using the regular `CredentialsManager` class.",
  "title": "Auth0.Android Save and Renew Tokens",
  "description": "Keeping your user logged in with Auth0.Android",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/tenant-settings/signing-keys/view-signing-certificates",
  "markdown": "# View Signing Certificates\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/keys/signing' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/keys/signing\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/keys/signing\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/keys/signing\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/keys/signing',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/keys/signing\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/keys/signing\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/keys/signing\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/keys/signing\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/keys/signing\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "View Signing Certificates",
  "description": "Describes how to view client secrets and signing keys using the Auth0 Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-android/auth0-android-user-management",
  "markdown": "# Auth0.Android: User Management\n\nThe Management API provides functionality that you can use to manage users of your application, including these types of tasks:\n\n*   Link separate user accounts from different providers, tying them to a single profile. To learn more, read [User Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking).\n    \n*   Unlink user accounts, returning them to separate identities.\n    \n*   Update user metadata. To learn more, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata).\n    \n\n## Initialize the UsersAPIClient\n\nTo get started, create a new `UsersAPIClient` instance by passing it the `account` and the token for the primary identity. In the case of linking users, this primary identity is the user profile that you want to \"keep\" the data for, and to which you plan to link other identities.\n\n```\nval account = Auth0(\"{yourClientId}\", \"{yourDomain}\")\nval client = UsersAPIClient(account, \"token\")\n```\n\n## Link users\n\nLinking user accounts lets a user authenticate from any of their accounts. No matter which account they authenticate with, they log in with the same profile. Without account linking, Auth0 treats every different account as a separate profile.\n\nThe `link` method accepts two parameters: the primary user id and the secondary user token (the token obtained after login with this identity). The user id in question is the unique identifier for this user account. If the id is in the format `facebook|1234567890`, the id required is the portion after the delimiting pipe.\n\n```\nclient\n    .link(\"primary user id\", \"secondary user token\")\n    .start(object: Callback<List<UserIdentity>, ManagementException>() {\n        override fun onSuccess(payload: List<UserIdentity>) {\n            // Got the updated identities! Accounts linked.\n        }\n\n        override fun onFailure(error: ManagementException) {\n            // Error!\n        }\n    })\n```\n\n## Unlink users\n\nUnlinking users returns the accounts to separate profiles. The `unlink` method takes three parameters: the primary user id, the secondary user id, and the secondary provider (of the secondary user).\n\n```\nusers\n    .unlink(\"primary user id\", \"secondary user id\", \"secondary provider\")\n    .start(object: Callback<List<UserIdentity>, ManagementException>() {\n        override fun onSuccess(payload: List<UserIdentity>) {\n            // Got the updated identities! Accounts linked.\n        }\n\n        override fun onFailure(error: ManagementException) {\n            // Error!\n        }\n    })\n```\n\nWhen accounts are linked, the secondary account's metadata does not merge with the primary account's metadata. Similarly, when unlinking two accounts, the secondary account does not retain the primary account's metadata.\n\n## Updating user metadata\n\nWhen updating user metadata, you create a `metadata` object and then call the `updateMetadata` method, passing it the user id and the `metadata` object. The values in this object overwrite existing values with the same key, or add new values for those that don't yet exist in the user metadata.\n\n```\nval metadata = mutableMapOf<String, Any?>()\nmetadata.put(\"name\", listOf(\"My\", \"Name\", \"Is\"));\nmetadata.put(\"phoneNumber\", \"1234567890\");\n\nusers\n    .updateMetadata(\"user id\", metadata)\n    .start(object: Callback<UserProfile, ManagementException>() {\n        override fun onSuccess(payload: UserProfile) {\n            // Metadata updated\n        }\n\n        override fun onFailure(error: ManagementException) {\n            // Error!\n        }\n    })\n```",
  "title": "Auth0.Android: User Management",
  "description": "How to use Auth0.Android to manage users",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/data-security/denylist",
  "markdown": "# Add User Attributes to Deny List\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID' \\\n  --header 'authorization: Bearer YOUR_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\"\n\n\tpayload := strings.NewReader(\"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\")\n  .header(\"authorization\", \"Bearer YOUR_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID',\n  headers: {authorization: 'Bearer YOUR_TOKEN', 'content-type': 'application/json'},\n  data: {options: {non_persistent_attrs: ['ethnicity', 'gender']}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"non_persistent_attrs\": @[ @\"ethnicity\", @\"gender\" ] } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\"\n\nheaders = {\n    'authorization': \"Bearer YOUR_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer YOUR_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"options\": [\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Add User Attributes to Deny List",
  "description": "Describes how to identify user attributes that you do not want to save in Auth0 databases.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/guides/users/update-root-attributes-users",
  "markdown": "# Update Root Attributes for Users\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/USER_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: '{ \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/USER_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"given_name\\\": GIVEN_NAME_VALUE, \\\"family_name\\\": FAMILY_NAME_VALUE,\\\"name\\\": NAME_VALUE, \\\"nickname\\\": NICKNAME_VALUE,\\\"picture\\\": PICTURE_VALUE }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\n\nlet postData = NSData(data: \"{ \"given_name\": GIVEN_NAME_VALUE, \"family_name\": FAMILY_NAME_VALUE,\"name\": NAME_VALUE, \"nickname\": NICKNAME_VALUE,\"picture\": PICTURE_VALUE }\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Update Root Attributes for Users",
  "description": "Learn how to update root attributes in existing user profiles using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-applications/configure-an-identity-provider-in-access-gateway",
  "markdown": "# Configure an Identity Provider in Access Gateway\n\nTo integrate Auth0 with a machine-to-machine (M2M) application, you must first register your app with Auth0 using the Auth0 Dashboard.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click **Create Application**.\n    \n2.  Enter a descriptive name for your application, select **Machine to Machine Applications**, and click **Create**.\n    \n    ![Auth0 Create Application](https://images.ctfassets.net/cdy7uua7fh8z/128mqeFl3vNb1lcyU38pnc/3e9ca9cc08aae6b9ff504b537a350cfb/Screen_Shot_2021-06-03_at_4.15.16_PM.png)\n3.  Select the Management API to authorize M2M communication, as this is how OAG interacts with Auth0.\n    \n\n![Dashboard Applications Applications Create Application Machine to Machine Application Authorized API Selection](https://images.ctfassets.net/cdy7uua7fh8z/17luDFRWRVXeNiE0BTt2X2/09132c2ee66480b3b8481679db90b1b4/dashboard-applications-applications-create-m2m-authorize-api.png)\n\n4\\. Click **Authorize**.\n\n5\\. Each M2M app that accesses an API must be granted a set of permissions (or scopes) that should be granted by the authenticated user. Select the **Permissions** that you want to be issued as part of your application's access token. OAG requires the following permissions for the **client** and **users:**\n\n*   `read:client, write:client, update:client, delete:client`\n    \n*   `read:users`\n    \n\n![Dashboard Applications Applications Create Machine to Machine Application Select Permissions](https://images.ctfassets.net/cdy7uua7fh8z/26HappX2cn7qKf3WePPJFt/0c4d3fbe253f83a764fdaafc935cd680/dashboard-applications-applications-create-m2m-permissions.png)\n\n6\\. Click **Authorize**.\n\n7\\. Select the **Credentials** tab of your application.\n\n8\\. Click the **Client ID** and copy it into a text editor app.\n\n9\\. Click the **Client Secret** and copy it into a text editor app.\n\n10\\. Continue with the [Use Customer Identity Cloud as the IdP for Access Gateway](https://help.okta.com/okta_help.htm?type=oag&id=ext_oag_config_idp_okta) procedure.",
  "title": "Configure an Identity Provider in Access Gateway",
  "description": "Configure an identity provider in OAG",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-native-apps",
  "markdown": "# Add Bot Detection to Native Applications\n\nYou can add [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection) to your native applications with little to no additional configuration depending on the SDK and authentication flow you are using.\n\n## Auth0.swift and Auth0.Android\n\nIf you’re using Universal Login, Bot Detection is supported automatically by the following SDK versions:\n\n*   `Auth0.swift` version 1.28.0+\n    \n*   `Auth0.Android` version 1.25.0+\n    \n\nIf you’re not using Universal Login, Bot Detection is supported, but you need to configure your application accordingly:\n\n*   Your application must handle the `requires_verification` exception (which is thrown when a high-risk login attempt is detected) and then trigger a WebAuth flow to render a CAPTCHA verification step.\n    \n*   When you trigger the WebAuth flow, you may pass the `login_hint` parameter to prevent the user from needing to type in their username again.\n    \n\n### Auth0.swift example\n\nIf your application performs database login/signup through the [Authentication API](https://auth0.com/docs/api/authentication), you must handle the `isVerificationRequired` error. This error indicates that the request was flagged as suspicious and an additional verification step is necessary to authenticate the user.\n\n```\nAuth0\n    .authentication()\n    .login(usernameOrEmail: email, \n           password: password, \n           realmOrConnection: connection, \n           scope: scope)\n    .start { result in\n        switch result {\n        case .success(let credentials): // ...\n        case .failure(let error) where error.isVerificationRequired:\n            DispatchQueue.main.async {\n                Auth0\n                    .webAuth()\n                    .connection(connection)\n                    .scope(scope)\n                    .useEphemeralSession()\n                    // ☝🏼 Otherwise a session cookie will remain\n                    .parameters([\"login_hint\": email])\n                    // ☝🏼 So the user doesn't have to type it again\n                    .start { result in\n                        // ...\n                    }\n            }\n        case .failure(let error): // ...\n        }\n    }\n```\n\nIn the case of signup, you can add [an additional parameter](https://auth0.com/docs/authenticate/login/auth0-universal-login) to make the user land directly on the signup page:\n\n`.parameters([\"login_hint\": email, \"screen_hint\": \"signup\"])`\n\nRead [Auth0.swift Getting Started](https://github.com/auth0/Auth0.swift#getting-started) for details on how to set up Universal Login.\n\n### Auth0.Android example\n\nIf your application performs database login/signup through the Authentication API, you must handle the `AuthenticationException#isVerificationRequired()` error. This error indicates that the request was flagged as suspicious and an additional verification step is necessary to log the user in.\n\n```\nfinal String email = \"username@domain.com\";\nfinal String password = \"a secret password\";\nfinal String realm = \"my-database-connection\";\n\nAuthenticationAPIClient authentication = new AuthenticationAPIClient(account);\nauthentication.login(email, password, realm)\n        .start(new BaseCallback<Credentials, AuthenticationException>() {\n\n            @Override\n            public void onFailure(AuthenticationException error) {\n                if (error.isVerificationRequired()){\n                    Map<String, Object> params = new HashMap<>();\n                    params.put(\"login_hint\", email); // So the user doesn't have to type it again\n                    WebAuthProvider.login(account)\n                            .withConnection(realm)\n                            .withParameters(params)\n                            .start(LoginActivity.this, new AuthCallback() {\n                                // You might already have an AuthCallback instance defined\n\n                                @Override\n                                public void onFailure(@NonNull Dialog dialog) {\n                                    // Error dialog available\n                                }\n\n                                @Override\n                                public void onFailure(AuthenticationException exception) {\n                                    // Error\n                                }\n\n                                @Override\n                                public void onSuccess(@NonNull Credentials credentials) {\n                                    // Handle WebAuth success\n                                }\n                            });\n                }\n            }\n\n            @Override\n            public void onSuccess(Credentials payload) {\n                // Handle API success\n            }\n        });\n```\n\nIn the case of signup, you can add [an additional parameter](https://auth0.com/docs/authenticate/login/auth0-universal-login) to make the user land directly on the signup page:\n\n`params.put(\"screen_hint\", \"signup\");`\n\nRead [Auth0.Android Authentication with Universal Login SDK documentation](https://github.com/auth0/Auth0.Android#authentication-with-universal-login) for details on how to set up Universal Login.\n\n## Lock.Swift and Lock.Android\n\nIf you’re using Universal Login, Bot Detection is supported automatically by the following SDK versions:\n\n*   `Lock.Swift` version 2.19.0+\n    \n*   `Lock.Android` version 2.22.0+\n    \n\nIf you’re not using Universal Login, Bot Detection is supported, but you need to configure your application accordingly:\n\n*   Your application must handle the `requires_verification` exception (which is thrown when a high-risk login attempt is detected) and then trigger a WebAuth flow to render a CAPTCHA verification step.\n    \n*   When you trigger the WebAuth flow, you may pass the `login_hint` parameter to prevent the user from needing to type in their username again.\n    \n\n## Authentication API\n\nIf you’re using the Authentication API directly, Bot Detection is supported, but you need to configure your application accordingly:\n\n*   Your application must handle the `requires_verification` error (which is returned by the Authentication API when a high-risk login attempt is detected) and then trigger a WebAuth flow to render a CAPTCHA verification step.\n    \n\n## Learn more\n\n*   [Add Bot Detection to Custom Login Pages](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-custom-login-pages)",
  "title": "Add Bot Detection to Native Applications",
  "description": "Learn how to add bot protection and detection to your native application that use Auth0.Swift, Auth0.Android, Lock.Swift, and Lock.Android. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/mobile-device-login-flow-best-practices",
  "markdown": "# Mobile Device Login Flow Best Practices\n\nWhen developing a native mobile application, such as an iOS or Android application, you can choose between the following login flows: native or browser-based.\n\n![Native vs. Browser-based Login Page UX](https://images.ctfassets.net/cdy7uua7fh8z/7CRPh9xs7KloQB8gt2hSC/a69eeb843ccc2a6c5effe15be465c5d9/mobile-ux.png)\n\n*   When using a **browser-based** login flow, the user is shown a web browser and redirected to the Auth0 login page, where they can either sign up or log in. For example, an iOS application opens a SafariViewController or Android application opens a Custom Chrome Tab.\n    \n*   When using a **native** login flow, the user signs up or enters their credentials directly into the app.\n    \n\nIf your platform supports it, we recommend that you use a browser-based login flow where your application presents an in-application (embedded) browser for login and signup. Using an in-application browser gives your application the benefits of browser-based authentication, such as shared authentication state and security context, without disrupting the user experience by switching applications. Regardless of which option you choose, Auth0 supports either.\n\n## Single Sign-on across native applications\n\nIf you have several mobile applications (such as Google Drive, Google Docs/Sheets, YouTube, and so on), you might want to automatically log the user into all of them if they log into any one app.\n\nIf your applications use a wholly native experience, your users have to enter their credentials for each application. However, if you use a browser-based login flow you can implement Single Sign-on (SSO), reducing the number of times the user has to log in.\n\n## SSO across devices/desktops/laptops\n\nGoogle is currently investing in the ability to synchronize sessions across devices called Google SmartLock. This allows users to sign in using one device or desktop/laptop computer and automatically sync their session across all of their devices. To learn more, read [Sync passwords across your devices in the Google Help Center](https://get.google.com/smartlock/).\n\nWhile SmartLock is not yet universal, using browser-based login flows allows you to take advantage of this tool.\n\n## Phishing and security issues\n\nWith a native login flow, an unauthorized party could decompile or intercept traffic to/from your application to get the Client ID and authentication URL. With this information the unauthorized party could create a rogue application, upload it to an application store, and use it to phish for usernames, passwords, and Access Tokens.\n\nUsing a browser-based flow protects you from this, since the callback URL is linked to the application through universal links (iOS) or App Links (Android). Note, however, that this is **not** a universally supported feature. To learn more about universal app links, read [Universal Links for Developers on apple.com](https://developer.apple.com/ios/universal-links/). To learn more about App Links, read [Enable Android App Links Support](https://auth0.com/docs/get-started/applications/enable-android-app-links-support).\n\n## Implementation time\n\nUsing browser-based flows reduces the implementation time required, since everything is handled by the hosted login page (including multi-factor authentication and attack protection).\n\nBy default, Lock provides the user experience, but you can customize it with your own templates written in HTML and CSS, then integrate it with `auth0.js`.\n\n## Automatic improvements\n\nBy relying on a Universal Login experience, you will automatically receive new features without requiring you to make any changes to your native application. For example, if Auth0 adds support for FIDO/U2F, you would not need to make any code changes to your application before you can use this functionality. To learn more about FIDO/U2F, read [What is FIDO U2F? on yubico.com](https://www.yubico.com/solutions/fido-u2f/).\n\n## Load time and user experience\n\nWhen using a native login flow, the login UI and logic is included in the application. With a browser-based login flow, the user sees some loading time as the page loads.\n\nHowever, it's worth noting that the number of times a user logs in with the mobile devices is low. Once the user logs in, your application should only log them out if you revoke their access or if the user opts to log out.\n\n## Compliance with best practices\n\nAs explained in the [RFC 8252 OAuth 2.0 for Native Apps](https://tools.ietf.org/html/rfc8252), OAuth 2.0 authorization requests from native apps should only be made through external user-agents, primarily the user's browser. The specification details the security and usability reasons why this is the case.\n\n## Implementation examples\n\nYou can find instructions on how to implement a browser-based login flow in our Quickstarts:\n\n*   [iOS (Swift)](https://auth0.com/docs/quickstart/native/ios-swift/00-login)\n    \n*   [Android](https://auth0.com/docs/quickstart/native/android/00-login)\n    \n\nFor native login flows, you can find samples in the following GitHub repos:\n\n*   [iOS Swift](https://github.com/auth0-samples/auth0-ios-swift-sample/tree/embedded-login/01-Embedded-Login)\n    \n*   [Android](https://github.com/auth0-samples/auth0-android-sample/tree/embedded-login/01-Embedded-Login-Kt)",
  "title": "Mobile Device Login Flow Best Practices",
  "description": "Describes the pros and cons between a browser-based vs. native experience when implementing Auth0 on a mobile device",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties",
  "markdown": "# JSON Web Key Set Properties\n\nHere is an example of the JSON Web Key Set (JWKS) used by a sample tenant, containing a single JSON Web Key (JWK):\n\n```\n{\n\"keys\": [\n  {\n    \"alg\": \"RS256\",\n    \"kty\": \"RSA\",\n    \"use\": \"sig\",\n    \"x5c\": [\n      \"MIIC+DCCAeCgAwIBAgIJBIGjYW6hFpn2MA0GCSqGSIb3DQEBBQUAMCMxITAfBgNVBAMTGGN1c3RvbWVyLWRlbW9zLmF1dGgwLmNvbTAeFw0xNjExMjIyMjIyMDVaFw0zMDA4MDEyMjIyMDVaMCMxITAfBgNVBAMTGGN1c3RvbWVyLWRlbW9zLmF1dGgwLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMnjZc5bm/eGIHq09N9HKHahM7Y31P0ul+A2wwP4lSpIwFrWHzxw88/7Dwk9QMc+orGXX95R6av4GF+Es/nG3uK45ooMVMa/hYCh0Mtx3gnSuoTavQEkLzCvSwTqVwzZ+5noukWVqJuMKNwjL77GNcPLY7Xy2/skMCT5bR8UoWaufooQvYq6SyPcRAU4BtdquZRiBT4U5f+4pwNTxSvey7ki50yc1tG49Per/0zA4O6Tlpv8x7Red6m1bCNHt7+Z5nSl3RX/QYyAEUX1a28VcYmR41Osy+o2OUCXYdUAphDaHo4/8rbKTJhlu8jEcc1KoMXAKjgaVZtG/v5ltx6AXY0CAwEAAaMvMC0wDAYDVR0TBAUwAwEB/zAdBgNVHQ4EFgQUQxFG602h1cG+pnyvJoy9pGJJoCswDQYJKoZIhvcNAQEFBQADggEBAGvtCbzGNBUJPLICth3mLsX0Z4z8T8iu4tyoiuAshP/Ry/ZBnFnXmhD8vwgMZ2lTgUWwlrvlgN+fAtYKnwFO2G3BOCFw96Nm8So9sjTda9CCZ3dhoH57F/hVMBB0K6xhklAc0b5ZxUpCIN92v/w+xZoz1XQBHe8ZbRHaP1HpRM4M7DJk2G5cgUCyu3UBvYS41sHvzrxQ3z7vIePRA4WF4bEkfX12gvny0RsPkrbVMXX1Rj9t6V7QXrbPYBAO+43JvDGYawxYVvLhz+BJ45x50GFQmHszfY3BR9TPK8xmMmQwtIvLu1PMttNCs7niCYkSiUv2sc2mlq1i3IashGkkgmo=\"\n    ],\n    \"n\": \"yeNlzlub94YgerT030codqEztjfU_S6X4DbDA_iVKkjAWtYfPHDzz_sPCT1Axz6isZdf3lHpq_gYX4Sz-cbe4rjmigxUxr-FgKHQy3HeCdK6hNq9ASQvMK9LBOpXDNn7mei6RZWom4wo3CMvvsY1w8tjtfLb-yQwJPltHxShZq5-ihC9irpLI9xEBTgG12q5lGIFPhTl_7inA1PFK97LuSLnTJzW0bj096v_TMDg7pOWm_zHtF53qbVsI0e3v5nmdKXdFf9BjIARRfVrbxVxiZHjU6zL6jY5QJdh1QCmENoejj_ytspMmGW7yMRxzUqgxcAqOBpVm0b-_mW3HoBdjQ\",\n    \"e\": \"AQAB\",\n    \"kid\": \"NjVBRjY5MDlCMUIwNzU4RTA2QzZFMDQ4QzQ2MDAyQjVDNjk1RTM2Qg\",\n    \"x5t\": \"NjVBRjY5MDlCMUIwNzU4RTA2QzZFMDQ4QzQ2MDAyQjVDNjk1RTM2Qg\"\n  }\n]}\n```\n\nEach property in the key is defined by the JWK specification [RFC 7517 Section 4](https://tools.ietf.org/html/rfc7517#section-4) or, for algorithm-specific properties, in [RFC 7518](https://tools.ietf.org/html/rfc7518)\\].\n\n| Property name | Description |\n| --- | --- |\n| `alg` | The specific cryptographic algorithm used with the key. This is an optional parameter. By default, Auth0 includes the signing algorithm defined at the tenant level in the JSON Web Key Set (JWKS), which is then published. To allow for keys to be used with multiple algorithms rather than a single algorithm i.e. RS256, toggle off **Include Signing Algorithms in JSON Web Key Set** under Advanced Tenant settings in Dashboard. This removes the `alg` parameter and requires consumers of the JWKS to interpret the signing algorithms as needed. |\n| `kty` | The family of cryptographic algorithms used with the key. |\n| `use` | How the key was meant to be used; `sig` represents the signature. |\n| `x5c` | The x.509 certificate chain. The first entry in the array is the certificate to use for token verification; the other certificates can be used to verify this first certificate. |\n| `n` | The modulus for the [RSA public key](https://tools.ietf.org/html/rfc7518#page-30). |\n| `e` | The exponent for the [RSA public key](https://tools.ietf.org/html/rfc7518#page-30). |\n| `kid` | The unique identifier for the key. |\n| `x5t` | The thumbprint of the x.509 cert (SHA-1 thumbprint). |\n\nFor an example that uses JWKS to verify a JWT's signature, see [Navigating RS256 and JWKS](https://auth0.com/blog/navigating-rs256-and-jwks/) (uses Node.js), or check out our [Backend/API Quickstarts](https://auth0.com/docs/quickstart/backend).\n\n## Learn more\n\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [Locate JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets)\n*   [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure)",
  "title": "JSON Web Key Set Properties",
  "description": "Describes the properties available in a JSON Web Key Set (JWKS).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets",
  "markdown": "# Locate JSON Web Key Sets\n\nUse this Discovery endpoint to configure your application or API to automatically locate the [JSON Web Key Set (JWKS)](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets) endpoint (`jwks_uri`), which contains the JWKS used to sign all Auth0-issued JSON Web Tokens (JWTs) signed with the RS256 signing algorithm. The endpoint exists at:\n\n`https://{yourDomain}/.well-known/openid-configuration`.\n\nWhen [validating a JWT](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens) using a JWKS, you will need to:\n\n1.  Retrieve the JWKS from the Auth0 Discovery endpoint, and filter for potential signing keys (e.g., any keys missing a public key or with a `kid` property).\n    \n2.  Grab the `kid` property from the Header of the decoded JWT.\n    \n3.  Search your filtered JWKS for the key with the matching `kid` property.\n    \n4.  Build a certificate using the corresponding `x5c` property in your JWKS.\n    \n5.  Use the certificate to verify the JWT's signature.\n    \n\nFor an example that uses JWKS to verify a JWT's signature, see [Navigating RS256 and JWKS](https://auth0.com/blog/navigating-rs256-and-jwks/) (uses Node.js), or check out our [Backend/API Quickstarts](https://auth0.com/docs/quickstart/backend).\n\nFor more info about the structure of a JWT, see [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure).\n\nIt's good practice to assume that multiple signing keys could be present in your JWKS. This may seem unnecessary since the Auth0 JWKS endpoint typically contains a single signing key; however, multiple keys can be found in the JWKS when rotating signing certificates.\n\nWe recommend that you cache your signing keys to improve application performance and avoid running into [rate limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy), but you will want to make sure that if decoding a token fails, you invalidate the cache and retrieve new signing keys before trying **only one** more time.\n\n## Learn more\n\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [JSON Web Key Set Properties](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties)\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure)\n*   [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Locate JSON Web Key Sets",
  "description": "Describes how to use the JSON Web Keys (JWKs) discovered using the JSON Web Key Set (JWKS) endpoint to verify a JWT signature.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/universal-login/customize-signup-and-login-prompts",
  "markdown": "# Customize Signup and Login Prompts\n\n**Customize Signup and Login Prompts** is a feature that allows customers with Custom Domain and Custom Page Template enabled to add custom fields and content to their app’s signup and login prompts.\n\n#### Use Cases \n\nCustomize Signup and Login Prompts supports two use cases: **custom content** and **data capture.** \n\n**Custom content** is static content like text, links, or images placed directly on the signup and login prompts.\n\n**Data capture** uses form elements dynamically added to the signup and login prompts, which is useful for collecting and validating user consent or user-produced data like surname. Data capture is only available for Database Connections without Passkey authentication users.\n\n#### Terminology\n\nA **Prompt** is a specific step in a given authentication flow. Each Prompt has at least one **Screen** and, depending on tenant configuration, each supported Screen has either four or six **Entry Points,** which are locations in the Screen where custom code (**Partials**) can be inserted.\n\nThe following Prompts can be customized:\n\n*   `signup`\n    \n*   `signup-id`\n    \n*   `signup-password`\n    \n*   `login`\n    \n*   `login-id`\n    \n*   `login-password`\n    \n\nPartials support HTML, CSS, Javascript, and [Liquid syntax](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers) to power conditional logic and dynamic variables. In addition, any Liquid variable that is available to the [Page Template](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates) is also available.\n\nThese entry points available when a database connection is enabled:\n\n*   `form-content-start`\n    \n*   `form-content-end`\n    \n*   `form-footer-start`\n    \n*   `form-footer-end`\n    \n\nThe following Entry Points are available when at least one social or enterprise connection is enabled:\n\n*   `secondary-actions-start`\n    \n*   `secondary-actions-end`\n    \n\n#### Use the Management API to Manage Partials\n\nPartials can be a maximum of 10,000 characters and are be managed by the [Auth0 Management API](https://auth0.com/docs/api/management/v2/prompts/put-partials) at `/v2/prompts/{prompts_name}/partials`. Every Prompt must specify the `Screen` when adding, updating, or deleting a Partial. Below is an example call to view all existing Partials for a prompt, noting that `ulp-container` prefix is not required when referencing Entry Points in API calls.\n\nCustom Prompts does not currently support [Auth0's Deploy CLI tool](https://auth0.com/docs/deploy-monitor/deploy-cli-tool) or Auth0 CLI.\n\n```\nGET /api/v2/prompts/signup-id/partials\n# response\n# success code: 200\n# not found code: 404\nbody: {\n  \"signup-id\": {\n    \"form-content-start\": \"<div>HTML or Liquid</div>...\",\n    \"form-content-end\": \"<div>HTML or Liquid</div>...\"\n  }\n}\n```\n\n#### Style and Validate Form Inputs\n\nCustomize Signup and Login Prompts offers pre-built styles and support for client-side validations for certain HTML form elements. The following elements are supported:\n\n*   `<input type=\"text\">`\n    \n*   `<input type=\"number\">`\n    \n*   `<input type=\"checkbox\">` \n    \n*   `<input type=\"password\">`\n    \n*   `<input type=\"email\">`\n    \n*   `<input type=\"tel\">`\n    \n*   `<input type=\"url\">`\n    \n*   `<select>`\n    \n*   `<textarea>`\n    \n\nTo use pre-built input styles, wrap your form element of choice in a `<div>` with the `ulp-field` class. Similarly, add the `ulp-error` class to the same `<div>` to use pre-built error styles. If the `ulp-error-info` element is present, a styled error message will also be displayed.\n\n#### Client-Side Validation\n\nThe feature's client-side validation framework allows customers to validate user input using HTML attributes to execute one or more custom validation functions. Validation functions can be included directly in the Partial or included in the `<head>` of the page template.\n\nTo add client-side validation to a form element:\n\n*   Reference the validation function using the `data-ulp-validation-function` attribute on the `<div class=\"ulp-error-info\">` element.\n    \n*   Declare which DOM events the validation function should be run on using the `data-ulp-validation-event-listeners` attribute on the `<div class=\"ulp-error-info\">` element, noting that validations run automatically on submission.\n    \n\n#### Localize Content\n\nPartial content can be localized by defining new custom text variables using the [Custom Text API](https://auth0.com/docs/api/management/v2/prompts/put-custom-text-by-language). Up to thirty custom text variables can be defined per screen/language combination.\n\n##### Create or Update a Custom Text Variable\n\nThe Custom Text API is available [here](https://auth0.com/docs/api/management/v2/prompts/get-custom-text-by-language) and each variable follows a `var-<name>` naming convention. Calls to the API must specify the Screen when adding, updating, or deleting a custom text variable. Markdown links are supported and are converted to HTML `<a>` elements before being displayed to users.\n\nBelow is an example call to add a variable for the text of a terms of service checkbox label in English and Spanish. See the Management API to learn more.\n\n```\n# PUT /api/v2/prompts/signup-id/custom-text/en\n{\n  \"signup\": {\n    \"var-tos\": \"I agree with the [Terms of Service](https://en.example.com/tos)\"\n  }\n}\n\n# PUT /api/v2/prompts/signup-id/custom-text/es\n{\n  \"signup\": {\n    \"var-tos\": \"Estoy de acuerdo con los [Términos de Servicio](https://es.example.com/tos)\"\n  }\n}\n```\n\n##### Use a Custom Text Variable in a Partial\n\nCustom text variables are referenced in Partials using the `prompts.screen.text` object; the reference for the `var-tos` example in the previous section is `prompt.screen.texts.varTos`. See below for an example of how to use a previously created variable in a Partial on the Signup ID Prompt, noting that the Management API's `var-tos` variable is referenced as `varTos` in the Partial.\n\n```\n# PUT api/v2/prompts/signup/partials\n{\n  \"signup\": {\n    \"form-content-end\": \"<div class='ulp-field'><input type='checkbox' name='ulp-terms-of-service' id='terms-of-service'><label for='terms-of-service'>{{ prompt.screen.texts.varTos }}</label></div>\"\n  }\n}\n```\n\n#### Validate and Save Captured Data\n\nData captured by custom form elements is available in Actions, and Auth0 recommends that the collected data be validated.\n\nEach Action receives the captured data as an object on the `event.request.body`. Customers can return a validation error by using the `api.validation.error` function.\n\n*   Data from the Signup Prompts is accessible on Pre User Registration, and if a validation error is returned, the user is prevented from registering.\n    \n*   Data from Login Prompts is accessible on Post Login, and if a validation error is returned, the validation error is forwarded to the customer’s application error page.\n    \n\n##### Save to User Metadata\n\nFrom the Action, captured data can be sent to an external API for validation and storage or saved in `user_metadata` on the user via `api.user.setUserMetadata`.\n\n```\n# Given this code in the signup form\n# <div class=\"ulp-field\">\n#   <label for=\"full-name\">Full Name</label>\n#   <input type=\"text\" name=\"ulp-full-name\" id=\"full-name\">\n# </div>\n\nexports.onExecutePreUserRegistration = async (event, api) => {\n  const fullName = event.request.body['ulp-full-name'];\n  if(!fullName) {\n    api.validation.error(\"invalid_payload\", \"Missing Name\");\n    return;\n  }\n\n  api.user.setUserMetadata(\"fullName\", fullName);\n};\n```\n\n## Learn more\n\n*   [Use Dynamic Variables to Internationalize Custom Form Elements](https://auth0.com/docs/use-dynamic-variables-to-internationalize-custom-form-elements)\n*   [Use Actions to Validate and Store End-user Data Gathered By Signup Prompt Customizations](https://auth0.com/docs/validate-and-store-user-data-with-actions)",
  "title": "Customize Signup and Login Prompts",
  "description": "Learn how to customize signup and login prompts for Universal Login ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/universal-login/customize-themes",
  "markdown": "# Customize Universal Login Page Themes\n\nYou can create a consistently branded login experience for your users by styling your Universal Login prompts. With the Universal Login no-code editor, you can easily customize the colors, fonts, borders, and backgrounds of the prompts displayed to users throughout the login flow.\n\nThe no-code editor allows you to customize your Universal Login branding theme. To customize the text included in each prompt, review [Customize Universal Login Text Elements](https://auth0.com/docs/customize/login-pages/universal-login/customize-text-elements). For expanded customization capabilities, review [Customize Universal Login Page Templates](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates).\n\n## Universal Login no-code editor\n\nTo customize your Universal Login theme, follow the steps below:\n\n1.  On the Auth0 Dashboard, navigate to [Branding > Universal Login > Customization Options](https://manage.auth0.com/#/universal-login/customizations/colors).\n    \n2.  Select a [theme component](#theme-components) (e.g., Colors) from the Styles menu. Then, customize the options listed to the right.\n    \n3.  After customizing your theme, select **Save and Publish**.\n    \n\nAfter you save your theme, you can access a live preview of your login experience to review and test your screens. To launch the preview in a new tab, select **Try** above the no-code editor.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/01nmAYzRb5U8xOpUWEClH9/de60b97b42c6de04bea69914d36e6984/branding-customize-NUL-Nocode-fullscreen0.png)\n\n### Theme components\n\nTo create your desired Universal Login theme, the Styles menu contains the following components:\n\n## Management API\n\nYou can also customize your Universal Login theme with the [Management API](https://auth0.com/docs/api/management/v2). Specifically, you can use the Branding endpoints to:\n\n*   [Create a new branding theme](https://auth0.com/docs/api/management/v2/branding/post-branding-theme)\n    \n*   [Retrieve the default branding theme](https://auth0.com/docs/api/management/v2/branding/get-default-branding-theme)\n    \n*   [Retrieve a specific branding theme](https://auth0.com/docs/api/management/v2/branding/get-branding-theme)\n    \n*   [Delete a branding theme](https://auth0.com/docs/api/management/v2/branding/delete-branding-theme)\n    \n*   [Update the current theme](https://auth0.com/docs/api/management/v2/branding/patch-branding-theme)",
  "title": "Customize Universal Login Page Themes",
  "description": "Describes how to use the no-code editor to customize themes for Universal Login pages.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset",
  "markdown": "# Password Reset Flow\n\nThe Password Reset Flow runs during the password reset process when a user completes the first challenge, typically a link to the [user's email](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators), but before a new password is set. You can use this flow to challenge a user with an additional multi-factor authentication (MFA) factor or to redirect the user to an external site, such as a third-party verifier.\n\nAfter verification, users can provide the new password for their account.\n\n![To use the Password Reset Flow, navigate to Dashboard > Actions > Flows ](https://images.ctfassets.net/cdy7uua7fh8z/1Pugm9fFYCmdhh7QO5Klzm/7f7eefbf810fd4ebeb22d6393151ffa2/2023-08-14_15-54-03.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### PostChallenge\n\nThe `post-challenge` trigger is a function that executes after a user completes the first password reset challenge, typically an email magic link. You can create up to four Actions in your tenant that leverage the `post-challenge` trigger.\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset/event-object): Provides contextual information about a single user logging in via Auth0.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Limitations\n\nThe Password Reset Flow does not support [Active Directory/LDAP connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap).\n\n## Common use cases\n\n### Secure password reset with additional MFA factors\n\nA `password-reset` / `post-challenge` Actions can issue an MFA challenge after the user completes the first challenge. For example, you can issue a WebAuthn-based challenge as a secondary factor if your tenant has WebAuthN enabled as a factor.\n\n```\n/**@type {PasswordResetPostChallengeAction}**/\nmodule.exports.onExecutePostChallenge = async (event, api) => {\n  const enrolledFactors = event.user.enrolledFactors.map((x) => ({\n    type: x.type\n  }));\n  api.authentication.challengeWith({ type: 'webauthn-roaming' }, { additionalFactors: enrolledFactors });\n};\n```\n\n### Redirect users to a third-party application\n\nIn addition to an MFA challenge, you can also try adding a redirect in the custom Action, for example, to a third-party verifier or risk assessor.\n\n```\n/** @type {PasswordResetPostChallengeAction}\n * This sample action redirects the user to an example app\n * and then continues the action after the redirect to challenge\n * the user with an MFA factor\n */\n\nmodule.exports.onExecutePostChallenge = async (event, api) => {\n  // Send the user to https://my-app.example.com\n  api.redirect.sendUserTo('https://my-app.example.com');\n};\n\nmodule.exports.onContinuePostChallenge = async (event, api) => {\n  const enrolledFactors = event.user.enrolledFactors.map((x) => ({\n    type: x.type\n  }));\n\n  // Challenge the user with email otp OR another enrolled factor\n  api.authentication.challengeWith({ type: 'email' }, { additionalFactors: enrolledFactors });\n\n  // Example of how to challenge the user with multiple options\n  // in this case email otp OR sms otp\n  // api.authentication.challengeWithAny([{ type: 'email' }, { type: 'sms' }]);\n};\n```\n\nThe Actions pipeline is not active while Auth0 redirects the user. Once the user continues the Auth0 login process, the Actions pipeline resumes. Actions that were executed prior to the redirect are not executed again. To learn more, review [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions).",
  "title": "Password Reset Flow",
  "description": "Learn about the Actions Password Reset Flow, which is executed after a user completes the first challenge but before the user sets a password.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/get-access-tokens-for-spas",
  "markdown": "# Get Management API Access Tokens for Single-Page Applications\n\nIn certain cases, you may want to use Auth0's [Management API](https://auth0.com/docs/api/management/v2#!) to manage your applications and APIs rather than the Auth0 Management Dashboard.\n\nTo call any Management API endpoints, you must authenticate using a specialized [Access Token](https://auth0.com/docs/secure/tokens/access-tokens) called the Management API Token. Management API Tokens are [JSON Web Tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens) that contain specific granted permissions (also known as scopes) for the Management API endpoints you want to call.\n\n## Limitations\n\nSince single-page applications (SPAs) are public clients and cannot securely store sensitive information (such as a **Client Secret**), they must retrieve Management API Tokens from the frontend, unlike other [application types](https://auth0.com/docs/get-started/applications). This means that Management API Tokens for SPAs have certain limitations. Specifically, they are issued in the context of the user who is currently signed in to Auth0 which limits updates to only the logged-in user's data. Although this restricts use of the Management API, it can still be used to perform actions related to updating the logged-in user's user profile.\n\n## Available scopes and endpoints\n\nWith a Management API Token issued for a SPA, you can access the following scopes (and hence endpoints).\n\n## Use Management API token to call Management API from a SPA\n\nYou can retrieve a Management API Token from a SPA (using the Management API’s audience to generate it) and use the token to call the Management API to retrieve the full user profile of the currently logged-in user.\n\n1.  [Retrieve a Management API token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production).\n    \n    1.  Authenticate the user by redirecting them to the Authorization endpoint, which is where users are directed upon login or sign-up.\n        \n    2.  When you receive the Management API Token, it will be in [JSON Web Token format](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure).\n        \n    3.  Decode it and review its contents.\n        \n2.  Call the Management API to retrieve the logged-in user's user profile from the [Get User by ID](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) endpoint.\n    \n    1.  To call the endpoint, include the encoded Management API token you retrieved in the `Authorization` header of the request.\n        \n    2.  Be sure to replace the `USER_ID` and `MGMT_API_ACCESS_TOKEN` placeholder values with the logged-in user's user ID (`sub` value from the decoded Management API token) and the Management API access token, respectively.\n        \n\n## Learn more\n\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)",
  "title": "Get Management API Access Tokens for Single-Page Applications",
  "description": "Learn about available scopes and endpoints for Management API tokens for Single-page Applications (SPAs).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login",
  "markdown": "# Customize MFA Selection for Universal Login\n\nAuth0 supports a variety of factors for securing user access with [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors). Using `post-login` Actions, you can customize your MFA flows to challenge users with a specific factor or sequence of factors. You can also use contextual information about users and their organizations to create more individualized experiences. For example, you can customize your flows to challenge users with specific factors based on their membership in certain Organizations or their assigned user roles.\n\n## How it works\n\nYou can use [Actions](https://auth0.com/docs/customize/actions) to customize your MFA flows. Specifically, you can modify the `post-login` trigger of the [Login Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) with the following Authentication API methods:\n\n*   `challengeWith`: Specifies the factor or factors users must use to authenticate, such as a one-time password (OTP). This method presents a default challenge to users and can optionally provide access to a factor picker that allows them to choose a different authentication method.\n    \n*   `challengeWithAny`: Sets a group of factors users can choose from when authenticating, such as email and OTP. By default, this method presents a factor picker to users rather than a specific challenge, in accordance with the following conditions:\n    \n    *   If two or more factors are specified, a factor picker displays to the user.\n        \n    *   If the user has only enrolled in one of the specified factors (or only one factor is supplied), the factor picker is skipped.\n        \n    *   If the user has not enrolled in any of the specified factors, the command fails.\n        \n\nYou can use a combination of these methods to tailor your MFA flows as needed. You can also incorporate user metadata, such as roles or previously used factors, into these methods to create more tailored flows.\n\nWhen choosing MFA challenges for your commands, you can use the factors listed below or the `enrolledFactors` value. `enrolledFactors` represents the list of active factors associated with a user's account.\n\n*   `otp`\n    \n*   `email`\n    \n*   `push-notification`\n    \n    *   `otpFallback`\n        \n*   `phone`\n    \n    *   `preferredMethod: voice`\n        \n    *   `preferredMethod: sms`\n        \n    *   `preferredMethod: both`\n        \n*   `webauthn-platform`\n    \n*   `webauthn-roaming`\n    \n\nThe array `event.authentication.methods` includes a `type` field when the name of the method is set to `mfa`. type is a string that contains factor values matching those used by the `type` field from `enrolledFactors` (listed above). When an MFA challenge is performed, `methods` contains an object of `name:mfa` with `type` set to the factor used for that challenge. `methods` is only updated when an Action begins. To see the results of a challenge, `methods` must be accessed in the next Action in the flow.\n\nTo learn more, review the following resources:\n\n*   [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object)\n    \n*   [Actions Triggers: post-login - API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object)\n    \n\n### Sequenced and contextual flows\n\nWith the `challengeWith` or `challengeWithAny` commands, you can use contextual information to determine the best challenge or series of challenges to present to users. Specifically, you can leverage the following:\n\n*   **Sequenced flows**: Challenge users with a series of different factors in a specific order.\n    \n*   **Contextual flows**: Determine which factor to next challenge the user with based on previous challenges in the flow.\n    \n\nTo help illustrate these flows, consider the following example:\n\n```\n// ACTION 1 \n\nexports.onExecutePostLogin = async (event, api) => {\n\n   api.authentication.challengeWithAny([{ type: 'phone'}, { type: 'push-notification' }]);\n\n} \n\n// ============================================ \n\n// ACTION 2 \n\n// Decide based on what the user did in the previous action \n\nexports.onExecutePostLogin = async (event, api) => { \n\n    if(event.authentication.methods.find(m => m.type === 'phone') && event.authorization?.roles.includes('admin')) { \n\n        api.authentication.challengeWith({ type: 'push-notification' }); \n\n    }\n\n}\n```\n\nIn this scenario, a user is first challenged with SMS via the `challengeWithAny` command in Action 1. Then, Action 2 challenges the user with a push notification because they have the Admin user role and also completed the SMS challenge.\n\nIn this flow, you can make decisions about which factor to challenge the user with due to the following:\n\n1.  The flow pauses after executing Action 1.\n    \n2.  The user completes the MFA flow prompted by Action 1.\n    \n3.  `event.authentication.methods.type` in Action 2 populates with information from the previous MFA challenge.\n    \n4.  The flow resumes to execute Action 2 using contextual information from Action 1.\n    \n\nWhile this example presents a similar experience to using redirects in your Actions, commands using `challengeWith` and `challengeWithAny` offer the following unique benefits:\n\n*   Flows pause after each command, allowing you to accumulate user information that can be used in subsequent Actions. Comparatively, redirects only occur a single time as the final command in a flow.\n    \n*   MFA is triggered after each Action containing `challengeWith` or `challengeWithAny` commands is executed. With redirects, MFA runs as the final Action in the pipeline.\n    \n\n**Note**: This method of executing Actions only applies to those containing `challengeWith` or `challengeWithAny` commands. Actions serving other purposes are not affected.\n\n## Before you begin\n\nBefore you can customize your MFA flows, you must first enable MFA in your tenant and prompt your users to enroll in the appropriate factors.\n\n### Prepare your tenant\n\nTo get started, set up MFA in your tenant and enable the Customize MFA Factors using Actions setting. You can set up one or more factors and define your MFA policies on the Auth0 Dashboard under [Security > Multifactor Auth](https://manage.auth0.com/#/security/mfa).\n\n*   To learn more about the setup process, review [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa).\n    \n*   For information about configuring specific factors, review [Multi-factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n    \n\nTo customize your flows, you **must enable** the Customize MFA Factors using Actions toggle in the Additional Settings section. Your customized flows will not work properly if this setting is not enabled.\n\n![Auth0 Dashboard > Security > Multi-factor Auth > Additional Settings](https://images.ctfassets.net/cdy7uua7fh8z/2hv0ELTkkka3t230SXfxw/46def5395652b2451cfc9e0ad01a371a/MFA_actions.png)\n\n### Enroll users in factors\n\nOnce MFA is configured, ensure your users enroll in one or more of the factors you enabled. Users must enroll in authenticators before they can be challenged by `post-login` Action commands.\n\nAfter a user signs up or is created in your tenant, you can create enrollments with the Management API [authentication-methods](https://auth0.com/docs/api/management/v2/users/post-authentication-methods) endpoint, or you can manage users' enrollments directly through their profile pages in the Auth0 Dashboard.\n\n## Customize your MFA flows\n\nOnce your tenant is ready, you can create `post-login` Actions to customize your MFA flows. Steps and example use cases are provided below.\n\n### Create your post-login Action\n\n1.  On your Auth0 Dashboard, navigate to [Actions > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**.\n    \n2.  Under Add Action, select **Custom** and choose **Create Action**.\n    \n3.  On the Create Action popup:\n    \n    *   Enter a name for your Action.\n        \n    *   Select **Login / Post-Login** as the trigger.\n        \n    *   Use **Node 18 (Recommended)** for the runtime.\n        \n4.  Review the popup to ensure accuracy. Then, select **Create**.\n    \n5.  After creation, the code editor displays the `onPostExecute` command. Add your custom code or code sample to the command.\n    \n6.  When your command is ready, select **Deploy**.\n    \n7.  Select **Add to Flow** on the successful deployment notification.\n    \n    *   **Note**: If the notification has closed, choose **Back to Flow** above the code editor.\n        \n8.  Drag and drop your new command from the Add Action panel into your Login flow. Then, select **Apply**.\n    \n\nTo make additional updates to your Action, navigate to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your command. You can then update and redeploy your code as needed.\n\n### Test your post-login Action\n\nTo ensure your commands function appropriately, you can test your Action through the Auth0 Dashboard:\n\n*   Navigate to [Authentication > Authentication Profile](https://manage.auth0.com/#/authentication-profiles).\n    \n*   Select **Try** to open a sample login prompt in a new tab.\n    \n*   Enter your credentials and test your new MFA flow.\n    \n\nIf the flow is successful, a confirmation screen displays. If you encounter any issues, you can update your code by navigating to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) on your Auth0 Dashboard.\n\n## Example use cases\n\nThe examples below outline common use cases for customizing MFA flows.\n\n### Use current enrollments to determine challenge method\n\nThe following sample challenges a user with MFA if they are enrolled with the following factors:\n\n*   One-time password (OTP)\n    \n*   Phone\n    \n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\n api.authentication.challengeWithAny([{type: 'otp'}, {type: 'phone'}]);\n\n}\n```\n\n### Use roles to determine challenge method\n\nThe following sample challenges all users with OTP. If a user has the Admin role and requires a higher level of access to your application, they are challenged with an additional factor as a form of [step-up authentication](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication).\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n    api.authentication.challengeWith({type: 'otp'});\n\n    const isAdmin = event.authorization?.roles.includes('admin');\n    if(isAdmin) {\n        api.authentication.challengeWith({type: 'phone'});\n    }\n}\n```\n\n### Use metadata to determine challenge method\n\nIn this example, MFA factors are enabled at the [Organization](https://auth0.com/docs/manage-users/organizations) level. This sample uses different categories of metadata to determine the right challenge for individual users:\n\n*   **Organization metadata**: Organization-level data, such as the specific factors enabled for an Organization.\n    \n*   **User metadata**: User-level data, such as whether a user has a phone number associated with their profile.\n    \n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const orgFactors = event.organization.metadata.factors ?? [];\n\n  // Get the intersection of factors available for the user and factors enabled for the org\n  const availableFactors = orgFactors.filter(f => event.user.enrolledFactors.some(ef => ef.type === f));\n\n  // Prefer push if available\n  if(availableFactors.includes('push-notification')) {\n    api.authentication.challengeWith({ type: 'push-notification' });\n    return;\n  }\n\n  // If the user has a verified phone number and the organization\n  // allows for SMS and email, prefer SMS and allow email as a fallback\n  // if available\n  if(event.user.phone_number && \n     event.user.phone_verified && \n     availableFactors.includes('phone')) {\n    if(availableFactors.includes('email') {\n      api.authentication.challengeWith({ type: 'phone' }, {\n        additionalFactors: [{\n          type: 'email'\n        }]\n      });\n    } else {\n      api.authentication.challengeWith({ type: 'phone' });\n    }\n\n    return;\n  }\n\n  // If push-notifications and/or phone couldn't be prioritized, fallback to email if\n  // enabled for the org, otherwise fail.\n  if(availableFactors.includes('email') {\n    api.authentication.challengeWith({ type: \"email\" });\n    return;\n  }\n\n  api.access.deny(\"No MFA factors available for this org + user\");\n};\n```\n\n### Allow users to select an alternate method of authentication\n\nFor a more flexible experience, you can present users with a **Try Another Method** link as part of their MFA challenge. This link allows users to select a different method of authentication than the default challenge.\n\nTo achieve this, include the `additionalFactors` parameter in your Actions code. You can set this parameter to a specific factor for all users or use `enrolledFactors` to let users choose their preferred factor.\n\n**Specific Factor**\n\nThe following sample challenges users with OTP by default. If desired, users can access the Try Another Method link to authenticate with email instead.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  api.authentication.challengeWith({ type: 'otp' }, \n    { additionalFactors: [{type: 'email'}] })\n};\n```\n\n**Enrolled Factors**\n\nThe following sample challenges users with OTP by default. If desired, users can access the Try Another Method link to authenticate with one of their other enrolled factors.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const enrolledFactors = event.user.enrolledFactors.map((f) => ({type: f.type}));\n\n  api.authentication.challengeWith({ type: 'otp' }, \n    { additionalFactors: enrolledFactors })\n};\n```\n\n### Use Adaptive MFA to determine when to challenge users\n\nThe following example uses [Adaptive MFA](https://auth0.com/docs/get-started/auth0-teams/tenant-management) to determine if users should be challenged.\n\nAdaptive MFA is a flexible MFA policy that protects your tenant from bad actors by assessing potential risk during login transactions and prompting users for additional verification when appropriate.\n\nIn this case, users are prompted with MFA if they log in from an unrecognized device and their overall confidence score is low or medium.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.authentication?.riskAssessment?.assessments.NewDevice) {\n\n  // Example condition: prompt MFA only based on the NewDevice \n    // confidence level, this will prompt for MFA when a user is logging in \n    // from an unknown device.\n    let shouldPromptMfa;\n\n    switch (event.authentication.riskAssessment.assessments.NewDevice.confidence) {\n      case 'low':\n      case 'medium':\n        shouldPromptMfa = true;\n        break;\n      case 'high':\n        shouldPromptMfa = false;\n        break;\n      case 'neutral':\n        // When this assessor has no useful information about the confidence, \n        // do not prompt MFA.\n        shouldPromptMfa = false;\n        break;\n    }\n\n      // It only makes sense to prompt for MFA when the user has at least one \n      // enrolled MFA factor.\n    const canPromptMfa = event.user.enrolledFactors?.length > 0;\n\n    if (shouldPromptMfa && canPromptMfa) {\n      const enrolledFactors = event.user.enrolledFactors.map((f) => ({type: f.type}));\n      api.authentication.challengeWithAny(enrolledFactors);\n    }\n\n  }\n\n};\n```\n\n### Use Actions to challenge users\n\nYou can use Actions to customize MFA flows by modifying the `post-login` trigger of the Login Flow. This example uses the `phone` method of authentication and `preferredMethod: 'both'`, referring to the active MFA factors associated with a user's account. For more information, refer to [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object).\n\n```\napi.authentication.challengeWith({ \n  type: 'phone', \n  options: { preferredMethod: 'both'} \n});\n```\n\n## Troubleshooting\n\nIn the event that you experience errors or unexpected results from your customized MFA flows, you can use the information below to help identify and resolve these issues.\n\n### Tenant logs\n\nYou can monitor your customized MFA flows through [tenant logs](https://auth0.com/docs/deploy-monitor/logs).\n\nTenant logs are available on the Auth0 Dashboard under [Monitoring > Logs](https://manage.auth0.com/#/logs). Alternatively, you can retrieve logs using the [Management API](https://auth0.com/docs/api/management/v2/introduction).\n\nIf you or your users experience unexpected behavior, review tenant logs for the following event codes for more information:\n\n| Scenario | Event Code | Descriptive Error |\n| --- | --- | --- |\n| A user is prompted with multi-factor authentication, but none of the requested factors can be used as a challenge. In this case, the user cannot complete MFA. | mfar | This scenario results in the following error message:<br><br>An MFA challenge is used in a PostLogin action but the requested factors are not properly set up. To perform MFA, enable the requested factors and ensure the user is enrolled with them. |\n| A user is prompted with multi-factor authentication, but one of the requested factors cannot be used as a challenge. In this case, the user can complete MFA using a different requested factor. | w   | This scenario results in the following warning message:<br><br>An MFA challenge is used in a PostLogin action, but the requested factor {factor name} is not properly set up. Enable the requested factor and ensure the user is enrolled with it. |\n\n### Troubleshooting checklist\n\nThe following checklist provides additional suggestions for identifying and resolving common issues with customized MFA flows.\n\n1.  The **Customize MFA factors with Actions** toggle must be enabled.\n    \n    *   Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure the toggle in the Additional Settings section is enabled.\n        \n2.  Factors referenced in your Actions must be enabled in your tenant.\n    \n    *   **Review your code**: Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and review your Actions code. Ensure all factors referenced are applicable to your use cases.\n        \n    *   **Review your factors**: Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure all factors referenced in your Actions are enabled.\n        \n3.  Users must be enrolled in the factors referenced in your Actions.\n    \n    *   If an individual receives an error, review their user details to ensure they are enrolled in the proper factors. Navigate to [**Auth0 Dashboard > User Management > Users**](https://manage.auth0.com/#/users) and select their name from the list.\n        \n        *   Review the Multi-factor Authentication section on the **Detail tab** to verify their enrollments. If the user is not enrolled, you can use the **Send an enrollment invitation** link available in this section.\n            \n        *   Alternatively, verify the user's enrollments through the **Raw JSON tab**. This information can also be retrieved using the [Management API](https://auth0.com/docs/api/management/v2/users/get-authentication-methods). However, it is important to note that the API does not list auto-enrolled authenticators, such as Email factors set up via an email verification link.\n            \n    *   If users are not enrolled in the appropriate factors, you can create enrollments with the Management API [authentication-methods](https://auth0.com/docs/api/management/v2/users/post-authentication-methods) endpoint. You can also manage users' enrollments directly through their profile pages in the Auth0 Dashboard.\n        \n4.  Ensure your Actions have been deployed and saved in your Pipeline.\n    \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library). Locate your Action in the list and ensure its status is **Deployed**. If a different status is listed, access your Action, review your code, and click **Deploy** to the top right.\n        \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**. Ensure your Action is listed in the flow. If not, access the **Custom tab** of the Add Action panel and drag and drop your Action into your Login flow. Then, select **Apply**.\n        \n5.  Ensure you've upgraded to the latest version of `post-login` Actions.\n    \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your Action. If your Action is out-of-date, you will see a yellow banner prompting you to update the Action. If the banner displays, select **Update**.\n        \n    *   You can also specify the latest version of `post-login` Actions for deployment when using the Deploy CLI. For more information, review [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).",
  "title": "Customize MFA Selection for Universal Login",
  "description": "Customize MFA flows using post-login Actions to challenge users with specific factors or sequences of factors. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/confidential-and-public-applications/view-application-ownership",
  "markdown": "# View Application Ownership\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D?fields=is_first_party&include_fields=true' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D?fields=is_first_party&include_fields=true\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D?fields=is_first_party&include_fields=true\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D?fields=is_first_party&include_fields=true\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D',\n  params: {fields: 'is_first_party', include_fields: 'true'},\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D?fields=is_first_party&include_fields=true\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D?fields=is_first_party&include_fields=true\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/clients/%7ByourClientId%7D?fields=is_first_party&include_fields=true\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D?fields=is_first_party&include_fields=true\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D?fields=is_first_party&include_fields=true\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "View Application Ownership",
  "description": "Learn how to check whether an application is registered with Auth0 as a first-party or third-party app using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/configure-application-metadata",
  "markdown": "# Configure Application Metadata\n\nApplication metadata is optional and consists of customizable keys and values (max 255 characters each), that you can set for each application. Metadata is exposed in the `Client` object as `client_metadata`, and in Rules as `context.clientMetadata`. You might store, for example, the URL for the application’s home page (a field that Auth0 doesn’t provide by default in the application settings).\n\nClient metadata is stored as part of the application (client) properties. To learn more about data types, field names, and storage limitations, read [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data).\n\n#### Where to store client secrets\n\nWhere to store the secret depends on the scope of the secret:\n\n*   Is it just one secret per application? Then `client_metadata` would be a good place.\n    \n*   Is it the same secret for the whole system (i.e., for all applications or many)? Then the rule’s configuration values might be a better choice\n    \n*   Is it a different secret for each user? Then storing in `app_metadata` might be better.\n    \n\nExisting applications will have no value for this property.\n\nYou can access application metadata in [Actions](https://auth0.com/docs/customize/actions):\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.client.metadata.SKIP_VERIFICATION === \"yes\"){\n    return;\n  }\n  // ... continue this Action\n}\n```\n\n... or in [Rules](https://auth0.com/docs/customize/rules):\n\n```\nfunction applicationMetadataExample (user, context, callback){\n  context.clientMetadata = context.clientMetadata || {};\n  if (context.clientMetadata.SKIP_VERIFICATION === \"yes\"){\n    return callback();\n  }\n  // ... continue this Rule\n}\n```\n\nYou can read and add to the application metadata using either the Dashboard or the Management API. To learn how to manage client metadata with the Management API, read [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api).\n\n## Add application metadata key/value pairs\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the application.\n    \n2.  Scroll down and click **Advanced Settings**.\n    \n3.  On the **Application Metadata** tab, enter the key's name and value, then click **Add**.\n    \n    ![Dashboard Applications Applications Settings Tab Advanced Settings Application Metadata Tab](https://images.ctfassets.net/cdy7uua7fh8z/7GWHyQloNihda3fuYiVEWQ/d32531dbb111dc90f491985970da76fe/dashboard-applications-applications-settings-advanced-app-metadata.png)\n4.  Click **Save Changes**.\n    \n\n## Update application metadata value\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the application.\n    \n2.  Scroll down and click **Advanced Settings**.\n    \n3.  On the **Application Metadata** tab, enter the key's name that you want to change and enter a new value, then click **Add**.\n    \n4.  Click **Save Changes**\n    \n\n## Delete application metadata\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the application.\n    \n2.  Scroll down and click **Advanced Settings**.\n    \n3.  On the **Application Metadata** tab locate the key/value pair you want to delete and click the trash can icon.\n    \n4.  Confirm the deletion.\n    \n5.  Click **Save Changes**.\n    \n\n## Learn more\n\n*   [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Rotate Client Secrets](https://auth0.com/docs/get-started/applications/rotate-client-secret)",
  "title": "Configure Application Metadata",
  "description": "Learn how to configure, update, and delete application metadata (client_metadata and clientMetadata)  in the Auth0 Dashboard Applications Advanced Settings.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata",
  "markdown": "# Manage User Metadata with the post-login Action Trigger\n\nAuth0 provides a rich system for storing [metadata](https://auth0.com/docs/manage-users/user-accounts/metadata) on the Auth0 user profile. You can configure a `post-login` trigger to modify `user_metadata` and `app_metadata` as part of a user’s login flow. Post-login triggers are useful for tasks such as storing application-specific data on the user profile, capturing user operation logs, mapping SAML attributes to the metadata field, or caching expensive operation values on the User profile for re-used in future logins.\n\nThe `post-login` `api` object provides common operations that can be performed in this trigger. To manage user metadata, we want to use the `api.user.setAppMetadata` and `api.user.setUserMetadata` methods. For example, to guard against some behavior running more than once for a specific user, consider an Action that looks like this:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.user.app_metadata.didAnExpensiveTask) {\n    console.log(`Skipping the expensive task because it already occurred for ${event.user.email}.`);\n    return;\n  }\n  // do and expensive task\n  api.user.setAppMetadata(\"didAnExpensiveTask\", true);\n};\n```\n\nHere, we added a check at the start of the Action to see if we have already performed the expensive task for this user. If the metadata field exists, then we return from the function.\n\nAt the end of the Action, we call `api.user.setAppMetadata` to signal that we would like to store some metadata on the user object. At the end of each trigger’s execution, Actions will update the user profile as a single operation. If several calls are made to `setUserMetadata` actions, even if they are made in different actions as part of the same flow, Actions will only update the user profile a single time--at the end of the trigger’s execution.\n\n## Best practices\n\nBeware of storing too much data in the Auth0 profile. This data is intended to be used for authentication and authorization purposes, and users can edit their own `user_metadata` field, so don't store sensitive data in it. The metadata and search capabilities of Auth0 are not designed for marketing research or anything else that requires heavy search or update frequency. Your system is likely to run into scalability and performance issues if you use Auth0 for this purpose. A better approach is to store data in an external system and store a pointer (the user ID) in Auth0 so that backend systems can fetch the data if needed.\n\n## Rate limits\n\nEven though a single call is made to update the user profile, that operation is still subject to your tenant’s \"Write User\" [rate limits](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits). If the Rate Limit is hit when attempting to update metadata, Actions will retry the request as long as a `429` HTTP status code is returned. The delay between retries is governed by the value of the `X-RateLimit-Reset` header returned as part of the `429` response.\n\n## Redirects\n\nIn the event of a Redirect invoked with `api.redirect.sendUserTo()`, any pending user or app metadata updates will be applied to the user profile before the user is redirected to the external site. To learn more, see [Redirecting With Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions).\n\n## Learn more\n\n*   [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions)",
  "title": "Manage User Metadata with the post-login Action Trigger",
  "description": "Learn how to use the post-login Action trigger to modify user_metadata and app_metadata as part of a user’s login flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/custom-signup",
  "markdown": "# Custom Signup\n\nYou can customize the user signup form with more fields in addition to email and password when using Lock or the Auth0 API.\n\nThere are many factors to consider before you choose [Lock vs. Custom UI](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk). For example, using Lock, you can redirect to another page to capture data or use progressive profiling. When using the Auth0 API, you can capture custom fields and store them in a database. There are certain limitations to the customization that should be considered when choosing the method that best suits your purpose. Some typical customizations include adding a username and verifying password strength.\n\n#### Universal Login recommended\n\nAuth0 offers a [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) option that you can use instead of designing your own custom login or signup pages, or using those that are embedded in any of the Auth0 libraries. If you want to offer signup and login options, and you only need to customize the application name, logo and background color, then Universal Login might be an easier option to implement.\n\n## Using Lock\n\nLock supports [custom fields signup](https://auth0.com/docs/libraries/lock/lock-configuration).\n\nLock's `additionalSignUpFields` option will only work with database signups. For signups using social identity providers, collecting these fields in the same manner is not possible with Lock, but there are two other options to allow social IDP signups with Lock while still collecting additional custom fields.\n\n### Redirect to another page\n\nOne way to use social provider signups with Lock and collect custom fields is to use [redirect rules](https://auth0.com/docs/customize/rules/redirect-users) to redirect the user to another page where you ask for extra information, and then redirect back to finish the authentication transaction.\n\n### Progressive profiling\n\nAnother way to collect custom field data when signing users up with social providers is via [progressive profiling](https://auth0.com/docs/manage-users/user-accounts/user-profiles/progressive-profiling) whereby you can slowly build up user profile data over time. You collect the bare minimum details upon signup, but when a user later interacts with your app, you collect a small amount of data (perhaps one question) each time until their profile is complete. This allows you to collect the desired information but with less friction, since the goal of using a social IDP for signup is making it more effortless and streamlined for the user.\n\n## Using the API\n\n### Create a signup form to capture custom fields\n\nThe `name` is a user profile attribute and `color` is a custom field.\n\nThere is currently no way to validate user-supplied custom fields when signing up. Validation must be done from an Auth0 [Rule](https://auth0.com/docs/customize/rules) at login, or with custom, **server-side** logic in your application.\n\n### Send the form data\n\nSend a POST request to the [/dbconnections/signup](https://auth0.com/docs/api/authentication/reference#signup) endpoint in Auth0.\n\nYou will need to send:\n\n*   Your application's `client_id`\n    \n*   The `email` and `password` of the user being signed up\n    \n*   The name of the database `connection` to store your user's data\n    \n*   Any user profile attribute you want to update for the user, which can include `given_name`, `family_name`, `name`, `nickname`, and `picture`.\n    \n*   Any custom fields as part of `user_metadata`\n    \n\n## Custom fields limitations\n\nWhen your users sign up, the custom fields are sent as part of `user_metadata`. The limitations of this field are:\n\n*   `user_metadata` must contain no more than 10 fields\n    \n*   `user_metadata.field` must be a string\n    \n*   `user_metadata.field.value.length` must be fewer than 500 characters\n    \n*   `user_metadata.field.length` must be fewer than 100 characters\n    \n*   The current size limit for `user_metadata` is **16 MB**\n    \n\n## Redirect mode\n\nAfter a successful login, Auth0 will redirect the user to your configured callback URL with a JWT (`id_token`) in the query string.\n\nYour server will then need to call APIv2 to add the necessary custom fields to the user's profile.\n\n## Add username to the signup form\n\nOne common signup customization is to add a username to the signup.\n\nTo enable this feature, turn on the **Requires Username** setting on the [Connections > Database](https://manage.auth0.com/#/connections/database/) section of the dashboard under the **Settings** tab for the connection you wish to edit.\n\nCapture the `username` field in your custom form, and add the `username` to your request body.\n\n## Optional: Verify password strength\n\nPassword policies for database connections can be configured in the dashboard. For more information, see: [Password Strength in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-strength).\n\nIf required for implementation of custom signup forms, the configured password policies, along with other connection information, can be retrieved from the [Management v2 API](https://auth0.com/docs/api/management/v2#!/Connections/get_connections_by_id). The result can be parsed client-side, and will contain information about the current password policy (or policies) configured in the dashboard for that connection.",
  "title": "Custom Signup",
  "description": "How to customize the user signup form with additional fields using Lock or the Auth0 API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/create-organizations",
  "markdown": "# Create Organizations\n\n```\ncurl --request POST \\\n  --url https://%7ByourAuth0Domain/api/v2/organizations \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"name\": \"ORG_NAME\", \"display_name\": \"ORG_DISPLAY_NAME\", \"branding\": [ { \"logo_url\": \"{orgLogo}\", \"colors\": [ { \"primary\": \"{orgPrimaryColor}\", \"page_background\": \"{orgPageBackground}\" } ] } ], \"metadata\": [ { \"{key}\": \"{value}\", \"{key}\": \"{value}\", \"{key}\": \"{value}\" } ] }, \"enabled_connections\": [ { \"connection_id\": \"{connectionId}\", \"assign_membership_on_login\": \"{assignMembershipOption}\" }, { \"connection_id\": \"{connectionId}\", \"assign_membership_on_login\": \"{assignMembershipOption}\" } ] }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourAuth0Domain/api/v2/organizations\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"name\\\": \\\"ORG_NAME\\\", \\\"display_name\\\": \\\"ORG_DISPLAY_NAME\\\", \\\"branding\\\": [ { \\\"logo_url\\\": \\\"{orgLogo}\\\", \\\"colors\\\": [ { \\\"primary\\\": \\\"{orgPrimaryColor}\\\", \\\"page_background\\\": \\\"{orgPageBackground}\\\" } ] } ], \\\"metadata\\\": [ { \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\" } ] }, \\\"enabled_connections\\\": [ { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" }, { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" } ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourAuth0Domain/api/v2/organizations\"\n\n\tpayload := strings.NewReader(\"{ \\\"name\\\": \\\"ORG_NAME\\\", \\\"display_name\\\": \\\"ORG_DISPLAY_NAME\\\", \\\"branding\\\": [ { \\\"logo_url\\\": \\\"{orgLogo}\\\", \\\"colors\\\": [ { \\\"primary\\\": \\\"{orgPrimaryColor}\\\", \\\"page_background\\\": \\\"{orgPageBackground}\\\" } ] } ], \\\"metadata\\\": [ { \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\" } ] }, \\\"enabled_connections\\\": [ { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" }, { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" } ] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://%7ByourAuth0Domain/api/v2/organizations\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"name\\\": \\\"ORG_NAME\\\", \\\"display_name\\\": \\\"ORG_DISPLAY_NAME\\\", \\\"branding\\\": [ { \\\"logo_url\\\": \\\"{orgLogo}\\\", \\\"colors\\\": [ { \\\"primary\\\": \\\"{orgPrimaryColor}\\\", \\\"page_background\\\": \\\"{orgPageBackground}\\\" } ] } ], \\\"metadata\\\": [ { \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\" } ] }, \\\"enabled_connections\\\": [ { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" }, { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" } ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://%7ByourAuth0Domain/api/v2/organizations',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'cache-control': 'no-cache'\n  },\n  data: '{ \"name\": \"ORG_NAME\", \"display_name\": \"ORG_DISPLAY_NAME\", \"branding\": [ { \"logo_url\": \"{orgLogo}\", \"colors\": [ { \"primary\": \"{orgPrimaryColor}\", \"page_background\": \"{orgPageBackground}\" } ] } ], \"metadata\": [ { \"{key}\": \"{value}\", \"{key}\": \"{value}\", \"{key}\": \"{value}\" } ] }, \"enabled_connections\": [ { \"connection_id\": \"{connectionId}\", \"assign_membership_on_login\": \"{assignMembershipOption}\" }, { \"connection_id\": \"{connectionId}\", \"assign_membership_on_login\": \"{assignMembershipOption}\" } ] }'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"cache-control\": @\"no-cache\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ \"name\": \"ORG_NAME\", \"display_name\": \"ORG_DISPLAY_NAME\", \"branding\": [ { \"logo_url\": \"{orgLogo}\", \"colors\": [ { \"primary\": \"{orgPrimaryColor}\", \"page_background\": \"{orgPageBackground}\" } ] } ], \"metadata\": [ { \"{key}\": \"{value}\", \"{key}\": \"{value}\", \"{key}\": \"{value}\" } ] }, \"enabled_connections\": [ { \"connection_id\": \"{connectionId}\", \"assign_membership_on_login\": \"{assignMembershipOption}\" }, { \"connection_id\": \"{connectionId}\", \"assign_membership_on_login\": \"{assignMembershipOption}\" } ] }\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourAuth0Domain/api/v2/organizations\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourAuth0Domain/api/v2/organizations\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"name\\\": \\\"ORG_NAME\\\", \\\"display_name\\\": \\\"ORG_DISPLAY_NAME\\\", \\\"branding\\\": [ { \\\"logo_url\\\": \\\"{orgLogo}\\\", \\\"colors\\\": [ { \\\"primary\\\": \\\"{orgPrimaryColor}\\\", \\\"page_background\\\": \\\"{orgPageBackground}\\\" } ] } ], \\\"metadata\\\": [ { \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\" } ] }, \\\"enabled_connections\\\": [ { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" }, { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" } ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"name\\\": \\\"ORG_NAME\\\", \\\"display_name\\\": \\\"ORG_DISPLAY_NAME\\\", \\\"branding\\\": [ { \\\"logo_url\\\": \\\"{orgLogo}\\\", \\\"colors\\\": [ { \\\"primary\\\": \\\"{orgPrimaryColor}\\\", \\\"page_background\\\": \\\"{orgPageBackground}\\\" } ] } ], \\\"metadata\\\": [ { \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\" } ] }, \\\"enabled_connections\\\": [ { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" }, { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" } ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"%7ByourAuth0Domain/api/v2/organizations\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourAuth0Domain/api/v2/organizations\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"name\\\": \\\"ORG_NAME\\\", \\\"display_name\\\": \\\"ORG_DISPLAY_NAME\\\", \\\"branding\\\": [ { \\\"logo_url\\\": \\\"{orgLogo}\\\", \\\"colors\\\": [ { \\\"primary\\\": \\\"{orgPrimaryColor}\\\", \\\"page_background\\\": \\\"{orgPageBackground}\\\" } ] } ], \\\"metadata\\\": [ { \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\", \\\"{key}\\\": \\\"{value}\\\" } ] }, \\\"enabled_connections\\\": [ { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" }, { \\\"connection_id\\\": \\\"{connectionId}\\\", \\\"assign_membership_on_login\\\": \\\"{assignMembershipOption}\\\" } ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"cache-control\": \"no-cache\"\n]\n\nlet postData = NSData(data: \"{ \"name\": \"ORG_NAME\", \"display_name\": \"ORG_DISPLAY_NAME\", \"branding\": [ { \"logo_url\": \"{orgLogo}\", \"colors\": [ { \"primary\": \"{orgPrimaryColor}\", \"page_background\": \"{orgPageBackground}\" } ] } ], \"metadata\": [ { \"{key}\": \"{value}\", \"{key}\": \"{value}\", \"{key}\": \"{value}\" } ] }, \"enabled_connections\": [ { \"connection_id\": \"{connectionId}\", \"assign_membership_on_login\": \"{assignMembershipOption}\" }, { \"connection_id\": \"{connectionId}\", \"assign_membership_on_login\": \"{assignMembershipOption}\" } ] }\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourAuth0Domain/api/v2/organizations\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Create Organizations",
  "description": "Learn how to create Organizations using the Auth0 Dashboard and Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/delete-organizations",
  "markdown": "# Delete Organizations\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/organizations/ORG_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations/ORG_ID\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations/ORG_ID\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/organizations/ORG_ID\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/organizations/ORG_ID',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations/ORG_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations/ORG_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/organizations/ORG_ID\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations/ORG_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations/ORG_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Delete Organizations",
  "description": "Learn how to delete Organizations using the Auth0 Dashboard or Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/disable-connections",
  "markdown": "# Disable Organization Connections\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections/CONNECTION_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Disable Organization Connections",
  "description": "Learn how to disable organization connections using the Auth0 Dashboard or Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/define-organization-behavior",
  "markdown": "# Define Organization Behavior\n\nWhen representing your application in Auth0, you can specify what types of users the application should support. Some applications support individuals logging in with personal accounts, while others are intended for use by members of [organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview). Some should support both. This is known as organization behavior and can be set for each application that you connect to Auth0.\n\nFor example, your application could have:\n\n*   A generic marketing landing page that has a **Log in** button that takes your users to the Auth0 login flow without an Organization.\n    \n*   A separate URL for each of your B2B customers (e.g., Acme users go to `acme.yourcompany.com`) that redirects users to Auth0 with an Organization, so that your users see Acme’s SSO Login button.\n    \n\nYou can define Organization behavior to allow either of these scenarios. Additionally, you can configure Organization behavior such that if your application requires that an Organization be provided but your user accidentally is sent to Auth0 without an organization, they would see a prompt that would allow them to enter the name of their organization.\n\nYou can define organization behavior using either the Auth0 Dashboard or the Management API.\n\n## Auth0 Dashboard\n\nTo define organization behavior via the Auth0 Dashboard:\n\n1.  Navigate to [Auth0 Dashboard > Applications](https://manage.auth0.com/#/applications), and select the application for which you want to configure organizations.\n    \n2.  Select the **Organizations** view and configure the appropriate settings:\n    \n    | **Field** | **Description** | **API Mapping** |\n    | --- | --- | --- |\n    | **Type of Users** | Determines which category of users can log in to your application.<br><br>Options include:<br><br>*   **Individuals**: Users can sign up with a personal account and log directly in to your application. Individual users cannot log in using an Organization.<br>*   **Business Users**: Users must be a member of an Organization in order to log in. When selected, you must either provide an Organization when you redirect users to the `/authorize` endpoint or set your Login Flow to Prompt for Organization.<br>*   **Both**: Users can log in as an Organization member or sign up with a personal account. | **Type of Users** maps to `organization_usage`<br><br>Options:<br><br>*   **Individuals** maps to `deny`<br>*   **Business Users** maps to `require`<br>*   **Both** maps to `allow` |\n    | **Login Flow** | Determines the initial login prompt presented to users when they access your application. You can only configure this field if Type of Users is set to Businsess Users or Both.<br><br>Options include:<br><br>*   **Prompt for Credentials**: Users are first asked to provide their login credentials. After logging in, users can select their Organization.<br>*   **Prompt for Organization**: Users are first asked to select their Organization. Then, they can provide their credentials to log in. You can only use this option if you set Type of Users to Business Users.<br>*   **No Prompt**: Auth0 does not dictate which login prompt is given to users. Instead, your application is responsible for sending the required parameters to Auth0 to display the appropriate prompt. | **Login Flow** maps to `organization_require_behavior`<br><br>Options:<br><br>*   **Prompt for Credentials** maps to `post_login_prompt`<br>*   **Prompt for Organization** maps to `pre_login_prompt`<br>*   **No Prompt** maps to `no_prompt` |\n    \n3.  Select **Save changes**.\n    \n\n## Management API\n\nMake a `PATCH` call to the [Update a Client endpoint](https://auth0.com/docs/api/management/v2#!/Clients/patch_clients_by_id). Be sure to replace `client_id`, `mgmt_api_access_token`, `organization_usage`, and `organization_require_behavior` placeholder values with your client ID, Management API Access Token, organization use option, and organization behavior option, respectively.\n\n*   [cURL](#4af1448a89374d8aad58164b823b4892_shell)\n*   [C#](#4af1448a89374d8aad58164b823b4892_csharp)\n*   [Go](#4af1448a89374d8aad58164b823b4892_go)\n*   [Java](#4af1448a89374d8aad58164b823b4892_java)\n*   [Node.JS](#4af1448a89374d8aad58164b823b4892_node)\n*   [Obj-C](#4af1448a89374d8aad58164b823b4892_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/clients/CLIENT_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"organization_usage\": \"ORG_USAGE\", \"organization_require_behavior\": \"ORG_REQUIRE_BEHAVIOR\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients/CLIENT_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"organization_usage\\\": \\\"ORG_USAGE\\\", \\\"organization_require_behavior\\\": \\\"ORG_REQUIRE_BEHAVIOR\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients/CLIENT_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"organization_usage\\\": \\\"ORG_USAGE\\\", \\\"organization_require_behavior\\\": \\\"ORG_REQUIRE_BEHAVIOR\\\" }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/clients/CLIENT_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"organization_usage\\\": \\\"ORG_USAGE\\\", \\\"organization_require_behavior\\\": \\\"ORG_REQUIRE_BEHAVIOR\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/clients/CLIENT_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    organization_usage: 'ORG_USAGE',\n    organization_require_behavior: 'ORG_REQUIRE_BEHAVIOR'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"organization_usage\": @\"ORG_USAGE\",\n                              @\"organization_require_behavior\": @\"ORG_REQUIRE_BEHAVIOR\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients/CLIENT_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients/CLIENT_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"organization_usage\\\": \\\"ORG_USAGE\\\", \\\"organization_require_behavior\\\": \\\"ORG_REQUIRE_BEHAVIOR\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"organization_usage\\\": \\\"ORG_USAGE\\\", \\\"organization_require_behavior\\\": \\\"ORG_REQUIRE_BEHAVIOR\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/clients/CLIENT_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients/CLIENT_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"organization_usage\\\": \\\"ORG_USAGE\\\", \\\"organization_require_behavior\\\": \\\"ORG_REQUIRE_BEHAVIOR\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"organization_usage\": \"ORG_USAGE\",\n  \"organization_require_behavior\": \"ORG_REQUIRE_BEHAVIOR\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients/CLIENT_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `CLIENT_ID` | ID of the application for which you want to add organization behavior. |\n| `MGMT_API_ACCESS_TOKEN` | [Access Tokens for the Management API](https://auth0.com/docs/tokens/management-api-access-tokens) with the scope `update:clients`. |\n| `ORGANIZATION_USAGE` | Dictates whether your application can support users logging into an organization. Options include:<br><br>*   `deny`: (Default) Users cannot log in using an organization.<br>*   `allow`: Users can log in with or without an Organization. When selected, you must provide an organization when you redirect users to the `/authorize` endpoint.<br>*   `require`: Users must log in using an organization. When selected, you must either provide an organization when you redirect users to the `/authorize` endpoint or set `organization_require_behavior` to `pre_login_prompt` to allow users to choose an organization before they log in. |\n| `ORGANIZATION_REQUIRE_BEHAVIOR` | Determines the Login Flow presented to users accessing your application. Only applicable when `organization_usage` is set to `require` or `allow`.<br><br>Options include:<br><br>*   `no_prompt`: (Default) Display no prompt. Requests without a valid organization parameter are rejected.<br>*   `pre_login_prompt`: Prompt users to select an Organization before they can log in. You can only use this option if `organization_usage` is set to `require`.<br>*   `post_login_prompt`: Prompt users to log in with their credentials. After they log in, prompt users to select their Organization. |\n\n### Response status codes\n\nPossible response status codes are as follows:\n\n| Status code | Error code | Message | Cause |\n| --- | --- | --- | --- |\n| `200` |     | Client successfully updated. |     |\n| `400` | `invalid_uri` | Invalid request URI. The message will vary depending on the cause. | The path is not valid. |\n| `400` | `invalid_body` | Invalid request body. The message will vary depending on the cause. | The request payload is not valid. |\n| `401` |     | Invalid token. |     |\n| `401` |     | Client is not global. |     |\n| `401` |     | Invalid signature received for JSON Web Token validation. |     |\n| `403` | `insufficient_scope` | Insufficient scope; expected any of: `update:clients`. | Tried to read/write a field that is not allowed with provided bearer token scopes. |\n| `403` | `insufficient_scope` | Some fields cannot be updated with the permissions granted by the bearer token scopes. The message will vary depending on the fields and the scopes. | Tried to read/write a field that is not allowed with provided bearer token scopes. |\n| `403` | `operation_not_supported` | The account is not allowed to perform this operation. | The account is not allowed to perform this operation. |\n| `404` | `inexistent_client` | Client not found. | Inexistent resource. Specified application does not exist. |\n| `429` |     | Too many requests. Check the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers. |     |",
  "title": "Define Organization Behavior",
  "description": "Learn to define organization behavior within applications for Auth0's Organizations feature.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/send-membership-invitations",
  "markdown": "# Send Organization Membership Invitations\n\nYou can send [organization](https://auth0.com/docs/manage-users/organizations/organizations-overview) membership invitations to users using either the Auth0 Dashboard or the Management API.\n\n## Auth0 Dashboard\n\nTo invite members via the Auth0 Dashboard:\n\n1.  Navigate to [Auth0 Dashboard > Organizations](https://manage.auth0.com/#/organizations), and select the organization for which you want to configure membership.\n    \n2.  Select the **Invitations** view, and select **Invite Members**.\n    \n3.  Select the Application to which you would like to invite the member, enter the email address of the user you would like to invite to the organization, and select **Send Invite(s)**.\n    \n\n## Management API\n\nTo invite members via the Management API: Make a `POST` call to the Create Organization Invitations endpoint. Be sure to replace `ORG_ID`, `MGMT_API_ACCESS_TOKEN`, `NAME_OF_USER`, `EMAIL_ADDRESS`, `CLIENT_ID`, `CONNECTION_ID`, `EXP_TIME`, `ROLE_ID`, and `SEND_INVITATION_EMAIL_OPTION` placeholder values with your organization ID, Management API Access Token, name of invited user, email address of invited user, client ID, connection ID, expiration time, and role IDs, respectively.\n\n```\n{\n  \"method\": \"POST\",\n  \"url\": \"https://YOUR_AUTH0_DOMAIN/api/v2/organizations/ORG_ID/invitations\",\n\"headers\": [\n  { \"name\": \"Content-Type\", \"value\": \"application/json\" },\n  { \"name\": \"Authorization\", \"value\": \"Bearer MGMT_API_ACCESS_TOKEN\" },\n  { \"name\": \"Cache-Control\", \"value\": \"no-cache\" }\n  ],\n  \"postData\": {\n  \"mimeType\": \"application/json\",\n  \"text\" : \"{ \\\"inviter\\\": { \\\"name\\\": \\\"NAME_OF_USER\\\"}, \\\"invitee\\\": { \\\"email\\\": \\\"EMAIL_ADDRESS\\\" }, \\\"client_id\\\": \\\"CLIENT_ID\\\", \\\"connection_id\\\": \\\"CONNECTION_ID\\\", \\\"ttl_sec\\\": \\\"EXP_TIME\\\", \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ], \\\"send_invitation_email\\\": \\\"SEND_EMAIL_INVITATION_OPTION\\\" }\"\n  }\n}\n```\n\n| Value | Description |\n| --- | --- |\n| `ORG_ID` | ID of the organization for which you want to assign membership. |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/tokens/management-api-access-tokens) with the scope `create:organization_invitations`. |\n| `NAME_OF_USER` | Name of the user to whom you want to send the invitation. Maximum of 300 characters. |\n| `EMAIL_ADDRESS` | Email address to which the invitation should be sent. |\n| `CLIENT_ID` | ID of the application to which the invited user should authenticate. |\n| `CONNECTION_ID` | ID of the connection through which the invited member should authenticate. |\n| `EXP_TIME` | Number of seconds before the invitation expires. If unspecified or set to 0, defaults to 604800 seconds (7 days). Maximum of 2592000 seconds (30 days). |\n| `ROLE_ID` | ID of the role(s) you want to assign to the invited user for the specified organization. Maximum of 50 roles per member. |\n| `SEND_INVITATION_EMAIL_OPTION` | Indicates whether Auth0 should send the email. Values are `true` or `false`. When set to `false`, Auth0 will generate an invitation URL that you can deliver to users through your own email service. |\n\n### Response status codes\n\nPossible response status codes are as follows:\n\n| Status code | Error code | Message | Cause |\n| --- | --- | --- | --- |\n| `200` |     | Invitation successfully created. |     |\n| `400` | `invalid_body` | The specified client\\_id does not exist. | The request payload is not valid. |\n| `400` | `invalid_body` | The specified connection does not exist. | The request payload is not valid. |\n| `400` | `invalid_body` | Passwordless connections are not supported. | The request payload is not valid. |\n| `400` | `invalid_body` | A default login route is required to generate the invitation url. To learn more, see [Configure default login routes](https://auth0.com/docs/universal-login/configure-default-login-routes). | The request payload is not valid. |\n| `400` | `invalid_body` | One or more of the specified roles do not exist: role1, role2'. | The request payload is not valid. |\n| `400` | `invalid_body` | Invalid request body. The message will vary depending on the cause. | The request payload is not valid. |\n| `400` | `invalid_query_string` | Invalid request query string. The message will vary depending on the cause. | The query string is not valid. |\n| `401` |     | Invalid token. |     |\n| `401` |     | Invalid signature received for JSON Web Token validation. |     |\n| `401` |     | Client is not global. |     |\n| `403` | `insufficient_scope` | Insufficient scope; expected any of: `create:organization_invitations`. | Tried to read/write a field that is not allowed with provided bearer token scopes. |\n| `404` |     | No organization found by that id. |     |\n| `429` |     | Too many requests. Check the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers. |     |",
  "title": "Send Organization Membership Invitations",
  "description": "Learn how to send membership invitations for Organizations using the Auth0 Dashboard or Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/grant-just-in-time-membership",
  "markdown": "# Grant Just-In-Time Membership to an Organization Connection\n\nGranting just-in-time membership allows users that log in via an enabled connection to automatically be given membership to an [organization](https://auth0.com/docs/manage-users/organizations/organizations-overview).\n\nTo automatically grant membership when users log in to an organization, you must first [configure and enable a connection](https://auth0.com/docs/manage-users/organizations/configure-organizations/enable-connections) for the organization. While enabling your connection, select **Enable Auto-Membership** to allow all users logging in with the connection to be automatically added as members of this organization.",
  "title": "Grant Just-In-Time Membership to an Organization Connection",
  "description": "Learn how to grant Just-in-Time (JIT) membership to organizations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/assign-members",
  "markdown": "# Assign Members to an Organization\n\n```\ncurl --request POST \\\n  --url https://your_auth0_domain/api/v2/organizations/ORG_ID/members \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"members\": [ \"USER_ID\", \"USER_ID\", \"USER_ID\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://your_auth0_domain/api/v2/organizations/ORG_ID/members\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://your_auth0_domain/api/v2/organizations/ORG_ID/members\"\n\n\tpayload := strings.NewReader(\"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://your_auth0_domain/api/v2/organizations/ORG_ID/members\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://your_auth0_domain/api/v2/organizations/ORG_ID/members',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {members: ['USER_ID', 'USER_ID', 'USER_ID']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"members\": @[ @\"USER_ID\", @\"USER_ID\", @\"USER_ID\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://your_auth0_domain/api/v2/organizations/ORG_ID/members\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://your_auth0_domain/api/v2/organizations/ORG_ID/members\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"your_auth0_domain\")\n\npayload = \"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/api/v2/organizations/ORG_ID/members\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://your_auth0_domain/api/v2/organizations/ORG_ID/members\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"members\": [\"USER_ID\", \"USER_ID\", \"USER_ID\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://your_auth0_domain/api/v2/organizations/ORG_ID/members\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Assign Members to an Organization",
  "description": "Learn how to assign members directly to an Organization using either the Auth0 Dashboard or Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/remove-members",
  "markdown": "# Remove Members From Organizations\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/organizations/ORG_ID/members' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --data '{ \"members\": [ \"USER_ID\", \"USER_ID\", \"USER_ID\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"undefined\", \"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations/ORG_ID/members\"\n\n\tpayload := strings.NewReader(\"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"DELETE\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/organizations/ORG_ID/members',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN', 'cache-control': 'no-cache'},\n  data: {members: ['USER_ID', 'USER_ID', 'USER_ID']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"members\": @[ @\"USER_ID\", @\"USER_ID\", @\"USER_ID\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations/ORG_ID/members\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations/ORG_ID/members\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_POSTFIELDS => \"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/organizations/ORG_ID/members\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"members\\\": [ \\\"USER_ID\\\", \\\"USER_ID\\\", \\\"USER_ID\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"members\": [\"USER_ID\", \"USER_ID\", \"USER_ID\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations/ORG_ID/members\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Remove Members From Organizations",
  "description": "Learn how to remove members from Organizations directly using the Auth0 Dashboard or Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/remove-member-roles",
  "markdown": "# Remove Roles from Organization Members\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --data '{ \"roles\": [ \"ROLE_ID\", \"ROLE_ID\", \"ROLE_ID\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"undefined\", \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\"\n\n\tpayload := strings.NewReader(\"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"DELETE\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN', 'cache-control': 'no-cache'},\n  data: {roles: ['ROLE_ID', 'ROLE_ID', 'ROLE_ID']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"roles\": @[ @\"ROLE_ID\", @\"ROLE_ID\", @\"ROLE_ID\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_POSTFIELDS => \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"roles\": [\"ROLE_ID\", \"ROLE_ID\", \"ROLE_ID\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Remove Roles from Organization Members",
  "description": "Learn how to remove roles from Organization members using the Auth0 Dashboard or Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/search-for-organizations",
  "markdown": "# Search for Organizations\n\nWhen working with [organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview), you may need to search for organizations by name or display name. You can do this using the Auth0 Dashboard.\n\n![Auth0 Dashboard - Organization Search Options - Name and Display Name](https://images.ctfassets.net/cdy7uua7fh8z/5CeeKLjPGxjTqy682lbnyj/7aa9ea469b3825f2ffac4b491262e6ad/dashboard-organizations-search-options.png)\n\nResults will be returned if the entered text is found within the field being searched. For example, if there is an Organization named \"Big Holdings Co\" and the search term provided is `hold` or `ings`, the Big Holdings organization will be returned.\n\n![Auth0 Dashboard - Search Organizations](https://images.ctfassets.net/cdy7uua7fh8z/73GgvbfKT5zgTVCHNQYMqh/9687c90727da8c631082a25b946ab183/dashboard-organizations-search.png)\n\nSearch for Organizations returns a maximum of 50 results. If the desired result isn’t located, use a more specific search term.\n\nNote that searching for Organizations is eventually consistent, meaning that recently created or modified Organizations entities might not show up immediately in search results, but the results will eventually be accurate.",
  "title": "Search for Organizations",
  "description": "Learn how to search for Organizations using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-organizations",
  "markdown": "# Retrieve Organizations\n\nWhen working with [organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview) programmatically, you may need to retrieve either a list of all organizations or organizations individually by name or ID.\n\n## Retrieve tenant organizations\n\nYou can retrieve all organizations for a tenant via the Management API.\n\nMake a `GET` call to the `Get Organizations` endpoint. Be sure to replace the `MGMT_API_ACCESS_TOKEN` placeholder value with your Management API Access Token.\n\n*   [cURL](#3b5988849bc94a50be9f1282c519d3d7_shell)\n*   [C#](#3b5988849bc94a50be9f1282c519d3d7_csharp)\n*   [Go](#3b5988849bc94a50be9f1282c519d3d7_go)\n*   [Java](#3b5988849bc94a50be9f1282c519d3d7_java)\n*   [Node.JS](#3b5988849bc94a50be9f1282c519d3d7_node)\n*   [Obj-C](#3b5988849bc94a50be9f1282c519d3d7_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/organizations' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/organizations\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/organizations',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/organizations\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Response status codes\n\nPossible response status codes are as follows:\n\n| Status code | Error code | Message | Cause |\n| --- | --- | --- | --- |\n| `200` |     | Organizations successfully retrieved. |     |\n| `400` | `invalid_paging` | Requesting page exceeds the allowed maximum of 1000 records. | API has been limited to only return up to 1000 records. |\n| `400` | `invalid_query_string` | Invalid request query string. The message will vary depending on the cause. | The query string is not valid. |\n| `401` |     | Invalid token. |     |\n| `401` |     | Invalid signature received for JSON Web Token validation. |     |\n| `401` |     | Client is not global. |     |\n| `403` | `insufficient_scope` | Insufficient scope; expected any of: `read:organizations`. | Tried to read/write a field that is not allowed with provided bearer token scopes. |\n| `429` |     | Too many requests. Check the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers. |     |\n\n## Retrieve organization by ID\n\nYou can retrieve an organization by its ID through the Management API.\n\nMake a `GET` call to the `Get Organization` endpoint. Be sure to replace the `ORG_ID` and `MGMT_API_ACCESS_TOKEN` placeholder values with your organization ID and Management API Access Token, respectively.\n\n*   [cURL](#5e05b3d45e4b454d97e09c634378df80_shell)\n*   [C#](#5e05b3d45e4b454d97e09c634378df80_csharp)\n*   [Go](#5e05b3d45e4b454d97e09c634378df80_go)\n*   [Java](#5e05b3d45e4b454d97e09c634378df80_java)\n*   [Node.JS](#5e05b3d45e4b454d97e09c634378df80_node)\n*   [Obj-C](#5e05b3d45e4b454d97e09c634378df80_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/organizations/ORG_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations/ORG_ID\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations/ORG_ID\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/organizations/ORG_ID\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/organizations/ORG_ID',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations/ORG_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations/ORG_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/organizations/ORG_ID\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations/ORG_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations/ORG_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Response status codes\n\nPossible response status codes are as follows:\n\n| Status code | Error code | Message | Cause |\n| --- | --- | --- | --- |\n| `200` |     | Organization successfully retrieved. |     |\n| `400` | `invalid_query_string` | Invalid request query string. The message will vary depending on the cause. | The query string is not valid. |\n| `401` |     | Invalid token. |     |\n| `401` |     | Invalid signature received for JSON Web Token validation. |     |\n| `401` |     | Client is not global. |     |\n| `403` | `insufficient_scope` | Insufficient scope; expected any of: `read:organizations`. | Tried to read/write a field that is not allowed with provided bearer token scopes. |\n| `429` |     | Too many requests. Check the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers. |     |\n\n## Retrieve organization by name\n\nYou can retrieve an organization by its name through the Management API.\n\nMake a `GET` call to the `Get Organization by Name` endpoint. Be sure to replace the `ORG_NAME` and `MGMT_API_ACCESS_TOKEN` placeholder values with your organization ID and Management API Access Token, respectively.\n\n*   [cURL](#1abfd1e0004249bfa650004394d76122_shell)\n*   [C#](#1abfd1e0004249bfa650004394d76122_csharp)\n*   [Go](#1abfd1e0004249bfa650004394d76122_go)\n*   [Java](#1abfd1e0004249bfa650004394d76122_java)\n*   [Node.JS](#1abfd1e0004249bfa650004394d76122_node)\n*   [Obj-C](#1abfd1e0004249bfa650004394d76122_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/organizations/name/ORG_NAME' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations/name/ORG_NAME\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations/name/ORG_NAME\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/organizations/name/ORG_NAME\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/organizations/name/ORG_NAME',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations/name/ORG_NAME\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations/name/ORG_NAME\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/organizations/name/ORG_NAME\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations/name/ORG_NAME\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations/name/ORG_NAME\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `ORG_ NAME` | Name of the organization you want to retrieve. Maximum length of 50 characters. |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/tokens/management-api-access-tokens) with the scope `read:organizations`. |\n\n### Response status codes\n\nPossible response status codes are as follows:\n\n| Status code | Error code | Message | Cause |\n| --- | --- | --- | --- |\n| `200` |     | Organizations successfully retrieved. |     |\n| `400` | `invalid_query_string` | Invalid request query string. The message will vary depending on the cause. | The query string is not valid. |\n| `401` |     | Invalid token. |     |\n| `401` |     | Invalid signature received for JSON Web Token validation. |     |\n| `401` |     | Client is not global. |     |\n| `403` | `insufficient_scope` | Insufficient scope; expected any of: `read:organizations`. | Tried to read/write a field that is not allowed with provided bearer token scopes. |\n| `429` |     | Too many requests. Check the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers. |     |",
  "title": "Retrieve Organizations",
  "description": "Learn how to retrieve Organizations using the Auth0 Dashboard and Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-connections",
  "markdown": "# Retrieve Organization Connections\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations/ORG_ID/enabled_connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Retrieve Organization Connections",
  "description": "Learn how to retrieve Organization connections using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-members",
  "markdown": "# Retrieve Organization Members\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/organizations/ORG_ID/members' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations/ORG_ID/members\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/organizations/ORG_ID/members',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations/ORG_ID/members\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations/ORG_ID/members\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/organizations/ORG_ID/members\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations/ORG_ID/members\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Retrieve Organization Members",
  "description": "Learn how to retrieve Organization members using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/search-organization-members",
  "markdown": "# Search Organization Members\n\nIn addition to [listing organization members](https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-members), you can use [User Search](https://auth0.com/docs/manage-users/user-search) to find users filtered by organization membership by using the `organization_id` parameter in a search.\n\nFor example, below is a filter for users that have an `acme.com` email domain but are not members of the Acme organization:\n\n`email.domain:\"acme.com\" AND NOT organization_id:\"ACME_ORG_ID\"`\n\nThe following finds all users that are in the Acme organization and log in with a specific database connection.\n\n`organization_id:\"ACME_ORG_ID\" AND identities.connection:\"my-db-connection-name\"`\n\nThe example below finds users whose email addresses start with jane and are members of the Acme organization.\n\n`organization_id:\"ACME_ORG_ID\" AND email:jane*`\n\nSee [User Search](https://auth0.com/docs/manage-users/user-search) for more details.",
  "title": "Search Organization Members",
  "description": "How to use User Search to find members of an Organization",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-user-membership",
  "markdown": "# Retrieve User's Organization Memberships\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID/organizations' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID/organizations\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID/organizations\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users/USER_ID/organizations\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID/organizations',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID/organizations\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID/organizations\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users/USER_ID/organizations\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID/organizations\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID/organizations\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Retrieve User's Organization Memberships",
  "description": "Learn how to retrieve Organization memberships for a user using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-member-roles",
  "markdown": "# Retrieve Member Roles for an Organization\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/organizations/ORG_ID/members/USER_ID/roles\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Retrieve Member Roles for an Organization",
  "description": "Learn how to retrieve member roles for an Organization using the Auth0 Dashboard and Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/login/flows/authorization-code-flow",
  "markdown": "# Authorization Code Flow\n\nThe Authorization Code Flow (defined in [OAuth 2.0 RFC 6749, section 4.1](https://tools.ietf.org/html/rfc6749#section-4.1)), involves exchanging an authorization code for a token.\n\nThis flow can only be used for confidential applications (such as Regular Web Applications) because the application's authentication methods are included in the exchange and must be kept secure.\n\n![Auth - Auth code flow- Authorization sequence diagram](https://images.ctfassets.net/cdy7uua7fh8z/7mWk9No612EefC8uBidCqr/821eb60b0aa953b0d8e4afe897228844/Auth-code-flow-diagram.png)\n\n1.  User selects **Login** within application.\n    \n2.  Auth0's SDK redirects user to Auth0 Authorization Server ([`/authorize` endpoint](https://auth0.com/docs/api/authentication#authorization-code-grant)).\n    \n3.  Auth0 Authorization Server redirects user to login and authorization prompt.\n    \n4.  User authenticates using one of the configured login options, and may see a consent prompt listing the permissions Auth0 will give to the application.\n    \n5.  Auth0 Authorization Server redirects user back to application with single-use authorization code.\n    \n6.  Auth0's SDK sends authorization code, application's client ID, and application's credentials, such as client secret or Private Key JWT, to Auth0 Authorization Server ([`**/oauth/token**` endpoint](https://auth0.com/docs/api/authentication?http#authorization-code-flow43)).\n    \n7.  Auth0 Authorization Server verifies authorization code, application's client ID, and application's credentials.\n    \n8.  Auth0 Authorization Server responds with an ID token and access token (and optionally, a refresh token).\n    \n9.  Application can use the access token to call an API to access information about the user.\n    \n10.  API responds with requested data.\n    \n\n## How to implement Authorization Code Flow\n\nThe easiest way to implement the Authorization Code Flow is to follow our [Regular Web App Quickstarts](https://auth0.com/docs/quickstart/webapp).\n\nAlternatively, you can use the Authentication API to implement the Authorization Code Flow. For more information, read [Add Login Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow) or [Call Your API Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow).\n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)\n*   [Auth0 Hooks](https://auth0.com/docs/customize/hooks)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)",
  "title": "Authorization Code Flow",
  "description": "Learn how the Authorization Code flow works and why you should use it for regular web apps.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page",
  "markdown": "# Customize Classic Password Reset Page\n\n#### Resetting a password?\n\nThis page describes how you can customize a Classic Login password reset page.\n\nIf you need assistance resetting a password, review the following documentation instead:\n\n*   For tenant administrators resetting other users' passwords: [Change Users' Passwords](https://auth0.com/docs/authenticate/database-connections/password-change)\n    \n*   For individuals resetting their own passwords: [Reset Auth0 Account Password](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords)\n    \n\nIf you are using Classic Login, the password reset page provides your users with a way to change their passwords if they cannot log in. Within the password reset page, Auth0 handles all required functionality, including:\n\n*   Hosting the page itself\n    \n*   Redirecting the user wanting to reset their password as necessary\n    \n*   Ensuring the user's password meets your defined requirements\n    \n*   Automatically redirecting the user after they reset their password\n    \n\nTo create a consistently branded experience throughout the login flow, you can customize how the password reset prompt displays to users. You can also update the password reset page to display certain personal information if appropriate.\n\n## Enable password reset page customization\n\nThe password reset page is enabled for all Auth0 users by default and does not require customization. However, you can enable [advanced customization](https://auth0.com/docs/customize/login-pages/classic-login/customization-classic) if you wish to update the branding and other elements of the password reset page.\n\nTo enable advanced customization from the Auth0 Dashboard:\n\n1.  Navigate to [Branding > Universal Login > Password Reset tab](https://manage.auth0.com/#/password_reset).\n    \n2.  Enable the **Customize Password Reset Page** toggle.\n    \n\nIn the code editor below the toggle, you can now directly modify the page template.\n\n![Branding Universal Login Password Reset Tab Customize Password Reset Page Toggle](https://images.ctfassets.net/cdy7uua7fh8z/5gwXwgXNWtiKZJlg3LX3nn/0decad4895539437dbe4ecabe55dcdde/dashboard-branding-universal-login-password-reset.png)\n\n## Edit password reset page\n\nAfter enabling customization for the password reset page, you can use the built-in code editor to modify its HTML, style the page using CSS, and change the JavaScript used to retrieve and display custom variables. Ensure you select **Save Changes** below the code editor to save your updates.\n\n### Display custom information on the Password Reset Page\n\nYou can display personalized information on the password reset page. This is done by editing the embedded JavaScript using the password reset page editor:\n\n```\nnew Auth0ChangePassword({\n      container:         \"change-password-widget-container\",     // required\n      email:             \"{{email}}\",                            // DO NOT CHANGE THIS\n      csrf_token:        '{{csrf_token}}',                       // DO NOT CHANGE THIS\n      ticket:            '{{ticket}}',                           // DO NOT CHANGE THIS\n      password_policy:   '{{password_policy}}',                  // DO NOT CHANGE THIS\n      theme: {\n        icon: \"{{tenant.picture_url | default: '//cdn.auth0.com/styleguide/1.0.0/img/badge.png'}}\",\n        primaryColor: \"#ea5323\"\n      },\n      dict: {\n        // passwordPlaceholder: \"your new password\",\n        // passwordConfirmationPlaceholder: \"confirm your new password\",\n        // passwordConfirmationMatchError: \"Please ensure the password and the confirmation are the same.\",\n        // passwordStrength: {\n        //   containsAtLeast: \"Contain at least %d of the following %d types of characters:\",\n        //   identicalChars: \"No more than %d identical characters in a row (such as, \\\"%s\\\" not allowed)\",\n        //   nonEmpty: \"Non-empty password required\",\n        //   numbers: \"Numbers (such as 0-9)\",\n        //   lengthAtLeast: \"At least %d characters in length\",\n        //   lowerCase: \"Lower case letters (a-z)\",\n        //   shouldContain: \"Should contain:\",\n        //   specialCharacters: \"Special characters (such as !@#$%^&*)\",\n        //   upperCase: \"Upper case letters (A-Z)\"\n        // },\n        // successMessage: \"Your password has been reset successfully.\",\n        // configurationError: \"An error occurred. There appears to be a misconfiguration in the form.\",\n        // networkError: \"The server cannot be reached, there is a problem with the network.\",\n        // timeoutError: \"The server cannot be reached, please try again.\",\n        // serverError: \"There was an error processing the password reset.\",\n        // headerText: \"Enter a new password for<br />{email}\",\n        // title: \"Change Password\",\n        // weakPasswordError: \"Password is too weak.\"\n        // passwordHistoryError: \"Password has previously been used.\"\n      }\n    });\n```\n\nFor example, the sample template snippet below shows the variable `tenant.picture_url`. This variable returns the Logo URL value defined in [Dashboard > Settings](https://manage.auth0.com/#/tenant).\n\n```\nnew Auth0ChangePassword({\n      theme: {\n        icon: \"{{tenant.picture_url | default: '//cdn.auth0.com/styleguide/1.0.0/img/badge.png'}}\",\n      }\n    });\n```\n\nAuth0 retrieves the logo at the URL and displays it on the password reset prompt. If Auth0 can't resolve the URL, it'll display the default image.\n\n#### Custom variables\n\nYou can use the following custom variables to display personalized information on the password reset page:\n\n| Variable | Description |\n| --- | --- |\n| `email` | The email address of the user requesting the password change |\n| `ticket` | The ticket representing the given password reset request |\n| `csrf_token` | Token used to prevent CSRF activity |\n| `tenant.name` | The name associated with your Auth0 tenant |\n| `tenant.friendly_name` | The name displayed for your Auth0 tenant |\n| `tenant.picture_url` | The URL leading to the logo representing you in Auth0 |\n| `tenant.support_email` | The support email address for your company displayed to your Auth0 users |\n| `tenant.support_url` | The support URL for your company displayed to your Auth0 users |\n| `lang` | The user's language |\n| `password_policy` | The active connection's security policy. You can see what this is using `https://manage.auth0.com/#/connections/database/con_YOUR-CONNECTION-ID/security`. Be sure to provide your connection ID in the URL.) |\n| `password_complexity_options` | Object containing settings for the password complexity requirements |\n| `min_length` | The minimum length required for newly-created passwords. Can range from 1 to 128 characters in length |\n\n**Notes:**\n\n*   You can set/check the values for your tenant variables in the Settings area in [Dashboard > Settings](https://manage.auth0.com/#/tenant).\n    \n*   You cannot make customizations conditional based on the Application ID (`client_id`).\n    \n\n#### Custom error messages\n\nIf your custom database script returns a custom error, you can map an error description using the `dict` property:\n\n```\nnew Auth0ChangePassword({\n  // ...other options\n  dict: {\n    yourCustomError: 'This is a custom error message'\n  }\n});\n\nfunction changePassword(email, newPassword, callback) {\n  callback(new ValidationError('yourCustomError'));\n}\n```\n\n## Update password reset prompt\n\nIf you do not enable customization for the password reset page, Auth0 will handle updates necessary for the script, including changes to the version number of the included password reset prompt.\n\n**When you enable customization for the password reset page**, you assume responsibility for updating and maintaining the script. This includes updating the version number for the password reset prompt. With customization enabled, Auth0 cannot update your script automatically without potentially interfering with the changes you've made.\n\nThe current version of the password reset prompt is 1.5.5. Use this link to call the latest version, including future minor version updates:\n\n`https://cdn.auth0.com/js/change-password-1.5.min.js`\n\n## Revert changes\n\nTo revert the password reset page to an earlier design, you can:\n\n*   Revert to the last saved template by clicking **Reset to Last.**\n    \n*   Revert to the default template provided by Auth0 by clicking **Reset to Default**.\n    \n\n## Learn more\n\n*   [Customize Classic Login Pages](https://auth0.com/docs/customize/login-pages/classic-login/customization-classic)\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)\n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages)\n*   [Self Change Password Errors](https://auth0.com/docs/troubleshoot/authentication-issues/self-change-password-errors)",
  "title": "Customize Classic Password Reset Page",
  "description": "Learn how to customize a Classic Login password reset page.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/public-cloud-service-endpoints",
  "markdown": "# Auth0 Public Cloud Service Endpoints\n\nThe following endpoints are used by Auth0 public cloud service:\n\n## United States Region\n\n*   https://manage.auth0.com\n    \n*   https://auth0.com\n    \n*   https://auth0.auth0.com\n    \n*   https://login.us.auth0.com\n    \n*   https://cdn.us.auth0.com\n    \n*   https://{yourAccount}.us.auth0.com\n    \n*   https://{yourAccount}.guardian.us.auth0.com\n    \n\n## Europe, Australia, and Japan Regions\n\n*   https://manage.auth0.com\n    \n*   https://auth0.com\n    \n*   https://auth0.auth0.com\n    \n*   https://login.\\[eu|au|jp\\].auth0.com\n    \n*   https://cdn.\\[eu|au|jp\\].auth0.com\n    \n*   https://{yourAccount}.\\[eu|au|jp\\].auth0.com\n    \n*   https://{yourAccount}.guardian.\\[eu|au|jp\\].auth0.com\n    \n\n## Learn more\n\n*   [Auth0 IP Addresses for Allow Lists](https://auth0.com/docs/secure/security-guidance/data-security/allowlist)",
  "title": "Auth0 Public Cloud Service Endpoints",
  "description": "Lists all the endpoints used by Auth0 public cloud service.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/billing-policy",
  "markdown": "# Billing Policy\n\nThe following policy governs requests for billing mechanisms within the Auth0 Dashboard.\n\n## Change billing email address\n\nIt is possible to change the billing email address, but for security reasons, the request should be performed by a Tenant Administrator by filing a new ticket through our [Support Center](https://support.auth0.com/). A member of our support team will then contact you in that same ticket with steps on how the request will proceed.\n\nIf you are not a Tenant Administrator, we will not process a billing change request.\n\nIf you created tenants using the Heroku hosting platform, you must change the billing email address (or any other billing details) on that platform. We cannot edit any billing information on that service.\n\n## Credit card issues\n\nTo determine the reason for the failure, you must contact your credit card company. Billing issues can be triggered by a credit card reaching the limit or simply being rejected by the bank.\n\nIf your credit card charge fails, we automatically retry to charge it up to 4 times. If you fix the issue before the fourth failure (by entering new card information or by solving the issue with the bank), then the charge will go through and everything will work as expected. However, if the problem is not fixed prior to the fourth failure, all past due invoices will be manually initiated by Auth0. This means that you may be charged on an unexpected date.\n\n## Cancel subscription\n\nTo cancel your subscription, downgrade it to the Free plan in the Auth0 Dashboard. To learn more, read [Downgrade or Cancel Subscriptions](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/downgrade-or-cancel-subscriptions).\n\n## Credits and refunds\n\nIf you cancel your subscription, you may be eligible for a credit or refund depending on the circumstances.\n\n### Unused tenants\n\nTenants with minimal login transaction history may be eligible for a credit or refund. If we consider the usage of the tenant to not be minimal, Auth0 reserves the right to deny the credit or refund request.\n\nAuth0 does not provide credits or refunds when a tenant on a paid plan is downgraded to another paid plan with fewer features.\n\n### Unneeded self-service plans\n\nTenants with no recorded login transactions may be eligible for a credit or refund for any unused portion of the subscription within the last three (3) months.\n\n### Request a credit or refund\n\nYou can request a credit or refund by contacting Okta Accounts Receivable at `ar@okta.com` and providing the following information:\n\n*   Subscription plan that your tenant was on before downgrade or cancellation.\n    \n*   Date of downgrade or cancellation.\n    \n*   Brief description of reason for downgrade or cancellation.\n    \n\nRequests must be submitted by a Tenant Administrator and are subject to evaluation and verification by Okta.\n\n## Invoices\n\n### Account-based\n\nIf you are using [Auth0 Teams](https://auth0.com/docs/get-started/auth0-teams), your subscriptions and invoices are managed on the account level.\n\nYou can view invoices in the Auth0 Dashboard:\n\n1.  Go to your [Team dashboard](https://auth0.com/docs/get-started/auth0-teams/tenant-management), and then select **Settings**.\n    \n2.  Switch to the **Payment & Billing** view.\n    \n3.  Locate the **Payment History** section.\n    \n4.  Select an invoice from the list.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/1O8lnFYlhsij9CPop0rQTK/069f34f3a3f5da418f3512275c7c0b41/account-invoice.png)\n\n### Tenant-based\n\nYou can view invoices in the Auth0 Dashboard:\n\n1.  Go to [Tenant Settings](https://manage.auth0.com/#/tenant).\n    \n2.  Switch to the **Payment & Billing** view.\n    \n3.  Locate the **Payment History** section.\n    \n4.  Select an invoice from the list.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/4mw2SNUXwrCe9EoHgpdafI/d7df101ff7d8e050e4322d1e522eb65f/tenant-invoice__1_.png)\n\n## Receipts\n\nYou can obtain receipts by filing a ticket through our [Support Center](https://support.auth0.com/). Please note that you have to be a Tenant admin to do this request. Auth0 sends receipts to the email entered when you created your tenant. If you want to change this setting, please let us know through our [Support Center](https://support.auth0.com/).\n\n## Taxes\n\nFor certain regions, depending on tax laws and requirements, Auth0 is required to charge tax on invoices.\n\nIf your billing address is tax-eligible, you'll see the applicable tax added to your total during checkout. You will also see the applicable tax amount on all of your Auth0 invoices and receipts.\n\n## Charges for users\n\nYou can choose a subscription plan based on your use case and the type of users who access your application. For information on subscriptions plans, see [Auth0 Pricing](https://auth0.com/pricing/).\n\nAn active user is a user that has authenticated with a username/password combination, a Passwordless connection, or any social provider during a given calendar month. Auth0 counts users on a per-tenant basis. A user who logs in to multiple applications on the same tenant counts as one user.\n\nYou can scale the number of users as needed each month.\n\n1.  In the Dashboard, go to the upper right corner, click on your tenant name, and select **Settings** from the drop-down menu.\n    \n2.  In the **Subscriptions** tab, select the option that best suits your needs.\n    \n\n## Combine billing for multiple tenants\n\nIf you have an Enterprise or upgraded Self service subscription, then use [Auth0 Teams](https://auth0.com/docs/get-started/auth0-teams) to combine billing for multiple tenants under a single subscription.\n\nTo learn more about linking multiple tenants under a single subscription, read [Link Multiple Tenants to a Single Subscription](https://auth0.com/docs/get-started/auth0-overview/create-tenants/child-tenants).\n\n## Convert tenant from free trial to any other plan\n\n1.  In the Dashboard, go to the upper right corner, click on your tenant name, and select **Settings** from the drop-down menu.\n    \n2.  In the **Subscriptions** tab, select the plan that best suits your needs.\n    \n\n## Learn more\n\n*   [Downgrade or Cancel Auth0 Subscriptions](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/downgrade-or-cancel-subscriptions)",
  "title": "Billing Policy",
  "description": "Describes the billing policy which governs requests for billing mechanisms within the Auth0 dashboard",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/data-export-and-transfer-policy",
  "markdown": "# Data Export and Transfer Policy\n\n## Export data\n\nIf you would like to export your data from Auth0 there are a several ways you can do this. Please note these tools do not export password hashes of your Auth0-hosted database users. You can still request this information by opening a [support ticket](https://support.auth0.com/). If you are opting to end your use of our service, see [Export Data](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data) for details.\n\n### Use the Import/Export Extension\n\nYou can use our [Import/Export Extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension) to export nearly all data in your Auth0 tenant.\n\n### Use the Management API\n\nIf you want to export certain sets of data programmatically, use the Management API Bulk User Export endpoint.\n\n## Transfer data\n\nAuth0 will not transfer data from one Auth0 tenant to another. This applies to both Public Cloud and Private Cloud customers.\n\nAll data in your Auth0 tenant is always under your control and is available through the Management API at any time. The only information which is not available through the API are the password hashes of your Auth0-hosted database users and private keys, for security reasons.\n\n## Learn more\n\n*   [Export Data](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data)",
  "title": "Data Export and Transfer Policy",
  "description": "Describes Auth0 policies on exporting and transferring data.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/load-testing-policy",
  "markdown": "# Load Testing Policy\n\n**Effective Date**: 4 February 2019\n\nAuth0 recognizes that customers may occasionally need to perform load tests against its production cloud service. In order to ensure a successful test and maintain a high quality of service for all customers, Auth0 has established the following guidelines. Any load testing in Auth0 must be conducted in accordance with this Policy.\n\nOnly customers who have purchased an Enterprise subscription may conduct load testing. Customers with an Enterprise subscription may request one load test (with up to 2 repeats) per year against an Auth0 production tenant. Performance and load testing are only allowed with Auth0's prior written approval. Once approved, testing can only target tenants that we have approved.\n\n## Red Change Freeze periods\n\n**Updated**: March 26, 2024\n\nLoad tests will not be allowed during Red Change Freeze periods.\n\n*   Any requested exceptions require approval of the Senior Vice President of Engineering and the Senior Vice President of Customer Success.\n    \n*   Previously approved load tests that fall within a Red Change Freeze have been rescheduled.\n    \n\n### Q1 2024\n\nRed Change Freeze periods for Q1 2024 are 2024-03-23 to 2024-03-31.\n\n### Q2 2024\n\nRed Change Freeze periods for Q2 2024 are 2024-05-11 to 2024-05-19.\n\n## Holiday load testing policy\n\n**Updated:** November 1, 2022\n\nDuring the holiday season, load testing requests must meet the following requirements:\n\n*   Be filed at least 2 weeks prior to the desired test date. 1 month or more of advance notice is preferred to ensure time for a thorough review and any required modifications.\n    \n*   Approved load tests are permitted only on Tuesdays, Wednesdays and Thursdays during off peak hours for the targeted environment.\n    \n*   If all RPS requests are determined to be safely within the RPS limits, the load test will be allowed, as long as it has been reviewed and approved by all product/platform teams owning the endpoints being tested.\n    \n    *   Tests that fall outside the safe RPS will be rejected.\n        \n*   Only one load test per customer, per environment will be scheduled in a single day.\n    \n    *   If there’s a need to run more than one test at a time, the request must be escalated and approved by a Platform Director or Vice President.\n        \n\n## Submit load testing request\n\nYou must file a load testing request via the [Support Center](https://support.auth0.com/). Under the **Issue type** field, select **I have a question regarding my Auth0 account** then select **I would like to file a Load Testing Request**.\n\nTo be considered for approval, the request must:\n\n*   Be filed at least 2 weeks prior to the desired test date; in many cases, Auth0 encourages one 1 month of advance notice to ensure time for a thorough review and any required modifications.\n    \n*   Be approved in writing before any testing is conducted.\n    \n*   Stay within our [published production rate limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy).\n    \n*   Include all information described below.\n    \n\n### Information to include in requests\n\nThe load testing request must include the following:\n\n*   A description of the test to be done\n    \n*   The name and region of the Auth0 tenant to be used during the test\n    \n*   The requested date and time of the test, including time zone\n    \n*   The requested duration of the test (2 hours maximum)\n    \n*   The platforms to be used for the test (desktop/laptop, iOS, Android, other)\n    \n*   The Auth0 features (such as rules or email) used during the test\n    \n*   The Auth0 API methods and endpoints to be used (for example `GET /api/v2/clients`)\n    \n*   The maximum requests per second for each type of request or endpoint\n    \n*   The types of Auth0 connections involved in the test\n    \n*   Whether you are using a custom domain\n    \n*   Which Auth0 Rules, if any, will execute during the test\n    \n*   Which Custom DB, if any, will be used\n    \n*   Which Auth0 Webtasks, if any, will be used\n    \n*   Whether verification, welcome or other emails will be sent\n    \n*   The peak load, specified in requests-per-second, expected for each API endpoint or Auth0 feature involved in the test\n    \n*   An explanation/justification for the peak load numbers, including the size of the target user population and realistic estimates of logins per hour\n    \n*   The ramp-up rate for the test\n    \n*   Contacts who will be available during the test and how to reach them\n    \n*   Number of unique users participating in the load test\n    \n\n### Email considerations\n\nBefore any testing, customers must:\n\n*   Configure their own email provider in Auth0\n    \n*   Receive approval from their email provider to send the expected volume of email\n    \n*   Make arrangements for bounced emails\n    \n*   Establish a mechanism for testing that emails arrived\n    \n\n## Test requirements\n\nLoad testing windows are subject to availability so advance notice is highly recommended. Once approved, load testing windows will have a scheduled start and end time not to exceed two (2) hours in duration. All testing must begin and end during this window.\n\nAuth0 strongly recommends including a brief \"ramp-up\" period to the desired load test target numbers. For example, a load test request of 100 RPS might be preceded by three five-minute periods: 5 minutes at 25 RPS, 5 minutes at 50 RPS, and 5 minutes at 75 RPS. This ramp-up period allows Auth0 and the customer to observe and compare effects at increasing RPS levels prior to peak RPS. If a ramp-up period is not possible, please indicate why.\n\n## Acceptable testing windows\n\nPublic cloud customers must arrange to conduct their load tests during the following off-peak test windows:\n\n*   **prod-au**: 9:00 - 17:00 UTC\n    \n*   **prod-eu**: 21:00 - 5:00 UTC\n    \n*   **prod-us**: 2:00 - 10:00 UTC\n    \n*   **prod-jp**: 14:00 - 22:00 UTC\n    \n\nIn very exceptional circumstances, Auth0 may grant exceptions to this rule.\n\n## Learn more\n\n*   [Auth0 Professional Services](https://auth0.com/docs/get-started/professional-services)",
  "title": "Load Testing Policy",
  "description": "Describes Auth0's Load Testing Policy.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/penetration-testing-policy",
  "markdown": "# Penetration Testing Policy\n\nIf you have a paid Auth0 subscription, you may conduct a security test of your application involving Auth0 infrastructure (e.g. `your-tenant.auth0.com`) with prior approval.\n\n## Submit penetration testing request\n\nTo conduct a security test, please notify us in advance via the [Support Center](https://support.auth0.com/). Auth0 requires at least 7 days notice prior to your test's planned start date.\n\nIf the test is isolated to your infrastructure (that is, there will be no testing of Auth0 services), you do not need to notify Auth0.\n\n### Information required\n\nPlease provide the following information in the support ticket when requesting approval for testing:\n\n*   The specific dates/times of the test and timezone. Tests are not allowed during a change freeze period. To learn more, read the change freeze penetration testing policy below.\n    \n*   Scope and purpose of the test\n    \n*   IP address(es) the test will come from\n    \n*   Tooling that is planned to be used\n    \n*   Request per second (the test must be conformant with the [Rate Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy))\n    \n*   The Auth0 tenant(s) involved\n    \n*   Two contacts - phone number and email -  who will be available during the entire test period in case we need to contact you. If we have any questions, we will make a reasonable attempt to contact you. If you cannot be reached, we reserve the right to take measures to protect the service, which may include shutting down or blocking your tenant and/or the source of the intrusion traffic.\n    \n\n## Change freeze penetration testing policy\n\n*   Penetration tests are not allowed during change freezes.\n    \n*   Approved tests scheduled to occur during an ad hoc change freeze will be rescheduled and clearly communicated.\n    \n*   Auth0 may grant exceptions in extenuating circumstances.\n    \n\n## Test requirements\n\nAuth0 requires that:\n\n*   The test be restricted to only your tenant\n    \n*   The test requests per second must not exceed rates defined in our [Rate Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy)\n    \n*   You disclose any suspected findings to the Auth0 Security team for explanation/discussion\n    \n*   You understand that your tenant will be moved between environments during testing. Auth0 will move your tenant from the Production environment to the Preview environment before the testing commences. Auth0 will then return your tenant to the Production environment once the testing period ends. Note that while your tenant is on the Preview environment it may receive updates more rapidly.\n    \n\n## Reporting Identified Vulnerabilities\n\nTo report any vulnerabilities identified, kindly send us an email to **security@auth0.com**. The PGP key to encrypt the email or report can be found at [https://auth0.com/security](https://auth0.com/security).\n\n## Restrictions\n\n*   You may not conduct any [load testing](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/load-testing-policy) (such as Denial of Service testing) per the load testing policy.\n    \n*   You may not conduct any penetration testing targeting our management dashboard. Management and Authentication APIs are allowed.\n    \n*   You may not conduct any penetration testing targeting tenants that we have not approved.\n    \n\n## Private Cloud customers\n\nPrivate Cloud customers should also request permission to run a penetration test via the Auth0 support center. Please include the information listed above with your support request.\n\n## Learn more\n\n*   [Load Testing Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/load-testing-policy)",
  "title": "Penetration Testing Policy",
  "description": "Describes Auth0's Penetration Testing Policy.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/enterprise-public",
  "markdown": "# Enterprise\n\nSee below for the rate limits in the Enterprise subscription type.\n\n/\n\nAuthentication API\n\nRate limits for the Authentication API and API endpoints in the Enterprise subscription type.\n\n/\n\nManagement API\n\nRate limits for the Management API, API endpoints, and API endpoint groups in the Enterprise subscription type.",
  "title": "Enterprise",
  "description": "Rate limits for the Enterprise subscription type.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/free-public",
  "markdown": "# Free\n\nSee below for the rate limit policies for the Free subscription type.\n\n/\n\nAuthentication API\n\nRate limits for the Authentication API on the Free subscription tier.\n\n/\n\nManagement API\n\nRate limits for the Management API on the Free subscription tier.",
  "title": "Free",
  "description": " rate limit policies for the Free Public subscription type.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/self-service-public",
  "markdown": "# Self Service\n\nSee below for the rate limit policies for the Self service subscription type.\n\n/\n\nAuthentication API\n\nRate Limits for the Authentication API and API Endpoints in the Self service subscription type.\n\n/\n\nManagement API\n\nRate Limits for the Management API, API Endpoints, and API Endpoint Groups in the Self service subscription type.",
  "title": "Self Service",
  "description": "Rate limits for the self service public subscription type",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/tier-20-development-private-cloud",
  "markdown": "# Tier Dev Private Cloud\n\nSee below for the rate limit policies for the Tier 20 (Development) Private Cloud subscription type.",
  "title": "Tier Dev Private Cloud",
  "description": "Rate limits for the Tier 20 (Development) Private Cloud subscription type.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-use-cases",
  "markdown": "# Rate Limit Use Cases\n\n## Discover when requests to a tenant are rate-limited\n\nThere are a handful of ways to determine if a customer product is being rate limited by Auth0. See below for the possible causes of rate limitation.\n\n### Tenant logs\n\nYou can use tenant logs for more information on request limits. The `api_limit` is exported in the logs immediately after a rate limit is exceeded. If the rate limit is still being exceeded after an hour, then a second log is created. This enables rate limit detection in both Auth0 or customer-built applications.\n\nTo learn more about tenant logs, read [Logs](https://auth0.com/docs/deploy-monitor/logs).\n\n### API responses\n\nAuth0 API responses deliver [HTTP 429 (Too Many Requests)](http://tools.ietf.org/html/rfc6585#section-4) responses with the exceeded rate limit. This enables customers to observe rate limit enforcement in real time. However, this is only useful for custom-built customer applications interacting directly with the Auth0 API.\n\n### SDK error handling\n\nIf you are using an SDK, refer to the [Management API SDK libraries](https://auth0.com/docs/libraries#mgmt) error pages.\n\n### Error pages\n\nThe error page response is sent for endpoints that render HTML content to the end user. If your tenant is configured to use generic (Auth0 hosted) pages, Auth0 renders the error page instead of the expected content when you exceed the response limit.  If your tenant is configured to use [custom error pages](https://auth0.com/docs/customize/login-pages/custom-error-pages), the user is redirected to the custom error page URL with the relevant error in the `error_description` query string parameter.  For more information, see [Affected endpoints](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/authentication-api-endpoint-rate-limits#affected-endpoints) and the [JSON Error](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/authentication-api-endpoint-rate-limits#json-error) descriptions.\n\n## Find out why a tenant is being rate limited\n\nIf you believe tenant requests are rate limited and need assistance to understand why, open a request via the [Support Center](http://support.auth0.com/).  As part of your request, please include the full raw log where the issue was seen.\n\n## Predict when requests to a tenant will be rate limited \n\nAuth0 reports up-to-date information on the current status of your rate limits using HTTP response headers from endpoints that have rate limit policies configured. This status is communicated as follows:\n\n*   `x-ratelimit-limit`: Maximum number of requests available until the bucket is refilled with additional requests.\n    \n*   `x-ratelimit-remaining`: Number of remaining requests available until the bucket is refilled with additional requests.\n    \n*   `x-ratelimit-reset`: [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time), in milliseconds, of the expected time when additional requests will be added to the bucket.\n    \n\nFor example:\n\nAn API has the following rate limit:\n\n*   Burst Limit: `1000`\n    \n*   Sustained Rate Limit: `100` `requests per second` (on a sliding window)\n    \n\nFrom this information, you can derive:\n\n*   The sustained rate limit is `100 requests per second` on a sliding window\n    \n*   1000 milliseconds = 1 second \n    \n*   Due to the sliding window, a new request is granted every 10 milliseconds (1000 milliseconds divided by 100 requests = 10 milliseconds for a request to be granted).\n    \n\nIf you receive the following x-headers in your API response:\n\n*   `x-ratelimit-limit: 1000`\n    \n*   `x-ratelimit-remaining: 50`\n    \n*   `x-ratelimit-reset: 1675452600000`\n    \n\nYou now know that:\n\n*   Your tenant has used up 950 of the 1000 requests allowable to that API, and only has 50 requests remaining until such time that additional requests are added.\n    \n*   New requests will be added at `1675452600000`, or 7:30:00.000 PM UTC on February 3, 2023.\n    \n*   1 new request will be added at that time \n    \n\nTherefore, if you are making requests at a rate greater than what is described above, then a rate limitation is expected.  How soon you will be rate limited depends on the burst limit and to what extent you are exceeding the sustained limit.\n\n## Examples of how rate limits are enforced\n\n### Requests per second example\n\nAssume Auth0 launches a new API called `/ratelimitexample` with the following rate limit values:\n\n*   Burst limit: `5` requests\n    \n*   Sustained rate limit: `10` requests per second.\n    \n\nExample scenario:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7jujhIRszVOVxXDfCUW3oV/aa122d509a96e49eed80a4deb9bd0541/image1.png)\n\nKey points:\n\n*   API begins with, and will never exceed, 5 request tokens, which is equal to the burst limit.\n    \n*   10 new request tokens are added every second, using a “sliding window.”  10 new tokens are added at equal, incremental intervals over the course of each second.  There are 1000 milliseconds in 1 second, and we can determine that a new request token will be added by 1000 milliseconds / 10 requests = 100 milliseconds / request.\n    \n\n Example scenario with rate limits:  \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/30m5xST81Db6mROVGCV5Bj/fa2b8110f4fb2fb0da07c6f67b8f0146/image3.png)\n\nIn this scenario:\n\n*   T0 - T100ms:  The end user makes 6 requests in the first 100 milliseconds.  5 requests – equal to the burst limit – receive a `200` response.  The 6th request receives a `429` error because there are no remaining request tokens.\n    \n*   T100 ms - T200ms:  Auth0 adds a new request token, due to the sliding window. A new request is added at a rate of 10 RPS, or 1 token every 100 ms.  The 7th request exhausts the remaining request but is successful.  The eighth request therefore results in a `429` error.\n    \n*   T200ms - T300ms:  Auth0 adds a new request token, and the next request receives a `200` response.\n    \n\n### Requests per minute example\n\nAssume Auth0 launches a new API called `/ratelimitexample2` with the following rate limit values:\n\n*   Burst limit:  5 requests\n    \n*   Sustained Rate limit:  6 requests per minute.\n    \n\nExample scenario:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/2BfglJ4X6m0RLd3Ux6ADba/348057d11afd9f09bf24964bd7b196a6/image2.png)\n\nKey points:\n\n*   API begins with 5 request tokens, which is equal to the burst limit.\n    \n*   6 new request tokens are added every minute, using a “sliding window”.  6 new tokens are added at equal, incremental intervals over the course of each minute.  There are 60 seconds in 1 minute, and a new request token will be added 60 seconds / 6 request tokens = 10 seconds.\n    \n\nExample scenario with rate limits:  \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/PhtwGBwS9PfEpNQbPeA1o/0c7a81c8362b003b04af006355aa8404/image4.png)\n\nIn this scenario:\n\n*   T0 - T-10 seconds:  The end user makes 6 requests in the first second.  5 requests – equal to the burst limit – receive a 200 response.  The 6th request receives a `429` error because there are no remaining request tokens.\n    \n*   T-10 seconds - T-20 seconds:  Auth0 adds a new request token. Due to the sliding window a new request is added at a rate of 6 RPM, or 1 token every 10 seconds.  The 7th request exhausts the remaining request token but is successful.  The eighth request therefore results in a `429` error.\n    \n*   T-20 seconds - T-30 seconds:  Auth0 adds a new request token, and the next request receives a `200` response.\n    \n\n### Other Scenarios\n\nOn occasion, Auth0 will assign two rate limits to a single API.  This is done in order to configure a burst limit and the sustained rate limit that is more customized to the needs of the service.  In effect, the first rate limit becomes the effective burst limit, and the second rate limit becomes the effective sustained rate limit.  In this scenario, Auth0 only publishes the effective burst and sustained rate limits, rather than communicating the actual burst and sustained rate limits.",
  "title": "Rate Limit Use Cases",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/tier-100-rps-private-cloud",
  "markdown": "# Private Cloud Basic 100 RPS (1x)\n\nSee below for the rate limits in the Private Cloud Basic 100 RPS (1x) subscription type. These limits apply to each tenant you create in the private cloud environment. \n\nTherefore, we recommend deploying one tenant per private cloud environment for risk mitigation.",
  "title": "Private Cloud Basic 100 RPS (1x)",
  "description": "Tier 100 RPS Private Cloud rate limits",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/tier-500-rps-private-cloud",
  "markdown": "# Private Cloud Performance 500 RPS (5x)\n\nSee below for the rate limits in the Private Cloud Performance 500 RPS (5x) subscription type. \n\nThese limits apply to each tenant you create in the private cloud environment.  Therefore, we recommend deploying one tenant per private cloud environment for risk mitigation.",
  "title": "Private Cloud Performance 500 RPS (5x)",
  "description": "Tier 500 RPS Private Cloud rate limits",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/tier-3000-rps-private-cloud",
  "markdown": "# Private Cloud Performance 3000 RPS (30x)\n\nSee below for the rate limits in the Private Cloud Performance 3000 RPS (30x) subscription type. These limits apply to each tenant you create in the private cloud environment. \n\nTherefore, we recommend deploying one tenant per private cloud environment for risk mitigation.",
  "title": "Private Cloud Performance 3000 RPS (30x)",
  "description": "Tier 3000 RPS Private Cloud rate limits",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/tier-6000-rps-private-cloud",
  "markdown": "# Private Cloud Performance 6000 RPS (60x)\n\nSee below for the rate limits in the Private Cloud Performance 6000 RPS (60x) subscription type. These limits apply to each tenant you create in the private cloud environment. \n\nTherefore, we recommend deploying one tenant per private cloud environment for risk mitigation.",
  "title": "Private Cloud Performance 6000 RPS (60x)",
  "description": "Tier 6000 RPS Private Cloud rate limits",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/tier-1500-rps-private-cloud",
  "markdown": "# Private Cloud Performance 1500 RPS (15x)\n\nSee below for the rate limits in the Private Cloud Performance 1500 RPS (15x) subscription type. These limits apply to each tenant you create in the private cloud environment. \n\nTherefore, we recommend deploying one tenant per private cloud environment for risk mitigation.",
  "title": "Private Cloud Performance 1500 RPS (15x)",
  "description": "Tier 1500 RPS Private Cloud rate limits",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa",
  "markdown": "# Configure Email Notifications for MFA\n\nUse email as a multi-factor authentication (MFA) factor to provide users a way to perform MFA when they don't have their primary factor available (e.g. they don't have their device to receive an SMS or push notification).\n\n#### Availability varies by login implementation\n\nThe login implementation you use affects whether this feature is available. To learn more, read [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).\n\nEmail is not true MFA because it does not represent a different factor than the password. It does not represent **something I have** or **something I am**, but rather just **something I know** (the email password). It is also weaker than other factors in that it's only as secure as the email itself (for example, encrypted end-to-end).\n\nUsers do not need to explicitly enroll with email MFA. They will get be able to use it when they have a verified email. This happens when they:\n\n*   Complete the email verification flow which updates the `email_verified` field using the Management API.\n    \n*   Log in with a connection that provides verified emails (such as Google).\n    \n\nYou can only enable email as an MFA factor if there is already another factor enabled.\n\nOnce Email MFA is enabled, users will be prompted to complete MFA with another enabled factor. If they select **Try another method**, and then pick **Email**, they will be sent an email with a 6-digit code that they will need to enter to complete the authentication flow.\n\n## Configure email notifications\n\nYou can explicitly enroll email for MFA using the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators). If users have a verified email and one or more explicitly enrolled emails, they can choose to select which email they want to use to complete MFA when logging-in using Universal Login.\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/multifactor-auth) and enable the **Email** toggle. You will only be able to enable it if there is another factor enabled.\n    \n2.  Auth0 provides a test email provider but it only allows a limited amount of emails, so you should configure your own email provider. To learn more, read [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers).\n    \n\n## Learn more\n\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Customize Emails](https://auth0.com/docs/customize/email)\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n*   [Configure Custom External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)",
  "title": "Configure Email Notifications for MFA",
  "description": "Describes how to configure email as an MFA factor for users who don't have their primary factor available.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/email-templates/email-template-descriptions",
  "markdown": "# Email Template Descriptions\n\n## Verification emails\n\nIf you turn on the **Verification Email**, users who sign up on a database connection will receive a message asking to confirm their email address by clicking on a URL included in the message.\n\nIn addition to the common variables available for all email templates, the **Verification Email** provides the `url` variable that refers to the URL that the user will have to click. You will use it in the **Message** field to create a link that the user can follow.\n\n### Redirect To results for verification email template\n\nYou can configure a **Redirect To** URL to send the users to after the email verification action was attempted. By default, Auth0 includes the following parameters:\n\n*   `success` with value `true` or `false` indicating whether the email verification was successful\n    \n*   `message` with an additional description of the outcome. Some possible values are:\n    \n    *   `Your email was verified. You can continue using the application.` (with `success=true`)\n        \n    *   `This URL can be used only once` (with `success=false`)\n        \n    *   `Access expired.` (with `success=false`)\n        \n    *   `User account does not exist or verification code is invalid.` (with `success=false`)\n        \n    *   `This account is already verified.` or `Your email address could not be verified.`(with `success=false`)\n        \n\nYou can prevent sending the email addresses on the redirect links by updating the email templates using the Management API. For example:\n\n`PATCH /api/v2/email-templates/reset_email { \"includeEmailInRedirect\": false }` or,\n\n`PATCH /api/v2/email-templates/verify_email { \"includeEmailInRedirect\": false }`\n\nThe target URL handler should be prepared to gracefully handle other possible messages as well.\n\n## Welcome emails\n\nOnce a user verifies their email address, they will receive a **Welcome Email**. If you turn off the **Verification Email** feature, the **Welcome Email** will be sent to the user when they sign-up (or log in for the first time).\n\nIn addition to the common variables available for all email templates, the following are available to the **Welcome** template:\n\n*   If the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview):\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\n## Change password emails\n\nIf a user requests a password change, they will receive a **Change Password** email that contains a URL link. When the user clicks on the link, a [Password Reset page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page) will be presented to enter the new password.\n\nIn addition to the common variables available for all email templates, the following are available to the **User Invitation** template:\n\n*   `url`: URL that the user will select to change their password. You can use it in the **Message** field to create a link that the user can follow, as in this example: `<a href=\"/docs/{{ url }}\">Click here to change your password</a>`\n    \n*   If the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview):\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\n### Redirect To results for change password template\n\nYou can configure a **Redirect To** URL to send the users to after the password change action was attempted. By default, Auth0 includes the following parameters:\n\n*   `success` with value `true` or `false` indicating whether the password change was successful\n    \n*   `message` with an additional description of the outcome. Some possible values are:\n    \n    *   `You can now login to the application with the new password.` (with `success=true`)\n        \n    *   `This URL can be used only once` (with `success=false`)\n        \n    *   `Access expired.` (with `success=false`)\n        \n    *   `The operation cannot be completed. Please try again.` (with `success=false`)\n        \n\nThe target URL handler should be prepared to gracefully handle other possible messages as well.\n\n## Blocked account emails\n\nIf a user attempts to log in ten or more times unsuccessfully from the same IP address, the user account will be locked and they will receive a **Blocked Account** email. Once the user receives this email, they will not be able to login from that IP address again until they click on the link contained in the email.\n\nIf the user successfully logs in before they exhaust their ten allowed attempts, the counter is reset.\n\nIn addition to the common variables available for all email templates, the following ones are available in the **Blocked Account Email** template:\n\n*   `user.source_ip`\n    \n*   `user.city`\n    \n*   `user.country`\n    \n*   If the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview):\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\nThis template also provides the `url` variable that should be used to create the link that the user needs to follow. For example:\n\n`<a href=\"/docs/{{ url }}\">Click here to unblock your account</a>`\n\n### Redirect To results for blocked account email templates\n\nYou can configure a **Redirect To** URL to send the users to after the account unblocking action was attempted. When redirecting, Auth0 will include the following parameters:\n\n*   `email` indicating the email of the user\n    \n*   `success` with value `true` or `false` indicating whether the account unblocking was successful\n    \n*   `message` with an additional description of the outcome. Some possible values are:\n    \n    *   `Your account has been unblocked.` (with `success=true`)\n        \n    *   `This URL can be used only once` (with `success=false`)\n        \n    *   `Access expired.` (with `success=false`)\n        \n\nThe target URL handler should be prepared to gracefully handle other possible messages as well.\n\n## Breached password alert emails\n\nThis email type is sent whenever Auth0 detects that the user is trying to access the application using a password that has been leaked by a third party. These emails are only set after enabling **Breached Password Detection** in the [Attack Protection](https://manage.auth0.com/#/security/attack-protection) section of the dashboard. To learn more, see [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection).\n\nIn addition to the common variables available for all email templates, the following ones are available for the **Breached Password Alert** emails:\n\n*   If the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview):\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\n## Enrollment emails for MFA\n\nThis email will be generated when an MFA enrollment invitation is sent. The message will contain a link that, when visited, will show the MFA enrollment experience.\n\nIn addition to the common variables available for all email templates, the `link` variable is available in this email type, containing the URL that you will use to construct the link for this action, as in this example:\n\n`<a href=\"/docs/{{ link }}\">Enroll your MFA device</a>`\n\nUnlike other email templates, the correct variable name is `link` and not `url`. Also, the `connection.name` variable is not available on this email template type.\n\n## Verification code emails for MFA\n\nThis email will be generated when you use email as an MFA method and request a verification code to be sent. In addition to the common variables available, the template provides a `code` variable to render the code used for MFA verification. For example:\n\n`<div>Your code is: {{ code }}</div>`\n\n## User invitation emails\n\nIf a user is invited to become a member of an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview), they will receive a **User Invitation** email that contains a URL link. When the user clicks on the link, they will be redirected to your default login route. To learn more, see [Configure Default Login Routes](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes).\n\nIn addition to the common variables available for all email templates, the following are available to the **User Invitation** template:\n\n*   User invitation information (all information derived from the user invitation ticket):\n    \n    *   `inviter.name`\n        \n    *   `app_metadata`\n        \n    *   `user_metadata`\n        \n    *   `roles.id`\n        \n    *   `roles.name`\n        \n    *   `roles.description`\n        \n*   Organization information:\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\nTo localize emails, you can set the `locale` to be sent in `user_metadata` when creating an invitation. To learn more, see [Customize Email Templates: Multilingual Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\n### Redirect results for user invitation email templates\n\nYou must [configure a default login route](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes), to which users will be sent after selecting the link to accept the invitation. When redirecting, Auth0 will include the following parameters:\n\n*   `invitation`: ID of the invitation ticket\n    \n*   `organization`: ID of the organization to which the user is being invited\n    \n*   `organization_name`: Name of the organization to which the user is being invited\n    \n\nFor example, if you have an organization-enabled application with an **Application Login URI** set to `https://myapp.com/login`, then the link sent in the email invitation that an end-user receives will be: `https://myapp.com/login?invitation={invitation_ticket_id}&organization={organization_id}&organization_name={organization_name}`.\n\nThe target login route should initiate a transaction to `/authorize` that contains the provided `invitation` and `organization` key-value pairs. It should also be prepared to gracefully handle other possible messages.\n\n## Passwordless emails\n\nUnlike the previous email templates types, this email template is not configured from the Email Templates section. Instead, it's part of the [settings for the Email Passwordless Connection](https://manage.auth0.com/#/connections/passwordless).\n\nThe Passwordless Email is sent when a passwordless access is requested, either by code (the user receives a code that types in the application) or by a link (the user clicks on a link and is taken directly to the application).\n\nYou can use all the common variables available in all templates, plus the following variables defined specifically for the **Passwordless Email** template:\n\n*   `send`, which will contain a value of `link`, `link_ios`, `link_android` or `code` depending on the type of passwordless email requested.\n    \n*   `code` with the one-time-use code to access the application\n    \n*   `link` with the link that can be clicked by the user to gain access to the application (only for link-type passwordless emails)\n    \n*   `request_language` will have the language code of the user request, if available\n    \n*   `operation`, which will be `change_email` if this is a passwordless email change operation.\n    \n\nThe default template uses the above variables to do something like this:\n\n```\n<!-- Email change content -->\n{% if operation == 'change_email' %}\n  <p>Your email address has been updated.</p>\n{% else %}\n  <!-- Signup email content -->\n  {% if send == 'link' or send == 'link_ios' or send == 'link_android' %}\n    <p>Click and confirm that you want to sign in to {{ application.name }}. This link will expire in five minutes.</p>\n    <a href=\"/docs/{{ link }}\">Sign in to {{ application.name }}</a>\n    {% elsif send == 'code' %}\n    <p>Your verification code is: <b>{{ code }}</b></p>\n  {% endif %}\n{% endif %}\n```\n\nIn the Passwordless Email template only the `email` property of the `user` object is available.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)",
  "title": "Email Template Descriptions",
  "description": "Describes the email templates used in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/email-templates/use-liquid-syntax-in-email-templates",
  "markdown": "# Use Liquid Syntax in Email Templates\n\nWhen using the [Email Templates](https://manage.auth0.com/#/branding/email_templates) available on the Auth0 dashboard, you have the option of using the Liquid template language to select the appropriate data and formatting your emails. Liquid is an open-source templating language that extends the functionality of HTML that you can use to dynamically generate your emails to contain varying information. To learn more, read [Liquid for Designers](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers) on Github.\n\nUsing Liquid, you can structure the `Subject` of your emails to display the appropriate application name, rather than hardcoding a particular value:\n\n`We are {{application.name}}!`\n\nHTML with Liquid syntax is supported in every field (except `URL Lifetime`) on the Verification, Change Password Confirmation, and Blocked Account email templates. For more information on supported output attributes and their usage, see [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nThere are two types of markup in Liquid: output and tag.\n\n### Output markup\n\n**Output** markup resolves to text and is surrounded by two pairs of matching curly braces:\n\n`Hello {{ name }}!`\n\nYou can further customize the appearance of the output by using filters, which are simple methods. For example, the `upcase` filter will convert the text which is passed to the filter to uppercase:\n\n`Hello {{ name | upcase }}!`\n\nMultiple filters are separated by `|` and are processed from left to right, applying the subsequent filter to the result of the previous one. The template will render the final result.\n\nThe following filters are supported:\n\n| Filter | Description | Example |\n| --- | --- | --- |\n| `append` | Append a string | `{{ 'foo' \\| append:'bar' }} #=> 'foobar'` |\n| `capitalize` | Capitalize words in the input sentence | `{{ \"my great title\" \\| capitalize }} #=> My great title` |\n| `date` | Reformat a date ([syntax reference](http://docs.shopify.com/themes/liquid-documentation/filters/additional-filters#date)) |     |\n| `default` | Returns the given variable unless it is null or the empty string, when it will return the given value | `{{ undefined_variable \\| default: \"Default value\" }} #=> \"Default value\"` |\n| `divided_by` | Integer division | `{{ 10 \\| divided_by:3 }} #=> 3` |\n| `downcase` | Convert an input string to lowercase, | `{{ \"Parker Moore\" \\| downcase }} #=> parker moore` |\n| `escape` | HTML escape a string | `{{ \"Have you read 'James & the Giant Peach'?\" \\| escape }} #=> Have you read &#39;James &amp; the Giant Peach&#39;?` |\n| `escape_once` | Returns an escaped version of HTML without affecting existing escaped entities | `{{ \"1 < 2 &amp; 3\" \\| escape_once }} #=> 1 &lt; 2 &amp; 3` |\n| `first` | Get the first element of the passed in array |     |\n| `join` | Join elements of the array with certain character between them |     |\n| `last` | Get the last element of the passed in array |     |\n| `map` | Map/collect an array on a given property |     |\n| `minus` | Subtraction | `{{ 4 \\| minus:2 }} #=> 2` |\n| `modulo` | Remainder | `{{ 3 \\| modulo:2 }} #=> 1` |\n| `newline_to_br` | Replace each newline (\\\\n) with HTML break |     |\n| `plus` | Addition | `{{ '1' \\| plus:'1' }} #=> 2`, `{{ 1 \\| plus:1 }} #=> 2` |\n| `prepend` | Prepend a string | `{{ 'bar' \\| prepend:'foo' }} #=> 'foobar'` |\n| `remove` | Remove each occurrence | `{{ 'foobarfoobar' \\| remove:'foo' }} #=> 'barbar'` |\n| `remove_first` | Remove the first occurrence | `{{ 'barbar' \\| remove_first:'bar' }} #=> 'bar'` |\n| `replace` | Replace each occurrence | `{{ 'foofoo' \\| replace:'foo','bar' }} #=> 'barbar'` |\n| `replace_first` | Replace the first occurrence | `{{ 'barbar' \\| replace_first:'bar','foo' }} #=> 'foobar'` |\n| `round` | Rounds input to the nearest integer or specified number of decimals | `{{ 4.5612 \\| round: 2 }} #=> 4.56` |\n| `size` | Return the size of an array or string | `{{ \"Ground control to Major Tom.\" \\| size }} #=> 28` |\n| `sort` | Sort elements of the array |     |\n| `split` | Split a string on a matching pattern | `{{ \"a~b\" \\| split:\"~\" }} #=> ['a','b']` |\n| `strip_html` | Strip HTML from string | `{{ \"How <em>are</em> you?\" \\| strip_html }} #=> How are you?` |\n| `strip_newlines` | Strip all newlines (\\\\n) from string |     |\n| `times` | Multiplication | `{{ 5 \\| times:4 }} #=> 20` |\n| `truncate` | Truncate a string down to x characters. It also accepts a second parameter that will append to the string | `{{ 'foobarfoobar' \\| truncate: 5, '.' }} #=> 'foob.'` |\n| `truncatewords` | Truncate a string down to x words |     |\n| `upcase` | Convert an input string to uppercase | `{{ \"Parker Moore\" \\| upcase }} #=> PARKER MOORE` |\n\n### Tag markup\n\n**Tag** markup does not resolve to text and is surrounded by a pair of matched curly braces and percent signs:\n\n`{% this does not resolve to text %}`\n\nTags are typically used to apply logic to your template. Using the Liquid [supported tags](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers#tags), you can have one template meet several needs.\n\nYou could use tags to execute `if / else` statements to have a single template send out emails in multiple languages.\n\nFor example:\n\n`{% if user.user_metadata.lang == 'en' %} [email body in English] {% elsif user.user_metadata.lang == 'de' %} [email body in German] {% endif %}`\n\nIf you need to use additional conditions, consider using a case statement. To learn more about case statements, see [Liquid for Designers](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers#case-statement) on Github.\n\nAny content between `{% comment %}` and `{% endcomment %}` tags will not be rendered.\n\n`This will be seen. {% comment %} This will not be seen. {% endcomment %}`\n\n#### Tag raw\n\nTo temporarily disable processing of Liquid markup, use `{% raw %}` and `{% endraw %}`. This is useful if you are using syntax that conflicts with Liquid.\n\nFor example, you can escape the following `Mustache.js` line as follows:\n\n`{% raw %} var clients = \"Clients:<ul>{{#client}}<li>{{fn}} {{ln}}\" + {{phone}}</li>{{/client}}</ul>\"; {% endraw %}`\n\n## Debug variables\n\nTo assist your template development, we've added a custom `{% debug %}` liquid tag, which outputs a summary of the template variables available to your template when it was rendered. Remember to remove this tag from any \"live\" templates.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Email Template Descriptions](https://auth0.com/docs/customize/email/email-templates/email-template-descriptions)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)",
  "title": "Use Liquid Syntax in Email Templates",
  "description": "Describes how to use Liquid syntax in your email templates.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow",
  "markdown": "# Post Change Password Flow\n\nThe Post Change Password Flow runs after a user resets or changes their password. You can use this flow to email the user after a password change or to notify another system that the user’s password has changed, so that other sessions not managed by Auth0 can be revoked.\n\n![Diagram showing the Actions Post Change Password Flow.](https://images.ctfassets.net/cdy7uua7fh8z/3i65TvmTpHkyDTqKvXAkMi/3adb8f0bd195cec4dd0a82cb87b270b9/post-change-password-flow.png)\n\nActions in this flow are non-blocking (asynchronous), which means the Auth0 pipeline will continue to run without waiting for the Action to finish its execution. Thus, the Action's outcome does not affect the Auth0 transaction.\n\n## Triggers\n\n### Post Change Password\n\nThe `post-change-password` trigger runs after a database connection user resets or changes their password.\n\nMultiple Actions can be bound to this trigger, and the Actions will run in order. However, these Actions will be run asynchronously and will not block the password reset process.\n\n### Reference\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow/event-object): Provides contextual information about the user and the connection on which the password was changed.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Common use cases\n\n### Invalidate the user’s session in another system\n\nA post-change-password Action can be used to invalidate the user's session in another system:\n\n```\nconst axios = require(\"axios\");\n\n/**\n * @param {Event} event - Details about user whose password was changed.\n */\nexports.onExecutePostChangePassword = async (event) => {\n  axios.post(\"https://my-api.exampleco.com/revoke-session\", { params: { email: event.user.email }});\n};\n```\n\n### Send an email after the user changes their password\n\n```\nconst axios = require(\"axios\");\n\nexports.onExecutePostChangePassword = async (event) => {\n  try {\n    // https://sendgrid.api-docs.io/v3.0/mail-send\n    axios.post('https://api.sendgrid.com/v3/mail/send',\n      {\n        personalizations: [{\n          to: [{ email: event.user.email }]\n        }],\n        from: { email: 'admin@exampleco.com' },\n        subject: 'Your password was changed',\n        content: [{\n          type: 'text/plain',\n          value: 'The password for your ' + event.connection.name + ' account ' + event.user.email + ' was recently changed.'\n        }]\n      },\n      {\n        headers: {\n          'Authorization': 'Bearer ' + event.secrets.SENDGRID_API_KEY\n        },\n      }\n    );\n  } catch (err) {\n    console.log(`Error sending email to ${event.user.email}:`, err.message)\n  }\n};\n```",
  "title": "Post Change Password Flow",
  "description": "Learn about the Post Change Password flow and the post-change-password Action trigger, which runs after a Database connection user resets or changes their password. This trigger can be used to notify another system that the user’s password has changed.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow",
  "markdown": "# Implicit Flow with OIDC\n\nTraditionally, the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) was used by applications that were incapable of securely storing secrets. Using this flow is no longer considered a best practice for requesting access tokens; new implementations should use [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). However, when used with Form Post response mode, Implicit Flow does offer a streamlined workflow if the application needs only an ID token to perform user authentication; in these cases, it would be used as part of the [Hybrid Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow).\n\nRefresh tokens will no longer be returned when using the Implicit Flow for authentication.\n\nIn addition, the OIDC-conformant pipeline affects the Implicit Flow in the following areas: authentication request, authentication response, ID token structure, and access token structure.\n\n## Authentication request\n\n### Legacy\n\n```\nGET /authorize?\n    response_type=token\n    &scope=openid email favorite_color offline_access\n    &client_id=123\n    &state=af0ifjsldkj\n    &redirect_uri=https://app.example.com\n    &device=my-device-name\n```\n\nThe `device` parameter is only needed if requesting a refresh token by passing the `offline_access` scope. To learn more, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n### OIDC-conformant\n\n```\nGET /authorize?\n    response_type=token id_token\n    &scope=openid email\n    &client_id=123\n    &state=af0ifjsldkj\n    &nonce=jxdlsjfi0fa\n    &redirect_uri=https://app.example.com\n    &audience=https://api.example.com\n```\n\n*   `response_type` indicates that we want to receive both an access token and ID token.\n    \n*   Refresh tokens are not allowed in the implicit grant. Use `prompt=none` instead. To learn more read [Configure Silent Authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication).\n    \n*   `favorite_color` is no longer a valid scope.\n    \n*   `audience` is optional.\n    \n*   `nonce` must be a cryptographically secure random string. To learn more, read [Mitigate Replay Attacks When Using the Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow).\n    \n\n## Authentication response\n\n### Legacy\n\n```\nHTTP/1.1 302 Found\nLocation: https://app.example.com/#\n    access_token=SlAV32hkKG\n    &expires_in=86400\n    &state=af0ifjsldk\n    &id_token=eyJ...\n    &refresh_token=8xLOxBtZp8\n    &token_type=Bearer\n```\n\n*   The returned access token is valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n    \n*   A refresh token will be returned only if a `device` parameter was passed and the `offline_access` scope was requested.\n    \n\n### OIDC-conformant\n\n```\nHTTP/1.1 302 Found\nLocation: https://app.example.com/#\n    access_token=eyJ...\n    &expires_in=86400\n    &state=af0ifjsldk\n    &id_token=eyJ...\n    &token_type=Bearer\n```\n\n*   The returned access token is valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint (provided that the API specified by the `audience` param uses `RS256` as [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms)) and optionally the resource server specified by the `audience` parameter.\n    \n*   If using `response_type=id_token`, Auth0 will only return an ID token. Refresh Tokens are not allowed in the implicit grant. Use `prompt=none` instead.\n    \n\n## ID token structure\n\n### Legacy\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"favorite_color\": \"blue\"\n}\n```\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"https://app.example.com/favorite_color\": \"blue\",\n    \"nonce\": \"jxdlsjfi0fa\"\n}\n```\n\n*   The `favorite_color` claim must be namespaced and added through a rule. To learn more, read [Create Namespaced Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n    \n*   After validating the ID token, the application must validate the nonce to mitigate replay attacks.\n    \n\n## Access token structure (optional)\n\n### Legacy\n\nThe returned Access Token is opaque and only valid for calling the [](https://auth0.com/docs/api/authentication#get-user-info)`/userinfo` endpoint[](https://auth0.com/docs/api/authentication#get-user-info).\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": [\n        \"https://api.example.com\",\n        \"https://{yourDomain}/userinfo\"\n    ],\n    \"azp\": \"123\",\n    \"exp\": 1482816809,\n    \"iat\": 1482809609,\n    \"scope\": \"openid email\"\n}\n```\n\n*   The returned access token is a JWT valid for calling the [](https://auth0.com/docs/api/authentication#get-user-info)`/userinfo` endpoint[](https://auth0.com/docs/api/authentication#get-user-info) (provided that the API specified by the `audience` param uses `RS256` as [signing algorithm](https://auth0.com/docs/get-started/applications/change-application-signing-algorithms)) as well as the resource server specified by the `audience` parameter.\n    \n*   An opaque access token could still be returned if `/userinfo` is the only specified audience.\n    \n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
  "title": "Implicit Flow with OIDC",
  "description": "Learn how the OIDC-conformant pipeline affects the Implicit Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/customize-tokens-using-hooks-with-client-credentials-flow",
  "markdown": "# Customize Tokens Using Hooks with Client Credentials Flow\n\nYou can change scopes and add custom claims in the tokens issued through the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) by adding [Hooks](https://auth0.com/docs/customize/hooks).\n\nHooks allow you to customize the behavior of Auth0 using Node.js code. They are secure, self-contained functions associated with specific extensibility points of the Auth0 platform (like the Client Credentials flow). Auth0 invokes the Hooks at runtime to execute your custom logic.\n\nYou can manage Hooks using the Auth0 Dashboard or the Management API.\n\n## Prerequisites\n\nBefore beginning this tutorial, you must:\n\n*   [Register your API with Auth0](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n    \n    *   [Add appropriate API permissions](https://auth0.com/docs/get-started/apis/add-api-permissions)\n        \n*   [Register the M2M Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps).\n    \n    *   Select an **Application Type** of **Machine to Machine Applications**.\n        \n    *   Choose your previously-registered API.\n        \n    *   Authorize the M2M Application to call your API.\n        \n\n## Steps\n\n1.  **Create Hook**: Create a hook that will customize your token.\n    \n2.  **Test Hook**: Test your new hook by running a Client Credentials Flow and decoding the access token.\n    \n\n### Create a Hook\n\nIn this example, you will:\n\n*   add an arbitrary claim (`https://foo.com/claim`) to the [Access Token](https://auth0.com/docs/secure/tokens/access-tokens)\n    \n*   add an extra permission to your configured API\n    \n\nCreate a Hook to customize your token. When asked to choose an extensibility point, select `Client Credentials Exchange`, and add the following code in the editor:\n\n```\nmodule.exports = function(client, scope, audience, context, cb) {\n  var access_token = {};\n  access_token['https://foo.com/claim'] = 'bar';\n  access_token.scope = scope;\n  access_token.scope.push('extra');\n  cb(null, access_token);\n};\n```\n\n### Test your Hook\n\nTo test the hook you just created you need to run a Client Credentials exchange, get the Access Token, decode it, and review its contents.\n\n#### Get token\n\nTo get a token, make a `POST` call to the [Client Credentials Flow endpoint](https://auth0.com/docs/api/authentication#client-credentials-flow). Be sure to replace CLIENT\\_ID, CLIENT\\_SECRET, and API\\_IDENTIFIER placeholder values with your application's Client ID, your application's Client Secret, and your API's Identifier, respectively. You can find the Client ID and Client Secret in your [Application](https://manage.auth0.com/#/applications) settings and the API Identifier in your [API](https://manage.auth0.com/#/apis) settings.\n\n*   [cURL](#b175f49de59c43708065a9997290b0df_shell)\n*   [C#](#b175f49de59c43708065a9997290b0df_csharp)\n*   [Go](#b175f49de59c43708065a9997290b0df_go)\n*   [Java](#b175f49de59c43708065a9997290b0df_java)\n*   [Node.JS](#b175f49de59c43708065a9997290b0df_node)\n*   [Obj-C](#b175f49de59c43708065a9997290b0df_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=CLIENT_SECRET \\\n  --data audience=API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id={yourClientId}&client_secret=CLIENT_SECRET&audience=API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id={yourClientId}&client_secret=CLIENT_SECRET&audience=API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id={yourClientId}&client_secret=CLIENT_SECRET&audience=API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'CLIENT_SECRET',\n    audience: 'API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id={yourClientId}&client_secret=CLIENT_SECRET&audience=API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id={yourClientId}&client_secret=CLIENT_SECRET&audience=API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id={yourClientId}&client_secret=CLIENT_SECRET&audience=API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nA successful response will include:\n\n*   an `access_token`,\n    \n*   its expiration time in seconds (`expires_in`),\n    \n*   the token's type set as `Bearer` (`token_type`), and\n    \n*   an `extra` permission (`scope`) (which was added by your Hook)\n    \n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5ESTFNa05DTVRGQlJrVTRORVF6UXpFMk1qZEVNVVEzT1VORk5ESTVSVU5GUXpnM1FrRTFNdyJ9.eyJpc3MiOiJodHRwczovL2RlbW8tYWNjb3VudC5hdXRoMC3jb20vIiwic3ViIjoic0FRSlFpQmYxREw0c2lqSVZCb2pFRUZvcmRoa0o4WUNAY2xpZW50cyIsImF1ZCI6ImRlbW8tYWNjb3VudC5hcGkiLCJleHAiOjE0ODc3NjU8NjYsImlhdCI6MTQ4NzY3OTI2Niwic2NvcGUiOiJyZWFkOmRhdGEgZXh0cmEiLCJodHRwczovL2Zvby5jb20vY2xhaW0iOiKoPXIifQ.da-48mHY_7esfLZpvHWWL8sIH1j_2mUYAB49c-B472lCdsNFvpaLoq6OKQyhnqk9_aW_Xhfkusos3FECTrLFvf-qwQK70QtwbkbVye_IuPSTAYdQ2T-XTzGDm9Nmmy5Iwl9rNYLxVs2OoCdfpVMyda0OaI0AfHBgEdKWluTP67OOnV_dF3KpuwtK3dPKWTCo2j9VCa7X1I4h0CNuM79DHhY2wO7sL8WBej7BSNA3N2TUsp_YTWWfrvsr_vVhJf-32G7w_12ms_PNFUwj2C30ZZIPWc-uEkDztyMLdI-lu9q9TLrLdr0dOhfrtfkdeJx4pUSiHdJHf42kg7UAVK6JcA\",\n  \"expires_in\": 86400,\n  \"scope\": \"extra\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n#### Decode token\n\nThe easiest way to decode the access token and review its contents is to use the [JWT.io Debugger](https://jwt.io/#debugger-io).\n\nCopy your access token and paste it into the editor. The JWT is decoded automatically and its contents are displayed.\n\nNote that the last two items of the **Payload** have both been set by your hook:\n\n*   `\"scope\": \"extra\"`\n    \n*   `\"https://foo.com/claim\": \"bar\"`\n    \n\n## Learn more\n\n*   [Auth0 Hooks](https://auth0.com/docs/customize/hooks)\n*   [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow)\n*   [Call Your API Using the Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow)",
  "title": "Customize Tokens Using Hooks with Client Credentials Flow",
  "description": "Learn how to use Hooks to change scopes and add custom claims in the access token obtained using the Client Credentials Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow",
  "markdown": "# Machine to Machine Flow\n\nThe Machine to Machine Flow runs when an Access Token is being issued via the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).\n\n![Diagram showing the Actions Machine to Machine Flow and when the triggers inside of it run.](https://images.ctfassets.net/cdy7uua7fh8z/1JPl54LFWCUh5StuglZS2o/41f89372526574c3b8cdac4d5ba38072/Machine_to_Machine_Flow.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### M2M / Client Credentials\n\nThe `credentials-exchange` trigger is a function executed before the access token is returned.\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow/event-object): Provides contextual information about the request for a client credentials exchange.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow/api-object): Provides methods for changing the behavior of the flow\n    \n\n## Common use cases\n\n### Access control\n\nA credentials-exchange Action can be used to deny an access token based on custom logic.\n\n```\n/**\n * @param {Event} event - Details about client credentials grant request.\n * @param {CredentialsExchangeAPI} api - Interface whose methods can be used to change the behavior of client credentials grant.\n */\nexports.onExecuteCredentialsExchange = async (event, api) => {\n  if (event.request.geoip.continentCode === \"NA\") {\n    api.access.deny('invalid_request', \"Access from North America is not allowed.\");\n  }\n};\n```\n\n### Add custom claims to the access token\n\nA credentials-exchange Action can be used to add custom claims to an access token.\n\n```\n/**\n * @param {Event} event - Details about client credentials grant request.\n * @param {CredentialsExchangeAPI} api - Interface whose methods can be used to change the behavior of client credentials grant.\n */\nexports.onExecuteCredentialsExchange = async (event, api) => {\n  api.accessToken.setCustomClaim(\"https://my-api.exampleco.com/request-ip\", event.request.ip);  \n};\n```",
  "title": "Machine to Machine Flow",
  "description": "Learn about the Actions Machine to Machine Flow and the credentials-exchange Action trigger, which runs as part of the Machine to Machine Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets",
  "markdown": "# Create Custom Enrollment Tickets\n\nYou can manage users' enrollments by creating enrollment tickets via the MFA API [`/Guardian/post_ticket`](https://auth0.com/docs/api/management/v2#!/Guardian/post_ticket) endpoint. This API will return an enrollment ticket containing a `ticket_id` and a `ticket_url`, which can be used to enroll a user. The `ticket_url` can be delivered to the user (for example, via email) and used to kick off the enrollment process. Tickets expire after 5 days. A user who receives a ticket will only be able to enroll once. Further enrollments must be made via the MFA API.\n\nIf you are using the Classic Universal Login experience and you need to customize how the page looks when the user navigates to the `ticket_url`, you can edit the MFA page. Go to the [Dashboard > Branding > Universal Login > Multi-factor Authentication](https://manage.auth0.com/#/mfa_page) tab, and modify the `ticket` variable. Here is an example:\n\n```\n{% if ticket %}\n<h4 class=\"message\">Welcome, {{ userData.email }}, enroll your device below</h4>\n{% else %}\n<h4 class=\"message\">Welcome back, {{ userData.email }}, authenticate below</h4>\n{% endif %}\n```\n\n## Learn more\n\n*   [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options)\n*   [Guardian Error Code Reference](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/guardian-error-code-reference)\n*   [Auth0 MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api)",
  "title": "Create Custom Enrollment Tickets",
  "description": "Learn how to create an enrollment ticket from the Auth0 MFA API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/install-guardian-sdk",
  "markdown": "# Install Guardian SDK\n\nThe Guardian SDK provides a UI-less client for Guardian.\n\n`npm install auth0-guardian-js`\n\n## Source files\n\n*   [Full SDK Version](https://cdn.auth0.com/js/guardian-js/1.3/guardian-js.js)\n    \n*   [Minified SDK Version](https://cdn.auth0.com/js/guardian-js/1.3/guardian-js.min.js)\n    \n*   [Full Guardian API](https://github.com/auth0/auth0-guardian.js#full-api)\n    \n\n## Configure Guardian\n\n```\nvar auth0GuardianJS = require('auth0-guardian-js')({\n\t// For US tenants: https://{name}.guardian.auth0.com\n \t// For AU tenants: https://{name}.guardian.au.auth0.com\n \t// For EU tenants: https://{name}.guardian.eu.auth0.com\n  // For JP tenants: https://{name}.guardian.jp.auth0.com\n\tserviceUrl: \"https://{{ userData.tenant }}.guardian.auth0.com\",\n\trequestToken: \"{{ requestToken }}\", // or ticket: \"{{ ticket }}\" - see below\n\n\tissuer: {\n\t\t// The issuer name to show in OTP Generator apps\n\t\tlabel: \"{{ userData.tenantFriendlyName }}\",\n\t\tname: \"{{ userData.tenant }}\",\n\t},\n\n\t// The account label to show in OTP Generator apps\n\taccountLabel: \"{{ userData.friendlyUserId }}\",\n\n\t// Optional, for debugging purpose only,\n\t// ID that allows to associate a group of requests\n\t// together as belonging to the same \"transaction\" (in a wide sense)\n\tglobalTrackingId: \"{{ globalTrackingId }}\"\n});\n```\n\nUse of `requestToken` or `ticket` depends on the authentication method. Ticket corresponds to a previously generated [enrollment ticket](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets).\n\n### Use a custom domain\n\nIf you have a custom domain configured for your Auth0 tenant, you'll need to update the `serviceUrl` property to point to the Guardian endpoint:\n\n```\nvar auth0GuardianJS = require('auth0-guardian-js')({\n    // For custom domains\n    serviceUrl: \"https://{yourCustomDomain}/guardian/\",\n    ...\n});\n```\n\n## Enroll devices\n\nEnrolling devices consists of the following steps:\n\n1.  Start the transaction.\n    \n2.  (optional) Check if the user is already enrolled. You cannot enroll twice.\n    \n3.  Send the information needed to enroll.\n    \n4.  Confirm enrollment.\n    \n5.  Show the recovery code.\n    \n\nSome steps can be omitted depending on the method. We provide the same interface for all methods so you can write uniform code. Some of the methods complete the authentication, whereas others need an extra authentication step. You can determine that by listening to the `enrollment-complete` event.\n\n```\nfunction enroll(transaction, method) {\n\tif (transaction.isEnrolled()) {\n\t\tconsole.log('You are already enrolled');\n\t\treturn;\n\t}\n\n\tvar enrollData = {};\n\n\tif (method === 'sms') {\n\t\tenrollData.phoneNumber = prompt('Phone number'); // Collect phone number\n\t}\n\n\treturn transaction.enroll(method, enrollData, function (err, otpEnrollment) {\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tvar uri = otpEnrollment.getUri();\n\t\tif (uri) {\n\t\t\tshowQR(uri);\n\t\t}\n\n\t\tvar confirmData = {};\n\t\tif (method === 'otp' || method === 'sms') {\n\t\t\tconfirmData.otpCode = prompt('Otp code'); // Collect verification otp\n\t\t}\n\n\t\totpEnrollment.confirm(confirmData);\n\t});\n}\n\nauth0GuardianJS.start(function(err, transaction) {\n\tif (err) {\n\t\tconsole.error(err);\n\t\treturn;\n\t}\n\n\ttransaction.on('error', function(error) {\n\t\tconsole.error(error);\n\t});\n\n\ttransaction.on('timeout', function() {\n\t\tconsole.log('Timeout');\n\t});\n\n\ttransaction.on('enrollment-complete', function(payload) {\n\t\tif (payload.recoveryCode) {\n\t\t\talert('Recovery code is ' + payload.recoveryCode);\n\t\t}\n\n\t\tif (payload.authRequired) {\n\t\t\tshowAuthenticationFor(transaction, payload.enrollment);\n\t\t\treturn;\n\t\t}\n\t});\n\n\ttransaction.on('auth-response', function(payload) {\n\t\tif (payload.recoveryCode) {\n\t\t\talert('The new recovery code is ' + payload.recoveryCode);\n\t\t}\n\n\t\tif (!payload.accepted) {\n\t\t\talert('Authentication has been rejected');\n\t\t\treturn;\n\t\t}\n\n\t\tauth0GuardianJS.formPostHelper('{{ postActionURL }}', { signature: payload.signature });\n\t});\n\n\tvar availableEnrollmentMethods = transaction.getAvailableEnrollmentMethods();\n\n\tmethod = prompt('What method do you want to use, select one of '\n\t\t+ availableEnrollmentMethods.join(', '));\n\n\tenroll(transaction, method) // For sms\n});\n```\n\n## Authenticate\n\nTo authenticate with a method you need to execute the following steps:\n\n1.  Start the transaction.\n    \n2.  (optional) Check if the user is already enrolled. You need to be enrolled to authenticate.\n    \n3.  Request the auth (the push notification or SMS). Request is a noop for OTP.\n    \n4.  Verify the OTP (`.verify` is a noop for push).\n    \n\nSome steps can be omitted depending on the method, we provide the same interface for all methods so you can write uniform code. After the factor is verified or the push accepted you will receive an `auth-response` event with the payload to send to the server, you can use the `auth0GuardianJS.formPostHelper('{{ postActionURL }}', payload)` to post back the message to the server.\n\nYou may also receive `auth-rejected` if the push notification was received.\n\n```\nfunction authenticate(method) {\n\tauth0GuardianJS.start(function (err, transaction) {\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!transaction.isEnrolled()) {\n\t\t\tconsole.log('You are not enrolled');\n\t\t\treturn;\n\t\t}\n\n\t\ttransaction.on('error', function(error) {\n\t\t\tconsole.error(error);\n\t\t});\n\n\t\ttransaction.on('timeout', function() {\n\t\t\tconsole.log('Timeout');\n\t\t});\n\n\t\ttransaction.on('auth-response', function(payload) {\n\t\t\tif (payload.recoveryCode) {\n\t\t\t\talert('The new recovery code is ' + payload.recoveryCode);\n\t\t\t}\n\n\t\t\tif (!payload.accepted) {\n\t\t\t\talert('Authentication has been rejected');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tauth0GuardianJS.formPostHelper('{{ postActionURL }}', { signature: payload.signature });\n\t\t});\n\n\t\tvar enrollment = transaction.getEnrollments()[0];\n\n\t\tif (enrollment.getAvailableAuthenticatorTypes().length === 0) {\n\t\t\talert('Somethings went wrong, seems that there is no authenticators');\n\t\t\treturn;\n\t\t}\n\n\t\ttransaction.requestAuth(enrollment, { method: method } function(err, auth) {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar data = {};\n\t\t\tif (method === 'sms' || method === 'otp') {\n\t\t\t\tdata.otpCode = prompt('Otp code');\n\t\t\t} else if (method === 'recovery-code') {\n\t\t\t\tdata.recoveryCode = prompt('Recovery code');\n\t\t\t}\n\n\t\t\treturn auth.verify(data);\n\t\t});\n\t});\n}\n```\n\n## Learn more\n\n*   [Guardian Error Code Reference](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/guardian-error-code-reference)",
  "title": "Install Guardian SDK",
  "description": "Describes how to install, configure options, and use the Guardian SDKs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/guardian-error-code-reference",
  "markdown": "# Guardian Error Code Reference\n\nUse the error codes to display informative messages and to distinguish between recoverable and unrecoverable errors.\n\n| Error Code | Description |\n| --- | --- |\n| `invalid_token` | Invalid request or transaction token |\n| `insufficient_scope` | You don't have enought grants to perform the requested operation |\n| `invalid_bearer_format` | The bearer put in authentication header was not valid |\n| `enrollment_conflict` | There is another enrollment for the same user. You cannot enroll twice. |\n| `tenant_not_found` | The tenant associated cannot be found. Should not normally happen at least that you delete the tenant |\n| `login_transaction_not_found` | The mfa auth transaction is not active or has already expired |\n| `error_sending_push_notification` | Push notification delivery failed |\n| `push_notification_wrong_credentials` | Push notification delivery failed because of wrong credentials |\n| `invalid_otp` | Provided otp code was not valid |\n| `invalid_recovery_code` | Provided recovery code was not valid |\n| `invalid_body` | Body validation failed. Bad request. |\n| `invalid_query_string` | Query string validation failed. Bad request. |\n| `enrollment_transaction_not_found` | The mfa enrollment transaction is not active or has expired |\n| `invalid_phone_number` | The provided phone number is invalid |\n| `error_sending_sms` | SMS Delivery error |\n| `feature_disabled` | The requested feature is currently globally not available (contact the provider) |\n| `feature_disabled_by_admin` | The requested feature is currently disabled by your admin |\n| `pn_endpoint_disabled` | We were unable to deliver the push notification after retrying many times. Try removing you account for the device and adding it again. |\n| `too_many_sms` | You have exeed the amount of SMSs assigned to your user |\n| `too_many_pn` | You have exeed the amount of push notifications assigned to your user |\n| `too_many_sms_per_tenant` | You have exeed the amount of SMSs assigned to your tenant |\n| `too_many_pn_per_tenant` | You have exeed the amount of push notifications assigned to your tenant |\n| `field_required` | A field is required to perform the operation (this errors has a field attribute with a code for the field: `otpCode`, `recoveryCode`) |\n| `method_not_found` | You have requested a method that is currently not supported (should not happen) |\n| `no_method_available` | There is currently no method to enroll (all of them are disabled) |\n| `enrollment_method_disabled` | The specified enrollment method is disabled, this error has also a .method field |\n| `auth_method_disabled` | The specified authentication method is disabled, this error has also a .method field |\n| `invalid_otp_format` | OTP format validation error |\n| `invalid_recovery_code_format` | Recovery code format validation error |\n| `transaction_expired` | The transaction has already expired |\n| `already_enrolled` | You are already enrolled, cannot enroll again |\n| `not_enrolled` | You not enrolled. Must enroll first |\n| `invalid_enrollment` | The enrollment provided to transaction#requestAuth method is not valid or is null/undefined |",
  "title": "Guardian Error Code Reference",
  "description": "Lists Guardian error codes and descriptions.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/import-user-mfa-authenticator-enrollments",
  "markdown": "# Import User MFA Authenticator Enrollments\n\nYou can import a user's MFA enrollments with [automatic migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) and [bulk user imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports). The supported enrollment types are:\n\n*   Email: for email verification.\n    \n*   Phone: for SMS verification.\n    \n*   OTP: for One-Time Passwords (OTPs) used with authenticator applications, such as Google Authenticator.\n    \n\nImporting MFA enrollments provides a seamless user experience, since users won't have to re-enroll after migration.\n\nThe classic login experience does not support factor selection for users with multiple factors. If you plan to import users with multiple registered factors, consider using the [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) experience.\n\n## Schema\n\nThe schema applies to MFA factors for both of the following workflows.\n\n```\n{\n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"totp\": {\n                \"type\": \"object\",\n                \"properties\": {\n                \"secret\": {\n                    \"type\": \"string\",\n                        \"pattern\": \"^[A-Z2-7]+$\",\n                        \"description\": \"The OTP secret is used for MFA authentication with Google Authenticator type apps. It must be supplied in un-padded Base32 encoding, such as: JBTWY3DPEHPK3PNP\"\n                    },\n                },\n                \"additionalProperties\": false,\n                \"required\": [\"secret\"],\n            },\n            \"phone\": {\n                \"type\": \"object\",\n                \"properties\": {\n                \"value\": {\n                    \"type\": \"string\",\n                    \"pattern\": \"^\\\\+[0-9]{1,15}$\",\n                    \"description\": \"The phone number for SMS or Voice MFA. The phone number should include a country code and begin with +, such as: +12125550001\"\n                },\n                },\n                \"additionalProperties\": false,\n                \"required\": [\"value\"],\n            },\n            \"email\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"value\": {\n                        \"type\": \"string\",\n                        \"format\": \"email\",\n                        \"description\": \"The email address for MFA\"\n                    },\n                },\n                \"additionalProperties\": false,\n                \"required\": [\"value\"],\n            },\n        },\n        \"maxProperties\": 1,\n        \"additionalProperties\": false,\n    },\n    \"minItems\": 1,\n    \"maxItems\": 10\n}\n```\n\n## Automatic migration\n\nMFA enrollments can also be imported during an [automatic migration](https://auth0.com/docs/connections/database/custom-db/overview-custom-db-connections#automatic-migration-scenario). This can be accomplished by providing any existing enrollments in the `mfa_factors` field of the user that is provided to the callback at the end of your custom DB [login script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login).\n\nAny failures will appear in your tenant logs as failed logins, and will be distinguishable from other failures by their description: `Unable to import MFA factors`. For example:\n\n```\n{\n  \"_id\": \"5e9df3b29ebabe00571c04a7\",\n  \"date\": \"2020-04-20T19:10:42.916Z\",\n  \"type\": \"fu\",\n  \"description\": \"Unable to import MFA factors.\",\n  \"connection\": \"Username-Password-Authentication\",\n  \"connection_id\": \"con_mMkvaycgzgCS0p0z\",\n  \"client_id\": \"aCbTAJNi5HbsjPJtRpSP6BIoLPOrSj2Cgg\",\n  \"client_name\": \"All Applications\",\n  \"ip\": \"10.12.13.1\",\n  \"client_ip\": null,\n  \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\",\n  \"details\": {\n    \"error\": {\n      \"message\": \"Unable to import MFA factors.\"\n    }\n  },\n  \"user_name\": \"test@test.io\",\n  \"strategy\": \"auth0\",\n  \"strategy_type\": \"database\"\n}\n```\n\n## Bulk user import\n\n1.  Prepare a `users.json` file. See [bulk user imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports) for details.\n    \n2.  Include existing MFA enrollments for each user.\n    \n3.  Start a bulk user import.\n    \n4.  Update the factors of any existing users by enabling the `upsert` option in your initial request.\n    \n5.  Once the import job completes, check the response for any errors. If any of the users' MFA factors failed to import, you will see errors such as:\n    \n\nWhen using the `upsert` option, any non-MFA related updates to existing users will have been applied to the user's profile. For example, the following error summary shows the user's `picture` attribute was successfully set to `http://example.org/jdoe.png`, however we were unable to import the provided MFA factors. In cases like this, it is safe to retry the import for failed users.\n\n```\n[\n  {\n    \"user\": {\n      \"email\": \"antoinette@contoso.com\",\n      \"picture\": \"http://example.org/jdoe.png\",\n      \"mfa_factors\": [\n        {\n          \"totp\": {\n            \"secret\": \"2PRXZWZAYYDAWCD\"\n          }\n        },\n        {\n          \"phone\": {\n            \"value\": \"+15551112233\"\n          }\n        },\n        {\n          \"email\": {\n            \"value\": \"antoinette@antoinette.biz\"\n          }\n        }\n      ]\n    },\n    \"errors\": [\n      {\n        \"code\": \"MFA_FACTORS_FAILED\",\n        \"message\": \"Unable to import factors\"\n      }\n    ]\n  }\n]\n```\n\n## Recovery codes\n\nAuth0 does not provide a way to import recovery codes. When the user's MFA factors are imported, they won't have a recovery code.\n\nTo provide users a recovery code, you can check if they have one enrolled, and if not, use the [Recovery Code Regeneration endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_recovery_code_regeneration) to generate a new one.\n\n## Learn more\n\n*   [Configure Automatic Migration from Your Database](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database)\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)",
  "title": "Import User MFA Authenticator Enrollments",
  "description": "Describes how to import MFA enrollments for your existing users.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes",
  "markdown": "# Challenge with Recovery Codes\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'recovery_code={recoveryCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-recovery-code',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    recovery_code: '{recoveryCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&recovery_code={recoveryCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&recovery_code={recoveryCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Challenge with Recovery Codes",
  "description": "Describes how to use the MFA API to challenge users who lose access to their device or account using recovery codes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators",
  "markdown": "# Enroll and Challenge Email Authenticators\n\nAuth0 provides a built-in MFA enrollment and authentication flow using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). However, if you want to create your own user interface, you can use the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) to accomplish it.\n\nWhen email is enabled as a factor, all users with verified emails will be able to use them to complete MFA.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Prerequisites\n\nBefore you can use the MFA APIs, you'll need to enable the MFA grant type for your application. Go to [Auth0 Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**.\n\n*   [Configure Email](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa) as a factor in the Dashboard or using the [Management API](https://auth0.com/docs/api/management/v2#!/Guardian/put_factors_by_name).\n    \n\n## Enroll with email\n\nTo enable users to enroll emails in addition to their verified email in their primary identity, you need to complete the following steps.\n\n### Get MFA token\n\nDepending on when you are triggering enrollment, you can obtain an access token for using the MFA API in different ways:\n\n*   If you are enrolling during authentication, see [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   If you want to let the user enroll a factor at any moment, see [Manage MFA Factor Enrollments](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n\n### Enroll authenticator\n\nMake a `POST` request to the MFA Associate endpoint to enroll the user's authenticator. The bearer token required by this endpoint is the MFA token obtained in the previous step.\n\nUse the following parameters:\n\n| Parameter | Value |\n| --- | --- |\n| `authentication_types` | `[oob]` |\n| `oob_channels` | `[email]` |\n| `email` | `email@address.com`, the users email address. |\n\n*   [cURL](#6f05dd94d61f49ce8ba14d073a96ddce_shell)\n*   [C#](#6f05dd94d61f49ce8ba14d073a96ddce_csharp)\n*   [Go](#6f05dd94d61f49ce8ba14d073a96ddce_go)\n*   [Java](#6f05dd94d61f49ce8ba14d073a96ddce_java)\n*   [Node.JS](#6f05dd94d61f49ce8ba14d073a96ddce_node)\n*   [Obj-C](#6f05dd94d61f49ce8ba14d073a96ddce_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"authenticator_types\": [\"oob\"], \"oob_channels\": [\"email\"], \"email\" : \"email@address.com\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/associate\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/associate\"\n\n\tpayload := strings.NewReader(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/associate\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'},\n  data: {\n    authenticator_types: ['oob'],\n    oob_channels: ['email'],\n    email: 'email@address.com'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"authenticator_types\": @[ @\"oob\" ],\n                              @\"oob_channels\": @[ @\"email\" ],\n                              @\"email\": @\"email@address.com\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/associate\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/associate\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\"\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/associate\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/associate\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"authenticator_types\": [\"oob\"],\n  \"oob_channels\": [\"email\"],\n  \"email\": \"email@address.com\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/associate\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf successful, you receive a response like this:\n\n```\n{\n    \"authenticator_type\": \"oob\",\n    \"binding_method\": \"prompt\",\n    \"oob_code\" : \"Fe26..nWE\",\n    \"oob_channel\": \"email\",\n    \"recovery_codes\": [ \"N3BGPZZWJ85JLCNPZBDW6QXC\" ]\n  }\n```\n\nIf you get a `User is already enrolled` error, the user already has an MFA factor enrolled. Before associating another factor with the user, you must challenge the user with the existing factor.\n\nIf this is the first time the user is associating an authenticator, you'll notice the response includes `recovery_codes`. Recovery codes are used to access the user's account in the event that they lose access to the account or device used for their second-factor authentication. These are one-time usable codes, and new ones are generated as necessary.\n\n### Confirm email enrollment\n\nThe user should receive an email containing the 6-digit code that they can provide to the application.\n\nTo complete the enrollment, make a `POST` request to the [**`/oath/token`**](https://auth0.com/docs/api/authentication#get-token) endpoint. Include the `oob_code` returned in the previous response and the `binding_code` with the value in the email message.\n\n*   [cURL](#b330b86f829d4e3dbb656db629ee6964_shell)\n*   [C#](#b330b86f829d4e3dbb656db629ee6964_csharp)\n*   [Go](#b330b86f829d4e3dbb656db629ee6964_go)\n*   [Java](#b330b86f829d4e3dbb656db629ee6964_java)\n*   [Node.JS](#b330b86f829d4e3dbb656db629ee6964_node)\n*   [Obj-C](#b330b86f829d4e3dbb656db629ee6964_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}' \\\n  --data 'binding_code={userEmailOtpCode}' \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddParameter(\"undefined\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}',\n    binding_code: '{userEmailOtpCode}',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&binding_code={userEmailOtpCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\"\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&binding_code={userEmailOtpCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the following format, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\nAt this point, the authenticator is fully associated and ready to be used, and you have the authentication tokens for the user.\n\nYou can check at any point to verify whether an authenticator has been confirmed by calling the MFA Authenticators endpoint. If the authenticator is confirmed, the value returned for `active` is `true`.\n\nOptionally, you can customize the emails that users receive. See [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates) for details.\n\n## Challenge with email\n\n### Get MFA token\n\nGet an MFA token following the steps described in [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n\n### Retrieve enrolled authenticators\n\nTo challenge the user, you need the `authenticator_id` for the factor you want to challenge. You can list all enrolled authenticators using the MFA Authenticators endpoint:\n\n*   [cURL](#18f53b8c09354cb39df22ed8f7fa2786_shell)\n*   [C#](#18f53b8c09354cb39df22ed8f7fa2786_csharp)\n*   [Go](#18f53b8c09354cb39df22ed8f7fa2786_go)\n*   [Java](#18f53b8c09354cb39df22ed8f7fa2786_java)\n*   [Node.JS](#18f53b8c09354cb39df22ed8f7fa2786_node)\n*   [Obj-C](#18f53b8c09354cb39df22ed8f7fa2786_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Challenge user with OTP\n\nTo trigger an email challenge, `POST` to the MFA Challenge endpoint using the corresponding `authenticator_id` and the `mfa_token`.\n\n*   [cURL](#ee2a535b9a8e4b12b524bb444cbdc4e8_shell)\n*   [C#](#ee2a535b9a8e4b12b524bb444cbdc4e8_csharp)\n*   [Go](#ee2a535b9a8e4b12b524bb444cbdc4e8_go)\n*   [Java](#ee2a535b9a8e4b12b524bb444cbdc4e8_java)\n*   [Node.JS](#ee2a535b9a8e4b12b524bb444cbdc4e8_node)\n*   [Obj-C](#ee2a535b9a8e4b12b524bb444cbdc4e8_objc)\n*   [...](#)\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --data '{  \"client_id\": \"{yourClientId}\",  \"client_secret\": \"{yourClientSecret}\",  \"challenge_type\": \"oob\",  \"authenticator_id\": \"email|dev_NU1Ofuw3Cw0XCt5x\", \"mfa_token\": \"{mfaToken}\" }'\n```\n\nto configure this snippet with your account\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/challenge\");\nvar request = new RestRequest(Method.POST);\nrequest.AddParameter(\"undefined\", \"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\nto configure this snippet with your account\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/challenge\"\n\n\tpayload := strings.NewReader(\"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\nto configure this snippet with your account\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/challenge\")\n  .body(\"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n  .asString();\n```\n\nto configure this snippet with your account\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    challenge_type: 'oob',\n    authenticator_id: 'email|dev_NU1Ofuw3Cw0XCt5x',\n    mfa_token: '{mfaToken}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\nto configure this snippet with your account\n\n```\n#import <Foundation/Foundation.h>\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"challenge_type\": @\"oob\",\n                              @\"authenticator_id\": @\"email|dev_NU1Ofuw3Cw0XCt5x\",\n                              @\"mfa_token\": @\"{mfaToken}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/challenge\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\nto configure this snippet with your account\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/challenge\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\nto configure this snippet with your account\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/challenge\", payload)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\nto configure this snippet with your account\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/challenge\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest.body = \"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\nto configure this snippet with your account\n\n```\nimport Foundation\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"challenge_type\": \"oob\",\n  \"authenticator_id\": \"email|dev_NU1Ofuw3Cw0XCt5x\",\n  \"mfa_token\": \"{mfaToken}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/challenge\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Complete authentication using received code\n\nIf successful, you receive the following response:\n\n```\n{\n  \"challenge_type\": \"oob\",\n  \"oob_code\": \"abcd1234...\",\n  \"binding_method\": \"prompt\"\n}\n```\n\nYour application should prompt the user for the code and send it as part of the request in the `binding_code` parameter in the following call to the `oauth``/token` endpoint:\n\n*   [cURL](#057f5620d6f649b2ac69f2ff28bbc340_shell)\n*   [C#](#057f5620d6f649b2ac69f2ff28bbc340_csharp)\n*   [Go](#057f5620d6f649b2ac69f2ff28bbc340_go)\n*   [Java](#057f5620d6f649b2ac69f2ff28bbc340_java)\n*   [Node.JS](#057f5620d6f649b2ac69f2ff28bbc340_node)\n*   [Obj-C](#057f5620d6f649b2ac69f2ff28bbc340_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}' \\\n  --data 'binding_code={userEmailOtpCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}',\n    binding_code: '{userEmailOtpCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&binding_code={userEmailOtpCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&binding_code={userEmailOtpCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the format below, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n## Learn more\n\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)",
  "title": "Enroll and Challenge Email Authenticators",
  "description": "Describes how to build your own MFA flows using SMS or voice as an authentication factor.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators",
  "markdown": "# Enroll and Challenge Push Authenticators\n\nAuth0 provides a built-in MFA enrollment and authentication flow using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). However, if you want to create your own user interface, you can use the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) to accomplish it.\n\nYou can enroll and challenge users using push notifications with the Guardian application or SDK using the MFA API.\n\n## Prerequisites\n\nBefore you can use the MFA APIs, you'll need to enable the MFA grant type for your application. Go to [Auth0 Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**.\n\n*   [Configure Push](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa) as a factor in the Dashboard or using the [Management API](https://auth0.com/docs/api/management/v2#!/Guardian/put_factors_by_name).\n    \n\n## Enroll with push\n\n### Get MFA token\n\nDepending on when you are triggering enrollment, you can obtain an access token for using the MFA API in different ways:\n\n*   If you are enrolling during authentication, see [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   If you want to let the user enroll a factor at any moment, see [Manage MFA Factor Enrollments](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n\n### Enroll authenticator\n\nMake a `POST` request to the MFA Associate endpoint to enroll the user's authenticator. The bearer token required by this endpoint is the MFA token obtained in the previous step.\n\nTo enroll with push, set the `authenticator_types` parameter to `[oob]` and the `oob_channels` parameter to `[auth0]`.\n\n*   [cURL](#dd6af4895af6435cb7a3e0f2fa56548f_shell)\n*   [C#](#dd6af4895af6435cb7a3e0f2fa56548f_csharp)\n*   [Go](#dd6af4895af6435cb7a3e0f2fa56548f_go)\n*   [Java](#dd6af4895af6435cb7a3e0f2fa56548f_java)\n*   [Node.JS](#dd6af4895af6435cb7a3e0f2fa56548f_node)\n*   [Obj-C](#dd6af4895af6435cb7a3e0f2fa56548f_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"authenticator_types\": [\"oob\"], \"oob_channels\": [\"auth0\"] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/associate\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/associate\"\n\n\tpayload := strings.NewReader(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/associate\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'},\n  data: {authenticator_types: ['oob'], oob_channels: ['auth0']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"authenticator_types\": @[ @\"oob\" ],\n                              @\"oob_channels\": @[ @\"auth0\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/associate\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/associate\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\"\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/associate\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/associate\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"authenticator_types\": [\"oob\"],\n  \"oob_channels\": [\"auth0\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/associate\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf successful, you receive a response like this:\n\n```\n{\n    \"authenticator_type\": \"oob\",\n    \"barcode_uri\": \"otpauth://totp/tenant:user?enrollment_tx_id=qfjn2eiNYSjU3xID7dBYeCBSrdREWJPY&base_url=tenan\",\n    \"recovery_codes\": [\n        \"ALKE6EJZ4853BJYLM2DM2WU7\"\n    ],\n    \"oob_channel\": \"auth0\",\n    \"oob_code\": \"Fe26.2...SYAg\"\n}\n```\n\nIf you get a `User is already enrolled` error, the user already has an MFA factor enrolled. Before associating another factor with the user, you must challenge the user with the existing factor.\n\nIf this is the first time the user is associating an authenticator, you'll notice the response includes `recovery_codes`. Recovery codes are used to access the user's account in the event that they lose access to the account or device used for their second-factor authentication. These are one-time usable codes, and new ones are generated as necessary.\n\n### Confirm push enrollment\n\nTo confirm the enrollment, the end user will need to scan a QR code with the `barcode_uri` in the Guardian application, within the next 5 minutes.\n\nOnce that is done, the Guardian application will notify Auth0 that the user enrolled successfully. To know if that happened, poll the Auth0 Token endpoint with the `oob_code` returned by the MFA Associate endpoint call.\n\n*   [cURL](#9edc92c4e71f496ba38663298e0e88e4_shell)\n*   [C#](#9edc92c4e71f496ba38663298e0e88e4_csharp)\n*   [Go](#9edc92c4e71f496ba38663298e0e88e4_go)\n*   [Java](#9edc92c4e71f496ba38663298e0e88e4_java)\n*   [Node.JS](#9edc92c4e71f496ba38663298e0e88e4_node)\n*   [Obj-C](#9edc92c4e71f496ba38663298e0e88e4_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'authorization: Bearer {mfaToken}' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {mfaToken}\");\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {mfaToken}\")\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"authorization\", \"Bearer {mfaToken}\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {\n    authorization: 'Bearer {mfaToken}',\n    'content-type': 'application/x-www-form-urlencoded'\n  },\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {mfaToken}\",\n                           @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {mfaToken}\",\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\"\n\nheaders = {\n    'authorization': \"Bearer {mfaToken}\",\n    'content-type': \"application/x-www-form-urlencoded\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {mfaToken}'\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {mfaToken}\",\n  \"content-type\": \"application/x-www-form-urlencoded\"\n]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the user has not scanned the code, it will return an `authorization_pending` response, indicating that you need to call `oauth_token` again in a few seconds:\n\n```\n{\n    \"error\": \"authorization_pending\",\n    \"error_description\": \"Authorization pending: please repeat the request in a few seconds.\"\n}\n```\n\nIf the call was successful, you'll receive a response in the following format, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\nAt this point, the authenticator is fully associated and ready to be used, and you have the authentication tokens for the user.\n\nYou can check at any point to verify whether an authenticator has been confirmed by calling the MFA Authenticators endpoint. If the authenticator is confirmed, the value returned for `active` is `true`.\n\n## Challenge with push\n\n### Get MFA token\n\nGet an MFA token following the steps described in [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n\n### Retrieve enrolled authenticators\n\nTo challenge the user, you need the `authenticator_id` for the factor you want to challenge. You can list all enrolled authenticators using the MFA Authenticators endpoint:\n\n*   [cURL](#4ae436a2c5974d6d88e418acb7741570_shell)\n*   [C#](#4ae436a2c5974d6d88e418acb7741570_csharp)\n*   [Go](#4ae436a2c5974d6d88e418acb7741570_go)\n*   [Java](#4ae436a2c5974d6d88e418acb7741570_java)\n*   [Node.JS](#4ae436a2c5974d6d88e418acb7741570_node)\n*   [Obj-C](#4ae436a2c5974d6d88e418acb7741570_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou will get a list of authenticators with the following format:\n\n```\n[\n    {\n        \"id\": \"recovery-code|dev_Ahb2Tb0ujX3w7ilC\",\n        \"authenticator_type\": \"recovery-code\",\n        \"active\": true\n    },\n    {\n        \"id\": \"push|dev_ZUla9SQ6tAIHSz6y\",\n        \"authenticator_type\": \"oob\",\n        \"active\": true,\n        \"oob_channel\": \"auth0\",\n        \"name\": \"user's device name\"\n    },\n    {\n        \"id\": \"totp|dev_gJ6Y6vpSrjnKeT67\",\n        \"authenticator_type\": \"otp\",\n        \"active\": true\n    }\n]\n```\n\nWhen users enroll with push, they also get enrolled in OTP, as Guardian supports [challenging with OTP](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators) for scenarios where the user does not have connectivity.\n\n### Challenge user with push\n\nTo trigger a push challenge, `POST` to the MFA Challenge endpoint using the corresponding `authenticator_id` and the `mfa_token`.\n\n*   [cURL](#72789a943e404ea3b853a03d15eb5a33_shell)\n*   [C#](#72789a943e404ea3b853a03d15eb5a33_csharp)\n*   [Go](#72789a943e404ea3b853a03d15eb5a33_go)\n*   [Java](#72789a943e404ea3b853a03d15eb5a33_java)\n*   [Node.JS](#72789a943e404ea3b853a03d15eb5a33_node)\n*   [Obj-C](#72789a943e404ea3b853a03d15eb5a33_objc)\n*   [...](#)\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --data '{ \"client_id\": \"{yourClientId}\",  \"client_secret\": \"{yourClientSecret\", \"challenge_type\": \"oob\", \"authenticator_id\": \"push|dev_ZUla9SQ6tAIHSz6y\", \"mfa_token\": \"{mfaToken}\" }'\n```\n\nto configure this snippet with your account\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/challenge\");\nvar request = new RestRequest(Method.POST);\nrequest.AddParameter(\"undefined\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\nto configure this snippet with your account\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/challenge\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\nto configure this snippet with your account\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/challenge\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n  .asString();\n```\n\nto configure this snippet with your account\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret',\n    challenge_type: 'oob',\n    authenticator_id: 'push|dev_ZUla9SQ6tAIHSz6y',\n    mfa_token: '{mfaToken}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\nto configure this snippet with your account\n\n```\n#import <Foundation/Foundation.h>\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret\",\n                              @\"challenge_type\": @\"oob\",\n                              @\"authenticator_id\": @\"push|dev_ZUla9SQ6tAIHSz6y\",\n                              @\"mfa_token\": @\"{mfaToken}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/challenge\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\nto configure this snippet with your account\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/challenge\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\nto configure this snippet with your account\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/challenge\", payload)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\nto configure this snippet with your account\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/challenge\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\nto configure this snippet with your account\n\n```\nimport Foundation\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret\",\n  \"challenge_type\": \"oob\",\n  \"authenticator_id\": \"push|dev_ZUla9SQ6tAIHSz6y\",\n  \"mfa_token\": \"{mfaToken}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/challenge\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Complete authentication using received code\n\nIf success, you receive the following response:\n\n```\n{\n    \"challenge_type\": \"oob\",\n    \"oob_code\": \"Fe26...jGco\"\n}\n```\n\nYour application must start polling the OAuth0 Token endpoint until the user accepts the push notification.\n\n*   [cURL](#0c1cc763c9004019a7eb3bf167b081d8_shell)\n*   [C#](#0c1cc763c9004019a7eb3bf167b081d8_csharp)\n*   [Go](#0c1cc763c9004019a7eb3bf167b081d8_go)\n*   [Java](#0c1cc763c9004019a7eb3bf167b081d8_java)\n*   [Node.JS](#0c1cc763c9004019a7eb3bf167b081d8_node)\n*   [Obj-C](#0c1cc763c9004019a7eb3bf167b081d8_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe call can return one of the following results:\n\n| Result | Description |\n| --- | --- |\n| `authorization_pending` | Error: If the challenge has not been accepted or rejected. |\n| `slow_down` | Error: If the polling is too frequent. |\n| `access_token` and `refresh_token` | If the challenge has been accepted; polling should be stopped at this point. |\n| `invalid_grant` | Error: If the challenge has been rejected: polling should be stopped at this point. |\n\n## Learn more\n\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)",
  "title": "Enroll and Challenge Push Authenticators",
  "description": "Describes how to build your own MFA flows using push as an authentication factor.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/enterprise/active-directory-ldap",
  "markdown": "# Connect Your App to Active Directory using LDAP\n\nAuth0 integrates with Active Directory (AD) using Lightweight Directory Access Protocol (LDAP) through an **Active Directory/LDAP Connector** that you install on your network.\n\nThe **AD/LDAP Connector** (1), is a bridge between your **Active Directory/LDAP** (2) and the **Auth0 Service** (3). This bridge is necessary because AD/LDAP is typically restricted to your internal network, and Auth0 is a cloud service running in a completely different context.\n\n![Overview Diagram of AD/LDAP Connector](https://images.ctfassets.net/cdy7uua7fh8z/2HT4cRvUDzA2OdEPlfgLDV/be32ffe82562dc8f07fdd2097f14d881/ldap-connect.png)\n\nFor [high availability and load balancing](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability), you can install multiple instances of the connector. All connections are outbound from the connector to the Auth0 Server, so changes to your firewall are generally unnecessary.\n\n## Prerequisites\n\nBefore beginning:\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of `**{https://yourApp/callback}**`.\n        \n    *   Make sure your Application's [**Grant Types**](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n\n## Steps\n\nTo connect your application to Active Directory/LDAP, you must:\n\n1.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0) and download the installer\n    \n2.  [Install the connector on your network](#install-the-connector-on-your-network)\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application)\n    \n4.  [Test the connection](#test-the-connection)\n    \n\n## Create an enterprise connection in Auth0\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Active Directory / LDAP**, and select its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create**:\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Display name** (optional) | Text used to customize the login button for Universal Login. When set, the Universal Login login button reads: \"Continue with {Display name}\". |\n    | **Logo URL** (optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    | **IdP Domains** (optional) | Comma-separated list of valid email domains that will be allowed to log in using this connection. Only needed if using the Lock login widget. |\n    | **Disable cache** | When enabled, disables caching. |\n    | **Use client SSL certificate authentication** | When enabled, uses client SSL certificate authentication. |\n    | **Use Windows Integrated Auth (Kerberos)** | When enabled, you will be asked to enter a range of IP addresses. When users log in through these IP addresses, Kerberos will be used; otherwise, AD/LDAP username/password will be requested. Typically, the IP range entered represent intranet addresses. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    ![Enter AD / LDAP Connection Details](https://images.ctfassets.net/cdy7uua7fh8z/2IR80sIwNNyPlDMxIjWv8e/b6748243f90ce0e7d771a39cef24cb0f/LDAP_Connection__1_.png)\n3.  Download the provided installer and make note of the provided **Provisioning Ticket URL**.\n    \n\n## Install the connector on your network\n\nSet up the [AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector) by following the instructions for your platform:\n\n*   [Install the AD/LDAP Connector on Windows](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector)\n    \n*   [Install the AD/LDAP Connector on Non-Microsoft Platforms](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector)\n    \n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new AD connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n## Next Steps\n\n*   [Integrate with Auth0 using one of our libraries](https://auth0.com/docs/libraries)\n    \n*   [Integrate with Auth0 using our Authentication API](https://auth0.com/docs/api/authentication)\n    \n*   [Read more about the authentication flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow)\n    \n*   [Pass additional parameters to the Identity Provider](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps)\n    \n*   [Re-prompt users for permissions](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions)",
  "title": "Connect Your App to Active Directory using LDAP",
  "description": "Learn how to connect your app to Active Directory (AD) using Lightweight Directory Access Protocol (LDAP) through an enterprise connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/enterprise/adfs",
  "markdown": "# Connect Your App to ADFS\n\nTo connect your application to Microsoft's Active Directory Federation Services (ADFS), you will need to provide the following information to your ADFS administrator:\n\n*   Realm Identifier: `urn:auth0:{yourTenant}`\n    \n*   Endpoint: `https://{yourDomain}/login/callback` or `https://<YOUR CUSTOM DOMAIN>/login/callback`, if you are using a [custom domain](https://auth0.com/docs/customize/custom-domains).\n    \n\n#### Federated metadata\n\nThe Federation Metadata file contains information about the ADFS server's certificates. If the Federation Metadata endpoint (`/FederationMetadata/2007-06/FederationMetadata.xml`) is enabled in ADFS, Auth0 can periodically (once a day) look for changes in the configuration, like a new signing certificate added to prepare for a rollover. Because of this, enabling the Federation Metadata endpoint is preferred to providing a standalone metadata file. If you provide a standalone metadata file, we will notify you via email when the certificates are close to their expiration date.\n\nYou can use a script to to setup the connection or set it up manually.\n\n## Scripted setup\n\nRun the following two commands in the Windows PowerShell window.\n\n```\n(new-object Net.WebClient -property @{Encoding = [Text.Encoding]::UTF8}).DownloadString(\"https://raw.github.com/auth0/adfs-auth0/master/adfs.ps1\") | iex\n```\n\n```\nAddRelyingParty \"urn:auth0:{yourTenant}\" \"https://{yourDomain}/login/callback\"\n```\n\nFor automated integration, this script uses the [ADFS PowerShell SnapIn](http://technet.microsoft.com/en-us/library/adfs2-powershell-basics.aspx) to create and configure a **Relying Party** that will issue, for the authenticated user, the following claims: **email**, **upn**, **given name**, and **surname**.\n\nThe script creates the Relying Party Trust on ADFS, as follows:\n\n```\n$realm = \"urn:auth0:{yourTenant}\";\n$webAppEndpoint = \"https://{yourDomain}/login/callback\";\nAdd-PSSnapin Microsoft.Adfs.Powershell\nAdd-ADFSRelyingPartyTrust -Name $realm -Identifier $realm -WSFedEndpoint $webAppEndpoint\n$rp = Get-ADFSRelyingPartyTrust -Name $realm\n```\n\nThe script also creates rules to output the most common attributes, such as email, UPN, given name, or surname:\n\n```\n$rules = @'\n@RuleName = \"Store: ActiveDirectory -> Mail (ldap attribute: mail), Name (ldap attribute: displayName), Name ID (ldap attribute: userPrincipalName), GivenName (ldap attribute: givenName), Surname (ldap attribute: sn)\"\nc:[Type == \"http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname\", Issuer == \"AD AUTHORITY\"]\n=> issue(store = \"Active Directory\",\n    types = (\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n             \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\",\n             \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n             \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n             \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\"), query = \";mail,displayName,userPrincipalName,givenName,sn;{0}\", param = c.Value);\n'@\nSet-ADFSRelyingPartyTrust –TargetName $realm -IssuanceTransformRules $rules\n$rSet = New-ADFSClaimRuleSet –ClaimRule '=> issue(Type = \"http://schemas.microsoft.com/authorization/claims/permit\", Value = \"true\");'\nSet-ADFSRelyingPartyTrust –TargetName $realm –IssuanceAuthorizationRules $rSet.ClaimRulesString\n```\n\n## Manual setup part 1: Add a Relying Party Trust\n\n1.  Open the ADFS Management Console.\n    \n2.  On the right side of the console, click **Add Relying Party Trust**\\*\n    \n3.  Click **Start**.\n    \n4.  Select **Enter data about the relying party manually**, and click **Next**.\n    \n5.  Type a name (such as `{yourAppName}`), and click **Next**.\n    \n6.  Use the default (`ADFS 2.0 profile`), and click **Next**.\n    \n7.  Use the default (`no encryption certificate`), and click **Next**.\n    \n8.  Check **Enable support for the WS-Federation...**, and type this value in the textbox: `https://{yourDomain}/login/callback`,or if you are using a [custom domain](https://auth0.com/docs/customize/custom-domains), use `https://<YOUR CUSTOM DOMAIN>/login/callback`\n    \n9.  Click **Next**.\n    \n10.  Add a Relying Party Trust identifier with this value: `urn:auth0:{yourTenant}`\n    \n11.  Click **Add**, and then **Next**.\n    \n12.  Leave the default `Permit all users...`, and click **Next**.\n    \n13.  Click **Next**, and then **Close**.\n    \n\n## Manual setup part 2: Add a claim issuance policy rule\n\n1.  If you're using Windows Server 2019, the Edit Claim Issuance Policy dialog box automatically opens when you finish the Add Relying Party Trust wizard. If you're using Windows 2012 or 2016, follow these steps:\n    \n    | In Windows Server 2012 | In Windows Server 2016 |\n    | --- | --- |\n    | In the Actions panel on the right side of the console, find the Relying Party Trust you just created. Beneath it, click **Edit Claim Issuance Policy**. | In the console tree, under ADFS, click **Relying Party Trusts**. On the right side of the console, find the Relying Party Trust you just created. Right-click it and click **Edit Claim Issuance Policy**. |\n    \n2.  In the Edit Claim Issuance Policy Window, under Issuance Transform Rules, click **Add Rule...**.\n    \n3.  Leave the default `Send LDAP Attributes as Claims`.\n    \n4.  Give the rule a name that describes what it does.\n    \n5.  Under Attribute Store, select **Active Directory**.\n    \n6.  Select these mappings under `Mapping of LDAP attributes to outgoing claim types`, and click **Finish**.\n    \n    | LDAP Attribute | Outgoing Claim Type |\n    | --- | --- |\n    | E-Mail-Addresses | E-Mail Address |\n    | Display-Name | Name |\n    | User-Principal-Name | Name ID |\n    | Given-Name | Given Name |\n    | Surname | Surname |\n    \n\n### Add additional LDAP attributes\n\nThe mappings in the previous steps are the most commonly used, but if you need additional LDAP attributes with information about the user, you can add more claim mappings.\n\n1.  If you closed the window on the previous step, select **Edit Claim Rules** on the context menu for the Relying Party Trust you created, and edit the rule.\n    \n2.  Create an additional row for every LDAP attribute you need, choosing the attribute name in the left column and desired claim type in the right column.\n    \n3.  If the claim type you are looking for doesn't exist, you have two options:\n    \n    1.  Type a [namespace-qualified name](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims) for the new claim (for example, `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/department`).\n        \n    2.  Register a new claim type (under **ADFS > Services > Claim Descriptions** on the ADFS admin console), and use the claim name in the mapping. Auth0 uses the name part of the claim type (for example `department` in `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/department`) as the attribute name for the user profile.\n        \n\n## Next Steps\n\nNow that you have a working connection, the next step is to configure your application to use it. You can follow our step-by-step quickstarts or use our libraries and API.\n\n*   [Get started with our Quickstarts](https://auth0.com/docs/quickstarts)\n    \n*   [Configure your application using our Lock login form](https://auth0.com/docs/libraries/lock)\n    \n*   [Configure your application using our Auth0.js library and your own UI](https://auth0.com/docs/libraries/auth0js)\n    \n*   [Use our Authentication API to authenticate](https://auth0.com/docs/api/authentication)",
  "title": "Connect Your App to ADFS",
  "description": "Learn how to connect your application to Active Directory Federation Services (ADFS) using enterprise connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings",
  "markdown": "# SAML Identity Provider Configuration Settings\n\n## Common settings\n\nThese are the settings used to configure a SAML identity provider (IdP).\n\n### post-back URL\n\nWhen using IdP-Initiated SSO, make sure to include the connection parameter in the post-back URL:\n\n```\nhttps://{yourDomain}/login/callback?connection={yourConnectionName}\n```\n\nIf you are using the [Organizations](https://auth0.com/docs/manage-users/organizations) feature, you can optionally include an organization parameter containing the organization ID of the desired organization:\n\n```\nhttps://{yourDomain}/login/callback?connection={yourConnectionName}&organization={yourCustomersOrganizationId}\n```\n\n### Entity ID\n\nThe ID of the service provider is:\n\n```\nurn:auth0:{yourTenant}:{yourConnectionName}\n```\n\nYou can create a custom Entity ID using the property `connection.options.entityId`. To learn more, read [Specify a Custom Entity ID](https://auth0.com/docs/connections/enterprise/saml#specify-a-custom-entity-id).\n\nYou can obtain the custom Entity ID value using the Get a Connection endpoint:\n\n*   [cURL](#4c28d9bb601f4acd926f9431a4450f84_shell)\n*   [C#](#4c28d9bb601f4acd926f9431a4450f84_csharp)\n*   [Go](#4c28d9bb601f4acd926f9431a4450f84_go)\n*   [Java](#4c28d9bb601f4acd926f9431a4450f84_java)\n*   [Node.JS](#4c28d9bb601f4acd926f9431a4450f84_node)\n*   [Obj-C](#4c28d9bb601f4acd926f9431a4450f84_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D' \\\n  --header 'authorization: Bearer {yourAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D\")\n  .header(\"authorization\", \"Bearer {yourAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D',\n  headers: {authorization: 'Bearer {yourAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/connections/%7ByourConnectionID%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/%7ByourConnectionID%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nReplace the `ACCESS_TOKEN` header value, with a Management APIv2 access token.\n\n### SAML Request Binding\n\nAlso called the **Protocol Binding**, is sent to the IdP from Auth0. If possible, dynamically set the value based on `connection.options.protocolBinding`:\n\n| `connection.options.protocolBinding` value | SAML Request Binding value |\n| --- | --- |\n| Empty value (\"\") or not present | `HTTP-Redirect` |\n| `urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect` | `HTTP-Redirect` |\n| `urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST` | `HTTP-POST` |\n\nIf dynamically setting the value isn't possible, then set as either `HTTP-Redirect` (default) or `HTTP-Post` if you selected this option in **Protocol Binding**.\n\n### SAML Response Binding\n\nHow the SAML token is received by Auth0 from IdP, set as `HTTP-Post`.\n\n### NameID format\n\nUnspecified.\n\n### SAML assertion and response\n\nThe SAML assertion, and the SAML response can be individually or simultaneously signed.\n\n### SingleLogout service URL\n\nThis is where the SAML identity provider will send logout requests and responses:\n\n```\nhttps://{yourDomain}/logout\n```\n\nSAML logout requests must be signed by the identity provider.\n\n## Signed assertions\n\nUse the following links to obtain the public key in different formats:\n\n*   [CER](https://{yourdomain}/cer?cert=connection)\n    \n*   [PEM](https://{yourdomain}/pem?cert=connection)\n    \n*   [raw PEM](https://{yourdomain}/rawpem?cert=connection)\n    \n*   [PKCS#7](https://{yourdomain}/pb7?cert=connection)\n    \n*   [Fingerprint](https://{yourdomain}/fingerprint?cert=connection)\n    \n\nDownload the certificate in the format requested by the IdP.\n\n### IdP-initiated Single Sign-on\n\nTo learn about IdP-initiated SSO, read [Configure SAML IdP-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on).\n\n## Metadata\n\nSome SAML identity providers can accept importing metadata directly with all the required information. You can access the metadata for your connection in Auth0 here:\n\n```\nhttps://{yourDomain}/samlp/metadata?connection={yourConnectionName}\n```\n\n## Organizations\n\nUse the ACS URL for your organization in the federated IdP to start the Organizations login flow.\n\n```\nhttps://{yourDomain}/samlp?connection={yourConnectionName}&organization=${yourOrgID}\n```\n\n## Learn more\n\n*   [Locate the Connection ID or Name](https://auth0.com/docs/authenticate/identity-providers/locate-the-connection-id)\n*   [Customize SAML Assertions](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)",
  "title": "SAML Identity Provider Configuration Settings",
  "description": "Describes the SAML identity provider configuration settings. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions",
  "markdown": "# Customize SAML Assertions\n\n`audience` string Audience of the SAML assertion. Default is issuer on SAMLRequest. `recipient` string Recipient of the SAML assertion (`SubjectConfirmationData`). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent. `issuer` string Unique identifier of the SAML identity provider, formatted as a URL. `mappings` object Mappings between Auth0 profile and the output attributes on the SAML assertion. Default mapping is shown above. `createUpnClaim` boolean Whether or not a UPN claim should be created. Default is `true`. `passthroughClaimsWithNoMapping` boolean If `true` (default), for each claim that is not mapped to the common profile, Auth0 passes through those in the output assertion. If `false`, those claims won't be mapped. `mapUnknownClaimsAsIs` boolean If `passthroughClaimsWithNoMapping` is `true` and this is `false` (default), for each claim not mapped to the common profile Auth0 adds a prefix `http://schema.auth0.com`. If `true` it will pass through the claim as-is. `mapIdentities` boolean If `true` (default), it adds more information in the token such as the provider (Google, ADFS, AD, etc.) and the access token, if available. `signatureAlgorithm` string Signature algorithm to sign the SAML assertion or response. Default is `rsa-sha1`. `digestAlgorithm` string Digest algorithm to calculate digest of the SAML assertion or response. Default is `sha1`. `destination` object Destination of the SAML response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest. `lifetimeInSeconds` integer Expiration of the token. Default is `3600` seconds (1 hour). `signResponse` boolean Whether or not the SAML response should be signed. By default the SAML assertion will be signed, but not the SAML response. If `true`, SAML Response will be signed instead of SAML assertion. `nameIdentifierFormat` string Default is `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`. `nameIdentifierProbes` array Auth0 will try each of the attributes of this array in order. If one of them has a value, it will use that for the `Subject/NameID`. The order is: `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier (mapped from user_id)`, `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress (mapped from email)`, `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name` (mapped from name). `authnContextClassRef` string Default is `urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified`. `typedAttributes` boolean Default is `true`. When set to `true`, we infer the `xs:type` of the element. Types are `xs:string`, `xs:boolean`, `xs:double` and `xs:anyType`. When set to `false` all `xs:type` are `xs:anyType`. `includeAttributeNameFormat` boolean Default is `true`. When set to `true`, we infer the `NameFormat` based on the attribute name. `NameFormat` values are `urn:oasis:names:tc:SAML:2.0:attrname-format:uri`, `urn:oasis:names:tc:SAML:2.0:attrname-format:basic` and `urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified`. If set to `false`, the attribute `NameFormat` is not set in the assertion. `logout` object Controls SAML logout. It can contain two properties:`callback` (string) that contains the service provider (client application) Single Logout Service URL, where Auth0 will send logout requests and responses, and `slo_enabled`(boolean) that controls whether Auth0 should notify service providers of session termination. The default value is`true` (notify service providers). `binding` string Optionally indicates the protocol binding used for SAML logout responses. By default Auth0 uses `HTTP-POST`, but you can switch to `HTTP-Redirect` by setting `\"binding\"` to `\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"`. `signingCert` string Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `\"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"`.",
  "title": "Customize SAML Assertions",
  "description": "Describes how to customize SAML assertions and the SAML and WS-Fed protocol parameters.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/deprovision-users-in-saml-integrations",
  "markdown": "# Deprovision Users in SAML Integrations\n\nIf you need to remove application access for users, you'll need to deprovision them at a minimum with the identity provider. Depending on the identity provider, the steps required to deprovision a user account vary. Check with your provider for further instructions.\n\nOnce a user's account is removed or disabled with the identity provider, the user will not be able to log in.\n\nYou may also want to remove the Auth0 user accounts for those who've been deprovisioned if Auth0 is the service provider or if your app integrates with Auth0. Regardless of whether Auth0 is the identity or service provider, you can remove users using the [Dashboard](https://manage.auth0.com/#/users) or using the Management API.\n\n## Learn more\n\n*   [Remove Permissions from Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/remove-permissions-from-users)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors)",
  "title": "Deprovision Users in SAML Integrations",
  "description": "Learn how to deprovision users of your SAML integration.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/saml-attribute-mapping-examples",
  "markdown": "# Map SAML Attributes with Auth0 as IdP/SAML Add-on\n\nWhen Auth0 is the IdP, you can map user attributes through Auth0's SAML2 add-on. Errors could occur if attributes are misconfigured. For example, a user enters username and password successfully, but fails to sign in to the application even though logs in the Auth0 Dashboard show successful login events. Or, your application is missing user information such as name or email.\n\n## Use cases\n\nThe user profile below is the example for the following scenarios.\n\n```\n//SAMPLE IdP User Profile\n{\n   \"created_at\": \"2021-06-21T13:26:08.579Z\",\n   \"email\": \"testuser@example.com\",\n...\n   \"fav_genre\": \"fiction\",\n   \"user_metadata\": {\n       \"fav_streaming_service\": \"hulu\"\n   }\n...\n}\n```\n\n#### No mappings object\n\nWhen using the SAML2 add-on, an empty mappings object generates by default.\n\nIn this example, `fav_genre` and `user_metadata.fav_streaming_service` are undefined but can be customized and mapped to the SAML Response populated by Auth0.\n\nIn the example below, `\"fav_genre\": \"fiction\"` gets mapped to the  [http://schemas.auth0.com/fav\\_genre](http://schemas.auth0.com/fav_food) attribute in the SAML Response with the `fiction` value while`\"user_metadata\": {\"fav_streaming_service\": \"hulu\"}` does not appear in the SAML response at all.\n\nResulting SAML Response that the IdP sends:\n\n```\n<samlp:Response xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\" ID=\"_e30cb5f29249a82846eb\" InResponseTo=\"_e33996d83f953ce46225185b3a1c0ad8\" Version=\"2.0\" IssueInstant=\"2021-11-03T21:34:42.493Z\" Destination=\"https://example-dev-tenant.us.auth0.com/login/callback\">\n...\n       <saml:AttributeStatement xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n           <saml:Attribute Name=\"http://schemas.auth0.com/fav_genre\" NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\">\n               <saml:AttributeValue xsi:type=\"xs:string\">\n                   fiction\n               </saml:AttributeValue>\n           </saml:Attribute>\n...\n       </saml:AttributeStatement>\n   </saml:Assertion>\n</samlp:Response>\n```\n\n#### Standard mappings example\n\nIn the earlier example, not customizing the mappings object resulted in a [http://schemas.auth0.com/fav\\_genre](http://schemas.auth0.com/fav_food) attribute in the SAML Response with the `\"fiction\"` value.\n\nNext, map the attributes in the Mappings Object of the SAML2 add-on settings to account for that.\n\nAfter doing so, notice how the `\"fiction\"` value is the same in the SAML Response, but the attribute name in the SAML Response has been changed from the default [http://schemas.auth0.com/fav\\_fiction](http://schemas.auth0.com/fav_food) to [http://schemas.auth0.com/books](http://schemas.auth0.com/dinner).\n\nConfiguring the SAML2 add-on mappings object:\n\n```\n\"mappings\": {\n   \"fav_genre\": \"http://schemas.auth0.com/books\"\n }\n```\n\nThis mapping results in the following response:\n\n```\n<samlp:Response xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\" ID=\"_e30cb5f29249a82846eb\" InResponseTo=\"_e33996d83f953ce46225185b3a1c0ad8\" Version=\"2.0\" IssueInstant=\"2021-11-03T21:34:42.493Z\" Destination=\"https://example-dev-tenant.us.auth0.com/login/callback\">\n...\n       <saml:AttributeStatement xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n           <saml:Attribute Name=\"http://schemas.auth0.com/books\" NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\">\n               <saml:AttributeValue xsi:type=\"xs:string\">\n                   fiction\n               </saml:AttributeValue>\n           </saml:Attribute>\n...\n       </saml:AttributeStatement>\n   </saml:Assertion>\n</samlp:Response>\n```\n\n#### Mapping the same value to multiple attributes\n\nThere may be scenarios where mapping the SAML Response to multiple attributes with the same value is required.\n\nIn this case, there is the option to map the same value from the user profile to multiple attributes in the SAML Response.\n\nHow to configure the SAML2 add-on mappings object:\n\n```\n\"mappings\": {\n   \"fav_genre\": [\n     \"http://schemas.auth0.com/movies\",\n     \"http://schemas.auth0.com/books\",\n     \"http://schemas.auth0.com/television\"\n   ]\n }\n```\n\nThis mapping results in the following response:\n\n```\n<samlp:Response xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\" ID=\"_e30cb5f29249a82846eb\" InResponseTo=\"_e33996d83f953ce46225185b3a1c0ad8\" Version=\"2.0\" IssueInstant=\"2021-11-03T21:34:42.493Z\" Destination=\"https://example-dev-tenant.us.auth0.com/login/callback\">\n...\n       <saml:AttributeStatement xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n           <saml:Attribute Name=\"http://schemas.auth0.com/movies\" NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\">\n               <saml:AttributeValue xsi:type=\"xs:string\">\n                   fiction\n               </saml:AttributeValue>\n           </saml:Attribute>\n           <saml:Attribute Name=\"http://schemas.auth0.com/books\" NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\">\n               <saml:AttributeValue xsi:type=\"xs:string\">\n                   fiction\n               </saml:AttributeValue>\n           </saml:Attribute>\n           <saml:Attribute Name=\"http://schemas.auth0.com/television\" NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\">\n               <saml:AttributeValue xsi:type=\"xs:string\">\n                   fiction\n               </saml:AttributeValue>\n           </saml:Attribute>\n...\n       </saml:AttributeStatement>\n   </saml:Assertion>\n</samlp:Response>\n```",
  "title": "Map SAML Attributes with Auth0 as IdP/SAML Add-on",
  "description": "Provides examples how to map SAML attributes when Auth0 is the identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/configure-auth0-as-service-and-identity-provider",
  "markdown": "# Test SAML SSO with Auth0 as Service Provider and Identity Provider\n\nYou can configure Auth0 as both the service provider (SP) and the identity provider (IdP) to test your SAML single sign-on (SSO) connection.\n\n![Protocols Auth0 as SAML SP and IdP Diagram](https://images.ctfassets.net/cdy7uua7fh8z/7Ds9dLC3HaxGBLsG3ry7B9/0c08d51b6d6bb57ef6eff3796ca4cd21/saml-case3.png)\n\nAuth0 only supports using Auth0 as the SP in SAML configurations with SAML 1.1 or SAML 2.0 while you can use Auth0 as the IdP in SAML configurations with SAML 2.0.\n\nYou can set up a simple example application for testing that uses Auth0 to authenticate users through SAML SSO using one tenant as the SAML SP and another tenant as the SAML IdP. You will configure two federations for one tenant.\n\n## Create IdP tenant\n\nIf you do not already have a secondary Auth0 tenant to serve as a SAML IdP, you will need to create one:\n\n1.  Go to the [Auth0 Dashboard](https://manage.auth0.com/#/), select your tenant name and select **Create Tenant**.\n    \n    ![Dashboard Tenant Drop-Down Menu Create Tenant](https://images.ctfassets.net/cdy7uua7fh8z/53KetqhNIGDs6N5cqJdQtz/a8ab19657d5070e1d3c121c3ad8d18d4/dashboard-tenant-drop-down-menu.png)\n2.  Enter a **Domain**, select a **Region**, and click **Create**.\n    \n    ![Dashboard Tenant Drop Down Menu Create Tenant](https://images.ctfassets.net/cdy7uua7fh8z/68loKS3C0dxUlSjKhZPYSG/856a0b27795360ebc8c042a0db941e5e/dashboard-tenant-menu-create-tenant.png)\n\n## Configure IdP tenant\n\nConfigure your secondary tenant as an IdP, and register an application to represent your SP tenant.\n\n1.  Switch to your IdP tenant. Open the tenant menu, select **Switch Tenant**, and then select your IdP tenant.\n    \n2.  Navigate to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select **Create Application**.\n    \n3.  Enter a name for the application, such as `my-auth0-idp`, select **Regular Web Application** for the application type, and then select **Create**.\n    \n4.  Go to the bottom of the **Settings** page, and select **Show Advanced Settings**.\n    \n5.  Switch to the **Certificates** view, then select **Download Certificate**, and choose **PEM**. The certificate will download. You will use this certificate when you configure the SP tenant.\n    \n6.  Switch to the **Endpoints** view, locate **SAML Protocol URL**, and copy its contents. You will use this URL when you configure the SP tenant.\n    \n\n## Create user to test SAML sequence\n\n1.  Go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users) and select **Create User**.\n    \n2.  Enter an email address for your test user. The domain name should match the service provider tenant email domain that you will configure next. For example, if your user is `john.doe@exampleco.com`, you should enter `exampleco.com` for the email domain.\n    \n3.  Enter a password for the test user.\n    \n4.  Use the default value for **Connection**.\n    \n5.  Select **Create**.\n    \n\n## Configure service provider tenant\n\nConfigure the SP tenant to communicate with the IdP tenant for SSO using the SAML protocol.\n\n1.  Switch to your SP tenant. Open the tenant menu, select **Switch Tenant**, and then select your SP tenant.\n    \n2.  Go to [Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise) and select **SAML**.\n    \n3.  Select **Create Connection**.\n    \n4.  Enter the following information, and select **Create**:\n    \n    | Setting | Description |\n    | --- | --- |\n    | Connection Name | Enter any name, such as `SAML-Auth0-IDP`. |\n    | Sign In URL | Enter the SAML Protocol URL value that you copied in above. |\n    | Sign Out URL | Enter the same URL as for the Sign In URL above. |\n    | X509 Signing Certificate | Click on the red **UPLOAD CERTIFICATE...** button and select the `.pem` file you downloaded above. |\n    \n5.  Switch to the **Setup** view to see the metadata associated with the tenant. Copy and save the URL.\n    \n6.  Open a new browser tab and navigate to the URL you copied previously. (If you are logged in on the Auth0 Docs site, the settings will pre-populate with the correct values.)\n    \n    1.  Locate **Entity ID**, and then copy and save its contents. It will look like: `urn:auth0:{yourTenant}:{yourConnectionName}`. Replace `{yourConnectionName}` with the name of the connection you created for your IdP tenant.\n        \n    2.  Locate **Metadata**, and copy and save the provided URL. It will look like: `https://{yourDomain}/samlp/metadata?connection={yourConnectionName}`. Replace `{yourConnectionName}` with the name of the connection you created for your IdP tenant.\n        \n    3.  Go to the URL you previously copied to display the metadata for this connection in the SP tenant. Alternatively, your browser may prompt you to save the metadata file.\n        \n    4.  Locate the row that starts with **AssertionConsumerService**, and copy and save the value of the **Location** field. It will be a URL of the form: `https://{yourDomain}/login/callback?connection={yourConnectionName}`. This is the URL on your SP tenant that receives the SAML assertion from the IdP tenant. In the next section, you will provide this URL to the IdP tenant so it knows where to send the SAML assertion.\n        \n\n## Add service provider metadata to IdP\n\nAdd information about the SP tenant to the IdP tenant so it knows how to receive and respond to SAML authentication requests.\n\n1.  Switch to your IdP tenant. Open the tenant menu, select **Switch Tenant**, and then select your IdP tenant.\n    \n2.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the name of the IdP application you created previously.\n    \n3.  Switch to the **Addons** view.\n    \n4.  Select **SAML2 Web App** to view its options, and locate the **Application Callback URL**. Paste the **AssertionConsumerService URL** that you copied previously.\n    \n5.  In the **Settings** code block, locate the `audience` key, and uncomment it, then remove the comma from the end of the line and replace the original value (`urn:foo`) with the **Entity ID** value you copied previously (including the connection name you created in Step 4 when you configured your service provider tenant). The new line should look like: \"`audience\":\"urn:auth0:{yourTenant}:{yourConnectionName}\"`.\n    \n6.  Select **Enable**.\n    \n\n## Test IdP\n\n1.  In the same window, scroll up, and select **Debug**. A login screen will appear.\n    \n2.  Log in with the credentials of the test user you created above. If your configuration is correct, it will display \"It works!\", and the encoded and decoded SAML response that would be sent to the IdP.\n    \n3.  Check the decoded SAML response, locate `<saml:Audience>`, and make sure it matches the **Entity ID** you entered on the previous screen.\n    \n4.  Select **Close this window**.\n    \n\n## Create application to test SAML connection\n\nCreate a simple application to test the SAML connection you created.\n\n1.  Switch to your SP tenant. Open the tenant menu, select **Switch Tenant**, and then select your SP tenant.\n    \n2.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select **Create Application**.\n    \n3.  Enter an application name, select **Regular Web Application** as the application type, and then select **Create**.\n    \n4.  Copy and save the **Domain** and **Client ID** values.\n    \n5.  Locate the **Allowed Callback URLs** field, and enter `http://jwt.io`. This is the list of allowed callback URLs to which users will be redirected after authentication. The URL(s) entered here must match the callback URL in the HTML code created in the next step. Normally you would enter a URL for your application, but to keep this example simple, the test user will be sent to the Auth0 JWT online tool, which provides some information about the JSON Web Token (JWT) returned at the end of the authentication sequence.\n    \n6.  Select **Save Changes**.\n    \n7.  Switch to the **Connections** view, locate the SAML connection you created under the **Enterprise** section, and enable it.\n    \n\n## Test connection between service and identity provider\n\nTest to ensure the SAML configuration between your SP tenant and IdP tenant works.\n\n1.  Go to [Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise) and select **SAML**.\n    \n2.  Locate the SAML connection you created, and select the **Try** arrow icon. Since you previously logged in while testing this connection, you should be sent directly to the \"It works!\" screen. If you see the login screen, log in using your test user's credentials.\n    \n\nIf the configuration is set up correctly, you will see \"It works!\", and the page will display the contents of the SAML authentication assertion sent by the IdP tenant to the Auth0 tenant.\n\nIf it is not configured correctly, double-check your steps. If you are still having trouble, consult the troubleshooting section at the end of this document.\n\n## Create a web page for test application\n\nCreate a simple web page that invokes the Lock widget triggering the SAML login sequence.\n\n1.  Create an HTML page, and insert the following HTML and JavaScript code. Replace `{yourClientId}` and `{yourDomain}` with the actual values of the application you registered above. (If you did not note those values, you can find them in the **Application Settings** on your SP tenant.)\n    \n    ```\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <body>\n      <button type=\"button\" onclick=\"login()\">Log in</button>\n      <script src=\"https://cdn.auth0.com/js/auth0/9.19.0/auth0.min.js\"></script>\n      <script>\n        var auth0 = new auth0.WebAuth({\n          domain: YOUR_AUTH0_DOMAIN,\n          clientID: YOUR_CLIENT_ID,\n          redirectUri: URL_TO_THIS_PAGE,\n          responseType: 'token id_token',\n          scope: 'openid email profile'\n        })\n    \n        auth0.parseHash(function(err, data) {\n          if (err) {\n            console.log(err)\n          }\n    \n          if (data) {\n            console.log('Login successful!')\n            console.log(data)\n          }\n        })\n    \n        window.login = function() {\n          auth0.authorize()\n        }\n      </script>\n    \n    </body>\n    </html>\n    ```\n    \n2.  You can also replace `audience` with the appropriate value for your application, but for the purposes of this test, a placeholder is sufficient. If you do specify the `audience` parameter, ensure that it matches an identifier of an existing API you have configured in Auth0.\n    \n3.  Save the HTML file where you can access it from a browser.\n    \n\n## Test sample application\n\nTest the sample HTML application that uses the Auth0 SAML connection you created in your SP tenant to perform SSO authentication against the IdP tenant.\n\n1.  Open the HTML file you created above with a browser. You should see a login button.\n    \n2.  Click **Login**. You should see the Lock widget with one option. If you have other connections turned on for your application, the screen may look different. If you are prompted for an email address, make sure the email address you enter has the same domain name as the domain you entered in the **Settings** view for the application in the first tenant.\n    \n3.  Click the blue button, which may say **saml** or **ACCESS**. Whether you are prompted for credentials or immediately redirected to the callback URL depends on whether you still have an active session.\n    \n\n## Troubleshoot test scenario\n\n*   Clear your browser history and cookies each time before you test. If you do not, the browser may not pick up the latest version of your HTML page, or it may have stale cookies that affect execution.\n    \n*   Capture an HTTP trace of the interaction. Many tools will capture the HTTP traffic from your browser for analysis.\n    \n    *   Search the internet for \"HTTP Trace\" to find and install a tool.\n        \n    *   Capture the login sequence from start to finish and analyze the trace. Track the sequence of GETs to see how far in the expected sequence you get. You should see a redirect from your original site to the SP tenant and then to the IdP tenant, a POST of credentials if you had to log in, then a redirect back to the callback URL or the SP tenant, and then a redirect to the **Callback URL** specified in your application.\n        \n*   Ensure that cookies and JavaScript are enabled for your browser.\n    \n*   Ensure that the **Callback URL** specified in the HTML file is also listed in the **Allowed Callback URLs** field for your application. To do so, go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the name of your application, then locate **Allowed Callback URLs**.\n    \n*   Use the [http://samltool.io](http://samltool.io/) tool to decode a SAML assertion.\n    \n\n## Learn more\n\n*   [SAML Single Sign-On Integrations](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations)\n*   [Customize SAML Assertions](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)\n*   [Deprovision Users in SAML Integrations](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/deprovision-users-in-saml-integrations)\n*   [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)\n*   [Sign and Encrypt SAML Requests](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/sign-and-encrypt-saml-requests)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)",
  "title": "Test SAML SSO with Auth0 as Service Provider and Identity Provider",
  "description": "Describes how to configure SAML SSO with Auth0 as both the service provider and identity provider for testing.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations",
  "markdown": "# SAML Single Sign-On Integrations\n\nWhen you implement SAML single sign-on (SSO), it's important to consider:\n\n*   Which system(s) will serve as the authoritative source for user profile information if there's ever a conflict between two or more sources.\n    \n*   What user profile attributes each application needs.\n    \n*   How user profile information will be distributed to the systems that need it.\n    \n\n## Identity provider-initiated SSO\n\nYou typically set up a SAML federation by configuring SSO initiated by the service provider. The service provider returns a browser redirect so that the user authenticates using the IdP. After authentication, the browser redirects the user back to the service provider with a SAML assertion containing information about the authentication status. This is commonly used for consumer-facing scenarios.\n\nYou can also configure the IdP to initiate SSO instead of the service provider. In this scenario, the user invokes a URL on the IdP and is prompted to authenticate, then is redirected to the service provider with a SAML assertion. This is commonly used in enterprise scenarios. To learn more, read [Configure SAML Identity Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on).\n\n## Auth0 as identity provider for SAML SSO integrations\n\nSome of the following integrations make use of the Auth0 SAML2 Web App addon.\n\n*   [Amazon Web Services](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)\n    \n*   [Atlassian](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-atlassian)\n    \n*   [Cisco-WebEx](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-cisco-webex)\n    \n*   [DataDog](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-datadog)\n    \n*   [Egencia](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-egencia)\n    \n*   [Freshdesk](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-freshdesk)\n    \n*   [GitHub Enterprise Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n    \n*   [GitHub Enterprise Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n    \n*   [Google Workspace](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-idp-for-google-g-suite)\n    \n*   [Heroku](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-heroku)\n    \n*   [Hosted Graphite](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-hosted-graphite)\n    \n*   [Litmos](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-litmos)\n    \n*   [Oracle Eloqua Marketing Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-addon-eloqua)\n    \n*   [PluralSight](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-pluralsight)\n    \n*   [Sprout Video](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-sprout-video)\n    \n*   [Tableau Online](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-online)\n    \n*   [Tableau Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-server)\n    \n*   [Workday](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workday)\n    \n*   [Workpath](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workpath)\n    \n\nTo learn more, read [Enable SAML2 Web App Addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon).\n\n## Other SAML identity provider SSO integrations\n\nAuth0 provides SSO integrations for using the following services as identity providers:\n\n*   [ADFS](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-adfs-saml-connections)\n    \n*   [Okta](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-okta-as-saml-identity-provider)\n    \n*   [OneLogin](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-onelogin-as-saml-identity-provider)\n    \n*   [PingFederate](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-pingfederate-as-saml-identity-provider)\n    \n*   [Salesforce](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-salesforce-as-saml-identity-provider)\n    \n*   [SiteMinder](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-siteminder-as-saml-identity-provider)\n    \n*   [SSOCircle](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-ssocircle-as-saml-identity-provider)\n    \n\n## Special scenarios\n\nOnce you've set up a basic SAML integration, there are a number of additional requirements you might need to implement so that your integration reflects your needs and requirements.\n\nYou have set up a connection or an application and that you're altering specific settings for an existing SAML integration, not configuring an integration from scratch.\n\nTo learn more about special scenarios, read [Configure Identity Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on) and [Sign and Encrypt SAML Requests](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/sign-and-encrypt-saml-requests).\n\n## Learn more\n\n*   [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)\n*   [Customize SAML Assertions](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)\n*   [Configure SAML Identity Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on)\n*   [Sign and Encrypt SAML Requests](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/sign-and-encrypt-saml-requests)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)",
  "title": "SAML Single Sign-On Integrations",
  "description": "Describes the Security Assertion Markup Language (SAML) for single sign-on (SSO) integration options. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-adfs-saml-connections",
  "markdown": "# Configure ADFS as SAML Identity Provider\n\nCreate a custom SAML connection to Microsoft's Active Directory Federation Services (ADFS) to get more flexibility when configuring your mappings. To create the custom connection, you will need to:\n\n1.  Configure ADFS.\n    \n2.  Create a SAML connection where Auth0 acts as the service provider.\n    \n3.  Edit the Relying Party Trust in ADFS.\n    \n4.  Enable and test your integration.\n    \n\n## Configure ADFS\n\n### Add Relying Party Trust\n\nTo learn how to add a relying party trust, read [Create a relying party trust](https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/operations/create-a-relying-party-trust) at [https://docs.microsoft.com](https://docs.microsoft.com/).\n\n#### Create using federation metadata\n\nFollow the steps on [Create a claims aware Relying Party Trust using federation metadata (MSDN)](https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/operations/create-a-relying-party-trust#to-create-a-claims-aware-relying-party-trust-using-federation-metadata). For the **Federation metadata address** in Step 4, the URL you enter should be in one of these formats:\n\nUS: `https://{yourTenantName}.auth0.com/samlp/metadata?connection={connectionName}`\n\nEU: `https://{yourTenantName}.eu.auth0.com/samlp/metadata?connection={connectionName}`\n\nAU: `https://{yourTenantName}.au.auth0.com/samlp/metadata?connection={connectionName}`\n\nJP: `https://{yourTenantName}.jp.auth0.com/samlp/metadata?connection=CONNECTION_NAME`\n\nCustom domain: `https://{yourTenantName}/samlp/metadata?connection={connectionName}`\n\nOnce you've finished creating the relying party trust, [continue to the next section](#edit-claim-issuance-policy).\n\n#### Create manually\n\n1.  Launch your instance of ADFS and start the **Add Relying Party Trust** wizard.\n    \n2.  On the **Welcome** page, choose **Claims aware** and click **Start**.\n    \n3.  On the **Select Data Source** page, select **Enter data about the relying party manually** and click **Next**.\n    \n4.  On the **Specify Display Name** page, provide a descriptive name for your relying party (the typical format is `urn:auth0:{yourTenant}:{yourConnectionName}`) and a brief description under **Notes**. Be sure to replace `{yourConnectionName}` with a unique name you will also use to create a connection in Auth0 in a later step. If you are unsure of the connection name at this time, you can always edit the connection name later. Click **Next**.\n    \n5.  On the **Configure Certificate** page, click **Next**. (We will come back to configure the certificate later.)\n    \n6.  On the **Configure URL** page, check the box for **Enable support for the SAML 2.0 WebSSO protocol**. The wizard then asks for a **Relying party SAML 2.0 SSO service URL**. For the time being, provide a placeholder URL; we will return to this step later. Click **Next**.\n    \n7.  On the **Configure Identifiers** page, indicate that the **Relying party trust identifier** is `urn:auth0:{yourTenant}:{yourConnectionName}` (or whatever value you used as the display name when you started using the wizard). Click **Next**.\n    \n8.  On the **Choose Access Control Policy** page, select **Permit everyone** and click **Next**.\n    \n9.  Review the settings you provided on the **Ready to Add Trust** page and click **Next** to save your information. If you were successful, you'll see a message indicating that on the **Finish** page.\n    \n10.  Make sure that the **Configure claims issuance policy for this application** checkbox is selected, and click **Close**.\n    \n\n### Edit Claim Issuance Policy\n\nAfter you close the **Add Relying Party Trust** wizard, the **Edit Claim Issuance Policy** window appears.\n\n1.  Click **Add Rule...** to launch the wizard.\n    \n2.  Select **Send LDAP Attributes as Claims** for your **Claim rule template**, and click **Next**.\n    \n3.  Provide a value for the **Claim rule name**, such as \"LDAP Attributes\" (it can be anything you want).\n    \n4.  Choose **Active Directory** as your **Attribute Store**.\n    \n5.  Map your LDAP attributes to the following outgoing claim types:\n    \n    | LDAP Attribute | Outgoing Claim |\n    | --- | --- |\n    | E-Mail-Addresses | E-Mail Address |\n    | Display-Name | Name |\n    | User-Principal-Name | Name ID |\n    | Given-Name | Given Name |\n    | Surname | Surname |\n    \n    The `Name ID` outgoing claim should always be present to ensure correct session handling. We strongly recommend adding all of the claims listed above, especially `E-Mail Address`, since they are the ones most commonly used. You can add additional claim mappings if necessary.\n    \n6.  Click **Finish**.\n    \n7.  In the **Edit Claim Issuance Policy** window, click **Apply**. You can now exit out of this window.\n    \n\n### Export Signing Certificate\n\nFinally, you'll need to export the signing certificate from the ADFS console to upload it to Auth0.\n\n1.  Using the left-hand navigation pane, go to **ADFS > Service > Certificates**. Select the **Token-signing** certificate, and right click to select **View Certificate**.\n    \n2.  On the **Details** tab, click **Copy to File...**. This launches the **Certificate Export Wizard**. Click **Next**.\n    \n3.  Choose **Base-64 encoded X.509 (.CER)** as the format you'd like to use. Click **Next**.\n    \n4.  Provide the location to where you want the certificate exported. Click **Next**.\n    \n5.  Verify that the settings for your certificate are correct and click **Finish**.\n    \n\n## Create SAML connection with Auth0 as service provider\n\n1.  Follow the tutorial on creating a SAML connection where [Auth0 acts as the service provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider). Where prompted, upload the signing certificate you exported from ADFS.\n    \n    The sign in and sign out URLs are usually in the form of `https://your.adfs.server/adfs/ls`.\n    \n2.  Click **Save**. A page with instructions for creating a new Relying Party Trust in ADFS appears displaying the exact values required for your Auth0 account/connection. Make a note of these values. Here is an example:\n    \n    | Parameter | Example Value |\n    | --- | --- |\n    | Post-back URL | `https://<YOUR CUSTOM DOMAIN>/login/callback?connection=YOUR_CONNECTION_NAME` if a custom domain is configured |\n    |     | `https://{yourDomain}/login/callback?connection=YOUR_CONNECTION_NAME` if not using custom domains |\n    | Entity ID | `urn:auth0:{yourTenant}:YOUR_CONNECTION_NAME` |\n    \n\n## Edit Relying Party Trust\n\n1.  In the ADFS console, go to **ADFS > Relying Party Trusts** using the left-hand navigation pane. Select the Relying Party Trust you created earlier and click **Properties** (located on the right-hand navigation pane).\n    \n2.  Select the **Identifiers** tab, and populate the **Relying Party Identifier** with the **Entity ID** value from the previous screen. Be sure to click **Add** to add the identifier to your list.\n    \n3.  Select the **Endpoints** tab, and select the placeholder URL you provided earlier. Click **Edit...**.\n    \n4.  Populate the **Trusted URL** with the **Post-back URL** value.\n    \n5.  Click **OK**. Finally, click **Apply** and exit the Properties window.\n    \n\n## Enable sign requests (optional)\n\nOptionally, you can sign your SAML requests to the ADFS server.\n\n1.  Go to the **Settings** page for your SAML-P Identity Provider in the Auth0 Dashboard.\n    \n2.  Enable **Sign Requests**.\n    \n3.  Just below the **Sign Requests** toggle is a link to download your certificate.\n    \n4.  Return to ADFS and load the downloaded certificate using the **Signatures** tab of the Relying Party properties dialog.\n    \n\n## Enable and test the integration\n\nBefore you test your integration, make sure that you've completed the following steps:\n\n*   Create a user on the identity provider that you can use to test your new connection.\n    \n*   Enable your Connection for at least one application.\n    \n\n1.  Go to [Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n2.  Select the connection that you want to test and click the ellipses (...) then click **Try**. The Microsoft Sign in screen will appear. Sign in and click **Next**.\n    \n\n## Learn more\n\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)",
  "title": "Configure ADFS as SAML Identity Provider",
  "description": "Learn how to configure a SAML connection against ADFS in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-okta-as-saml-identity-provider",
  "markdown": "# Configure Okta as SAML Identity Provider\n\nYou can configure Okta as a SAML identity provider (IdP) in Auth0 by configuring a SAML Enterprise connection.\n\n## Configure Okta SAML app integration\n\nYou can create a SAML app integration in the Okta Developer Console.\n\n### Create app integration\n\n1.  Log in to the [Okta Developer Console](https://login.okta.com/).\n    \n2.  Go to **Create App Integration** and choose **SAML 2.0** from the options.\n    \n3.  Configure the following settings:\n    \n    | **Setting** | **Description** | **Example** |\n    | --- | --- | --- |\n    | Single Sign-On URL | Auth0 tenant login callback URL. | `https://{yourAuth0Domain}/login/callback?connection={yourAuth0ConnectionName}` |\n    | Audience URI (SP Entity ID) | Auth0 connection audience value. | `urn:auth0:{yourAuth0TenantName}:{yourAuth0ConnectionName}` |\n    \n4.  Select **Next**, and then select **Finish** to complete the Okta app integration configuration.\n    \n\n### Record SSO URL and download certificate\n\nThe login flow is now directed to the **Sign On** page for the newly-created app.\n\n1.  Select **View SAML Setup Instructions**.\n    \n2.  Record the **Identity Provider Single Sign-On URL**.\n    \n3.  Download the **X.509 Certificate** in PEM or CER format.\n    \n4.  Navigate to **Assignments**, and then assign a user to the Okta application.\n    \n\n## Configure SAML connection in Auth0\n\nYou can create a SAML Enterprise connection in the Auth0 Dashboard.\n\n1.  Log in to the [Auth0 Dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n3.  Select **Create** (**+** button) next to **SAML**.\n    \n4.  Configure the following settings:\n    \n    | **Setting** | **Description** | **Example** |\n    | --- | --- | --- |\n    | Connection name | Auth0 connection name. | `myoktaconnection` |\n    | Sign In URL | Okta URL where user login requests are sent.<br><br>This is the **Identity Provider Single Sign-On URL** value you recorded previously. | `https://my_okta_tenant_name.okta.com/app/` `my_okta_tenant_namemy_okta_saml_app_integration_name/` `dakflkbzevu5i5zBi939/sso/saml` |\n    | X509 Signing Certificate | Okta tenant public key signing certificate.<br><br>Upload the **X509 Certificate** you downloaded previously. | `myOktaTenantSigningCertificate.pem` |\n    \n5.  Select **Create**.\n    \n\n## Enable SAML Enterprise connection in Auth0\n\nYou can enable your SAML Enterprise connection in the Auth0 Dashboard.\n\n### Enable SAML Enterprise connection when using Organizations\n\nIf you’re using Organizations:\n\n1.  Log in to the [Auth0 Dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Organizations](https://manage.auth0.com/#/organizations), and select your Organization.\n    \n3.  Switch to the **Connections** view.\n    \n4.  Select **Enable Connections**.\n    \n5.  Select the SAML connection you created previously, and then select **Enable Connection**.\n    \n\n### Enable SAML Enterprise connection when not using Organizations\n\nIf you’re not using Organizations:\n\n1.  Log in to the [Auth0 Dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp), and select the SAML connection you created previously.\n    \n3.  Switch to the **Applications** view, and enable the connection for your chosen application(s).\n    \n\n## Test connection\n\nYou can test your connection in the Auth0 Dashboard.\n\n1.  Log in to the [Auth0 Dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n3.  Locate your connection in the list.\n    \n4.  Select **More Actions** (**...** button), and then select **Try**.\n    \n    *   If your connection is configured correctly, you'll see the **It works!** screen.\n        \n    *   If not, you’ll see an error message with details about what went wrong.",
  "title": "Configure Okta as SAML Identity Provider",
  "description": "Learn how to configure Okta as an SAML identity provider (IdP) in Auth0. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-onelogin-as-saml-identity-provider",
  "markdown": "# Configure OneLogin as SAML Identity Provider\n\nConfigure OneLogin as a SAML identity provider by completing the following steps:\n\n1.  Configure OneLogin SAML integration\n    \n2.  Configure SAML connection in Auth0.\n    \n3.  Test connection.\n    \n\n## Prerequisite\n\nYou must have OneLogin developer account.\n\n## Configure OneLogin\n\n1.  Log in to the [OneLogin](https://www.onelogin.com/) Dashboard, and click **Apps** > **Add Apps**.\n    \n2.  Search for **SAML**, and select **SAML Test Connector (IdP w/attr)**.\n    \n3.  When prompted, change the **Display Name** of your app.\n    \n4.  Click **SAVE**.\n    \n5.  Go to the **SSO** tab, and copy the values for **SAML 2.0 Endpoint (HTTP)** and **SLO Endpoint (HTTP)**.\n    \n6.  Click on the **View Details** link at the **X.509 Certificate** field.\n    \n7.  Download the X.509 certificate **onelogin.pem**.\n    \n\n## Configure Auth0 connection\n\n1.  Go to [Dashboard > Authentication > Enterprise > SAMLP](https://manage.auth0.com/#) and click the **plus** icon to be redirected to the page that allows you to create a new Connection.\n    \n2.  You will be prompted to provide the appropriate configuration settings for this Connection. The only mandatory fields are:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **Sign In URL** | The SAML 2.0 Endpoint (HTTP) value you noted when setting up your OneLogin app. |\n    | **Sign Out URL** | The SLO Endpoint (HTTP) value you noted when setting up your OneLogin app. |\n    | **X509 Signing Certificate** | The certificate you downloaded from Onelogin. You will need to upload the certificate directly to Auth0. |\n    \n3.  Click **Save** to proceed.\n    \n4.  In the next window, you'll be provided two options.\n    \n    1.  If you are a domain administrator, you can click **Continue** for additional instructions on SAML Identity Provider Configuration.\n        \n    2.  If you are not, you can give your domain administrator the provided URL so that they can finish the configuration.\n        \n\n### Auth0 configuration values\n\nTo finish configuration of the SAML application, the admin will need the following information regarding Auth0:\n\n*   **SAML Consumer URL**: `https://{yourDomain}/login/callback`\n    \n*   **SAML Audience**: `urn:auth0:{yourTenant}:yourConnectionName`\n    \n\nAlso copy the values of the **post-back URL** and the **Entity ID** before heading back to the Configuration tab of your [OneLogin](https://www.onelogin.com/) app:\n\n| Auth0 value | OneLogin configuration field |\n| --- | --- |\n| Post-back URL | ACS (Consumer) URL and Recipient |\n| Entity ID | Audience |\n\nAlso provide a valid regular expression for the **ACS (Consumer) URL Validator**. For example:\n\n`[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)`\n\n## Test connection\n\nBefore testing your connection:\n\n*   Be sure that you have a OneLogin user that you can use for testing. If not, go to the **Users** tab on the OneLogin dashboard and add one\n    \n*   Be sure that your new Auth0 SAMLP connection has been associated with an application (otherwise you will get an `invalid_request: the connection was disabled` error)\n    \n\nNext to your **SAML** connection, click the **Try** button. If all goes well, you will be redirected to a page informing you that the connection works.\n\n## Identity provider-initiated SSO\n\nOneLogin offers an Application Portal/Launcher to its users. If you want to take advantage of this functionality, you will have to change the **SAML Consumer URL** in OneLogin dashboard to include the `connection` parameter (e.g., `https://{yourDomain}/login/callback?connection=onelogin-customer`). Be sure to replace `onelogin-customer` with the name of your Auth0 connection.\n\nFinally, be sure to enable IdP-initiated login for the connection and pick the application to which your user is redirected after the SAML assertion is consumed. To learn more, read [Configure Identity-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on).\n\n## Edit connection mappings\n\nIf you use OneLogin and Auth0 out of the box, users logging in using OneLogin and created in the Auth0 Dashboard will be missing some profile information you might like to have.\n\nTo collect additional user information, edit the appropriate parameters in the OneLogin dashboard, include the parameters in the SAML assertion, and create the mappings in the Auth0 connection.\n\n### User profile attributes\n\nSometimes the standard User Profile Attributes are not enough for the functionality you want to build. If this is the case, you can use custom attributes in order to enhance the SAML token. Let's work through a basic example.\n\nThe SAML token contains, among others, two attributes: `FirstName` and `LastName`. Let's add a new custom attribute, named `FullName`, that will contain the concatenation of first and last name.\n\n1.  Navigate to the OneLogin dashboard and edit your app.\n    \n2.  On the **Parameters** tab, click **Add Parameter**.\n    \n3.  In the pop-up, set a name for your new custom attribute using the **Field name** text box. Make sure you check the **Include in SAML assertion** flag. Click **Save**.\n    \n4.  The new attribute you created is displayed. Click on the **Value** field, which is currently displaying `- No default -`.\n    \n5.  Click the **Value** dropdown menu and select `- Macro -`.\n    \n6.  At the text box, set the value to `{firstname} {lastname}`. Click **Save**.\n    \n7.  Test our changes. Go back to [Auth0 dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise). On your **SAML** connection, click the **Try** button. The result should include the new attribute `FullName`.\n    \n\nYou can find more information on Attribute Macros at the [OneLogin Help Center](https://support.onelogin.com/hc/en-us/articles/201174464-Attribute-macros).\n\n### Add new parameter to SAML assertion\n\nFor the purposes of demonstration, let's see how we can add the `EmailAddress` information, which is more than the concatenation of two fields we're already sending, to our login.\n\n1.  Before you can map users' **EmailAddress**, you must add this field as a custom parameter to the OneLogin dashboard. Set **Field name** to `EmailAddress` and **Value** as `Email`.\n    \n2.  You can find details on the steps needed to customize the user profile in the section above.\n    \n3.  Once you've made your changes, save them, and test your connection once again.\n    \n4.  Review your Auth0 user, making sure that the `EmailAddress` information is now included and that the value is correct.\n    \n\nYou are now ready to proceed with mapping the user information fields in Auth0.\n\n1.  Go to the **Settings** of your [SAML](https://manage.auth0.com/#/connections/enterprise) and navigate to the tab **Mappings**. For the email addresses, copy the mapping below, and paste it into the text box.\n    \n2.  Save your changes, and try your connection again. Once you have successfully logged in, go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users), and check your login. You will see additional information for the appropriate user.",
  "title": "Configure OneLogin as SAML Identity Provider",
  "description": "Learn how to configure OneLogin as a SAML identity provider for use with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-pingfederate-as-saml-identity-provider",
  "markdown": "# Configure PingFederate as SAML Identity Provider\n\nPingFederate is a federation server that provides identity management, single sign-on, and API security for the enterprise. See the complete PingFederate instructions to [configure PingFederate as an identity provider](https://docs.pingidentity.com/r/en-us/pingfederate-120/pf_ident_provid_sso_config).\n\nTo configure Auth0 to use PingFederate as an identity provider, you will use primarily the default values and your Auth0 tenant metadata file to upload the required configuration parameter values for your Auth0 tenant. If the metadata upload fails for some reason, these are the most important configuration parameters:\n\n*   **EntityID:** `urn:auth0:{yourTenant}:{yourConnectionName}`\n    \n*   **Assertion Consumer Service URL:** `https://{yourDomain}/login/callback`\n    \n*   **Logout URL:** `https://{yourDomain}/logout`\n    \n*   **HTTP-Redirect** binding for SAML Request\n    \n*   **HTTP-POST** binding for SAML Response\n    \n\n1.  Download your Auth0 metadata file from `https://YOUR_DOMAIN/samlp/metadata?connection=YOUR_CONNECTION_NAME`. Make sure that you use your custom domain if you have one configured. You will upload this file to import your Auth0 tenant information into the PingFederate configuration.\n    \n2.  Sign on to your PingFederated account and select **Create New** from the **SP Connections** section.\n    \n3.  Configure the **SP Connection**.\n    \n    *   Select the **Browser SSO Profiles** as the **Connection Type**.\n        \n    *   Select **Browser SSO** as the **Connection Options**.\n        \n4.  Upload the metadata file that you downloaded in step 1. The **Entity ID**, **Connection Name**, and the **Base URL** will be automatically populated based on the information from the metadata file.\n    \n5.  Configure **Browser SSO**.\n    \n    *   Select **SP-Initiated SSO** and **SP-Initiated SLO** in **SAML Profiles**.\n        \n    *   Go to the **Assertion Creation** section and click **Configure Assertion**. Accept all defaults for the next two screens.\n        \n6.  Go to the **IdP Adapter Mapping** section. This is where users will be authenticated. Likely, you already have one configured in your PingFederate installation. Select one, or add a new one. Auth0 only requires the **NameIdentifier** claim. All other attributes will be passed further to the end application.\n    \n7.  Configure **Protocol Settings**. Values for **Protocol Settings** are imported from the metadata file. Next, you will see the **Assertion Consumer Service URL** and the Sign-Out URLs. Click **Next** to the **Allowable SAML Bindings** section.\n    \n8.  Leave **POST** and **Redirect** enabled. Make sure **SAML Assertion** is always signed.\n    \n9.  Configure **Credentials**. On **Digital Signature Settings**, select your signing certificate and make sure you check the option to include it in the `<KeyInfo>` element.\n    \n10.  Configure the certificate used to sign incoming requests. You can download the Auth0 certificate (use `https://{yourTenant}.auth0.com/pem`) and upload it here. Auth0 signs `SAMLRequests` by default; you can change that when you configure the connection.\n    \n11.  Review your settings and set them as **Active** or **Inactive**.\n    \n12.  Click **Save** at the bottom of the screen. You should see the new SP Connection on the **Main** screen.\n    \n\n## Identity provider-initiated SSO\n\nTo use IdP-Initiated SSO, make sure to include the `connection` parameter in the Assertion Consumer Service URL: `https://{yourDomain}/login/callback?connection={yourConnectionName}`.\n\nTo learn how to configure Auth0 to route the incoming SAML responses, read [Configure Identity Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on).",
  "title": "Configure PingFederate as SAML Identity Provider",
  "description": "Describes how to configure PingFederate as a SAML identity provider for use with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-salesforce-as-saml-identity-provider",
  "markdown": "# Configure Salesforce as SAML Identity Provider\n\nConfigure Salesforce as a SAML identity provider by completing the following steps:\n\n1.  Obtain Salesforce certificate and metadata.\n    \n2.  Set up Auth0 as a service provider.\n    \n3.  Configure the Salesforce identity provider (IdP).\n    \n4.  Grant privileges to users in Salesforce.\n    \n5.  Test the connection to the Salesforce IdP.\n    \n\n## Prerequisite\n\nRegister for a [Salesforce.com](http://salesforce.com/) account. You must select one of the account types that include identity provider support.\n\n## Obtain Salesforce certificate and metadata\n\n1.  Log in to your [Salesforce](http://salesforce.com/) account.\n    \n2.  Create your [Salesforce Domain](https://help.salesforce.com/apex/HTViewHelpDoc?id=domain_name_setup.htm&language=en_US).\n    \n3.  Log into your Salesforce domain `https://{yourDomain}.my.salesforce.com` and click on **Setup** on the top right.\n    \n4.  In the Quick Find box, enter Single Sign-On Settings, then select **Single Sign-On Settings**, and then click **Edit**.\n    \n5.  To view the SAML SSO settings, select **SAML Enabled**\n    \n6.  Select the default certificate and click **Save**.\n    \n7.  Click **Download Certificate** to download the identity provider certificate.\n    \n8.  Click **Download Metadata** to download the identity provider metadata.\n    \n\n## Set up Auth0 as a service provider\n\nConfigure Auth0 as a service provider to communicate with the Salesforce identity provider for SSO.\n\n1.  Go to the [Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise) and click **SAML**.\n    \n2.  Click **Create Connection**.\n    \n3.  In the configuration window, enter the following information:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **Connection Name** | Name your connection. For example **SFIDP**. |\n    | **Email Domains** | Enter the email domain name that your users will be loggin in from. For example, if your users have an email domain of `abc-example.com`, enter that into this field. You can enter multiple domains. |\n    | **Sign In URL** | Open the metadata file you downloaded from Salesforce and locate the line that contains the `SingleSignOnService` binding. The value of the `location` attribute on this line is your Sign In URL. It will be something like: `https://{sf-account-name}.my.salesforce.com/idp/endpoint/HttpRedirect` where `{sf-account-name}` is your Salesforce domain name. |\n    | **Sign Out URL** | Enter the same URL you entered for Sign In URL. |\n    \n4.  For the **Certificate**, you convert the certificate downloaded from Salesforce to .pem format with the following command: `openssl x509 -in original.crt -out sfcert.pem -outform PEM` where `original.crt` is the filename of the downloaded .crt file.\n    \n    1.  Click **UPLOAD CERTIFICATE** and select the `.pem` file you just created. (`sfcert.pem` in the example above). You can ignore the rest of the fields for now.\n        \n    2.  Click **SAVE**.\n        \n    3.  Click **CONTINUE**. In the window that appears, SAML metadata for the Auth0 Service Provider will be displayed. Keep this window open since you will need to enter some of this information into Salesforce to finish the configuration.\n        \n\nYou can access the metadata for an Auth0 SAML connection with this URL syntax: `https://{yourDomain}/samlp/metadata?connection={yourConnectionName}`.\n\n## Configure Salesforce as an identity provider\n\nConfigure Salesforce with the metadata from Auth0 so it can receive and respond to SAML-based authentication requests from Auth0.\n\n1.  Open [**salesforce.com**](http://salesforce.com/).\n    \n2.  Go to **Setup** > **Manage Apps**. Click **Connected Apps**.\n    \n3.  Create a new Connected App and fill out the following fields:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **Entity ID** | `urn:auth0:YOUR_TENANT:YOUR_CONNECTION_NAME` |\n    | **ACS URL** | `https://{yourDomain}/login/callback` |\n    | **Subject Type** | `Persistent ID` |\n    | **Name ID Format** | Choose the one with `emailAddress` |\n    | **Issuer** | `https://{your-saleforce-domain}.my.salesforce.com` |\n    \n4.  Click **Save** to complete the configuration.\n    \n\n## Grant privileges to users in Salesforce\n\n1.  Open [**salesforce.com**](http://salesforce.com/) and click **Setup**.\n    \n2.  Under **Manage Users**, click **Profiles**.\n    \n3.  Scroll down to find the profile called **Standard User** (on page 2).\n    \n4.  Click on **Edit** to edit the profile.\n    \n5.  Scroll down to the **Connected App Access** section.\n    \n6.  Check the box next to the name of your connected app to enable it for this profile.\n    \n7.  Click **Save**.\n    \n8.  Under **Manage Users**, click **Users**.\n    \n9.  Click **Edit** to edit your test user and set the profile to **Standard User**. To use a different Salesforce profile, enable the connected app for that profile and ensure that all users that login through the Salesforce Identity Provider have that profile.\n    \n\n## Test connection to Salesforce\n\n1.  Navigate to the [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise) section of the Auth0 dashboard. Select the **SAMLP Identity Provider**.\n    \n2.  Click the **Try** button for the SAML connection you created earlier. You should be redirected from Auth0 to the Salesforce login page.\n    \n3.  Once you are at the **Salesforce login screen**, login with the credentials you provided when you created the Salesforce account.\n    \n    1.  If the SAML configuration works, your browser will be redirected back to an Auth0 page that says **\"It works!!!\"**. This page will display the contents of the SAML authentication assertion sent by the Salesforce IDP to Auth0.\n        \n    2.  If it didn't work, double check the steps above and consult the **troubleshooting** section below.\n        \n\nWhen troubleshooting SSO, it is often helpful to capture an HTTP trace of the interaction and save it in a HAR file. To learn more, read [Generate and Analyze HAR Files](https://auth0.com/docs/troubleshoot/guides/generate-har-files).\n\nOnce you have an http trace tool, capture the login sequence from start to finish and analyze the trace for the sequence of GETs. You should see a redirect from your original site to the IDP, a post of credentials if you had to log in, and then a redirect back to the callback URL. The HAR file will also contain the SAML response.\n\nMake sure that cookies and JavaScript are enabled for your browser.\n\nMake sure that the user's profile in Salesforce has permission to login via the Salesforce IDP (See section 4 above).",
  "title": "Configure Salesforce as SAML Identity Provider",
  "description": "Describes how to Salesforce as SAML identity provider for use with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-siteminder-as-saml-identity-provider",
  "markdown": "# Configure SiteMinder as SAML Identity Provider\n\nConfigure SiteMinder as a SAML identity provider by completing the following steps.\n\n## Prerequisite\n\nYou must have a [SiteMinder](https://www.siteminder.com/login/) account.\n\n## Configure SiteMinder settings\n\nWhen configuring SiteMinder, you will use the default values for most options. You will also need the following Auth0-related values in the configuration steps below:\n\n*   **EntityID:** `urn:auth0:{yourTenant}`\n    \n*   **Assertion Consumer Service URL:** `https://{yourDomain}/login/callback`\n    \n*   **Logout URL:** `https://{yourDomain}/logout`\n    \n*   **HTTP-Redirect** binding for SAML Request\n    \n*   **HTTP-POST** binding for SAML Response\n    \n\n1.  Log into [SiteMinder](https://www.siteminder.com/login/).\n    \n2.  Open the **SAML Service Provider Dialog**.\n    \n3.  Provide an appropriate name for this service provider.\n    \n4.  Define the `NameIdentifier`. There are many ways of generating this for users authenticating with SiteMinder. Typically you will map this value to one of the user properties in the User Directory as `uid`.\n    \n5.  Configure the service provider general SAML properties:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **SP ID** | `urn:auth0:{yourTenant}` |\n    | **SAML Version** | 2.0 |\n    | **Skew Time:** | 30 seconds |\n    \n6.  Configure the **Assertion Consumer Service URL** which is the location where SiteMinder will POST back the SAML token. This Service Provider ({yourTenant}) only supports the `HTTP-POST` binding for SAML Responses. Use: `https://{yourDomain}/login/callback`\n    \n7.  Check the **HTTP-Post** box.\n    \n8.  Configure additional user properties to send in the token. Add any other properties you wish to share about the authenticated user to this Service Provider. Common values are: `name`, `lastname`, `email address`, and so on. This Service Provider will use the `NameIdentifier` defined previously as a unique handle of the user. These attributes will be treated as reference information.\n    \n9.  Enter the **SLO Location URL:** `https://{yourDomain}/logout`\n    \n10.  (Optional) The service provider supports encryption of assertions. To use this option, do the following to download the Service Provider public key certificate.\n    \n    1.  In the Auth0 Dashboard, click on **Connections** and then **Enterprise.**\n        \n    2.  Click on SAMLP Identity Provider.\n        \n    3.  Click on the setup icon (pencil).\n        \n    4.  In the window which appears, the seventh (last) bullet gives you links to download the .pem or .cer format certificate.\n        \n    5.  Download the desired certificate and add it to the SiteMinder **Policy Server Keystore**.",
  "title": "Configure SiteMinder as SAML Identity Provider",
  "description": "Learn how to configure SiteMinder as a SAML identity provider for use with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock/selecting-from-multiple-connection-options",
  "markdown": "# Select from Multiple Connection Options\n\nWith Auth0 you can offer users multiple methods of authenticating. This is important with SaaS or multi-tenant apps, where many organizations use a single app. Each organization might use different systems such as LDAP, Active Directory, Google Workspace, or username/password stores.\n\nIn Auth0, you can associate different connections (methods of authentication) to specific applications, or directly to a tenant (as [domain connections](https://auth0.com/docs/authenticate/identity-providers/promote-connections-to-domain-level)). When a user logs in, one of these connections will need to be selected as the one to use.\n\n![Home Realm Discovery in Lock](https://images.ctfassets.net/cdy7uua7fh8z/1wnZRx9V1cyyV1nRgsu9fD/f2569441334d3b277702db225045e102/2023-09-22_14-18-30.png)\n\nSelecting the appropriate Identity Providers from multiple options is called \"Home Realm Discovery\".\n\nIf you use at most one database connection and zero or more social connections the selection process is straightforward. The user will either:\n\n*   Click on one of the social identity providers buttons (e.g., \"Log in with Google\")\n    \n*   Enter their email and password (meaning \"I will use the database connection\").\n    \n\nBut if the application or tenant has other connection types enabled (like enterprise connections or multiple databases) the selection process might be more involved. How do you indicate that a user wants to use a specific database connection if more than one is enabled? What if a user wants to use an enterprise connection to log in using Single Sign-on (SSO)?\n\nIf you implement [a custom login UI](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk) you have full control over the authentication flow. You can choose the connection based on context (like the given email address) or by asking the user, then provide the `connection` parameter to one of Auth0.js' [login methods](https://auth0.com/docs/libraries/auth0js).\n\n## Lock and multiple connections\n\nLock has built-in functionality for identity provider selection. For social connections, it shows logos for all those enabled in a particular app. It also provides username/email and password fields if a database connection or Active Directory connection is enabled.\n\nYou will only see a login button if it is the only connection enabled for the application (for [Classic Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience) experience). Otherwise, you will need to use a [custom UI](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk) or the [New Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience), which does support having a button for every social and enterprise connection enabled.\n\n## Using email domains with enterprise connections\n\nAn additional feature in Lock is the use of email domains as a way of routing authentication requests. Enterprise connections in Auth0 can be mapped to `domains`. For example, when configuring an ADFS or a SAML\\-P identity provider:\n\n![Configuring ADFS or SAML-P identity providers](https://images.ctfassets.net/cdy7uua7fh8z/6c8fqJpKCPNSqlop6ZJGYK/b20b1125302b8f5511825be1299e0f96/enterprise-connection.png)\n\nIf a connection has domains mapped to it, then the password input field gets disabled automatically when a user enters an email with a mapped domain.\n\n![Mapped domain login screen](https://images.ctfassets.net/cdy7uua7fh8z/6pb7kGpuHkj0rVPPaJw6Xb/373b9e7a2bf49748a1a306623c13b299/hrd-sso.png)\n\nIn the example above the domain `auth0.com` has been mapped to an enterprise connection.\n\nNotice that you can associate multiple domains to a single connection.\n\n## Selecting among multiple database connections\n\nIf your application has multiple database connections enabled, Lock needs to know which one to use. You can provide a [`connectionResolver` option](https://github.com/auth0/lock#other-options), which takes a function that decides the connection to use based on the user input and context. In this example an alternative database connection is used if the email domain is \"auth0.com\":\n\n```\nvar options = {\n  connectionResolver: function (username, context, cb) {\n    var domain = username.indexOf('@') !== -1 && username.split('@')[1];\n    if (domain && domain ==='auth0.com') {\n      // If the username is test@auth0.com, the connection used will be the `auth0-users` connection.\n      cb({ type: 'database', name: 'auth0-users' });\n    } else {\n      // Use the default approach to figure it out the connection\n      cb(null);\n    }\n  }\n}\n```\n\nYou can use the [`defaultDatabaseConnection` option](https://auth0.com/docs/libraries/lock/v11/configuration#defaultdatabaseconnection-string-) to specify the database connection that will be used by default.\n\n## Filtering available connections programmatically\n\nThe [`allowedConnections` option](https://auth0.com/docs/libraries/lock/v11/configuration#allowedconnections-array-) in Lock lets you indicate which of the available connections should be presented as an option to the user.\n\nThis lets you tailor the experience based on additional input or context (e.g. \"Click here to log in as a student, or here to log in as a faculty member\").\n\nto configure this snippet with your account\n\n```\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}',\n  {\n    allowedConnections: ['yourConnection'];\n  }\n);\n```\n\nNote that you can also provide the `allowedConnections` option to the `lock.show()` method if providing it at instantiation is not ideal for your use case. Please refer to the [API documentation](https://auth0.com/docs/libraries/lock/lock-api-reference) for the `show` method for more information.\n\n## Sending realm information from the application\n\nSometimes the application requesting an authentication can know, in advance, the realm intended to be used by the user. E.g. a multi-tenant application might use URLs in the form of: `https://{customer}.yoursite.com` or `https://www.yoursite.com/{customer}`. When a user arrives at your application with the vanity URL, you can pick up that `tenant` value and pass it as the `login_hint` in the `authorize` request:\n\n`https://{YOUR_AUTH0_DOMAIN}/authorize?client_id=[...]&login_hint={customer}`\n\n`login_hint` is a hint to the authorization server (Auth0) to indicate what the user might use to log in. In this case, based on the URL where the user landed, we treat the \"customer\" as the realm.\n\nThe default hosted login page code uses it to pre-fill the email field in Lock, but we can modify the code to alter the default database connection to be used if a realm is provided instead of an actual email address:\n\n```\n// from the default Hosted Login Page template\nvar config = JSON.parse(decodeURIComponent(escape(window.atob('@@config@@'))));\n[...]\n\nvar loginHint = config.extraParams.login_hint;\nvar realmHint;\n\n// if the login hint is not an email address, we treat it as a realm hint\nif (loginHint && loginHint.indexOf('@') < 0) {\n  realmHint = loginHint;\n  loginHint = null;\n}\n\n// now we map the realm into an actual database\nvar defaultDatabaseConnection;\nif (realmHint === 'acme') {\n  defaultDatabaseConnection = 'acme-users';\n} else if (realmHint === 'auth0') {\n  defaultDatabaseConnection = 'auth0-DB';\n}\n    \n// When configuring Lock, we provide the values obtained before\nvar lock = new Auth0Lock(config.clientID, config.auth0Domain, {\n  [...] // other options\n  prefill: loginHint ? { email: loginHint, username: loginHint } : null,\n  defaultDatabaseConnection: defaultDatabaseConnection\n}\n```\n\nThe above code is, of course, just a sample. You could expand this logic to filter out social connections, or to set a default connection to be used even if an email address is provided as a `login_hint`.\n\nMapping the \"customer\" as a realm is an arbitrary design decision for this example. But it is generally a good idea to isolate applications from the actual \"connection\" concept used within Auth0 and use the more abstract \"realm\" concept instead, possibly doing a realm-to-connection mapping within the hosted login page (where it's easier to make changes if necessary).",
  "title": "Select from Multiple Connection Options",
  "description": "How to select different connection types for multiple login options with Lock V11.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-mtls/set-up-resource-server-for-token-binding",
  "markdown": "# Set up Resource Server for Token Binding\n\nWhenever mTLS Token Binding is enabled, resource servers must ensure that the binding is enforced. Resource servers that enforce Token Binding must request client TLS certificates and perform some of the same verifications as the authorization server.\n\nThe `cnf` claim of an access token is an indication that Token Binding of some sort must be enforced. For mTLS Token Binding, the `cnf` claim has the following form:\n\n`\"cnf\":{\"x5t#S256\":\"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0\"}`\n\nIn this example, `x5t#S256` indicates this access token is bound to an mTLS client certificate with a thumbprint of `A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0`.\n\nThe resource server that receives a bound access token must verify that the client certificate sent in the request has a matching thumbprint (`A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0` in our example). If the client certificate was not sent, or the thumbprint of the client certificate does not match, the resource server rejects the request using an HTTP 401 status code and an `invalid_token` error code.\n\nUnlike the authorization server (or customer edge), the resource server does not necessarily need to verify the entire certificate chain of the client certificate, only that the client certificate matches the one in the access token’s thumbprint. For more information on how the thumbprint is calculated, see RFC 8705’s section on [JWT Certificate Thumbprint Confirmation Method](https://www.rfc-editor.org/rfc/rfc8705#name-jwt-certificate-thumbprint-).\n\nResource servers that progressively migrate clients to use mTLS may wish to expose their API at two domains: one non-mTLS domain for non-mTLS clients and one mTLS-enabled domain for mTLS-capable clients. An alternative is to create an entirely separate mTLS-only resource server on an mTLS-enabled domain.\n\nFor more information, see RFC 8705’s sections on [Token Binding](https://www.rfc-editor.org/rfc/rfc8705#name-mutual-tls-client-certifica) and [Resource Servers](https://www.rfc-editor.org/rfc/rfc8705#name-resource-server).\n\n## Enable token binding with Auth0 Dashboard\n\nAccess tokens issued by Auth0 can be constrained to the sender (i.e. the client application) that needs to access APIs at a resource server. To enable Token Binding or sender constraining, configure the **API Settings** of your API.\n\n1.  Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis).\n    \n2.  Select the API you want to configure.\n    \n3.  Under the **Settings** tab, find the **Token Sender-Constraining** section.\n    \n4.  Configure the following:\n    \n    1.  Sender Constraining Method: **None** or **mTLS**.\n        \n    2.  Require Token Sender Constraining: all access tokens issued to an application for this API will be constrained to that application.\n        \n\n![Auth0 Dashboard > APIs > Settings > Token binding](https://images.ctfassets.net/cdy7uua7fh8z/3Dv98iZosdpJMcZXfXyurn/e59a01bfba3ee9bf828cdc24383e9101/2024-05-28_16-04-06.png)\n\n## Learn more\n\n*   [Set up the Customer Edge](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge)\n*   [Configure mTLS for a Tenant](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-tenant)\n*   [Configure mTLS for a Client](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client)",
  "title": "Set up Resource Server for Token Binding",
  "description": "Learn how to set up your resource server for Token Binding.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-ssocircle-as-saml-identity-provider",
  "markdown": "# Configure SSOCircle as SAML Identity Provider\n\nConfigure SSOCircle as an identity provider by completing the following steps:\n\n1.  Obtain SSOCircle metadata.\n    \n2.  Configure enterprise connection in Auth0.\n    \n3.  Configure SSOCircle as identity provider.\n    \n4.  Test connection.\n    \n\n## Prerequisite\n\nYou must have a [SSOCircle](https://idp.ssocircle.com/) account.\n\n## Obtain SSOCircle metadata\n\n1.  Navigate to [SSOCircle's IDP page](https://idp.ssocircle.com/) to see the metadata required for integration. You will be shown an XML file.\n    \n2.  From this page, you will need to save the following attributes:\n    \n    1.  The Location URL for the `SingleSignOnService` attribute with an `HTTP-Redirect` type.\n        \n    2.  The Location URL for the `SingleLogoutService` attribute with an `HTTP-Redirect` type.\n        \n3.  [Download](http://www.ssocircle.com/en/idp-tips-tricks/public-idp-configuration) and save the SSOCircle CA Certificate.\n    \n\n## Configure enterprise connection in Auth0\n\n1.  Go to [Dashboard > Authentication > Enterprise > SAMLP](https://manage.auth0.com/#/connections) and click the **plus** icon to go to the page that allows you to create a new connection.\n    \n2.  Provide the appropriate configuration settings for this connection. The only mandatory fields are as follows:\n    \n    | **Setting** | **Description** | **Example** |\n    | --- | --- | --- |\n    | Connection name | Auth0 connection name. | `myoktaconnection` |\n    | Sign In URL | Okta URL where user login requests are sent.<br><br>This is the **Identity Provider Single Sign-On URL** value you recorded previously. | `https://my_okta_tenant_name.okta.com/app/` `my_okta_tenant_namemy_okta_saml_app_integration_name/` `dakflkbzevu5i5zBi939/sso/saml` |\n    | X509 Signing Certificate | Okta tenant public key signing certificate.<br><br>Upload the **X509 Certificate** you downloaded previously. | `myOktaTenantSigningCertificate.pem` |\n    \n3.  When setting up mappings, use the following JSON to properly map SAML attributes from SSO Circle:\n    \n    ```\n    {\n          \"email\": \"EmailAddress\",\n          \"given_name\": \"FirstName\",\n          \"family_name\": \"LastName\"\n        }\n    ```\n    \n4.  Click **Save**. In the next window, you'll be provided two options:\n    \n    1.  If you are a domain administrator, click **Continue** for additional instructions on SAML identity provider configuration.\n        \n    2.  If you are not, you can give your domain administrator the provided URL so that they can finish the configuration.\n        \n\nYou can access the metadata for an Auth0 SAML connection using a URL with the following format: `https://{yourDomain}/samlp/metadata?connection={yourConnectionName}`.\n\nYou will need to provide this metadata to SSOCircle in the next step.\n\n## Configure SSOCircle as identity provider\n\n1.  Log in to your [SSOCircle](http://ssocircle.com/) account. You will be directed to your user profile, and to the left of that is a navigation bar.\n    \n2.  Click **Manage Metadata**.\n    \n3.  Select **Add New Service Provider**, and provide the following information to configure the new service provider which, in this case, is Auth0:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **FQDN of the ServiceProvider** | `auth0.com` |\n    | **Attributes to send in assertion** | Check the box for `EmailAddress` |\n    | **Insert your metadata information:** | Paste in the XML metadata that you downloaded after you configured your Auth0 connection. |\n    \n4.  Click **Submit**.\n    \n\n## Test connection\n\n### Create Auth0 application\n\n1.  Go to the **Applications** page on the [Auth0 Dashboard](https://manage.auth0.com/#) and click **\\+ New Application**.\n    \n2.  Provide some basic information about your new application. Choose **Regular Web Applications** as the application type.\n    \n3.  Click **Create** to finish configuration and begin the Application creation process. You will be directed to the application details page.\n    \n4.  Click **Settings**.\n    \n5.  In the **Allowed Callback URL** field, enter the list of allowed callback URLs includes those to which users will be redirected after authentication. The URL(s) entered here must match the **callback URL** in the HTML code you will create in a later step. Normally, you would enter a URL for your application, but to keep this example simple, users will simply be sent to the Auth0 JWT Tool.\n    \n6.  Click **SAVE CHANGES**.\n    \n7.  Return to the top of **Settings** and click **Connections**.\n    \n8.  Scroll to the **Enterprise** section. Find the row for the SAML connection you created above and turn on toggle to enable the SAML connection.\n    \n\n### Test enterprise connection\n\n1.  To test your connection, follow the steps in [Test Enterprise Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n    \n2.  During this process you will be asked to log in and consent.\n    \n3.  Additionally, if you see a message that says, \"Your session has timed out,\" click the **Return to Login page** link below the message.\n    \n\nIf logging in to your application doesn't work the first time, clear your browser's history and cookies before testing again. The browser may not be picking up the latest version of your HTML.\n\nWhen troubleshooting SSO, it is often helpful to capture an HTTP trace of the interaction. There are many tools that will capture the HTTP traffic from your browser for analysis (search for \"HTTP Trace\" to find one appropriate for your needs). Once you have an HTTP tracer, capture the login sequence from start to finish and analyze the trace to see the sequence of `GET` requests to see where the error occurs. You should see:\n\n*   A redirect from your original site to the IDP\n    \n*   A post of credentials (if you were asked to log in)\n    \n*   A redirect to the callback URL.\n    \n\nEnsure that your browser has enabled cookies and JavaScript.\n\nCheck to make sure that the callback URL specified in the HTML is also listed in the **Allowed Callback URLs** field in the **Settings** tab of the Auth0 Application.",
  "title": "Configure SSOCircle as SAML Identity Provider",
  "description": "Learn how to configure an application to use Auth0 for SAML Single Sign-on (SSO), authenticating users against SSOCircle.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/clients/post-clients",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/clients/post-credentials",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/api/management/v2/connections/get-connections-by-id",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa",
  "markdown": "# Configure OTP Notifications for MFA\n\nTo use one time passwords (OTPs) as an authentication factor, users need an Authenticator app such as:\n\n*   Authy ([Google Play](https://play.google.com/store/apps/details?id=com.authy.authy) / [App Store](https://itunes.apple.com/us/app/authy/id494168017)).\n    \n*   Google Authenticator ([Google Play](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2) / [App Store](https://itunes.apple.com/us/app/google-authenticator/id388497605)).\n    \n*   Auth0 Guardian ([Google Play](https://play.google.com/store/apps/details?id=com.auth0.guardian) / [App Store](https://itunes.apple.com/us/app/auth0-guardian/id1093447833)).\n    \n*   Microsoft Authenticator ([Google Play](https://play.google.com/store/apps/details?id=com.azure.authenticator) / [App Store](https://itunes.apple.com/us/app/microsoft-authenticator/id983156458))\n    \n\n![Auth0 Guardian OTP QR code setup example](https://images.ctfassets.net/cdy7uua7fh8z/2J6vWaonPbCvpuBUu9b8q1/50be3671f7524b0e84628763a38a3b8b/mfa-otp-setup.png)\n\nUpon signup, they can scan a code and set up the app, upon which it will begin generating one-time codes. Afterward, when logging in to the app, the user can simply check the authenticator app for the current one-time code:\n\n![Auth0 Guardian OTP Code Google example](https://images.ctfassets.net/cdy7uua7fh8z/1vVY2NLQwsOwdHIPU4Qj3B/026255e1549c3ec5bdc790280590d210/google-auth-screenshot.png)\n\nYour user enters the code at the prompt:\n\n![Auth0 Guardian OTP Login Prompt Example](https://images.ctfassets.net/cdy7uua7fh8z/4dntQCYqgx5QyLZKW7quxR/f8c5af166c1387442285da52e99dfd67/mfa-login.png)\n\nYour users will need to have an OTP Authenticator app installed on their mobile devices.\n\n## Learn more\n\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)",
  "title": "Configure OTP Notifications for MFA",
  "description": "Describes how to configure time-based one time passwords (OTP) notifications for MFA.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/roles/get-role-user",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/connections/azuread-adfs-email-verification",
  "markdown": "# Email Verification for Azure AD and ADFS\n\nAuth0 user's profile has an `email_verified` field, which can be set in different ways depending on the connection type. For database connections, users must go through an email validation flow to get the email verified. For federated connections, identity providers can return the `email_verified` field based on their own criteria.\n\nAzure AD and ADFS cannot guarantee that the emails they return have been verified:\n\n*   In ADFS, the ADFS administrator can configure any email they want.\n    \n*   In Azure AD, depending on how the Azure AD tenant is configured, email addresses returned by Azure AD may or may not correspond to Office mailboxes. Auth0 can't know whether they do or not.\n    \n\nHowever, if you know how an Azure AD or ADFS is configured and managed, you can decide to trust that the emails from those accounts are verified.\n\nTo accommodate both needs, Azure AD and ADFS connections have an **Email Verification** property with two values:\n\n*   Always set `email_verified` to `true`\n    \n*   Always set `email_verified` to `false`\n    \n\nThe Azure AD connection also has a **Use Common Endpoint** property. When it's enabled, the user can authenticate with any Azure AD tenant. Given it's not possible to trust that any Azure AD tenant will return verified emails, the **Email Verification** property will need to be set to **Always set** `**email_verified**` **to** `**false**`.\n\nWhen the property is set to **Always set** `**email_verified**` **to** `**false**`, users will get `email_verified` set to `false` the next time they log in, unless [syncing user profile attributes at each login](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) is disabled.\n\nIn previous versions, Auth0 always set the `email_verified` field to `true` in Azure AD and ADFS connections. If you were using Azure AD and ADFS connections in the past, you will have a tenant setting that will override the Connection Setting for **Email Verification** and keep the previous behavior.\n\nYou can find the new tenant setting in the [Auth0 Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced). Locate the **Migrations** section, then find **Default to** `**Email Verification**` **setting for Azure AD/ADFS connections**.\n\n![Dashboard - Advanced Tenant Settings - Migrations](https://images.ctfassets.net/cdy7uua7fh8z/4K1rQIv6p96KPCYOrhjXz4/be0f7b104d743fd0d3d42d18df97e144/dashboard-tenant-edit_view-advanced_migrations_azure-adfs.png)\n\nWhen this setting is disabled, `email_verified` will always be `true` for Azure AD/ADFS connections. When enabled, it will use the `Email Verification` setting at the connection level.\n\nIf your application requires that the emails from an Azure AD/ADFS connection's users are always verified, you can enable the **Enable email verification flow during login for Azure AD and ADFS connections** option in the tenant's **Advanced Settings** section.\n\nAfter the user authenticates for the first time with a non-verified email, Auth0 will ask the user to verify their email by entering a one-time-use code that will be sent to their email account:\n\n![Auth0 - Email Verification Prompt - One-Time Code](https://images.ctfassets.net/cdy7uua7fh8z/i92GJgntVuU5QK37adugH/51b66e40d90d953a9d8e974f03371e84/azuread-adfs-email-verification.png)\n\nIf the user completes this step, the `email_verified` field will be set to `true`, and users will not be prompted again for email verification, unless Azure AD or ADFS return a different email for the user.\n\nThis new screen is rendered using the Universal Login experience, even if you are using Classic Login. To learn how to customize it, read [Customize Universal Login Pages](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates).\n\nTo learn how to customize the email that is sent to users, read [Verify Emails using Auth0](https://auth0.com/docs/manage-users/user-accounts/verify-emails).",
  "title": "Email Verification for Azure AD and ADFS",
  "description": "Describes how to control how the `email_verified` field is set for Azure AD and ADFS.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/product-lifecycle/deprecations-and-migrations/logout-return-to",
  "markdown": "# Logout Redirects Migration Guide\n\nOn **01 December 2021**, the logout behavior will change to always redirect users to the URI passed to the Auth0 logout APIs instead of using the `returnTo` query parameter passed by Identity Providers to the `/login/callback` during the execution of the logout. The URI used will depend on the API called to request the session logout:\n\n*   `https://{yourDomain}/logout`: Auth0 will use the `returnTo` parameter\n    \n*   `https://{yourDomain}/v2/logout?federated`: Auth0 will use the `returnTo` parameter\n    \n*   `https://{yourDomain}/wsfed/{yourClientId}?wa=wsignout1.0`: the `wreply` parameter\n    \n\nIf Auth0 does not have a record of a preceding call to one of these APIs, logout will complete, but redirection will not occur and an error page will be displayed to end users.\n\n### Affected endpoints\n\nThe following endpoints are affected by this change:\n\n*   `https://{yourDomain}/v2/logout` when using the `federated` query parameter to l[og users out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n    \n*   `https://{yourDomain}/wsfed/{yourClientId}?wa=wsignout1.0` when using the `wreply` query to [log out of Auth0 using the WS-Fed Protocol](https://auth0.com/docs/authenticate/protocols/ws-fed-protocol)\n    \n*   `https://{yourDomain}/login/callback` when using the `returnTo` query parameter.\n    \n\nTenants relying on the following usage patterns will not be able to redirect to their desired redirect URI after **01 December 2021**.\n\n1.  Applications that call `/login/callback?returnTo` without a preceding call to `/v2/logout or /wsfed/{yourClient}?wa=wsignout1.0` to specify the Logout URL.\n    \n2.  Identity Providers that call `/login/callback?returnTo` with a value in `returnTo` that is different to the value originally provided in a preceding call to `/v2/logout` or `/wsfed/{yourClientId}`.\n    \n3.  Applications that make concurrent calls to one of the affected APIs while providing different redirection URIs in the different calls.\n    \n4.  Applications or users that make calls to the `/authorize` API concurrently or interleaved with calls to one of the affected APIs regardless of whether there was a preceding call to `/v2/logout` or `/wsfed/{yourClientId}?wa=wsignout1.0`.\n    \n\n### Actions\n\n1.  Go to [Auth0 Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs), and search for `type:depnote AND description:*unvalidated*redirects*` to find applications that rely on the deprecated behavior.\n    \n2.  For each affected application, ensure that:\n    \n    1.  the application or Relying Party initiates the logout using one of Auth0’s public APIs: [Authentication API: Logout](https://auth0.com/docs/api/authentication#logout) or [Authentication API: WS-Federation](https://auth0.com/docs/api/authentication#ws-federation).\n        \n    2.  the application does not rely on Identity Providers modifying the Logout URL that is passed back to `/login/callback?returnTo` as these modifications will no longer be honored.\n        \n    3.  the application does not make concurrent calls to logout APIs using different Logout URLs. Auth0 will store only a single Logout URL for a user agent at any one time, which means that concurrent logout processes will fail to redirect.\n        \n    4.  the application does not make calls to `/authorize` concurrently or interleaved with calls to the logout APIs. Completing a login transaction will clear the stored Logout URL for a user agent, which means that concurrent logout processes will fail to redirect.\n        \n    5.  the application and users do not interleave calls to `/authorize` with calls to one of the affected APIs.\n        \n\nOnce the migration actions have been completed and tested, you should verify the migration.\n\n### Verify migration\n\nOnce you have migrated your applications and are sure that they no longer rely on the deprecated usage patterns, verify your changes by disabling the deprecated behavior at a time of your choosing and ahead of **01 December 2021**.\n\n1.  Go to [Auth0 Dashboard > Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced), and locate the **Migrations** section.\n    \n2.  Disable the **Unvalidated redirects from /login/callback** switch. Turning off this switch disables the deprecated behavior for your tenant, preventing it from being used.\n    \n    ![Dashboard - Tenant - Advanced - Migrations - Unvalidated redirects from /login/callback switch](https://images.ctfassets.net/cdy7uua7fh8z/5kiOydQyxQmTbgfwtqCWT7/9f64f0a9d52d61d76922ac49f8e6e436/dashboard-tenant-advanced_migrations.png)\n\nIf redirection to the Logout URL does not work as expected after disabling this switch, it is a sign that your application still relies on the deprecated behavior.\n\nOnce migrations have been successfully performed and confirmed in production environments, the you can disable the switch permanently to ensure that the deprecated features can no longer be used. On **01 December 2021**, Auth0 will remove the deprecated behavior completely together with the associated switch.",
  "title": "Logout Redirects Migration Guide",
  "description": "After December 1, 2021, logout behavior will change to always redirect users to the URI passed to the Auth0 logout APIs instead of using the returnTo query parameter passed by Identity Providers to the  /login/callback during the execution of the logout.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-requirements",
  "markdown": "# AD/LDAP Connector System Requirements\n\nTypically the AD/LDAP Connector needs to be installed by a sys admin or an operations engineer vs. a developer, since it often requires access to production resources. Following is a checklist of things they should consider ahead of the actual install:\n\n## Host servers\n\nThe Connector can be installed on an existing server, even a Domain Controller. However, more often it's installed on virtual machines provisioned just for the Connector. Regardless, the host server should have the following hardware and software specifications/configurations:\n\n### Hardware requirements\n\n*   **Architecture**: x86 or x86-64\n    \n*   **CPU cores**: min. 1, recommended 2\n    \n*   **Storage**: 500MB of free space on disk\n    \n*   **Operating System**: The connector can run on Windows or Linux. Windows is required if Kerberos authentication will be used.\n    \n*   **RAM**: min. 2GB\n    \n\n### Windows version\n\nWe recommend using a supported version of Windows Server, like Windows Server 2016 or Windows Server 2019. The connector can also run on Windows Server 2012 R2.\n\n### Time synchronization\n\nIt is very important to have the Connector host server clock automatically synchronized with an NTP server. Otherwise the connector will fail to start and report a clock skew error.\n\n## Outbound connectivity\n\nThe host server requires outbound network connectivity to the following services:\n\n### Auth0\n\nThe connector must be installed on a server with outbound connectivity to the Auth0 service at: `https://{yourDomain}` on port 443.\n\nThe connector can be installed and configured behind a proxy server but we don't recommend this. Enable a proxy through the environment or configuration variable `HTTP_PROXY`.\n\n### LDAP\n\nThe Connector must be installed on a server with access to the LDAP server on port 389 for ldap or 636 for ldaps. Before installing the Connector you should know the LDAP Connection String and the Base DN required to connect to your LDAP directory.\n\n## Inbound connectivity\n\nYou do not need inbound connectivity enabled to the Connector unless Kerberos or certificate authentication is enabled. In these cases, the server(s) on which the Connector is installed must be reachable from your users' browsers on port 443. If more than one instance of the connector is installed, you should use a load balancer to direct traffic to one connector or the another.\n\nTo learn more, read [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos) or [Configure AD/LDAP Connector Authentication with Client Certificates](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates).\n\n## Service account\n\nThe Connector will be run using a service account that must be a domain user that at a minimum has read access to the directory. You will need the username/password of this account when performing the install.\n\n## One Connector per Auth0 tenant\n\nIf you establish multiple Auth0 tenants, for example to isolate development and production environments, you will need to set up an AD/LDAP connection on the Auth0 Dashboard and with an AD/LDAP Connector for each Auth0 tenant that needs this form of authentication. A Connector is tied to a specific connection within an Auth0 tenant.\n\nIt is possible to have multiple Connectors within one Auth0 tenant if you have multiple AD/LDAP directories against which users will authenticate. For example, to support different departments or customers each with their own directory. In addition, multiple Connectors can point to the same AD or LDAP directory but a Connector can only be used by one Auth0 Connection within one Auth0 tenant.\n\n## High availability\n\nThe Connector can be installed on multiple host servers for high-availability and redundancy (most organizations provision two) in case one server becomes unavailable. Each server will have the same requirements listed above. No load balancer is required as that is performed by the Auth0 server itself, unless you enable Kerberos or client certificate based authentication.\n\nTo learn more, read [Deploy AD/LDAP Connectors for High Availability Environments.](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability)\n\n## Learn more\n\n*   [Install and Configure AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector)\n*   [Deploy AD/LDAP Connectors for High Availability Environments](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability)\n*   [Configure AD/LDAP Connector Authentication with Client Certificates](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates)\n*   [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos)",
  "title": "AD/LDAP Connector System Requirements",
  "description": "Lists all the prerequisites to installing and configuring the connector.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector",
  "markdown": "# Install and Configure AD/LDAP Connector\n\n*    [![](https://cdn.auth0.com/docs/img/node-windows.png) Auth0 Active Directory/LDAP Connector for Windows](https://cdn.auth0.com/adldap.msi) -  \n            \n\n### Run the installer\n\nRun the installer and follow the instructions.\n\n![AD/LDAP Connector Services](https://images.ctfassets.net/cdy7uua7fh8z/1cN4OfG8G3nsJDnVPneNLj/0bd9efb494c6d26016b3a15d0dddf063/adldap-connector-setup.png)\n\nThe **AD/LDAP Connector** is installed as a Windows Service.\n\n![AD/LDAP Connector Services](https://images.ctfassets.net/cdy7uua7fh8z/MPMfLmJsXoPAzpPQhGAv5/25fb39ac7cef7a125110b8fa9f2dff01/adldap-connector-services.png)\n\n### Link to Auth0\n\nOnce the installation is complete, you will see a screen in a browser pointing to localhost:\n\n![AD/LDAP Connector Admin Ticket](https://images.ctfassets.net/cdy7uua7fh8z/3biSuxJYQ4swMGJkOZtC3R/cab77cb763ad3b9ff47710bc406c527b/adldap-connector-admin-ticket.png)\n\nEnter the **TICKET URL** provided when you provisioned the connection. The **TICKET URL** uniquely identifies this connector in Auth0. The Connector will use this to communicate with Auth0 Server and automatically complete the configuration.\n\n### Link to LDAP\n\nEnter the LDAP settings:\n\n![adldap-connector-admin-settings](https://images.ctfassets.net/cdy7uua7fh8z/2mHaknek0qyBxGmsanb30L/600b0259ed6db3fe9c526aa9f57a76bd/adldap-connector-admin-settings.png)\n\n| Setting | Description |\n| --- | --- |\n| **LDAP Connection String** | For example, `ldap://ldap.internal.contoso.com`. This is the protocol + the domain name or ip address of your LDAP server. Your LDAP server is the local domain controller where Active Directory is installed. The protocol can be either `ldap` or `ldaps`. If you need to use `ldaps` make sure that the certificate is valid in the current server. |\n| **Base DN** | For example, `dc=contoso,dc=com`. This is the base container for all the queries performed by the connector. |\n| **Username** | For example, `cn=svcauth0,dc=services,dc=contoso,dc=com` The full distinguish name of a user to perform queries. |\n| **Password** | The password of the user. |\n\nOnce you submit the above information, the connector will perform a series of tests to validate the information you entered. The results are displayed under **Configuration Log** in the console screen.\n\n![adldap-connector-admin-settings-ok](https://images.ctfassets.net/cdy7uua7fh8z/7kezId8mhvyYDbuovvi9FM/c2f3b2188fdfebc460458daf7247c124/adldap-connector-admin-settings-ok.png)\n\nMake sure that all tests are green.\n\n| Test | Description | Troubleshoot |\n| --- | --- | --- |\n| Test 1 | Attempts to establish a TCP connection to the LDAP server and port specified. | Check basic network connectivity and firewall settings that might prevent such a connection. |\n| Test 2 | Attempts to perform an LDAP bind on the LDAP server and port specified and with the username and password provided. | Check the LDAP connection string, search path, username and password. |\n| Test 3 | Attempts to perform an LDAP search against the directory to check the privileges of the specified username. | Check the privileges of the username in the target directory. |\n| Test 4 | Attempts to establish a connection to the Auth0 server. | Check network connectivity and firewall settings that might prevent such a connection. |\n\n## Install the connector for other platforms\n\n1.  Download the **Auth0 Active Directory/LDAP Connector** package to `/tmp`:\n    \n    **Curl example:**  \n    \n2.  Expand the package and install its dependencies:\n    \n    ```\n    mkdir /opt/auth0-adldap\n    tar -xzf /tmp/adldap.tar.gz -C /opt/auth0-adldap --strip-components=1\n    cd /opt/auth0-adldap\n    npm install\n    ```\n    \n3.  Start your server. `node server.js` When prompted for the ticket number, enter the full ticket URL from the **Settings** tab of the **Setup AD/LDAP connector** screen in the Auth0 Management Dashboard.\n    \n4.  You will be prompted to edit the `config.json` configuration file with your LDAP connection and authentication details:\n    \n    ```\n    \"LDAP_URL\": \"ldap://{yourLdapServerFqdn}\",\n        \"LDAP_BASE\": \"dc={yourDomain},dc=com\",\n        \"LDAP_BIND_USER\":\"{yourLdapUser}\",\n        \"LDAP_BIND_PASSWORD\":\"{yourLdapUserPassword}\" //cleartextpassword\n    ```\n    \n5.  Run `node server.js` once more to start the Connector. Note that the `LDAP_BIND_PASSWORD` line in `config.json` changes to `LDAP_BIND_CREDENTIALS` at this point.\n    \n6.  Once the Connector is running, you will need to daemonize the Connector (if you don't already have a tool selected, you can consider [upstart](http://upstart.ubuntu.com/) or [systemd](https://www.freedesktop.org/wiki/Software/systemd/)). For example, for using systemd with Ubuntu Xenial, the file `/lib/systemd/system/auth0-adldap.service` could contain the following:\n    \n    ```\n    [Unit]\n    Description=Auth0 AD LDAP Agent\n    After=network.target\n    \n    [Service]\n    Type=simple\n    Restart=always\n    User=ubuntu\n    WorkingDirectory=/opt/auth0-adldap\n    ExecStart=/usr/bin/node server.js\n    ```\n    \n7.  Run `node admin/server.js` to access the admin UI. The admin UI will be running and available on `http://localhost:8357`.\n    \n\nIf you get an `Invalid Ticket` message when configuring the Connector for the first time, the most likely cause is a network issue (for example, you have the Connector running behind a proxy).",
  "title": "Install and Configure AD/LDAP Connector",
  "description": "Describes how to install and configure the AD/LDAP Connector.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos",
  "markdown": "# Configure AD/LDAP Connector Authentication with Kerberos\n\nYou can federate with Active Directory through the AD/LDAP Connector. The AD/LDAP Connector enables your users to authenticate when they are on a domain-joined machine within the corporate network.\n\n## Configure Active Directory\n\n1.  Go to [Auth0 Dashboard > Authentication > Enterprise > Active Directory/LDAP](https://manage.auth0.com/#/connections/enterprise/ad), and select the connection you want to configure.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP - Configure Kerberos](https://images.ctfassets.net/cdy7uua7fh8z/23xp9ItKBX6DVkfKzRr6m2/72bb0c1abb3b2e9038f94c78cb8b66fd/Dashboard_-_Connections_-_Enterprise_-_AD_LDAP.png)\n2.  Enable the **Use Windows Integrated Auth (Kerberos)** switch.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP - Kerberos Switch](https://images.ctfassets.net/cdy7uua7fh8z/7uXuztjn96TQ2BU2rGezQ3/f6e27abbd51b33866a0c1498d0ccaae8/Dashboard_-_Authentication_-_Enterprise_-_ADLDAP_-_Kerberos_Switch.png)\n\n### Auto-detected range for Kerberos\n\nWhen Kerberos authentication is enabled, the visible IP address of the server where the AD Connector is running is implicitly added to the network IP range. This means that if a user's requests originate from the same visible IP address as that of the AD Connector, then Kerberos authentication will be attempted.\n\n1.  Configure the **IP Ranges**. Use [CIDR-notation](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing). These should be ranges that are visible by Auth0. When Auth0 is running in the cloud, it won't be able to see your user's internal IP address. In that case you'd configure the public facing/WAN IP address(es) of your company.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP - Kerberos Settings](https://images.ctfassets.net/cdy7uua7fh8z/14nhVrsvmiencYIyI2sJfy/558a86c25dd8ce7e08efd84d40134b29/Dashboard_-_Authentication_-_Enterprise_-_ADLDAP_-_Kerberos_-_IP.png)\n2.  We recommend restarting the Windows Service that hosts the AD Connector every time this setting is changed. This way, changes will take effect immediately.\n    \n\n## Authentication flow\n\nDepending on the users' location, the authentication flow will be different when IP ranges are set. Using Fabrikam as an example, since it uses the SaaS version of Auth0, they configured their Public IP Address (`24.12.34.56/32`) in the connection. Users connecting from within the building will all originate from `24.12.34.56` (as configured on the connection). When they authenticate, the users can follow the AD/LDAP native flow and have a seamless SSO experience.\n\nFor this to work, the network must allow the users to connect to the AD/LDAP Connector on the port configured in the `config.json` file. In [](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability)highly available deployments of the Connector, the address users will be connecting to is the network load balancer in front of all connectors instances.\n\n![Configure AD/LDAP Connector Authentication with Kerberos Flow Diagram](https://images.ctfassets.net/cdy7uua7fh8z/1EUZhFx2w5FjDeIoMySERC/fc50869b131faf3257cfe429c96f68d1/2023-09-22_14-28-30.png)\n\nTo learn more, read [Deploy AD/LDAP Connectors for High Availability Environments.](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability)\n\nOn the other hand, when users are not in the corporate network (for example, at a customer site, working from home without VPN) they won't be able to access the AD/LDAP Connector directly. The users will need to enter their username/password, and Auth0 will validate these credentials with the AD/LDAP Connector (which will in turn use Active Directory to validate those credentials).\n\n![Configure AD/LDAP Connector Authentication with Kerberos Credentials Flow Diagram](https://images.ctfassets.net/cdy7uua7fh8z/7xo1cIdF6GmSowlVB8kjQn/4b55f555977742af3f3df94c5b3a0a9b/2023-09-22_14-29-00.png)\n\n## Auto-login with Lock\n\nWhen an application is using Lock 10 or 11 within the Login Page hosted by Auth0 (typically used for SAML/WS-Federation protocols and Single Sign-on (SSO) Integrations), there will be a button which allows users to authenticate using \"Windows Authentication\".\n\nIn some cases the requirement could be to automatically sign in the user if Kerberos is possible (based on the IP-address of the end user). The following changes can be added to the Auth0 Login Page to automatically sign in the user if Kerberos is possible:\n\n```\n<script src=\"https://cdn.auth0.com/js/lock/11.x.x/lock.min.js\"></script>\n<script src=\"https://cdn.auth0.com/js/auth0/9.x/auth0.min.js\"></script>\n<script src=\"https://cdn.auth0.com/js/polyfills/1.0/object-assign.min.js\"></script>\n\n<script>\n  var config = JSON.parse(decodeURIComponent(escape(window.atob('@@config@@'))));\n\n  var lock = new Auth0Lock(config.clientID, config.auth0Domain, {\n      //...additional configuration\n  });\n\n  function handleError(err) {\n    // add proper error handling\n    console.log(err);\n  };\n\n  var params = Object.assign({\n      scope: config.internalOptions.scope,\n      _csrf: config.internalOptions._csrf,\n      state: config.internalOptions.state,\n    },\n    {\n      /* additional configuration needed for use of custom domains \n      overrides: {\n        __tenant: config.auth0Tenant,\n        __token_issuer: '{yourCustomDomain}'\n      }, */\n      domain: config.auth0Domain,\n      clientID: config.clientID,\n      redirectUri: config.callbackURL,\n      responseType: 'code'\n    });\n\n  var webAuth = new auth0.WebAuth(params);\n\n  /*\n   * Verify if Kerberos is possible, if it is, try to authenticate the user.\n   *\n   * the response from getSSOData will only have a connection and strategy if \n   * the IP address is within the Kerberos range in the connection's settings\n   */\n  webAuth.client.getSSOData(true, function(err, data) {\n    if (err) handleError(err);\n\n    if (data.connection && data.strategy === 'ad') {\n      webAuth.authorize({connection: data.connection}, function(err) {\n        if (err) handleError(err);\n      });\n    } else {\n      lock.show();\n    }\n  });\n</script>\n```\n\n## Bypass Kerberos at runtime\n\nYou can prevent Kerberos from being used, even if the user is logging in from an IP address within the range configured in the connection's settings, by passing `rememberLastLogin: false` to `lock.show()`.\n\n```\nfunction useKerberos() {\n      // return true to use Kerberos, false to bypass\n    };\n    \n    lock.show({rememberLastLogin: useKerberos()});\n```\n\n## Enable Kerberos request logging\n\n1.  To enable verbose logging of Kerberos requests, add a system level environment variable `DEBUG=kerberos-server`.\n    \n2.  Restart the Connector.\n    \n3.  Log in again and check the logs for more information.\n    \n\n## Firefox support for Kerberos\n\nBy default, [Firefox](https://www.mozilla.org/firefox) [rejects all \"negotiate\" requests required to authenticate users with Kerberos](https://developer.mozilla.org/en-US/docs/Mozilla/Integrated_authentication). If you wish to use Firefox with Kerberos, you need to AllowList the server where the connector is installed.\n\n1.  Open a Firefox tab and type `about:config` in the address bar.\n    \n2.  Dismiss any warning message, and in the search box type `negotiate`.\n    \n3.  Locate the `network.negotiate-auth.trusted-uris` item and double click to change its value.\n    \n4.  Type the domain name of the server where the connector is installed. If you have multiple instances of the connector behind a load balancer, add the dns name of the balancer. The value accepts a comma-separated list of URL prefixes or domains in the form of `mydomain.com, https://myotherdomain.com`.\n    \n5.  Click **Ok**. You don't need to restart the server for the changes to take effect.\n    \n\n## HTTPS support for Kerberos\n\nKerberos authentication works over HTTP (not HTTPS). Microsoft Office 365 and other modern products might not work with HTTP.\n\nTo resolve this limitation:\n\n1.  Set up a reverse proxy and expose the AD/LDAP Connector on an HTTPS domain. You can use the `SERVER_URL` (Front Facing URL) parameter to publish the public location where the AD/LDAP Connector will be listening to incoming requests.\n    \n2.  Map the `SERVER_URL` in the reverse proxy to all internal instances of the deployed connectors.",
  "title": "Configure AD/LDAP Connector Authentication with Kerberos",
  "description": "Describes how to configure AD/LDAP Connector for federating with Kerberos authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates",
  "markdown": "# Configure AD/LDAP Connector Authentication with Client Certificates\n\nThe AD/LDAP Connector also allows users to authenticate with a certificate installed on their machine or device.\n\n## Enable client certificates\n\n1.  Go to [Auth0 Dashboard > Authentication > Enterprise > Active Directory/LDAP](https://manage.auth0.com/#/connections/enterprise/ad), and select the connection you want to configure.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP - SSL](https://images.ctfassets.net/cdy7uua7fh8z/4lDEw3pd8TcCCKPyMz9eT3/039445bd6f221a6fb98082cd5dc2582e/Dashboard_-_Connections_-_Enterprise_-_AD_LDAP.png)\n2.  Toggle the **Use client SSL certificate authentication** option in the settings.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP - SSL](https://images.ctfassets.net/cdy7uua7fh8z/34RZpgx0kQfCCBjibk44qK/f05360185579b46056b94069e9822643/Dashboard_-_Connections_-_Enterprise_-_AD_LDAP_-_SSL.png)\n3.  Provide IP address ranges in the **IP Ranges** field. Only users coming from the given IP ranges are prompted to authenticate using client certificates. Users from different IP ranges are prompted to login with the username and password login form.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP -  SSL Settings](https://images.ctfassets.net/cdy7uua7fh8z/1NHuMcSPpRFqRxRBXMjzdc/a262f08ce7d02d5f6bb5c3c2496ee841/Dashboard_-_Connections_-_Enterprise_-_AD_LDAP_-__SSL_Settings.png)\n\n## Configure certificates\n\nOnce the AD/LDAP connection has been configured in Auth0, you'll need to configure the certificates in the AD/LDAP Connector. Supporting client certificates will require the following:\n\n*   An SSL certificate for the Front Facing URL, because the interaction between the end user and the Connector will need to happen over HTTPS.\n    \n*   One or more CA certificates.\n    \n*   A Client Certificate signed by the CA for each user that needs to authenticate using Client Certificates.\n    \n\n1.  Before uploading certificates to the AD/LDAP connector, convert X.509 certificates to Base64. Use Base64 or Certutil on Windows Server. To learn more, see [Base64 Decode](https://www.base64decode.org/) at Base64decode or [Certutil.exe](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil#BKMK_encode) in Microsoft documentation.\n    \n2.  Upload the SSL and CA certificates to the AD/LDAP Connector:\n    \n    ![Configure AD/LDAP Connector Authentication with Client Certificates Setup Screen](https://images.ctfassets.net/cdy7uua7fh8z/2zRux90ZHATIBFWyHlodue/c426e5a475ff528a467db6409980de12/connector-client-cert-config.png)\n3.  To test, generate a self-signed CA and Client Certificates using **makecert.exe** on Windows, which is part of the Windows SDK:\n    \n    ```\n    SET ClientCertificateName=jon\n        SET RootCertificateName=FabrikamRootCA\n        \"C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v7.1A\\Bin\\makecert.exe\" -sky exchange -r -n \"CN=%RootCertificateName%\" -pe -a sha1 -len 2048 -ss My \"%RootCertificateName%.cer\"\n        \"C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v7.1A\\Bin\\makecert.exe\" -n \"CN=%ClientCertificateName%\" -pe -sky exchange -m 96 -ss My -in \"%RootCertificateName%\" -is my -a sha1\n    ```\n    \n    It is important that the Client Certificate's subject be in the format of `CN=AD_USERNAME`, for example `CN=jon`.\n\nIn an application, when a user starts the sign-in flow using an AD/LDAP Connection:\n\n```\nauth.signin({\n       popup: true,\n       connection: 'FabrikamAD',\n       scope: 'openid name email'\n     }, onLoginSuccess, onLoginFailed);\n```\n\nIf the user's IP address falls within the configured IP range, they'll be prompted to authenticate with a Client Certificate:\n\n![Configure AD/LDAP Connector Authentication with Client Certificates Choose Client Certificate](https://images.ctfassets.net/cdy7uua7fh8z/1loz5lrd2NkHs2gKgbIJKF/11a373d520eaae08c20055cb68613972/connector-client-cert-choose.png)\n\nAfter choosing the certificate the AD/LDAP Connector will validate it and the user will be logged in:\n\n![Configure AD/LDAP Connector Authentication with Client Certificates Logged In User](https://images.ctfassets.net/cdy7uua7fh8z/2Lr78NWYfzD3Hw3JIDPQmb/3790acd68fa283ca79c1263f97fa29c4/connector-client-cert-loggedin.png)",
  "title": "Configure AD/LDAP Connector Authentication with Client Certificates",
  "description": "Describes how to setup authentication using client certificates.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-config-file-schema",
  "markdown": "# AD/LDAP Connector Configuration File Schema\n\n`AD_HUB` The Auth0 endpoint to which the connector will connect. This value is maintained by the connector. `CA_CERT` An authority certificate or array of authority certificates to check the remote host against. `CLIENT_CERT_AUTH` Specifies if **Client Certificate Authentication** is enabled or not. This value is configured in Auth0 and maintained by the connector. `CONNECTION` The name of the connection in Auth0 which is linked to this instance of the connector. This value is maintained by the connector. `CONNECTIONS_API_V2_KEY` A Management API token used to call the Get a connection endpoint. Set this when you need to troubleshoot the connector. This compares the local certificate to the one configured in Auth0 and detects a possible mismatch. `FIREWALL_RULE_CREATED` Set to `true` once the Firewall rule has been created for the Kerberos Server (only when Kerberos is enabled). `GROUPS` Include the user's groups when enriching the profile. `true` `GROUP_PROPERTY` The attribute of the group object used when adding the groups to a user. `cn` `GROUPS_CACHE_SECONDS` Total time in seconds to cache a user's groups. 600 seconds. `GROUPS_TIMEOUT_SECONDS` The timeout in seconds for searching all groups a user belongs to. 20 seconds `HTTP_PROXY` The proxy server URL if one is required to connect from the AD/LDAP Connector to Auth0. `KERBEROS_AUTH` Set if **Kerberos Authentication** is enabled or not. This value is configured in Auth0 and maintained by the connector. `LAST_SENT_THUMBPRINT` Thumbprint of the last certificate which was sent to Auth0. `LDAP_BASE` Defines the location in the directory where the LDAP search begins. For example: `DC=fabrikam,DC=local`. `LDAP_BASE_GROUPS` Defines the location in the directory where the LDAP groups search begins. `LDAP_BIND_PASSWORD` The password of the LDAP user. This setting is automatically removed after the connector initializes. `LDAP_BIND_CREDENTIALS` The encrypted password of the LDAP user. This setting is automatically added after the connector initializes. `LDAP_BIND_USER` The user for binding a connection to LDAP. `LDAP_HEARTBEAT_SEARCH_QUERY` The LDAP search query used for heartbeat checks. `(&(objectclass=user)(|(sAMAccountName=foo)(UserPrincipalName=foo)))` `LDAP_HEARTBEAT_SECONDS` Time in seconds to keep the LDAP connection open. `LDAP_SEARCH_ALL_QUERY` The LDAP query used to list all users in the LDAP store. `(objectCategory=person)` `LDAP_SEARCH_GROUPS` The LDAP query used to find groups in the LDAP store. For example: `(&(objectCategory=group)(member={0}))` `(member:1.2.840.113556.1.4.1941:={0})` `LDAP_SEARCH_QUERY` The LDAP query used to find users in the LDAP store. `(&(objectCategory=person)(anr={0}))` `LDAP_USER_BY_NAME` The LDAP query used to find the user during authentication. This setting lets you specify which attribute is considered the user's username. For example, like the common name: the sAMAccountName, UPN, et cetera. This setting also supports multiple values for an OR search, for example: `(|(sAMAccountName={0})(userPrincipalName={0}))` `(sAMAccountName={0})` `LDAP_URL` The LDAP connection string. For example: `ldap://fabrikam-dc.fabrikam.local`. `PORT` The port the server runs on when Kerberos or Client Certificate Authentication is enabled. `PROVISIONING_TICKET` The Auth0 provisioning ticket used to communicate with Auth0. `REALM` The Auth0 realm, for example: `urn:auth0:fabrikam`. This value is maintained by the connector. `SERVER_URL` The default connector URL will be `server-name:port`, but this setting allows you to overwrite this. For example: `connector.mycompany.com`. `SESSION_SECRET` The session secret used to encrypt the session cookie. `SITE_NAME` When Client Certificate Authentication is enabled, but not possible the AD Connector will show a fallback login page. This setting allows you to specify the title that will show on top of the page. Name of the AD connection. `SSL_CA_PATH` Absolute path to the base directory where the CA certificate file(s) are located. `SSL_KEY_PASSWORD` The password for the SSL certificate. `SSL_PFX` Base64 encoded certificate to use for SSL. `TENANT_SIGNING_KEY` Your Auth0 tenant used to verify JWTs. `WSFED_ISSUER` The issuer being set in the WS-Federation responses. If a connection is configured with email domains, the first email domain configured in Auth0 will be used as issuer. `urn:auth0`",
  "title": "AD/LDAP Connector Configuration File Schema",
  "description": "Describes the AD/LDAP Connector Configuration file contents. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/import-export-ad-ldap-connector-configs",
  "markdown": "# Import and Export AD/LDAP Connector Configurations\n\nYou can export the AD/LDAP Connector configuration or import a previously exported configuration. This is useful for deployments with more than one node of the AD/LDAP Connector deployed for high availability. You can set up and test the configuration on one node then export the working configuration and imported into all subsequent nodes.\n\n1.  From a browser, go to [http://localhost:8357](http://localhost:8357/) to launch the **Connector Admin Console** on the AD/LDAP Connector server.\n    \n2.  Click **Import / Export** tab.\n    \n3.  Export a .zip file that contains the `config.json` file, the `certs` folder and the `lib\\\\profileMapper.js` file from the `%Program Files(x86)%\\Auth0\\AD LDAP Connector\\` folder.\n    \n4.  To import, upload a backup .zip file on the **Import / Export** tab.\n    \n\n## Learn more\n\n*   [Install and Configure AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector)\n*   [Deploy AD/LDAP Connectors for High Availability Environments](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability)\n*   [Update AD/LDAP Connectors](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/update-ad-ldap-connectors)",
  "title": "Import and Export AD/LDAP Connector Configurations",
  "description": "Describes how to import or export an AD/LDAP Connector configuration from the Connector Admin Console.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/map-ad-ldap-profile-attributes-to-auth0",
  "markdown": "# Map AD/LDAP Profile Attributes to Auth0 User Profile\n\nYou can modify the mapping of profile attributes from AD/LDAP attributes to attributes in the Auth0 user profile.\n\n1.  From a browser, go to [http://localhost:8357](http://localhost:8357/) to launch the **Connector Admin Console** on the AD/LDAP Connector server.\n    \n2.  Click **Profile Mapper** to open a code editor screen which maps attributes from a source directory service (represented by the `raw_data` variable) to a variable that gets returned to populate the Auth0 user profile. The first part of the function instantiates a variable called `profile` and has a mapping for the core portion of the Auth0 User Profile. Additional attributes can be set below that using syntax in the form: `profile['department'] = raw_data['companydept'];` In this example, `department` is the name of the attribute in the Auth0 user profile and `companydept` is the name of the attribute in the source directory service (such as AD).\n    \n3.  Click **Save** when you are done modifying the LDAP configuration.\n    \n4.  After the Connector runs the tests, ensure that all the tests are green.\n    \n    | Test | Description | Troubleshoot |\n    | --- | --- | --- |\n    | Test 1 | Attempts to establish a TCP connection to the LDAP server and port specified. | Check basic network connectivity and firewall settings that might prevent such a connection. |\n    | Test 2 | Attempts to perform an LDAP bind on the LDAP server and port specified and with the username and password provided. | Check the LDAP connection string, search path, username and password. |\n    | Test 3 | Attempts to perform an LDAP search against the directory to check the privileges of the specified username. | Check the privileges of the username in the target directory. |\n    | Test 4 | Attempts to establish a connection to the Auth0 server. | Check network connectivity and firewall settings that might prevent such a connection. |",
  "title": "Map AD/LDAP Profile Attributes to Auth0 User Profile",
  "description": "Describes how to map AD/LDAP profile attributes to Auth0 user profile attributes using the Profile Mapper in the Connector Admin Console. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-to-auth0",
  "markdown": "# Point AD/LDAP Connector to Auth0 Connections\n\nYou may need to point your AD/LDAP Connector instance to a new connection in Auth0, for example, If you have migrated to a new Auth0 tenant, or if you changed the name of the Auth0 connection. Because you can't rename connections in Auth0, you must create a new AD/ LDAP connection and point your existing Connector instances to it.\n\n1.  Create the new AD/LDAP connection in the Auth0 dashboard and copy the resulting **TICKET URL**. If you are using the custom domains, you will need to replace the `{yourDomain}` part of the **TICKET URL** with your custom domain, such as `identity.fabrikam.com`.\n    \n2.  On the AD/LDAP Connector host in the Connector Admin app, perform an export of the existing settings via the **Import / Export** tab. This is just a precaution in case something were to happen in the following steps that would accidentally overwrite your custom settings. If you are running the Connector on a host that does not have a web browser to access to the Connector Admin website, simply make a copy of your `config.json` file.\n    \n3.  On the AD/LDAP Connector host, edit the `config.json` file and change the value of the `PROVISIONING_TICKET` property to the **TICKET URL** you copied in Step 1.\n    \n4.  If you moved from one Auth0 tenant to another, remove the property in the `config.json` file that has the name `urn:auth0:{oldAuth0TenantName}`. If this is not removed, the Connector will still function but this old configuration data is not needed.\n    \n5.  Restart the AD/LDAP Connector service (the **Auth0 ADLDAP** service in Windows).\n    \n6.  Take a look at the Connector logs (**Troubleshooting** tab in the Connector Admin tool or tail the `logs.log` file) and make sure there is a recent entry that looks something like: `2016-03-10T22:47:32.970Z - debug: [2016-03-10 22:47:32] Loading settings from ticket: {yourTicketUrl}/info`\n    \n7.  Make sure the new AD/LDAP connection in the Auth0 dashboard is now showing as connected (the dot to the left of the new connection is green and not red).\n    \n8.  Perform a test authentication through your new connection and make sure you see activity in your Connector logs as well.\n    \n\n## Learn more\n\n*   [Troubleshoot AD/LDAP Connector](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-ad-ldap-connector)",
  "title": "Point AD/LDAP Connector to Auth0 Connections",
  "description": "Describes how to point AD/LDAP Connector instances to a new connections in Auth0. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api",
  "markdown": "# Manage Authentication Methods with Management API\n\nThe [Auth0 Management API](https://auth0.com/docs/api/management/v2) provides several endpoints you can use to manage your users' MFA authentication methods.\n\nThis method relies on authenticating using a confidential application. To learn more about confidential vs. public applications, read [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n\n## Get all authentication methods\n\nUse the [Gets a list of authentication methods](https://auth0.com/docs/api/management/v2#!/Users/get_authentication_methods) endpoint to get a list of all of the authentication methods a user has either fully or partially enrolled.\n\nThis endpoint requires the scope: `read:authentication_methods`.\n\n### Examples\n\nThe following request returns a list of all authentication methods for a specified user.\n\n*   [cURL](#3b5a5f122ec3429b9948c16aa1aff26c_shell)\n*   [C#](#3b5a5f122ec3429b9948c16aa1aff26c_csharp)\n*   [Go](#3b5a5f122ec3429b9948c16aa1aff26c_go)\n*   [Java](#3b5a5f122ec3429b9948c16aa1aff26c_java)\n*   [Node.JS](#3b5a5f122ec3429b9948c16aa1aff26c_node)\n*   [Obj-C](#3b5a5f122ec3429b9948c16aa1aff26c_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n[\n  {\n    \"id\": \"totp|dev_XXXXXXXXXXXXXXXX\",\n    \"type\": \"totp\",\n    \"confirmed\": true,\n    \"created_at\": \"2021-09-23T22:57:30.206Z\",\n    \"last_auth_at\": \"2021-09-23T22:57:51.652Z\"\n  }\n]\n```\n\n## Get a single authentication method\n\nUse the [Gets an authentication method by ID](https://auth0.com/docs/api/management/v2#!/Users/get_authentication_methods_by_authentication_method_id) endpoint to get a single authentication method for a user specified by the authentication method's ID.\n\nThis endpoint requires the scope: `read:authentication_methods`.\n\n### Examples\n\nThe following request returns a single authentication method for a user based on the specified authentication method's ID.\n\n*   [cURL](#f700359625d047618aed0838489b967d_shell)\n*   [C#](#f700359625d047618aed0838489b967d_csharp)\n*   [Go](#f700359625d047618aed0838489b967d_go)\n*   [Java](#f700359625d047618aed0838489b967d_java)\n*   [Node.JS](#f700359625d047618aed0838489b967d_node)\n*   [Obj-C](#f700359625d047618aed0838489b967d_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"id\": \"totp|dev_XXXXXXXXXXXXXXXX\",\n    \"type\": \"totp\",\n    \"confirmed\": true,\n    \"created_at\": \"2021-09-23T22:57:30.206Z\",\n    \"last_auth_at\": \"2021-09-23T22:57:51.652Z\"\n}\n```\n\n## Create an authentication method\n\nUse the [Creates an authentication method for a given user](https://auth0.com/docs/api/management/v2#!/Users/post_authentication_methods) endpoint to create an authentication method for a user, including SMS, email, one-time password (OTP), or WebAuthn with security keys. To learn more about available MFA authentication factors, read [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n\nThis endpoint requires the scope: `create:authentication_methods`.\n\n### SMS\n\nSend users an OTP over SMS which the user is then prompted to enter before they can finish authenticating.\n\n#### Examples\n\nThe following request creates a SMS authentication method for a user.\n\n*   [cURL](#125e4fee03724ad591df12b41984cac4_shell)\n*   [C#](#125e4fee03724ad591df12b41984cac4_csharp)\n*   [Go](#125e4fee03724ad591df12b41984cac4_go)\n*   [Java](#125e4fee03724ad591df12b41984cac4_java)\n*   [Node.JS](#125e4fee03724ad591df12b41984cac4_node)\n*   [Obj-C](#125e4fee03724ad591df12b41984cac4_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"type\": \"phone\", \"name\": \"SMS\", \"phone_number\": \"+00000000000\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {type: 'phone', name: 'SMS', phone_number: '+00000000000'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"type\": @\"phone\",\n                              @\"name\": @\"SMS\",\n                              @\"phone_number\": @\"+00000000000\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"POST\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  \"type\": \"phone\",\n  \"name\": \"SMS\",\n  \"phone_number\": \"+00000000000\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"phone\",\n    \"name\": \"SMS\",\n    \"created_at\": \"2023-01-01T00:00:00.000Z\",\n    \"phone_number\": \"user@example.com\",\n    \"id\": \"phone|dev_XXXXXXXXXXXXXXXX\"\n}\n```\n\n### Email\n\nSend users an OTP over email which the user is then prompted to enter before they can finish authenticating. The email factor is only supported when a user has no other factors available.\n\n#### Examples\n\nThe following request creates an email authentication method for a user.\n\n*   [cURL](#f0def55fa5044124a3cf2dc747f56b83_shell)\n*   [C#](#f0def55fa5044124a3cf2dc747f56b83_csharp)\n*   [Go](#f0def55fa5044124a3cf2dc747f56b83_go)\n*   [Java](#f0def55fa5044124a3cf2dc747f56b83_java)\n*   [Node.JS](#f0def55fa5044124a3cf2dc747f56b83_node)\n*   [Obj-C](#f0def55fa5044124a3cf2dc747f56b83_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"type\": \"email\", \"name\": \"Email Factor\", \"email\": \"user@example.com\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {type: 'email', name: 'Email Factor', email: 'user@example.com'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"type\": @\"email\",\n                              @\"name\": @\"Email Factor\",\n                              @\"email\": @\"user@example.com\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"POST\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  \"type\": \"email\",\n  \"name\": \"Email Factor\",\n  \"email\": \"user@example.com\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"email\",\n    \"name\": \"Email Factor\",\n    \"created_at\": \"2023-01-01T00:00:00.000Z\",\n    \"email\": \"user@example.com\",\n    \"id\": \"email|dev_XXXXXXXXXXXXXXXX\"\n}\n```\n\n### One-time passwords (OTP)\n\nEnable users to use an authenticator application, such as Google Authenticator, on their personal device to generate an OTP that changes periodically, which the user is prompted to enter before they finish authenticating.\n\n#### Examples\n\nThe following request creates an OTP authentication method for a user.\n\n*   [cURL](#22cc0e0844fd435982f39f76e6444d36_shell)\n*   [C#](#22cc0e0844fd435982f39f76e6444d36_csharp)\n*   [Go](#22cc0e0844fd435982f39f76e6444d36_go)\n*   [Java](#22cc0e0844fd435982f39f76e6444d36_java)\n*   [Node.JS](#22cc0e0844fd435982f39f76e6444d36_node)\n*   [Obj-C](#22cc0e0844fd435982f39f76e6444d36_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"type\": \"totp\", \"name\": \"OTP Application\", \"totp_secret\": \"{yourSecret}\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {type: 'totp', name: 'OTP Application', totp_secret: '{yourSecret}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"type\": @\"totp\",\n                              @\"name\": @\"OTP Application\",\n                              @\"totp_secret\": @\"{yourSecret}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"POST\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  \"type\": \"totp\",\n  \"name\": \"OTP Application\",\n  \"totp_secret\": \"{yourSecret}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"totp\",\n    \"name\": \"OTP Application\",\n    \"created_at\": \"2023-01-01T00:00:00.000Z\",\n    \"email\": \"user@example.com\",\n    \"id\": \"totp|dev_XXXXXXXXXXXXXXXX\"\n}\n```\n\n### WebAuthn with security keys\n\nEnable users to use FIDO-compliant security keys (for example, [Yubikey](https://www.yubico.com/) or [Google Titan](https://cloud.google.com/titan-security-key)) to perform multi-factor authentication.\n\n#### Examples\n\nThe following request creates a WebAuthn with security keys authentication method for a user.\n\n*   [cURL](#e505fa923c254c44b9d35dc0e72af19d_shell)\n*   [C#](#e505fa923c254c44b9d35dc0e72af19d_csharp)\n*   [Go](#e505fa923c254c44b9d35dc0e72af19d_go)\n*   [Java](#e505fa923c254c44b9d35dc0e72af19d_java)\n*   [Node.JS](#e505fa923c254c44b9d35dc0e72af19d_node)\n*   [Obj-C](#e505fa923c254c44b9d35dc0e72af19d_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"type\": \"webauthn_roaming\", \"name\": \"WebAuthn with security keys\", \"public_key\": \"{yourPublicKey}\", \"key_id\": \"{yourKeyId}\", \"relying_party_identifier\": \"{yourDomain}\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {\n    type: 'webauthn_roaming',\n    name: 'WebAuthn with security keys',\n    public_key: '{yourPublicKey}',\n    key_id: '{yourKeyId}',\n    relying_party_identifier: '{yourDomain}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"type\": @\"webauthn_roaming\",\n                              @\"name\": @\"WebAuthn with security keys\",\n                              @\"public_key\": @\"{yourPublicKey}\",\n                              @\"key_id\": @\"{yourKeyId}\",\n                              @\"relying_party_identifier\": @\"{yourDomain}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"POST\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  \"type\": \"webauthn_roaming\",\n  \"name\": \"WebAuthn with security keys\",\n  \"public_key\": \"{yourPublicKey}\",\n  \"key_id\": \"{yourKeyId}\",\n  \"relying_party_identifier\": \"{yourDomain}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"webauthn-roaming\",\n    \"name\": \"WebAuthn with security keys\",\n    \"relyingPartyIdentifier\": \"example-tenant.auth0.com\",\n    \"keyId\": \"X9FrwMfmzj...\",\n    \"publicKey\": \"bXktcHVibGljLWtle...\",\n    \"created_at\": \"2023-03-09T17:33:47.545Z\",\n    \"id\": \"webauthn-roaming|dev_XXXXXXXXXXXXXXXX\"\n}\n```\n\n## Replace all authentication methods\n\nUse the [Updates all authentication methods by replacing them with the given ones](https://auth0.com/docs/api/management/v2#!/Users/put_authentication_methods) endpoint to replace all existing authentication methods with those provided.\n\nThis endpoint requires the scope: `update:authentication_methods`.\n\n### Examples\n\nThe following request replaces all existing authentication methods for a user.\n\n*   [cURL](#a93d4b978c294c4d8e0ff450c68954de_shell)\n*   [C#](#a93d4b978c294c4d8e0ff450c68954de_csharp)\n*   [Go](#a93d4b978c294c4d8e0ff450c68954de_go)\n*   [Java](#a93d4b978c294c4d8e0ff450c68954de_java)\n*   [Node.JS](#a93d4b978c294c4d8e0ff450c68954de_node)\n*   [Obj-C](#a93d4b978c294c4d8e0ff450c68954de_objc)\n*   [...](#)\n\n```\ncurl --request PUT \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '[{ \"type\": \"phone\", \"preferred_authentication_method\": \"sms\", \"phone_number\": \"+00000000000\", \"name\": \"SMS\" }]'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.PUT);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\")\n\n\treq, _ := http.NewRequest(\"PUT\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.put(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PUT',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: [\n    {\n      type: 'phone',\n      preferred_authentication_method: 'sms',\n      phone_number: '+00000000000',\n      name: 'SMS'\n    }\n  ]\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @[ @{ @\"type\": @\"phone\", @\"preferred_authentication_method\": @\"sms\", @\"phone_number\": @\"+00000000000\", @\"name\": @\"SMS\" } ];\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PUT\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PUT\",\n  CURLOPT_POSTFIELDS => \"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"PUT\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Put.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  [\n    \"type\": \"phone\",\n    \"preferred_authentication_method\": \"sms\",\n    \"phone_number\": \"+00000000000\",\n    \"name\": \"SMS\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PUT\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n[\n  {\n    \"id\": \"phone|dev_XXXXXXXXXXXXXXXX\",\n    \"type\": \"phone\",\n    \"name\": \"SMS\",\n    \"phone_number\": \"+00000000000\",\n    \"created_at\": \"2023-03-09T17:53:23.647Z\",\n    \"preferred_authentication_method\": \"sms\",\n    \"authentication_methods\": [\n      {\n        \"id\": \"sms|dev_XXXXXXXXXXXXXXXX\",\n        \"type\": \"sms\"\n      }\n    ]\n  }\n]\n```\n\n## Update a single authentication method\n\nUse the [Updates an authentication method](https://auth0.com/docs/api/management/v2#!/Users/patch_authentication_methods_by_authentication_method_id) endpoint to update a single authentication method for a user.\n\nThis endpoint requires the scope: `update:authentication_methods`.\n\n### Examples\n\nThe following request updates a single authentication method for a user based on the specific authentication method's ID.\n\n*   [cURL](#a54d5e45e2b74c799ca4ca039519a3b0_shell)\n*   [C#](#a54d5e45e2b74c799ca4ca039519a3b0_csharp)\n*   [Go](#a54d5e45e2b74c799ca4ca039519a3b0_go)\n*   [Java](#a54d5e45e2b74c799ca4ca039519a3b0_java)\n*   [Node.JS](#a54d5e45e2b74c799ca4ca039519a3b0_node)\n*   [Obj-C](#a54d5e45e2b74c799ca4ca039519a3b0_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"name\": \"Mobile SMS\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bear