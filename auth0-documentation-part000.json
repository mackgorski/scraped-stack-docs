[
  {
    "url": "https://auth0.com/docs/quickstart/backend/nodejs/interactive",
    "markdown": "# Auth0 Node (Express) API SDK Quickstarts: Add authorization to an Express.js API application\n\nThis guide demonstrates how to integrate Auth0 with any new or existing Express.js API application using the `express-oauth2-jwt-bearer` package.\n\nIf you have not created an API in your Auth0 dashboard yet, use the interactive selector to create a new Auth0 API or select an existing project API.\n\nTo set up your first API through the Auth0 dashboard, review [our getting started guide](https://auth0.com/docs/get-started/auth0-overview/set-up-apis). Each Auth0 API uses the API Identifier, which your application needs to validate the access token.\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nFirst, install the SDK with `npm`.\n\n```\nnpm install --save express-oauth2-jwt-bearer\n```\n\nConfigure `express-oauth2-jwt-bearer` with your Domain and API Identifier.\n\nThe `checkJwt` middleware shown to the right checks if the user's access token included in the request is valid. If the token is not valid, the user gets a 401 Authorization error when they try to access the endpoints.\n\nThe middleware does not check if the token has sufficient scope to access the requested resources.\n\nTo protect an individual route by requiring a valid JWT, configure the route with the `checkJwt` middleware constructed from `express-oauth2-jwt-bearer`.\n\nYou can configure individual routes to look for a particular scope. To achieve that, set up another middleware with the `requiresScope` method. Provide the required scopes and apply the middleware to any routes you want to add authorization to.\n\nPass the `checkJwt` and `requiredScopes` middlewares to the route you want to protect.\n\nIn this configuration, only access tokens with the `read:messages` scope can access the endpoint.\n\n### Make a Call to Your API\n\nTo make calls to your API, you need an Access Token. You can get an Access Token for testing purposes from the **Test** view in your [API settings](https://manage.auth0.com/#/apis).\n\n![Obtain a JWT](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/request-access-token.png)\n\nProvide the Access Token as an `Authorization` header in your requests.\n\n*   [cURL](#b2c8398041a443d0afcd95e898bd80e5_shell)\n*   [C#](#b2c8398041a443d0afcd95e898bd80e5_csharp)\n*   [Go](#b2c8398041a443d0afcd95e898bd80e5_go)\n*   [Java](#b2c8398041a443d0afcd95e898bd80e5_java)\n*   [Node.JS](#b2c8398041a443d0afcd95e898bd80e5_node)\n*   [Obj-C](#b2c8398041a443d0afcd95e898bd80e5_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url http://your-domain.com/api_path \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'\n```\n\n```\nvar client = new RestClient(\"http://your-domain.com/api_path\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://your-domain.com/api_path\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://your-domain.com/api_path\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://your-domain.com/api_path',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN_HERE'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN_HERE\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://your-domain.com/api_path\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"http://your-domain.com/api_path\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"your-domain.com\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN_HERE\" }\n\nconn.request(\"GET\", \"/api_path\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://your-domain.com/api_path\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN_HERE\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://your-domain.com/api_path\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Checkpoint\n\nNow that you have configured your application, run your application to verify that:\n\n*   `GET /api/public` is available for non-authenticated requests.\n*   `GET /api/private` is available for authenticated requests.\n*   `GET /api/private-scoped` is available for authenticated requests containing an access token with the `read:messages` scope.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [express-oauth2-jwt-bearer SDK](https://github.com/auth0/node-oauth2-jwt-bearer/tree/main/packages/express-oauth2-jwt-bearer) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
    "title": "Auth0 Node (Express) API SDK Quickstarts: Add authorization to an Express.js API application",
    "description": "This tutorial demonstrates how to add authorization to an Express.js API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/quickstart/spa/react/interactive",
    "markdown": "# Add Login to your React App\n\n## Add Login to Your React Application\n\nAuth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in any React application using the Auth0 React SDK.\n\nTo use this quickstart, you’ll need to:\n\n*   Sign up for a free Auth0 account or log in to Auth0.\n*   Have a working React project that you want to integrate with. Alternatively, you can view or download a sample application after logging in.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Web Origins\n\nAn Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.\n\nAuth0 provides a [React SDK](https://github.com/auth0/auth0-react) (auth0-react.js) to simplify the process of implementing Auth0 authentication and authorization in React apps.\n\nInstall the Auth0 React SDK by running the following commands in your terminal:\n\n```\ncd <your-project-directory>\nnpm install @auth0/auth0-react\n```\n\n### Configure the Auth0Provider component\n\nFor the SDK to function properly, you must set the following properties in the Auth0Provider component:\n\n*   `domain`: The domain of your Auth0 tenant. Generally, you can find this in the Auth0 Dashboard under your Application's Settings in the Domain field. If you are using a [custom domain](https://auth0.com/docs/custom-domains), you should set this to the value of your custom domain instead.\n*   `clientId`: The ID of the Auth0 Application you set up earlier in this quickstart. You can find this in the Auth0 Dashboard under your Application's Settings in the Client ID field.\n*   `authorizationParams.redirect_uri`: The URL in your application that you would like Auth0 to redirect users to after they have authenticated. This corresponds to the callback URL you set up earlier in this quickstart. You can also find this value in the Auth0 Dashboard under your Application's Settings in the Callback URLs field. Make sure what you enter in your code matches what you set up earlier or your users will see an error.\n\n##### Checkpoint\n\nYour Auth0Provider component should now be properly configured. Run your application to verify that:\n\n*   the SDK is initializing correctly\n*   your application is not throwing any errors related to Auth0\n\nNow that you have configured your Auth0 Application and the Auth0 React SDK, you need to set up login for your project. To do this, you will use the SDK’s loginWithRedirect() method to create a login button that redirects users to the Auth0 Universal Login page. After a user successfully authenticates, they will be redirected to the callback URL you set up earlier in this quickstart.\n\nCreate a new file in your application called `login.js` for the login button component, and copy in the code from the interactive panel to the right, which contains the logic needed for login. Then, update your `index.js` file to include the new login button.\n\n##### Checkpoint\n\nYou should now be able to log in or sign up using a username and password.\n\nClick the login button and verify that:\n\n*   your React Application redirects you to the Auth0 Universal Login page\n*   you can log in or sign up\n*   Auth0 redirects you to your application using the value of the `authorizationParams.redirect_uri` you used to configure the `Auth0Provider`\n\nUsers who log in to your project will also need a way to log out. Create a logout button using the SDK’s logout() method. When users log out, they will be redirected to your [Auth0 logout](https://auth0.com/docs/api/authentication?javascript#logout) endpoint, which will then immediately redirect them to the logout URL you set up earlier in this quickstart.\n\nCreate a new file in your application called `logout.js` for the logout button component, and copy in the code from the interactive panel, which contains the logic needed for logout. Then, update your `index.js` file to include the logout button.\n\n##### Checkpoint\n\nRun your application and click the logout button, verify that:\n\n*   your React application redirects you to the address you specified as one of the Allowed Logout URLs in your Application Settings\n*   you are no longer logged in to your application\n\nNow that your users can log in and log out, you will likely want to be able to retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with authenticated users. For example, you may want to be able to display a logged-in user’s name or profile picture in your project.\n\nThe Auth0 React SDK provides user information through the `user` property. Review the `profile.js` code in the interactive panel to see an example of how to use it.\n\nBecause the `user` property contains sensitive information related to the user's identity, its availability depends on the user's authentication status. To prevent render errors, you should always:\n\n*   use the `isAuthenticated` property to determine whether Auth0 has authenticated the user before React renders any component that consumes the `user` property.\n*   ensure that the SDK has finished loading by checking that `isLoading` is false before accessing the `isAuthenticated` property.\n\n##### Checkpoint\n\nVerify that:\n\n*   you can display the `user.name` or any other user property within a component correctly after you have logged in\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-react SDK](https://www.github.com/auth0/auth0-react/) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
    "title": "Auth0 React SDK Quickstarts: Add Login to your React App",
    "description": "Auth0 allows you to add authentication to your React application quickly and to gain access to user profile information. This guide demonstrates how to integrate Auth0 with any new or existing React application using the Auth0 React SDK.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/quickstart/spa/vanillajs/interactive",
    "markdown": "# Add login to your JavaScript App\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Web Origins\n\nAn Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.",
    "title": "Auth0 JavaScript SDK Quickstarts: Add login to your JavaScript App",
    "description": "Auth0 allows you to add authentication to your JavaScript application quickly and to gain access to user profile information. This guide demonstrates how to integrate Auth0 with any new or existing JavaScript application using the Auth0 SPA SDK.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/api",
    "markdown": "# Auth0 APIs\n\nAuth0 exposes the following APIs for developers to consume in their applications.\n\n## Authentication API\n\nThe Authentication API exposes identity functionality for Auth0 and supported identity protocols (including OpenID Connect, OAuth, and SAML).\n\nTypically, you should consume this API through one of the Auth0 SDKs, such as [Auth0.js](https://auth0.com/docs/libraries/auth0js), or a library like [Lock](https://auth0.com/docs/libraries/lock). However, if you are building your authentication UI manually, you will need to call the Authentication API directly.\n\nSome example tasks include:\n\n*   Get [tokens](https://auth0.com/docs/secure/tokens) during authentication\n    \n*   Request a user's profile using an [Access Token](https://auth0.com/docs/secure/tokens/access-tokens)\n    \n*   Exchange [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens) for new Access Tokens\n    \n*   Request a challenge for [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication)\n    \n\n### API\n\nLearn about and explore the requests and responses for the Auth0 Authentication API endpoints in your browser with the [Authentication API](https://auth0.com/docs/auth-api).\n\n## Management API\n\nThe Management API allows you to manage your Auth0 account programmatically, so you can automate configuration of your environment. Most of the tasks you can perform in the Auth0 Management Dashboard can also be performed programmatically by using this API.\n\nSome example tasks include:\n\n*   Register your applications and APIs with Auth0\n    \n*   Set up [connections](https://auth0.com/docs/connections) with which your users can authenticate\n    \n*   [Manage users](https://auth0.com/docs/manage-users)\n    \n*   [Link user accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n    \n\nFor Public Cloud tenants, Management API endpoints return a maximum of 50 results per response. When there are more results than can be returned in a response, include the `page` and `per_page` parameters in your request to retrieve more results.\n\nSee [Migrate to Management API v2 Endpoint Paginated Queries](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-paginated-queries) for information on updating your applications.\n\n### API Explorer\n\nLearn about and use the Auth0 Management API in your browser with the [Management API Explorer](https://auth0.com/docs/api/v2).\n\n### Management API v1 has been deprecated\n\nThe Management API v1 is deprecated and should not be used for new projects.\n\nManagement API v1 reached its End of Life on **July 13, 2020**. You may have been required to take action before that date to ensure no interruption to your service. Notifications were sent to customers that needed to complete this migration.",
    "title": "Auth0 APIs",
    "description": "Learn about Auth0's Management and Authentication APIs.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/libraries/lock",
    "markdown": "# Lock for Web\n\nLock is an embeddable login form that can be [configured to your needs](https://auth0.com/docs/libraries/lock/v11/configuration) and is recommended for use in single-page apps, preferably in conjunction with [Universal Login](https://auth0.com/docs/universal-login), which should be used whenever possible. Lock enables you to easily add social identity providers, so that your users can log in seamlessly using any desired provider.\n\n## Lock Installation\n\nYou can install Lock via several methods. Select any of the following installation sources that best suit your environment and application.\n\n### Installation Sources\n\nInstall via [npm](https://npmjs.org/): `npm install auth0-lock`\n\nInstall via [bower](http://bower.io/):\n\n`bower install auth0-lock`\n\nInclude via our CDN (Replace `.x` and `.y` with the latest minor and patch release numbers from the [Lock Github repository](https://github.com/auth0/lock/releases):\n\nLatest Minor Release: `<script src=\"https://cdn.auth0.com/js/lock/11.x/lock.min.js\"></script>` Latest Patch Release: `<script src=\"https://cdn.auth0.com/js/lock/11.x.y/lock.min.js\"></script>`\n\nIt is recommended that production applications use a specific patch version, or at the very least a specific minor version. Regardless of the method by which Lock is included, the recommendation is that the version should be locked down and only manually updated, to ensure that those updates do not adversely affect your implementation. Check the [GitHub repository](https://github.com/auth0/lock/releases) for a current list of releases.\n\n### Mobile\n\nIf you are targeting mobile audiences, Auth0 recommends that you add the following meta tag to your application's `head`:\n\n`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>`\n\n### Bundling Dependencies\n\nIf you are using browserify or webpack to build your project and bundle its dependencies, after installing the `auth0-lock` module, you will need to bundle it with all its dependencies. Examples are available for [Browserify](https://github.com/auth0/lock/tree/master/examples/bundling/browserify) and [webpack](https://github.com/auth0/lock/tree/master/examples/bundling/webpack).\n\n### Cross-Origin Authentication\n\nEmbedding Lock within your application requires [cross-origin authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication) to be properly configured. Specifically, you need to set the **Allowed Web Origins** property to the domain making the request. You can find this field in the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\nMake sure you read about the limitations of cross-origin authentication before implementing embedded login with Lock.\n\n## Usage\n\n### 1\\. Initializing Lock\n\nFirst, you'll need to initialize a new `Auth0Lock` object, and provide it with your Auth0 client ID (the unique client ID for each Auth0 application, which you can get from the [management dashboard](https://manage.auth0.com/#)) and your Auth0 domain (for example `yourname.auth0.com`).\n\nto configure this snippet with your account\n\n```\n// Initializing our Auth0Lock\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}'\n);\n```\n\n### 2\\. Authenticating and Getting User Info\n\nNext, listen using the `on` method for the `authenticated` event. When the event occurs, use the `accessToken` which was received to call the `getUserInfo` method and acquire the user's profile information (as needed).\n\nto configure this snippet with your account\n\n```\nvar Auth = (function() {\n\n  var wm = new WeakMap();\n  var privateStore = {};\n  var lock;\n\n  function Auth() {\n    this.lock = new Auth0Lock(\n      '<{yourClientId}>',\n      '<{yourDomain}>'\n    );\n    wm.set(privateStore, {\n      appName: \"example\"\n    });\n  }\n\n  Auth.prototype.getProfile = function() {\n    return wm.get(privateStore).profile;\n  };\n\n  Auth.prototype.authn = function() {\n    // Listening for the authenticated event\n    this.lock.on(\"authenticated\", function(authResult) {\n      // Use the token in authResult to getUserInfo() and save it if necessary\n      this.getUserInfo(authResult.accessToken, function(error, profile) {\n        if (error) {\n          // Handle error\n          return;\n        }\n\n        //we recommend not storing Access Tokens unless absolutely necessary\n        wm.set(privateStore, {\n          accessToken: authResult.accessToken\n        });\n\n        wm.set(privateStore, {\n          profile: profile\n        });\n\n      });\n    });\n  };\n  return Auth;\n}());\n```\n\nYou can then manipulate page content and display profile information to the user (for example, displaying their name in a welcome message).\n\n`<h2>Welcome <span id=\"nick\" class=\"nickname\"></span></h2>`\n\nNote that if you are storing the user profile, you will want to `JSON.stringify` the profile object and then, when using it later, `JSON.parse` it, because it will need to be stored in `localStorage` as a string rather than a JSON object.\n\n### 3\\. Showing Lock\n\nHere you're showing the Lock widget after the user clicks a login button; you can just as easily show Lock automatically when arriving at a page by just using `lock.show();` on page load.\n\nThis will show the Lock widget, and paired with the above, you're now ready to handle logins!\n\n```\ndocument.getElementById('btn-login').addEventListener('click', function() {\n  lock.show();\n});\n```\n\n## Passwordless\n\nLock's Passwordless Mode is only available in Lock v11.2.0 and later. Please use the [latest release of Lock](https://github.com/auth0/lock/releases) for this feature!\n\nYou can use Lock's Passwordless Mode to allow users to authenticate using just an email or mobile number. They will receive the code and then return to input it, or click the link, and they can be authenticated without remembering a password.\n\nIn Lock, in order to implement Passwordless Mode, you initialize Lock in a slightly different manner, with `Auth0LockPasswordless` rather than with `Auth0Lock`:\n\nto configure this snippet with your account\n\n```\nvar lockPasswordless = new Auth0LockPasswordless(\n '{yourClientId}',\n '{yourDomain}'\n);\n```\n\n### Passwordless options\n\nAdditionally, Lock's Passwordless Mode has a couple of configuration options that are unique to it.\n\nIn order to indicate which connection type you would like, you initialize Lock with the `allowedConnections` option with either `email` or `sms` as the value:\n\n```\nvar passwordlessOptions = {\n  allowedConnections: ['sms']\n}\n```\n\nRemember to enable the passwordless connection of your choice in the [Dashboard](https://manage.auth0.com/#) under **Connections -> Passwordless**, and then to enable it for your application, that way when Lock tries to use it, it is already set up and linked to the application.\n\nIf you choose to use `email`, you have one more option to select - whether you wish your users to receive a code to input, or a \"magic link\" to use. This is done via the `passwordlessMethod` option, which takes values of `code` or `link`.\n\n```\nvar passwordlessOptions = {\n  allowedConnections: ['email'],\n  passwordlessMethod: 'code'\n}\n```\n\n### Passwordless example\n\nto configure this snippet with your account\n\n```\nvar passwordlessOptions = {\n  allowedConnections: ['email'],\n  passwordlessMethod: 'code',\n  auth: {\n    redirectUrl: 'http://localhost:3000/callback',   \n    responseType: 'token id_token',\n    params: {\n      scope: 'openid email'               \n    }          \n  }\n}\n\nvar lockPasswordless = new Auth0LockPasswordless(\n '{yourClientId}',\n '{yourDomain}',\n passwordlessOptions\n);\n```\n\n### Single Sign-On with embedded authentication\n\nApps with embedded login must meet two criteria in order to have Single Sign-on (SSO).\n\n1.  Both of the applications attempting SSO must be first-party applications. SSO with third-party applications will not work.\n    \n2.  They need to make use of custom domains and have both the applications which intend to have SSO as well as the Auth0 tenant on the same domain. Traditionally, Auth0 domains are in the format `foo.auth0.com`, but custom domains allow you to use the same domain for each of the applications in question as well as your Auth0 tenant, preventing the risk of CSRF attacks.\n    \n\nOur recommendation is to use Universal Login instead of setting up SSO in embedded login scenarios. Universal Login is the most reliable and stable way to perform SSO, and is the only way to do so if you must use multiple domains for your applications, or use [third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications).\n\n## Error Codes and Descriptions\n\nWhen Lock is used for embedded login, it employs the `/co/authenticate` endpoint, which has the following errors.\n\nThe error description is human readable. It **should not be parsed by any code** and it subject to change at any time.\n\n| **Status** | **Code** | **Description** |\n| --- | --- | --- |\n| 400 | invalid\\_request | Invalid request body. All and only of client\\_id, credential\\_type, username, otp, realm are required. |\n| 401 | unauthorized\\_client | Cross origin login not allowed. |\n| 400 | unsupported\\_credential\\_type | Unknown credential type parameter. |\n| 400 | invalid\\_request | Unknown realm non-existent-connection. |\n| 403 | access\\_denied | Wrong email or password. |\n| 403 | access\\_denied | Authentication error |\n| 403 | blocked\\_user | Blocked user |\n| 401 | password\\_leaked | This login attempt has been blocked because the password you're using was previously disclosed through a data breach (not in this application). |\n| 429 | too\\_many\\_attempts | Your account has been blocked after multiple consecutive login attempts. We've sent you a notification via your preferred contact method with instructions on how to unblock it. |\n| 429 | too\\_many\\_attempts | We have detected suspicious login behavior and further attempts will be blocked. Please contact the administrator. |\n\n## Browser Compatibility\n\nBrowser compatibility is ensured for **Chrome**, **Safari**, **Firefox** and **IE >= 10**. Auth0 currently uses [zuul](https://github.com/defunctzombie/zuul) along with [Saucelabs](https://saucelabs.com/) to run integration tests on each push.\n\n## Learn more\n\n*   [Lock API Reference](https://auth0.com/docs/libraries/lock/lock-api-reference)\n*   [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration)",
    "title": "Lock for Web",
    "description": "A widget that provides a frictionless login and signup experience for your web apps.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate",
    "markdown": "# Authenticate\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nIn authentication, a user or application proves they are who they say they are by providing valid credentials. The most common verification is password, often combined with other methods, such as a fingerprint.\n\nAuth0 simplifies the use of open industry standards like OAuth 2.0, OIDC, and SAML to authenticate. Users can log into your applications with social media credentials, corporate accounts, and a broad range of other credentials.\n\n* * *\n\n## Add Login\n\n##### Implement Auth0 Universal Login (or an alternative) to control access to your applications.\n\n* * *\n\n## Provision Users\n\n##### Source users from social identity providers (such as Facebook or SalesForce), enterprise user stores (such as Active Directory or Google Workspace), a custom database, and more.",
    "title": "Authenticate",
    "description": "Learn all about how to authenticate using Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers",
    "markdown": "# Identity Providers\n\nIntroduction to the various sources of users for applications, including identity providers, databases, and passwordless authentication methods.\n\nA connection is the relationship between Auth0 and a source of users, which may include external Identity Providers (such as Google or LinkedIn), databases, or passwordless authentication methods. Auth0 sits between your application and its sources of users, which adds a level of abstraction, so your application is isolated from any changes to and idiosyncrasies of each source's implementation.\n\nBy default, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. You can disable synchronization to allow for updating profile attributes from your application.\n\nYou can configure any number of connections for your applications.",
    "title": "Identity Providers",
    "description": "Learn about types of identity providers supported by Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/quickstart/webapp/nextjs",
    "markdown": "# Auth0 Next.js SDK Quickstarts: Login\n\nThis guide demonstrates how to integrate Auth0 with any new or existing Next.js application using the Auth0 Next.js SDK. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Next.js 13.4+\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Install the Auth0 Next.js SDK\n\nRun the following command within your project directory to install the Auth0 Next.js SDK:\n\n```\nnpm install @auth0/nextjs-auth0\n```\n\nThe SDK exposes methods and variables that help you integrate Auth0 with your Next.js application using [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) on the backend and [React Context](https://reactjs.org/docs/context.html) with [React Hooks](https://reactjs.org/docs/hooks-overview.html) on the frontend.\n\n### Configure the SDK\n\nIn the root directory of your project, add the file `.env.local` with the following [environment variables](https://nextjs.org/docs/basic-features/environment-variables):\n\n```\nAUTH0_SECRET='use [openssl rand -hex 32] to generate a 32 bytes value'\nAUTH0_BASE_URL='http://localhost:3000'\nAUTH0_ISSUER_BASE_URL='https://{yourDomain}'\nAUTH0_CLIENT_ID='{yourClientId}'\nAUTH0_CLIENT_SECRET='{yourClientSecret}'\n```\n\n*   `AUTH0_SECRET`: A long secret value used to encrypt the session cookie. You can generate a suitable string using `openssl rand -hex 32` on the command line.\n*   `AUTH0_BASE_URL`: The base URL of your application.\n*   `AUTH0_ISSUER_BASE_URL`: The URL of your Auth0 tenant domain. If you are using a [Custom Domain with Auth0](https://auth0.com/docs/custom-domains), set this to the value of your Custom Domain instead of the value reflected in the \"Settings\" tab.\n*   `AUTH0_CLIENT_ID`: Your Auth0 application's Client ID.\n*   `AUTH0_CLIENT_SECRET`: Your Auth0 application's Client Secret.\n\nThe SDK will read these values from the Node.js process environment and automatically configure itself.\n\n### Add the dynamic API route handler\n\nCreate a file at `app/api/auth/[auth0]/route.js`. This is your Route Handler file with a [Dynamic Route Segment](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#dynamic-route-segments).\n\nThen, import the `handleAuth` method from the SDK and call it from the `GET` export.\n\n```\n// app/api/auth/[auth0]/route.js\nimport { handleAuth } from '@auth0/nextjs-auth0';\n\nexport const GET = handleAuth();\n```\n\nThis creates the following routes:\n\n*   `/api/auth/login`: The route used to perform login with Auth0.\n*   `/api/auth/logout`: The route used to log the user out.\n*   `/api/auth/callback`: The route Auth0 will redirect the user to after a successful login.\n*   `/api/auth/me`: The route to fetch the user profile from.\n\n### Add the UserProvider component\n\nOn the frontend side, the SDK uses React Context to manage the authentication state of your users. To make that state available to all your pages, you need to override the [Root Layout component](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required) and wrap the `<body>` tag with a `UserProvider` in the file `app/layout.jsx`.\n\nCreate the file `app/layout.jsx` as follows:\n\n```\n// app/layout.jsx\nimport { UserProvider } from '@auth0/nextjs-auth0/client';\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n    <UserProvider>\n      <body>{children}</body>\n    </UserProvider>\n    </html>\n  );\n}\n```\n\nThe authentication state exposed by `UserProvider` can be accessed in any Client Component using the `useUser()` hook.\n\n### Checkpoint\n\nNow that you have added the dynamic route and `UserProvider`, run your application to verify that your application is not throwing any errors related to Auth0.\n\n## Add Login to Your Application\n\nUsers can now log in to your application by visiting the `/api/auth/login` route provided by the SDK. Add a link that points to the login route using an **anchor tag**. Clicking it redirects your users to the Auth0 Universal Login Page, where Auth0 can authenticate them. Upon successful authentication, Auth0 will redirect your users back to your application.\n\n```\n<a href=\"/api/auth/login\">Login</a>\n```\n\n### Checkpoint\n\nAdd the login link to your application. When you click it, verify that your Next.js application redirects you to the [Auth0 Universal Login](https://auth0.com/universal-login) page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects back to your application.\n\n![Auth0 Universal Login](https://auth0.com/docs/media/quickstarts/universal-login.png)\n\n## Add Logout to Your Application\n\nNow that you can log in to your Next.js application, you need [a way to log out](https://auth0.com/docs/logout/log-users-out-of-auth0). Add a link that points to the `/api/auth/logout` API route. Clicking it redirects your users to your [Auth0 logout endpoint](https://auth0.com/docs/api/authentication?javascript#logout) (`https://YOUR_DOMAIN/v2/logout`) and then immediately redirects them back to your application.\n\n```\n<a href=\"/api/auth/logout\">Logout</a>\n```\n\n### Checkpoint\n\nAdd the logout link to your application. When you click it, verify that your Next.js application redirects you to the address you specified as one of the \"Allowed Logout URLs\" in the \"Settings\".\n\n## Show User Profile Information\n\nThe Auth0 Next.js SDK helps you retrieve the [profile information](https://auth0.com/docs/users/user-profiles) associated with the logged-in user, such as their name or profile picture, to personalize the user interface.\n\n### From a Client Component\n\nThe profile information is available through the `user` property exposed by the `useUser()` hook. Take this [Client Component](https://nextjs.org/docs/getting-started/react-essentials#client-components) as an example of how to use it:\n\n```\n'use client';\n\nimport { useUser } from '@auth0/nextjs-auth0/client';\n\nexport default function ProfileClient() {\n  const { user, error, isLoading } = useUser();\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>{error.message}</div>;\n\n  return (\n    user && (\n      <div>\n        <img src={user.picture} alt={user.name} />\n        <h2>{user.name}</h2>\n        <p>{user.email}</p>\n      </div>\n    )\n  );\n}\n```\n\nThe `user` property contains sensitive information and artifacts related to the user's identity. As such, its availability depends on the user's authentication status. To prevent any render errors:\n\n*   Ensure that the SDK has completed loading before accessing the `user` property by checking that `isLoading` is `false`.\n*   Ensure that the SDK has loaded successfully by checking that no `error` was produced.\n*   Check the `user` property to ensure that Auth0 has authenticated the user before React renders any component that consumes it.\n\n### From a Server Component\n\nThe profile information is available through the `user` property exposed by the `getSession` function. Take this [Server Component](https://nextjs.org/docs/getting-started/react-essentials#server-components) as an example of how to use it:\n\n```\nimport { getSession } from '@auth0/nextjs-auth0';\n\nexport default async function ProfileServer() {\n  const { user } = await getSession();\n\n  return (\n      user && (\n          <div>\n            <img src={user.picture} alt={user.name} />\n            <h2>{user.name}</h2>\n            <p>{user.email}</p>\n          </div>\n      )\n  );\n}\n```\n\n### Checkpoint\n\nVerify that you can display the `user.name` or [any other](https://auth0.com/docs/users/user-profile-structure#user-profile-attributes) `user` property within a component correctly after you have logged in.\n\n## What's next?\n\nWe put together a few examples of how to use [nextjs-auth0](https://github.com/auth0/nextjs-auth0) in more advanced use cases:\n\n*   [Protecting a Server Side Rendered (SSR) Page](https://github.com/auth0/nextjs-auth0/blob/main/EXAMPLES.md#protecting-a-server-side-rendered-ssr-page)\n*   [Protecting a Client Side Rendered (CSR) Page](https://github.com/auth0/nextjs-auth0/blob/main/EXAMPLES.md#protecting-a-client-side-rendered-csr-page)\n*   [Protect an API Route](https://github.com/auth0/nextjs-auth0/blob/main/EXAMPLES.md#protect-an-api-route)\n*   [Access an External API from an API Route](https://github.com/auth0/nextjs-auth0/blob/main/EXAMPLES.md#access-an-external-api-from-an-api-route)",
    "title": "Auth0 Next.js SDK Quickstarts: Login",
    "description": "This guide demonstrates how to integrate Auth0 with any new or existing Next.js application using the Auth0 Next.js SDK.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections",
    "markdown": "# Database Connections\n\nAuth0 provides database connections to authenticate users with an email/username and password. These credentials are securely stored in the Auth0 user store or in your own database.\n\nYou can create a new database connection and manage existing ones at [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database):\n\n![Select connection](https://images.ctfassets.net/cdy7uua7fh8z/6shISO4Uw6XqldxxGnbrqW/0215e069f09c6baebd1d7abb5b3ae253/2024-03-20_16-39-37.png)\n\n## Scenarios\n\nAuth0 provides the database infrastructure to store your users by default. This scenario provides the best performance for the authentication process since all data is stored in Auth0.\n\nThe Auth0-hosted database is highly secure. Passwords are never stored or logged in plain text but are hashed with **bcrypt**. Varying levels of password security requirements can also be enforced. To learn more, read [Password Strength in Auth0 Connections](https://auth0.com/docs/authenticate/database-connections/password-strength).\n\n## Learn more\n\n*   [Manage Users](https://auth0.com/docs/manage-users)",
    "title": "Database Connections",
    "description": "Learn how to create and use a database connection using either the Auth0 user store or your own user store.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize",
    "markdown": "# Customize\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nAuth0 lets you customize your users’ entire authentication experience. You can:\n\n*   Brand and internationalize all interaction with end users\n    \n*   Define your own logic to customize and extend how Auth0 works\n    \n*   Integrate Auth0 with third-party software to add capabilities\n    \n\n* * *\n\n## Brand Customization\n\n##### Seamlessly integrate Auth0 with your own brand and localize the experience for international users.\n\n* * *\n\n## Code Customization\n\n##### Create Actions to customize and extend Auth0’s capabilities with custom logic. Or maintain legacy Rules and Hooks.\n\n* * *\n\n## Third-Party Customization\n\n##### Take advantage of third-party integrations and Auth0 extensions to expand what Auth0 can do for your systems.",
    "title": "Customize",
    "description": "Learn how to brand, customize, and localize your login pages, domain names, emails sent to users, and consent prompts.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users",
    "markdown": "# Manage Users\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nAuth0's hosted cloud database stores user data that is available to you via user profiles. The user information itself can come from a variety of sources, including identity providers, your own databases, and enterprise connections (such as Active Directory or SAML).\n\n* * *\n\n## Manage Users\n\n##### Import, group, and administer users and control their access.\n\n* * *\n\n## Manage Access\n\n##### Control who can interact within your applications.",
    "title": "Manage Users",
    "description": "Learn about working with users, user profiles, and user metadata in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure",
    "markdown": "# Secure\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nAuth0 provides critical tools for securing your applications against people who are interested in attacking information technology systems. Multi-factor authentication (MFA) reduces risk by requiring more than one type of user validation, while attack protection features automatically detect and respond to malicious behavior such as rapid, repeated failed logins or one IP address rapidly attempting to log into multiple accounts. \n\nAuth0 maintains and meets the requirements for multiple compliance frameworks and certifications including GDPR and HIPAA.\n\n* * *\n\n## Protect Your Application\n\n##### Make sure only the right people can access your applications.\n\n* * *\n\n## Compliance\n\n##### Learn how Auth0 meets requirements for multiple compliance frameworks and certifications, including GDPR and HIPAA.",
    "title": "Secure",
    "description": "Learn about various security-related issues, such as handling tokens, preventing security attacks, AllowListing, data privacy, and Auth0 security bulletins",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor",
    "markdown": "# Deploy and Monitor\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nYou can deploy Auth0 to the public cloud, a private cloud on AWS, or a private cloud on Azure. Deployment tools and checklists smooth the process. Monitoring tools and event logs let you track system health and events.\n\n* * *\n\n## Deployment\n\n##### Plan, check, and execute your Auth0 deployment.\n\n* * *\n\n## Monitoring\n\n##### Monitor events and service status and work with tenant log event data.",
    "title": "Deploy and Monitor",
    "description": "Learn about Auth0 public and private cloud deployment options, as well as deployment checklists and tools. ",
    "languageCode": null
  },
  {
    "url": "https://jonmeyers.io/blog-series/build-a-saas-platform-with-next-js-prisma-auth0-and-stripe/",
    "markdown": "# Build a SaaS Platform with Next.js, Prisma, Auth0 and Stripe (series)twitterSoundcloud\n\n[*   Tech stack and initial project setup](https://jonmeyers.io/blog/tech-stack-and-initial-project-setup)[*   Hosting on Vercel, automatic deploys with GitHub and configuring custom domains](https://jonmeyers.io/blog/hosting-on-vercel-automatic-deploys-with-github-and-configuring-custom-domains)[*   Authentication with Auth0 and Next.js](https://jonmeyers.io/blog/authentication-with-auth0-and-next-js)[*   Social login with GitHub and Auth0 rules](https://jonmeyers.io/blog/social-login-with-github-and-auth0-rules)[*   Processing payments with Stripe and webhooks](https://jonmeyers.io/blog/processing-payments-with-stripe-and-webhooks)[*   Implementing subscriptions with Stripe](https://jonmeyers.io/blog/implementing-subscriptions-with-stripe)\n\n* * *\n\nIn this series we are going to create an application with subscription-based billing. We will be using Next.js, Vercel, Prisma, Supabase, Auth0 and Stripe to build a network of services that stay in sync via change events sent as webhooks.\n\nWe will be covering:\n\n*   static site generation (SSG) vs serverside rendering (SSR)\n*   application hosting\n*   environment variables\n*   authentication\n*   authorization\n*   social login with GitHub\n*   schema design\n*   migrations\n*   relationships between tables\n*   queries with joins across tables\n*   serverless functions\n*   charging for an individual item\n*   recurring subscription payments\n*   customer portals\n*   and so much more!",
    "title": "Build a SaaS Platform with Next.js, Prisma, Auth0 and Stripe (series)",
    "description": "In this series we are going to create an application with subscription-based billing. We will be using Next.js, Vercel, Prisma, Supabase, Auth0 and Stripe to build a network of services that stay in sync via change events sent as webhooks. We will be covering static site generation (SSG) vs serverside rendering (SSR), application hosting, environment variables, authentication, authorisation, social login with GitHub, schema design, migrations, relationships between tables, queries with joins across tables, serverless functions, charging for an individual item, recurring subscription payments, customer portals and so much more!",
    "languageCode": "en"
  },
  {
    "url": "https://egghead.io/blog/saas-app-with-nextjs-prisma-auth0-and-stripe",
    "markdown": "# Building a SaaS Application with Next.js, Prisma, Auth0 and Stripe\n\n## Introduction\n\nThis article is about my experience building a SaaS application. And while this won't be a step-by-step guide on how to build a SaaS app, I will be providing you valuable insight on what the process was like for me as well as teaching you about the methods and technologies that I used.\n\nSoftware as a Service (SaaS) is a business model whereby the user pays a subscription to access cloud-based services or an application. In my case, I wanted to build an educational course platform where users can purchase an individual course to own for life or pay a subscription to gain access to all premium courses.\n\nBefore building this application, I had only used Stripe Checkout to process one-off payments. I wanted to use this opportunity to go a little deeper - primarily learning how Stripe handles recurring payments. I plan to implement what I have learned throughout this process into my [site](https://jonmeyers.io/), which will house my premium courses one day.\n\nThe final version of this SaaS project ended up with a few third-party services, each handling their own piece of the puzzle and using webhooks to keep them in sync. Below is an architecture diagram representing the relationships between those services.\n\n![architecture diagram representing the relationships between third party services](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1619542684/egghead-next-ebombs/how-i-built-a-subscription-based-saas-product-in-six-weeks-using-next-js-prisma-auth0-and-stripe/Screen_Shot_2021-04-14_at_8.39.48_pm.png)\n\nThis article will focus on each chunk of the stack individually. I will talk through why I chose each technology and discuss any problems I ran into during the process.\n\n[Here is the project repo](https://github.com/dijonmusters/courses) for those after the code and a [live version of the final project named \"Courses\"](https://courses-saas.vercel.app/). FYI, payments are real! You have been warned, and thank you for your donation! 😆\n\n## What will be covered?\n\n*   High-level explanation of why certain technologies were chosen\n*   Biggest problems encountered throughout and how they were solved\n*   Next.js and the use cases for pregeneration vs serverside rendering\n*   Hosting, secrets, and automatic deploys with Vercel\n*   Prisma as an ORM, as well as the project's database schema and migrations\n*   Using Auth0 for authentication, GitHub as a social provider, and webhooks to keep things in sync\n*   Stripe for individual payments, subscriptions, and more webhooks!\n\n## What will not be covered?\n\n*   A step-by-step guide for building a SaaS project - I wrote a [blog article each week](https://jonmeyers.io/blog/build-a-saas-platform-with-stripe) as I was building the project, which goes into more granular detail.\n\n[![Create an eCommerce Store with Next.js and Stripe Checkout](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1638622187/course-resources/build-a-saas-product-with-next-js-supabase-and-stripe/og-image--build-a-saas-product-with-next-js-supabase-and-stripe_2x.png)](https://egghead.io/courses/build-a-saas-product-with-next-js-supabase-and-stripe-61f2bc20?utm_source=blog_post&utm_medium=course_cta&utm_term=supabase)\n\n## Tech stack\n\n*   **Next.js** was used to build the UI, as well as the small chunks of server-side logic required for fetching gated content from Prisma, initiating authentication with Auth0, and payments with Stripe\n*   **Vercel** was used as a hosting platform for the application and its serverless functions\n*   **Prisma** provides a beautiful query-building language to abstract away those scary, complex SQL queries\n*   **Supabase** was used to host a Postgres database instance - it is capable of so much more around authentication and real-time database events, but we already had those pieces solved\n*   **Auth0** was used to authenticate users with GitHub, manage sessions and protect both client and API routes in Next.js\n*   **Stripe** was used to process payments, subscriptions and host a customer portal for users to manage their subscription and payment information\n\n## The app\n\nWhen considering different framework options to build the app, I had already decided that React would be the foundation - I have the most experience with it, and it makes me the most productive. I wanted to be able to pre-generate (build static pages) any un-gated/public content. This gave me a few options:\n\n**Handcrafted React and Node server**\n\n❌ Too much work!\n\n**Gatsby**\n\n✅ Awesome framework\n\n✅ Static generation of pages at build time\n\n**Next.js**\n\n✅ Also an awesome framework\n\n✅ Static generation of pages at build time\n\n✅ Server-side rendered pages\n\n✅ API routes (serverless functions)\n\nI chose Next.js primarily because of its server-side rendering. Authentication would be a big part of this project, so I wanted to have an easily accessible server to handle all that secret stuff! While Gatsby spins up a server when building an application, that server does not exist when your users are using the app. Therefore, if I wanted to do secret stuff, I would have to manage another server! That sounds like too much work!\n\nAdditionally, with so many different technologies being used already, and one of the main outcomes of this project being a case study to share with people, I didn't want to throw in the mental overhead of GraphQL, which is somewhat unescapable with Gatsby - GraphQL is awesome. Still, we can cover it at another time!\n\n## Pregeneration (SSG)\n\nPregeneration is the process of fetching all the data for a page when building the application. This means we can request data from slow servers, do expensive computational tasks, etc., without every user needing to sit and watch a loading spinner. We do all these slow tasks once, build static HTML pages with the data, and then serve them as static assets - much cheaper to host and scale!\n\nNext.js makes pregeneration super easy! All you need to do is export a function called `getStaticProps` from a page-level component. It will pick this up when building the application, run the function and inject the result into the component.\n\nHere is a simple example of how this can be used.\n\nHere is an example from our SaaS application where we need to fetch all of the `prices` from Stripe, then iterate over each one and request its associated `product`.\n\nIn this example, we have two subscription plans, so we would be making three requests - one for the list of `prices` and then an additional request for each one's `product`. Imagine if we had one hundred products. What about a thousand! This could take a while and provide a pretty bad experience for our users 🙁\n\nRemember, happy customers, like to buy our things!\n\nIf we make these requests when we build our application, then they only happen once - when we deploy. No users are sitting around and waiting for us to deploy. When they visit the site, they get a super snappy pregenerated static page that doesn't need to rely on any third-party services for its data!\n\nPregeneration works amazingly well for public content - pages where you don't care who the user is. Great for marketing pages and things that don't need to change frequently - such as a pricing page.\n\nIf the page requires a user to be signed in or you are rendering different content for different users - such as a user dashboard - pregeneration is no longer a viable option. The problem is that when the server is building these static pages, there is no user!\n\n## Server-side Rendering (SSR)\n\nThat's where server-side rendering comes to save the day! This process runs when the user requests the page rather than when the server builds the application. Therefore, we know who the user is and can determine what they should and shouldn't access. Additionally, because this logic is running on the server, we can do secret things - such as fetch premium content from Prisma or check whether the user has a particular role - without worrying whether the user has tinkered with it.\n\nNEVER TRUST ANYTHING ON THE CLIENT! We can only trust our server-side code!\n\nAgain, Next.js makes it super simple to run some server-side code. We export a function called `getServerSideProps`, and it will automagically turn it into a serverless function that runs when the user requests the page. Again, the data returned is injected into the component and displayed to the user.\n\nHere is a simplified example of this logic.\n\nAnd here is a more realistic example from our application where we only want to display a lesson's video URL if the course is free, paid for, or has an active subscription.\n\nIn the above example, `videoUrl` is either null or a URL for the lesson's video, depending on whether the user is allowed to see this content or not. By only returning the bits of data that the user is allowed to see, we make sure that the secret stuff remains secret! If we had returned the entire lesson from `getServerSideProps` and simply checked in the component whether we should display it or not, then that data has still been sent across from the server to the client. The secret stuff is no longer secret! Take this example.\n\nIf we were to run this in the browser, it would seem equivalent to our previous example - the video would only display if the user were allowed to see it. However, if we open the console, the entire lesson object will be displayed - including the `videoUrl`. Once we have sent the page to the browser, it runs on the user's machine and is very easy to tinker with! Therefore, if we only return the bits of the data that the user is allowed to see from `getServerSideProps`, then we can keep the secret stuff secret.\n\nServer-side rendering with `getServerSideProps` allows us to encapsulate some logic that we need to run on the server without needing to maintain one.\n\n## Ready to pick up the pace?\n\nEnter your email and receive regular updates on our latest articles and courses\n\n![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)egghead.io\n\n## We're here to help.\n\nSign up for our **FREE** email course\n\n*   ⭐️ **Portfolio Building:** Learn how to build a badass developer portfolio so you can land that next job\n\n## Hosting\n\nNext up, we need a place to host this application to share it with the world! Again, there are many options that vary greatly in the amount of control vs. work done for you. Since hosting the application is not the thing my users care about, I wanted to use a service that did as much of the heavy lifting as possible.\n\nNetlify and Vercel were the main options I was considering. Netlify is awesome and has recently released a [zero-config plugin that enables all the SSR Next.js magic](https://www.netlify.com/blog/2021/03/16/try-the-new-essential-next.js-plugin-now-with-auto-install/). However, I chose to go with Vercel as they are usually slightly ahead of the curve with new Next.js features - probably because they are the creators and maintainers of that too!\n\nHosting the application was super simple with their CLI.\n\nThat's it! This will deploy a new version of your application with a `.vercel.app` domain. This is now hosted live on the Internet and can be seen by anyone in the world with an Internet connection. Very cool!\n\n## Automatic deploys\n\nAutomatic deploys with GitHub were also a breeze to configure with Vercel. Just push the code to GitHub, authorize Vercel and tell it which branch.\n\n![Git Repository and branch settings](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1619542684/egghead-next-ebombs/how-i-built-a-subscription-based-saas-product-in-six-weeks-using-next-js-prisma-auth0-and-stripe/Screen_Shot_2021-04-11_at_7.27.19_pm.png)\n\nIt will now automatically deploy a new version of our application anytime new commits are pushed to the `master` branch of the `courses` repo.\n\n## Preview deployments\n\nAnother awesome thing Vercel gives us for free is [Preview Deployments.](https://vercel.com/docs/platform/deployments#preview) It will listen for any changes that we push to branches other than `master` - such as opening a new Pull Request - and automatically deploy a new preview version of our application with its own unique URL. This is an awesome way to test new features or get feedback from the team before something goes live!\n\n## Secrets\n\nNext up, we need to tell Vercel all of our secrets! Secrets are the variables our application needs to do all the secret things when running in production. These often include API keys to send authenticated requests to a service, database connection strings, and special values we need for auth stuff.\n\nVercel does environment variables a little differently from other platforms. You first create the secret, then link its value to a particular environment variable. This gives you more control over sharing secrets across multiple projects and granting or restricting particular environments access - e.g., available in production and preview, but not development.\n\nAgain, super simple to configure. Head over to Settings > Environment Variables and create what you need.\n\nThere are three different types of Environment Variables in Vercel:\n\n1.  Plaintext - things that don't need to be secret - such as API\\_URL\n2.  Secret - sensitive values - such as API keys, DB connection strings etc\n3.  Provided by system - values populated by the system during deployment - such as Preview deploy URL\n\nI used `secret` for all of my environment variables. These are made available to your API routes (serverless functions) and any functions that run on the server - `getStaticProps`, `getServerSideProps`, etc. If you would like an environment variable to be available in your client-side code, it must be prepended with `NEXT_PUBLIC_`. In our SaaS application, we have a publishable key from stripe called `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY`.\n\nYou can run the `vercel dev` command locally to run a development server with access to secrets that you have granted the Development permission to, however, I find it easier to just create a `.env` file for secrets running in dev. This is automatically loaded by Next.js and applies the same rules - environment variables available to server-side stuff, variables prepended with `NEXT_PUBLIC_` available client-side. This also means you don't need to add a second copy of your secrets just for dev, or use the same secrets across all of your environments - which is a bad idea!\n\nVercel is an awesome host that makes deployments and hosting super simple. They take care of all the difficult stuff so you can focus on building the thing that makes you money! Additionally, they have a super generous free tier. If you hit the ceiling then you probably have enough users to justify paying Vercel!\n\n## Database\n\nThe next thing we need to consider is what kind of database we need. The first question to ask is whether you actually need a database at all? Could you get away with just using content in markdown files? In my case, I will need to store course content - this sounds great for markdown files - but I also need to know which users have bought particular courses and whether they have subscribed. This might be getting a bit hard to do with markdown. Since we already know we will need to build relationships between different bits of data, a relational database sounds like a good option.\n\nAgain, there are many options for database hosts with varying levels of management. I decided to go with [Supabase](https://supabase.io/) due to its simplicity of getting up and running. They are an open-source alternative to Google's Firebase and offer so much more than what we are using them for here. Creating a hosted Postgres DB was as simple as authenticating with GitHub and creating a new project. The connection string can be found at Settings > Database > Connection String.\n\nNow we need to decide how we want to talk to this database. I'm a huge fan of not manually writing SQL! I can fumble through a query or two but don't trust myself to do it in a performant way. I also have a background in Rails and really like how ORMs (object-relational mappers) abstract away the complexity of writing queries - it feels more like writing code.\n\nPrisma is a fantastic ORM that makes building queries that request data across multiple tables super simple and easy to read. Here is an example where we want to find a user based on their email.\n\nIf we wanted to also select the courses they had enrolled in (data from another table), we can just tell the Prisma query to include it.\n\n## Schema\n\nPrisma uses a `schema.prisma` file to define the structure of the database. Models represent different tables and declare the relationships between them. This is the final schema for our SaaS project.\n\n![many-to-many relationship diagram](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1619542683/egghead-next-ebombs/how-i-built-a-subscription-based-saas-product-in-six-weeks-using-next-js-prisma-auth0-and-stripe/Screen_Shot_2021-04-14_at_8.11.48_pm.png)\n\nA many-to-many relationship - such as a user's courses - can be easily queried like this.\n\nA one-to-many relationship - such as a lesson's course - can be queried like this.\n\nNo need for scary joins!\n\n## Migrations\n\nPrisma uses migrations to track changes to the database structure - such as adding a new table or column. This is inevitable as a project grows, so having a way to make these incremental changes without breaking things is a must! Prisma validates each change before applying the migration and altering the database structure. This means you get helpful errors and warnings if you try to do something that will modify or destroy existing data. For example, if I tried to remove the ID column on our user model, I get the following helpful error:\n\nTo create a migration you just modify the `prisma.schema` file to reflect what you want to change and then run this command to tell Prisma to update the database.\n\n## Seeds\n\nAnother thing I found particularly useful when making lots of changes to the DB was a `seed.js` file. This can be populated with test data, which makes playing around with database structure much more fun! If you break things too much, just reset the DB and populate with the seed file again! Here is an example course from our SaaS project.\n\n> Using `upsert` makes this file _idempotent_, meaning it can be run over and over again without filling up our database with unnecessary records.\n\n## Auth\n\nSince we will be locking down premium content to only display for people who have purchased a course or have a subscription, we're going to need to know who they are. For this, we will need them to create an account. Like all of these services, you can manage as much of the process and have as much control as you want. Since I have had fairly limited experience with building authentication solutions, I want something else to stay up to date with all the security best practices and tell me whether a user should have access or not.\n\nAuth0 does exactly this - and has done for many, many years. It is yet another awesome service that has a super generous free tier! They also integrate with a huge number of social providers - even things like Strava and Fitbit. This means that users don't need to create yet another account just to use our application. Since my product will be pretty heavily targeted at software developers, I set up the only authentication method to be with GitHub.\n\n## Auth0 and Next.js\n\nSo, how easy is it to integrate Next.js with Auth0? Install an NPM package and copy in a small amount of starter code! Super easy! Auth0 has built an amazing integration library called `nextjs-auth0`. I recommend checking out their [Getting Started](https://github.com/auth0/nextjs-auth0#getting-started) guide to get everything configured.\n\nThis library takes care of all the session management logic between the Next.js application and API routes. It also creates new API routes for login, logout, token exchange, and a \"me\" page to check who is currently logged in. Additionally, it includes a collection of helper functions that we can use in different parts of our application to determine who the user is and whether they should be able to view the content. Check out the [Examples page](https://github.com/auth0/nextjs-auth0/blob/main/EXAMPLES.md) to learn more about when to use each one.\n\n## Rules\n\n[Auth0 Rules](https://auth0.com/docs/rules) are serverless functions that allow us to run some code during the authentication process - after a user has signed in but before they are redirected to our application. This is the perfect time for us to create a new Prisma user and anything else we need to do to keep our local bits of data in sync with Auth0. This is how we make a request to our SaaS project and tell it to create a new Prisma user.\n\nSince we only want to do this the first time the user logs in, we can set some metadata on our Auth0 user to let us know this has already been done before.\n\nWe are also sending across a `secret` value to validate that this request is coming from Auth0.\n\nThis is our API route to receive the request from Auth0.\n\nAuth0 will halt the authentication flow until it receives the response from our API. This will eventually timeout and fail to authenticate the user if we forget to send a response. Best not to do anything too computationally expensive here, but perfect for creating a new DB record!\n\nThis is what the interactions between our application, Auth0 and Prisma look like when a user logs in for the first time.\n\n![app, auth0, and prima user log in interactions](https://res.cloudinary.com/dg3gyk0gu/video/upload/v1619542683/egghead-next-ebombs/how-i-built-a-subscription-based-saas-product-in-six-weeks-using-next-js-prisma-auth0-and-stripe/new-user.gif)\n\n## Payments\n\nNow for the exciting bit! Let's make some money! Stripe is an incredible service for dealing with payments. They take on all the scary credit card stuff so that our application doesn't even need to know about it. We just subscribe to particular Stripe events and update our database accordingly. Again, they have a huge security team constantly updating how they process payments and store data. I do not want that responsibility!\n\nMake sure to check out their [pricing page](https://stripe.com/en-au/pricing) to make sure you are happy with what they are charging. Given how easy they make it to set up credit card payments and complex subscriptions without needing to pay upfront, I am pleased with it!\n\n## Creating a Stripe customer\n\nSince we will be using Stripe pretty extensively - once-off payments, subscriptions, and a customer portal - we probably want to create a Stripe customer as early as possible and store their ID with our Prisma user. Since we already have a serverless function to keep Auth0 and Prisma in sync, let's also add the Stripe logic.\n\nThis is what the interaction looks like between our application, Auth0, Stripe and Prisma when a user signs in for the first time.\n\n![first sign in interaction](https://res.cloudinary.com/dg3gyk0gu/video/upload/v1619542684/egghead-next-ebombs/how-i-built-a-subscription-based-saas-product-in-six-weeks-using-next-js-prisma-auth0-and-stripe/new-user-with-stripe.gif)\n\n## One-off payments\n\nTo charge a customer for a course, we need to create a new API route to set up a Stripe session. Remember, we cannot trust any data coming from the client - especially the price! Think about the minimal amount of information you actually need from the user to know what they would like to purchase. This is usually just an ID of the product and the quantity they would like to purchase. Since it doesn't make sense for one user to purchase multiple copies of a course, we have hard-coded the quantity.\n\nSo there is a bit going on in this example.\n\n1.  We need to know who the user is so this needs to be an authenticated API route. We're using `withApiAuthRequired()` to help us with that.\n2.  We get the course ID from the dynamic part of the URL.\n3.  We get the user's email from the session. The session contains session information from Auth0, but is missing things like their Prisma and Stripe ID.\n4.  We make a request to Prisma for the full user.\n5.  We make a request to Prisma for the full course. We don't want to trust the client to send us data about the course, just which one they would like to purchase.\n6.  We create an array of line items that the user would like to purchase. We are just charging for a single item, but this still needs to be an array for Stripe to process it.\n7.  We create a Stripe Checkout session with some information about the transaction and pass this back to the client so they can be redirected to Stripe.\n8.  We are attaching some metadata to the session - user ID and course ID. This will be used when we configure webhooks.\n\n## Subscriptions\n\nSubscriptions are significantly more complex than one-off payments. We need to keep a track of when to charge the user again, as well as store their card details and deal with all the edge cases when they want to change to a different plan or cancel their subscription altogether. Thankfully, Stripe does all the hard work so we don't need to worry about any of this. We just create our different pricing options as products in the Stripe dashboard, and create an API route to initiate the session.\n\nIt is actually fewer lines of code than a one-off payment! Amazing!\n\nNow that we have payments implemented we probably need to tell our Prisma DB that someone has purchased a course or updated their subscription.\n\n## Webhooks\n\nWebhooks allow us to subscribe to particular events, and have Stripe let us know when they happen. Let's create a new API route to handle this.\n\nThis one is a little complicated as the `req` object we get from Vercel is structured differently to what Stripe is expecting. Let's break it down.\n\n1.  We export a `config` object to tell Vercel we want the raw request.\n2.  We compare the request we get from the user with Stripe's `constructEvent` function. This validates that the request was sent by Stripe and returns the webhook event object. If it cannot validate the request, it throws an exception, and we return an error to the client.\n3.  Next we determine which event has been received\n    *   `charge.succeeded` - user purchased a course.\n    *   `customer.subscription.created` - user subscribed.\n    *   `customer.subscription.updated` - user has changed their subscription. Since cancellation events are triggered separately, we can just trust the user is still subscribed.\n    *   `customer.subscription.deleted` - user cancelled their subscription. This is triggered when the subscription expires, rather than when they cancel.\n4.  Update our Prisma user.\n\nWebhooks can be tested locally using [Stripe's CLI tool](https://stripe.com/docs/stripe-cli). [Check out this article from the Stripe docs](https://stripe.com/docs/webhooks/test) to get it setup. Prod webhooks can be setup in Stripe's dashboard.\n\nThis is the interaction between our application, Stripe and Prisma when a user subscribes.\n\n![user subscription interaction](https://res.cloudinary.com/dg3gyk0gu/video/upload/v1619542684/egghead-next-ebombs/how-i-built-a-subscription-based-saas-product-in-six-weeks-using-next-js-prisma-auth0-and-stripe/subscribe.gif)\n\n## Customer portal\n\nThe last thing we need to set up is a customer portal. This will enable users to manage their own subscription and payment information. This can be configured via Stripe's dashboard `Settings > Billing > Customer Portal` and gives super granular control over what you would like customers to be able to change. A new portal session can be initiated from an API route like this.\n\nBy allowing users to manage this stuff directly with Stripe, we do not need to build these flows ourselves, and since we have subscribed to those webhooks, Stripe will just let us know if the user changes anything.\n\n## Final thoughts\n\nIt is amazing standing on the shoulders of giants! These services are incredible! We have created a complex SaaS project with authentication and multiple payment options with a very minimal amount of code. This stack was a pleasure to work in and was almost seamless.\n\nStripe is not only making this stuff a delight for developers to build hobby projects, t hey are also enabling people of all kinds to set up their own online businesses and make a living. Very cool!\n\n## Helpful resources\n\n*   [Build a SaaS project with Stripe](https://jonmeyers.io/blog/build-a-saas-platform-with-stripe) by me!\n*   [React 2025](https://react2025.com/) by Lee Robinson\n*   [Minimum viable SaaS](https://github.com/jaredpalmer/minimum-viable-saas) By Jared Palmer\n*   [nextjs-auth0 repo](https://github.com/auth0/nextjs-auth0)\n*   [Calling external API from Auth0 Rule](https://community.auth0.com/t/how-do-i-call-my-api-from-a-rule/41309)\n*   [Rules metadata in Auth0](https://auth0.com/docs/rules/metadata)\n*   [Calling a rule after social login](https://community.auth0.com/t/calling-hook-for-social-login/35604)\n*   [Stripe API docs](https://stripe.com/docs/api)\n*   [Stripe webhook verification with Next.js](https://codedaily.io/tutorials/Stripe-Webhook-Verification-with-NextJS)\n*   [Testing Stripe webhooks](https://stripe.com/docs/webhooks/test)\n\n## Ready to pick up the pace?\n\nEnter your email and receive regular updates on our latest articles and courses\n\n![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)egghead.io\n\n## We're here to help.\n\nSign up for our **FREE** email course\n\n*   ⭐️ **Portfolio Building:** Learn how to build a badass developer portfolio so you can land that next job",
    "title": "Building a SaaS Application with Next.js, Prisma, Auth0 and Stripe | egghead.io",
    "description": "expert led courses for front-end web developers and teams that want to level up through straightforward and concise lessons on the most useful tools available.",
    "languageCode": "en"
  },
  {
    "url": "https://auth0.com/docs/api/management/v2/",
    "markdown": "Auth0 Management API v2",
    "title": "Auth0 Management API v2",
    "description": null,
    "languageCode": "en"
  },
  {
    "url": "https://auth0.com/docs/api/authentication?javascript",
    "markdown": "# Authentication API Explorer\n\n## Introduction\n\nThe Authentication API enables you to manage all aspects of user identity when you use Auth0. It offers endpoints so your users can log in, sign up, log out, access APIs, and more.\n\nThe API supports various identity protocols, like [OpenID Connect](https://auth0.com/docs/protocols/oidc), [OAuth 2.0](https://auth0.com/docs/protocols/oauth2), [FAPI](https://auth0.com/docs/secure/highly-regulated-identity#advanced-security-with-openid-connect-fapi-) and [SAML](https://auth0.com/docs/protocols/saml).\n\n## Base URL\n\nThe Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base: `https://{yourDomain}`\n\n## Authentication methods\n\nYou have five options for authenticating with this API:\n\n*   OAuth2 Access Token\n*   Client ID and Client Assertion (confidential applications)\n*   Client ID and Client Secret (confidential applications)\n*   Client ID (public applications)\n*   mTLS Authentication (confidential applications)\n\n### OAuth2 Access Token\n\nSend a valid Access Token in the `Authorization` header, using the `Bearer` authentication scheme.\n\nAn example is the [Get User Info endpoint](#get-user-info). In this scenario, you get an Access Token when you authenticate a user, and then you can make a request to the [Get User Info endpoint](#get-user-info), using that token in the `Authorization` header, in order to retrieve the user's profile.\n\n### Client ID and Client Assertion\n\nGenerate a [client assertion](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) containing a signed JSON Web Token (JWT) to authenticate. In the body of the request, include your Client ID, a `client_assertion_type` parameter with the value `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`, and a `client_assertion` parameter with your signed assertion. Review [Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) for examples.\n\n### Client ID and Client Secret\n\nSend the Client ID and Client Secret. The method you can use to send this data is determined by the [Token Endpoint Authentication Method](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/view-application-type) configured for your application.\n\nIf you are using **Post**, you must send this data in the JSON body of your request.\n\nIf you are using **Basic**, you must send this data in the `Authorization` header, using the `Basic` authentication scheme. To generate your credential value, concatenate your Client ID and Client Secret, separated by a colon (`:`), and encode it in Base64.\n\nAn example is the [Revoke Refresh Token endpoint](#revoke-refresh-token). This option is available only for confidential applications (such as applications that are able to hold credentials in a secure way without exposing them to unauthorized parties).\n\n### Client ID\n\nSend the Client ID. For public applications (applications that cannot hold credentials securely, such as SPAs or mobile apps), we offer some endpoints that can be accessed using only the Client ID.\n\nAn example is the [Implicit Grant](#implicit-flow).\n\n### mTLS Authentication\n\nGenerate a certificate, either [self-signed](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#self-signed-certificates) or [certificate authority signed](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#certificate-authority-signed-certificates). Then, [set up the customer edge network](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge) that performs the mTLS handshake.\n\nOnce your edge network verifies the certificate, forward the request to the Auth0 edge network with the following headers:\n\n*   The Custom Domain API key as the `cname-api-key` header.\n*   The client certificate as the `client-certificate` header.\n*   The client certificate CA verification status as the `client-certificate-ca-verified` header. For more information, see [Forward the Request](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge#forward-the-request-).\n\nTo learn more, read [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls).\n\n## Parameters\n\nFor GET requests, any parameters not specified as a segment in the path can be passed as an HTTP query string parameter:\n\n`GET https://{yourDomain}/some-endpoint?param=value&param=value`\n\nFor POST requests, parameters not included in the URL should be encoded as JSON with a Content-Type of `application/json`:\n\n`curl --request POST --url 'https://{yourDomain}/some-endpoint' --header 'content-type: application/json' --data '{\"param\": \"value\", \"param\": \"value\"}'`\n\n## Code samples\n\nFor each endpoint, you will find sample snippets you can use, in three available formats:\n\n*   HTTP request\n*   Curl command\n*   JavaScript: depending on the endpoint each snippet may use the [Auth0.js library](https://auth0.com/docs/libraries/auth0js), Node.js code or simple JavaScript\n\nEach request should be sent with a Content-Type of `application/json`.\n\n## Testing\n\nYou can test the endpoints using the [Authentication API Debugger](https://auth0.com/docs/extensions/authentication-api-debugger).\n\n### Authentication API Debugger\n\nThe [Authentication API Debugger](https://auth0.com/docs/extensions/authentication-api-debugger) is an Auth0 extension you can use to test several endpoints of the Authentication API.\n\nClick on **Install Debugger** to go to the article that explains how (you only have to do this once).\n\n**If you have already installed the extension, skip to the Authentication API Debugger.**\n\nThe link varies according to your tenant's region: [US West](https://{yourtenant}.us.webtask.io/auth0-authentication-api-debugger), [Europe Central](https://{yourtenant}.eu.webtask.io/auth0-authentication-api-debugger) or [Australia](https://{yourtenant}.au.webtask.io/auth0-authentication-api-debugger).\n\n### Configure Connections\n\n1.  On the _Configuration_ tab, set the fields **Application** (select the application you want to use for the test) and **Connection** (the name of the social connection to use).\n    \n2.  Copy the **Callback URL** and set it as part of the **Allowed Callback URLs** of your [Application Settings](https://manage.auth0.com/#/applications).\n    \n3.  At the _OAuth2 / OIDC_ tab, select **OAuth2 / OIDC Login**.\n    \n\n### Endpoint options\n\nConfigure other endpoints with the following options:\n\n*   Passwordless: On the _OAuth2 / OIDC_ tab, set **Username** to the user's phone number if `connection=sms`, or the user's email if `connection=email`, and **Password** to the user's verification code. Click **Resource Owner Endpoint**.\n*   SAML SSO: On the _Other Flows_ tab, select **SAML**.\n*   WS-Federation: On the _Other Flows_ tab, select **WS-Federation**.\n*   Logout: On the _Other Flows_ tab, select **Logout**, or **Logout (Federated)** to log the user out of the identity provider as well.\n*   Legacy Login: On the _OAuth2 / OIDC_ tab, set the fields **ID Token**, **Refresh Token** and **Target Client ID**. Click **Delegation**.\n*   Legacy Delegation: On the _OAuth2 / OIDC_ tab, set **Username** and **Password**. Click **Resource Owner Endpoint**.\n*   Legacy Resource Owner: On the _OAuth2 / OIDC_ tab, set the **Username** and **Password**, then select **Resource Owner Endpoint**.\n\n### Authentications flows\n\nConfigure authentication flows with the following options:\n\n*   Authorization Code Flow: On the _OAuth2 / OIDC_ tab, set the field **Authorization Code** to the code you retrieved from [Authorization Code Grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), and the **Code Verifier** to the key. Click **OAuth2 Code Exchange**.\n*   Authorization Code Flow + PKCE: On the _OAuth2 / OIDC_ tab, set the field **Authorization Code** to the code you retrieved from [Authorization Code Grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce), and the **Code Verifier** to the key. Click **OAuth2 Code Exchange**.\n*   Client Credential Flow: On the _OAuth2 / OIDC_ tab, select **OAuth2 Client Credentials**.\n\n## Errors\n\nWhen an error occurs, you will receive an error object. Most of these error objects contain an error code and an error description so that your applications can more efficiently identify the problem.\n\nIf you get an `4xx` HTTP response code, then you can assume that there is a bad request from your end. In this case, check the [Standard Error Responses](#standard-error-responses) for more context.\n\n`5xx` errors suggest a problem on Auth0's end, so in this case, check [Auth0 Status Page](https://status.auth0.com/) and [@auth0status on Twitter](https://twitter.com/auth0status) to see how our systems are doing.\n\nIn any other case you can use [our support options](#support).\n\n## Rate limiting\n\nThe Authentication API is subject to rate limiting. The limits differ per endpoint.\n\nIf you exceed the provided rate limit for a given endpoint, you will receive the `429 Too Many Requests` response with the following message: `Too many requests. Check the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers.`\n\nFor details on rate limiting, refer to [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits).\n\nNote that for database connections Auth0 limits certain types of repeat login attempts depending on the user account and IP address. For details, refer to [Rate Limits on User/Password Authentication](https://auth0.com/docs/policies/rate-limit-policy/database-connections-rate-limits).\n\n## Support\n\nIf you have problems or need help with your case, you can always reach out to our [Support](https://support.auth0.com/).\n\nNote that if you have a free subscription plan, and you are not in your 22-day trial period, you will not be able to access or open tickets in the [Support Center](https://support.auth0.com/). In this case, you can seek support through the [Auth0 Community](https://community.auth0.com/). For more info on our support program, refer to [Support Options](https://auth0.com/docs/support).\n\n## Login\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE&\n  ADDITIONAL_PARAMETERS\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize app\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Trigger login with google\n  webAuth.authorize({\n    connection: 'google-oauth2'\n  });\n\n  // Trigger login with github\n  webAuth.authorize({\n    connection: 'github'\n  });\n\n  // Trigger login popup with twitter\n  webAuth.popup.authorize({\n    connection: 'twitter'\n  });\n</script>\n```\n\nYou can connect your Auth0 service to a social identity provider and allow your users to log in to your application via Facebook, Google, Apple, or other supported providers. To learn more about supported providers, visit [Marketplace](https://marketplace.auth0.com/features/social-connections).\n\nTo authenticate users with a social provider, make a `GET` call to the `/authorize` endpoint. It will return a `302` redirect to the social provider specified in the `connection` parameter.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nSpecifies the token type. Use `code` for server side flows and `token` for application side flows\n\n`client_id`  \nRequired\n\nThe `client_id` of your application\n\n`connection`\n\nThe name of a social identity provider configured to your application, for example `google-oauth2` or `facebook`. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`state`  \nRecommended\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`ADDITIONAL_PARAMETERS`\n\nAppend any additional parameter to the end of your request, and it will be sent to the provider. For example, `access_type=offline` (for Google Refresh Tokens) , `display=popup` (for Windows Live popup mode).\n\n*   If `response_type=token`, after the user authenticates on the provider, it will redirect to your application `callback URL` passing the Access Token and ID Token in the address `location.hash`. This is used for Single-Page Apps and also on Native Mobile SDKs.\n    \n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n    \n\n### Learn More\n\n*   [Supported Social Identity Providers](https://marketplace.auth0.com/features/social-connections)\n*   [Custom Social Connections](https://auth0.com/docs/connections/social/oauth2)\n*   [State Parameter](https://auth0.com/docs/secure/attack-protection/state-parameters)\n*   [Auth0.js /authorize Method Reference](https://auth0.com/docs/libraries/auth0js#webauth-authorize-)\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  scope=openid%20profile%20email&\n  state=STATE\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize app\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Calculate URL to redirect to\n  var url = webAuth.client.buildAuthorizeUrl({\n    clientID: '{yourClientId}', // string\n    responseType: 'token', // code or token\n    redirectUri: '{https://yourApp/callback}',\n    scope: 'openid profile email'\n    state: 'YOUR_STATE'\n  });\n\n  // Redirect to url\n  // ...\n</script>\n```\n\nUse the Auth0 user store or your own database to store and manage username and password credentials. If you have your own user database, you can use it as an identity provider in Auth0 to authenticate users. When you make a `GET` call to the `/authorize` endpoint for browser based (passive) authentication. It returns a `302` redirect to the [Auth0 Login Page](https://{yourdomain}/login) that will show the Login Widget where the user can log in with email and password.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nSpecifies the token type. Use `code` for server side flows and `token` for application side flows.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget using the first database connection.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`scope`  \nRecommended\n\nOIDC scopes and custom API scopes. For example: `openid read:timesheets`. Include `offline_access` to get a Refresh Token.\n\n`state`  \nRecommended\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n*   If `response_type=token`, after the user authenticates, it will redirect to your application `callback URL` passing the Access Token and ID Token in the address `location.hash`. This is used for Single-Page Apps and also on Native Mobile SDKs.\n*   The main difference between passive and active authentication is that the former happens in the browser through the [Auth0 Login Page](https://{yourdomain}/login) and the latter can be invoked from anywhere (a script, server to server, and so forth).\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [Database Identity Providers](https://auth0.com/docs/connections/database)\n*   [Rate Limits on User/Password Authentication](https://auth0.com/docs/policies/rate-limit-policy/database-connections-rate-limits)\n*   [Active Directory/LDAP Connector](https://auth0.com/docs/connector)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Auth0.js /authorize Method Reference](https://auth0.com/docs/libraries/auth0js#webauth-authorize-)\n\n## Enterprise (SAML and Others)\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Calculate URL to redirect to\n  var url = webAuth.client.buildAuthorizeUrl({\n    clientID: 'YOUR_CLIENT_ID', // string\n    responseType: 'token', // code or token\n    redirectUri: 'https://YOUR_APP/callback',\n    scope: 'openid profile email'\n    state: 'YOUR_STATE'\n  });\n\n  // Redirect to url\n  // ...\n</script>\n```\n\nYou can connect your Auth0 service to an enterprise identity provider and allow your users to log in to your application via Microsoft Azure Active Directory, Google Workspace, Okta Workforce, or other supported providers. To learn more about supported providers, visit [Auth0 Marketplace](https://marketplace.auth0.com/features/enterprise-connections).\n\nMake a `GET` call to the `/authorize` endpoint for passive authentication. It returns a `302` redirect to the SAML Provider (or Windows Azure AD and the rest, as specified in the `connection`) to enter their credentials.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nSpecifies the token type. Use `code` for server side flows, `token` for application side flows.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget using the first database connection.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`state`  \nRecommended\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n*   If no `connection` is specified, it will redirect to the [Login Page](https://{yourdomain}/login) and show the Login Widget.\n*   If `response_type=token`, after the user authenticates, it will redirect to your application `callback URL` passing the Access Token and ID Token in the address `location.hash`. This is used for Single-Page Apps and also on Native Mobile SDKs.\n*   Additional parameters can be sent that will be passed to the provider.\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n*   [Obtain a Client Id and Client Secret for Microsoft Azure Active Directory](https://auth0.com/docs/connections/enterprise/azure-active-directory)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Auth0.js /authorize Method Reference](https://auth0.com/docs/libraries/auth0js#webauth-authorize-)\n\n## Logout\n\n## Auth0 Logout\n\n### GET /v2/logout\n\n```\nGET https://{yourDomain}/v2/logout?\n  client_id={yourClientId}&\n  returnTo=LOGOUT_URL\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/v2/logout' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"returnTo\":\"LOGOUT_URL\"}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.logout({\n    returnTo: 'YOUR_LOGOUT_URL',\n    client_id: '{yourClientId}'\n  });\n</script>\n```\n\nUse this endpoint to logout a user. If you want to navigate the user to a specific URL after the logout, set that URL at the `returnTo` parameter. The URL should be included in any the appropriate `Allowed Logout URLs` list:\n\n*   If the `client_id` parameter is included, the `returnTo` URL must be listed in the `Allowed Logout URLs` set at the application level. To learn more, read [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications).\n*   If the `client_id` parameter is NOT included, the `returnTo` URL must be listed in the `Allowed Logout URLs` set at the tenant level. To learn more, read [Log Users Out of Auth0](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0).\n*   If the `client_id` parameter is included and the `returnTo` URL is NOT set, the server returns the user to the first Allowed Logout URLs set in the Dashboard. To learn more, read [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`returnTo`\n\nURL to redirect the user after the logout.\n\n`client_id`\n\nThe `client_id` of your application.\n\n`federated`\n\nAdd this query string parameter to the logout URL, to log the user out of their identity provider, as well: `https://{yourDomain}/v2/logout?federated`.\n\n*   Logging the user out of their identity provider is not common practice, so think about the user experience before you use the `federated` query string parameter.\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [Logout](https://auth0.com/docs/logout)\n\n## OIDC Logout\n\n### GET /oidc/logout\n\n```\nGET https://{yourDomain}/oidc/logout?\n  post_logout_redirect_uri=LOGOUT_URL&\n  id_token_hint=ID_TOKEN_HINT\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/oidc/logout' \\\n  --header 'content-type: application/json' \\\n  --data-raw '\n  { \n    \"client_id\":\"{yourClientId}\", \n    \"post_logout_redirect_uri\":\"LOGOUT_URL\", \n    \"id_token_hint\":\"ID_TOKEN_HINT\"\n  }'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.logout({\n    post_logout_redirect_uri: 'YOUR_LOGOUT_URL',\n    id_token_hint: 'YOUR_ID_TOKEN_HINT'\n  });\n</script>\n```\n\nUse this endpoint to logout a user. If you want to navigate the user to a specific URL after the logout, set that URL at the `post_logout_redirect_uri` parameter. The URL should be included in the appropriate `Allowed Logout URLs` list:\n\n*   If the `id_token_hint` parameter is included:\n    \n    *   When the `client_id` parameter is included, the server uses the URL from the `aud` claim in the `id_token_hint` to select which of the `Allowed Logout URLs` to use from the application specified by the `client_id`.\n    *   When the `client_id` parameter is NOT included, the server uses the URL from the `aud` claim in the `id_token_hint` to select which of the `Allowed Logout URLs` at the tenant level to use.\n*   If the `id_token_hint` parameter is not included:\n    \n    *   If the `client_id` parameter is included, the `post_logout_redirect_uri` URL must be listed in the `Allowed Logout URLs` set at the application level.\n    *   If the `client_id` parameter is NOT included, the `post_logout_redirect_uri` URL must be listed in the `Allowed Logout URLs` set at the tenant level.\n    *   If the `client_id` parameter is included and the `post_logout_redirect_uri` URL is NOT set, the server returns the user to the first `Allowed Logout URLs` set in Auth0 Dashboard.\n    \n    To learn more, read [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0).\n    \n\n### Request Parameters\n\nParameter\n\nDescription\n\n`id_token_hint` (Recommended)\n\nPreviously issued ID Token for the user. This is used to indicate which user to log out.\n\n`logout_hint` (Optional)\n\nOptional `sid` (session ID) value to indicate which user to log out. Should be provided when `id_token_hint` is not available.\n\n`post_logout_redirect_uri` (Optional)\n\nURL to redirect the user after the logout.\n\n`client_id` (Optional)\n\nThe `client_id` of your application.\n\n`federated` (Optional)\n\nAdd this query string parameter to log the user out of their identity provider: `https://YOUR_DOMAIN/oidc/logout?federated`.\n\n`state` (Optional)\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the`post_logout_redirect_uri`.\n\n`ui_locales` (Optional)\n\nSpace-delimited list of locales used to constrain the language list for the request. The first locale on the list must match the enabled locale in your tenant\n\n*   Logging the user out of their social identity provider is not common practice, so think about the user experience before you use the `federated` query string parameter with social identity providers.\n*   If providing both `id_token_hint` and `logout_hint`, the `logout_hint` value must match the `sid` claim from the id\\_token\\_hint.\n*   If providing both `id_token_hint` and `client_id`, the `client_id` value must match the `aud` claim from the `id_token_hint`.\n*   If `id_token_hint` is not provided, then the user will be prompted for consent unless a `logout_hint` that matches the user's session ID is provided.\n*   The `POST` HTTP method is also supported for this request. When using `POST`, the request parameters should be provided in the request body as form parameters instead of the query string. The federated parameter requires a value of `true` or `false`.\n*   This conforms to the [OIDC RP-initiated Logout Specification](https://openid.net/specs/openid-connect-rpinitiated-1_0.html).\n\n### Learn More\n\n*   [Logout](https://auth0.com/docs/logout)\n*   [Use the OIDC Endpoint to Log Users Out of Auth0](https://auth0.com/docs/logout/log-users-out-of-auth0)\n*   [OIDC RP-initiated Logout Specification](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)\n\n## SAML Logout\n\n```\nPOST https://{yourDomain}/samlp/CLIENT_ID/logout\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/samlp/CLIENT_ID/logout' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data '{SAML_LOGOUT_REQUEST}'\n```\n\nUse this endpoint to log out a user from an Auth0 tenant configured as a SAML identity provider (IdP).\n\nLogout behavior is determined by the configuration of the SAML2 Web App addon for the application on the Auth0 tenant acting as the SAML IdP. To learn more, read [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps#configure-slo-when-auth0-is-the-saml-idp).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`CLIENT_ID`\n\nClient ID of your application configured with the [SAML2 Web App addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon).\n\n`SAML_LOGOUT_REQUEST`\n\nSAML `<LogoutRequest>` message.\n\n*   The POST body must contain a valid SAML `<LogoutRequest>` message. To learn more, read [Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0 on Oasis](https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf).\n\n### Learn More\n\n*   [Logout](https://auth0.com/docs/logout)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n\n## Passwordless\n\nPasswordless connections do not require the user to remember a password. Instead, another mechanism is used to prove identity, such as a one-time code sent through email or SMS, every time the user logs in.\n\n## Get Code or Link\n\n```\nPOST https://{yourDomain}/passwordless/start\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\", // for web applications\n  \"connection\": \"email|sms\",\n  \"email\": \"USER_EMAIL\", //set for connection=email\n  \"phone_number\": \"USER_PHONE_NUMBER\", //set for connection=sms\n  \"send\": \"link|code\", //if left null defaults to link\n  \"authParams\": { // any authentication parameters that you would like to add\n    \"scope\": \"openid\",\n    \"state\": \"YOUR_STATE\"\n  }\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"connection\":\"email|sms\", \"email\":\"USER_EMAIL\", \"phone_number\":\"USER_PHONE_NUMBER\", \"send\":\"link|code\", \"authParams\":{\"scope\": \"openid\",\"state\": \"YOUR_STATE\"}}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Send a verification code using email\n  webAuth.passwordlessStart({\n      connection: 'email',\n      send: 'code',\n      email: 'USER_EMAIL'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Send a link using email\n  webAuth.passwordlessStart({\n      connection: 'email',\n      send: 'link',\n      email: 'USER_EMAIL'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Send a verification code using SMS\n  webAuth.passwordlessStart({\n      connection: 'sms',\n      send: 'code',\n      phoneNumber: 'USER_PHONE_NUMBER'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n</script>\n```\n\n### POST /passwordless/start\n\nYou have three options for [passwordless authentication](https://auth0.com/docs/connections/passwordless):\n\n*   Send a verification code using email.\n*   Send a link using email.\n*   Send a verification code using SMS.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`client_assertion`  \n\nA JWT containing containing a signed assertion with your applications credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nUse the value `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nThe `client_secret` of your application. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`. Specifically required for Regular Web Applications **only**.\n\n`connection`  \nRequired\n\nHow to send the code/link to the user. Use `email` to send the code/link using email, or `sms` to use SMS.\n\n`email`\n\nSet this to the user's email address, when `connection=email`.\n\n`phone_number`\n\nSet this to the user's phone number, when `connection=sms`.\n\n`send`\n\nUse `link` to send a link or `code` to send a verification code. If null, a link will be sent.\n\n`authParams`\n\nUse this to append or override the link parameters (like `scope`, `redirect_uri`, `protocol`, `response_type`), when you send a link using email.\n\n*   If you sent a verification code, using either email or SMS, after you get the code, you have to authenticate the user using the [/passwordless/verify endpoint](#authenticate-user), using `email` or `phone_number` as the `username`, and the verification code as the `password`.\n*   This endpoint is designed to be called from the client-side, and is subject to [rate limits](https://auth0.com/docs/policies/rate-limit-policy/authentication-api-endpoint-rate-limits).\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /passwordless/start](#post-passwordless-start).\n\n### Learn More\n\n*   [Passwordless Authentication](https://auth0.com/docs/connections/passwordless)\n*   [Passwordless Best Practices](https://auth0.com/docs/connections/passwordless/best-practices)\n\n## Authenticate User\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/json\n{\n  \"grant_type\" : \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\", // for web applications\n  \"otp\": \"CODE\",\n  \"realm\": \"email|sms\" //email or sms\n  \"username\":\"USER_EMAIL|USER_PHONE_NUMBER\", // depends on which realm you chose\n  \"audience\" : \"API_IDENTIFIER\", // in case you need an access token for a specific API\n  \"scope\": \"SCOPE\",\n  \"redirect_uri\": \"REDIRECT_URI\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"grant_type\":\"http://auth0.com/oauth/grant-type/passwordless/otp\", \"client_id\":\"{yourClientId}\", \"client_secret\":\"CLIENT_SECRET\", \"otp\":\"CODE\", \"realm\":\"email|sms\", \"username\":\"USER_EMAIL|USER_PHONE_NUMBER\", \"audience\":\"API_IDENTIFIER\", \"scope\":\"SCOPE\", \"redirect_uri\": \"REDIRECT_URI\"}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Verify code sent via email\n  webAuth.passwordlessLogin({\n      connection: 'email',\n      email: 'USER_EMAIL',\n      verificationCode: 'VERIFICATION_CODE_SENT'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Verify code sent within link using email\n  webAuth.passwordlessLogin({\n      connection: 'email',\n      email: 'USER_EMAIL',\n      verificationCode: 'VERIFICATION_CODE_SENT_WITHIN_LINK'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Verify code sent via SMS\n  webAuth.passwordlessLogin({\n      connection: 'sms',\n      phoneNumber: 'USER_PHONE_NUMBER',\n      verificationCode: 'VERIFICATION_CODE_SENT'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n</script>\n```\n\n### POST /oauth/token\n\nOnce you have a verification code, use this endpoint to login the user with their phone number/email and verification code.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nIt should be `http://auth0.com/oauth/grant-type/passwordless/otp`.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nThe `client_secret` of your application. Required\\*\\* when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`. Specifically required for Regular Web Applications **only**.\n\n`username`  \nRequired\n\nThe user's phone number if `realm=sms`, or the user's email if `realm=email`.\n\n`realm`  \nRequired\n\nUse `sms` or `email` (should be the same as [POST /passwordless/start](#get-code-or-link))\n\n`otp`  \nRequired\n\nThe user's verification code.\n\n`audience`\n\nAPI Identifier of the API for which you want to get an Access Token.\n\n`scope`\n\nUse `openid` to get an ID Token, or `openid profile email` to also include user profile information in the ID Token.\n\n`redirect_uri`  \nRequired\n\nA callback URL that has been registered with your application's **Allowed Callback URLs**.\n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Standard Error Responses](#standard-error-responses).\n\n### Learn More\n\n*   [Passwordless Authentication](https://auth0.com/docs/connections/passwordless)\n\n### POST /passwordless/verify\n\nOnce you have a verification code, use this endpoint to login the user with their phone number/email and verification code. This is active authentication, so the user must enter the code in your app.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`connection`  \nRequired\n\nUse `sms` or `email` (should be the same as [POST /passwordless/start](#get-code-or-link))\n\n`grant_type`  \nRequired\n\nUse `password`\n\n`username`  \nRequired\n\nThe user's phone number if `connection=sms`, or the user's email if `connection=email`.\n\n`password`  \nRequired\n\nThe user's verification code.\n\n`scope`\n\nUse `openid` to get an ID Token, or `openid profile email` to include also user profile information in the ID Token.\n\n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /passwordless/verify](#post-passwordless-verify).\n\n### Learn More\n\n*   [Passwordless Best Practices](https://auth0.com/docs/connections/passwordless/best-practices)\n\n## Signup\n\n```\nPOST https://{yourDomain}/dbconnections/signup\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"email\": \"EMAIL\",\n  \"password\": \"PASSWORD\",\n  \"connection\": \"CONNECTION\",\n  \"username\": \"johndoe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"name\": \"John Doe\",\n  \"nickname\": \"johnny\",\n  \"picture\": \"http://example.org/jdoe.png\"\n  \"user_metadata\": { plan: 'silver', team_id: 'a111' }\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/dbconnections/signup' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"email\":\"test.account@signup.com\", \"password\":\"PASSWORD\", \"connection\":\"CONNECTION\", \"username\": \"johndoe\", \"given_name\": \"John\", \"family_name\": \"Doe\", \"name\": \"John Doe\", \"nickname\": \"johnny\", \"picture\": \"http://example.org/jdoe.png\", \"user_metadata\":{ \"plan\": \"silver\", \"team_id\": \"a111\" }}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize client\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.signup({ \n    connection: 'CONNECTION', \n    email: 'EMAIL', \n    password: 'PASSWORD',\n    username: \"johndoe\",\n    given_name: \"John\",\n    family_name: \"Doe\",\n    name: \"John Doe\",\n    nickname: \"johnny\",\n    picture: \"http://example.org/jdoe.png\",\n    user_metadata: { plan: 'silver', team_id: 'a111' }\n  }, function (err) { \n    if (err) return alert('Something went wrong: ' + err.message); \n      return alert('success signup without login!') \n  });\n</script>\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"_id\": \"58457fe6b27...\",\n  \"email_verified\": false,\n  \"email\": \"test.account@signup.com\",\n  \"username\": \"johndoe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"name\": \"John Doe\",\n  \"nickname\": \"johnny\",\n  \"picture\": \"http://example.org/jdoe.png\"\n}\n```\n\n### POST /dbconnections/signup\n\nGiven a user's credentials and a `connection`, this endpoint creates a new user.\n\nThis endpoint only works for database connections.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your client.\n\n`email`  \nRequired\n\nThe user's email address.\n\n`password`  \nRequired\n\nThe user's desired password.\n\n`connection`  \nRequired\n\nThe name of the database configured to your client.\n\n`username`\n\nThe user's username. Only valid if the connection requires a username.\n\n`given_name`\n\nThe user's given name(s).\n\n`family_name`\n\nThe user's family name(s).\n\n`name`\n\nThe user's full name.\n\n`nickname`\n\nThe user's nickname.\n\n`picture`\n\nA URI pointing to the user's picture.\n\n`user_metadata`\n\nThe [user metadata](https://auth0.com/docs/users/concepts/overview-user-metadata) to be associated with the user. If set, the field must be an object containing no more than ten properties. Property names can have a maximum of 100 characters, and property values must be strings of no more than 500 characters.\n\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [Password Strength in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-strength)\n*   [Password Options in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-options)\n*   [Adding Username for Database Connections](https://auth0.com/docs/connections/database/require-username)\n*   [Metadata Overview](https://auth0.com/docs/users/concepts/overview-user-metadata)\n\n## Change Password\n\n```\nPOST https://{yourDomain}/dbconnections/change_password\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"email\": \"EMAIL\",\n  \"connection\": \"CONNECTION\",\n  \"organization\": \"ORGANIZATION_ID\"\n}\n```\n\n```\ncurl --request POST \\\n  --url https://{yourDomain}/dbconnections/change_password \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\",\"email\": \"EMAIL\", \"connection\": \"CONNECTION\", \"organization\": \"ORGANIZATION_ID\"}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.changePassword({\n    connection: 'CONNECTION',\n    email:   'EMAIL',\n    organization: 'ORGANIZATION_ID'\n  }, function (err, resp) {\n    if(err){\n      console.log(err.message);\n    }else{\n      console.log(resp);\n    }\n  });\n</script>\n```\n\n### POST /dbconnections/change\\_password\n\n> RESPONSE SAMPLE:\n\n```\n\"We've just sent you an email to reset your password.\"\n```\n\nSend a change password email to the user's provided email address and `connection`.\n\nOptionally, you may provide an Organization ID to support Organization-specific variables in [customized email templates](https://auth0.com/docs/customize/email/email-templates#common-variables) and to include the `organization_id` and `organization_name` parameters in the **Redirect To** URL.\n\nNote: This endpoint only works for database connections.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`\n\nThe `client_id` of your client. We strongly recommend including a Client ID so that the email template knows from which client the request was triggered.\n\n`email`  \nRequired\n\nThe user's email address.\n\n`connection`  \nRequired\n\nThe name of the database connection configured to your client.\n\n`organization`\n\nThe `organization_id` of the Organization associated with the user.\n\n*   When the user clicks on the password change link they will be redirected to a page asking them for a new password.\n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n\n### Learn More\n\n*   [Changing a User's Password](https://auth0.com/docs/connections/database/password-change)\n*   [Password Strength in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-strength)\n*   [Password Options in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-options)\n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations)\n\n## User Profile\n\n## Get User Info\n\n```\nGET https://{yourDomain}/userinfo\nAuthorization: 'Bearer {ACCESS_TOKEN}'\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/userinfo' \\\n  --header 'Authorization: Bearer {ACCESS_TOKEN}' \\\n  --header 'Content-Type: application/json'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize the Auth0 application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Parse the URL and extract the Access Token\n  webAuth.parseHash(window.location.hash, function(err, authResult) {\n    if (err) {\n      return console.log(err);\n    }\n    webAuth.client.userInfo(authResult.accessToken, function(err, user) {\n        // This method will make a request to the /userinfo endpoint\n        // and return the user object, which contains the user's information,\n        // similar to the response below.\n    });\n  });\n</script>\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"sub\": \"248289761001\",\n  \"name\": \"Jane Josephine Doe\",\n  \"given_name\": \"Jane\",\n  \"family_name\": \"Doe\",\n  \"middle_name\": \"Josephine\",\n  \"nickname\": \"JJ\",\n  \"preferred_username\": \"j.doe\",\n  \"profile\": \"http://exampleco.com/janedoe\",\n  \"picture\": \"http://exampleco.com/janedoe/me.jpg\",\n  \"website\": \"http://exampleco.com\",\n  \"email\": \"janedoe@exampleco.com\",\n  \"email_verified\": true,\n  \"gender\": \"female\",\n  \"birthdate\": \"1972-03-31\",\n  \"zoneinfo\": \"America/Los_Angeles\",\n  \"locale\": \"en-US\",\n  \"phone_number\": \"+1 (111) 222-3434\",\n  \"phone_number_verified\": false,\n  \"address\": {\n    \"country\": \"us\"\n  },\n  \"updated_at\": \"1556845729\"\n}\n```\n\n### GET /userinfo\n\nGiven the Auth0 Access Token obtained during login, this endpoint returns a user's profile.\n\nThis endpoint will work only if `openid` was granted as a scope for the Access Token. The user profile information included in the response depends on the scopes requested. For example, a scope of just `openid` may return less information than a a scope of `openid profile email`.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`access_token`  \nRequired\n\nThe Auth0 Access Token obtained during login.\n\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n*   The auth0.js `parseHash` method, requires that your tokens are signed with `RS256`, rather than `HS256`.\n*   To return `user_metadata` or other custom information from this endpoint, add a custom claim to the ID token with an [Action](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims#create-custom-claims). For more information refer to [User profile claims and scope](https://auth0.com/docs/api-auth/tutorials/adoption/scope-custom-claims).\n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n*   The `Email` claim returns a snapshot of the email at the time of login\n*   Standard claims (other than `email`) return the latest value (unless the value comes from an external IdP)\n*   Custom claims always returns the latest value of the claim\n*   To access the most up-to-date values for the `email` or custom claims, you must get new tokens. You can log in using silent authentication (where the `prompt` parameter for your call to the [`authorize` endpoint](https://auth0.com/docs/api/authentication#authorization-code-grant) equals `none`)\n*   To access the most up-to-date values for standard claims that were changed using an external IdP (for example, the user changed their email address in Facebook)., you must get new tokens. Log in again using the external IdP, but _not_ with silent authentication.\n\n### Learn More\n\n*   [Auth0.js v8 Reference: Extract the authResult and get user info](https://auth0.com/docs/libraries/auth0js#extract-the-authresult-and-get-user-info)\n    \n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits)\n    \n\n## Multi-factor Authentication\n\nThe Multi-factor Authentication (MFA) API endpoints allow you to enforce MFA when users interact with [the Token endpoints](#get-token), as well as enroll and manage user authenticators.\n\nFirst, request a challenge based on the challenge types supported by the application and user. If you know that one-time password (OTP) is supported, you can skip the challenge request.\n\nNext, verify the multi-factor authentication using the `/oauth/token` endpoint and the specified challenge type: a one-time password (OTP), a recovery code, or an out-of-band (OOB) challenge.\n\nTo learn more, read:\n\n*   [Multi-factor Authentication and Resource Owner Password](https://auth0.com/docs/mfa/guides/mfa-api/multifactor-resource-owner-password)\n*   [Multi-factor Authentication API](https://auth0.com/docs/mfa/concepts/mfa-api)\n*   [Multi-factor Authentication in Auth0](https://auth0.com/docs/mfa)\n\n## Challenge Request\n\n```\nPOST https://{yourDomain}/mfa/challenge\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"mfa_token\": \"MFA_TOKEN\",\n  \"challenge_type\": \"oob|otp\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --header 'content-type: application/json' \\\n  --data '{\"mfa_token\":\"MFA_TOKEN\", \"challenge_type\":\"oob otp\", \"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\"}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  headers: { 'content-type': 'application/json' },\n  body:\n   { mfa_token: 'MFA_TOKEN',\n     challenge_type: 'oob otp',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"challenge_type\":\"otp\",\n}\n```\n\n> RESPONSE SAMPLE FOR OOB WITHOUT BINDING METHOD:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"challenge_type\":\"oob\",\n  \"oob_code\": \"abcde...dasg\"\n}\n```\n\n> RESPONSE SAMPLE FOR OOB WITH BINDING METHOD:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"challenge_type\":\"oob\",\n  \"binding_method\":\"prompt\",\n  \"oob_code\": \"abcde...dasg\"\n}\n```\n\nRequest a challenge for multi-factor authentication (MFA) based on the challenge types supported by the application and user.\n\nThe `challenge_type` is how the user will get the challenge and prove possession. Supported challenge types include:\n\n*   `otp`: for one-time password (OTP)\n*   `oob`: for SMS/Voice messages or out-of-band (OOB)\n\nIf OTP is supported by the user and you don't want to request a different factor, you can skip the challenge request and [verify the multi-factor authentication with a one-time password](#verify-with-one-time-password-otp-).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`mfa_token`  \nRequired\n\nThe token received from `mfa_required` error.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`challenge_type`\n\nA whitespace-separated list of the challenges types accepted by your application. Accepted challenge types are `oob` or `otp`. Excluding this parameter means that your client application accepts all supported challenge types.\n\n`authenticator_id`\n\nThe ID of the authenticator to challenge. You can get the ID by querying the list of available authenticators for the user as explained on [List authenticators](#list-authenticators) below.\n\n*   This endpoint does not support enrollment; the user must be enrolled with the preferred method before requesting a challenge.\n*   Auth0 chooses the challenge type based on the application's supported types and types the user is enrolled with.\n*   An `unsupported_challenge_type` error is returned if your application does not support any of the challenge types the user has enrolled with.\n*   An `unsupported_challenge_type` error is returned if the user is not enrolled.\n*   If the user is not enrolled, you will get a `association_required` error, indicating the user needs to enroll to use MFA. Read [Add an authenticator](#add-an-authenticator) below on how to proceed.\n\n### Learn More\n\n*   [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/mfa/guides/mfa-api/authenticate)\n*   [Manage Authenticator Factors using the MFA API](https://auth0.com/docs/mfa/guides/mfa-api/manage)\n\n## Verify with One-Time Password (OTP)\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&otp=OTP_CODE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'mfa_token=MFA_TOKEN&otp=OTP_CODE&grant_type=http://auth0.com/oauth/grant-type/mfa-otp&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { mfa_token: 'MFA_TOKEN',\n     otp: 'OTP_CODE',\n     grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nVerifies multi-factor authentication (MFA) using a one-time password (OTP).\n\nTo verify MFA with an OTP, prompt the user to get the OTP code, then make a request to the `/oauth/token` endpoint. The request must have the OTP code, the `mfa_token` you received (from the `mfa_required` error), and the `grant_type` set to `http://auth0.com/oauth/grant-type/mfa-otp`.\n\nThe response is the same as responses for `password` or `http://auth0.com/oauth/grant-type/password-realm` grant types.\n\n### Request parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For OTP MFA use `http://auth0.com/oauth/grant-type/mfa-otp`.\n\n`client_id`\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`mfa_token`  \nRequired\n\nThe `mfa_token` you received from `mfa_required` error.\n\n`otp`  \nRequired\n\nOTP Code provided by the user.\n\n### Learn More\n\n*   [Associate OTP Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/otp)\n\n## Verify with Out-of-Band (OOB)\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&oob_code=OOB_CODE&binding_code=BINDING_CODE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http://auth0.com/oauth/grant-type/mfa-oob&oob_code=OOB_CODE&binding_code=BINDING_CODE'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { mfa_token: 'MFA_TOKEN',\n     oob_code: \"OOB_CODE\",\n     binding_code: \"BINDING_CODE\"\n     grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR PENDING CHALLENGE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"error\":\"authorization_pending\",\n  \"error_description\":\"Authorization pending: please repeat the request in a few seconds.\"\n}\n```\n\n> RESPONSE SAMPLE FOR VERIFIED CHALLENGE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n> RESPONSE SAMPLE FOR REJECTED CHALLENGE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"error\":\"invalid_grant\",\n  \"error_description\":\"MFA Authorization rejected.\"\n}\n```\n\n### POST /oauth/token\n\nVerifies multi-factor authentication (MFA) using an out-of-band (OOB) challenge (either Push notification, SMS, or Voice).\n\nTo verify MFA using an OOB challenge, your application must make a request to `/oauth/token` with `grant_type=http://auth0.com/oauth/grant-type/mfa-oob`. Include the `oob_code` you received from the challenge response, as well as the `mfa_token` you received as part of `mfa_required` error.\n\nThe response to this request depends on the status of the underlying challenge verification:\n\n*   If the challenge has been accepted and verified, it will be the same as `password` or `http://auth0.com/oauth/grant-type/password-realm` grant types.\n*   If the challenge has been rejected, you will get an `invalid_grant` error, meaning that the challenge was rejected by the user. At this point you should stop polling, as this response is final.\n*   If the challenge verification is still pending (meaning it has not been accepted nor rejected), you will get an `authorization_pending` error, meaning that you must retry the same request a few seconds later. If you request too frequently, you will get a `slow_down` error.\n\nWhen the challenge response includes a `binding_method: prompt`, your app needs to prompt the user for the `binding_code` and send it as part of the request. The `binding_code` is usually a 6-digit number (similar to an OTP) included as part of the challenge. No `binding_code` is necessary if the challenge response did not include a `binding_method`. In this scenario, the response will be immediate; you will receive an `invalid_grant` or an `access_token` as response.\n\n### Request parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For OTP MFA, use `http://auth0.com/oauth/grant-type/mfa-oob`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`mfa_token`  \nRequired\n\nThe `mfa_token` you received from `mfa_required` error.\n\n`oob_code`  \nRequired\n\nThe oob code received from the challenge request.\n\n`binding_code`\n\nA code used to bind the side channel (used to deliver the challenge) with the main channel you are using to authenticate. This is usually an OTP-like code delivered as part of the challenge message.\n\n### Learn More\n\n*   [Associate Out-of-Band Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/oob)\n\n## Verify with Recovery Code\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&recovery_code=RECOVERY_CODE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code&recovery_code=RECOVERY_CODE'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { mfa_token: 'MFA_TOKEN',\n     recovery_code: 'RECOVERY_CODE',\n     grant_type: 'http://auth0.com/oauth/grant-type/mfa-recovery-code',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400,\n  \"recovery_code\": \"abcdefg\"\n}\n```\n\n### POST /oauth/token\n\nVerifies multi-factor authentication (MFA) using a recovery code.\n\nSome multi-factor authentication (MFA) providers (such as Guardian) support using a recovery code to login. Use this method to authenticate when the user's enrolled device is unavailable, or the user cannot receive the challenge or accept it due to connectivity issues.\n\nTo verify MFA using a recovery code your app must prompt the user for the recovery code, and then make a request to `oauth/token` with `grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code`. Include the collected recovery code and the `mfa_token` from the `mfa_required` error. If the recovery code is accepted, the response will be the same as for `password` or `http://auth0.com/oauth/grant-type/password-realm` grant types. It might also include a `recovery_code` field, which the application must display to the end-user to be stored securely for future use.\n\n### Request parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For recovery code use `http://auth0.com/oauth/grant-type/mfa-recovery-code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`mfa_token`  \nRequired\n\nThe `mfa_token` you received from `mfa_required` error.\n\n`recovery_code`  \nRequired\n\nRecovery code provided by the end-user.\n\n## Add an Authenticator\n\n```\nPOST https://{yourDomain}/mfa/associate\nContent-Type: application/json\nAuthorization: Bearer ACCESS_TOKEN or MFA_TOKEN\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"authenticator_types\": [\"oob\"],\n  \"oob_channels\": \"sms\",\n  \"phone_number\": \"+1 555 123456\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer ACCESS_TOKEN or MFA_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\", \"authenticator_types\":[\"oob\"], \"oob_channels\":\"sms\", \"phone_number\": \"+1 555 123456\"}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {\n    'authorization': 'Bearer TOKEN',\n    'content-type': 'application/json'\n  },\n  body:\n   { client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     authenticator_types: [\"oob\"],\n     oob_channels: \"sms\",\n     phone_number: \"+1 555 123456\" },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OOB (SMS channel):\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"oob_code\": \"Fe26.2**da6....\",\n  \"binding_method\":\"prompt\",\n  \"authenticator_type\":\"oob\",\n  \"oob_channels\":\"sms\",\n  \"recovery_codes\":[\"ABCDEFGDRFK75ABYR7PH8TJA\"],\n}\n```\n\n> RESPONSE SAMPLE FOR OOB (Auth0 channel):\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"oob_code\": \"Fe26.2**da6....\",\n  \"barcode_uri\":\"otpauth://...\",\n  \"authenticator_type\":\"oob\",\n  \"oob_channels\":\"auth0\",\n  \"recovery_codes\":[\"ABCDEFGDRFK75ABYR7PH8TJA\"],\n}\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"secret\": \"ABCDEFGMK5CE6WTZKRTTQRKUJVFXOVRF\",\n  \"barcode_uri\":\"otpauth://...\",\n  \"authenticator_type\":\"otp\",\n  \"recovery_codes\":[\"ABCDEFGDRFK75ABYR7PH8TJA\"],\n}\n```\n\n### POST /mfa/associate\n\nAssociates or adds a new authenticator for multi-factor authentication (MFA).\n\nIf the user has active authenticators, an Access Token with the `enroll` scope and the `audience` set to `https://{yourDomain}/mfa/` is required to use this endpoint.\n\nIf the user has no active authenticators, you can use the `mfa_token` from the `mfa_required` error in place of an Access Token for this request.\n\nAfter an authenticator is added, it must be verified. To verify the authenticator, use the response values from the `/mfa/associate` request in place of the values returned from the `/mfa/challenge` endpoint and continue with the verification flow.\n\nA `recovery_codes` field is included in the response the first time an authenticator is added. You can use `recovery_codes` to pass multi-factor authentication as shown on [Verify with recovery code](#verify-with-recovery-code) above.\n\nTo access this endpoint, you must set an Access Token at the Authorization header, with the following claims:\n\n*   `scope`: `enroll`\n*   `audience`: `https://{yourDomain}/mfa/`\n\n### Request parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field in your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`authenticator_types`  \nRequired\n\nThe type of authenticators supported by the client. Value is an array with values `\"otp\"` or `\"oob\"`.\n\n`oob_channels`\n\nThe type of OOB channels supported by the client. An array with values `\"auth0\"`, `\"sms\"`, `\"voice\"`. Required if `authenticator_types` include `oob`.\n\n`phone_number`\n\nThe phone number to use for SMS or Voice. Required if `oob_channels` includes `sms` or `voice`.\n\n### Learn More\n\n*   [Multi-factor Authentication API](https://auth0.com/docs/mfa/concepts/mfa-api)\n\n## List Authenticators\n\n```\nGET https://{yourDomain}/mfa/authenticators\nContent-Type: application/json\nAuthorization: Bearer ACCESS_TOKEN\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {\n    'authorization': 'Bearer ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n[\n  {\n    \"id\":\"recovery-code|dev_DsvzGfZw2Fg5N3rI\",\n    \"authenticator_type\":\"recovery-code\",\n    \"active\":true\n  },\n  {\n    \"id\":\"sms|dev_gB342kcL2K22S4yB\",\n    \"authenticator_type\":\"oob\",\n    \"oob_channels\":\"sms\",\n    \"name\":\"+X XXXX1234\",\n    \"active\":true\n  },\n  {\n    \"id\":\"sms|dev_gB342kcL2K22S4yB\",\n    \"authenticator_type\":\"oob\",\n    \"oob_channels\":\"sms\",\n    \"name\":\"+X XXXX1234\",\n    \"active\":false\n  },\n  {\n    \"id\":\"push|dev_433sJ7Mcwj9P794y\",\n    \"authenticator_type\":\"oob\",\n    \"oob_channels\":\"auth0\",\n    \"name\":\"John's Device\",\n    \"active\":true\n  },\n    {\n    \"id\":\"totp|dev_LJaKaN5O3tjRFOw2\",\n    \"authenticator_type\":\"otp\",\n    \"active\":true\n  }\n]\n```\n\n### GET /mfa/authenticators\n\nReturns a list of authenticators associated with your application.\n\nTo access this endpoint you must set an Access Token at the Authorization header, with the following claims:\n\n*   `scope`: `read:authenticators`\n*   `audience`: `https://{yourDomain}/mfa/`\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`ACCESS_TOKEN`  \nRequired\n\nThe Access Token obtained during login.\n\n#### Learn More\n\n*   [Manage Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/manage)\n\n## Delete an Authenticator\n\n```\nDELETE https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\nAuthorization: Bearer ACCESS_TOKEN\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID' \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'DELETE',\n  url: 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID',\n  headers: {\n    'authorization': 'Bearer ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 204 OK\n```\n\n### DELETE /mfa/authenticators\n\nDeletes an associated authenticator using its ID.\n\nYou can get authenticator IDs by [listing the authenticators](#list-authenticators).\n\nTo access this endpoint, you must set an Access Token at the Authorization header, with the following claims:\n\n*   `scope`: `remove:authenticators`\n*   `audience`: `https://{yourDomain}/mfa/`\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`ACCESS_TOKEN`  \nRequired\n\nThe Access Token obtained during login.\n\n`AUTHENTICATOR_ID`  \nRequired\n\nThe ID of the authenticator to delete.\n\n### Learn More\n\n*   [Manage Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/manage)\n\n## SAML\n\nThe SAML protocol is used mostly for third-party SaaS applications, like Salesforce and Box. Auth0 supports Service Provider (SP) and Identity Provider (IDP) initiated Sign On. To learn more, see [SAML](https://auth0.com/docs/protocols/saml).\n\n## Accept Request\n\n```\nGET https://{yourDomain}/samlp/{yourClientId}?\n  connection=CONNECTION\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/samlp/{yourClientId}' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data '\"connection\"=\"CONNECTION\"'\n```\n\n### GET /samlp/YOUR\\_CLIENT\\_ID\n\nUse this endpoint to accept a SAML request to initiate a login.\n\nOptionally, you can include a `connection` parameter to log in with a specific provider. If no connection is specified, the [Auth0 Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login) will be shown.\n\nOptionally, SP-initiated login requests can include an `organization` parameter to authenticate users in the context of an organization. To learn more, see [Organizations](https://auth0.com/docs/organizations).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nClient ID of your application.\n\n`connection`\n\nConnection to use during login.\n\n`organization`\n\nOrganization ID, if authenticating in the context of an organization.\n\n*   All the parameters of the SAML response can be modified with [Rules](https://auth0.com/docs/rules).\n*   The SAML request `AssertionConsumerServiceURL` will be used to `POST` back the assertion. It must match one of the application's `callback_URLs`.\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n\n## Get Metadata\n\n```\nGET https://{yourDomain}/samlp/metadata/{yourClientId}\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/samlp/metadata/{yourClientId}'\n```\n\n### GET /samlp/metadata/YOUR\\_CLIENT\\_ID\n\nThis endpoint returns the SAML 2.0 metadata.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n\n## IdP-Initiated Single Sign-On (SSO) Flow\n\n```\nPOST https://{yourDomain}/login/callback?connection=CONNECTION\nContent-Type: 'application/x-www-form-urlencoded'\n  SAMLResponse=SAML_RESPONSE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/login/callback' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data '\"connection\":\"CONNECTION\", \"SAMLResponse\":\"SAML_RESPONSE\"'\n```\n\n### POST /login/callback\n\nThis endpoint accepts an IdP-Initiated Sign On SAMLResponse from a SAML Identity Provider. The connection corresponding to the identity provider is specified in the query string. The user will be redirected to the application that is specified in the SAML Provider IdP-Initiated Sign On section.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`connection`  \nRequired\n\nThe name of an identity provider configured to your application.\n\n`SAMLResponse`  \nRequired\n\nAn IdP-Initiated Sign On SAML Response.\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n\n## WS-Federation\n\n## Accept Request\n\n```\nGET https://{yourDomain}/wsfed/{yourClientId}\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/wsfed/{yourClientId}'\n```\n\n### GET /wsfed/YOUR\\_CLIENT\\_ID\n\nThis endpoint accepts a WS-Federation request to initiate a login.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client-id`\n\nThe `client-id` of your application.\n\n`wtrealm`\n\nCan be used in place of `client-id`.\n\n`whr`\n\nThe name of the connection (used to skip the login page).\n\n`wctx`\n\nYour application's state.\n\n`wreply`\n\nThe callback URL.\n\n*   The `wtrealm` parameter must be in one of these formats:\n    *   `urn:clientID` (for example, urn:{yourClientId})\n    *   If this parameter does not begin with a urn, the `client.clientAliases` array is used for look-up. This can only be set with the [/api/v2/clients](https://auth0.com/docs/api/management/v2#!/Clients/get_clients) Management API.\n*   The `whr` parameter is mapped to the connection like this: `urn:CONNECTION_NAME`. For example, `urn:google-oauth2` indicates login with Google. If there is no `whr` parameter included, the user will be directed to the [Auth0 Login Page](https://auth0.com/docs/login_page).\n\n### Learn More\n\n*   [WS-Federation](https://auth0.com/docs/protocols/ws-fed)\n\n## Get Metadata\n\n```\nGET https://{yourDomain}/wsfed/FederationMetadata/2007-06/FederationMetadata.xml\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/wsfed/FederationMetadata/2007-06/FederationMetadata.xml'\n```\n\n### GET /wsfed/FederationMetadata/2007-06/FederationMetadata.xml\n\nThis endpoint returns the WS-Federation metadata.\n\n### Learn More\n\n*   [WS-Federation](https://auth0.com/docs/protocols/ws-fed)\n\n## Dynamic Application (Client) Registration\n\n```\nPOST https://{yourDomain}/oidc/register\nContent-Type: application/json\n{\n  \"client_name\": \"YOUR-NEW-CLIENT-NAME\",\n  \"redirect_uris\": [],\n  \"token_endpoint_auth_method\": \"client_secret_post\"\n}\n```\n\n```\ncurl --request POST \\\n  --url https://{yourDomain}/oidc/register \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_name\": \"YOUR-NEW-CLIENT-NAME\",\"redirect_uris\": [], \"token_endpoint_auth_method\": \"client_secret_post\"}'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"client_name\": \"My Dynamic Client\",\n  \"client_id\": \"8SXWY6j3afl2CP5ntwEOpMdPxxy49Gt2\",\n  \"client_secret\": \"Q5O...33P\",\n  \"redirect_uris\": [\n    \"https://client.example.com/callback\",\n    \"https://client.example.com/callback2\"\n  ],\n  \"client_secret_expires_at\": 0\n}\n```\n\n### POST /oidc/register\n\nWith a name and the necessary callback URL, you can dynamically register a client with Auth0. No token is needed for this request.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_name`\n\nThe name of the Dynamic Client to be created. It is recommended to provide a value but if it is omitted, the default name \"My App\" will be used.\n\n`redirect_uris`  \nRequired\n\nAn array of URLs that Auth0 will deem valid to call at the end of an Authentication flow.\n\n`token_endpoint_auth_method`\n\nDefault value is `client_secret_post`. Use `token_endpoint_auth_method: none` in the request payload if creating a SPA.\n\nAPI Authorization\n\n## Authorize Application\n\nTo begin an OAuth 2.0 Authorization flow, your application should first send the user to the authorization URL.\n\n## Authorize endpoint\n\nThe purpose of this call is to obtain consent from the user to invoke the API (specified in `audience`) and do certain things (specified in `scope`) on behalf of the user. Auth0 will authenticate the user and obtain consent, unless consent has been previously given. If you alter the value in `scope`, Auth0 will require consent to be given again.\n\nThe OAuth 2.0 flows that require user authorization are:\n\n*   [Authorization Code Flow](https://auth0.com/docs/flows/concepts/auth-code)\n*   [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce)\n*   [Implicit Flow](https://auth0.com/docs/flows/concepts/implicit)\n\nThe [Resource Owner Password Grant](https://auth0.com/docs/api-auth/grant/password) and [Client Credentials Flow](https://auth0.com/docs/flows/concepts/client-credentials) do not use this endpoint since there is no user authorization involved. Instead, they directly invoke the `POST /oauth/token` endpoint to retrieve an Access Token.\n\nBased on the OAuth 2.0 flow you are implementing, the parameters slightly change. To determine which flow is best suited for your case, refer to: [Which OAuth 2.0 flow should I use?](https://auth0.com/docs/api-auth/which-oauth-flow-to-use).\n\n## Get Token\n\nFor token-based authentication, use the `oauth/token` endpoint to get an access token for your application to make authenticated calls to a secure API. Optionally, you can also retrieve an ID Token and a Refresh Token. ID Tokens contains user information in the form of scopes you application can extract to provide a better user experience. Refresh Tokens allow your application to request a new access token once the current token expires without interruping the user experience. To learn more, read [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens) and [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\nNote that the only OAuth 2.0 flows that can retrieve a Refresh Token are:\n\n*   [Authorization Code Flow (Authorization Code)](https://auth0.com/docs/flows/concepts/auth-code)\n*   [Authorization Code Flow with PKCE (Authorization Code with PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce)\n*   [Resource Owner Password](https://auth0.com/docs/api-auth/grant/password)\n*   [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth)\n*   Token Exchange\\*\n\n## Authorization Code Flow\n\n## Authorize\n\n```\nGET https://{yourDomain}/authorize?\n  audience=API_IDENTIFIER&\n  scope=SCOPE&\n  response_type=code&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}?code=AUTHORIZATION_CODE&state=STATE\n```\n\n### GET /authorize\n\nThis is the OAuth 2.0 grant that regular web apps utilize in order to access an API.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes which you want to request authorization for. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token.\n\n`response_type`  \nRequired\n\nIndicates to Auth0 which OAuth 2.0 flow you want to use. Use `code` for Authorization Code Grant Flow.\n\n`client_id`  \nRequired\n\nYour application's ID.\n\n`state`  \nRecommended\n\nAn opaque value the application adds to the initial request that Auth0 includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`redirect_uri`\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`connection`\n\nThe name of the connection configured to your application.\n\n`prompt`\n\nTo initiate a [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) request, use `prompt=none` (To learn more, read the Remarks).\n\n`organization`\n\nID of the [organization](https://auth0.com/docs/organizations) to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n`invitation`\n\nTicket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the invitation and organization key-value pairs when the user accepts the invitation.\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'authorization_code',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     code: 'AUTHORIZATION_CODE',\n     redirect_uri: '{https://yourApp/callback}' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the flow that regular web apps use to access an API. Use this endpoint to exchange an Authorization Code for a token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Authorization Code, use `authorization_code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`  \nRequired\n\nYour application's Client Secret.\n\n`code`  \nRequired\n\nThe Authorization Code received from the initial `/authorize` call.\n\n`redirect_uri`\n\nThis is required only if it was set at the [GET /authorize](#authorization-code-grant) endpoint. The values from `/authorize` must match the value you set at `/oauth/token`.\n\n### Learn More\n\n*   [Authorization Code Flow](https://auth0.com/docs/flows/concepts/auth-code)\n*   [Call API Using the Authorization Code Flow](https://auth0.com/docs/flows/guides/auth-code/call-api-auth-code)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication)\n\n## Authorization Code Flow with PKCE\n\n## Authorize\n\n```\nGET https://{yourDomain}/authorize?\n  audience=API_IDENTIFIER&\n  scope=SCOPE&\n  response_type=code&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  code_challenge=CODE_CHALLENGE&\n  code_challenge_method=S256\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}?code=AUTHORIZATION_CODE\n```\n\n### GET /authorize\n\nThis is the OAuth 2.0 grant that mobile apps utilize in order to access an API. Before starting with this flow, you need to generate and store a `code_verifier`, and using that, generate a `code_challenge` that will be sent in the authorization request.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes which you want to request authorization for. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token.\n\n`response_type`  \nRequired\n\nIndicates to Auth0 which OAuth 2.0 Flow you want to perform. Use `code` for Authorization Code Grant (PKCE) Flow.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`state`  \nRecommended\n\nAn opaque value the client adds to the initial request that Auth0 includes when redirecting back to the client. This value must be used by the client to prevent CSRF attacks.\n\n`redirect_uri`\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`code_challenge_method`  \nRequired\n\nMethod used to generate the challenge. The PKCE spec defines two methods, `S256` and `plain`, however, Auth0 supports only `S256` since the latter is discouraged.\n\n`code_challenge`  \nRequired\n\nGenerated challenge from the `code_verifier`.\n\n`connection`\n\nThe name of the connection configured to your application.\n\n`prompt`\n\nTo initiate a [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) request, use `prompt=none` (To learn more, read the Remarks).\n\n`organization`\n\nID of the [organization](https://auth0.com/docs/organizations) to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n`invitation`\n\nTicket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the invitation and organization key-value pairs when the user accepts the invitation.\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&client_id={yourClientId}&code_verifier=CODE_VERIFIER&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=authorization_code&client_id={yourClientId}&code_verifier=CODE_VERIFIER&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form: {\n    grant_type:\"authorization_code\",\n    client_id: \"{yourClientId}\",\n    code_verifier: \"CODE_VERIFIER\",\n    code: \"AUTHORIZATION_CODE\",\n    redirect_uri: \"{https://yourApp/callback}\", } };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the flow that mobile apps use to access an API. Use this endpoint to exchange an Authorization Code for a token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Authorization Code (PKCE) use `authorization_code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`code`  \nRequired\n\nThe Authorization Code received from the initial `/authorize` call.\n\n`code_verifier`  \nRequired\n\nCryptographically random key that was used to generate the `code_challenge` passed to `/authorize`.\n\n`redirect_uri`\n\nThis is required only if it was set at the [GET /authorize](#authorization-code-grant-pkce-) endpoint. The values from `/authorize` must match the value you set at `/oauth/token`.\n\n*   In order to improve compatibility for applications, Auth0 will now return profile information in a [structured claim format as defined by the OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). This means that in order to add custom claims to ID tokens or access tokens, they must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims) to avoid possible collisions with standard OIDC claims.\n*   Include `offline_access` to the `scope` request parameter to get a refresh token from [POST /oauth/token](#authorization-code-pkce-). Make sure that the **Allow Offline Access** field is enabled in the [API Settings](https://manage.auth0.com/#/apis).\n*   The `redirect_uri` value must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications).\n*   Silent authentication lets you perform an authentication flow where Auth0 will only reply with redirects, and never with a login page. When an Access Token has expired, silent authentication can be used to retrieve a new one without user interaction, assuming the user's Single Sign-on (SSO) session has not expired.\n\n### Learn More\n\n*   [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce)\n*   [Call API Using the Authorization Code Flow with PKCE](https://auth0.com/docs/flows/guides/auth-code-pkce/call-api-auth-code-pkce)\n*   [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication)\n\n\\>\n\n## Authorization Code Flow with Enhanced Privacy Protection\n\n## Push Authorization Requests (PAR)\n\n### POST /oauth/par\n\n```\nPOST {yourDomain}/oauth/par\nContent-Type: 'application/x-www-form-urlencoded'\n  audience={https://yourApi/}&\n  response_type=code|code id_token&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE&\n  scope=openid|profile|email&\n  code_challenge=CODE_CHALLENGE&\n  code_challenge_method=S256&\n  nonce=NONCE&\n  connection=CONNECTION&\n  prompt=login|consent|none&\n  organisation=ORGANIZATION\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/par,\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form: {\n    audience: '{https://yourApi/}',\n    response_type: 'code|code id_token',\n    client_id: '{yourClientId}',\n    redirect_uri: '{https://yourApp/callback}',\n    state: 'STATE',\n    scope: 'openid|profile|email',\n    authorization_details: JSON.stringify([{ type: 'my_type' }]),\n    code_challenge: 'CODE_CHALLENGE',\n    code_challenge_method: 'S256',\n    nonce: 'NONCE',\n    connection: 'CONNECTION',\n    prompt: 'login|consent|none'\n    organisation: 'ORGANIZATION'\n    }\n};\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/par' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n--data 'audience={https://yourApi/}response_type=code|code id_token&client_id={yourClientId}&redirect_uri={https://yourApp/callback}&state=STATE&scope=openid|profile|email&authorization_details='[{\"type\":\"my_type\"}]'\n&code_challenge=CODE_CHALLENGE&code_challenge_method=S256&nonce=NONCE&connection=CONNECTION&prompt=login|consent|none&organisation=ORGANIZATION'\n\n```\n\n> RESPONSE SAMPLE:\n\n```\n/**\nIf the request is successful, `/oauth/par` responds with a `JSON` object containing the `request_uri` property, which can be used at the authorization endpoint, and the `expires_in` value, which indicates the number of seconds the `request_uri` is valid. \n*/\n\nHTTP/1.1 201 Created\nContent-Type: application/json\n\n{\n  \"request_uri\":\n    \"urn:ietf:params:oauth:request_uri:6esc_11ACC5bwc014ltc14eY22c\",\n  \"expires_in\": 30\n}\n```\n\nAuthorization Code Flow with [Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par) uses the `/oauth/par` endpoint to allow applications to send the authorization parameters usually sent in a `GET` request to `/authorize`. PAR uses a POST method from the backend to keep parameter values secure. The `/oauth/par` endpoint accepts all authorization parameters which can be proivided to `/authorize`. Assuming the call to the `/oauth/par` endpoint is valid, Auth0 will respond with a `redirect_uri` value that can be used as a parameter for the `/authorize` endpoint.\n\nAssuming the call to the `/oauth/par` endpoint is valid, Auth0 will respond with a `redirect_uri` value also used as a parameter for the `/authorize` endpoint. To learn more about configuring PAR, read [Configure Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/applications/configure-par).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`authorization_details`\n\nRequested permissions for each resource. Similar to scopes. To learn more, read [RAR reference documention](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar).\n\n`audience`\n\nThe unique identifier of the target API you want to access.\n\n`response_type`  \nRequired\n\nSpecifies the token type. We recommend you use `code` to request an authorization code, or code `id_token` to receive an authorization code and a [detached signature](https://openid.net/specs/openid-financial-api-part-2-1_0.html#id-token-as-detached-signature).\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`state`  \nRecommended\n\nAn opaque value the application adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`scope`  \nRecommended\n\nOIDC scopes and custom API scopes. For example: `openid read:timesheets`. Include `offline_access` to get a refresh token.\n\n`code_challenge`  \nRecommended\n\nOIDC scopes and custom API scopes. For example: `openid read:timesheets`. Include `offline_access` to get a refresh token.\n\n`code_challenge_method`  \nRecommended\n\nMethod used to generate the challenge. The PKCE specification defines two methods, `S256` and plain, however, Auth0 supports only S256 since the latter is discouraged. \\[Authorization Code Flow with Proof Key for Code Exchange (PKCE)\\] (/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n\n`nonce`  \nRecommended\n\nA string value which will be included in the ID token response from Auth0, used to prevent token replay attacks. It is required for `response_type=id_token` token.\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget using the first database connection.\n\n`prompt`\n\nCan be used to force a particular prompt to display, e.g. `prompt=consent` will always display the consent prompt.\n\n`organization`\n\nID of the organization to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n*   To make a call to the PAR endpoint, you must:\n    *   Set the request content type as `application/x-www-form-urlencoded`\n    *   Use `strings` for all passed parameters\n    *   Include an additional parameter for application authentication in the request (e.g. `client_secret`, or `client_assertion` and `client_assertion_type` for JSON Web Token Client Authentication, or pass a `client-certificate` and `client-certificate-ca-verified` header when using Mutual TLS).\n*   Use the `authorization_details` parameter to request permission for each resource. For example, you can specify an array of JSON objects to convey fine-grained information on the authorization. Each JSON object must contain a `type` attribute. The rest is up to you to define.\n\n## Authorize\n\n### GET /authorize\n\n```\nGET https://{yourDomain}/authorize\n  request_uri={yourRequestUri}&\n  client_id={yourClientId}\n```\n\nAfter calling the `/oauth/par` endpoint, redirect the end user to the `/authorize` endpoint using a `GET` call.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`request_uri`  \nRequired\n\nThe `request_uri` value that was received from the `/oauth/par` endpoint.\n\n## Exchange an Authorization Code for a Token\n\n### POST /oauth/token\n\n```\nPOST https://{yourDomain}/oauth/par\nContent-Type: 'application/x-www-form-urlencoded'\n  grant_type=code|code id_token&\n  client_id={yourClientId}&\n  code=CODE&\n redirect_uri={https://yourApp/callback}&\n code_verifier=CODE_VERIFIER\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/par' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n--data 'grant_type=authorization_code& client_id={yourClientId}& code=CODE&redirect_uri={https://yourApp/callback}&code_verifier=CODE_VERIFIER'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token,\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form: { \n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    code: 'CODE',\n    redirect_uri: '{https://yourApp/callback}',\n    code_verifier: 'CODE_VERIFIER'\n    }\n};\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\n/**\nThe `/oauth/token` endpoint will respond with a JSON object containing an `id_token` property, and potentially also a `refresh_token` if one was requested.\n*/\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n   \"refresh_token\":\"GEbRxBN...edjnXbL\",\n    \"access_token\":\"eybRxBN...edjnXZQ\",  \n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400,\n  \"authrorization_details\":[\n    {\n      \"type\":\"my_type\",\n      \"other_attributes_of_my_type\":\"value\"}\n  ]\n},\n  \n  \n```\n\nWhen users are redirected back to your callback, you need to make a `POST` call to the `oauth/token` endpoint to exchange an authorization code for an access and/or an ID token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow. Assuming you have an authorization code from the `/authorize` endpoint, use `authorization_code`.\n\n`code`\n\nThe authorization code from the initial `/authorize` call.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`request_uri`  \nRequired\n\nThis is required only if it was set at the `GET` `/oauth/par` endpoint. The values from `/authorize` must match the value you set at `/oauth/token`.\n\n`code_verifier`  \nRecommended\n\nCryptographically random key used to generate the `code_challenge` passed to `/oauth/par`. If the `code_challenge` parameter is passed in the call to `/oauth/par`, this is required.\n\nTo make a call to `/oauth/token` endpoint, you must:\n\n*   Set the request content type as `application/x-www-form-urlencoded`\n*   Use `strings` for all passed parameters\n*   Include an additional parameter for application authentication in the request (e.g. `client_secret`, or `client_assertion` and `client_assertion_type` for JSON Web Token Client Authentication, or pass a `client-certificate` and `client-certificate-ca-verified` header when using Mutual TLS).\n\n\\>\n\n## Client Credential Flow\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\naudience=API_IDENTIFIER&grant_type=client_credentials&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'audience=API_IDENTIFIER&grant_type=client_credentials&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     audience: 'API_IDENTIFIER',\n     grant_type: 'client_credentials' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the OAuth 2.0 grant that server processes use to access an API. Use this endpoint to directly request an access token by using the application's credentials (a Client ID and a Client Secret).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Client Credentials use `client_credentials`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`  \nRequired\n\nYour application's Client Secret.\n\n`audience`  \nRequired\n\nThe unique identifier of the target API you want to access.\n\n### Learn More\n\n*   [Client Credentials Flow](https://auth0.com/docs/flows/concepts/client-credentials)\n*   [Call API using the Client Credentials Flow](https://auth0.com/docs/flows/guides/client-credentials/call-api-client-credentials)\n*   [Setting up a Client Grant using the Management Dashboard](https://auth0.com/docs/api-auth/config/using-the-auth0-dashboard)\n*   [Asking for Access Tokens for a Client Credentials Grant](https://auth0.com/docs/api-auth/config/asking-for-access-tokens)\n\n\\>\n\n## Implicit Flow\n\n## Authorize\n\n```\nGET https://{yourDomain}/authorize?\n  audience=API_IDENTIFIER&\n  scope=SCOPE&\n  response_type=token|id_token|id_token token&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE&\n  nonce=NONCE\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}#access_token=TOKEN&state=STATE&token_type=TYPE&expires_in=SECONDS\n```\n\n### GET /authorize\n\nThis is the OAuth 2.0 grant that web apps utilize in order to access an API.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes which you want to request authorization for. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`. Custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`).\n\n`response_type`  \nRequired\n\nThis will specify the type of token you will receive at the end of the flow. Use `token` to get only an Access Token, `id_token` to get only an ID token (if you don't plan on accessing an API), or `id_token token` to get both an ID token and an Access Token.\n\n`client_id`  \nRequired\n\nYour application's ID.\n\n`state`  \nRecommended\n\nAn opaque value the application adds to the initial request that Auth0 includes when redirecting back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`redirect_uri`\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`nonce`  \nRecommended\n\nA string value which will be included in the ID token response from Auth0, [used to prevent token replay attacks](https://auth0.com/docs/api-auth/tutorials/nonce). It is required for `response_type=id_token token`.\n\n`connection`\n\nThe name of the connection configured for your application.\n\n`prompt`\n\nTo initiate a [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) request, use `prompt=none` (To learn more, read the Remarks).\n\n`organization`\n\nID of the [organization](https://auth0.com/docs/organizations) to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n`invitation`\n\nTicket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the invitation and organization key-value pairs when the user accepts the invitation.\n\n*   The `redirect_uri` value must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications).\n*   If `response_type=token`, after the user authenticates with the provider, this will redirect them to your application callback URL while passing the `access_token` in the address `location.hash`. This is used for Single-Page Apps and on Native Mobile SDKs.\n*   The Implicit Grant does not support the issuance of Refresh Tokens. Use [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) instead.\n*   In order to improve compatibility for applications, Auth0 will now return profile information in a [structured claim format as defined by the OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). This means that in order to add custom claims to ID tokens or Access Tokens, they must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims) to avoid possible collisions with standard OIDC claims.\n*   Silent Authentication lets you perform an authentication flow where Auth0 will only reply with redirects, and never with a login page. When an Access Token has expired, silent authentication can be used to retrieve a new one without user interaction, assuming the user's Single Sign-on (SSO) session has not expired.\n\n### Learn More\n\n*   [Implicit Flow](https://auth0.com/docs/flows/concepts/implicit)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Mitigate replay attacks when using the Implicit Grant](https://auth0.com/docs/api-auth/tutorials/nonce)\n*   [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication)\n\n\\>\n\n## Resource Owner Password Flow\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=password&username=USERNAME&password=PASSWORD&audience=API_IDENTIFIER&scope=SCOPE&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=password&username=USERNAME&password=PASSWORD&audience=API_IDENTIFIER&scope=SCOPE&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'password',\n     username: 'USERNAME',\n     password: 'PASSWORD',\n     audience: 'API_IDENTIFIER',\n     scope: 'SCOPE',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the OAuth 2.0 grant that highly-trusted apps use to access an API. In this flow, the end-user is asked to fill in credentials (username/password), typically using an interactive form in the user-agent (browser). This information is sent to the backend and from there to Auth0. It is therefore imperative that the application is absolutely trusted with this information. For [single-page applications and native/mobile apps](https://auth0.com/docs/flows/concepts/auth-code-pkce), we recommend using web flows instead.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Resource Owner Password use `password`. To add realm support use `http://auth0.com/oauth/grant-type/password-realm`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`audience`\n\nThe unique identifier of the target API you want to access.\n\n`username`  \nRequired\n\nResource Owner's identifier, such as a username or email address.\n\n`password`  \nRequired\n\nResource Owner's secret.\n\n`scope`\n\nString value of the different scopes the application is asking for. Multiple scopes are separated with whitespace.\n\n`realm`\n\nString value of the realm the user belongs. Set this if you want to add realm support at this grant. For more information on what realms are refer to [Realm Support](https://auth0.com/docs/api-auth/grant/password#realm-support).\n\nParameter\n\nDescription\n\n`auth0-forwarded-for`\n\nEnd-user IP as a string value. Set this if you want brute-force protection to work in server-side scenarios. For more information on how and when to use this header, refer to [Using resource owner password from server-side](https://auth0.com/docs/api-auth/tutorials/using-resource-owner-password-from-server-side).\n\n*   The scopes issued to the application may differ from the scopes requested. In this case, a `scope` parameter will be included in the response JSON.\n*   If you don't request specific scopes, all scopes defined for the audience will be returned due to the implied trust to the application in this grant. You can customize the scopes returned in a rule. For more information, refer to [Calling APIs from Highly Trusted Applications](https://auth0.com/docs/api-auth/grant/password).\n*   To add realm support set the `grant_type` to `http://auth0.com/oauth/grant-type/password-realm`, and the `realm` to the realm the user belongs. This maps to a connection in Auth0. For example, if you have configured a database connection for your internal employees and you have named the connection `employees`, then use this value. For more information on how to implement this refer to: [Realm Support](https://auth0.com/docs/api-auth/tutorials/password-grant#realm-support).\n*   In addition to username and password, Auth0 may also require the end-user to provide an additional factor as proof of identity before issuing the requested scopes. In this case, the request described above will return an `mfa_required` error along with an `mfa_token`. You can use these tokens to request a challenge for the possession factor and validate it accordingly. For details refer to [Resource Owner Password and MFA](#resource-owner-password-and-mfa).\n\n### Learn More\n\n*   [Calling APIs from Highly-Trusted Applications](https://auth0.com/docs/api-auth/grant/password)\n*   [Executing the Resource Owner Password Grant](https://auth0.com/docs/api-auth/tutorials/password-grant)\n*   [Multi-factor Authentication and Resource Owner Password](https://auth0.com/docs/mfa/guides/mfa-api/multifactor-resource-owner-password)\n\n\\>\n\n## Device Authorization Flow\n\n## Authorize\n\n```\nPOST https://{yourDomain}/oauth/device/code\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&scope=SCOPE&audience=API_IDENTIFIER\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/device/code' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&scope=SCOPE&audience=API_IDENTIFIER'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/device/code',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { client_id: '{yourClientId}',\n     scope: 'SCOPE',\n     audience: 'API_IDENTIFIER' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"device_code\":\"GmRh...k9eS\",\n  \"user_code\":\"WDJB-MJHT\",\n  \"verification_uri\":\"https://{yourDomain}/device\",\n  \"verification_uri_complete\":\"https://{yourDomain}/device?user_code=WDJB-MJHT\",\n  \"expires_in\":900, //in seconds\n  \"interval\":5\n}\n```\n\n### POST /oauth/device/code\n\nThis is the flow that input-constrained devices use to access an API. Use this endpoint to get a device code. To begin the [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth), your application should first request a device code.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes for which you want to request authorization. These must be separated by a space. You can request any of the [standard OIDC scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token.\n\n`client_id`  \nRequired\n\nYour application's ID.\n\n### Response Values\n\nValue\n\nDescription\n\n`device_code`\n\nThe unique code for the device. When the user visits the `verification_uri` in their browser-based device, this code will be bound to their session.\n\n`user_code`\n\nThe code that the user should input at the `verification_uri` to authorize the device.\n\n`verification_uri`\n\nThe URL the user should visit to authorize the device.\n\n`verification_uri_complete`\n\nThe complete URL the user should visit to authorize the device. Your app can use this value to embed the `user_code` in the URL, if you so choose.\n\n`expires_in`\n\nThe lifetime (in seconds) of the `device_code` and `user_code`.\n\n`interval`\n\nThe interval (in seconds) at which the app should poll the token URL to request a token.\n\n*   Include `offline_access` to the `scope` request parameter to get a Refresh Token from [POST /oauth/token](#device-auth). Make sure that the **Allow Offline Access** field is enabled in the [API Settings](https://manage.auth0.com/#/apis).\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&device_code=YOUR_DEVICE_CODE&grant_type=urn:ietf:params:oauth:grant-type:device_code\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&device_code=YOUR_DEVICE_CODE&grant_type=urn:ietf:params:oauth:grant-type:device_code'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { client_id: '{yourClientId}',\n     device_code: 'YOUR_DEVICE_CODE',\n     grant_type: 'urn:ietf:params:oauth:grant-type:device_code' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n   \"access_token\": \"eyJz93a...k4laUWw\",\n   \"id_token\": \"eyJ...0NE\",\n   \"refresh_token\": \"eyJ...MoQ\",\n   \"scope\": \"...\",\n   \"expires_in\": 86400,\n   \"token_type\": \"Bearer\"\n}\n```\n\n```\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\n { \n  // Can be retried\n  \"error\": \"authorization_pending\",\n  \"error_description\": \"User has yet to authorize device code.\"\n }\n```\n\n```\nHTTP/1.1 429 Too Many Requests\nContent-Type: application/json\n { \n  // Can be retried\n  \"error\": \"slow_down\",\n  \"error_description\": \"You are polling faster than the specified interval of 5 seconds.\"\n }\n```\n\n```\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\n { \n    // Cannot be retried; transaction failed\n    \"error\": \"access_denied|invalid_grant|...\",\n    \"error_description\": \"Failure: User cancelled the confirmation prompt or consent page; the code expired; there was an error.\"\n }\n```\n\n### POST /oauth/token\n\nThis is the OAuth 2.0 grant that input-constrained devices use to access an API. Poll this endpoint using the interval returned with your [device code](https://auth0.com/docs/api/authentication#get-device-code) to directly request an access token using the application's credentials (a Client ID) and a device code.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Device Authorization, use `urn:ietf:params:oauth:grant-type:device_code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`device_code`  \nRequired\n\nThe device code previously returned from the [/oauth/device/code endpoint](https://auth0.com/docs/api/authentication#device-authorization-flow).\n\n*   Because you will be polling this endpoint (using the `interval` from the initial response to determine frequency) while waiting for the user to go to the verification URL and enter their user code, you will likely receive at least one failure before receiving a successful response. See sample responses for possible responses.\n\n### Learn More\n\n*   [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth)\n*   [Call API using the Device Authorization Flow](https://auth0.com/docs/flows/guides/device-auth/call-api-device-auth)\n*   [Setting up a Device Code Grant using the Management Dashboard](https://auth0.com/docs/api-auth/config/using-the-auth0-dashboard)\n\n## Refresh Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&refresh_token=YOUR_REFRESH_TOKEN\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=refresh_token&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&refresh_token=YOUR_REFRESH_TOKEN'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'refresh_token',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     refresh_token: 'YOUR_REFRESH_TOKEN'}\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\": \"eyJ...MoQ\",\n  \"expires_in\": 86400,\n  \"scope\": \"openid offline_access\",\n  \"id_token\": \"eyJ...0NE\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### POST /oauth/token\n\nUse this endpoint to refresh an Access Token using the Refresh Token you got during authorization.\n\n## Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. To refresh a token, use `refresh_token`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`\n\nYour application's Client Secret. Required when the **Token Endpoint Authentication Method** field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`refresh_token`  \nRequired\n\nThe refresh token to use.\n\n`scope`\n\nA space-delimited list of requested scope permissions. If not sent, the original scopes will be used; otherwise you can request a reduced set of scopes. Note that this must be URL encoded.\n\n## Learn More\n\n*   [Refresh Tokens](https://auth0.com/docs/tokens/concepts/refresh-tokens)\n\n## Revoke Refresh Token\n\n```\nPOST https://{yourDomain}/oauth/revoke\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"token\": \"YOUR_REFRESH_TOKEN\",\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/revoke' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\", \"token\": \"YOUR_REFRESH_TOKEN\" }'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/revoke',\n  headers: { 'content-type': 'application/json' },\n  body: \n   { client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     token: 'YOUR_REFRESH_TOKEN' },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\n(empty-response-body)\n```\n\n### POST /oauth/revoke\n\nUse this endpoint to invalidate a Refresh Token if it has been compromised.\n\nThe behaviour of this endpoint depends on the state of the [Refresh Token Revocation Deletes Grant](https://auth0.com/docs/tokens/refresh-tokens/revoke-refresh-tokens#refresh-tokens-and-grants) toggle. If this toggle is enabled, then each revocation request invalidates not only the specific token, but all other tokens based on the same authorization grant. This means that **all Refresh Tokens that have been issued for the same user, application, and audience will be revoked**. If this toggle is disabled, then only the refresh token is revoked, while the grant is left intact.\n\n## Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is the application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nThe `client_secret` of your application. Required when Client Secret Basic or Client Secret Post is the application authentication method. Specifically required for Regular Web Applications **only**.\n\n`token`  \nRequired\n\nThe Refresh Token you want to revoke.\n\n*   For non-confidential applications that cannot keep the Client Secret safe (for example, native apps), the endpoint supports passing no Client Secret but the application itself must have the property `tokenEndpointAuthMethod` set to `none`. You can do this either from the UI ([Dashboard > Applications > Application Settings](https://manage.auth0.com/#/applications)) or using the [Management API](https://auth0.com/docs/api/management/v2#!/Applications/patch_applications_by_id).\n\n## Error Codes\n\nFor the complete error code reference for this endpoint, refer to [Errors > POST /oauth/revoke](#post-oauth-revoke).\n\n## Learn More\n\n*   [Refresh Tokens](https://auth0.com/docs/tokens/concepts/refresh-tokens)\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=urn:ietf:params:oauth:grant-type:token-exchange&subject_token=SUBJECT_TOKEN&subject_token_type=SUBJECT_TOKEN_TYPE&client_id={yourClientId}&audience=API_IDENTIFIER&scope=SCOPE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=urn:ietf:params:oauth:grant-type:token-exchange&subject_token=SUBJECT_TOKEN&subject_token_type=SUBJECT_TOKEN_TYPE&client_id={yourClientId}&audience=API_IDENTIFIER&scope=SCOPE'\n }'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange',\n     subject_token: 'SUBJECT_TOKEN',\n     subject_token_type: 'SUBJECT_TOKEN_TYPE',\n     client_id: '{yourClientId}',\n     audience: 'API_IDENTIFIER',\n     scope: 'SCOPE',\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{ \n  \"access_token\": \"eyJz93a...k4laUWw\",\n  \"id_token\": \"eyJ...0NE\",\n  \"refresh_token\": \"eyJ...MoQ\",\n  \"expires_in\":86400,\n  \"token_type\":\"Bearer\"\n}\n```\n\n### POST /oauth/token\n\nWhen a non-browser-based solution (such as a mobile platform's SDK) authenticates the user, the authentication will commonly result in artifacts being returned to application code. In such situations, this grant type allows for the Auth0 platform to accept artifacts from trusted sources and issue tokens in response. In this way, apps making use of non-browser-based authentication mechanisms (as are common in native apps) can still retrieve Auth0 tokens without asking for further user interaction.\n\nArtifacts returned by this flow (and the contents thereof) will be determined by the `subject_token_type` and the tenant's configuration settings.\n\n## Request Parameters\n\nParameter\n\nDescription\n\n`auth0-forwarded-for`\n\nEnd user IP as a string value. Set this if you want brute-force protection to work in server-side scenarios. To learn more about how and when to use this header, read [Using resource owner password from server-side](https://auth0.com/docs/api-auth/tutorials/using-resource-owner-password-from-server-side).\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Token Exchange for Native Social, use `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n`subject_token`  \nRequired\n\nExternally-issued identity artifact representing the user.\n\n`subject_token_type`  \nRequired\n\nIdentifier that indicates the type of `subject_token`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`audience`\n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nString value of the different scopes the application is requesting. Multiple scopes are separated with whitespace.\n\n`user_profile`  \nOnly For `apple-authz-code`\n\nOptional element used for native iOS interactions for which profile updates can occur. Expected parameter value will be JSON in the form of: `{ name: { firstName: 'John', lastName: 'Smith }}`\n\n*   The scopes issued to the application may differ from the requested scopes. In this case, a `scope` parameter will be included in the response JSON.\n*   If you don't request specific scopes, all scopes defined for the audience will be returned due to the implied trust to the application in this grant. You can customize the scopes returned in a rule. To learn more, read [Calling APIs from Highly Trusted Applications](https://auth0.com/docs/api-auth/grant/password).\n\n## Learn More\n\n*   [Add Sign In with Apple to Native iOS Apps](https://auth0.com/docs/connections/apple-siwa/add-siwa-to-native-app)\n*   [iOS Swift - Sign In with Apple Quickstart](https://auth0.com/docs/quickstart/native/ios-swift-siwa)\n\nLegacy\n\n## Login\n\n```\nPOST https://{yourDomain}/oauth/access_token\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"access_token\": \"ACCESS_TOKEN\",\n  \"connection\": \"CONNECTION\",\n  \"scope\": \"SCOPE\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/access_token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"access_token\":\"ACCESS_TOKEN\", \"connection\":\"CONNECTION\", \"scope\":\"SCOPE\"}'\n```\n\n```\nvar url = 'https://' + {yourDomain} + '/oauth/access_token';\nvar params = 'client_id={yourClientId}&access_token={ACCESS_TOKEN}&connection={CONNECTION}&scope={SCOPE}';\n\nvar xhr = new XMLHttpRequest();\n\nxhr.open('POST', url);\nxhr.setRequestHeader('Content-Type', 'application/json');\n\nxhr.onload = function() {\n  if (xhr.status == 200) {\n    fetchProfile();\n  } else {\n    alert(\"Request failed: \" + xhr.statusText);\n  }\n};\n\nxhr.send(params);\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"id_token\": \"eyJ0eXAiOiJKV1Qi...\",\n  \"access_token\": \"A9CvPwFojaBI...\",\n  \"token_type\": \"bearer\"\n}\n```\n\n### POST /oauth/access\\_token\n\nGiven the social provider's Access Token and the `connection`, this endpoint will authenticate the user with the provider and return a JSON with the Access Token and, optionally, an ID Token. This endpoint only works for Facebook, Google, Twitter, and Weibo.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`access_token`  \nRequired\n\nThe social provider's Access Token.\n\n`connection`  \nRequired\n\nThe name of an identity provider configured to your app.\n\n`scope`\n\nUse `openid` to get an ID Token, or `openid profile email` to include user information in the ID Token. If null, only an Access Token will be returned.\n\n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n    \n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n    \n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /oauth/access\\_token](#post-oauth-access_token).\n\n### Learn More\n\n*   [Call an Identity Provider API](https://auth0.com/docs/tutorials/calling-an-external-idp-api)\n*   [Identity Provider Access Tokens](https://auth0.com/docs/tokens/overview-idp-access-tokens)\n*   [Add scopes/permissions to call Identity Provider's APIs](https://auth0.com/docs/connections/adding-scopes-for-an-external-idp)\n\n```\nPOST https://{yourDomain}/oauth/ro\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"username\": \"USERNAME\",\n  \"password\": \"PASSWORD\",\n  \"connection\": \"CONNECTION\",\n  \"scope\": \"openid\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/ro' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"username\":\"USERNAME\", \"password\":\"PASSWORD\", \"connection\":\"CONNECTION\", \"scope\":\"openid\"}'\n\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Trigger login using redirect with credentials to enterprise connections\n  webAuth.redirect.loginWithCredentials({\n    connection: 'Username-Password-Authentication',\n    username: 'testuser',\n    password: 'testpass',\n    scope: 'openid'\n  });\n\n  // Trigger login using popup mode with credentials to enterprise connections\n  webAuth.popup.loginWithCredentials({\n    connection: 'Username-Password-Authentication',\n    username: 'testuser',\n    password: 'testpass',\n    scope: 'openid'\n  });\n\n  // The client.login method allows for non redirect auth using custom database connections, using /oauth/token.\n  webAuth.client.login({\n    realm: 'tests',\n    username: 'testuser',\n    password: 'testpass',\n    scope: 'openid profile',\n    audience: 'urn:test'\n  });\n</script>\n```\n\n### POST /oauth/ro\n\nUse this endpoint for API-based (active) authentication. Given the user credentials and the `connection` specified, it will do the authentication on the provider and return a JSON with the Access Token and ID Token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application\n\n`username`  \nRequired\n\nUsername/email of the user to login\n\n`password`  \nRequired\n\nPassword of the user to login\n\n`connection`  \nRequired\n\nThe name of the connection to use for login\n\n`scope`\n\nSet to `openid` to retrieve also an ID Token, leave null to get only an Access Token\n\n`grant_type`  \nRequired\n\nSet to `password` to authenticate using username/password or `urn:ietf:params:oauth:grant-type:jwt-bearer` to authenticate using an ID Token instead of username/password, in [Touch ID](https://auth0.com/docs/libraries/lock-ios/touchid-authentication) scenarios.\n\n`device`\n\nString value. Required when `grant_type` is `urn:ietf:params:oauth:grant-type:jwt-bearer`\n\n`id_token`\n\nUsed to authenticate using a token instead of username/password, in [Touch ID](https://auth0.com/docs/libraries/lock-ios/touchid-authentication) scenarios. Required when `grant_type` is `urn:ietf:params:oauth:grant-type:jwt-bearer`\n\n*   This endpoint only works for database connections, passwordless connections, Active Directory/LDAP, Windows Azure AD and ADFS.\n    \n*   The main difference between passive and active authentication is that the former happens in the browser through the [Auth0 Login Page](https://{yourdomain}/login) and the latter can be invoked from anywhere (a script, server to server, and so forth).\n    \n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n    \n\n### Error Codes\n\nFor the complete error code reference for this endpoint, refer to [Errors > POST /oauth/ro](#post-oauth-ro).\n\n### Learn More\n\n*   [Database Identity Providers](https://auth0.com/docs/connections/database)\n*   [Rate Limits on User/Password Authentication](https://auth0.com/docs/policies/rate-limit-policy/database-connections-rate-limits)\n*   [Active Directory/LDAP Connector](https://auth0.com/docs/connector)\n\n## User Profile\n\n## Get Token Info\n\n```\nPOST https://{yourDomain}/tokeninfo\nContent-Type: application/json\n{\n  \"id_token\": \"ID_TOKEN\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/tokeninfo' \\\n  --header 'content-type: application/json' \\\n  --data '{\"id_token\":\"\"}'\n```\n\n```\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n</script>\n\nwebAuth.parseHash(window.location.hash, function(err, authResult) {\n  if (err) {\n    return console.log(err);\n  }\n\n  webAuth.client.userInfo(authResult.accessToken, function(err, user) {\n    // Now you have the user's information\n  });\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"email_verified\": false,\n  \"email\": \"foo@bar.com\",\n  \"clientID\": \"q2hnj2iug0...\",\n  \"updated_at\": \"2016-12-08T14:26:59.923Z\",\n  \"name\": \"foo@bar.com\",\n  \"picture\": \"https://s.gravatar.com/avatar/foobar.png\",\n  \"user_id\": \"auth0|58454...\",\n  \"nickname\": \"foo.bar\",\n  \"identities\": [\n    {\n      \"user_id\": \"58454...\",\n      \"provider\": \"auth0\",\n      \"connection\": \"Username-Password-Authentication\",\n      \"isSocial\": false\n    }\n  ],\n  \"created_at\": \"2016-12-05T11:16:59.640Z\",\n  \"global_client_id\": \"dfas76s...\"\n}\n```\n\n### POST /tokeninfo\n\nThis endpoint validates a JSON Web Token (JWT) (signature and expiration) and returns the user information associated with the user id `sub` property of the token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`id_token`  \nRequired\n\nThe ID Token to use.\n\n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n\n### Learn More\n\n*   [User Profile Struture](https://auth0.com/docs/users/references/user-profile-structure)\n    \n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits)\n    \n\n## Account Linking\n\n## Link\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  access_token=LOGGED_IN_USER_ACCESS_TOKEN\n```\n\n### GET /authorize\n\nCall this endpoint when a user wants to link a second authentication method (for example, a user/password database connection, with Facebook).\n\nThis endpoint will trigger the login flow to link an existing account with a new one. This will return a 302 redirect to the `connection` that the current user wants to add. The user is identified by the Access Token that was returned on login success.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nUse `code` for server side flows, `token` for client side flows\n\n`client_id`  \nRequired\n\nThe `client_id` of your application\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to [Auth0 Login Page](https://auth0.com/#/login_page) and show the Login Widget using the first database connection.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`access_token`  \nRequired\n\nThe logged-in user's Access Token\n\n*   The `redirect_uri` value must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n### Learn More\n\n*   [Link User Accounts](https://auth0.com/docs/users/guides/link-user-accounts)\n*   [Link User Accounts Initiated by Users Scenario](https://auth0.com/docs/users/references/link-accounts-user-initiated-scenario)\n*   [Link User Accounts Server-Side Scenario](https://auth0.com/docs/users/references/link-accounts-server-side-scenario)\n\n## Unlink\n\n```\nPOST https://{yourDomain}/login/unlink\nContent-Type: application/json\n{\n  \"access_token\": \"LOGGED_IN_USER_ACCESS_TOKEN\", // Primary identity Access Token\n  \"user_id\": \"LINKED_USER_ID\" // (provider|id)\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/login/unlink' \\\n  --header 'content-type: application/json' \\\n  --data '{\"access_token\": \"LOGGED_IN_USER_ACCESS_TOKEN\", \"user_id\": \"LINKED_USER_ID\"}'\n```\n\n```\nvar url = 'https://' + {yourDomain} + '/login/unlink';\nvar params = 'access_token=LOGGED_IN_USER_ACCESS_TOKEN&user_id=' + localStorage.getItem('user_id');\n\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', url);\nxhr.setRequestHeader('Content-Type', 'application/json');\n\nxhr.onload = function() {\n  if (xhr.status == 200) {\n    fetchProfile();\n  } else {\n    alert(\"Request failed: \" + xhr.statusText);\n  }\n};\n\nxhr.send(params);\n```\n\n### POST /login/unlink\n\nGiven a logged-in user's `access_token` and `user_id`, this endpoint will unlink a user's account from the identity provider.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`access_token`  \nRequired\n\nThe logged-in user's Access Token\n\n`user_id`  \nRequired\n\nThe logged-in user's `user_id`\n\n### Learn More\n\n*   [Unlink User Accounts](https://auth0.com/docs/users/guides/unlink-user-accounts)\n\n## Delegation\n\n```\nPOST https://{yourDomain}/delegation\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n  \"id_token\" or \"refresh_token\" : \"TOKEN\",\n  \"target\": \"TARGET_CLIENT_ID\",\n  \"scope\": \"openid\",\n  \"api_type\": \"API_TYPE\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/delegation' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"grant_type\":\"urn:ietf:params:oauth:grant-type:jwt-bearer\", \"id_token|refresh_token\":\"TOKEN\", \"target\":\"TARGET_CLIENT_ID\", \"scope\":\"openid\", \"api_type\":\"API_TYPE\"}'\n```\n\n```\n// Delegation is not supported in version 8 of auth0.js.\n// For a version 7 sample refer to: https://auth0.com/docs/libraries/auth0js/v7#delegation-token-request\n```\n\n### POST /delegation\n\nA delegation token can be obtained and used when an application needs to call the API of an Application Addon, such as Firebase or SAP, registered and configured in Auth0, in the same tenant as the calling program.\n\nGiven an existing token, this endpoint will generate a new token signed with the `target` app' secret. This is used to flow the identity of the user from the application to an API.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nΤhe `client_id` of your app\n\n`grant_type`  \nRequired\n\nUse `urn:ietf:params:oauth:grant-type:jwt-bearer`\n\n`id_token` or `refresh_token`  \nRequired\n\nThe existing token of the user.\n\n`target`\n\nThe target `client_id`\n\n`scope`\n\nUse `openid` or `openid profile email`\n\n`api_type`\n\nThe API to be called.\n\n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n    \n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n    \n*   Delegation is **not supported** in version 8 of [auth0.js](https://auth0.com/docs/libraries/auth0js). For a sample in version 7 of the library, refer to [Delegation Token Request](https://auth0.com/docs/libraries/auth0js/v7#delegation-token-request).\n    \n*   This endpoint limits up to 10 requests per minute from the same IP address with the same `user_id`.\n    \n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    \n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n\n### Learn More\n\n*   [Delegation Tokens](https://auth0.com/docs/tokens/delegation)\n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits)\n\n## Impersonation\n\n```\nPOST https://{yourDomain}/users/{user_id}/impersonate\nContent-Type:   application/json\nAuthorization:  'Bearer {ACCESS_TOKEN}'\n{\n  protocol: \"PROTOCOL\",\n  impersonator_id: \"IMPERSONATOR_ID\",\n  client_id: \"{yourClientId}\",\n  additionalParameters: [\n    \"response_type\": \"code\",\n    \"state\": \"STATE\"\n  ]\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/users/{user_id}/impersonate' \\\n  --header 'Authorization: Bearer {ACCESS_TOKEN}' \\\n  --header 'content-type: application/x-www-form-urlencoded; charset=UTF-8' \\\n  --data '{\"protocol\":\"PROTOCOL\", \"impersonator_id\":\"IMPERSONATOR_ID\", \"client_id\":\"{yourClientId}\", \"additionalParameters\": {\"response_type\": \"code\", \"state\": \"STATE\"}}'\n```\n\n```\nvar url = 'https://' + {yourDomain} + '/users/' + localStorage.getItem('user_id') + '/impersonate';\nvar params = 'protocol=PROTOCOL&impersonator_id=IMPERSONATOR_ID&client_id={yourClientId}';\n\nvar xhr = new XMLHttpRequest();\n\nxhr.open('POST', url);\nxhr.setRequestHeader('Content-Type', 'application/json');\nxhr.setRequestHeader('Authorization', 'Bearer ' + localStorage.getItem('access_token'));\n\nxhr.onload = function() {\n  if (xhr.status == 200) {\n    fetchProfile();\n  } else {\n    alert(\"Request failed: \" + xhr.statusText);\n  }\n};\n\nxhr.send(params);\n```\n\n> RESPONSE SAMPLE:\n\n```\nhttps:/YOUR_DOMAIN/users/IMPERSONATOR_ID/impersonate?&bewit=WFh0MUtm...\n```\n\n### POST /users/{user\\_id}/impersonate\n\nUse this endpoint to obtain an impersonation URL to login as another user. Useful for troubleshooting.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`protocol`  \nRequired\n\nThe protocol to use against the identity provider: `oauth2`, `samlp`, `wsfed`, `wsfed-rms`.\n\n`impersonator_id`  \nRequired\n\nThe `user_id` of the impersonator.\n\n`client_id`  \nRequired\n\nThe `client_id` of the client that is generating the impersonation link.\n\n`additionalParameters`\n\nThis is a JSON object. You can use this to set additional parameters, like `response_type`, `scope` and `state`.\n\n*   This endpoint can only be used with **Global Client** credentials.\n    \n*   To distinguish between real logins and impersonation logins, the profile of the impersonated user will contain additional impersonated and impersonator properties. For example: `\"impersonated\": true, \"impersonator\": {\"user_id\": \"auth0|...\", \"email\": \"admin@example.com\"}`.\n    \n*   For a regular web app, you should set the `additionalParameters`: set the `response_type` to be `code`, the `callback_url` to be the callback URL to which Auth0 will redirect with the authorization code, and the `scope` to be the JWT claims that you want included in the JWT.\n    \n\n## Resource Owner\n\n```\nPOST https://{yourDomain}/oauth/ro\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"connection\": \"CONNECTION\",\n  \"grant_type\": \"password\",\n  \"username\": \"USERNAME\",\n  \"password\": \"PASSWORD\",\n  \"scope\": \"SCOPE\",\n  \"id_token\": \"ID_TOKEN\",\n  \"device\": \"DEVICE\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/ro' \\\n  --header 'accept: application/json' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"connection\": \"CONNECTION\", \"grant_type\": \"password\", \"username\": \"USERNAME\", \"password\": \"PASSWORD\", \"scope\": \"SCOPE\", \"id_token\": \"ID_TOKEN\", \"device\": \"DEVICE\" }'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/ro',\n  headers: { 'content-type': 'application/json', 'accept': 'application/json' },\n  body:\n   { connection: 'CONNECTION',\n     grant_type: 'PASSWORD',\n     username: 'USERNAME',\n     client_id: '{yourClientId}',\n     password: 'PASSWORD',\n     scope: 'SCOPE',\n     id_token: 'ID_TOKEN',\n     device: 'DEVICE'},\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"access_token\": \"eyJz93a...\",\n  \"id_token\": \"eyJ0XAi...\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### POST /oauth/ro\n\nGiven the user's credentials, this endpoint will authenticate the user with the provider and return a JSON object with the Access Token and an ID Token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nYour application's Application ID.\n\n`connection`  \nRequired\n\nThe name of the connection configured to your application\n\n`grant_type`  \nRequired\n\nUse the value `password`\n\n`username`  \nRequired\n\nThe user's username\n\n`password`  \nRequired\n\nThe user's password\n\n`scope`\n\nUse `openid` to get an ID Token, `openid profile email` to get an ID Token and the user profile, or `openid offline_access` to get an ID Token and a Refresh Token.\n\n`id_token`\n\nUsed to authenticate using a token instead of username/password, in [Touch ID](https://auth0.com/docs/libraries/lock-ios/touchid-authentication) scenarios.\n\n`device`\n\nYou should set this to a string, if you are requesting a Refresh Token (`scope=offline_access`).\n\n*   This endpoint only works for database connections, passwordless connections, Active Directory/LDAP, Windows Azure AD and ADFS.\n    \n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n    \n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n    \n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /oauth/ro](#post-oauth-ro).\n\n### Learn More\n\n*   [Calling APIs from Highly Trusted Applications](https://auth0.com/docs/api-auth/grant/password)\n\nErrors\n\n## Standard Error Responses\n\nThe Authentication API may return the following HTTP Status Codes:\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_scope\", \"error_description\": \"Scope must be an array or a string\"}`\n\n401 Unauthorized\n\n`{\"error\": \"invalid_client\", \"error_description\": \"...\"}`\n\n401 Unauthorized\n\n`{\"error\": \"requires_validation\", \"error_description\": \"Suspicious request requires verification\"}`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"...\"}`\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"...\"}`\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"Unknown or invalid refresh token\"}`\n\n403 Forbidden\n\n`{\"error\": \"invalid_grant\", \"error_description\": \"...\"}`\n\n404 Not Found\n\n`{\"error\": \"endpoint_disabled\", \"error_description\": \"...\"}`\n\n405 Method Not Allowed\n\n`{\"error\": \"method_not_allowed\", \"error_description\": \"...\"}`\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_requests\", \"error_description\": \"...\"}`\n\n500 Internal Server Error\n\n501 Not Implemented\n\n`{\"error\": \"unsupported_response_type\", \"error_description\": \"...\"}`\n\n501 Not Implemented\n\n`{\"error\": \"unsupported_grant_type\", \"error_description\": \"...\"}`\n\n503 Service Unavailable\n\n`{\"error\": \"temporarily_unavailable\", \"error_description\": \"...\"}`\n\n## POST /oauth/revoke\n\nStatus\n\nJSON Response\n\n200 Success\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}`  \nThe Refresh Token is revoked, does not exist, or was not issued to the client making the revocation request\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}` The required parameters were not sent in the request.\n\n401 Unauthorized\n\n`{\"error\": \"invalid_client\", \"error_description\": \"...\"}`  \nThe request is not authorized. Check that the client credentials `client_id` and client\\_secret\\` are present in the request and hold valid values.\n\n## POST /oauth/access\\_token\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"}`  \nThe connection is not active or not enabled for your `client_id`.\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing client_id parameter\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing access_token parameter\"}`\n\n401 Unauthorized\n\n`{\"error\": \"invalid_request\", \"error_description\": \"invalid access_token: invalid_token\"}`  \nThe `access_token` is invalid or does not contain the set `scope`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"invalid client\"}`\n\n## POST /oauth/ro\n\n## Grant type: jwt-bearer\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing device parameter\"}`  \nYou need to provide a device name for the caller device (like a browser, app, and so on)\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing id_token parameter\"}`  \nFor this grant type you need to provide a JWT ID Token\n\n400 Bad Request\n\n`{\"error\": \"invalid_grant\", \"error_description\": \"...\"}`  \nErrors related to an invalid ID Token or user\n\n## Grant type: password\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"scope parameter must be a string\"}`  \nIncorrect scope formatting; each scope must be separated by whitespace\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"specified strategy does not support requested operation\"}`  \nThe connection/provider does not implement username/password authentication\n\n401 Unauthorized\n\n`{\"error\": \"invalid_user_password\", \"error_description\": \"Wrong email or password.\"}`\n\n401 Unauthorized\n\n`{\"error\": \"unauthorized\", \"error_description\": \"user is blocked\"}`\n\n401 Unauthorized\n\n`{ \"error\": \"password_leaked\", \"error_description\": \"This login has been blocked because your password has been leaked in another website. We’ve sent you an email with instructions on how to unblock it.\"}`\n\n401 Unauthorized\n\n`{ \"error\": \"requires_verification\", \"error_description\": \"Suspicious request requires verification\" }`\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_attempts\", \"error_description\": \"...\"}`  \nSome attack protection features will return this error\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_logins\", \"error_description\": \"...\"}`  \nSome attack protection features will return this error\n\n## All grant types\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing client_id parameter\"}<`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"}`  \nCheck the connection in the dashboard, you may have turned it off for the provided `client_id`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"The connection is not yet configured...\"}`  \nThe connection is not properly configured with custom scripts\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found for tenant...\"}`  \nThe connection does not belong to the tenant; check your base url\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"Fields with \".\" are not allowed, please remove all dotted fields...\"}`  \nIf you are using rules, some field name contains dots\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"invalid client\"}`  \nThe provided `client_id` is not valid\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"...\"}`  \nValidation of specific points raised an access issue\n\n## POST /passwordless/start\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - tenant validation failed: invalid_tenant\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.client_id\", \"error_description\": \"Missing required property: client_id\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Missing required property: connection\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Connection does not exist\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Connection is disabled\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Invalid connection strategy. It must either be a passwordless connection\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.authParams\", \"error_description\": \"error in authParams - invalid type: string (expected object)\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.request\", \"error_description\": \"the following properties are not allowed: <INVALID_PARAMETER_VALUE>\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.phone_number\", \"error_description\": \"Missing required property: phone_number\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.phone_number\", \"error_description\": \"String does not match pattern: ^\\\\+[0-9]{1,15}$\"}`\n\n400 Bad Request\n\n`{\"error\": \"sms_provider_error\", \"error_description\": \"<SPECIFIC_PROVIDER_MESSAGE> (Code: <SPECIFIC_PROVIDER_CODE>)\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\",\"error_description\": \"Expected` auth0-forwarded-for `header to be a valid IP address.\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - could not find tenant in params\"}`\n\n400 Bad Request\n\n`{\"error\": \"server_error\",\"error_description\": \"error resolving client\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\",\"error_description\": \"The client_id in the authentication header does not match the client_id in the payload\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Public signup is disabled\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Unknown error\"}`\n\n401 Unauthorized\n\n`{\"error\": \"server_error\",\"error_description\": \"user is blocked\"}`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\",\"error_description\": \"Client authentication is required\"}`\n\n500 Internal Server Error\n\n`{\"error\": \"server_error\",\"error_description\": \"IdP Error\"}`\n\n## POST /passwordless/verify\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing username parameter\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"scope parameter must be a string\"}`  \nIncorrect scope formatting; each scope must be separated by whitespace\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing client_id parameter\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"}`  \nCheck the connection in the dashboard, you may have turned it off for the provided `client_id`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found for tenant...\"}`  \nThe connection does not belong to the tenant; check your base url\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"Fields with \".\" are not allowed, please remove all dotted fields...\"}`  \nIf you are using rules, some field name contains dots\n\n400 Bad Request\n\n`\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - could not find tenant in params\"`\n\n400 Bad Request\n\n`{\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - tenant validation failed: \"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Connection does not exist\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Invalid connection strategy. It must either be a passwordless connection\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"The connection is disabled\"}`\n\n401 Unauthorized\n\n`{\"error\": \"invalid_user_password\", \"error_description\": \"Wrong email or password.\"}`\n\n401 Unauthorized\n\n`{\"error\": \"unauthorized\", \"error_description\": \"user is blocked\"}`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"invalid client\"}`  \nThe provided `client_id` is not valid\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"...\"}`  \nValidation of specific points raised an access issue\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_attempts\", \"error_description\": \"...\"}`  \nSome attack protection features will return this error\n\n500 Bad Request\n\n`{\"error\": \"server_error\",\"error_description\": \"...\"}`",
    "title": "Authentication API Explorer",
    "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/api/authentication",
    "markdown": "# Authentication API Explorer\n\n## Introduction\n\nThe Authentication API enables you to manage all aspects of user identity when you use Auth0. It offers endpoints so your users can log in, sign up, log out, access APIs, and more.\n\nThe API supports various identity protocols, like [OpenID Connect](https://auth0.com/docs/protocols/oidc), [OAuth 2.0](https://auth0.com/docs/protocols/oauth2), [FAPI](https://auth0.com/docs/secure/highly-regulated-identity#advanced-security-with-openid-connect-fapi-) and [SAML](https://auth0.com/docs/protocols/saml).\n\n## Base URL\n\nThe Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base: `https://{yourDomain}`\n\n## Authentication methods\n\nYou have five options for authenticating with this API:\n\n*   OAuth2 Access Token\n*   Client ID and Client Assertion (confidential applications)\n*   Client ID and Client Secret (confidential applications)\n*   Client ID (public applications)\n*   mTLS Authentication (confidential applications)\n\n### OAuth2 Access Token\n\nSend a valid Access Token in the `Authorization` header, using the `Bearer` authentication scheme.\n\nAn example is the [Get User Info endpoint](#get-user-info). In this scenario, you get an Access Token when you authenticate a user, and then you can make a request to the [Get User Info endpoint](#get-user-info), using that token in the `Authorization` header, in order to retrieve the user's profile.\n\n### Client ID and Client Assertion\n\nGenerate a [client assertion](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) containing a signed JSON Web Token (JWT) to authenticate. In the body of the request, include your Client ID, a `client_assertion_type` parameter with the value `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`, and a `client_assertion` parameter with your signed assertion. Review [Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) for examples.\n\n### Client ID and Client Secret\n\nSend the Client ID and Client Secret. The method you can use to send this data is determined by the [Token Endpoint Authentication Method](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/view-application-type) configured for your application.\n\nIf you are using **Post**, you must send this data in the JSON body of your request.\n\nIf you are using **Basic**, you must send this data in the `Authorization` header, using the `Basic` authentication scheme. To generate your credential value, concatenate your Client ID and Client Secret, separated by a colon (`:`), and encode it in Base64.\n\nAn example is the [Revoke Refresh Token endpoint](#revoke-refresh-token). This option is available only for confidential applications (such as applications that are able to hold credentials in a secure way without exposing them to unauthorized parties).\n\n### Client ID\n\nSend the Client ID. For public applications (applications that cannot hold credentials securely, such as SPAs or mobile apps), we offer some endpoints that can be accessed using only the Client ID.\n\nAn example is the [Implicit Grant](#implicit-flow).\n\n### mTLS Authentication\n\nGenerate a certificate, either [self-signed](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#self-signed-certificates) or [certificate authority signed](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#certificate-authority-signed-certificates). Then, [set up the customer edge network](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge) that performs the mTLS handshake.\n\nOnce your edge network verifies the certificate, forward the request to the Auth0 edge network with the following headers:\n\n*   The Custom Domain API key as the `cname-api-key` header.\n*   The client certificate as the `client-certificate` header.\n*   The client certificate CA verification status as the `client-certificate-ca-verified` header. For more information, see [Forward the Request](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge#forward-the-request-).\n\nTo learn more, read [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls).\n\n## Parameters\n\nFor GET requests, any parameters not specified as a segment in the path can be passed as an HTTP query string parameter:\n\n`GET https://{yourDomain}/some-endpoint?param=value&param=value`\n\nFor POST requests, parameters not included in the URL should be encoded as JSON with a Content-Type of `application/json`:\n\n`curl --request POST --url 'https://{yourDomain}/some-endpoint' --header 'content-type: application/json' --data '{\"param\": \"value\", \"param\": \"value\"}'`\n\n## Code samples\n\nFor each endpoint, you will find sample snippets you can use, in three available formats:\n\n*   HTTP request\n*   Curl command\n*   JavaScript: depending on the endpoint each snippet may use the [Auth0.js library](https://auth0.com/docs/libraries/auth0js), Node.js code or simple JavaScript\n\nEach request should be sent with a Content-Type of `application/json`.\n\n## Testing\n\nYou can test the endpoints using the [Authentication API Debugger](https://auth0.com/docs/extensions/authentication-api-debugger).\n\n### Authentication API Debugger\n\nThe [Authentication API Debugger](https://auth0.com/docs/extensions/authentication-api-debugger) is an Auth0 extension you can use to test several endpoints of the Authentication API.\n\nClick on **Install Debugger** to go to the article that explains how (you only have to do this once).\n\n**If you have already installed the extension, skip to the Authentication API Debugger.**\n\nThe link varies according to your tenant's region: [US West](https://{yourtenant}.us.webtask.io/auth0-authentication-api-debugger), [Europe Central](https://{yourtenant}.eu.webtask.io/auth0-authentication-api-debugger) or [Australia](https://{yourtenant}.au.webtask.io/auth0-authentication-api-debugger).\n\n### Configure Connections\n\n1.  On the _Configuration_ tab, set the fields **Application** (select the application you want to use for the test) and **Connection** (the name of the social connection to use).\n    \n2.  Copy the **Callback URL** and set it as part of the **Allowed Callback URLs** of your [Application Settings](https://manage.auth0.com/#/applications).\n    \n3.  At the _OAuth2 / OIDC_ tab, select **OAuth2 / OIDC Login**.\n    \n\n### Endpoint options\n\nConfigure other endpoints with the following options:\n\n*   Passwordless: On the _OAuth2 / OIDC_ tab, set **Username** to the user's phone number if `connection=sms`, or the user's email if `connection=email`, and **Password** to the user's verification code. Click **Resource Owner Endpoint**.\n*   SAML SSO: On the _Other Flows_ tab, select **SAML**.\n*   WS-Federation: On the _Other Flows_ tab, select **WS-Federation**.\n*   Logout: On the _Other Flows_ tab, select **Logout**, or **Logout (Federated)** to log the user out of the identity provider as well.\n*   Legacy Login: On the _OAuth2 / OIDC_ tab, set the fields **ID Token**, **Refresh Token** and **Target Client ID**. Click **Delegation**.\n*   Legacy Delegation: On the _OAuth2 / OIDC_ tab, set **Username** and **Password**. Click **Resource Owner Endpoint**.\n*   Legacy Resource Owner: On the _OAuth2 / OIDC_ tab, set the **Username** and **Password**, then select **Resource Owner Endpoint**.\n\n### Authentications flows\n\nConfigure authentication flows with the following options:\n\n*   Authorization Code Flow: On the _OAuth2 / OIDC_ tab, set the field **Authorization Code** to the code you retrieved from [Authorization Code Grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), and the **Code Verifier** to the key. Click **OAuth2 Code Exchange**.\n*   Authorization Code Flow + PKCE: On the _OAuth2 / OIDC_ tab, set the field **Authorization Code** to the code you retrieved from [Authorization Code Grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce), and the **Code Verifier** to the key. Click **OAuth2 Code Exchange**.\n*   Client Credential Flow: On the _OAuth2 / OIDC_ tab, select **OAuth2 Client Credentials**.\n\n## Errors\n\nWhen an error occurs, you will receive an error object. Most of these error objects contain an error code and an error description so that your applications can more efficiently identify the problem.\n\nIf you get an `4xx` HTTP response code, then you can assume that there is a bad request from your end. In this case, check the [Standard Error Responses](#standard-error-responses) for more context.\n\n`5xx` errors suggest a problem on Auth0's end, so in this case, check [Auth0 Status Page](https://status.auth0.com/) and [@auth0status on Twitter](https://twitter.com/auth0status) to see how our systems are doing.\n\nIn any other case you can use [our support options](#support).\n\n## Rate limiting\n\nThe Authentication API is subject to rate limiting. The limits differ per endpoint.\n\nIf you exceed the provided rate limit for a given endpoint, you will receive the `429 Too Many Requests` response with the following message: `Too many requests. Check the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers.`\n\nFor details on rate limiting, refer to [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits).\n\nNote that for database connections Auth0 limits certain types of repeat login attempts depending on the user account and IP address. For details, refer to [Rate Limits on User/Password Authentication](https://auth0.com/docs/policies/rate-limit-policy/database-connections-rate-limits).\n\n## Support\n\nIf you have problems or need help with your case, you can always reach out to our [Support](https://support.auth0.com/).\n\nNote that if you have a free subscription plan, and you are not in your 22-day trial period, you will not be able to access or open tickets in the [Support Center](https://support.auth0.com/). In this case, you can seek support through the [Auth0 Community](https://community.auth0.com/). For more info on our support program, refer to [Support Options](https://auth0.com/docs/support).\n\n## Login\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE&\n  ADDITIONAL_PARAMETERS\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize app\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Trigger login with google\n  webAuth.authorize({\n    connection: 'google-oauth2'\n  });\n\n  // Trigger login with github\n  webAuth.authorize({\n    connection: 'github'\n  });\n\n  // Trigger login popup with twitter\n  webAuth.popup.authorize({\n    connection: 'twitter'\n  });\n</script>\n```\n\nYou can connect your Auth0 service to a social identity provider and allow your users to log in to your application via Facebook, Google, Apple, or other supported providers. To learn more about supported providers, visit [Marketplace](https://marketplace.auth0.com/features/social-connections).\n\nTo authenticate users with a social provider, make a `GET` call to the `/authorize` endpoint. It will return a `302` redirect to the social provider specified in the `connection` parameter.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nSpecifies the token type. Use `code` for server side flows and `token` for application side flows\n\n`client_id`  \nRequired\n\nThe `client_id` of your application\n\n`connection`\n\nThe name of a social identity provider configured to your application, for example `google-oauth2` or `facebook`. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`state`  \nRecommended\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`ADDITIONAL_PARAMETERS`\n\nAppend any additional parameter to the end of your request, and it will be sent to the provider. For example, `access_type=offline` (for Google Refresh Tokens) , `display=popup` (for Windows Live popup mode).\n\n*   If `response_type=token`, after the user authenticates on the provider, it will redirect to your application `callback URL` passing the Access Token and ID Token in the address `location.hash`. This is used for Single-Page Apps and also on Native Mobile SDKs.\n    \n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n    \n\n### Learn More\n\n*   [Supported Social Identity Providers](https://marketplace.auth0.com/features/social-connections)\n*   [Custom Social Connections](https://auth0.com/docs/connections/social/oauth2)\n*   [State Parameter](https://auth0.com/docs/secure/attack-protection/state-parameters)\n*   [Auth0.js /authorize Method Reference](https://auth0.com/docs/libraries/auth0js#webauth-authorize-)\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  scope=openid%20profile%20email&\n  state=STATE\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize app\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Calculate URL to redirect to\n  var url = webAuth.client.buildAuthorizeUrl({\n    clientID: '{yourClientId}', // string\n    responseType: 'token', // code or token\n    redirectUri: '{https://yourApp/callback}',\n    scope: 'openid profile email'\n    state: 'YOUR_STATE'\n  });\n\n  // Redirect to url\n  // ...\n</script>\n```\n\nUse the Auth0 user store or your own database to store and manage username and password credentials. If you have your own user database, you can use it as an identity provider in Auth0 to authenticate users. When you make a `GET` call to the `/authorize` endpoint for browser based (passive) authentication. It returns a `302` redirect to the [Auth0 Login Page](https://{yourdomain}/login) that will show the Login Widget where the user can log in with email and password.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nSpecifies the token type. Use `code` for server side flows and `token` for application side flows.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget using the first database connection.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`scope`  \nRecommended\n\nOIDC scopes and custom API scopes. For example: `openid read:timesheets`. Include `offline_access` to get a Refresh Token.\n\n`state`  \nRecommended\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n*   If `response_type=token`, after the user authenticates, it will redirect to your application `callback URL` passing the Access Token and ID Token in the address `location.hash`. This is used for Single-Page Apps and also on Native Mobile SDKs.\n*   The main difference between passive and active authentication is that the former happens in the browser through the [Auth0 Login Page](https://{yourdomain}/login) and the latter can be invoked from anywhere (a script, server to server, and so forth).\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [Database Identity Providers](https://auth0.com/docs/connections/database)\n*   [Rate Limits on User/Password Authentication](https://auth0.com/docs/policies/rate-limit-policy/database-connections-rate-limits)\n*   [Active Directory/LDAP Connector](https://auth0.com/docs/connector)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Auth0.js /authorize Method Reference](https://auth0.com/docs/libraries/auth0js#webauth-authorize-)\n\n## Enterprise (SAML and Others)\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Calculate URL to redirect to\n  var url = webAuth.client.buildAuthorizeUrl({\n    clientID: 'YOUR_CLIENT_ID', // string\n    responseType: 'token', // code or token\n    redirectUri: 'https://YOUR_APP/callback',\n    scope: 'openid profile email'\n    state: 'YOUR_STATE'\n  });\n\n  // Redirect to url\n  // ...\n</script>\n```\n\nYou can connect your Auth0 service to an enterprise identity provider and allow your users to log in to your application via Microsoft Azure Active Directory, Google Workspace, Okta Workforce, or other supported providers. To learn more about supported providers, visit [Auth0 Marketplace](https://marketplace.auth0.com/features/enterprise-connections).\n\nMake a `GET` call to the `/authorize` endpoint for passive authentication. It returns a `302` redirect to the SAML Provider (or Windows Azure AD and the rest, as specified in the `connection`) to enter their credentials.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nSpecifies the token type. Use `code` for server side flows, `token` for application side flows.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget using the first database connection.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`state`  \nRecommended\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n*   If no `connection` is specified, it will redirect to the [Login Page](https://{yourdomain}/login) and show the Login Widget.\n*   If `response_type=token`, after the user authenticates, it will redirect to your application `callback URL` passing the Access Token and ID Token in the address `location.hash`. This is used for Single-Page Apps and also on Native Mobile SDKs.\n*   Additional parameters can be sent that will be passed to the provider.\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n*   [Obtain a Client Id and Client Secret for Microsoft Azure Active Directory](https://auth0.com/docs/connections/enterprise/azure-active-directory)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Auth0.js /authorize Method Reference](https://auth0.com/docs/libraries/auth0js#webauth-authorize-)\n\n## Logout\n\n## Auth0 Logout\n\n### GET /v2/logout\n\n```\nGET https://{yourDomain}/v2/logout?\n  client_id={yourClientId}&\n  returnTo=LOGOUT_URL\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/v2/logout' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"returnTo\":\"LOGOUT_URL\"}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.logout({\n    returnTo: 'YOUR_LOGOUT_URL',\n    client_id: '{yourClientId}'\n  });\n</script>\n```\n\nUse this endpoint to logout a user. If you want to navigate the user to a specific URL after the logout, set that URL at the `returnTo` parameter. The URL should be included in any the appropriate `Allowed Logout URLs` list:\n\n*   If the `client_id` parameter is included, the `returnTo` URL must be listed in the `Allowed Logout URLs` set at the application level. To learn more, read [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications).\n*   If the `client_id` parameter is NOT included, the `returnTo` URL must be listed in the `Allowed Logout URLs` set at the tenant level. To learn more, read [Log Users Out of Auth0](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0).\n*   If the `client_id` parameter is included and the `returnTo` URL is NOT set, the server returns the user to the first Allowed Logout URLs set in the Dashboard. To learn more, read [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`returnTo`\n\nURL to redirect the user after the logout.\n\n`client_id`\n\nThe `client_id` of your application.\n\n`federated`\n\nAdd this query string parameter to the logout URL, to log the user out of their identity provider, as well: `https://{yourDomain}/v2/logout?federated`.\n\n*   Logging the user out of their identity provider is not common practice, so think about the user experience before you use the `federated` query string parameter.\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [Logout](https://auth0.com/docs/logout)\n\n## OIDC Logout\n\n### GET /oidc/logout\n\n```\nGET https://{yourDomain}/oidc/logout?\n  post_logout_redirect_uri=LOGOUT_URL&\n  id_token_hint=ID_TOKEN_HINT\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/oidc/logout' \\\n  --header 'content-type: application/json' \\\n  --data-raw '\n  { \n    \"client_id\":\"{yourClientId}\", \n    \"post_logout_redirect_uri\":\"LOGOUT_URL\", \n    \"id_token_hint\":\"ID_TOKEN_HINT\"\n  }'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.logout({\n    post_logout_redirect_uri: 'YOUR_LOGOUT_URL',\n    id_token_hint: 'YOUR_ID_TOKEN_HINT'\n  });\n</script>\n```\n\nUse this endpoint to logout a user. If you want to navigate the user to a specific URL after the logout, set that URL at the `post_logout_redirect_uri` parameter. The URL should be included in the appropriate `Allowed Logout URLs` list:\n\n*   If the `id_token_hint` parameter is included:\n    \n    *   When the `client_id` parameter is included, the server uses the URL from the `aud` claim in the `id_token_hint` to select which of the `Allowed Logout URLs` to use from the application specified by the `client_id`.\n    *   When the `client_id` parameter is NOT included, the server uses the URL from the `aud` claim in the `id_token_hint` to select which of the `Allowed Logout URLs` at the tenant level to use.\n*   If the `id_token_hint` parameter is not included:\n    \n    *   If the `client_id` parameter is included, the `post_logout_redirect_uri` URL must be listed in the `Allowed Logout URLs` set at the application level.\n    *   If the `client_id` parameter is NOT included, the `post_logout_redirect_uri` URL must be listed in the `Allowed Logout URLs` set at the tenant level.\n    *   If the `client_id` parameter is included and the `post_logout_redirect_uri` URL is NOT set, the server returns the user to the first `Allowed Logout URLs` set in Auth0 Dashboard.\n    \n    To learn more, read [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0).\n    \n\n### Request Parameters\n\nParameter\n\nDescription\n\n`id_token_hint` (Recommended)\n\nPreviously issued ID Token for the user. This is used to indicate which user to log out.\n\n`logout_hint` (Optional)\n\nOptional `sid` (session ID) value to indicate which user to log out. Should be provided when `id_token_hint` is not available.\n\n`post_logout_redirect_uri` (Optional)\n\nURL to redirect the user after the logout.\n\n`client_id` (Optional)\n\nThe `client_id` of your application.\n\n`federated` (Optional)\n\nAdd this query string parameter to log the user out of their identity provider: `https://YOUR_DOMAIN/oidc/logout?federated`.\n\n`state` (Optional)\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the`post_logout_redirect_uri`.\n\n`ui_locales` (Optional)\n\nSpace-delimited list of locales used to constrain the language list for the request. The first locale on the list must match the enabled locale in your tenant\n\n*   Logging the user out of their social identity provider is not common practice, so think about the user experience before you use the `federated` query string parameter with social identity providers.\n*   If providing both `id_token_hint` and `logout_hint`, the `logout_hint` value must match the `sid` claim from the id\\_token\\_hint.\n*   If providing both `id_token_hint` and `client_id`, the `client_id` value must match the `aud` claim from the `id_token_hint`.\n*   If `id_token_hint` is not provided, then the user will be prompted for consent unless a `logout_hint` that matches the user's session ID is provided.\n*   The `POST` HTTP method is also supported for this request. When using `POST`, the request parameters should be provided in the request body as form parameters instead of the query string. The federated parameter requires a value of `true` or `false`.\n*   This conforms to the [OIDC RP-initiated Logout Specification](https://openid.net/specs/openid-connect-rpinitiated-1_0.html).\n\n### Learn More\n\n*   [Logout](https://auth0.com/docs/logout)\n*   [Use the OIDC Endpoint to Log Users Out of Auth0](https://auth0.com/docs/logout/log-users-out-of-auth0)\n*   [OIDC RP-initiated Logout Specification](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)\n\n## SAML Logout\n\n```\nPOST https://{yourDomain}/samlp/CLIENT_ID/logout\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/samlp/CLIENT_ID/logout' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data '{SAML_LOGOUT_REQUEST}'\n```\n\nUse this endpoint to log out a user from an Auth0 tenant configured as a SAML identity provider (IdP).\n\nLogout behavior is determined by the configuration of the SAML2 Web App addon for the application on the Auth0 tenant acting as the SAML IdP. To learn more, read [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps#configure-slo-when-auth0-is-the-saml-idp).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`CLIENT_ID`\n\nClient ID of your application configured with the [SAML2 Web App addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon).\n\n`SAML_LOGOUT_REQUEST`\n\nSAML `<LogoutRequest>` message.\n\n*   The POST body must contain a valid SAML `<LogoutRequest>` message. To learn more, read [Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0 on Oasis](https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf).\n\n### Learn More\n\n*   [Logout](https://auth0.com/docs/logout)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n\n## Passwordless\n\nPasswordless connections do not require the user to remember a password. Instead, another mechanism is used to prove identity, such as a one-time code sent through email or SMS, every time the user logs in.\n\n## Get Code or Link\n\n```\nPOST https://{yourDomain}/passwordless/start\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\", // for web applications\n  \"connection\": \"email|sms\",\n  \"email\": \"USER_EMAIL\", //set for connection=email\n  \"phone_number\": \"USER_PHONE_NUMBER\", //set for connection=sms\n  \"send\": \"link|code\", //if left null defaults to link\n  \"authParams\": { // any authentication parameters that you would like to add\n    \"scope\": \"openid\",\n    \"state\": \"YOUR_STATE\"\n  }\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"connection\":\"email|sms\", \"email\":\"USER_EMAIL\", \"phone_number\":\"USER_PHONE_NUMBER\", \"send\":\"link|code\", \"authParams\":{\"scope\": \"openid\",\"state\": \"YOUR_STATE\"}}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Send a verification code using email\n  webAuth.passwordlessStart({\n      connection: 'email',\n      send: 'code',\n      email: 'USER_EMAIL'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Send a link using email\n  webAuth.passwordlessStart({\n      connection: 'email',\n      send: 'link',\n      email: 'USER_EMAIL'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Send a verification code using SMS\n  webAuth.passwordlessStart({\n      connection: 'sms',\n      send: 'code',\n      phoneNumber: 'USER_PHONE_NUMBER'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n</script>\n```\n\n### POST /passwordless/start\n\nYou have three options for [passwordless authentication](https://auth0.com/docs/connections/passwordless):\n\n*   Send a verification code using email.\n*   Send a link using email.\n*   Send a verification code using SMS.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`client_assertion`  \n\nA JWT containing containing a signed assertion with your applications credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nUse the value `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nThe `client_secret` of your application. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`. Specifically required for Regular Web Applications **only**.\n\n`connection`  \nRequired\n\nHow to send the code/link to the user. Use `email` to send the code/link using email, or `sms` to use SMS.\n\n`email`\n\nSet this to the user's email address, when `connection=email`.\n\n`phone_number`\n\nSet this to the user's phone number, when `connection=sms`.\n\n`send`\n\nUse `link` to send a link or `code` to send a verification code. If null, a link will be sent.\n\n`authParams`\n\nUse this to append or override the link parameters (like `scope`, `redirect_uri`, `protocol`, `response_type`), when you send a link using email.\n\n*   If you sent a verification code, using either email or SMS, after you get the code, you have to authenticate the user using the [/passwordless/verify endpoint](#authenticate-user), using `email` or `phone_number` as the `username`, and the verification code as the `password`.\n*   This endpoint is designed to be called from the client-side, and is subject to [rate limits](https://auth0.com/docs/policies/rate-limit-policy/authentication-api-endpoint-rate-limits).\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /passwordless/start](#post-passwordless-start).\n\n### Learn More\n\n*   [Passwordless Authentication](https://auth0.com/docs/connections/passwordless)\n*   [Passwordless Best Practices](https://auth0.com/docs/connections/passwordless/best-practices)\n\n## Authenticate User\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/json\n{\n  \"grant_type\" : \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\", // for web applications\n  \"otp\": \"CODE\",\n  \"realm\": \"email|sms\" //email or sms\n  \"username\":\"USER_EMAIL|USER_PHONE_NUMBER\", // depends on which realm you chose\n  \"audience\" : \"API_IDENTIFIER\", // in case you need an access token for a specific API\n  \"scope\": \"SCOPE\",\n  \"redirect_uri\": \"REDIRECT_URI\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"grant_type\":\"http://auth0.com/oauth/grant-type/passwordless/otp\", \"client_id\":\"{yourClientId}\", \"client_secret\":\"CLIENT_SECRET\", \"otp\":\"CODE\", \"realm\":\"email|sms\", \"username\":\"USER_EMAIL|USER_PHONE_NUMBER\", \"audience\":\"API_IDENTIFIER\", \"scope\":\"SCOPE\", \"redirect_uri\": \"REDIRECT_URI\"}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Verify code sent via email\n  webAuth.passwordlessLogin({\n      connection: 'email',\n      email: 'USER_EMAIL',\n      verificationCode: 'VERIFICATION_CODE_SENT'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Verify code sent within link using email\n  webAuth.passwordlessLogin({\n      connection: 'email',\n      email: 'USER_EMAIL',\n      verificationCode: 'VERIFICATION_CODE_SENT_WITHIN_LINK'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Verify code sent via SMS\n  webAuth.passwordlessLogin({\n      connection: 'sms',\n      phoneNumber: 'USER_PHONE_NUMBER',\n      verificationCode: 'VERIFICATION_CODE_SENT'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n</script>\n```\n\n### POST /oauth/token\n\nOnce you have a verification code, use this endpoint to login the user with their phone number/email and verification code.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nIt should be `http://auth0.com/oauth/grant-type/passwordless/otp`.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nThe `client_secret` of your application. Required\\*\\* when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`. Specifically required for Regular Web Applications **only**.\n\n`username`  \nRequired\n\nThe user's phone number if `realm=sms`, or the user's email if `realm=email`.\n\n`realm`  \nRequired\n\nUse `sms` or `email` (should be the same as [POST /passwordless/start](#get-code-or-link))\n\n`otp`  \nRequired\n\nThe user's verification code.\n\n`audience`\n\nAPI Identifier of the API for which you want to get an Access Token.\n\n`scope`\n\nUse `openid` to get an ID Token, or `openid profile email` to also include user profile information in the ID Token.\n\n`redirect_uri`  \nRequired\n\nA callback URL that has been registered with your application's **Allowed Callback URLs**.\n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Standard Error Responses](#standard-error-responses).\n\n### Learn More\n\n*   [Passwordless Authentication](https://auth0.com/docs/connections/passwordless)\n\n### POST /passwordless/verify\n\nOnce you have a verification code, use this endpoint to login the user with their phone number/email and verification code. This is active authentication, so the user must enter the code in your app.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`connection`  \nRequired\n\nUse `sms` or `email` (should be the same as [POST /passwordless/start](#get-code-or-link))\n\n`grant_type`  \nRequired\n\nUse `password`\n\n`username`  \nRequired\n\nThe user's phone number if `connection=sms`, or the user's email if `connection=email`.\n\n`password`  \nRequired\n\nThe user's verification code.\n\n`scope`\n\nUse `openid` to get an ID Token, or `openid profile email` to include also user profile information in the ID Token.\n\n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /passwordless/verify](#post-passwordless-verify).\n\n### Learn More\n\n*   [Passwordless Best Practices](https://auth0.com/docs/connections/passwordless/best-practices)\n\n## Signup\n\n```\nPOST https://{yourDomain}/dbconnections/signup\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"email\": \"EMAIL\",\n  \"password\": \"PASSWORD\",\n  \"connection\": \"CONNECTION\",\n  \"username\": \"johndoe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"name\": \"John Doe\",\n  \"nickname\": \"johnny\",\n  \"picture\": \"http://example.org/jdoe.png\"\n  \"user_metadata\": { plan: 'silver', team_id: 'a111' }\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/dbconnections/signup' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"email\":\"test.account@signup.com\", \"password\":\"PASSWORD\", \"connection\":\"CONNECTION\", \"username\": \"johndoe\", \"given_name\": \"John\", \"family_name\": \"Doe\", \"name\": \"John Doe\", \"nickname\": \"johnny\", \"picture\": \"http://example.org/jdoe.png\", \"user_metadata\":{ \"plan\": \"silver\", \"team_id\": \"a111\" }}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize client\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.signup({ \n    connection: 'CONNECTION', \n    email: 'EMAIL', \n    password: 'PASSWORD',\n    username: \"johndoe\",\n    given_name: \"John\",\n    family_name: \"Doe\",\n    name: \"John Doe\",\n    nickname: \"johnny\",\n    picture: \"http://example.org/jdoe.png\",\n    user_metadata: { plan: 'silver', team_id: 'a111' }\n  }, function (err) { \n    if (err) return alert('Something went wrong: ' + err.message); \n      return alert('success signup without login!') \n  });\n</script>\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"_id\": \"58457fe6b27...\",\n  \"email_verified\": false,\n  \"email\": \"test.account@signup.com\",\n  \"username\": \"johndoe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"name\": \"John Doe\",\n  \"nickname\": \"johnny\",\n  \"picture\": \"http://example.org/jdoe.png\"\n}\n```\n\n### POST /dbconnections/signup\n\nGiven a user's credentials and a `connection`, this endpoint creates a new user.\n\nThis endpoint only works for database connections.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your client.\n\n`email`  \nRequired\n\nThe user's email address.\n\n`password`  \nRequired\n\nThe user's desired password.\n\n`connection`  \nRequired\n\nThe name of the database configured to your client.\n\n`username`\n\nThe user's username. Only valid if the connection requires a username.\n\n`given_name`\n\nThe user's given name(s).\n\n`family_name`\n\nThe user's family name(s).\n\n`name`\n\nThe user's full name.\n\n`nickname`\n\nThe user's nickname.\n\n`picture`\n\nA URI pointing to the user's picture.\n\n`user_metadata`\n\nThe [user metadata](https://auth0.com/docs/users/concepts/overview-user-metadata) to be associated with the user. If set, the field must be an object containing no more than ten properties. Property names can have a maximum of 100 characters, and property values must be strings of no more than 500 characters.\n\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [Password Strength in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-strength)\n*   [Password Options in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-options)\n*   [Adding Username for Database Connections](https://auth0.com/docs/connections/database/require-username)\n*   [Metadata Overview](https://auth0.com/docs/users/concepts/overview-user-metadata)\n\n## Change Password\n\n```\nPOST https://{yourDomain}/dbconnections/change_password\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"email\": \"EMAIL\",\n  \"connection\": \"CONNECTION\",\n  \"organization\": \"ORGANIZATION_ID\"\n}\n```\n\n```\ncurl --request POST \\\n  --url https://{yourDomain}/dbconnections/change_password \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\",\"email\": \"EMAIL\", \"connection\": \"CONNECTION\", \"organization\": \"ORGANIZATION_ID\"}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.changePassword({\n    connection: 'CONNECTION',\n    email:   'EMAIL',\n    organization: 'ORGANIZATION_ID'\n  }, function (err, resp) {\n    if(err){\n      console.log(err.message);\n    }else{\n      console.log(resp);\n    }\n  });\n</script>\n```\n\n### POST /dbconnections/change\\_password\n\n> RESPONSE SAMPLE:\n\n```\n\"We've just sent you an email to reset your password.\"\n```\n\nSend a change password email to the user's provided email address and `connection`.\n\nOptionally, you may provide an Organization ID to support Organization-specific variables in [customized email templates](https://auth0.com/docs/customize/email/email-templates#common-variables) and to include the `organization_id` and `organization_name` parameters in the **Redirect To** URL.\n\nNote: This endpoint only works for database connections.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`\n\nThe `client_id` of your client. We strongly recommend including a Client ID so that the email template knows from which client the request was triggered.\n\n`email`  \nRequired\n\nThe user's email address.\n\n`connection`  \nRequired\n\nThe name of the database connection configured to your client.\n\n`organization`\n\nThe `organization_id` of the Organization associated with the user.\n\n*   When the user clicks on the password change link they will be redirected to a page asking them for a new password.\n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n\n### Learn More\n\n*   [Changing a User's Password](https://auth0.com/docs/connections/database/password-change)\n*   [Password Strength in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-strength)\n*   [Password Options in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-options)\n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations)\n\n## User Profile\n\n## Get User Info\n\n```\nGET https://{yourDomain}/userinfo\nAuthorization: 'Bearer {ACCESS_TOKEN}'\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/userinfo' \\\n  --header 'Authorization: Bearer {ACCESS_TOKEN}' \\\n  --header 'Content-Type: application/json'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize the Auth0 application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Parse the URL and extract the Access Token\n  webAuth.parseHash(window.location.hash, function(err, authResult) {\n    if (err) {\n      return console.log(err);\n    }\n    webAuth.client.userInfo(authResult.accessToken, function(err, user) {\n        // This method will make a request to the /userinfo endpoint\n        // and return the user object, which contains the user's information,\n        // similar to the response below.\n    });\n  });\n</script>\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"sub\": \"248289761001\",\n  \"name\": \"Jane Josephine Doe\",\n  \"given_name\": \"Jane\",\n  \"family_name\": \"Doe\",\n  \"middle_name\": \"Josephine\",\n  \"nickname\": \"JJ\",\n  \"preferred_username\": \"j.doe\",\n  \"profile\": \"http://exampleco.com/janedoe\",\n  \"picture\": \"http://exampleco.com/janedoe/me.jpg\",\n  \"website\": \"http://exampleco.com\",\n  \"email\": \"janedoe@exampleco.com\",\n  \"email_verified\": true,\n  \"gender\": \"female\",\n  \"birthdate\": \"1972-03-31\",\n  \"zoneinfo\": \"America/Los_Angeles\",\n  \"locale\": \"en-US\",\n  \"phone_number\": \"+1 (111) 222-3434\",\n  \"phone_number_verified\": false,\n  \"address\": {\n    \"country\": \"us\"\n  },\n  \"updated_at\": \"1556845729\"\n}\n```\n\n### GET /userinfo\n\nGiven the Auth0 Access Token obtained during login, this endpoint returns a user's profile.\n\nThis endpoint will work only if `openid` was granted as a scope for the Access Token. The user profile information included in the response depends on the scopes requested. For example, a scope of just `openid` may return less information than a a scope of `openid profile email`.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`access_token`  \nRequired\n\nThe Auth0 Access Token obtained during login.\n\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n*   The auth0.js `parseHash` method, requires that your tokens are signed with `RS256`, rather than `HS256`.\n*   To return `user_metadata` or other custom information from this endpoint, add a custom claim to the ID token with an [Action](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims#create-custom-claims). For more information refer to [User profile claims and scope](https://auth0.com/docs/api-auth/tutorials/adoption/scope-custom-claims).\n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n*   The `Email` claim returns a snapshot of the email at the time of login\n*   Standard claims (other than `email`) return the latest value (unless the value comes from an external IdP)\n*   Custom claims always returns the latest value of the claim\n*   To access the most up-to-date values for the `email` or custom claims, you must get new tokens. You can log in using silent authentication (where the `prompt` parameter for your call to the [`authorize` endpoint](https://auth0.com/docs/api/authentication#authorization-code-grant) equals `none`)\n*   To access the most up-to-date values for standard claims that were changed using an external IdP (for example, the user changed their email address in Facebook)., you must get new tokens. Log in again using the external IdP, but _not_ with silent authentication.\n\n### Learn More\n\n*   [Auth0.js v8 Reference: Extract the authResult and get user info](https://auth0.com/docs/libraries/auth0js#extract-the-authresult-and-get-user-info)\n    \n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits)\n    \n\n## Multi-factor Authentication\n\nThe Multi-factor Authentication (MFA) API endpoints allow you to enforce MFA when users interact with [the Token endpoints](#get-token), as well as enroll and manage user authenticators.\n\nFirst, request a challenge based on the challenge types supported by the application and user. If you know that one-time password (OTP) is supported, you can skip the challenge request.\n\nNext, verify the multi-factor authentication using the `/oauth/token` endpoint and the specified challenge type: a one-time password (OTP), a recovery code, or an out-of-band (OOB) challenge.\n\nTo learn more, read:\n\n*   [Multi-factor Authentication and Resource Owner Password](https://auth0.com/docs/mfa/guides/mfa-api/multifactor-resource-owner-password)\n*   [Multi-factor Authentication API](https://auth0.com/docs/mfa/concepts/mfa-api)\n*   [Multi-factor Authentication in Auth0](https://auth0.com/docs/mfa)\n\n## Challenge Request\n\n```\nPOST https://{yourDomain}/mfa/challenge\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"mfa_token\": \"MFA_TOKEN\",\n  \"challenge_type\": \"oob|otp\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --header 'content-type: application/json' \\\n  --data '{\"mfa_token\":\"MFA_TOKEN\", \"challenge_type\":\"oob otp\", \"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\"}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  headers: { 'content-type': 'application/json' },\n  body:\n   { mfa_token: 'MFA_TOKEN',\n     challenge_type: 'oob otp',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"challenge_type\":\"otp\",\n}\n```\n\n> RESPONSE SAMPLE FOR OOB WITHOUT BINDING METHOD:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"challenge_type\":\"oob\",\n  \"oob_code\": \"abcde...dasg\"\n}\n```\n\n> RESPONSE SAMPLE FOR OOB WITH BINDING METHOD:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"challenge_type\":\"oob\",\n  \"binding_method\":\"prompt\",\n  \"oob_code\": \"abcde...dasg\"\n}\n```\n\nRequest a challenge for multi-factor authentication (MFA) based on the challenge types supported by the application and user.\n\nThe `challenge_type` is how the user will get the challenge and prove possession. Supported challenge types include:\n\n*   `otp`: for one-time password (OTP)\n*   `oob`: for SMS/Voice messages or out-of-band (OOB)\n\nIf OTP is supported by the user and you don't want to request a different factor, you can skip the challenge request and [verify the multi-factor authentication with a one-time password](#verify-with-one-time-password-otp-).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`mfa_token`  \nRequired\n\nThe token received from `mfa_required` error.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`challenge_type`\n\nA whitespace-separated list of the challenges types accepted by your application. Accepted challenge types are `oob` or `otp`. Excluding this parameter means that your client application accepts all supported challenge types.\n\n`authenticator_id`\n\nThe ID of the authenticator to challenge. You can get the ID by querying the list of available authenticators for the user as explained on [List authenticators](#list-authenticators) below.\n\n*   This endpoint does not support enrollment; the user must be enrolled with the preferred method before requesting a challenge.\n*   Auth0 chooses the challenge type based on the application's supported types and types the user is enrolled with.\n*   An `unsupported_challenge_type` error is returned if your application does not support any of the challenge types the user has enrolled with.\n*   An `unsupported_challenge_type` error is returned if the user is not enrolled.\n*   If the user is not enrolled, you will get a `association_required` error, indicating the user needs to enroll to use MFA. Read [Add an authenticator](#add-an-authenticator) below on how to proceed.\n\n### Learn More\n\n*   [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/mfa/guides/mfa-api/authenticate)\n*   [Manage Authenticator Factors using the MFA API](https://auth0.com/docs/mfa/guides/mfa-api/manage)\n\n## Verify with One-Time Password (OTP)\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&otp=OTP_CODE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'mfa_token=MFA_TOKEN&otp=OTP_CODE&grant_type=http://auth0.com/oauth/grant-type/mfa-otp&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { mfa_token: 'MFA_TOKEN',\n     otp: 'OTP_CODE',\n     grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nVerifies multi-factor authentication (MFA) using a one-time password (OTP).\n\nTo verify MFA with an OTP, prompt the user to get the OTP code, then make a request to the `/oauth/token` endpoint. The request must have the OTP code, the `mfa_token` you received (from the `mfa_required` error), and the `grant_type` set to `http://auth0.com/oauth/grant-type/mfa-otp`.\n\nThe response is the same as responses for `password` or `http://auth0.com/oauth/grant-type/password-realm` grant types.\n\n### Request parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For OTP MFA use `http://auth0.com/oauth/grant-type/mfa-otp`.\n\n`client_id`\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`mfa_token`  \nRequired\n\nThe `mfa_token` you received from `mfa_required` error.\n\n`otp`  \nRequired\n\nOTP Code provided by the user.\n\n### Learn More\n\n*   [Associate OTP Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/otp)\n\n## Verify with Out-of-Band (OOB)\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&oob_code=OOB_CODE&binding_code=BINDING_CODE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http://auth0.com/oauth/grant-type/mfa-oob&oob_code=OOB_CODE&binding_code=BINDING_CODE'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { mfa_token: 'MFA_TOKEN',\n     oob_code: \"OOB_CODE\",\n     binding_code: \"BINDING_CODE\"\n     grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR PENDING CHALLENGE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"error\":\"authorization_pending\",\n  \"error_description\":\"Authorization pending: please repeat the request in a few seconds.\"\n}\n```\n\n> RESPONSE SAMPLE FOR VERIFIED CHALLENGE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n> RESPONSE SAMPLE FOR REJECTED CHALLENGE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"error\":\"invalid_grant\",\n  \"error_description\":\"MFA Authorization rejected.\"\n}\n```\n\n### POST /oauth/token\n\nVerifies multi-factor authentication (MFA) using an out-of-band (OOB) challenge (either Push notification, SMS, or Voice).\n\nTo verify MFA using an OOB challenge, your application must make a request to `/oauth/token` with `grant_type=http://auth0.com/oauth/grant-type/mfa-oob`. Include the `oob_code` you received from the challenge response, as well as the `mfa_token` you received as part of `mfa_required` error.\n\nThe response to this request depends on the status of the underlying challenge verification:\n\n*   If the challenge has been accepted and verified, it will be the same as `password` or `http://auth0.com/oauth/grant-type/password-realm` grant types.\n*   If the challenge has been rejected, you will get an `invalid_grant` error, meaning that the challenge was rejected by the user. At this point you should stop polling, as this response is final.\n*   If the challenge verification is still pending (meaning it has not been accepted nor rejected), you will get an `authorization_pending` error, meaning that you must retry the same request a few seconds later. If you request too frequently, you will get a `slow_down` error.\n\nWhen the challenge response includes a `binding_method: prompt`, your app needs to prompt the user for the `binding_code` and send it as part of the request. The `binding_code` is usually a 6-digit number (similar to an OTP) included as part of the challenge. No `binding_code` is necessary if the challenge response did not include a `binding_method`. In this scenario, the response will be immediate; you will receive an `invalid_grant` or an `access_token` as response.\n\n### Request parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For OTP MFA, use `http://auth0.com/oauth/grant-type/mfa-oob`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`mfa_token`  \nRequired\n\nThe `mfa_token` you received from `mfa_required` error.\n\n`oob_code`  \nRequired\n\nThe oob code received from the challenge request.\n\n`binding_code`\n\nA code used to bind the side channel (used to deliver the challenge) with the main channel you are using to authenticate. This is usually an OTP-like code delivered as part of the challenge message.\n\n### Learn More\n\n*   [Associate Out-of-Band Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/oob)\n\n## Verify with Recovery Code\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&recovery_code=RECOVERY_CODE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code&recovery_code=RECOVERY_CODE'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { mfa_token: 'MFA_TOKEN',\n     recovery_code: 'RECOVERY_CODE',\n     grant_type: 'http://auth0.com/oauth/grant-type/mfa-recovery-code',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400,\n  \"recovery_code\": \"abcdefg\"\n}\n```\n\n### POST /oauth/token\n\nVerifies multi-factor authentication (MFA) using a recovery code.\n\nSome multi-factor authentication (MFA) providers (such as Guardian) support using a recovery code to login. Use this method to authenticate when the user's enrolled device is unavailable, or the user cannot receive the challenge or accept it due to connectivity issues.\n\nTo verify MFA using a recovery code your app must prompt the user for the recovery code, and then make a request to `oauth/token` with `grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code`. Include the collected recovery code and the `mfa_token` from the `mfa_required` error. If the recovery code is accepted, the response will be the same as for `password` or `http://auth0.com/oauth/grant-type/password-realm` grant types. It might also include a `recovery_code` field, which the application must display to the end-user to be stored securely for future use.\n\n### Request parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For recovery code use `http://auth0.com/oauth/grant-type/mfa-recovery-code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`mfa_token`  \nRequired\n\nThe `mfa_token` you received from `mfa_required` error.\n\n`recovery_code`  \nRequired\n\nRecovery code provided by the end-user.\n\n## Add an Authenticator\n\n```\nPOST https://{yourDomain}/mfa/associate\nContent-Type: application/json\nAuthorization: Bearer ACCESS_TOKEN or MFA_TOKEN\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"authenticator_types\": [\"oob\"],\n  \"oob_channels\": \"sms\",\n  \"phone_number\": \"+1 555 123456\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer ACCESS_TOKEN or MFA_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\", \"authenticator_types\":[\"oob\"], \"oob_channels\":\"sms\", \"phone_number\": \"+1 555 123456\"}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {\n    'authorization': 'Bearer TOKEN',\n    'content-type': 'application/json'\n  },\n  body:\n   { client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     authenticator_types: [\"oob\"],\n     oob_channels: \"sms\",\n     phone_number: \"+1 555 123456\" },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OOB (SMS channel):\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"oob_code\": \"Fe26.2**da6....\",\n  \"binding_method\":\"prompt\",\n  \"authenticator_type\":\"oob\",\n  \"oob_channels\":\"sms\",\n  \"recovery_codes\":[\"ABCDEFGDRFK75ABYR7PH8TJA\"],\n}\n```\n\n> RESPONSE SAMPLE FOR OOB (Auth0 channel):\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"oob_code\": \"Fe26.2**da6....\",\n  \"barcode_uri\":\"otpauth://...\",\n  \"authenticator_type\":\"oob\",\n  \"oob_channels\":\"auth0\",\n  \"recovery_codes\":[\"ABCDEFGDRFK75ABYR7PH8TJA\"],\n}\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"secret\": \"ABCDEFGMK5CE6WTZKRTTQRKUJVFXOVRF\",\n  \"barcode_uri\":\"otpauth://...\",\n  \"authenticator_type\":\"otp\",\n  \"recovery_codes\":[\"ABCDEFGDRFK75ABYR7PH8TJA\"],\n}\n```\n\n### POST /mfa/associate\n\nAssociates or adds a new authenticator for multi-factor authentication (MFA).\n\nIf the user has active authenticators, an Access Token with the `enroll` scope and the `audience` set to `https://{yourDomain}/mfa/` is required to use this endpoint.\n\nIf the user has no active authenticators, you can use the `mfa_token` from the `mfa_required` error in place of an Access Token for this request.\n\nAfter an authenticator is added, it must be verified. To verify the authenticator, use the response values from the `/mfa/associate` request in place of the values returned from the `/mfa/challenge` endpoint and continue with the verification flow.\n\nA `recovery_codes` field is included in the response the first time an authenticator is added. You can use `recovery_codes` to pass multi-factor authentication as shown on [Verify with recovery code](#verify-with-recovery-code) above.\n\nTo access this endpoint, you must set an Access Token at the Authorization header, with the following claims:\n\n*   `scope`: `enroll`\n*   `audience`: `https://{yourDomain}/mfa/`\n\n### Request parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field in your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`authenticator_types`  \nRequired\n\nThe type of authenticators supported by the client. Value is an array with values `\"otp\"` or `\"oob\"`.\n\n`oob_channels`\n\nThe type of OOB channels supported by the client. An array with values `\"auth0\"`, `\"sms\"`, `\"voice\"`. Required if `authenticator_types` include `oob`.\n\n`phone_number`\n\nThe phone number to use for SMS or Voice. Required if `oob_channels` includes `sms` or `voice`.\n\n### Learn More\n\n*   [Multi-factor Authentication API](https://auth0.com/docs/mfa/concepts/mfa-api)\n\n## List Authenticators\n\n```\nGET https://{yourDomain}/mfa/authenticators\nContent-Type: application/json\nAuthorization: Bearer ACCESS_TOKEN\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {\n    'authorization': 'Bearer ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n[\n  {\n    \"id\":\"recovery-code|dev_DsvzGfZw2Fg5N3rI\",\n    \"authenticator_type\":\"recovery-code\",\n    \"active\":true\n  },\n  {\n    \"id\":\"sms|dev_gB342kcL2K22S4yB\",\n    \"authenticator_type\":\"oob\",\n    \"oob_channels\":\"sms\",\n    \"name\":\"+X XXXX1234\",\n    \"active\":true\n  },\n  {\n    \"id\":\"sms|dev_gB342kcL2K22S4yB\",\n    \"authenticator_type\":\"oob\",\n    \"oob_channels\":\"sms\",\n    \"name\":\"+X XXXX1234\",\n    \"active\":false\n  },\n  {\n    \"id\":\"push|dev_433sJ7Mcwj9P794y\",\n    \"authenticator_type\":\"oob\",\n    \"oob_channels\":\"auth0\",\n    \"name\":\"John's Device\",\n    \"active\":true\n  },\n    {\n    \"id\":\"totp|dev_LJaKaN5O3tjRFOw2\",\n    \"authenticator_type\":\"otp\",\n    \"active\":true\n  }\n]\n```\n\n### GET /mfa/authenticators\n\nReturns a list of authenticators associated with your application.\n\nTo access this endpoint you must set an Access Token at the Authorization header, with the following claims:\n\n*   `scope`: `read:authenticators`\n*   `audience`: `https://{yourDomain}/mfa/`\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`ACCESS_TOKEN`  \nRequired\n\nThe Access Token obtained during login.\n\n#### Learn More\n\n*   [Manage Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/manage)\n\n## Delete an Authenticator\n\n```\nDELETE https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\nAuthorization: Bearer ACCESS_TOKEN\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID' \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'DELETE',\n  url: 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID',\n  headers: {\n    'authorization': 'Bearer ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 204 OK\n```\n\n### DELETE /mfa/authenticators\n\nDeletes an associated authenticator using its ID.\n\nYou can get authenticator IDs by [listing the authenticators](#list-authenticators).\n\nTo access this endpoint, you must set an Access Token at the Authorization header, with the following claims:\n\n*   `scope`: `remove:authenticators`\n*   `audience`: `https://{yourDomain}/mfa/`\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`ACCESS_TOKEN`  \nRequired\n\nThe Access Token obtained during login.\n\n`AUTHENTICATOR_ID`  \nRequired\n\nThe ID of the authenticator to delete.\n\n### Learn More\n\n*   [Manage Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/manage)\n\n## SAML\n\nThe SAML protocol is used mostly for third-party SaaS applications, like Salesforce and Box. Auth0 supports Service Provider (SP) and Identity Provider (IDP) initiated Sign On. To learn more, see [SAML](https://auth0.com/docs/protocols/saml).\n\n## Accept Request\n\n```\nGET https://{yourDomain}/samlp/{yourClientId}?\n  connection=CONNECTION\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/samlp/{yourClientId}' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data '\"connection\"=\"CONNECTION\"'\n```\n\n### GET /samlp/YOUR\\_CLIENT\\_ID\n\nUse this endpoint to accept a SAML request to initiate a login.\n\nOptionally, you can include a `connection` parameter to log in with a specific provider. If no connection is specified, the [Auth0 Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login) will be shown.\n\nOptionally, SP-initiated login requests can include an `organization` parameter to authenticate users in the context of an organization. To learn more, see [Organizations](https://auth0.com/docs/organizations).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nClient ID of your application.\n\n`connection`\n\nConnection to use during login.\n\n`organization`\n\nOrganization ID, if authenticating in the context of an organization.\n\n*   All the parameters of the SAML response can be modified with [Rules](https://auth0.com/docs/rules).\n*   The SAML request `AssertionConsumerServiceURL` will be used to `POST` back the assertion. It must match one of the application's `callback_URLs`.\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n\n## Get Metadata\n\n```\nGET https://{yourDomain}/samlp/metadata/{yourClientId}\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/samlp/metadata/{yourClientId}'\n```\n\n### GET /samlp/metadata/YOUR\\_CLIENT\\_ID\n\nThis endpoint returns the SAML 2.0 metadata.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n\n## IdP-Initiated Single Sign-On (SSO) Flow\n\n```\nPOST https://{yourDomain}/login/callback?connection=CONNECTION\nContent-Type: 'application/x-www-form-urlencoded'\n  SAMLResponse=SAML_RESPONSE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/login/callback' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data '\"connection\":\"CONNECTION\", \"SAMLResponse\":\"SAML_RESPONSE\"'\n```\n\n### POST /login/callback\n\nThis endpoint accepts an IdP-Initiated Sign On SAMLResponse from a SAML Identity Provider. The connection corresponding to the identity provider is specified in the query string. The user will be redirected to the application that is specified in the SAML Provider IdP-Initiated Sign On section.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`connection`  \nRequired\n\nThe name of an identity provider configured to your application.\n\n`SAMLResponse`  \nRequired\n\nAn IdP-Initiated Sign On SAML Response.\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n\n## WS-Federation\n\n## Accept Request\n\n```\nGET https://{yourDomain}/wsfed/{yourClientId}\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/wsfed/{yourClientId}'\n```\n\n### GET /wsfed/YOUR\\_CLIENT\\_ID\n\nThis endpoint accepts a WS-Federation request to initiate a login.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client-id`\n\nThe `client-id` of your application.\n\n`wtrealm`\n\nCan be used in place of `client-id`.\n\n`whr`\n\nThe name of the connection (used to skip the login page).\n\n`wctx`\n\nYour application's state.\n\n`wreply`\n\nThe callback URL.\n\n*   The `wtrealm` parameter must be in one of these formats:\n    *   `urn:clientID` (for example, urn:{yourClientId})\n    *   If this parameter does not begin with a urn, the `client.clientAliases` array is used for look-up. This can only be set with the [/api/v2/clients](https://auth0.com/docs/api/management/v2#!/Clients/get_clients) Management API.\n*   The `whr` parameter is mapped to the connection like this: `urn:CONNECTION_NAME`. For example, `urn:google-oauth2` indicates login with Google. If there is no `whr` parameter included, the user will be directed to the [Auth0 Login Page](https://auth0.com/docs/login_page).\n\n### Learn More\n\n*   [WS-Federation](https://auth0.com/docs/protocols/ws-fed)\n\n## Get Metadata\n\n```\nGET https://{yourDomain}/wsfed/FederationMetadata/2007-06/FederationMetadata.xml\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/wsfed/FederationMetadata/2007-06/FederationMetadata.xml'\n```\n\n### GET /wsfed/FederationMetadata/2007-06/FederationMetadata.xml\n\nThis endpoint returns the WS-Federation metadata.\n\n### Learn More\n\n*   [WS-Federation](https://auth0.com/docs/protocols/ws-fed)\n\n## Dynamic Application (Client) Registration\n\n```\nPOST https://{yourDomain}/oidc/register\nContent-Type: application/json\n{\n  \"client_name\": \"YOUR-NEW-CLIENT-NAME\",\n  \"redirect_uris\": [],\n  \"token_endpoint_auth_method\": \"client_secret_post\"\n}\n```\n\n```\ncurl --request POST \\\n  --url https://{yourDomain}/oidc/register \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_name\": \"YOUR-NEW-CLIENT-NAME\",\"redirect_uris\": [], \"token_endpoint_auth_method\": \"client_secret_post\"}'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"client_name\": \"My Dynamic Client\",\n  \"client_id\": \"8SXWY6j3afl2CP5ntwEOpMdPxxy49Gt2\",\n  \"client_secret\": \"Q5O...33P\",\n  \"redirect_uris\": [\n    \"https://client.example.com/callback\",\n    \"https://client.example.com/callback2\"\n  ],\n  \"client_secret_expires_at\": 0\n}\n```\n\n### POST /oidc/register\n\nWith a name and the necessary callback URL, you can dynamically register a client with Auth0. No token is needed for this request.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_name`\n\nThe name of the Dynamic Client to be created. It is recommended to provide a value but if it is omitted, the default name \"My App\" will be used.\n\n`redirect_uris`  \nRequired\n\nAn array of URLs that Auth0 will deem valid to call at the end of an Authentication flow.\n\n`token_endpoint_auth_method`\n\nDefault value is `client_secret_post`. Use `token_endpoint_auth_method: none` in the request payload if creating a SPA.\n\nAPI Authorization\n\n## Authorize Application\n\nTo begin an OAuth 2.0 Authorization flow, your application should first send the user to the authorization URL.\n\n## Authorize endpoint\n\nThe purpose of this call is to obtain consent from the user to invoke the API (specified in `audience`) and do certain things (specified in `scope`) on behalf of the user. Auth0 will authenticate the user and obtain consent, unless consent has been previously given. If you alter the value in `scope`, Auth0 will require consent to be given again.\n\nThe OAuth 2.0 flows that require user authorization are:\n\n*   [Authorization Code Flow](https://auth0.com/docs/flows/concepts/auth-code)\n*   [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce)\n*   [Implicit Flow](https://auth0.com/docs/flows/concepts/implicit)\n\nThe [Resource Owner Password Grant](https://auth0.com/docs/api-auth/grant/password) and [Client Credentials Flow](https://auth0.com/docs/flows/concepts/client-credentials) do not use this endpoint since there is no user authorization involved. Instead, they directly invoke the `POST /oauth/token` endpoint to retrieve an Access Token.\n\nBased on the OAuth 2.0 flow you are implementing, the parameters slightly change. To determine which flow is best suited for your case, refer to: [Which OAuth 2.0 flow should I use?](https://auth0.com/docs/api-auth/which-oauth-flow-to-use).\n\n## Get Token\n\nFor token-based authentication, use the `oauth/token` endpoint to get an access token for your application to make authenticated calls to a secure API. Optionally, you can also retrieve an ID Token and a Refresh Token. ID Tokens contains user information in the form of scopes you application can extract to provide a better user experience. Refresh Tokens allow your application to request a new access token once the current token expires without interruping the user experience. To learn more, read [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens) and [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\nNote that the only OAuth 2.0 flows that can retrieve a Refresh Token are:\n\n*   [Authorization Code Flow (Authorization Code)](https://auth0.com/docs/flows/concepts/auth-code)\n*   [Authorization Code Flow with PKCE (Authorization Code with PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce)\n*   [Resource Owner Password](https://auth0.com/docs/api-auth/grant/password)\n*   [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth)\n*   Token Exchange\\*\n\n## Authorization Code Flow\n\n## Authorize\n\n```\nGET https://{yourDomain}/authorize?\n  audience=API_IDENTIFIER&\n  scope=SCOPE&\n  response_type=code&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}?code=AUTHORIZATION_CODE&state=STATE\n```\n\n### GET /authorize\n\nThis is the OAuth 2.0 grant that regular web apps utilize in order to access an API.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes which you want to request authorization for. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token.\n\n`response_type`  \nRequired\n\nIndicates to Auth0 which OAuth 2.0 flow you want to use. Use `code` for Authorization Code Grant Flow.\n\n`client_id`  \nRequired\n\nYour application's ID.\n\n`state`  \nRecommended\n\nAn opaque value the application adds to the initial request that Auth0 includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`redirect_uri`\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`connection`\n\nThe name of the connection configured to your application.\n\n`prompt`\n\nTo initiate a [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) request, use `prompt=none` (To learn more, read the Remarks).\n\n`organization`\n\nID of the [organization](https://auth0.com/docs/organizations) to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n`invitation`\n\nTicket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the invitation and organization key-value pairs when the user accepts the invitation.\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'authorization_code',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     code: 'AUTHORIZATION_CODE',\n     redirect_uri: '{https://yourApp/callback}' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the flow that regular web apps use to access an API. Use this endpoint to exchange an Authorization Code for a token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Authorization Code, use `authorization_code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`  \nRequired\n\nYour application's Client Secret.\n\n`code`  \nRequired\n\nThe Authorization Code received from the initial `/authorize` call.\n\n`redirect_uri`\n\nThis is required only if it was set at the [GET /authorize](#authorization-code-grant) endpoint. The values from `/authorize` must match the value you set at `/oauth/token`.\n\n### Learn More\n\n*   [Authorization Code Flow](https://auth0.com/docs/flows/concepts/auth-code)\n*   [Call API Using the Authorization Code Flow](https://auth0.com/docs/flows/guides/auth-code/call-api-auth-code)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication)\n\n## Authorization Code Flow with PKCE\n\n## Authorize\n\n```\nGET https://{yourDomain}/authorize?\n  audience=API_IDENTIFIER&\n  scope=SCOPE&\n  response_type=code&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  code_challenge=CODE_CHALLENGE&\n  code_challenge_method=S256\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}?code=AUTHORIZATION_CODE\n```\n\n### GET /authorize\n\nThis is the OAuth 2.0 grant that mobile apps utilize in order to access an API. Before starting with this flow, you need to generate and store a `code_verifier`, and using that, generate a `code_challenge` that will be sent in the authorization request.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes which you want to request authorization for. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token.\n\n`response_type`  \nRequired\n\nIndicates to Auth0 which OAuth 2.0 Flow you want to perform. Use `code` for Authorization Code Grant (PKCE) Flow.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`state`  \nRecommended\n\nAn opaque value the client adds to the initial request that Auth0 includes when redirecting back to the client. This value must be used by the client to prevent CSRF attacks.\n\n`redirect_uri`\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`code_challenge_method`  \nRequired\n\nMethod used to generate the challenge. The PKCE spec defines two methods, `S256` and `plain`, however, Auth0 supports only `S256` since the latter is discouraged.\n\n`code_challenge`  \nRequired\n\nGenerated challenge from the `code_verifier`.\n\n`connection`\n\nThe name of the connection configured to your application.\n\n`prompt`\n\nTo initiate a [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) request, use `prompt=none` (To learn more, read the Remarks).\n\n`organization`\n\nID of the [organization](https://auth0.com/docs/organizations) to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n`invitation`\n\nTicket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the invitation and organization key-value pairs when the user accepts the invitation.\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&client_id={yourClientId}&code_verifier=CODE_VERIFIER&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=authorization_code&client_id={yourClientId}&code_verifier=CODE_VERIFIER&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form: {\n    grant_type:\"authorization_code\",\n    client_id: \"{yourClientId}\",\n    code_verifier: \"CODE_VERIFIER\",\n    code: \"AUTHORIZATION_CODE\",\n    redirect_uri: \"{https://yourApp/callback}\", } };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the flow that mobile apps use to access an API. Use this endpoint to exchange an Authorization Code for a token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Authorization Code (PKCE) use `authorization_code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`code`  \nRequired\n\nThe Authorization Code received from the initial `/authorize` call.\n\n`code_verifier`  \nRequired\n\nCryptographically random key that was used to generate the `code_challenge` passed to `/authorize`.\n\n`redirect_uri`\n\nThis is required only if it was set at the [GET /authorize](#authorization-code-grant-pkce-) endpoint. The values from `/authorize` must match the value you set at `/oauth/token`.\n\n*   In order to improve compatibility for applications, Auth0 will now return profile information in a [structured claim format as defined by the OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). This means that in order to add custom claims to ID tokens or access tokens, they must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims) to avoid possible collisions with standard OIDC claims.\n*   Include `offline_access` to the `scope` request parameter to get a refresh token from [POST /oauth/token](#authorization-code-pkce-). Make sure that the **Allow Offline Access** field is enabled in the [API Settings](https://manage.auth0.com/#/apis).\n*   The `redirect_uri` value must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications).\n*   Silent authentication lets you perform an authentication flow where Auth0 will only reply with redirects, and never with a login page. When an Access Token has expired, silent authentication can be used to retrieve a new one without user interaction, assuming the user's Single Sign-on (SSO) session has not expired.\n\n### Learn More\n\n*   [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce)\n*   [Call API Using the Authorization Code Flow with PKCE](https://auth0.com/docs/flows/guides/auth-code-pkce/call-api-auth-code-pkce)\n*   [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication)\n\n\\>\n\n## Authorization Code Flow with Enhanced Privacy Protection\n\n## Push Authorization Requests (PAR)\n\n### POST /oauth/par\n\n```\nPOST {yourDomain}/oauth/par\nContent-Type: 'application/x-www-form-urlencoded'\n  audience={https://yourApi/}&\n  response_type=code|code id_token&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE&\n  scope=openid|profile|email&\n  code_challenge=CODE_CHALLENGE&\n  code_challenge_method=S256&\n  nonce=NONCE&\n  connection=CONNECTION&\n  prompt=login|consent|none&\n  organisation=ORGANIZATION\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/par,\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form: {\n    audience: '{https://yourApi/}',\n    response_type: 'code|code id_token',\n    client_id: '{yourClientId}',\n    redirect_uri: '{https://yourApp/callback}',\n    state: 'STATE',\n    scope: 'openid|profile|email',\n    authorization_details: JSON.stringify([{ type: 'my_type' }]),\n    code_challenge: 'CODE_CHALLENGE',\n    code_challenge_method: 'S256',\n    nonce: 'NONCE',\n    connection: 'CONNECTION',\n    prompt: 'login|consent|none'\n    organisation: 'ORGANIZATION'\n    }\n};\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/par' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n--data 'audience={https://yourApi/}response_type=code|code id_token&client_id={yourClientId}&redirect_uri={https://yourApp/callback}&state=STATE&scope=openid|profile|email&authorization_details='[{\"type\":\"my_type\"}]'\n&code_challenge=CODE_CHALLENGE&code_challenge_method=S256&nonce=NONCE&connection=CONNECTION&prompt=login|consent|none&organisation=ORGANIZATION'\n\n```\n\n> RESPONSE SAMPLE:\n\n```\n/**\nIf the request is successful, `/oauth/par` responds with a `JSON` object containing the `request_uri` property, which can be used at the authorization endpoint, and the `expires_in` value, which indicates the number of seconds the `request_uri` is valid. \n*/\n\nHTTP/1.1 201 Created\nContent-Type: application/json\n\n{\n  \"request_uri\":\n    \"urn:ietf:params:oauth:request_uri:6esc_11ACC5bwc014ltc14eY22c\",\n  \"expires_in\": 30\n}\n```\n\nAuthorization Code Flow with [Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par) uses the `/oauth/par` endpoint to allow applications to send the authorization parameters usually sent in a `GET` request to `/authorize`. PAR uses a POST method from the backend to keep parameter values secure. The `/oauth/par` endpoint accepts all authorization parameters which can be proivided to `/authorize`. Assuming the call to the `/oauth/par` endpoint is valid, Auth0 will respond with a `redirect_uri` value that can be used as a parameter for the `/authorize` endpoint.\n\nAssuming the call to the `/oauth/par` endpoint is valid, Auth0 will respond with a `redirect_uri` value also used as a parameter for the `/authorize` endpoint. To learn more about configuring PAR, read [Configure Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/applications/configure-par).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`authorization_details`\n\nRequested permissions for each resource. Similar to scopes. To learn more, read [RAR reference documention](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar).\n\n`audience`\n\nThe unique identifier of the target API you want to access.\n\n`response_type`  \nRequired\n\nSpecifies the token type. We recommend you use `code` to request an authorization code, or code `id_token` to receive an authorization code and a [detached signature](https://openid.net/specs/openid-financial-api-part-2-1_0.html#id-token-as-detached-signature).\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`state`  \nRecommended\n\nAn opaque value the application adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`scope`  \nRecommended\n\nOIDC scopes and custom API scopes. For example: `openid read:timesheets`. Include `offline_access` to get a refresh token.\n\n`code_challenge`  \nRecommended\n\nOIDC scopes and custom API scopes. For example: `openid read:timesheets`. Include `offline_access` to get a refresh token.\n\n`code_challenge_method`  \nRecommended\n\nMethod used to generate the challenge. The PKCE specification defines two methods, `S256` and plain, however, Auth0 supports only S256 since the latter is discouraged. \\[Authorization Code Flow with Proof Key for Code Exchange (PKCE)\\] (/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n\n`nonce`  \nRecommended\n\nA string value which will be included in the ID token response from Auth0, used to prevent token replay attacks. It is required for `response_type=id_token` token.\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget using the first database connection.\n\n`prompt`\n\nCan be used to force a particular prompt to display, e.g. `prompt=consent` will always display the consent prompt.\n\n`organization`\n\nID of the organization to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n*   To make a call to the PAR endpoint, you must:\n    *   Set the request content type as `application/x-www-form-urlencoded`\n    *   Use `strings` for all passed parameters\n    *   Include an additional parameter for application authentication in the request (e.g. `client_secret`, or `client_assertion` and `client_assertion_type` for JSON Web Token Client Authentication, or pass a `client-certificate` and `client-certificate-ca-verified` header when using Mutual TLS).\n*   Use the `authorization_details` parameter to request permission for each resource. For example, you can specify an array of JSON objects to convey fine-grained information on the authorization. Each JSON object must contain a `type` attribute. The rest is up to you to define.\n\n## Authorize\n\n### GET /authorize\n\n```\nGET https://{yourDomain}/authorize\n  request_uri={yourRequestUri}&\n  client_id={yourClientId}\n```\n\nAfter calling the `/oauth/par` endpoint, redirect the end user to the `/authorize` endpoint using a `GET` call.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`request_uri`  \nRequired\n\nThe `request_uri` value that was received from the `/oauth/par` endpoint.\n\n## Exchange an Authorization Code for a Token\n\n### POST /oauth/token\n\n```\nPOST https://{yourDomain}/oauth/par\nContent-Type: 'application/x-www-form-urlencoded'\n  grant_type=code|code id_token&\n  client_id={yourClientId}&\n  code=CODE&\n redirect_uri={https://yourApp/callback}&\n code_verifier=CODE_VERIFIER\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/par' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n--data 'grant_type=authorization_code& client_id={yourClientId}& code=CODE&redirect_uri={https://yourApp/callback}&code_verifier=CODE_VERIFIER'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token,\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form: { \n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    code: 'CODE',\n    redirect_uri: '{https://yourApp/callback}',\n    code_verifier: 'CODE_VERIFIER'\n    }\n};\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\n/**\nThe `/oauth/token` endpoint will respond with a JSON object containing an `id_token` property, and potentially also a `refresh_token` if one was requested.\n*/\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n   \"refresh_token\":\"GEbRxBN...edjnXbL\",\n    \"access_token\":\"eybRxBN...edjnXZQ\",  \n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400,\n  \"authrorization_details\":[\n    {\n      \"type\":\"my_type\",\n      \"other_attributes_of_my_type\":\"value\"}\n  ]\n},\n  \n  \n```\n\nWhen users are redirected back to your callback, you need to make a `POST` call to the `oauth/token` endpoint to exchange an authorization code for an access and/or an ID token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow. Assuming you have an authorization code from the `/authorize` endpoint, use `authorization_code`.\n\n`code`\n\nThe authorization code from the initial `/authorize` call.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`request_uri`  \nRequired\n\nThis is required only if it was set at the `GET` `/oauth/par` endpoint. The values from `/authorize` must match the value you set at `/oauth/token`.\n\n`code_verifier`  \nRecommended\n\nCryptographically random key used to generate the `code_challenge` passed to `/oauth/par`. If the `code_challenge` parameter is passed in the call to `/oauth/par`, this is required.\n\nTo make a call to `/oauth/token` endpoint, you must:\n\n*   Set the request content type as `application/x-www-form-urlencoded`\n*   Use `strings` for all passed parameters\n*   Include an additional parameter for application authentication in the request (e.g. `client_secret`, or `client_assertion` and `client_assertion_type` for JSON Web Token Client Authentication, or pass a `client-certificate` and `client-certificate-ca-verified` header when using Mutual TLS).\n\n\\>\n\n## Client Credential Flow\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\naudience=API_IDENTIFIER&grant_type=client_credentials&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'audience=API_IDENTIFIER&grant_type=client_credentials&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     audience: 'API_IDENTIFIER',\n     grant_type: 'client_credentials' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the OAuth 2.0 grant that server processes use to access an API. Use this endpoint to directly request an access token by using the application's credentials (a Client ID and a Client Secret).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Client Credentials use `client_credentials`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`  \nRequired\n\nYour application's Client Secret.\n\n`audience`  \nRequired\n\nThe unique identifier of the target API you want to access.\n\n### Learn More\n\n*   [Client Credentials Flow](https://auth0.com/docs/flows/concepts/client-credentials)\n*   [Call API using the Client Credentials Flow](https://auth0.com/docs/flows/guides/client-credentials/call-api-client-credentials)\n*   [Setting up a Client Grant using the Management Dashboard](https://auth0.com/docs/api-auth/config/using-the-auth0-dashboard)\n*   [Asking for Access Tokens for a Client Credentials Grant](https://auth0.com/docs/api-auth/config/asking-for-access-tokens)\n\n\\>\n\n## Implicit Flow\n\n## Authorize\n\n```\nGET https://{yourDomain}/authorize?\n  audience=API_IDENTIFIER&\n  scope=SCOPE&\n  response_type=token|id_token|id_token token&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE&\n  nonce=NONCE\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}#access_token=TOKEN&state=STATE&token_type=TYPE&expires_in=SECONDS\n```\n\n### GET /authorize\n\nThis is the OAuth 2.0 grant that web apps utilize in order to access an API.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes which you want to request authorization for. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`. Custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`).\n\n`response_type`  \nRequired\n\nThis will specify the type of token you will receive at the end of the flow. Use `token` to get only an Access Token, `id_token` to get only an ID token (if you don't plan on accessing an API), or `id_token token` to get both an ID token and an Access Token.\n\n`client_id`  \nRequired\n\nYour application's ID.\n\n`state`  \nRecommended\n\nAn opaque value the application adds to the initial request that Auth0 includes when redirecting back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`redirect_uri`\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`nonce`  \nRecommended\n\nA string value which will be included in the ID token response from Auth0, [used to prevent token replay attacks](https://auth0.com/docs/api-auth/tutorials/nonce). It is required for `response_type=id_token token`.\n\n`connection`\n\nThe name of the connection configured for your application.\n\n`prompt`\n\nTo initiate a [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) request, use `prompt=none` (To learn more, read the Remarks).\n\n`organization`\n\nID of the [organization](https://auth0.com/docs/organizations) to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n`invitation`\n\nTicket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the invitation and organization key-value pairs when the user accepts the invitation.\n\n*   The `redirect_uri` value must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications).\n*   If `response_type=token`, after the user authenticates with the provider, this will redirect them to your application callback URL while passing the `access_token` in the address `location.hash`. This is used for Single-Page Apps and on Native Mobile SDKs.\n*   The Implicit Grant does not support the issuance of Refresh Tokens. Use [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) instead.\n*   In order to improve compatibility for applications, Auth0 will now return profile information in a [structured claim format as defined by the OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). This means that in order to add custom claims to ID tokens or Access Tokens, they must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims) to avoid possible collisions with standard OIDC claims.\n*   Silent Authentication lets you perform an authentication flow where Auth0 will only reply with redirects, and never with a login page. When an Access Token has expired, silent authentication can be used to retrieve a new one without user interaction, assuming the user's Single Sign-on (SSO) session has not expired.\n\n### Learn More\n\n*   [Implicit Flow](https://auth0.com/docs/flows/concepts/implicit)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Mitigate replay attacks when using the Implicit Grant](https://auth0.com/docs/api-auth/tutorials/nonce)\n*   [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication)\n\n\\>\n\n## Resource Owner Password Flow\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=password&username=USERNAME&password=PASSWORD&audience=API_IDENTIFIER&scope=SCOPE&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=password&username=USERNAME&password=PASSWORD&audience=API_IDENTIFIER&scope=SCOPE&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'password',\n     username: 'USERNAME',\n     password: 'PASSWORD',\n     audience: 'API_IDENTIFIER',\n     scope: 'SCOPE',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the OAuth 2.0 grant that highly-trusted apps use to access an API. In this flow, the end-user is asked to fill in credentials (username/password), typically using an interactive form in the user-agent (browser). This information is sent to the backend and from there to Auth0. It is therefore imperative that the application is absolutely trusted with this information. For [single-page applications and native/mobile apps](https://auth0.com/docs/flows/concepts/auth-code-pkce), we recommend using web flows instead.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Resource Owner Password use `password`. To add realm support use `http://auth0.com/oauth/grant-type/password-realm`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`audience`\n\nThe unique identifier of the target API you want to access.\n\n`username`  \nRequired\n\nResource Owner's identifier, such as a username or email address.\n\n`password`  \nRequired\n\nResource Owner's secret.\n\n`scope`\n\nString value of the different scopes the application is asking for. Multiple scopes are separated with whitespace.\n\n`realm`\n\nString value of the realm the user belongs. Set this if you want to add realm support at this grant. For more information on what realms are refer to [Realm Support](https://auth0.com/docs/api-auth/grant/password#realm-support).\n\nParameter\n\nDescription\n\n`auth0-forwarded-for`\n\nEnd-user IP as a string value. Set this if you want brute-force protection to work in server-side scenarios. For more information on how and when to use this header, refer to [Using resource owner password from server-side](https://auth0.com/docs/api-auth/tutorials/using-resource-owner-password-from-server-side).\n\n*   The scopes issued to the application may differ from the scopes requested. In this case, a `scope` parameter will be included in the response JSON.\n*   If you don't request specific scopes, all scopes defined for the audience will be returned due to the implied trust to the application in this grant. You can customize the scopes returned in a rule. For more information, refer to [Calling APIs from Highly Trusted Applications](https://auth0.com/docs/api-auth/grant/password).\n*   To add realm support set the `grant_type` to `http://auth0.com/oauth/grant-type/password-realm`, and the `realm` to the realm the user belongs. This maps to a connection in Auth0. For example, if you have configured a database connection for your internal employees and you have named the connection `employees`, then use this value. For more information on how to implement this refer to: [Realm Support](https://auth0.com/docs/api-auth/tutorials/password-grant#realm-support).\n*   In addition to username and password, Auth0 may also require the end-user to provide an additional factor as proof of identity before issuing the requested scopes. In this case, the request described above will return an `mfa_required` error along with an `mfa_token`. You can use these tokens to request a challenge for the possession factor and validate it accordingly. For details refer to [Resource Owner Password and MFA](#resource-owner-password-and-mfa).\n\n### Learn More\n\n*   [Calling APIs from Highly-Trusted Applications](https://auth0.com/docs/api-auth/grant/password)\n*   [Executing the Resource Owner Password Grant](https://auth0.com/docs/api-auth/tutorials/password-grant)\n*   [Multi-factor Authentication and Resource Owner Password](https://auth0.com/docs/mfa/guides/mfa-api/multifactor-resource-owner-password)\n\n\\>\n\n## Device Authorization Flow\n\n## Authorize\n\n```\nPOST https://{yourDomain}/oauth/device/code\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&scope=SCOPE&audience=API_IDENTIFIER\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/device/code' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&scope=SCOPE&audience=API_IDENTIFIER'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/device/code',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { client_id: '{yourClientId}',\n     scope: 'SCOPE',\n     audience: 'API_IDENTIFIER' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"device_code\":\"GmRh...k9eS\",\n  \"user_code\":\"WDJB-MJHT\",\n  \"verification_uri\":\"https://{yourDomain}/device\",\n  \"verification_uri_complete\":\"https://{yourDomain}/device?user_code=WDJB-MJHT\",\n  \"expires_in\":900, //in seconds\n  \"interval\":5\n}\n```\n\n### POST /oauth/device/code\n\nThis is the flow that input-constrained devices use to access an API. Use this endpoint to get a device code. To begin the [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth), your application should first request a device code.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes for which you want to request authorization. These must be separated by a space. You can request any of the [standard OIDC scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token.\n\n`client_id`  \nRequired\n\nYour application's ID.\n\n### Response Values\n\nValue\n\nDescription\n\n`device_code`\n\nThe unique code for the device. When the user visits the `verification_uri` in their browser-based device, this code will be bound to their session.\n\n`user_code`\n\nThe code that the user should input at the `verification_uri` to authorize the device.\n\n`verification_uri`\n\nThe URL the user should visit to authorize the device.\n\n`verification_uri_complete`\n\nThe complete URL the user should visit to authorize the device. Your app can use this value to embed the `user_code` in the URL, if you so choose.\n\n`expires_in`\n\nThe lifetime (in seconds) of the `device_code` and `user_code`.\n\n`interval`\n\nThe interval (in seconds) at which the app should poll the token URL to request a token.\n\n*   Include `offline_access` to the `scope` request parameter to get a Refresh Token from [POST /oauth/token](#device-auth). Make sure that the **Allow Offline Access** field is enabled in the [API Settings](https://manage.auth0.com/#/apis).\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&device_code=YOUR_DEVICE_CODE&grant_type=urn:ietf:params:oauth:grant-type:device_code\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&device_code=YOUR_DEVICE_CODE&grant_type=urn:ietf:params:oauth:grant-type:device_code'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { client_id: '{yourClientId}',\n     device_code: 'YOUR_DEVICE_CODE',\n     grant_type: 'urn:ietf:params:oauth:grant-type:device_code' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n   \"access_token\": \"eyJz93a...k4laUWw\",\n   \"id_token\": \"eyJ...0NE\",\n   \"refresh_token\": \"eyJ...MoQ\",\n   \"scope\": \"...\",\n   \"expires_in\": 86400,\n   \"token_type\": \"Bearer\"\n}\n```\n\n```\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\n { \n  // Can be retried\n  \"error\": \"authorization_pending\",\n  \"error_description\": \"User has yet to authorize device code.\"\n }\n```\n\n```\nHTTP/1.1 429 Too Many Requests\nContent-Type: application/json\n { \n  // Can be retried\n  \"error\": \"slow_down\",\n  \"error_description\": \"You are polling faster than the specified interval of 5 seconds.\"\n }\n```\n\n```\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\n { \n    // Cannot be retried; transaction failed\n    \"error\": \"access_denied|invalid_grant|...\",\n    \"error_description\": \"Failure: User cancelled the confirmation prompt or consent page; the code expired; there was an error.\"\n }\n```\n\n### POST /oauth/token\n\nThis is the OAuth 2.0 grant that input-constrained devices use to access an API. Poll this endpoint using the interval returned with your [device code](https://auth0.com/docs/api/authentication#get-device-code) to directly request an access token using the application's credentials (a Client ID) and a device code.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Device Authorization, use `urn:ietf:params:oauth:grant-type:device_code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`device_code`  \nRequired\n\nThe device code previously returned from the [/oauth/device/code endpoint](https://auth0.com/docs/api/authentication#device-authorization-flow).\n\n*   Because you will be polling this endpoint (using the `interval` from the initial response to determine frequency) while waiting for the user to go to the verification URL and enter their user code, you will likely receive at least one failure before receiving a successful response. See sample responses for possible responses.\n\n### Learn More\n\n*   [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth)\n*   [Call API using the Device Authorization Flow](https://auth0.com/docs/flows/guides/device-auth/call-api-device-auth)\n*   [Setting up a Device Code Grant using the Management Dashboard](https://auth0.com/docs/api-auth/config/using-the-auth0-dashboard)\n\n## Refresh Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&refresh_token=YOUR_REFRESH_TOKEN\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=refresh_token&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&refresh_token=YOUR_REFRESH_TOKEN'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'refresh_token',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     refresh_token: 'YOUR_REFRESH_TOKEN'}\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\": \"eyJ...MoQ\",\n  \"expires_in\": 86400,\n  \"scope\": \"openid offline_access\",\n  \"id_token\": \"eyJ...0NE\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### POST /oauth/token\n\nUse this endpoint to refresh an Access Token using the Refresh Token you got during authorization.\n\n## Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. To refresh a token, use `refresh_token`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`\n\nYour application's Client Secret. Required when the **Token Endpoint Authentication Method** field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`refresh_token`  \nRequired\n\nThe refresh token to use.\n\n`scope`\n\nA space-delimited list of requested scope permissions. If not sent, the original scopes will be used; otherwise you can request a reduced set of scopes. Note that this must be URL encoded.\n\n## Learn More\n\n*   [Refresh Tokens](https://auth0.com/docs/tokens/concepts/refresh-tokens)\n\n## Revoke Refresh Token\n\n```\nPOST https://{yourDomain}/oauth/revoke\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"token\": \"YOUR_REFRESH_TOKEN\",\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/revoke' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\", \"token\": \"YOUR_REFRESH_TOKEN\" }'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/revoke',\n  headers: { 'content-type': 'application/json' },\n  body: \n   { client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     token: 'YOUR_REFRESH_TOKEN' },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\n(empty-response-body)\n```\n\n### POST /oauth/revoke\n\nUse this endpoint to invalidate a Refresh Token if it has been compromised.\n\nThe behaviour of this endpoint depends on the state of the [Refresh Token Revocation Deletes Grant](https://auth0.com/docs/tokens/refresh-tokens/revoke-refresh-tokens#refresh-tokens-and-grants) toggle. If this toggle is enabled, then each revocation request invalidates not only the specific token, but all other tokens based on the same authorization grant. This means that **all Refresh Tokens that have been issued for the same user, application, and audience will be revoked**. If this toggle is disabled, then only the refresh token is revoked, while the grant is left intact.\n\n## Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is the application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nThe `client_secret` of your application. Required when Client Secret Basic or Client Secret Post is the application authentication method. Specifically required for Regular Web Applications **only**.\n\n`token`  \nRequired\n\nThe Refresh Token you want to revoke.\n\n*   For non-confidential applications that cannot keep the Client Secret safe (for example, native apps), the endpoint supports passing no Client Secret but the application itself must have the property `tokenEndpointAuthMethod` set to `none`. You can do this either from the UI ([Dashboard > Applications > Application Settings](https://manage.auth0.com/#/applications)) or using the [Management API](https://auth0.com/docs/api/management/v2#!/Applications/patch_applications_by_id).\n\n## Error Codes\n\nFor the complete error code reference for this endpoint, refer to [Errors > POST /oauth/revoke](#post-oauth-revoke).\n\n## Learn More\n\n*   [Refresh Tokens](https://auth0.com/docs/tokens/concepts/refresh-tokens)\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=urn:ietf:params:oauth:grant-type:token-exchange&subject_token=SUBJECT_TOKEN&subject_token_type=SUBJECT_TOKEN_TYPE&client_id={yourClientId}&audience=API_IDENTIFIER&scope=SCOPE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=urn:ietf:params:oauth:grant-type:token-exchange&subject_token=SUBJECT_TOKEN&subject_token_type=SUBJECT_TOKEN_TYPE&client_id={yourClientId}&audience=API_IDENTIFIER&scope=SCOPE'\n }'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange',\n     subject_token: 'SUBJECT_TOKEN',\n     subject_token_type: 'SUBJECT_TOKEN_TYPE',\n     client_id: '{yourClientId}',\n     audience: 'API_IDENTIFIER',\n     scope: 'SCOPE',\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{ \n  \"access_token\": \"eyJz93a...k4laUWw\",\n  \"id_token\": \"eyJ...0NE\",\n  \"refresh_token\": \"eyJ...MoQ\",\n  \"expires_in\":86400,\n  \"token_type\":\"Bearer\"\n}\n```\n\n### POST /oauth/token\n\nWhen a non-browser-based solution (such as a mobile platform's SDK) authenticates the user, the authentication will commonly result in artifacts being returned to application code. In such situations, this grant type allows for the Auth0 platform to accept artifacts from trusted sources and issue tokens in response. In this way, apps making use of non-browser-based authentication mechanisms (as are common in native apps) can still retrieve Auth0 tokens without asking for further user interaction.\n\nArtifacts returned by this flow (and the contents thereof) will be determined by the `subject_token_type` and the tenant's configuration settings.\n\n## Request Parameters\n\nParameter\n\nDescription\n\n`auth0-forwarded-for`\n\nEnd user IP as a string value. Set this if you want brute-force protection to work in server-side scenarios. To learn more about how and when to use this header, read [Using resource owner password from server-side](https://auth0.com/docs/api-auth/tutorials/using-resource-owner-password-from-server-side).\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Token Exchange for Native Social, use `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n`subject_token`  \nRequired\n\nExternally-issued identity artifact representing the user.\n\n`subject_token_type`  \nRequired\n\nIdentifier that indicates the type of `subject_token`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`audience`\n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nString value of the different scopes the application is requesting. Multiple scopes are separated with whitespace.\n\n`user_profile`  \nOnly For `apple-authz-code`\n\nOptional element used for native iOS interactions for which profile updates can occur. Expected parameter value will be JSON in the form of: `{ name: { firstName: 'John', lastName: 'Smith }}`\n\n*   The scopes issued to the application may differ from the requested scopes. In this case, a `scope` parameter will be included in the response JSON.\n*   If you don't request specific scopes, all scopes defined for the audience will be returned due to the implied trust to the application in this grant. You can customize the scopes returned in a rule. To learn more, read [Calling APIs from Highly Trusted Applications](https://auth0.com/docs/api-auth/grant/password).\n\n## Learn More\n\n*   [Add Sign In with Apple to Native iOS Apps](https://auth0.com/docs/connections/apple-siwa/add-siwa-to-native-app)\n*   [iOS Swift - Sign In with Apple Quickstart](https://auth0.com/docs/quickstart/native/ios-swift-siwa)\n\nLegacy\n\n## Login\n\n```\nPOST https://{yourDomain}/oauth/access_token\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"access_token\": \"ACCESS_TOKEN\",\n  \"connection\": \"CONNECTION\",\n  \"scope\": \"SCOPE\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/access_token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"access_token\":\"ACCESS_TOKEN\", \"connection\":\"CONNECTION\", \"scope\":\"SCOPE\"}'\n```\n\n```\nvar url = 'https://' + {yourDomain} + '/oauth/access_token';\nvar params = 'client_id={yourClientId}&access_token={ACCESS_TOKEN}&connection={CONNECTION}&scope={SCOPE}';\n\nvar xhr = new XMLHttpRequest();\n\nxhr.open('POST', url);\nxhr.setRequestHeader('Content-Type', 'application/json');\n\nxhr.onload = function() {\n  if (xhr.status == 200) {\n    fetchProfile();\n  } else {\n    alert(\"Request failed: \" + xhr.statusText);\n  }\n};\n\nxhr.send(params);\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"id_token\": \"eyJ0eXAiOiJKV1Qi...\",\n  \"access_token\": \"A9CvPwFojaBI...\",\n  \"token_type\": \"bearer\"\n}\n```\n\n### POST /oauth/access\\_token\n\nGiven the social provider's Access Token and the `connection`, this endpoint will authenticate the user with the provider and return a JSON with the Access Token and, optionally, an ID Token. This endpoint only works for Facebook, Google, Twitter, and Weibo.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`access_token`  \nRequired\n\nThe social provider's Access Token.\n\n`connection`  \nRequired\n\nThe name of an identity provider configured to your app.\n\n`scope`\n\nUse `openid` to get an ID Token, or `openid profile email` to include user information in the ID Token. If null, only an Access Token will be returned.\n\n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n    \n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n    \n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /oauth/access\\_token](#post-oauth-access_token).\n\n### Learn More\n\n*   [Call an Identity Provider API](https://auth0.com/docs/tutorials/calling-an-external-idp-api)\n*   [Identity Provider Access Tokens](https://auth0.com/docs/tokens/overview-idp-access-tokens)\n*   [Add scopes/permissions to call Identity Provider's APIs](https://auth0.com/docs/connections/adding-scopes-for-an-external-idp)\n\n```\nPOST https://{yourDomain}/oauth/ro\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"username\": \"USERNAME\",\n  \"password\": \"PASSWORD\",\n  \"connection\": \"CONNECTION\",\n  \"scope\": \"openid\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/ro' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"username\":\"USERNAME\", \"password\":\"PASSWORD\", \"connection\":\"CONNECTION\", \"scope\":\"openid\"}'\n\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Trigger login using redirect with credentials to enterprise connections\n  webAuth.redirect.loginWithCredentials({\n    connection: 'Username-Password-Authentication',\n    username: 'testuser',\n    password: 'testpass',\n    scope: 'openid'\n  });\n\n  // Trigger login using popup mode with credentials to enterprise connections\n  webAuth.popup.loginWithCredentials({\n    connection: 'Username-Password-Authentication',\n    username: 'testuser',\n    password: 'testpass',\n    scope: 'openid'\n  });\n\n  // The client.login method allows for non redirect auth using custom database connections, using /oauth/token.\n  webAuth.client.login({\n    realm: 'tests',\n    username: 'testuser',\n    password: 'testpass',\n    scope: 'openid profile',\n    audience: 'urn:test'\n  });\n</script>\n```\n\n### POST /oauth/ro\n\nUse this endpoint for API-based (active) authentication. Given the user credentials and the `connection` specified, it will do the authentication on the provider and return a JSON with the Access Token and ID Token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application\n\n`username`  \nRequired\n\nUsername/email of the user to login\n\n`password`  \nRequired\n\nPassword of the user to login\n\n`connection`  \nRequired\n\nThe name of the connection to use for login\n\n`scope`\n\nSet to `openid` to retrieve also an ID Token, leave null to get only an Access Token\n\n`grant_type`  \nRequired\n\nSet to `password` to authenticate using username/password or `urn:ietf:params:oauth:grant-type:jwt-bearer` to authenticate using an ID Token instead of username/password, in [Touch ID](https://auth0.com/docs/libraries/lock-ios/touchid-authentication) scenarios.\n\n`device`\n\nString value. Required when `grant_type` is `urn:ietf:params:oauth:grant-type:jwt-bearer`\n\n`id_token`\n\nUsed to authenticate using a token instead of username/password, in [Touch ID](https://auth0.com/docs/libraries/lock-ios/touchid-authentication) scenarios. Required when `grant_type` is `urn:ietf:params:oauth:grant-type:jwt-bearer`\n\n*   This endpoint only works for database connections, passwordless connections, Active Directory/LDAP, Windows Azure AD and ADFS.\n    \n*   The main difference between passive and active authentication is that the former happens in the browser through the [Auth0 Login Page](https://{yourdomain}/login) and the latter can be invoked from anywhere (a script, server to server, and so forth).\n    \n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n    \n\n### Error Codes\n\nFor the complete error code reference for this endpoint, refer to [Errors > POST /oauth/ro](#post-oauth-ro).\n\n### Learn More\n\n*   [Database Identity Providers](https://auth0.com/docs/connections/database)\n*   [Rate Limits on User/Password Authentication](https://auth0.com/docs/policies/rate-limit-policy/database-connections-rate-limits)\n*   [Active Directory/LDAP Connector](https://auth0.com/docs/connector)\n\n## User Profile\n\n## Get Token Info\n\n```\nPOST https://{yourDomain}/tokeninfo\nContent-Type: application/json\n{\n  \"id_token\": \"ID_TOKEN\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/tokeninfo' \\\n  --header 'content-type: application/json' \\\n  --data '{\"id_token\":\"\"}'\n```\n\n```\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n</script>\n\nwebAuth.parseHash(window.location.hash, function(err, authResult) {\n  if (err) {\n    return console.log(err);\n  }\n\n  webAuth.client.userInfo(authResult.accessToken, function(err, user) {\n    // Now you have the user's information\n  });\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"email_verified\": false,\n  \"email\": \"foo@bar.com\",\n  \"clientID\": \"q2hnj2iug0...\",\n  \"updated_at\": \"2016-12-08T14:26:59.923Z\",\n  \"name\": \"foo@bar.com\",\n  \"picture\": \"https://s.gravatar.com/avatar/foobar.png\",\n  \"user_id\": \"auth0|58454...\",\n  \"nickname\": \"foo.bar\",\n  \"identities\": [\n    {\n      \"user_id\": \"58454...\",\n      \"provider\": \"auth0\",\n      \"connection\": \"Username-Password-Authentication\",\n      \"isSocial\": false\n    }\n  ],\n  \"created_at\": \"2016-12-05T11:16:59.640Z\",\n  \"global_client_id\": \"dfas76s...\"\n}\n```\n\n### POST /tokeninfo\n\nThis endpoint validates a JSON Web Token (JWT) (signature and expiration) and returns the user information associated with the user id `sub` property of the token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`id_token`  \nRequired\n\nThe ID Token to use.\n\n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n\n### Learn More\n\n*   [User Profile Struture](https://auth0.com/docs/users/references/user-profile-structure)\n    \n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits)\n    \n\n## Account Linking\n\n## Link\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  access_token=LOGGED_IN_USER_ACCESS_TOKEN\n```\n\n### GET /authorize\n\nCall this endpoint when a user wants to link a second authentication method (for example, a user/password database connection, with Facebook).\n\nThis endpoint will trigger the login flow to link an existing account with a new one. This will return a 302 redirect to the `connection` that the current user wants to add. The user is identified by the Access Token that was returned on login success.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nUse `code` for server side flows, `token` for client side flows\n\n`client_id`  \nRequired\n\nThe `client_id` of your application\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to [Auth0 Login Page](https://auth0.com/#/login_page) and show the Login Widget using the first database connection.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`access_token`  \nRequired\n\nThe logged-in user's Access Token\n\n*   The `redirect_uri` value must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n### Learn More\n\n*   [Link User Accounts](https://auth0.com/docs/users/guides/link-user-accounts)\n*   [Link User Accounts Initiated by Users Scenario](https://auth0.com/docs/users/references/link-accounts-user-initiated-scenario)\n*   [Link User Accounts Server-Side Scenario](https://auth0.com/docs/users/references/link-accounts-server-side-scenario)\n\n## Unlink\n\n```\nPOST https://{yourDomain}/login/unlink\nContent-Type: application/json\n{\n  \"access_token\": \"LOGGED_IN_USER_ACCESS_TOKEN\", // Primary identity Access Token\n  \"user_id\": \"LINKED_USER_ID\" // (provider|id)\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/login/unlink' \\\n  --header 'content-type: application/json' \\\n  --data '{\"access_token\": \"LOGGED_IN_USER_ACCESS_TOKEN\", \"user_id\": \"LINKED_USER_ID\"}'\n```\n\n```\nvar url = 'https://' + {yourDomain} + '/login/unlink';\nvar params = 'access_token=LOGGED_IN_USER_ACCESS_TOKEN&user_id=' + localStorage.getItem('user_id');\n\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', url);\nxhr.setRequestHeader('Content-Type', 'application/json');\n\nxhr.onload = function() {\n  if (xhr.status == 200) {\n    fetchProfile();\n  } else {\n    alert(\"Request failed: \" + xhr.statusText);\n  }\n};\n\nxhr.send(params);\n```\n\n### POST /login/unlink\n\nGiven a logged-in user's `access_token` and `user_id`, this endpoint will unlink a user's account from the identity provider.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`access_token`  \nRequired\n\nThe logged-in user's Access Token\n\n`user_id`  \nRequired\n\nThe logged-in user's `user_id`\n\n### Learn More\n\n*   [Unlink User Accounts](https://auth0.com/docs/users/guides/unlink-user-accounts)\n\n## Delegation\n\n```\nPOST https://{yourDomain}/delegation\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n  \"id_token\" or \"refresh_token\" : \"TOKEN\",\n  \"target\": \"TARGET_CLIENT_ID\",\n  \"scope\": \"openid\",\n  \"api_type\": \"API_TYPE\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/delegation' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"grant_type\":\"urn:ietf:params:oauth:grant-type:jwt-bearer\", \"id_token|refresh_token\":\"TOKEN\", \"target\":\"TARGET_CLIENT_ID\", \"scope\":\"openid\", \"api_type\":\"API_TYPE\"}'\n```\n\n```\n// Delegation is not supported in version 8 of auth0.js.\n// For a version 7 sample refer to: https://auth0.com/docs/libraries/auth0js/v7#delegation-token-request\n```\n\n### POST /delegation\n\nA delegation token can be obtained and used when an application needs to call the API of an Application Addon, such as Firebase or SAP, registered and configured in Auth0, in the same tenant as the calling program.\n\nGiven an existing token, this endpoint will generate a new token signed with the `target` app' secret. This is used to flow the identity of the user from the application to an API.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nΤhe `client_id` of your app\n\n`grant_type`  \nRequired\n\nUse `urn:ietf:params:oauth:grant-type:jwt-bearer`\n\n`id_token` or `refresh_token`  \nRequired\n\nThe existing token of the user.\n\n`target`\n\nThe target `client_id`\n\n`scope`\n\nUse `openid` or `openid profile email`\n\n`api_type`\n\nThe API to be called.\n\n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n    \n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n    \n*   Delegation is **not supported** in version 8 of [auth0.js](https://auth0.com/docs/libraries/auth0js). For a sample in version 7 of the library, refer to [Delegation Token Request](https://auth0.com/docs/libraries/auth0js/v7#delegation-token-request).\n    \n*   This endpoint limits up to 10 requests per minute from the same IP address with the same `user_id`.\n    \n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    \n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n\n### Learn More\n\n*   [Delegation Tokens](https://auth0.com/docs/tokens/delegation)\n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits)\n\n## Impersonation\n\n```\nPOST https://{yourDomain}/users/{user_id}/impersonate\nContent-Type:   application/json\nAuthorization:  'Bearer {ACCESS_TOKEN}'\n{\n  protocol: \"PROTOCOL\",\n  impersonator_id: \"IMPERSONATOR_ID\",\n  client_id: \"{yourClientId}\",\n  additionalParameters: [\n    \"response_type\": \"code\",\n    \"state\": \"STATE\"\n  ]\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/users/{user_id}/impersonate' \\\n  --header 'Authorization: Bearer {ACCESS_TOKEN}' \\\n  --header 'content-type: application/x-www-form-urlencoded; charset=UTF-8' \\\n  --data '{\"protocol\":\"PROTOCOL\", \"impersonator_id\":\"IMPERSONATOR_ID\", \"client_id\":\"{yourClientId}\", \"additionalParameters\": {\"response_type\": \"code\", \"state\": \"STATE\"}}'\n```\n\n```\nvar url = 'https://' + {yourDomain} + '/users/' + localStorage.getItem('user_id') + '/impersonate';\nvar params = 'protocol=PROTOCOL&impersonator_id=IMPERSONATOR_ID&client_id={yourClientId}';\n\nvar xhr = new XMLHttpRequest();\n\nxhr.open('POST', url);\nxhr.setRequestHeader('Content-Type', 'application/json');\nxhr.setRequestHeader('Authorization', 'Bearer ' + localStorage.getItem('access_token'));\n\nxhr.onload = function() {\n  if (xhr.status == 200) {\n    fetchProfile();\n  } else {\n    alert(\"Request failed: \" + xhr.statusText);\n  }\n};\n\nxhr.send(params);\n```\n\n> RESPONSE SAMPLE:\n\n```\nhttps:/YOUR_DOMAIN/users/IMPERSONATOR_ID/impersonate?&bewit=WFh0MUtm...\n```\n\n### POST /users/{user\\_id}/impersonate\n\nUse this endpoint to obtain an impersonation URL to login as another user. Useful for troubleshooting.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`protocol`  \nRequired\n\nThe protocol to use against the identity provider: `oauth2`, `samlp`, `wsfed`, `wsfed-rms`.\n\n`impersonator_id`  \nRequired\n\nThe `user_id` of the impersonator.\n\n`client_id`  \nRequired\n\nThe `client_id` of the client that is generating the impersonation link.\n\n`additionalParameters`\n\nThis is a JSON object. You can use this to set additional parameters, like `response_type`, `scope` and `state`.\n\n*   This endpoint can only be used with **Global Client** credentials.\n    \n*   To distinguish between real logins and impersonation logins, the profile of the impersonated user will contain additional impersonated and impersonator properties. For example: `\"impersonated\": true, \"impersonator\": {\"user_id\": \"auth0|...\", \"email\": \"admin@example.com\"}`.\n    \n*   For a regular web app, you should set the `additionalParameters`: set the `response_type` to be `code`, the `callback_url` to be the callback URL to which Auth0 will redirect with the authorization code, and the `scope` to be the JWT claims that you want included in the JWT.\n    \n\n## Resource Owner\n\n```\nPOST https://{yourDomain}/oauth/ro\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"connection\": \"CONNECTION\",\n  \"grant_type\": \"password\",\n  \"username\": \"USERNAME\",\n  \"password\": \"PASSWORD\",\n  \"scope\": \"SCOPE\",\n  \"id_token\": \"ID_TOKEN\",\n  \"device\": \"DEVICE\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/ro' \\\n  --header 'accept: application/json' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"connection\": \"CONNECTION\", \"grant_type\": \"password\", \"username\": \"USERNAME\", \"password\": \"PASSWORD\", \"scope\": \"SCOPE\", \"id_token\": \"ID_TOKEN\", \"device\": \"DEVICE\" }'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/ro',\n  headers: { 'content-type': 'application/json', 'accept': 'application/json' },\n  body:\n   { connection: 'CONNECTION',\n     grant_type: 'PASSWORD',\n     username: 'USERNAME',\n     client_id: '{yourClientId}',\n     password: 'PASSWORD',\n     scope: 'SCOPE',\n     id_token: 'ID_TOKEN',\n     device: 'DEVICE'},\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"access_token\": \"eyJz93a...\",\n  \"id_token\": \"eyJ0XAi...\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### POST /oauth/ro\n\nGiven the user's credentials, this endpoint will authenticate the user with the provider and return a JSON object with the Access Token and an ID Token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nYour application's Application ID.\n\n`connection`  \nRequired\n\nThe name of the connection configured to your application\n\n`grant_type`  \nRequired\n\nUse the value `password`\n\n`username`  \nRequired\n\nThe user's username\n\n`password`  \nRequired\n\nThe user's password\n\n`scope`\n\nUse `openid` to get an ID Token, `openid profile email` to get an ID Token and the user profile, or `openid offline_access` to get an ID Token and a Refresh Token.\n\n`id_token`\n\nUsed to authenticate using a token instead of username/password, in [Touch ID](https://auth0.com/docs/libraries/lock-ios/touchid-authentication) scenarios.\n\n`device`\n\nYou should set this to a string, if you are requesting a Refresh Token (`scope=offline_access`).\n\n*   This endpoint only works for database connections, passwordless connections, Active Directory/LDAP, Windows Azure AD and ADFS.\n    \n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n    \n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n    \n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /oauth/ro](#post-oauth-ro).\n\n### Learn More\n\n*   [Calling APIs from Highly Trusted Applications](https://auth0.com/docs/api-auth/grant/password)\n\nErrors\n\n## Standard Error Responses\n\nThe Authentication API may return the following HTTP Status Codes:\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_scope\", \"error_description\": \"Scope must be an array or a string\"}`\n\n401 Unauthorized\n\n`{\"error\": \"invalid_client\", \"error_description\": \"...\"}`\n\n401 Unauthorized\n\n`{\"error\": \"requires_validation\", \"error_description\": \"Suspicious request requires verification\"}`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"...\"}`\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"...\"}`\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"Unknown or invalid refresh token\"}`\n\n403 Forbidden\n\n`{\"error\": \"invalid_grant\", \"error_description\": \"...\"}`\n\n404 Not Found\n\n`{\"error\": \"endpoint_disabled\", \"error_description\": \"...\"}`\n\n405 Method Not Allowed\n\n`{\"error\": \"method_not_allowed\", \"error_description\": \"...\"}`\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_requests\", \"error_description\": \"...\"}`\n\n500 Internal Server Error\n\n501 Not Implemented\n\n`{\"error\": \"unsupported_response_type\", \"error_description\": \"...\"}`\n\n501 Not Implemented\n\n`{\"error\": \"unsupported_grant_type\", \"error_description\": \"...\"}`\n\n503 Service Unavailable\n\n`{\"error\": \"temporarily_unavailable\", \"error_description\": \"...\"}`\n\n## POST /oauth/revoke\n\nStatus\n\nJSON Response\n\n200 Success\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}`  \nThe Refresh Token is revoked, does not exist, or was not issued to the client making the revocation request\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}` The required parameters were not sent in the request.\n\n401 Unauthorized\n\n`{\"error\": \"invalid_client\", \"error_description\": \"...\"}`  \nThe request is not authorized. Check that the client credentials `client_id` and client\\_secret\\` are present in the request and hold valid values.\n\n## POST /oauth/access\\_token\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"}`  \nThe connection is not active or not enabled for your `client_id`.\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing client_id parameter\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing access_token parameter\"}`\n\n401 Unauthorized\n\n`{\"error\": \"invalid_request\", \"error_description\": \"invalid access_token: invalid_token\"}`  \nThe `access_token` is invalid or does not contain the set `scope`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"invalid client\"}`\n\n## POST /oauth/ro\n\n## Grant type: jwt-bearer\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing device parameter\"}`  \nYou need to provide a device name for the caller device (like a browser, app, and so on)\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing id_token parameter\"}`  \nFor this grant type you need to provide a JWT ID Token\n\n400 Bad Request\n\n`{\"error\": \"invalid_grant\", \"error_description\": \"...\"}`  \nErrors related to an invalid ID Token or user\n\n## Grant type: password\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"scope parameter must be a string\"}`  \nIncorrect scope formatting; each scope must be separated by whitespace\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"specified strategy does not support requested operation\"}`  \nThe connection/provider does not implement username/password authentication\n\n401 Unauthorized\n\n`{\"error\": \"invalid_user_password\", \"error_description\": \"Wrong email or password.\"}`\n\n401 Unauthorized\n\n`{\"error\": \"unauthorized\", \"error_description\": \"user is blocked\"}`\n\n401 Unauthorized\n\n`{ \"error\": \"password_leaked\", \"error_description\": \"This login has been blocked because your password has been leaked in another website. We’ve sent you an email with instructions on how to unblock it.\"}`\n\n401 Unauthorized\n\n`{ \"error\": \"requires_verification\", \"error_description\": \"Suspicious request requires verification\" }`\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_attempts\", \"error_description\": \"...\"}`  \nSome attack protection features will return this error\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_logins\", \"error_description\": \"...\"}`  \nSome attack protection features will return this error\n\n## All grant types\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing client_id parameter\"}<`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"}`  \nCheck the connection in the dashboard, you may have turned it off for the provided `client_id`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"The connection is not yet configured...\"}`  \nThe connection is not properly configured with custom scripts\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found for tenant...\"}`  \nThe connection does not belong to the tenant; check your base url\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"Fields with \".\" are not allowed, please remove all dotted fields...\"}`  \nIf you are using rules, some field name contains dots\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"invalid client\"}`  \nThe provided `client_id` is not valid\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"...\"}`  \nValidation of specific points raised an access issue\n\n## POST /passwordless/start\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - tenant validation failed: invalid_tenant\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.client_id\", \"error_description\": \"Missing required property: client_id\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Missing required property: connection\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Connection does not exist\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Connection is disabled\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Invalid connection strategy. It must either be a passwordless connection\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.authParams\", \"error_description\": \"error in authParams - invalid type: string (expected object)\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.request\", \"error_description\": \"the following properties are not allowed: <INVALID_PARAMETER_VALUE>\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.phone_number\", \"error_description\": \"Missing required property: phone_number\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.phone_number\", \"error_description\": \"String does not match pattern: ^\\\\+[0-9]{1,15}$\"}`\n\n400 Bad Request\n\n`{\"error\": \"sms_provider_error\", \"error_description\": \"<SPECIFIC_PROVIDER_MESSAGE> (Code: <SPECIFIC_PROVIDER_CODE>)\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\",\"error_description\": \"Expected` auth0-forwarded-for `header to be a valid IP address.\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - could not find tenant in params\"}`\n\n400 Bad Request\n\n`{\"error\": \"server_error\",\"error_description\": \"error resolving client\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\",\"error_description\": \"The client_id in the authentication header does not match the client_id in the payload\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Public signup is disabled\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Unknown error\"}`\n\n401 Unauthorized\n\n`{\"error\": \"server_error\",\"error_description\": \"user is blocked\"}`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\",\"error_description\": \"Client authentication is required\"}`\n\n500 Internal Server Error\n\n`{\"error\": \"server_error\",\"error_description\": \"IdP Error\"}`\n\n## POST /passwordless/verify\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing username parameter\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"scope parameter must be a string\"}`  \nIncorrect scope formatting; each scope must be separated by whitespace\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing client_id parameter\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"}`  \nCheck the connection in the dashboard, you may have turned it off for the provided `client_id`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found for tenant...\"}`  \nThe connection does not belong to the tenant; check your base url\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"Fields with \".\" are not allowed, please remove all dotted fields...\"}`  \nIf you are using rules, some field name contains dots\n\n400 Bad Request\n\n`\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - could not find tenant in params\"`\n\n400 Bad Request\n\n`{\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - tenant validation failed: \"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Connection does not exist\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Invalid connection strategy. It must either be a passwordless connection\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"The connection is disabled\"}`\n\n401 Unauthorized\n\n`{\"error\": \"invalid_user_password\", \"error_description\": \"Wrong email or password.\"}`\n\n401 Unauthorized\n\n`{\"error\": \"unauthorized\", \"error_description\": \"user is blocked\"}`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"invalid client\"}`  \nThe provided `client_id` is not valid\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"...\"}`  \nValidation of specific points raised an access issue\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_attempts\", \"error_description\": \"...\"}`  \nSome attack protection features will return this error\n\n500 Bad Request\n\n`{\"error\": \"server_error\",\"error_description\": \"...\"}`",
    "title": "Authentication API Explorer",
    "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens",
    "markdown": "# Tokens\n\nThere are two types of tokens that are related to identity: ID tokens and access tokens.\n\n## ID tokens\n\n[ID tokens](https://auth0.com/docs/secure/tokens/id-tokens) are [JSON web tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens) meant for use by the application only. For example, if there's an app that uses Google to log in users and to sync their calendars, Google sends an ID token to the app that includes information about the user. The app then parses the [token's contents](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) and uses the information (including details like name and profile picture) to customize the user experience.\n\nDo **not** use ID tokens to gain access to an API. Each token contains information for the intended audience (which is usually the recipient). According to the OpenID Connect specification, the audience of the ID token (indicated by the **aud** claim) must be the client ID of the application making the authentication request. If this is not the case, you should not trust the token.\n\nThe decoded contents of an ID token looks like the following:\n\n```\n{\n  \"iss\": \"http://{yourDomain}/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": \"{yourClientId}\",\n  \"exp\": 1311281970,\n  \"iat\": 1311280970,\n  \"name\": \"Jane Doe\",\n  \"given_name\": \"Jane\",\n  \"family_name\": \"Doe\",\n  \"gender\": \"female\",\n  \"birthdate\": \"0000-10-31\",\n  \"email\": \"janedoe@example.com\",\n  \"picture\": \"http://example.com/janedoe/me.jpg\"\n}\n```\n\nThis token authenticates the user to the application. The audience (the **aud** claim) of the token is set to the application's identifier, which means that only this specific application should consume this token.\n\nConversely, an API expects a token with the **aud** value to equal the API's unique identifier. Therefore, unless you maintain control over both the application and the API, sending an ID token to an API will generally not work. Since the ID token is not signed by the API, the API would have no way of knowing if the application had modified the token (e.g., adding more scopes) if it were to accept the ID Token. See the [JWT Handbook](https://auth0.com/resources/ebooks/jwt-handbook) for more information.\n\n## Access tokens\n\n[Access tokens](https://auth0.com/docs/secure/tokens/access-tokens) (which aren't always JWTs) are used to inform an API that the bearer of the token has been authorized to access the API and perform a predetermined set of actions (specified by the **scopes** granted).\n\nIn the Google example above, Google sends an access token to the app after the user logs in and provides consent for the app to read or write to their Google Calendar. Whenever the app wants to write to Google Calendar, it sends a request to the Google Calendar API, including the access token in the HTTP **Authorization** header.\n\nAccess tokens must **never** be used for [authentication](https://auth0.com/docs/authenticate). Access tokens cannot tell if the user has authenticated. The only user information the access token possesses is the user ID, located in the **sub** claim. In your applications, treat access tokens as opaque strings since they are meant for APIs. Your application should not attempt to decode them or expect to receive tokens in a particular format.\n\nHere is an example of an access token:\n\n```\n{\n  \"iss\": \"https://{yourDomain}/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": [\n    \"my-api-identifier\",\n    \"https://{yourDomain}/userinfo\"\n  ],\n  \"azp\": \"{yourClientId}\",\n  \"exp\": 1489179954,\n  \"iat\": 1489143954,\n  \"scope\": \"openid profile email address phone read:appointments\"\n}\n```\n\nNote that the token does not contain any information about the user besides their ID (**sub** claim). It only contains authorization information about which actions the application is allowed to perform at the API (**scope** claim). This is what makes it useful for securing an API, but not for authenticating a user.\n\nIn some situations, it may be desirable to put additional information about the user or other custom claims, besides their sub claim, in the access token to save the API from having to do extra work to fetch details about the user. If you choose to do this, bear in mind that these extra claims will be readable in the access token. To learn more, read [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n## Specialized tokens\n\nThere are three specialized tokens used in Auth0's token-based authentication scenarios:\n\n*   **Refresh tokens**: A token used to obtain a renewed access token without having to re-authenticate the user.\n    \n*   **IDP access tokens**: Access tokens issued by identity providers after user authentication that you can use to call the third-party APIs.\n    \n*   **Auth0 Management API access tokens**: Short-lived tokens containing specific claims (scopes) that allow you to call Management API endpoints.\n    \n\n## Learn more\n\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens)\n*   [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens)\n*   [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens)\n*   [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Tokens",
    "description": "Describes the types of tokens related to identity and authentication and how they are used by Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens",
    "markdown": "# Access Tokens\n\nAccess tokens are used in token-based authentication to allow an application to access an API. The application receives an access token after a user successfully authenticates and authorizes access, then passes the access token as a credential when it calls the target API. The passed token informs the API that the bearer of the token has been authorized to access the API and perform specific actions specified by the Scope that was granted during authorization.\n\nIn addition, if you have chosen to allow users to log in through an Identity Provider (IdP), such as Facebook, the IdP will issue its own access token to allow your application to call the IDP's API. For example, if your user authenticates using Facebook, the access token issued by Facebook can be used to call the Facebook Graph API. These tokens are controlled by the IdP and can be issued in any format. See [Identity Provider Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/identity-provider-access-tokens) for details.\n\n## Opaque access tokens\n\nOpaque access tokens are tokens in a proprietary format that you cannot access and typically contain some identifier to information in a server's persistent storage. To validate an opaque token, the recipient of the token needs to call the server that issued the token.\n\nIn Auth0's case, opaque tokens can be used with the `/userinfo` endpoint to return a user's profile. If you receive an opaque Access Token, you don't need to validate it. You can use it with the `/userinfo` endpoint, and Auth0 takes care of the rest. To learn more, see [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens).\n\n## JWT access tokens\n\nJSON Web Token (JWT) access tokens conform to the [JWT standard](https://tools.ietf.org/html/rfc7519) and contain information about an entity in the form of claims. They are self-contained therefore it is not necessary for the recipient to call a server to validate the token.\n\nAccess tokens issued for the Management API and access tokens issued for any custom API that you have registered with Auth0 follow the JWT standard, which means that their basic structure conforms to the typical [JWT structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure), and they contain standard [JWT claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims) asserted about the token itself.\n\n### Management API access tokens\n\nAn access token issued for the Auth0 Management API should be treated as opaque (regardless of whether it actually is), so you don't need to validate it. You can use it with the Auth0 Management API, and Auth0 takes care of the rest. To learn more, see [Auth0 Management API Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n\n### Custom API access tokens\n\nIf validation of your custom API access token fails, make sure it was issued with your custom API as the `audience`. To learn more, see [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens).\n\n## Sample access token\n\nThis example shows the contents of an access token. Notice that the token only contains authorization information about the actions the application is allowed to perform at the API (such permissions are referred to as `scopes`).\n\n```\n{\n  \"iss\": \"https://my-domain.auth0.com/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": [\n    \"https://example.com/health-api\",\n    \"https://my-domain.auth0.com/userinfo\"\n  ],\n  \"azp\": \"my_client_id\",\n  \"exp\": 1311281970,\n  \"iat\": 1311280970,\n  \"scope\": \"openid profile read:patients read:admin\"\n}\n```\n\nThe token does not contain any information about the user except for the user ID (located in the `sub` claim). In many cases, you may find it useful to retrieve additional user information. You can do this by calling the [userinfo API endpoint](https://auth0.com/docs/api/authentication#get-user-info) with the Access Token. Be sure that the API for which the Access Token is issued uses the **RS256** [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms).\n\n## Access token security\n\nYou should follow [token best practices](https://auth0.com/docs/secure/tokens/token-best-practices) when using access tokens, and for JWTs, make sure that you [validate an access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens) before assuming that its contents can be trusted.\n\n## Access token lifetime\n\n### Custom API token lifetime\n\nBy default, an access token for a custom API is valid for 86400 seconds (24 hours). We recommend that you set the validity period of your token based on the security requirements of your API. For example, an access token that accesses a banking API should expire more quickly than one that accesses a to-do API. To learn more, see [Update Access Token Lifetime](https://auth0.com/docs/secure/tokens/access-tokens/update-access-token-lifetime).\n\n### /userinfo endpoint token lifetime\n\nAccess tokens issued strictly for the purpose of accessing the OIDC `/userinfo` endpoint have a default lifetime and can't be changed. The length of lifetime depends on the flow used to obtain the token:\n\n| Flow | Lifetime |\n| --- | --- |\n| Implicit | 7200 seconds (2 hours) |\n| Authorization Code/Hybrid | 86400 seconds (24 hours) |\n\n## Learn more\n\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Use Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/use-access-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Access Tokens",
    "description": "Describes how access tokens are used in token-based authentication to allow an application to access an API after a user successfully authenticates and authorizes access.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/refresh-tokens",
    "markdown": "# Refresh Tokens\n\nAuth0 issues an access token or an ID token in response to an authentication request. You can use access tokens to make authenticated calls to a secured API, while the ID token contains user profile attributes represented in the form of claims. Both are JSON web tokens (JWTs) and therefore have expiration dates indicated using the `exp` claim, as well as security measures, like signatures. Typically, a user needs a new access token when gaining access to a resource for the first time, or after the previous access token granted to them expires.\n\nAn OAuth Refresh Token is a credential artifact that OAuth can use to get a new access token without user interaction. This allows the Authorization Server to shorten the access token lifetime for security purposes without involving the user when the access token expires. You can request new access tokens until the refresh token is on the DenyList.\n\nIt is important to keep the number of refresh tokens within a reasonable manageable limit to make sure that it’s easy to maintain those credentials safely and securely. Applications must store refresh tokens securely because they essentially allow a user to remain authenticated forever.\n\n#### Offline access\n\nIf you want to allow users to get refresh tokens while offline, you can select the **Allow Offline Access** switch in [API Settings](https://auth0.com/docs/get-started/apis/api-settings).\n\nYou can increase security by using [refresh token rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation) which issues a new refresh token and invalidates the predecessor token with each request made to Auth0 for a new access token. Rotating the refresh token reduces the risk of a compromised refresh token.\n\n### Limitations\n\nAuth0 limits the amount of active refresh tokens to 200 tokens per user per application. This limit only applies to active tokens. If the limit is reached and a new refresh token is created, the system revokes and deletes the oldest token for that user and application. Revoked tokens and expired tokens do not count against the limit. To review our recommendations and best practices to avoid excess tokens, read [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices).\n\n### Enable OIDC Flag\n\nThe refresh token behavior is applicable to OIDC-conformant applications. You can configure an application to be OIDC-conformant in one of the following ways:\n\n1.  Enabling the **OIDC Conformant** flag for an app.\n    \n2.  Passing an `audience` claim to the `/authorize` endpoint of the Authentication API.\n    \n\n## SDK support\n\n### For web apps\n\nAuth0 SDKs support refresh tokens including:\n\n*   Node.js\n    \n*   ASP.NET Core\n    \n*   PHP\n    \n*   Java\n    \n\nFor a complete listing, see [Quickstarts](https://auth0.com/docs/quickstart/webapp).\n\n### For single-page apps\n\nProviding secure authentication in SPAs has a number of challenges based on your application’s use case. New browser privacy controls like Intelligent Tracking Prevention (ITP) adversely impact the user experience in SPAs by preventing access to third-party cookies.\n\nAuth0 recommends using refresh token rotation which provides a secure method for using refresh tokens in SPAs while providing end-users with seamless access to resources without the disruption in UX caused by browser privacy technology like ITP.\n\n### For native/mobile apps\n\nFor native applications, refresh tokens improve the authentication experience significantly. The user has to authenticate only once, through the web authentication process. Subsequent re-authentication can take place without user interaction, using the refresh token.\n\nFor information on using refresh tokens with our mobile SDKs, see:\n\n*   [Mobile/Native Quickstarts](https://auth0.com/docs/quickstart/native)\n    \n*   [Lock Android: Refresh JWT Tokens](https://auth0.com/docs/libraries/lock-android/lock-android-refresh-jwt)\n    \n*   [Lock iOS: Save and Renew JWT Tokens](https://auth0.com/docs/libraries/auth0-swift/auth0-swift-save-and-renew-tokens)\n    \n\n## Learn more\n\n*   [Get Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens)\n*   [Use Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Refresh Tokens",
    "description": "Describes how refresh tokens work to allow the application to ask Auth0 to issue a new access token or ID token without having to re-authenticate the user.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication",
    "markdown": "# Multi-Factor Authentication (MFA)\n\n#### Overview\n\nMulti-factor Authentication (MFA) is another method of securing your application and your users' identities. MFA adds a layer of security during login that requires users to provide more than one credential to prove their digital identity. Factors can be:\n\n*   Something you are - like a biometric\n    \n*   Something you know - like a password\n    \n*   Something you own - like a device\n    \n\nRead this Q&A to see if using MFA with your Auth0 instance is the right choice for you.\n\n## What is multi-factor authentication?\n\nMulti-factor authentication (MFA) is a user verification method that requires more than one type of user validation. It prevents bad actors from accessing an account even if they've acquired the username and password.\n\n## Why use multi-factor authentication?\n\nMFA reduces the likelihood of many types of cyber-attacks. It's common for third parties to steal user names and passwords or programmatically attack user accounts. An additional MFA factor, such as a thumbprint or one-time password, impedes these violations.\n\n## How does multi-factor authentication work?\n\nMFA works by requiring additional verification information (known as factors). Users can't log in using only user names and passwords. They must provide further proof of identity, such as face recognition or text message notifications.\n\n## MFA factors\n\nAuth0 supports a variety of MFA factors, including:\n\n*   Push notifications\n    \n*   SMS notifications\n    \n*   Voice notifications\n    \n*   One-time passwords\n    \n*   WebAuthn with security keys\n    \n*   WebAuthn with device biometrics\n    \n*   Email notifications\n    \n*   Cisco Duo security\n    \n*   Recovery codes\n    \n\nTo learn more, read [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n\n## Enable MFA\n\nTo learn how to enable MFA, read [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa).\n\n## Customize MFA\n\nYou can also use [Auth0 Actions](https://auth0.com/docs/customize/actions) to customize your MFA flow. You can require MFA only in specific circumstances or force use of a particular factor.\n\n## Learn more\n\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)\n*   [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa)\n*   [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa)\n*   [Multi-Factor Authentication Developer Resources](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources)\n*   [Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
    "title": "Multi-Factor Authentication (MFA)",
    "description": "Describes how multi-factor authentication (MFA) works in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts",
    "markdown": "# Link User Accounts\n\nLink user accounts together to form a primary and secondary relationship. On successful linking, the endpoint returns the new array of the primary account identities.\n\nAuth0 supports the linking of user accounts from various identity providers. This allows a user to authenticate from any of their accounts and still be recognized by your app and associated with the same user profile.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nAuth0 treats all identities as separate by default. For example, if a user logs in first against the Auth0 database and then via Google or Facebook, these two attempts would appear to Auth0 as two separate users.\n\nThere are three ways to link accounts:\n\n*   Use the Account Link extension\n    \n*   Use the Management API\n    \n*   Use Auth0.js\n    \n\nUse the tabs below to see the details for each option.\n\n*   [Account Link Extension](#extension)\n*   [Management API](#mgmt-api)\n*   [Auth0 js](#auth0js)\n\n## Account Link extension\n\nInstall and configure the [Account Link Extension](https://auth0.com/docs/extensions/account-link) extension in the Dashboard to prompt users that may have created a second account to link the new account with their old one on their first login. The user can choose to either link the two accounts or keep them separate if it was intentional.\n\n## Management API endpoint\n\nThe Auth0 Management API provides the [Link a user account](https://auth0.com/docs/api/v2#!/Users/post_identities) endpoint, which can be invoked in two ways:\n\n*   User initiated account linking using Access Tokens with the `update:current_user_identities` scope\n*   Server-side account linking using Access Token that contains the `update:users` scope\n\n### User initiated client-side account linking\n\nFor user initiated account linking from client-side code, use an Access Token that contains the following items in the payload:\n\n*   `update:current_user_identites` scope\n*   `user_id` of the primary account as part of the URL\n*   ID Token of the secondary account must be signed with `RS256` and an `aud` claim identifying the client that matches the value of the requesting Access Token's `azp` claim.\n\nAn Access Token that contains the `update:current_user_identities` scope can **only** be used to update the information of the currently logged-in user. Therefore, this method is suitable for scenarios where the user initiates the linking process.\n\n```\n{\n  \"method\": \"POST\",\n  \"url\": \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\",\n  \"httpVersion\": \"HTTP/1.1\",\n  \"headers\": [{\n    \"name\": \"Authorization\",\n    \"value\": \"Bearer ACCESS_TOKEN\"\n  },\n  {\n    \"name\": \"content-type\",\n    \"value\": \"application/json\"\n  }],\n  \"postData\" : {\n    \"mimeType\": \"application/json\",\n    \"text\": \"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\"\n  }\n}\n```\n\n### Server-side account linking\n\nFor server-side account linking, use an Access Token that contains the following items in the payload:\n\n*   `update:users` scope\n*   `user_id` of the primary account as part of the URL\n*   `user_id` of the secondary account\n*   ID Token of the secondary account must be signed with `RS256` and an `aud` claim identifying the client that matches the value of the requesting Access Token's `azp` claim.\n\nAccess Tokens that contain the `update:users` scope can be used to update the information of **any** user. Therefore, this method is intended for use in server-side code only.\n\n```\n{\n  \"method\": \"POST\",\n  \"url\": \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\",\n  \"httpVersion\": \"HTTP/1.1\",\n  \"headers\": [{\n    \"name\": \"Authorization\",\n    \"value\": \"Bearer ACCESS_TOKEN\"\n  },\n  {\n    \"name\": \"content-type\",\n    \"value\": \"application/json\"\n  }],\n  \"postData\" : {\n    \"mimeType\": \"application/json\",\n    \"text\": \"{\\\"provider\\\":\\\"SECONDARY_ACCOUNT_PROVIDER\\\", \\\"user_id\\\": \\\"SECONDARY_ACCOUNT_USER_ID\\\"}\"\n  }\n}\n```\n\nThe `SECONDARY_ACCOUNT_USER_ID` and `SECONDARY_ACCOUNT_PROVIDER` can be deduced by the unique ID of the user. For example, if the user ID is `google-oauth2|108091299999329986433`, set the `google-oauth2` part as the `provider`, and the `108091299999329986433` part as the `user_id` at your request.\n\nInstead of the `provider` and `user_id`, you can send the secondary account's ID Token as part of the payload:\n\n```\n{\n  \"method\": \"POST\",\n  \"url\": \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\",\n  \"httpVersion\": \"HTTP/1.1\",\n  \"headers\": [{\n    \"name\": \"Authorization\",\n    \"value\": \"Bearer ACCESS_TOKEN\"\n  },\n  {\n    \"name\": \"content-type\",\n    \"value\": \"application/json\"\n  }],\n  \"postData\" : {\n    \"mimeType\": \"application/json\",\n    \"text\": \"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\"\n  }\n}\n```\n\n## Auth0.js library\n\nYou can use the [Auth0.js](https://auth0.com/docs/libraries/auth0js) library.\n\nFirst, you must get an Access Token that can be used to call the Management API. You can do it by specifying the `https://{yourDomain}/api/v2/` audience when initializing Auth0.js. You will get the Access Token as part of the authentication flow. Alternatively, you can use the `checkSession` method.\n\nOnce you have the Access Token, you can create a new `auth0.Management` instance by passing it the account's Auth0 domain, and the Access Token.\n\nTo learn more, read [Auth0.js > User management](https://auth0.com/docs/libraries/auth0js/v9#user-management).\n\n## Add missing information with Rules\n\nWhen a user logs in, apps receive user information from the **primary identity**. Auth0 does not attempt to automatically complete missing profile fields with information from the secondary identities. For example, if the primary identity comes from a database connection and is missing the `given_name` and `family_name` properties, and the secondary identity comes from a Google social connection that includes the first and last name of the user, then the application will **not** receive data contained in the second identity.\n\nTo add missing information to primary identities with information from secondary identities, you can write a rule like the following example:\n\n```\nfunction(user, context, callback) {\n  \n  const propertiesToComplete = [\"given_name\", \"family_name\", \"name\"];\n\n  // go over each property and try to get missing\n  // information from secondary identities\n  for(var property of propertiesToComplete) {\n    if (!user[property]) {\n      for(var identity of user.identities) {\n        if (identity.profileData && identity.profileData[property]) {\n          user[property] = identity.profileData[property];\n          break;\n        }\n      }\n    }\n  }\n  \n  callback(null, user, context);\n}\n```\n\n## Account linking with Actions\n\nAuth0 Actions can be used to call the Management API to link user accounts. Auth0 does not automatically change to the correct primary user after Account Linking, so it must be changed within the Actions code upon successful Account Linking.\n\n#### Account linking with Actions\n\nActions allows for flexible extension of the Auth0 capabilities, and caution must be taken when linking user accounts.\n\nInsecurely linking accounts can allow malicious actors to access legitimate user accounts.\n\nPlease remain aware of the following:\n\n**Every** manual account link should prompt the user to enter credentials. Your tenant should request authentication for **both** accounts before linking occurs.\n\n### Example account linking with Actions\n\nA basic Account Linking implementation is as follows:\n\n1.  Identify potential user accounts to link with an Action.\n    \n2.  Redirect to an external linking app using the [Actions redirect functionality](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions) and token.\n    \n3.  Require the user to authenticate using their credentials for all accounts they wish to link.\n    \n4.  Redirect back to the Action with the outcome of the authentication encoded in a signed JWT and validate the authenticity and contents in that token.\n    \n5.  Perform Account Linking with a Management API call based on the results.\n    \n6.  Switch to the primary user for the remainder of the transaction using Actions.\n    \n\nIn order to perform those steps, an example Post-Login Action may contain the following:\n\n```\n// @ts-check\nconst { ManagementClient } = require(\"auth0\");\n\n// High-level Workflow for Performing Account Linking in Actions\n// --------------------------------------------------------------------------------------------\n//\n// The goal of this workflow is to systematically process all users for potential account\n// linking. We want to detect situations where an end-user\n// may have other identities in Auth0. These other identities would be discovered through\n// matching verified email addresses. The Auth0 Action will ensure that all users are processed\n// for account linking.\n//\n// A redirect app will be hosted by the customer to which we will redirect the user's browser\n// when account linking might be available. The customer's account linking app is responsible\n// authenticating that the current user owns the candidate linking identities. It will actually\n// perform the account linking via Management API before redirecting back to the login flow's\n// `/continue?state` endpoint.\n//\n// The Action will pick up here and update the primary user for the login if necessary and mark\n// the user as having been successfully processed.\n//\n// Here are the details of the workflow:\n//\n// 1. Check if the user has been processed for account linking. The state for this is encoded in\n//    the user's `app_metadata`. If the user has already been processed, exit this flow.\n// 2. Discover other user identities that are candidates for account linking. If candidates are\n//    found:\n//   1. Encode the current user and any candidate identities into a signed session token to be\n//      passed to the account linking app.\n//   2. Redirect the user's browser to the account linking app with the signed session token.\n//   3. The account linking app should challenge the user to authenticate using the candidate\n//      identities.\n//   4. If the user choses to proceed with account linking and successfully authenticates with\n//      candidate identities, determine the primary user under which to consolidate identities.\n//   5. Use the management API to perform account linking and to map any user or app metadata\n//      from the other user accounts into the new primary user account.\n//   6. Redirect back to `/continue?state` with a new signed token encoding the primary user\n//      that is the outcome of the account linking app.\n//   7. Validate the returned session token in the `onContinuePostLogin` entrypoint of the\n//      Action. If a change of primary user is required, change the primary user via\n//      `api.authentication.setPrimaryUser(newPrimaryUserId)`.\n// 3. Mark the user as having been processed for account linking by storing a flag in the\n//    user's `app_metadata`.\n\nconst LINKING_STATE_KEY = 'account_linking_state';\n\n/**\n * Handler that will be called during the execution of a PostLogin flow.\n *\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  if (!event.user.email_verified) {\n    // We won't process users for account linking until they have verified their email address.\n    // We might consider rejecting logins here or redirecting users to an external tool to\n    // remind the user to confirm their email address before proceeding.\n    //\n    // In this example, we simply won't process users unless their email is verified.\n    return;\n  }\n\n  const accountLinkingState = event.user.app_metadata[LINKING_STATE_KEY];\n\n  if (accountLinkingState) {\n    // Account linking has already been processed and completed for this user. No further work\n    // to be done in this Action.\n    return;\n  }\n\n  const token = await getManagementApiToken(event, api);\n  const domain = event.secrets.TENANT_DOMAIN;\n  const management = new ManagementClient({ domain, token });\n\n  // Search for other candidate users\n  const { data: candidateUsers } = await management.usersByEmail.getByEmail({\n    email: event.user.email,\n  });\n\n  if (!Array.isArray(candidateUsers)) {\n    return;\n  }\n\n  const candidateIdentities = candidateUsers.flatMap((user) => user.identities);\n\n  if (!candidateIdentities.length) {\n    // No candidate users for linking so mark the user as processed.\n    api.user.setAppMetadata(LINKING_STATE_KEY, Date.now());\n  }\n\n  // Encode the current user and an array of their \n  const sessionToken = api.redirect.encodeToken({\n    payload: {\n      current_user: event.user,\n      candidate_identities: candidateIdentities,\n    },\n    secret: event.secrets.REDIRECT_SECRET,\n    expiresInSeconds: 20,\n  });\n\n  api.redirect.sendUserTo('https://url.for/account/linking/service', {\n    query: { session_token: sessionToken },\n  });\n};\n\n/**\n * Handler that will be invoked when this action is resuming after an external redirect. If your\n * onExecutePostLogin function does not perform a redirect, this function can be safely ignored.\n *\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onContinuePostLogin = async (event, api) => {\n  // Validate the session token passed to `/continue?state` and extract the `user_id` claim. \n  const { user_id } = api.redirect.validateToken({\n    secret: event.secrets.REDIRECT_SECRET,\n    tokenParameterName: 'session_token',\n  });\n\n  if (user_id !== event.user.user_id) {\n    // The account linking service indicated that the primary user changed.\n    api.authentication.setPrimaryUser(user_id);\n  }\n\n  // Mark the user as having been processed for account linking\n  api.user.setAppMetadata(LINKING_STATE_KEY, Date.now());\n};\n```\n\n## Learn more\n\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)\n*   [User-Initiated Account Linking: Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)\n*   [Unlink User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/unlink-user-accounts)",
    "title": "Link User Accounts",
    "description": "Understand how to link user accounts from various identity providers, so your users can authenticate from any account and be recognized by your app.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/cross-origin-authentication",
    "markdown": "# Cross-Origin Authentication\n\nAuth0 strongly recommends that authentication transactions be handled via [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) because it is the easiest and most secure way to authenticate users. To learn more, read [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login). There are a limited number of situations that may require that authentication forms be directly embedded in an application. Although not recommended, cross-origin authentication provides a way to do this.\n\n## What is cross-origin authentication?\n\nWhen authentication requests are made from your application (via the Lock widget or a custom login form) to Auth0, the user's credentials are sent to a domain that differs from the one that serves your application. Collecting user credentials in an application served from one origin and then sending them to another origin can present certain security vulnerabilities, including the possibility of a phishing attack.\n\nAuth0 provides a cross-origin authentication flow that uses third-party cookies. The use of third-party cookies allows Lock and Auth0's backend to perform the necessary checks to allow for secure authentication transactions across different origins. This helps to prevent phishing when creating a Single Sign-on experience with the Lock widget or a custom login form in your application and it also helps to create a secure login experience even if SSO is not the goal.\n\nCross-origin authentication is not recommended and is only necessary when authenticating against a directory using a username and password. Social IdPs and enterprise federation use a different mechanism, redirecting via standard protocols like OpenID Connect and SAML. Additionally, cross-origin authentication is only applicable to embedded login on the web (using Lock or auth0.js). Native applications using embedded login make use of the standard OAuth 2.0 Token endpoint.\n\n## Limitations\n\nBecause cross-origin authentication is achieved using third-party cookies, disabling third-party cookies will make cross-origin authentication fail. Some browsers, such as the newest version of Firefox, disable third-party cookies by default, meaning that cross-origin authentication will not work for users on Firefox. The only way to make embedded login work for Firefox users is to use a custom domain, as described below.\n\nThere are two approaches you can follow to remediate the issue:\n\n*   Enable a [Custom Domain](https://auth0.com/docs/customize/custom-domains) on your tenant and host your web application in a domain that has the same top-level domain as your Auth0 custom domain. For example, you host an application at `https://northwind.com` and set your Auth0 custom domain as `https://login.northwind.com`. This way the cookies are no longer third-party (because both your Auth0 tenant and your application are using the same top-level domain), and thus, are not blocked by browsers.\n    \n*   Create and link a cross-origin verification page that will make cross-origin authentication work in a limited number of browsers even with third-party cookies disabled.\n    \n\n## Learn more\n\n*   [Configure Cross-Origin Resource Sharing](https://auth0.com/docs/get-started/applications/set-up-cors)\n*   [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login)\n*   [Migrate from Embedded Login to Universal Login](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-embedded-login-to-universal-login)\n*   [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login)",
    "title": "Cross-Origin Authentication",
    "description": "An explanation of cross-origin authentication in Auth0 and its compatibility with browsers",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains",
    "markdown": "# Custom Domains\n\nIf you have a paid Auth0 subscription, you can use your own domain name (also known as a CNAME or vanity URL) on authentication pages. A custom domain lets you unify the login experience with your own brand and products. Your users see a URL that displays your brand such as `login.YOUR_DOMAIN.com` instead of `YOUR_DOMAIN.auth0.com.` The custom domain in Auth0 is like a \"mask\" for your tenant domain URL.\n\nYou can configure your custom domain when you create your tenant or you can add a custom domain to an existing implementation with minor code and configuration changes.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Benefits of using a custom domain\n\nWith a custom domain, your users feel confident that they are providing their credentials to the right party. Authentication happens within the context of your brand which helps you build brand loyalty. Users are not redirected to a third-party site that breaks the branding context. This prevents users from becoming confused about whether they are still making a transaction or operation with you.\n\nContaining your authentication services in one place makes your application architecture more maintainable. Applications gain only the access they need and authentication services scale easily. Other security benefits of using a custom domain include:\n\n*   Some browsers, by default, make it difficult to communicate in an iFrame if you don't have a shared domain.\n    \n*   It's harder to phish your domain if you have a vanity URL because the phisher must create a vanity URL to mimic yours. For example, with a custom domain, you can use your own certificate to get an Extended Validation, making phishing harder.\n    \n\n## How it works\n\nYou configure a custom domain on the [Auth0 Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/custom_domains) tab in the Auth0 Dashboard. Add your custom domain, choose your certification type and follow the instructions. You will complete a verification process for your domain that varies depending on whether you use an Auth0-managed or a self-managed certificate. When you create a CNAME, you must declare it to Auth0 so that Auth0 can verify it and use the custom domain. After you configure and verify the custom domain, you must [configure the Auth0 features](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains) to use the new custom domain.\n\nAuth0 recommends that you create your custom domain during the development phase (before you go to production) so that you can ensure that you have managed the CNAME correctly. For example, you can create a CNAME that maps `login.YOUR_DOMAIN.com` to `YOUR_DOMAIN.auth0.com`.\n\nYou can update an existing tenant to use a custom domain. Your existing integrations using `YOUR_DOMAIN.auth0.com` will continue to work. After the change, your users must log in again because existing sessions will no longer be valid. In addition, users may need to delete the browser cookie associated with your custom domain if errors are present during login. If you use embedded Lock or an SDK, you can choose to use the standard domain setting or a custom domain.\n\n### Custom domains and authentication\n\nThe following Auth0 authentication features support the use of custom domains.\n\n| **Feature or Flow** | **Details** |\n| --- | --- |\n| Universal Login | For a seamless and secure user experience |\n| MFA | All factors |\n| Guardian | Android SDK/Swift SDK/MFA Widget version 1.3.3/Guardian.js version 1.3.0 or later |\n| Emails | Links included in the emails use your custom domain |\n| Connections | Database, social, Google Workspace, Azure AD, ADFS, AD/LDAP |\n| Lock | Version 11 with cross-origin authentication |\n| Passwordless | With Universal Login (The email link sent using the custom domain if the option is enabled in **Dashboard > Tenant Settings > Custom Domains**.) |\n| SAML | Connections and applications |\n| WS-Federation | Auth0 as identity provider using WS-Fed add-on |\n| OAuth 2.0/OIDC-Compliant flows | Using the [`/authorize`](https://auth0.com/docs/api/authentication#authorize-application) and [`/oauth/token`](https://auth0.com/docs/api/authentication#get-token) endpoints |\n\n### Custom domains and URIs\n\nAuth0 uses certain metadata endpoints for interoperability and configuration of third-party identity providers and applications. When the metadata contains URIs that point back to Auth0, the URL can be either the Auth0 subdomain or your custom domain depending on the hostname you used to request the metadata. For example:\n\n| **If you use** | **Reference Inside Metadata** |\n| --- | --- |\n| `https://travel0.auth0.com/.well-known/...` | `https://travel0.auth0.com/...` |\n| `https://travel0.auth0.com/samlp/metadata/...` | `https://travel0.auth0.com/...` |\n| `https://login.travel0.com/samlp/metadata/...` | `https://login.travel0.com/...` |\n\nTo learn more, review [Redirect Users After Login](https://auth0.com/docs/authenticate/login/redirect-users-after-login).\n\nThis flexibility applies to the following authentication scenarios:\n\n*   [Configure Applications with OpenID Connect Discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery)\n    \n*   [Configure Auth0 as SAML Service Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider)\n    \n*   [Configure Auth0 as SAML Identity Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider)\n    \n\n### Custom domains and token requests\n\nAuth0 issues tokens with the `iss` claim for the domain you used with the token request. For example:\n\n| **If you use** | **Claim value for iss** |\n| --- | --- |\n| `https://travel0.auth0.com/authorize...`  <br>`https://travel0.auth0.com/oauth/token...` | `https://travel0.auth0.com/` |\n| `https://login.travel0.com/authorize...`  <br>`https://login.travel0.com/oauth/token...` | `https://login.travel0.com/` |\n\nIf you obtain an access token for the Management API using an authorization flow with your custom domain, you must call the Management API using the custom domain or your token will be considered invalid. The token's `iss` claim is independent of the audience. Audience values remain the same for tokens obtained using a custom domain. To learn more about tokens, review [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n\n## Certificate management options\n\n### Auth0-managed certificates\n\nAuth0 can manage the certificates for your custom domain and manage the SSL handshake directly. You add a CNAME record on the domain, Auth0 validates the record and generates the certificate on Auth0 servers. The certificate renews automatically every three months. Once verified, [configure your Auth0 features](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains) to start using your custom domain. To learn more, review [Configure Custom Domains with Auth0-Managed Certificates](https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates).\n\n### Self-managed certificates\n\nYou can obtain and [manage your own certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates) in Custom Domains. In this case, you are responsible for handling SSL certificates and setting up and managing a reverse proxy to send content to Auth0. Auth0 negotiates SSL with the proxy not directly with the end-user client. The proxy, in turn, negotiates SSL with the end-user. To prevent someone from trying to use your Auth0 account from a domain you don't own, Auth0 needs to validate that the domain belongs to you: You need to provide Auth0 with a header (`cname-api-key`) to validate. You must be an Auth0 Enterprise subscriber to use this option.\n\nAuth0 provides instructions to configure a reverse proxy for the following providers:\n\n*   [Google Cloud Platform with Load Balancing](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-gcp-as-reverse-proxy)\n    \n*   [Cloudflare](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy)\n    \n*   [AWS CloudFront](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-aws-cloudfront-for-use-as-reverse-proxy)\n    \n*   [Azure CDN](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-azure-cdn-for-use-as-reverse-proxy)\n    \n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Configure Custom Domains with Auth0-Managed Certificates](https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates)\n*   [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [Migrate Private Cloud Custom Domains](https://auth0.com/docs/migrate-private-cloud-custom-domains)",
    "title": "Custom Domains",
    "description": "Understand how a custom domain (CNAME or vanity URL) can help you unify your brand and show continuity to your users.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/libraries/lock/lock-api-reference",
    "markdown": "# Lock API Reference\n\nLock has many methods, features, and configurable options. This reference is designed to direct you to the ones that you need, and discuss how to use them. Click below to go straight the method you're looking for, or just browse! If you're looking for information about events emitted by Lock, they're listed under the [on()](#on-) method section!\n\n*   [new Auth0Lock](#auth0lock) - Instantiating Lock\n    \n*   [getUserInfo()](#getuserinfo-) - Obtaining the profile of a logged in user\n    \n*   [show()](#show-) - Showing the Lock widget\n    \n*   [on()](#on-) - Listening for events\n    \n*   [resumeAuth()](#resumeauth-) - Use to complete authentication flow when `autoParseHash` is false\n    \n*   [checkSession()](#checksession-) - Get a new token from Auth0 for an authenticated user\n    \n*   [logout()](#logout-) - Log out the user\n    \n\n## Auth0Lock\n\n`new Auth0Lock(clientID, domain, options)`\n\nInitializes a new instance of `Auth0Lock` configured with your application's `clientID` and your account's `domain` from your [Auth0](https://manage.auth0.com/#/) management dashboard. The third and optional parameter is an `options` object used to configure Lock for your application's needs. You can find this information at your [application settings](https://manage.auth0.com/#/applications).\n\n*   **clientId {String}**: Required parameter. Your application's clientId in Auth0.\n    \n*   **domain {String}**: Required parameter. Your Auth0 domain. Usually your-account.auth0.com.\n    \n*   **options {Object}**: Optional parameter. Allows for the configuration of Lock's appearance and behavior. See [the configuration options page](https://auth0.com/docs/libraries/lock/lock-configuration) for details.\n    \n\nto configure this snippet with your account\n\n```\nvar Auth = (function() {\n\n  var privateStore = {};\n\n  function Auth() {\n    // Instantiate Lock - without custom options\n    this.lock = new Auth0Lock(\n      '<{yourClientId}>',\n      '<{yourDomain}>'\n    );\n  }\n\n  Auth.prototype.getProfile = function() {\n    return privateStore.profile;\n  };\n\n  Auth.prototype.authn = function() {\n    // Listening for the authenticated event and get profile\n    this.lock.on(\"authenticated\", function(authResult) {\n      // Use the token in authResult to getUserInfo() and save it if necessary\n      this.getUserInfo(authResult.accessToken, function(error, profile) {\n        if (error) {\n          // Handle error\n          return;\n        }\n\n        //save Access Token only if necessary\n        privateStore.accessToken = accessToken;\n        privateStore.profile = profile;\n\n        // Update DOM\n      });\n    });\n  };\n  return Auth;\n}());\n```\n\n## getUserInfo()\n\n`getUserInfo(accessToken, callback)`\n\nOnce the user has logged in and you are in possession of a token, you can use that token to obtain the user's profile with `getUserInfo`. This method replaces the deprecated `getProfile()`.\n\n*   **accessToken {String}**: User token.\n    \n*   **callback {Function}**: Will be invoked after the user profile been retrieved.\n    \n\n```\nlock.getUserInfo(accessToken, function(error, profile) {\n  if (!error) {\n    alert(\"hello \" + profile.name);\n  }\n});\n```\n\n## show()\n\n`show(options)`\n\nThe `show` method displays the widget. Beginning with Lock version 10.2.0, the `show` method can now accept an `options` object as a parameter. Note that this parameter is meant to be used as a way to override your Lock's `options` for this particular displaying of the widget - options should be set when instantiating Lock, and overridden, only if needed for your specific use case, here.\n\nThe following subset of `options` to be overridden from the values they were given (or their defaults) when Lock was instantiated:\n\n*   allowedConnections\n    \n*   auth.params\n    \n*   allowLogin\n    \n*   allowSignUp\n    \n*   allowForgotPassword\n    \n*   initialScreen\n    \n*   rememberLastLogin\n    \n\nFor more detail on the entire list of configurable options that can be chosen when instantiating Lock, as opposed to the limited subset above that can be overridden in the `show` method, please see the [user configurable options page](https://auth0.com/docs/libraries/lock/lock-configuration).\n\nOptions override examples:\n\n```\n// Show the Lock widget, without overriding any options\nlock.show();\n\n// Show the Lock widget, overriding some options\nlock.show({\n  allowedConnections: [\"twitter\", \"facebook\"],\n  allowSignUp: false\n});\n```\n\nOptions should be set when first instantiating Lock `var lock = new Auth0Lock(clientId, domain, options);`. Options should only be passed to `show` in order to override your previously set options while displaying the widget at this particular time and place.\n\nThere is an additional option that can be set in the `show` method called `flashMessage`.\n\n### flashMessage\n\nThis object is only available as an option for the `show` method, not for use in the normal `options` object when instantiating Lock. The `flashMessage` object shows an error or success flash message when Lock is shown. It has the following parameters:\n\n*   **type** {String}: The message type, it should be either `error` or `success`.\n    \n*   **text** {String}: The text to show.\n    \n\n```\nlock.show({\n  flashMessage:{\n    type: 'success',\n    text: 'Amazing Success!!'\n  }\n});\n```\n\nA practical application of the `flashMessage` option is to handle authorization errors. The `flashMessage` can be populated with error description text.\n\n```\nlock.on('authorization_error', function(error) {\n  lock.show({\n    flashMessage: {\n      type: 'error',\n      text: error.errorDescription\n    }\n  });\n});\n```\n\nSo, if `tester@example.com` were now to try to sign in, being a user who is blocked, the user will be shown Lock again, with a top bar displaying the error message, rather than simply failing to login and Lock closing.\n\n## hide()\n\n`hide()`\n\nThe `hide` method closes the widget if it is currently open. The widget closes itself under most circumstances, so this method would primarily be invoked in specific use cases only. For instance, one might wish to listen for the `unrecoverable_error` event and then `hide` the Lock and redirect to their own custom error page. Another example is users who are implementing [popup mode](https://auth0.com/docs/libraries/lock/lock-authentication-modes), and might need to manually `hide` the widget after the `authenticated` event fires.\n\nExample usage to hide (close) the Lock widget in popup mode:\n\n```\n// Listen for authenticated event and hide Lock\nlock.on(\"authenticated\", function() {\n  lock.hide();\n\n  // Whatever else you'd like to do on authenticated event\n\n});\n```\n\n## on()\n\nLock will emit events during its lifecycle. The `on` method can be used to listen for particular events and react to them.\n\n*   `show`: emitted when Lock is shown. Has no arguments.\n    \n*   `hide`: emitted when Lock is hidden. Has no arguments.\n    \n*   `unrecoverable_error`: emitted when there is an unrecoverable error, for instance when no connection is available. Has the error as the only argument.\n    \n*   `authenticated`: emitted after a successful authentication. Has the authentication result as the only argument. The authentication result contains the token which can be used to get the user's profile or stored to log them in on subsequent checks.\n    \n*   `authorization_error`: emitted when authorization fails. Has error as the only argument.\n    \n*   `hash_parsed`: every time a new Auth0Lock object is initialized in redirect mode (the default), it will attempt to parse the hash part of the url looking for the result of a login attempt. This is a low level event for advanced use cases and `authenticated` and `authorization_error` should be preferred when possible. After that this event will be emitted with `null` if it couldn't find anything in the hash. It will be emitted with the same argument as the `authenticated` event after a successful login or with the same argument as `authorization_error` if something went wrong. This event won't be emitted in [popup mode](https://auth0.com/docs/libraries/lock/lock-authentication-modes) because there is no need to parse the url's hash part.\n    \n*   `forgot_password ready`: emitted when the \"Forgot password\" screen is shown. (Only in Version >`10.18`)\n    \n*   `forgot_password submit`: emitted when the user clicks on the submit button of the \"Forgot password\" screen. (Only in Version >`10.14`)\n    \n*   `signin ready`: emitted when the \"Sign in\" screen is shown.\n    \n*   `signup ready`: emitted when the \"Sign up\" screen is shown.\n    \n*   `signin submit`: emitted when the user clicks on the submit button of the \"Login\" screen. (Only in Version >`10.18`)\n    \n*   `signup submit`: emitted when the user clicks on the submit button of the \"Sign Up\" screen. (Only in Version >`10.18`)\n    \n*   `federated login`: emitted when the user clicks on a social connection button. Has the connection name and the strategy as arguments. (Only in Version >`10.18`)\n    \n*   `socialOrPhoneNumber ready`: emitted when the Passwordless screen with Social + Phone Number is shown\n    \n*   `socialOrPhoneNumber submit`: emitted when the Passwordless screen with Social + Phone Number is submitted\n    \n*   `socialOrEmail ready`: emitted when the Passwordless screen with Social + Email is shown\n    \n*   `socialOrEmail submit`: emitted when the Passwordless screen with Social + Email is submitted\n    \n*   `vcode ready`: emitted when the Passwordless screen with the one-time-password is shown\n    \n*   `vcode submit`: emitted when the Passwordless screen with the one-time-password is submitted\n    \n\nThe `authenticated` event listener has a single argument, an `authResult` object. This object contains the following properties: `accessToken`, `idToken`, `state`, `refreshToken` and `idTokenPayload`.\n\nAn example use of the `authenticated` event:\n\nto configure this snippet with your account\n\n```\nvar Auth = (function() {\n\n  var privateStore = {};\n\n  function Auth() {\n    this.lock = new Auth0Lock(\n      '<{yourClientId}>',\n      '<{yourDomain}>'\n    );\n  }\n\n  Auth.prototype.getProfile = function() {\n    return privateStore.profile;\n  };\n\n  Auth.prototype.authn = function() {\n    // Listening for the authenticated event\n    this.lock.on(\"authenticated\", function(authResult) {\n      // Use the token in authResult to getUserInfo() and save it if necessary\n      this.getUserInfo(authResult.accessToken, function(error, profile) {\n        if (error) {\n          // Handle error\n          return;\n        }\n\n        privateStore.profile = profile;\n\n      });\n    });\n  };\n  return Auth;\n}());\n```\n\n## resumeAuth()\n\nThis method can only be used when you set the [auth.autoParseHash](https://auth0.com/docs/libraries/lock/lock-configuration) option to `false`. You'll need to call `resumeAuth` to complete the authentication flow. This method is useful when you're using a client-side router that uses a `#` to handle urls (angular2 with `useHash`, or react-router with `hashHistory`).\n\n*   **hash** {String}: The hash fragment received from the redirect.\n    \n*   **callback** {Function}: Will be invoked after the parse is done. Has an error (if any) as the first argument and the authentication result as the second one. If there is no hash available, both arguments will be `null`.\n    \n\n```\nlock.resumeAuth(hash, function(error, authResult) {\n  if (error) {\n    alert(\"Could not parse hash\");\n  }\n  //This is just an example; you should not log Access Tokens in production.\n  console.log(authResult.accessToken);\n});\n```\n\n## checkSession()\n\nThe `checkSession` method allows you to acquire a new token from Auth0 for a user who is already authenticated against Auth0 for your domain. It takes the following parameters:\n\n*   **options** {Object}: Optional. Accepts any valid OAuth2 parameters that would normally be sent to `/authorize`. If you omit them, it will use the ones provided when initializing Auth0.\n    \n*   **callback** {Function}: Will be invoked with the token renewal result. Has an error (if any) as the first argument and the authentication result as the second one.\n    \n\n```\nlock.checkSession({}, function(err, authResult) {\n  // handle error or new tokens\n});\n```\n\n## logout()\n\nLogs out the user.\n\n*   **options** {Object}: This is optional and follows the same rules as auth0.js logout().\n    \n\n```\nlock.logout({\n  returnTo: 'https://myapp.com/bye-bye'\n});\n```",
    "title": "Lock API Reference",
    "description": "Details on the Lock v11 API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login",
    "markdown": "# Login\n\nAuth0 offers two ways to implement login authentication for your applications:\n\n*   **Universal Login** where users log in to your application through a page hosted by Auth0.\n    \n*   **Embedded Login** where users log in to your application through a page you host.\n    \n\nFor the vast majority of use cases, we recommend Universal Login. It's safe and easy to implement.",
    "title": "Login",
    "description": "Learn about the ways to implement login authentication for your users with Auth0 Universal Login or Embedded Login. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/libraries/lock/v11/configuration",
    "markdown": "# Lock Configuration Options\n\nLock can be configured through the `options` parameter sent to the constructor. These options can alter the way that the Lock widget behaves, how it deals with connections, additional signup fields that you require for your project, the language and text values, colors, and images on the widget, and many more. Take a look at the index below if you know what you are looking for, or browse the options for more details.\n\n## UI\n\n| Option | Description |\n| --- | --- |\n| [allowAutocomplete](#allowautocomplete-boolean-) | Enable or disable autocompletion on the email or username inputs |\n| [allowPasswordAutocomplete](#allowpasswordautocomplete-boolean-) | Enable or disable autocompletion on password input |\n| [allowShowPassword](#allowshowpassword-boolean-) | Specifies if the user can choose to show password while typing it |\n| [allowedConnections](#allowedconnections-array-) | List of connections that will be available to perform authentication |\n| [autoclose](#autoclose-boolean-) | Specifies if Lock closes after a login |\n| [autofocus](#autofocus-boolean-) | Specifies if focus is set on the first input field |\n| [avatar](#avatar-object-) | Specifies if an avatar and a username should be displayed on the Lock's header once an email or username has been entered and how to obtain it |\n| [closable](#closable-boolean-) | Determines whether or not Lock can be closed |\n| [container](#container-string-) | The HTML element where Lock will be rendered. This causes Lock to appear inline instead of in a modal window |\n| [flashMessage](#flashmessage-object-) | Shows an `error` or `success` flash message when Lock is shown |\n| [language](#language-string-) | Specifies the language of the widget |\n| [languageDictionary](#languagedictionary-object-) | Customize text used for widget elements (such as labels and placeholders) |\n| [popupOptions](#popupoptions-object-) | Customize the location of the popup in the screen |\n| [rememberLastLogin](#rememberlastlogin-boolean-) | Whether or not to show a screen that allows you to quickly log in with the account you used the last time |\n| [scrollGlobalMessagesIntoView](#scrollglobalmessagesintoview-boolean-) | Specify if a globalMessage should be scrolled into the user's viewport |\n\n## Theme\n\nTheme options are grouped in the `theme` property of the `options` object.\n\n| Option | Description |\n| --- | --- |\n| [authButtons](#authbuttons-object-) | Customize the appearance of specific connection buttons |\n| [labeledSubmitButton](#labeledsubmitbutton-boolean-) | whether or not the submit button has text |\n| [logo](#logo-string-) | What logo should be used |\n| [primaryColor](#primarycolor-string-) | Color of the primary button on the widget |\n\n## Authentication\n\nAuthentication options are grouped in the `auth` property of the `options` object.\n\n| Option | Description |\n| --- | --- |\n| [audience](#audience-string-) | The API which will be consuming your Access Token |\n| [autoParseHash](#autoparsehash-boolean-) | Whether or not to automatically parse hash and continue |\n| [connectionScopes](#connectionscopes-object-) | Specify connection scopes |\n| [params](#params-object-) | Option to send parameters at login |\n| [redirect](#redirect-boolean-) | Whether or not to use redirect mode |\n| [redirectUrl](#redirecturl-string-) | The URL to redirect to after auth |\n| [responseMode](#responsemode-string-) | Option to send response as POST |\n| [responseType](#responsetype-string-) | Response as a code or token |\n| [sso](#sso-boolean-) | Determines whether Single Sign-On is enabled or not in Lock |\n\n## Database\n\n| Option | Description |\n| --- | --- |\n| [additionalSignUpFields](#additionalsignupfields-array-) | Additional fields collected at signup |\n| [allowLogin](#allowlogin-boolean-) | Whether or not to allow login on widget |\n| [allowForgotPassword](#allowforgotpassword-boolean-) | Whether or not to allow forgot password on widget |\n| [allowSignUp](#allowsignup-boolean-) | Whether or not to allow signup on widget |\n| [defaultDatabaseConnection](#defaultdatabaseconnection-string-) | Default shown DB connection |\n| [initialScreen](#initialscreen-string-) | Which screen to show when the widget is opened |\n| [loginAfterSignUp](#loginaftersignup-boolean-) | After signup, whether or not to auto login |\n| [forgotPasswordLink](#forgotpasswordlink-string-) | Link to a custom forgot password page |\n| [showTerms](#showterms-boolean-) | Specify if signup terms should be display |\n| [mustAcceptTerms](#mustacceptterms-boolean-) | Whether or not terms must be accepted (checkbox) |\n| [prefill](#prefill-object-) | Prefill values for email/username fields |\n| [signUpLink](#signuplink-string-) | Set a custom url to fire when clicking \"sign up\" |\n| [usernameStyle](#usernamestyle-string-) | Limit username field to accept only \"username\" values or only \"email\" values |\n\n## Enterprise\n\n| Option | Description |\n| --- | --- |\n| [defaultEnterpriseConnection](#defaultenterpriseconnection-string-) | Specifies a connection if more than one present |\n\n## Passwordless\n\n| Option | Description |\n| --- | --- |\n| [passwordlessMethod](#passwordlessmethod-string-) | When using `Auth0LockPasswordless` with an email connection, you can use this option to pick between sending a [code](https://auth0.com/docs/connections/passwordless/spa-email-code) or a [magic link](https://auth0.com/docs/connections/passwordless/spa-email-link) to authenticate the user |\n\n### Other\n\n| Option | Description |\n| --- | --- |\n| [configurationBaseUrl](#configurationbaseurl-string-) | Override your application's base URL |\n| [languageBaseUrl](#languagebaseurl-string-) | Override your language file base URL |\n| [hashCleanup](#hashcleanup-boolean-) | Override the default removal of the hash from the URL |\n| [connectionResolver](#connectionresolver-function-) | Optional callback function for choosing a connection based on the username information |\n\n* * *\n\n## UI Options\n\n### allowAutocomplete {Boolean}\n\nDetermines whether or not the email or username fields will allow autocomplete (`<input autocomplete />`). Defaults to `false`.\n\n`allowAutocomplete: true`\n\n### allowPasswordAutocomplete {Boolean}\n\nDetermines whether or not the password field will allow autocomplete (`<input autocomplete />`). Defaults to `false`.\n\nSet `allowPasswordAutocomplete` to `true` for password manager support and to avoid other cases of adverse behavior.\n\n`allowPasswordAutocomplete: true`\n\n### allowShowPassword {Boolean}\n\nThis option determines whether or not to add a checkbox to the UI which, when selected, will allow the user to show their password when typing it. The option defaults to `false`.\n\n`allowShowPassword: true`\n\nLock with `allowShowPassword` set to `true` and toggled to show the password:\n\n![Lock Option: Allow Show Password](https://images.ctfassets.net/cdy7uua7fh8z/6G8LJaNjaMl5zUrwGi5UJQ/44dc951b70077b0ec6bc04d2f0413b12/lock-allowshowpassword.png)\n\n### allowedConnections {Array}\n\nArray of connections that will be used for the `signin|signup|reset` actions. Defaults to all enabled connections.\n\n`allowedConnections: ['Username-Password-Authentication']`\n\n`allowedConnections: ['twitter', 'facebook', 'linkedin']`\n\n`allowedConnections: ['qraftlabs.com']`\n\nExamples of `allowedConnections`:\n\n![Lock Option: Allowed Connections - Database](https://images.ctfassets.net/cdy7uua7fh8z/1mllPDLFCCETwQ9MeGEf3W/763728971302656618ef3bd131ab83b1/lock-allowedconnections-database.png)![Lock Option: Allowed Connections - Social](https://images.ctfassets.net/cdy7uua7fh8z/7uYN4ebrLLM8bjx1fee8j0/1e716cca3e1bae990063e9226dfe9ac2/lock-allowedconnections-social.png)\n\n### autoclose {Boolean}\n\nDetermines whether or not the Lock will be closed automatically after a successful sign in. Defaults to false. If the Lock is not `closable` it won't be closed, even if this option is set to true.\n\n`autoclose: true`\n\n### autofocus {Boolean}\n\nIf true, the focus is set to the first field on the widget. Defaults to `false` when being rendered on a mobile device, or if a `container` option is provided; defaults to `true` in all other cases.\n\n`autofocus: false`\n\n### avatar {Object}\n\nBy default, Gravatar is used to fetch the user avatar and display name, but you can obtain them from anywhere with the `avatar` option.\n\n```\nvar options = {\n  avatar: {\n    url: function(email, cb) {\n      // Obtain the avatar url for the email input by the user, Lock\n      // will preload the image before displaying it.\n      // Note that in case of an error you call cb with the error in\n      // the first arg instead of `null`.\n      var url = obtainAvatarUrl(email);\n      cb(null, url);\n    },\n    displayName: function(email, cb) {\n      // Obtain the display name for the email input by the user.\n      // Note that in case of an error you call cb with the error in\n      // the first arg instead of `null`.\n      var displayName = obtainDisplayName(email);\n      cb(null, displayName);\n    }\n  }\n};\n```\n\nOr, if you want to display no avatar at all, simply pass in `null`.\n\n`avatar: null`\n\nDefault behavior with Gravatar:\n\n![Lock Option: Avatar](https://images.ctfassets.net/cdy7uua7fh8z/69Nz0QoQifPWpfBZwX15J0/204aad93cde406f0ed3771ce38766f56/lock-avatar.png)\n\n### closable {Boolean}\n\nDetermines whether or not the Lock can be closed. When a `container` option is provided its value is always `false`, otherwise it defaults to `true`.\n\n`closable: false`\n\n![Lock Option: Closable](https://images.ctfassets.net/cdy7uua7fh8z/2qwXtPQev1nlpyOQauXKBO/f967e1157972ecbf5b030b3be3600f2e/lock-closable.png)\n\n### container {String}\n\nThe `id` of the html element where the widget will be shown.\n\nThis makes the widget appear inline within your `div` instead of in a modal pop-out window.\n\n```\n<div id=\"hiw-login-container\"></div>\n\n<script>\n  var options = {\n    container: 'hiw-login-container'\n  };\n\n  // initialize\n  var lock = new Auth0Lock('xxxxxx', '<account>.auth0.com', options);\n\n  // render\n  lock.show();\n</script>\n```\n\n![Lock Option: Container](https://images.ctfassets.net/cdy7uua7fh8z/5L4S47Yfset2DR9pjcqVrX/1c4d1928cf75acf40129ffd01394bf33/lock-container.png)\n\n### flashMessage {Object}\n\nShows an `error` or `success` flash message when Lock is shown. This object has the following properties:\n\n*   type {String}: The message type, supported types are `error`, `info`, and `success`\n    \n*   text {String}: The text to show.\n    \n\n```\nvar options = {\n  flashMessage: {\n    type: 'success',\n    text: 'Welcome!'\n  }\n};\n```\n\n### language {String}\n\nSpecifies the language of the widget. Defaults to \"en\". See the [internationalization directory](https://github.com/auth0/lock/blob/master/src/i18n/) for a current list of provided languages.\n\n`language: 'es'`\n\n![Lock Option: Language](https://images.ctfassets.net/cdy7uua7fh8z/3u3lytCUBDbcKmXFV34OUv/5cf5d7e1af9593a3b094f32815a4da11/lock-language.png)\n\n### languageDictionary {Object}\n\nAllows customization of every piece of text displayed in the Lock. Defaults to {}. See English language [Language Dictionary Specification](https://github.com/auth0/lock/blob/master/src/i18n/en.js) for the full list of `languageDictionary` values able to be altered with this object.\n\n```\nvar options = {\n  languageDictionary: {\n    emailInputPlaceholder: \"something@youremail.com\",\n    title: \"Log me in\"\n  },\n};\n```\n\n![Lock Option: Language Dictionary](https://images.ctfassets.net/cdy7uua7fh8z/5203ofwtagtIKGT4HnIPmk/8ad9cdd151a2cdb18b8a42ee47dbf679/lock-languagedictionary.png)\n\nAdditionally, check out the [Customizing Error Messages](https://auth0.com/docs/customize/login-pages/classic-login/customize-lock-error-messages) page or the [Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/lock-internationalization) page for more information about the use of the `languageDictionary` option.\n\nAllows the customization the location of the popup in the screen. Any position and size feature allowed by window.open is accepted. Defaults to {}.\n\nOptions for the `window.open` features. This only applies if `redirect` is set to `false`.\n\n```\nvar options = {\n  auth: {\n      redirect: false\n  },\n  popupOptions: { width: 300, height: 400, left: 200, top: 300 }\n};\n```\n\n### rememberLastLogin {Boolean}\n\nDetermines whether or not to show a screen that allows you to quickly log in with the account you used the last time. Requests Single Sign-on (SSO) data and enables a **Last time you signed in with** message. Defaults to `true`. This information comes from the user's Auth0 session, so this ability will last as long as their Auth0 session would (which is configurable).\n\n`rememberLastLogin: false`\n\nNew tenants [automatically have Seamless SSO enabled](https://auth0.com/docs/get-started/tenant-settings/enable-sso-for-legacy-tenants). With this enabled, the `rememberLastLogin` option will not be relevant because if there is a session in place then the Universal Login page will not be displayed at all. Using Seamless SSO is highly recommended because it provides a seamless authentication experience: users log in once and won’t have to enter credentials again when they navigate either through the applications you have built, or third party apps. If the user is not logged in they will be redirected to the login screen, as expected. Additionally, the **Last time you signed in with** message will not be available under the following circumstances:\n\n*   You used Lock in a [Hosted Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login) with the session established using [Passwordless authentication](https://auth0.com/docs/connections/passwordless).\n    \n*   You used Lock in an [embedded login scenario](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login) where `responseType: code` (indicating the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), which is used for Regular Web Apps).\n    \n\n### scrollGlobalMessagesIntoView {Boolean}\n\nDetermines whether or not a `globalMessage` should be scrolled into the user's viewport. Defaults to `true`.\n\n`scrollGlobalMessagesIntoView: false`\n\n## Theme Options\n\nTheme options are grouped in the `theme` property of the `options` object.\n\n```\nvar options = {\n  theme: {\n    labeledSubmitButton: false,\n    logo: \"https://example.com/assets/logo.png\",\n    primaryColor: \"green\",\n    authButtons: {\n      connectionName: {\n        displayName: \"...\",\n        primaryColor: \"...\",\n        foregroundColor: \"...\",\n        icon: \"https://.../logo.png\"\n      }\n    }\n  }\n};\n```\n\n### authButtons {Object}\n\nAllows the customization of buttons in Lock with custom OAuth2 connections. Each custom connection whose button you desire to customize should be listed by name, each with their own set of parameters. The customizable parameters are listed below:\n\n*   **displayName** {String}: The name to show instead of the connection name when building the button title, such as `LOGIN WITH MYCONNECTION` for login).\n    \n*   **primaryColor** {String}: The button's background color. Defaults to `#eb5424`.\n    \n*   **foregroundColor** {String}: The button's text color. Defaults to `#FFFFFF`.\n    \n*   **icon** {String}: The URL of the icon for this connection. For example: `http://site.com/logo.png`.\n    \n\n```\nvar options = {\n  theme: {\n    authButtons: {\n      \"testConnection\": {\n        displayName: \"Test Conn\",\n        primaryColor: \"#b7b7b7\",\n        foregroundColor: \"#000000\",\n        icon: \"http://example.com/icon.png\"\n      },\n      \"testConnection2\": {\n        primaryColor: \"#000000\",\n        foregroundColor: \"#ffffff\",\n      }\n    }\n  }\n};\n```\n\n### labeledSubmitButton {Boolean}\n\nThis option indicates whether or not the submit button should have a label, and defaults to `true`. When set to `false`, an icon will be shown instead.\n\n```\nvar options = {\n  theme: {\n    labeledSubmitButton: false\n  }\n};\n```\n\n![Lock Option: Labeled Submit Button](https://images.ctfassets.net/cdy7uua7fh8z/5PNCvsbYa98pKZwWHVPS9S/39cb5ac63818ec5558c451b1e37f735f/lock-theme-labeledsubmitbutton.png)\n\nIf the label is set to true, which is the default, the label's text can be customized through the [languageDictionary](#languagedictionary-object-) option.\n\n### logo {String}\n\nThe value for `logo` is a URL for an image that will be placed in the Lock's header, and defaults to Auth0's logo. It has a recommended max height of `58px` for a better user experience.\n\n```\nvar options = {\n  theme: {\n    logo: 'https://example.com/logo.png'\n  }\n};\n```\n\n![Lock UI customization - Logo](https://images.ctfassets.net/cdy7uua7fh8z/FdOAKKy71rTbFjIlZEL8D/2eef96008095d85388daaa461707901d/lock-theme-logo.png)\n\n### primaryColor {String}\n\nThe `primaryColor` property defines the primary color of the Lock; all colors used in the widget will be calculated from it. This option is useful when providing a custom `logo`, to ensure all colors go well together with the `logo`'s color palette. Defaults to `#ea5323`.\n\n```\nvar options = {\n  theme: {\n    logo: 'https://example.com/logo.png',\n    primaryColor: '#31324F'\n  }\n};\n```\n\n![Lock UI customization - primary color](https://images.ctfassets.net/cdy7uua7fh8z/1qQjeTmXJyIziv400VPaOn/48dd3cb8a72a6e88b2634b4b8a8bed63/lock-theme-primarycolor.png)\n\n## Authentication Options\n\nAuthentication options are grouped in the `auth` property of the `options` object.\n\nThe default scope used by Lock is `openid profile email`.\n\n```\nvar options = {\n  auth: {\n   params: {\n    param1: \"value1\",\n    scope: \"openid profile email\"\n   },\n   autoParseHash: true,\n   redirect: true,\n   redirectUrl: \"some url\",\n   responseMode: \"form_post\",\n   responseType: \"token\",\n   sso: true,\n   connectionScopes: {\n    connectionName: [ 'scope1', 'scope2' ]\n   }\n  }\n};\n```\n\n### audience {String}\n\nThe `audience` option indicates the API which will be consuming the Access Token that is received after authentication.\n\n```\nvar options = {\n  auth: {\n    audience: 'https://{yourDomain}/userinfo',\n  }\n}\n```\n\n### autoParseHash {Boolean}\n\nWhen `autoParseHash` is set to `true`, Lock will parse the `window.location.hash` string when instantiated. If set to `false`, you'll have to manually resume authentication using the [resumeAuth](https://auth0.com/docs/libraries/lock/lock-api-reference) method.\n\n```\nvar options = {\n  auth: {\n    autoParseHash: false\n  }\n};\n```\n\n### connectionScopes {Object}\n\nThis option allows you to set scopes to be sent to the oauth2/social connection for authentication.\n\n```\nvar options = {\n  auth: {\n    connectionScopes: {\n      'facebook': ['scope1', 'scope2']\n    }\n  }\n};\n```\n\nA listing of particular scopes for your social connections can be acquired from the provider in question. For example, [Facebook for Developers](https://developers.facebook.com/docs/facebook-login/permissions/) reference has a listing of separate permissions that can be requested for your connection.\n\n### params {Object}\n\nYou can send parameters when starting a login by adding them to the options object. The example below adds a `state` parameter with a value equal to `foo` and also adds a `scope` parameter (which includes the scope, and then the requested attributes).\n\n```\nvar options = {\n  auth: {\n    params: {\n      state: 'foo',\n      scope: 'openid email user_metadata app_metadata picture'\n    }\n  }\n};\n```\n\nFor more details about supported parameters, see [Lock Authentication Parameters](https://auth0.com/docs/libraries/lock/lock-authentication-parameters).\n\n### redirect {Boolean}\n\nDefaults to true. When set to true, redirect mode will be used. If set to false, [popup mode](https://auth0.com/docs/libraries/lock/lock-authentication-modes) is chosen.\n\n```\nvar options = {\n  auth: {\n    redirect: false\n  }\n};\n```\n\n### redirectUrl {String}\n\nThe URL Auth0 will redirect back to after authentication. Defaults to the empty string \"\" (no redirect URL).\n\n```\nvar options = {\n  auth: {\n    redirectUrl: 'http://testurl.com'\n  }\n};\n```\n\nWhen the `redirectUrl` is provided (set to non blank value) the `responseType` option will be defaulted to `code` if not manually set.\n\n### responseMode {String}\n\nShould be set to `\"form_post\"` if you want the code or the token to be transmitted via an HTTP POST request to the `redirectUrl`, instead of being included in its query or fragment parts.\n\nOtherwise, this option should be omitted, and is omitted by default.\n\n```\nvar options = {\n  auth: {\n    responseMode: 'form_post'\n  }\n};\n```\n\n### responseType {String}\n\nThe value of `responseType` should be set to \"token\" for Single-Page Applications, and \"code\" otherwise. Defaults to \"code\" when redirectUrl is provided, and to \"token\" otherwise.\n\n```\nvar options = {\n  auth: {\n    responseType: 'token'\n  }\n};\n```\n\nWhen the `responseType` is set to `code`, Lock will never show the **Last time you logged in with** message, and will always prompt the user for credentials.\n\n## sso {Boolean}\n\nDefaults to true. When set to true, enables [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on) in Lock.\n\n```\nvar options = {\n  auth: {\n    sso: false\n  }\n};\n```\n\n## Database Options\n\n### additionalSignUpFields {Array}\n\nExtra input fields can be added to the sign up screen with the `additionalSignUpFields` option. Each option added in this manner will then be added to that user's `user_metadata`. To learn more, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata). Every input must have a `name` and a `placeholder`, and an `icon` URL can also be provided. Also, the initial value can be provided with the `prefill` option, which can be a string with the value or a function that obtains it. Other options depend on the type of the field, which is defined via the type option and defaults to \"text\".\n\n#### Option additionalSignUpFields Intended for use with database signup only\n\nThe `additionalSignUpFields` are intended for use with database signups only. If you have social sign ups too, you can ask for the additional information after the users sign up (see this [page about custom signup](https://auth0.com/docs/libraries/custom-signup) for more details). You can use the `databaseAlternativeSignupInstructions` i18n key to display these instructions.\n\nThe new fields are rendered below the regular sign up input fields in the order they are provided.\n\n#### Text Fields\n\nText fields are the default type of additional signup field. Note that a `validator` function can also be provided.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    name: \"address\",\n    placeholder: \"enter your address\",\n    // The following properties are optional\n    icon: \"https://example.com/assests/address_icon.png\",\n    prefill: \"street 123\",\n    validator: function(address) {\n      return {\n         valid: address.length >= 10,\n         hint: \"Must have 10 or more chars\" // optional\n      };\n    }\n  },\n  {\n    name: \"full_name\",\n    placeholder: \"Enter your full name\"\n  }]\n}\n```\n\nIf you don't specify a `validator` the text field will be **required**. If you want to make the text field optional, use a validator that always returns `true` like this:\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    name: \"favorite_color\",\n    placeholder: \"Enter your favorite color (optional)\",\n    validator: function() { \n      return true;\n    }\n  }]\n}\n```\n\nIf you want to save the value of the attribute in the root of your profile, use `storage: 'root'`. Only a subset of values can be stored this way. The list of attributes that can be added to your root profile is [here](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id). By default, every additional sign up field is stored inside the user\\_metadata object.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    name: \"name\",\n    storage: \"root\"\n  }]\n};\n```\n\n![Lock Option: Additional Signup Fields](https://images.ctfassets.net/cdy7uua7fh8z/2KPDGZb3caq57caJ90w53k/e092bdb4a4d93589aa006f796ff20fca/lock-additionalsignupfields.png)\n\n#### Select Field\n\nThe signup field `type: \"select\"` will allow you to use select elements for the user to choose a value from.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    type: \"select\",\n    name: \"location\",\n    placeholder: \"choose your location\",\n    options: [\n      {value: \"us\", label: \"United States\"},\n      {value: \"fr\", label: \"France\"},\n      {value: \"ar\", label: \"Argentina\"}\n    ],\n    // The following properties are optional\n    icon: \"https://example.com/assests/location_icon.png\",\n    prefill: \"us\"\n  }]\n}\n```\n\nThe `options` array items for `select` fields must adhere to the following format: `{label: “non empty string”, value: “non empty string”}`, and at least one option must be defined.\n\nThe `options` and `prefill` values can be provided through a function:\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    type: \"select\",\n    name: \"location\",\n    placeholder: \"choose your location\",\n    options: function(cb) {\n      // obtain options, in case of error you call cb with the error in the\n      // first arg instead of null\n      cb(null, options);\n    },\n    icon: \"https://example.com/assests/location_icon.png\",\n    prefill: function(cb) {\n      // obtain prefill, in case of error you call cb with the error in the\n      // first arg instead of null\n      cb(null, prefill);\n    }\n  }]\n}\n```\n\n#### Checkbox Field\n\nThe third type of custom signup field is the `type: \"checkbox\"`. The `prefill` value can determine the default state of the checkbox (`true` or `false`), and it is required.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    type: \"checkbox\",\n    name: \"newsletter\",\n    prefill: \"true\",\n    placeholder: \"I hereby agree that I want to receive marketing emails from your company\"\n  }]\n}\n```\n\n#### Hidden field\n\nThe signup field `type: \"hidden\"` will allow you to use a hidden input with a fixed value.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    type: \"hidden\",\n    name: \"signup_code\",\n    value: \"abc123\"\n  }]\n}\n```\n\nSome use cases may be able to use `additionalSignUpFields` data for email templates, such as an option for language preferences, the value of which could then be used to set the language of templated email communications.\n\n### allowLogin {Boolean}\n\nWhen set to `false` the widget won't display the login screen. This is useful if you want to use the widget just for signups (the login and signup tabs in the signup screen will be hidden) or to reset passwords (the back button in the forgot password screen will be hidden). In such cases you may also need to specify the `initialScreen`, `allowForgotPassword` and `allowSignUp` options. It defaults to `true`.\n\n`allowLogin: false`\n\n![Lock Option: Allow Login](https://images.ctfassets.net/cdy7uua7fh8z/6gI4aSLHXLzhcHiR9aWMET/d05c2a08a3895278b01150ecf894cb5f/lock-allowlogin.png)\n\n### allowForgotPassword {Boolean}\n\nWhen set to false, `allowForgotPassword` hides the \"Don't remember your password?\" link in the Login screen, making the Forgot Password screen unreachable. Defaults to true. If you are using a database connection with a custom database which doesn't have a change password script the Forgot Password screen won't be available.\n\n`allowForgotPassword: false`\n\n![Lock Option: Allow Forgot Password](https://images.ctfassets.net/cdy7uua7fh8z/1L6wJS3UnWK1VGKYMFhAB9/2ddcf2d462255e78a8b78958c2503809/lock-allowforgotpassword.png)\n\n### allowSignUp {Boolean}\n\nWhen set to `false`, hides the login and sign up tabs in the login screen, making the sign up screen unreachable. Defaults to `true`. Keep in mind that if the database connection has sign ups disabled or you are using a custom database which doesn't have a create script, then the sign up screen won't be available.\n\nAlso bear in mind that this option **only** controls client-side appearance, and does not completely stop new sign ups from determined anonymous visitors. If you are looking to fully prevent new users from signing up, you must use the **Disable Sign Ups** option in the dashboard, in the connection settings.\n\n`allowSignUp: false`\n\n![Lock Option: Allow Signup](https://images.ctfassets.net/cdy7uua7fh8z/2BNlYe99EFlRmIlhoLZiEB/f280d865cb16fa5fecda952271cb18bf/lock-allowsignup.png)\n\n### defaultDatabaseConnection {String}\n\nSpecifies the database connection that will be used when there is more than one available.\n\n`defaultDatabaseConnection: 'test-database'`\n\n### initialScreen {String}\n\nThe name of the screen that will be shown when the widget is opened. Valid values are `login`, `signUp`, and `forgotPassword`. If this option is left unspecified, the widget will default to the first screen that is available from that list.\n\n`initialScreen: 'forgotPassword'`\n\n### loginAfterSignUp {Boolean}\n\nDetermines whether or not the user will be automatically signed in after a successful sign up. Defaults to `true`.\n\n`loginAfterSignUp: false`\n\n### forgotPasswordLink {String}\n\nSet the URL for a page that allows the user to reset their password. When set to a non-empty string, the user will be sent to the provided URL when clicking the \"Don't remember your password?\" link in the login screen.\n\n`forgotPasswordLink: 'https://yoursite.com/reset-password'`\n\n### showTerms {Boolean}\n\nWhen set to `true` displays the `languageDictionary.signUpTerms` string. Defaults to `true`.\n\n`showTerms: false`\n\n### mustAcceptTerms {Boolean}\n\nWhen set to `true` displays a checkbox input alongside the terms and conditions that must be checked before signing up. The terms and conditions can be specified via the `languageDictionary` option. This option will only take effect for users signing up with database connections. Defaults to `false`.\n\n`mustAcceptTerms: true`\n\n### prefill {Object}\n\nAllows to set the initial value for the email and/or username inputs. When omitted, no initial value will be provided.\n\n```\nvar options = {\n  prefill: {\n    email: \"someone@auth0.com\",\n    username: \"someone\",\n    phoneNumber: \"+1234567890\"\n  }\n};\n```\n\n### signUpLink {String}\n\nSet the URL to be requested when clicking on the Signup button. When set to a non empty string, this option forces `allowSignUp` to `true`.\n\n`signUpLink: 'https://yoursite.com/signup'`\n\n### usernameStyle {String}\n\nDetermines what will be used to identify the user for a Database connection that has the `requires_username` flag set (if it is not set, `usernameStyle` option will be ignored). Possible values are `\"username\"` and `\"email\"`. By default both `username` and `email` are allowed; setting this option will limit logins to use one or the other.\n\n`usernameStyle: 'username'`\n\n## Enterprise Options\n\n### defaultEnterpriseConnection {String}\n\nSpecifies the enterprise connection which allows to login using a username and a password that will be used when there is more than one available or there is a database connection. If a `defaultDatabaseConnection` is provided the database connection will be used and this option will be ignored.\n\n`defaultEnterpriseConnection: 'test-database'`\n\n### defaultADUsernameFromEmailPrefix {Boolean}\n\nResolve the AD placeholder username from the email's prefix. Defaults to `true`.\n\n`defaultADUsernameFromEmailPrefix: false`\n\n## Passwordless Options\n\n### passwordlessMethod {String}\n\nWhen using `Auth0LockPasswordless` with an email connection, you can use this option to pick between sending a [code](https://auth0.com/docs/connections/passwordless/spa-email-code) or a [magic link](https://auth0.com/docs/connections/passwordless/spa-email-link) to authenticate the user. Available values for email connections are `code` and `link`. Defaults to `code`. SMS passwordless connections will always use `code`.\n\n`passwordlessMethod: code`\n\n## Other Options\n\n### configurationBaseUrl {String}\n\nOverrides the application settings base URL. By default, it uses the provided domain. This option is only necessary if your specific use case dictates that your application does not use the default behavior.\n\n`configurationBaseUrl: \"https://www.example.com\"`\n\n### languageBaseUrl {String}\n\nOverrides the language source url for Auth0's provided translations. By default, this option uses Auth0's CDN URL `https://cdn.auth0.com` since this is where all of the provided translations are stored. By providing another value, you can use another source for the language translations if needed.\n\n`languageBaseUrl: \"https://www.example.com\"`\n\n### hashCleanup {Boolean}\n\nWhen the `hashCleanup` option is enabled, it will remove the hash part of the callback URL after the user authentication. It defaults to true.\n\n`hashCleanup: false`\n\n### connectionResolver {Function}\n\nWhen in use, provides an extensibility point to make it possible to choose which connection to use based on the username information.\n\nHas `username`, `context`, and `callback` as parameters. The callback expects an object like: `{type: 'database', name: 'connection name'}`. **This only works for database connections.** Keep in mind that this resolver will run in the form's `onSubmit` event, so keep it simple and fast.\n\nThis is a beta feature. If you find a bug, please open a GitHub [issue](https://github.com/auth0/lock/issues/new).\n\n### leeway {Integer}\n\nThe `leeway` option can be set to an integer - a value in seconds - which can be used to account for clock skew in ID Token expirations. Typically the value is no more than a minute or two at maximum.\n\n`leeway: 30`",
    "title": "Lock Configuration Options",
    "description": "Lock has many configurable options that allow you to change the behavior, appearance, and connectivity of the Lock widget - this resource provides the details on those options for you!",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on",
    "markdown": "# Single Sign-On\n\nSingle Sign-on (SSO) occurs when a user logs in to one application and is then signed in to other applications automatically, regardless of the platform, technology, or domain the user is using. The user signs in only one time, hence the name of the feature (Single Sign-on).\n\nFor example, if you log in to a Google service such as Gmail, you are automatically authenticated to YouTube, AdSense, Google Analytics, and other Google apps. Likewise, if you log out of your Gmail or other Google apps, you are automatically logged out of all the apps; this is known as Single Logout.\n\nSSO provides a seamless experience for users when using your applications and services. Instead of having to remember separate sets of credentials for each application or service, users can simply log in once and access your full suite of applications.\n\nWhenever users go to a domain that requires authentication, they are redirected to the authentication domain where they may be asked to log in. If the user is already logged in at the authentication domain, they can be immediately redirected to the original domain without signing in again.\n\n## How it works\n\nSingle Sign-on and Single Logout are possible through the use of [sessions](https://auth0.com/docs/manage-users/sessions). There may be up to three different sessions for a user with SSO:\n\n*   Local session maintained by the application\n    \n*   Authorization Server session, if SSO is enabled\n    \n*   Identity Provider (IdP) session, if the user chose to log in through an Identity Provider (such as Google, Facebook, or an enterprise SAML Identity Provider)\n    \n\nWith SSO, a central domain performs authentication and then shares the session with other domains. The way a session is shared may differ between SSO protocols, but the general concept is the same.\n\nFor example, the authentication domain may generate a signed [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens) (encrypted using JSON Web Encryption (JWE)), which contains all the information needed to identify the user for any other domain requiring authentication. This token is passed to the client, but because it is signed, it cannot be modified in any way by the client. The token can be passed to the original domain by a redirect and used by the authentication domain and any other domains to identify the user.\n\n## SSO with Universal Login\n\nThe easiest and most secure way to implement Single Sign-on (SSO) with Auth0 is by using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) for authentication. In fact, currently SSO is only possible with native platforms (like iOS or Android) if the application uses Universal Login. The [Swift](https://auth0.com/docs/quickstart/native/ios-swift/00-login) and [Android](https://auth0.com/docs/quickstart/native/android/00-login) quick starts provide some examples of using Universal Login.\n\nIf you cannot use Universal Login with your application, review the following for additional info on embedded authentication:\n\n*   [Lock](https://auth0.com/docs/libraries/lock/lock-api-reference)\n    \n*   [Auth0.js](https://auth0.com/docs/libraries/auth0js)\n    \n\n### SSO on first login\n\nFor SSO with Auth0, the **Central Service** is the Auth0 Authorization Server.\n\nLet's look at an example of the SSO flow when a user logs in for the first time:\n\n1.  Your application redirects the user to the login page.\n    \n2.  Auth0 checks to see whether there is an existing SSO cookie.\n    \n3.  Because this is the first time the user is visiting the login page and no SSO cookie is present, the user will be asked to log in using one of the connections you have configured.\n    \n    ![Example timesheets application login screen](https://images.ctfassets.net/cdy7uua7fh8z/6m01sxT4xI0oUC6ox3vb4Z/99a19ac391ae33b1307d7de29c2222d1/lock-no-sso-cookie.png)\n4.  Once the user has logged in, Auth0 will set an SSO cookie and redirect the user to your application, returning an ID Token that contains identity information for the user.\n    \n\n### SSO on subsequent logins\n\nLet's look at an example of the SSO flow when a user returns to your website for a subsequent visit:\n\n1.  Your application redirects the user to the login page.\n    \n2.  Auth0 checks to see whether there is an existing SSO cookie.\n    \n3.  Auth0 finds the SSO cookie, and if necessary, updates it. No login screen is shown.\n    \n4.  Auth0 redirects the user to your application, returning an ID Token that contains identity information for the user.\n    \n\n### Check user's SSO status\n\nYou can check a user's SSO status from an application by calling the `checkSession` method of the `auth0.js` SDK, which will attempt to [silently authenticate](https://auth0.com/docs/authenticate/login/configure-silent-authentication) the user within an iframe. Whether the authentication is successful or not indicates whether the user has an active SSO cookie.\n\n## Protocols\n\n### SAML and WS-Federation\n\nSecurity Assertion Markup Language (SAML) and Web Services Federation (WS-Fed) are both [protocols](https://auth0.com/docs/authenticate/protocols) that are widely used in SSO implementations. Both SAML and WS-Fed exchange authorization and authentication data in XML format; the main parts of this exchange are the user, the identity provider, and the service provider.\n\nWith SAML or WS-Fed:\n\n1.  A user requests a resource from the service provider.\n    \n2.  The service provider checks with the identity provider to see if the user should have access to the resource.\n    \n3.  The identity provider verifies the user's identity, and if valid, asserts back to the service provider that the user should have access.\n    \n\n### OpenID Connect\n\nOpenID Connect (OIDC) is an authentication protocol commonly used in consumer-facing SSO implementations. The OIDC protocol handles authentication through JSON Web Tokens and a central identity provider.\n\nWith OIDC:\n\n1.  A user requests access to an application.\n    \n2.  The application redirects the user to the identity provider for authentication.\n    \n3.  The identity provider verifies the user, and if successful, prompts the user to grant data access to the application.\n    \n4.  If access is granted, the identity provider generates an ID Token, which contains user identity information that the application can consume.\n    \n5.  The identity provider returns the user to the application.\n    \n\n### AD/LDAP\n\nLightweight Directory Access Protocol (LDAP) is an application protocol used to access a directory of credentials that can be shared by multiple applications; it is commonly used by intranets. When paired with Active Directory (AD), LDAP provides a centralized location for user identity, so the application makes an authentication request to the LDAP/AD server. The LDAP protocol exchanges information in LDAP Data Interchange Format (LDIF).\n\n## Service-provider-initiated SSO\n\nFor [Service-Provider-initiated SSO](https://auth0.com/docs/authenticate/single-sign-on/inbound-single-sign-on), Auth0 is the SSO Service Provider (SP).\n\nWhen a user logs in to an application:\n\n1.  The application presents the user with one or more external identity providers.\n    \n2.  The user selects an identity provider to authenticate with and logs in.\n    \n3.  Upon successful authentication, the user is returned to the application.\n    \n\nSP-initiated SSO in Auth0 is handled by connections.\n\n## Identity-provider-initiated SSO\n\nFor [Identity-Provider-initiated SSO](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on), a third-party Identity Provider (IdP) is the SSO provider.\n\nWhen a user logs in to an application:\n\n1.  The application redirects the user to an identity provider.\n    \n2.  The third-party identity provider performs authentication and authorization.\n    \n3.  Upon successful authentication, the user is returned to the application.\n    \n\nWhen planning an IdP-initiated SSO implementation, you may choose to use Auth0's [SSO Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application), which allows you to create a dashboard that lists multiple enterprise applications that can be enabled for SSO. This dashboard is then presented to your users to log in.\n\n## Use cases\n\n### Business to Business\n\nFor Business to Business (B2B) scenarios, SSO can simplify packaging your application for enterprise consumption. With Auth0, your applications can support common enterprise federation scenarios, such as Active Directory (AD), Lightweight Directory Access Protocol (LDAP), Ping, or Security Assertion Markup Language (SAML). This allows your partners and enterprise customers to log in with their preferred enterprise identity technologies.\n\n*   [Case Study: O'Reilly](https://auth0.com/case-studies/oreilly)\n    \n\n### Business to Consumer CIAM\n\nFor Business to Consumer (B2C) or Customer Identity Access Management (CIAM) scenarios, SSO can provide frictionless access to your applications or services. You can let customers authenticate through popular social identity providers, such as Google, Facebook, LinkedIn, X, and Microsoft, instead of requiring them to make another account.\n\n*   [Case Study: Giving Compass](https://auth0.com/case-studies/giving-compass)\n    \n\n## Learn more\n\n*   [Service-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/inbound-single-sign-on)\n*   [Identity-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on)\n*   [API Endpoints for Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/api-endpoints-for-single-sign-on)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections)",
    "title": "Single Sign-On",
    "description": "Learn what Single Sign-on (SSO) is and how it works.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless",
    "markdown": "# Passwordless Connections\n\nPasswordless connections allow users to log in without the need to remember a password. Instead, users enter their mobile phone number or email address and receive a one-time password (OTP) or link, which they can then use to log in.\n\nWhen a user authenticates through a passwordless connection, their profile is created on the connection using Auth0 as the Identity Provider (IdP). Since you can't force users to use the same mobile phone number or email address every time they authenticate, users may end up with multiple user profiles in the Auth0 datastore. If this happens, you can associate multiple user profiles by [linking their accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking).\n\n### Passwordless connection vs. passwordless login\n\nA passwordless connection is another type of connection separate from any existing database, social, or enterprise connections. Even though a user from an Auth0 user database or social provider might share the same email address, the identity associated with their passwordless connection is distinct. As with linking multiple email addresses or mobile phone numbers used for the Passwordless connection, [account linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking) can also be used to associate a passwordless identity with identities from other types of connections.\n\nIn addition to supporting passwordless with passwordless connections, Auth0 lets you define a passwordless flow using WebAuthn with Device Biometrics. To learn more, review [Configure WebAuthn with Device Biometrics for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics).\n\n## Benefits\n\nThe benefits of using passwordless authentication include:\n\n*   Improved user experience. Users only need an email address or mobile phone number to sign up.\n    \n*   Enhanced security. Passwords are a major vulnerability as users reuse passwords and are able to share them with others. Passwords are the biggest attack vector and are responsible for a significant percentage of breaches. They also lead to attacks such as credentials stuffing, corporate account takeover, and brute force attacks.\n    \n*   Reduced total cost of ownership. Managing passwords is expensive between implementing password complexity policies, managing password expiration and password reset processes, hashing and storing passwords, and monitoring breached password detection.\n    \n\n## Supported authentication methods\n\nAuth0 passwordless connections support OTPs sent through SMS or email, and magic links sent through email.\n\n### SMS\n\nWhen using passwordless authentication with SMS, users:\n\n1.  Provide a mobile phone number instead of a username/password combination.\n    \n    ![Example of using Passwordless SMS](https://images.ctfassets.net/cdy7uua7fh8z/5duaNojd4n76NlAsYrdMYo/ebc92f9e422965202e225c5156638ef8/passwordless-sms-enter-phone-web.png)\n2.  Receive an OTP through SMS.\n    \n3.  Enter the OTP on the login screen to access the application.\n    \n\n### Email\n\nWhen using passwordless authentication with email, users:\n\n1.  Provide an email address instead of a username/password combination.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/5lq4hQnYFM4uphbj9YslUy/36abf4c62b442d6845dbe44edbe2fb5a/passwordless-email.png)\n2.  Depending on how you have configured your passwordless connection, receive either an OTP or magic link through email.\n    \n3.  Enter the OTP on the login screen (or open the magic link in the email) to access the application.\n    \n\n## Implement Passwordless\n\nTo implement passwordless, you'll need to make two key decisions:\n\n*   Which authentication factor(s) you want to support\n    \n*   Which login type you want to use\n    \n\n### Authentication factors\n\nWhen deciding to support an authentication factor, you must consider the user's experience, which that depends on your application and its target audience. If the application will run on mobile phones, it is highly likely that users will be able to receive SMS messages. If it's an internal web application that is used in an environment where users cannot have their mobile phones with them, email would be the only choice.\n\nIf you decide to use email, then you need to decide between OTPs or Magic Links. We recommend using OTPs, because the login flow is more predictable for end users. To learn more about authentication factors, read the following articles:\n\n*   [Passwordless Authentication with Email and One-time Passwords (OTP)](https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-otp)\n    \n*   [Passwordless Authentication with Email and Magic Links](https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-magic-link)\n    \n*   [Passwordless Authentication with SMS](https://auth0.com/docs/authenticate/passwordless/authentication-methods/sms-otp)\n    \n\n### Login type\n\nAuth0 recommends using either the Universal Login or the Classic Login experience to implement Passwordless authentication, but you may decide that Embedded Login is the best choice for your application.\n\nTo learn more about how to configure Passwordless authentication for different login types, read the following articles:\n\n*   [Passwordless Authentication with Universal Login](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login)\n    \n*   [Passwordless Authentication with Classic Login](https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login)\n    \n*   [Passwordless Authentication with Embedded Login](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login)\n    \n\n## Learn more\n\n*   [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices)\n*   [Using Passwordless APIs](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints)",
    "title": "Passwordless Connections",
    "description": "Learn about passwordless connections, Auth0-supported passwordless methods of authentication, and how to implement passwordless authentication with Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/enterprise-connections",
    "markdown": "# Enterprise Connections\n\nAuth0 provides Enterprise connections to authenticate users in an external, federated identity provider (IdP) such as Azure AD, Google Workspace, PingFederate, and more.\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects the availability of this feature. To learn more, read [Auth0's Pricing Page](https://auth0.com/pricing).\n\n## Create an Enterprise connection\n\nAuth0 supports many identity providers out of the box. To learn more, review [Enterprise Identity Providers](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers).\n\n#### OpenID Connect (OIDC) protocol\n\nEnterprise connections using OpenID Connect or Okta Workforce as the identity provider can support the following:\n\n*   Proof Key for Code Exchange (PKCE)\n    \n    *   For more information on PKCE, review [Protecting Apps with PKCE](https://www.oauth.com/oauth2-servers/pkce/).\n        \n*   Attribute claims and access token mapping\n    \n*   UserInfo integration\n    \n\nYou can currently implement these features for [OpenID Connect](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc) or [Okta Workforce](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta) connections. To learn more, review [Configure PKCE and Claim Mapping for OIDC Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc).\n\n## View Enterprise connections\n\nNavigate to [**Auth0 Dashboard > Authentication > Enterprise**](https://manage.auth0.com/#/connections/enterprise) to see all available Enterprise connection types. Select a connection type (for example, SAML) to see if there are any configured connections of that type.\n\nYou can also select a configured connection and check the **Applications** tab to see if it is enabled for any applications.\n\n## What is an active Enterprise connection?\n\nAn Enterprise connection is considered active if (during the current month) it has both:\n\n*   Been enabled for an application.\n    \n*   Had user activity (for example, login, sign-up, or token exchange).\n    \n\nIf an Enterprise connection was never enabled for any application, or was enabled but did not have any user activity during the current month, it is not considered active.\n\n## Learn more\n\n*   [Enterprise Identity Providers](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers)\n*   [Enable Enterprise Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections)\n*   [View Connections](https://auth0.com/docs/authenticate/identity-providers/view-connections)\n*   [Test Enterprise Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections)\n*   [Entity Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/entity-limit-policy)",
    "title": "Enterprise Connections",
    "description": "Learn how to create, manage, and monitor usage of Enterprise connections to authenticate users with external identity providers.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols",
    "markdown": "# Protocols\n\nThere are a set of open specifications and protocols that specify how to design an authentication and authorization system. They specify how you should manage identity, move personal data securely, and decide who can access applications and data.\n\nThe identity industry standards that we use at Auth0 are:\n\n*   Open Authorization (OAuth) 1: the original standard for access delegation. Used as a way for a user to grant websites access to their information on other websites or apps, but without giving them the credentials.\n    \n*   [Open Authorization (OAuth) 2](https://auth0.com/docs/authenticate/protocols/oauth): an authorization standard that allows a user to grant limited access to their resources on one site to another site, without having to expose their credentials. You use this standard every time you log in to a site using your Google account and you are asked if you agree with sharing your email address and your contacts list with that site.\n    \n*   [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol): an identity layer that sits on top of OAuth 2 and allows for easy verification of the user's identity, as well as the ability to get basic profile information from the identity provider.\n    \n*   [Lightweight Directory Access Protocol (LDAP)](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector): an application protocol used for accessing and maintaining distributed directory information services over an IP network. The function of LDAP is to enable access to an existing directory like Active Directory (AD). Auth0 uses a connector that you install on your network to integrate with AD/LDAP.\n    \n*   [JSON Web Tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens): an open standard that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.\n    \n*   [Security Assertion Markup Language (SAML)](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration): an open-standard, XML-based data format that allows businesses to communicate user authentication and authorization information to partner companies and enterprise applications their employees may use.\n    \n*   [WS-Federation (WS-Fed)](https://auth0.com/docs/authenticate/protocols/ws-fed-protocol): a standard developed by Microsoft, and used extensively in their applications. It defines the way security tokens can be transported between different entities to exchange identity and authorization information.",
    "title": "Protocols",
    "description": "Describes which authorization protocols Auth0 supports and how they work.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/social-identity-providers",
    "markdown": "# Social Identity Providers\n\nAuth0 supports multiple social identity providers for web applications out of the box, so you can gather up-to-date user information without creating friction or compromising the user experience. To explore the full list of Auth0-supported and partner-supported social identity providers, visit [Auth0 Marketplace: Social Connections](https://marketplace.auth0.com/features/social-connections).\n\nIf you don't see what you're looking for, you can also [create a connection to any OAuth2 Authorization Server](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/oauth2).\n\nFinally, Auth0 supports the following social providers specifically for native applications:\n\n*   [Sign In with Apple](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/apple-native)\n    \n*   [Facebook Login](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/facebook-native)",
    "title": "Social Identity Providers",
    "description": "Learn about the social identity providers supported by Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/connection-settings-best-practices",
    "markdown": "# Connection Settings Best Practices\n\nHere are some best practices for configuring connections. Before you set up connections, take a moment to review what connections are and [learn the basics of authentication](https://auth0.com/docs/authenticate) for your application type.\n\nAuth0 provides default credentials for social connections to help you get started. You should replace these temporary credentials with your own to avoid restrictions.\n\n## Review requested data\n\nYou should review the data you are requesting from each social connection. Users must grant consent for the requested data. Requesting a lot of unnecessary data may result in users declining the authorization request out of privacy concerns.\n\n## Set password policy for database connections\n\nConfigure the password policy for your Auth0 database connections so created users have strong passwords. You can configure the password policy in the database connection settings on the dashboard or with the Auth0 Management API.\n\nThe password policy applies to password resets performed with the Universal Login Page as well as the Auth0 Management API.\n\n## Disable user signup if it's not appropriate for each database connection\n\nIn your database connection settings, specify if self-service user signups should be enabled. If you enabled this during development, review if you should disable it on production tenants.\n\nOnly enable this setting for production tenants if you allow end-users to sign up in a self-service manner. If self-service signup is not allowed, disable the feature. You can then add users to the database connection with the Auth0 Management API.\n\nWhen using the Organizations feature, you can enable self-service signup for a given database connection in the context of a specific organization. When enabled, users can access a Sign Up link on the login prompt and gain membership to a specific organization upon creating their account. For more information, review [Enable Organization Connections](https://auth0.com/docs/manage-users/organizations/configure-organizations/enable-connections).\n\n## Review applications enabled for each connection\n\nFor each connection, review the list of allowed applications. Make sure there are no unintended authentication paths into an application. By default, new applications may have all of your tenant's connections enabled, which may not be appropriate.\n\n## Use RSA-SHA256 for SAML connections\n\nConfigure any SAML connections to sign requests and use RSA-SHA256 as the signature algorithm. This ensures the remote SAML Identity Provider can validate whether the authentication requests came from a legitimate application or not.",
    "title": "Connection Settings Best Practices",
    "description": "Learn about recommended identity provider connection settings in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers",
    "markdown": "# Enterprise Identity Providers\n\nAuth0 supports the following enterprise providers out of the box:\n\n*   [Active Directory/LDAP](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap)\n    \n*   [ADFS](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/adfs)\n    \n*   [Azure Active Directory Native](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory-native)\n    \n*   [Google Workspace](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/google-apps)\n    \n*   [OpenID Connect](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc)\n    \n*   [Okta](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta)\n    \n*   [PingFederate](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/ping-federate)\n    \n*   [SAML](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/saml)\n    \n*   [Azure Active Directory](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2)\n    \n\nYou can also explore partner-supported enterprise connections on the [Auth0 Marketplace](https://marketplace.auth0.com/features/enterprise-connections).\n\n## OpenID Connect (OIDC) protocol\n\nEnterprise connections using OpenID Connect or Okta Workforce as the identity provider can support the following:\n\n*   Proof Key for Code Exchange (PKCE)\n    \n    *   For more information on PKCE, review [Protecting Apps with PKCE](https://www.oauth.com/oauth2-servers/pkce/).\n        \n*   Attribute claims and access token mapping\n    \n*   UserInfo integration\n    \n\nYou can currently implement these features for [OpenID Connect](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc) or [Okta Workforce](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta) connections. To learn more, review [Configure PKCE and Claim Mapping for OIDC Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc).",
    "title": "Enterprise Identity Providers",
    "description": "Learn about enterprise identity providers supported by Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/test-connections",
    "markdown": "# Test Connections\n\nGenerally, to test a connection, you must log in to the Auth0 Dashboard.\n\n1.  Navigate to [Auth0 Dashboard](https://manage.auth0.com/#), and select **Authentication**, then select the type of connection you want to test.\n    \n2.  Locate the connection you want to test, and select **Try Connection** from its **More Options** menu (**...**).\n    \n3.  Log in with the identity provider.\n    \n4.  Wait for the **It Works!** page that displays the result.\n    \n\nAuth0 simulates the authentication flow as if it were an application, displaying the User Profile resulting from a successful authentication.\n\n## Test partner connections\n\nIf you are testing a connection that belongs to someone else, and you don't have test credentials with them, it is not possible to be logged in to the Auth0 Dashboard. This is common when connecting to Enterprise connections, such as SAML Identity Providers (IdPs) or Active Directory. The solution? Your partners can test the new connection.\n\n1.  Register a test app.\n    \n    *   Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **Create Application**. You can give it any name (for example, `Test App`).\n        \n    *   In the settings of the newly-created app, set **Allowed Callback URLs** to `http://jwt.io`.\n        \n    *   Select **Save Changes**.\n        \n2.  Send your partner the link to log in.\n    \n    ```\n    https://{yourDomain}/authorize?response_type=token&scope=openid%20profile&client_id={yourClientId}&redirect_uri=http://jwt.io&connection={connectionToTest}\n    ```\n    \n    Replace these two parameters:\n    *   `client_id`: Client ID of the application created in Step 1.\n        \n    *   `connection`: Name of the connection you want to test.\n        \n3.  Test the connection. When your partner follows the link, they will be redirected to their configured Identity Provider (the connection). After successful authentication, they will be sent back to [JWT.io](http://jwt.io/) where all user properties will be decoded from the token.",
    "title": "Test Connections",
    "description": "Describes how to test a connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/view-connections",
    "markdown": "# View Connections\n\nWas this article helpful?",
    "title": "View Connections",
    "description": "Describes how to view enabled connections in the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/legal",
    "markdown": "# Legal Identity Providers\n\nThrough our partner, Criipto, we offer a range of different, and often proprietary, e-ID services of the EU. To explore available options, visit [Auth0 Marketplace: Criipto](https://marketplace.auth0.com/integrations/criipto-verify-e-id).\n\nIf you don't find what you need here, please contact [Criipto](https://criipto.com/).",
    "title": "Legal Identity Providers",
    "description": "Learn about legal identity providers supported by Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/locate-the-connection-id",
    "markdown": "# Locate the Connection ID or Name\n\nSome user management tasks require a connection ID, which is a unique identifier for a source of users. For example, if you import or export users or connect to identity providers, you must provide a connection ID.\n\n1.  Go to [Auth0 Dashboard](https://manage.auth0.com/#/), select **Authentication**, then select the type of connection for which you need the ID.\n    \n2.  Select the name of the connection for which you need the ID.\n    \n3.  On the **Settings** view, locate the **Name** field; it contains the connection ID.",
    "title": "Locate the Connection ID or Name",
    "description": "Learn how to find the ID of a connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/retrieve-connection-options",
    "markdown": "# Retrieve Connection Options\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION-ID',\n  params: {fields: 'options'},\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
    "title": "Retrieve Connection Options",
    "description": "Learn how to retrieve the options object for a connection using the Auth0 Management API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/promote-connections-to-domain-level",
    "markdown": "# Promote Connections to Domain Level\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"is_domain_connection\": true }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"is_domain_connection\\\": true }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"is_domain_connection\\\": true }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"is_domain_connection\\\": true }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {is_domain_connection: true}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"is_domain_connection\": @YES };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"is_domain_connection\\\": true }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"is_domain_connection\\\": true }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"is_domain_connection\\\": true }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"is_domain_connection\": true] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
    "title": "Promote Connections to Domain Level",
    "description": "Learn how to promote a connection to domain level using the Auth0 Management API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/calling-an-external-idp-api",
    "markdown": "# Call an Identity Provider API\n\nOnce you successfully authenticate a user with an external Identity Provider (IdP), such as Facebook or GitHub, the IdP often includes an Access Token in the user profile it returns to Auth0.\n\nYou can retrieve and use this token to call the IdP's API.\n\nThe process you will follow differs depending on whether your code runs in the backend or the frontend:\n\n*   If your code runs in the backend, then we can assume that your server is trusted to safely store secrets (as you will see, we use a secret in the backend scenario). If that's the case, proceed to the [backend section](#from-the-backend) of this article.\n    \n*   If your code runs in the frontend (for example, it's a SPA, native desktop, or mobile app), then your app cannot hold credentials securely and has to follow an alternate approach. In this case, proceed to the [frontend section](#from-the-frontend) of this article.\n    \n\n## From the backend\n\nOnce you authenticate a user, the IdP often includes an Access Token in the user profile it returns to Auth0.\n\nFor security and compliance reasons, Auth0 does not send this token to your app as part of the user profile. To get it, you must access the Auth0 Management API and retrieve the full user's profile:\n\n1.  Get an Access Token that allows you to call the [Auth0 Management API](https://auth0.com/docs/api/management/v2).\n    \n2.  Call the Auth0 Management API's [Get Users by ID endpoint](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) using the Access Token obtained in step one. This endpoint returns the full user's profile, which contains the IdP Access Token.\n    \n3.  Extract the IdP Access Token from the response and use it to call the IdP's API.\n    \n\n### Step 1: Get a Token\n\nYou will need an Access Token to call the [Management API](https://auth0.com/docs/api/management/v2).\n\n#### Create a test application for the Management API\n\nIf this is the first time you are requesting a [Management APIv2 Token](https://auth0.com/docs/api/management/v2/tokens), you will need to create and configure an application that can be used to call the Management API:\n\n1.  Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and select the [Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients).\n    \n2.  Select the **API Explorer** view, and click **Create & Authorize a Test Application**.\n    \n\nThis will create a new application and grant all scopes of the Management API, which means that the tokens generated for this application will be able to access all Management API endpoints.\n\n#### Can't see the button?\n\nIf you don't see this button, it means that you already have at least one authorized application for the Management API. In this case, you can either update the scopes of the existing application and use that, or create a new one following these steps:\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **Create Application**.\n    \n2.  Select **Machine to Machine Applications**, and then **Create**.\n    \n3.  From the **Select an API** dropdown, select `Auth0 Management API`.\n    \n4.  Enable required scopes, and select **Authorize**.\n    \n5.  Select the **APIs** view, and enable the toggle for **Auth0 Management API**.\n    \n\nTo grant or remove scopes from the [registered Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients), select the [**Machine to Machine Applications** view](https://manage.auth0.com/#/apis/management/authorized-clients):\n\n![Edit the scopes granted to the Application](https://images.ctfassets.net/cdy7uua7fh8z/6nuMjQMrTWhoVqtRwJBQz7/c0608d7a19addef1acb143532004dba8/dashboard-apis-edit_view-m2m_mgmt-api-permissions.png)\n\n#### Get the Management API Token\n\nYou are now done with configuration and are ready to get your Management API token:\n\n1.  From the [registered Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients), select the [**Test** view](https://manage.auth0.com/#/apis/management/test).\n    \n2.  Choose your application from the **Application** dropdown to pre-populate the ready-to-use snippets with customized variables.\n    \n3.  Choose your language of preference for the snippet, and copy and run it.\n    \n4.  Extract the `access_token` property from the response. This is what you will use to access the Management API.\n    \n\n#### Token expiration\n\nBy default, the token you received expires in 24 hours (86,400 seconds). To change this:\n\n1.  Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and select the [Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients).\n    \n2.  Select the **Settings** view, locate the **Token Expiration (Seconds)** field, enter a new value, and click **Save**. The maximum value you can set is 2,592,000 seconds (30 days), though we recommend that you keep the default value.\n    \n\nThe next token you generate will use the updated expiration time.\n\n### Step 2: Get the full User Profile\n\nTo get a user's profile, call the [Get a User endpoint](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) of the Management API using the Access Token you extracted in the previous section:\n\n*   [cURL](#7c25cd17489e43a1b54ce26a366e3bf1_shell)\n*   [C#](#7c25cd17489e43a1b54ce26a366e3bf1_csharp)\n*   [Go](#7c25cd17489e43a1b54ce26a366e3bf1_go)\n*   [Java](#7c25cd17489e43a1b54ce26a366e3bf1_java)\n*   [Node.JS](#7c25cd17489e43a1b54ce26a366e3bf1_node)\n*   [Obj-C](#7c25cd17489e43a1b54ce26a366e3bf1_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users/%7BuserId%7D' \\\n  --header 'authorization: Bearer {yourAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/%7BuserId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n  .header(\"authorization\", \"Bearer {yourAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users/%7BuserId%7D',\n  headers: {authorization: 'Bearer {yourAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/%7BuserId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/%7BuserId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users/%7BuserId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/%7BuserId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nReplace these values:\n\n*   `{userId}`: ID of the user for whom you want to call the IdP's API.\n    \n*   `{yourAccessToken}`: Access Token you extracted in the previous section.\n    \n\n#### Where do I find the User ID?\n\n*   For testing purposes, you can find a user ID at [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users). Locate a user, and copy the value of the **user\\_id** field.\n    \n\n*   For your implementation, you can either extract the user ID from the `sub` claim in the [ID Token](https://auth0.com/docs/secure/tokens/id-tokens), or call the [/userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info) of the Authentication API and extract it from the `user_id` response property.\n    \n\nYou can find the Access Token used to call the IdP's API within the user's `identities` array: `user.identities[0].access_token`.\n\nIn most cases, the user will only have one identity, but if the user has signed in multiple times through different connections and you have used [account linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts), there may be more.\n\nIn this sample response, we see that our user has only one identity: `google-oauth2`.\n\n```\n{\n  \"email\": \"john.doe@test.com\",\n  \"email_verified\": true,\n  \"name\": \"John Doe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"picture\": \"https://myavatar/photo.jpg\",\n  \"gender\": \"male\",\n  \"locale\": \"en\",\n  \"updated_at\": \"2017-03-15T07:14:32.451Z\",\n  \"user_id\": \"google-oauth2|111199914890750704174\",\n  \"nickname\": \"john.doe\",\n  \"identities\": [\n    {\n      \"provider\": \"google-oauth2\",\n      \"access_token\": \"ya29.GlsPBCS6ahokDlgCYnVLnDKNE71HBXPEzNhAPoKJLAGKDSe1De3_xclahNcdZXoU-26hCpa8h6240TV86dtaEQ4ZWoeeZduHDq_yeu9QyQqUr--S9B2CR9YJrLTD\",\n      \"expires_in\": 3599,\n      \"user_id\": \"111199914890750704174\",\n      \"connection\": \"google-oauth2\",\n      \"isSocial\": true\n    }\n  ],\n  \"created_at\": \"2017-03-15T07:13:41.134Z\",\n  \"last_ip\": \"127.0.0.1\",\n  \"last_login\": \"2017-03-15T07:14:32.451Z\",\n  \"logins_count\": 99\n}\n```\n\nYou are now ready to call the IdP's API. Please refer to the IdP's documentation for specifics on how to do so.\n\n## From the frontend\n\nIf you are working with a public application (SPA, native desktop, or mobile app), then this is the place to be.\n\nWhen working with a frontend app, the process for calling IdP APIs differs from the backend process because frontend apps are public applications that **cannot hold credentials securely**. Because SPA code can be viewed and altered, and native/mobile apps can be decompiled and inspected, they cannot be trusted to hold sensitive information like secret keys or passwords.\n\nSpecifically, they cannot securely hold the **Client Secret** for the Machine to Machine Application, which you use to call `/oauth/token` during the first step of the backend process.\n\nInstead, you must build a proxy for your backend and expose it to your application as an API.\n\n### Build a proxy\n\nFirst, you will build a process in your backend that will implement the steps included in [the backend section](#from-the-backend) of this article, and expose it to your application as an API.\n\nYou will call the IdP's API from the same backend process, so the Access Token is never exposed to your public application.\n\nThen, you will call your proxy API from your public application using the [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).",
    "title": "Call an Identity Provider API",
    "description": "Describes how to call an external Identity Provider API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps",
    "markdown": "# Pass Parameters to Identity Providers\n\nYou can pass provider-specific parameters to an Identity Provider (IdP) during authentication. The values can either be static per connection or dynamic per user.\n\n## Limitations\n\nFor this configuration, be aware of the following restrictions:\n\n*   Only [valid OAuth 2.0/OIDC parameters](http://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint) are accepted.\n    \n*   Not all IdPs support upstream parameters. Check with the specific IdP before you proceed with your implementation.\n    \n*   SAML IdPs do not support upstream parameters.\n    \n\n## Static parameters\n\nUse static parameters to configure your connection to send a standard set of parameters to the IdP when a user logs in.\n\nTo configure static parameters, call the Auth0 Management API [Create a connection](https://auth0.com/docs/api/management/v2/#!/Connections/post_connections) or [Update a connection](https://auth0.com/docs/api/management/v2/#!/Connections/patch_connections_by_id) endpoint, and pass the `upstream_params` object in the `options` object with the parameters you'd like to send to the IdP.\n\n### Example: WordPress\n\nWordPress allows you to pass an optional `blog` parameter to its OAuth 2.0 authorization endpoint, and automatically request access to a specified blog for users when they log in. To learn more, read [WordPress's OAuth 2.0 documentation](https://developer.wordpress.com/docs/oauth2/).\n\nTo follow this example, you'll need a working [WordPress Social connection](https://marketplace.auth0.com/integrations/wordpress-social-connection).\n\n#### Get the connection\n\nCall the Management API [Get a connection](https://auth0.com/docs/api/management/v2#!/Connections/get_connections_by_id) endpoint to retrieve the existing values of the `options` object:\n\n*   [cURL](#d004be6840c24017b443e6ce39551c56_shell)\n*   [C#](#d004be6840c24017b443e6ce39551c56_csharp)\n*   [Go](#d004be6840c24017b443e6ce39551c56_go)\n*   [Java](#d004be6840c24017b443e6ce39551c56_java)\n*   [Node.JS](#d004be6840c24017b443e6ce39551c56_node)\n*   [Obj-C](#d004be6840c24017b443e6ce39551c56_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D',\n  headers: {\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'content-type': 'application/json'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe `options` object will look something like this:\n\n```\n{\n  \"options\": {\n    \"client_id\": \"\", \n    \"profile\": true, \n    \"scope\": [\"profile\"]\n  }\n}\n```\n\n#### Update the connection (static)\n\nCopy the existing `options` object, and then add the `upstream_params` object with the `blog` field as an attribute:\n\n```\n{\n  \"options\": {\n    \"client_id\": \"\", \n    \"profile\": true, \n    \"scope\": [\"profile\"],\n    \"upstream_params\": {\n      \"blog\": {\"value\":\"myblog.wordpress.com\"}\n    }\n  }\n}\n```\n\nCall the Management API [Update a connection](https://auth0.com/docs/api/management/v2/#!/Connections/patch_connections_by_id) endpoint with the `options` object in the body:\n\n*   [cURL](#edc1805dc3b840d5bfce317b146c9d49_shell)\n*   [C#](#edc1805dc3b840d5bfce317b146c9d49_csharp)\n*   [Go](#edc1805dc3b840d5bfce317b146c9d49_go)\n*   [Java](#edc1805dc3b840d5bfce317b146c9d49_java)\n*   [Node.JS](#edc1805dc3b840d5bfce317b146c9d49_node)\n*   [Obj-C](#edc1805dc3b840d5bfce317b146c9d49_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"options\":{\"client_id\":\"\",\"profile\":true,\"scope\":[\"profile\"],\"upstream_params\":{\"blog\":{\"value\":\"myblog.wordpress.com\"}}}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D',\n  headers: {\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'content-type': 'application/json'\n  },\n  data: {\n    options: {\n      client_id: '',\n      profile: true,\n      scope: ['profile'],\n      upstream_params: {blog: {value: 'myblog.wordpress.com'}}\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"client_id\": @\"\", @\"profile\": @YES, @\"scope\": @[ @\"profile\" ], @\"upstream_params\": @{ @\"blog\": @{ @\"value\": @\"myblog.wordpress.com\" } } } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\"\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"options\": [\n    \"client_id\": \"\",\n    \"profile\": true,\n    \"scope\": [\"profile\"],\n    \"upstream_params\": [\"blog\": [\"value\": \"myblog.wordpress.com\"]]\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nNow every time a user authenticates with this connection, the request to the Wordpress authorization endpoint will include the query parameter `blog=myblog.wordpress.com`.\n\n## Dynamic parameters\n\nUse dynamic parameters to configure your connection to send a set of parameters with values specific to the user to the IdP when they log in.\n\nTo configure dynamic parameters, call the Auth0 Management API [Create a connection](https://auth0.com/docs/api/management/v2/#!/Connections/post_connections) or [Update a connection](https://auth0.com/docs/api/management/v2/#!/Connections/patch_connections_by_id) endpoint, pass the `upstream_params` object in the `options` object with the parameters you'd like to send to the IdP, and specify the field that the parameter maps to with the `alias` attribute.\n\nHere's a sample `options` object that we'll revisit later in the X example:\n\n```\n{\n  \"options\": {\n    \"upstream_params\": {\n      \"screen_name\": {\n        \"alias\": \"login_hint\"\n      }\n    }\n  }\n}\n```\n\n### Available fields\n\nThese are the available fields for the `alias` attribute:\n\n*   `acr_values`\n    \n*   `audience`\n    \n*   `client_id`\n    \n*   `display`\n    \n*   `id_token_hint`\n    \n*   `login_hint`\n    \n*   `max_age`\n    \n*   `prompt`\n    \n*   `resource`\n    \n*   `response_mode`\n    \n*   `response_type`\n    \n*   `ui_locales`\n    \n\n### Example: X\n\nX allows you to pass an optional `screen_name` parameter to its OAuth authorization endpoint. The `screen_name` parameter pre-fills the username input box of the login screen with the given value. To learn more, read [X's API reference](https://developer.twitter.com/en/docs/basics/authentication/api-reference/authorize).\n\nTo follow this example, you'll need a working [Twitter Social connection](https://marketplace.auth0.com/integrations/twitter-social-connection).\n\n#### Get the connection\n\nCall the Management API [Get a connection](https://auth0.com/docs/api/management/v2#!/Connections/get_connections_by_id) endpoint to retrieve the existing values of the `options` object:\n\n*   [cURL](#b0ad98d286294affa31a04be0bb7fd43_shell)\n*   [C#](#b0ad98d286294affa31a04be0bb7fd43_csharp)\n*   [Go](#b0ad98d286294affa31a04be0bb7fd43_go)\n*   [Java](#b0ad98d286294affa31a04be0bb7fd43_java)\n*   [Node.JS](#b0ad98d286294affa31a04be0bb7fd43_node)\n*   [Obj-C](#b0ad98d286294affa31a04be0bb7fd43_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D',\n  headers: {\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'content-type': 'application/json'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe `options` object will look something like this:\n\n```\n\"options\": {\n  \"client_id\": \"thisismyid\",\n  \"client_secret\": \"thisismysecret\",\n  \"profile\": true\n}\n```\n\n#### Update the connection (dynamic)\n\nCopy the existing `options` object, add the `upstream_params` object with the `screen_name` field as an attribute, and then set the `alias` attribute to `login_hint`:\n\n```\n{\n  \"options\": {\n    \"client_id\": \"\", \n    \"profile\": true, \n    \"scope\": [\"profile\"],\n    \"upstream_params\": {\n      \"screen_name\": {\n        \"alias\": \"login_hint\"\n      }\n    }\n  }\n}\n```\n\nCall the Management API [Update a connection](https://auth0.com/docs/api/management/v2/#!/Connections/patch_connections_by_id) endpoint with the `options` object in the body:\n\n*   [cURL](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_shell)\n*   [C#](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_csharp)\n*   [Go](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_go)\n*   [Java](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_java)\n*   [Node.JS](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_node)\n*   [Obj-C](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"options\": {\"client_id\": \"{clientId}\", \"client_secret\": \"{clientSecret}\", \"profile\": true, \"upstream_params\": {\"screen_name\": {\"alias\": \"login_hint\"}}}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D',\n  headers: {\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'content-type': 'application/json'\n  },\n  data: {\n    options: {\n      client_id: '{clientId}',\n      client_secret: '{clientSecret}',\n      profile: true,\n      upstream_params: {screen_name: {alias: 'login_hint'}}\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"client_id\": @\"{clientId}\", @\"client_secret\": @\"{clientSecret}\", @\"profile\": @YES, @\"upstream_params\": @{ @\"screen_name\": @{ @\"alias\": @\"login_hint\" } } } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\"\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"options\": [\n    \"client_id\": \"{clientId}\",\n    \"client_secret\": \"{clientSecret}\",\n    \"profile\": true,\n    \"upstream_params\": [\"screen_name\": [\"alias\": \"login_hint\"]]\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Call the login endpoint\n\nWhen you call the Authentication API [Login endpoint](https://auth0.com/docs/api/authentication#login) for a user, you can pass their email address to the `login_hint` parameter:\n\n```\nhttps://{yourDomain}/authorize\n  ?client_id={yourClientId}\n  &response_type=token\n  &redirect_uri={https://yourApp/callback}\n  &scope=openid%20name%20email\n  &login_hint=user@domain.com\n```\n\nThis value will then be passed to the X authorization endpoint as the `screen_name` parameter:\n\n```\nhttps://api.twitter.com/oauth/authorize\n  ?oauth_token={yourXAuthToken}\n  &screen_name=user@domain.com\n```",
    "title": "Pass Parameters to Identity Providers",
    "description": "Describes how to pass parameters to an Identity Provider API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/adding-scopes-for-an-external-idp",
    "markdown": "# Add Scopes/Permissions to Call Identity Provider APIs\n\nOnce a user is logged in, you can get their user profile and then the associated `accessToken` to call the Identity Provider (IdP) APIs as described in [Call an Identity Provider API](https://auth0.com/docs/authenticate/identity-providers/calling-an-external-idp-api).\n\nHowever, if you are receiving `Access Denied` when calling the IdP API, you probably have not requested the correct permissions for the user during login. You can request the correct permissions in one of two ways.\n\n## Change Identity Provider Settings\n\nTo configure the scopes/permissions needed from the user, go to [Auth0 Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social), and select an IdP. You can select the required permissions listed on the configuration screen.\n\nFor example, if you click the **Google / Gmail** connection, you can configure Google-specific permissions:\n\n![Permissions for Google](https://images.ctfassets.net/cdy7uua7fh8z/61ACa6hnMtO5aUjus0fCb7/f06dbb20388edcaa30ea85d81cd725b5/dashboard-connections-social-create_google.png)\n\nYou can also pass the scopes/permissions you wish to request as a comma-separated list in the `connection_scope` parameter when calling the [authorize endpoint](https://auth0.com/docs/api/authentication#login). For example, if you want to request the `https://www.googleapis.com/auth/contacts.readonly` and `https://www.googleapis.com/auth/analytics` scopes from Google, you can pass these along with the `connection` parameter to ensure the user logs in with their Google account:\n\n```\nhttps://{yourDomain}/authorize\n  ?response_type=id_token\n  &client_id={yourClientId}\n  &redirect_uri={https://yourApp/callback}\n  &scope=openid%20profile\n  &connection=google-oauth2\n  &connection_scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fanalytics%2Chttps%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcontacts.readonly\n  &nonce=abc\n```",
    "title": "Add Scopes/Permissions to Call Identity Provider APIs",
    "description": "Describes how to add scopes to your IdP connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/auth0-user-store",
    "markdown": "# Auth0 User Store\n\nAuth0 provides the database infrastructure to store your users by default. This scenario provides the best performance for the authentication process since all data is stored in Auth0.\n\nThe Auth0-hosted database is highly secure. Passwords are never stored or logged in plain text but are hashed with **bcrypt**. Varying levels of password security requirements can also be enforced. To learn more, read [Password Strength in Auth0 Database Connections](https://auth0.com/docs/authenticate/database-connections/password-strength).\n\n## Migrating to Auth0 from a custom user store\n\nIn this scenario, you have a legacy user store and wish to switch to the Auth0 store. Auth0 provides an automatic migration feature that adds your users to the Auth0 database one-at-a-time as each logs in and avoids asking your users to reset their passwords all at the same time. To learn more, read [Configure Automatic Migration from Your Database](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database).\n\n## Learn more\n\n*   [Manage Users](https://auth0.com/docs/manage-users)",
    "title": "Auth0 User Store",
    "description": "Describes creating and using a database connection with the Auth0 user store.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db",
    "markdown": "# Custom Database Connections\n\nUse a custom database connection when you want to provide Auth0 with access to your own independent (legacy) identity data store primarily for authentication (filling the role of an identity provider) and for migrating user data to Auth0's data store.\n\nAuth0 [Extensibility](https://auth0.com/docs/customize/extensions) allows you to add custom logic to build out last-mile solutions for Identity and Access Management (IdAM). Auth0 extensibility comes in several forms: [Actions](https://auth0.com/docs/customize/actions), [Rules](https://auth0.com/docs/customize/rules), [Hooks](https://auth0.com/docs/customize/hooks), and [scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates) for both custom database connections and custom database migration. Each is implemented using [Node.js](https://nodejs.org/en/) running on the Auth0 platform in an Auth0 tenant.\n\nAuth0 extensibility executes at different points in the IdAM pipeline:\n\n*   **Actions** extend processes called flows, which are made up of one or more triggers, and which represent the logical pipeline through which information moves during a single point in the Auth0 journey. To learn more about available flows and triggers, read [Explore Flows and Triggers](https://auth0.com/docs/customize/actions/flows-and-triggers).\n    \n*   **Rules** run when artifacts for user authenticity are generated (i.e., an ID Token in OpenID Connect (OIDC)), an Access Token in OAuth 2.0, or an assertion in Security Assertion Markup Language (SAML).\n    \n*   **Hooks** provide additional extensibility for when there is an exchange of non-user related artifacts, and for when user identities are created.\n    \n*   **Custom database action scripts** can be used to integrate with an existing user identity store, or can be used where [automatic user migration](https://auth0.com/docs/manage-users/user-migration) from a legacy identity store is required. Various [templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates) are provided.\n    \n\nWhatever the use case, Auth0 extensibility allows you to tailor IdAM operations to your exact requirements. However, if not used in the right way, this can open up the potential for improper or unintended use which can lead to problematic situations down the line. In an attempt to address matters ahead of time, Auth0 provides [best practice guidance](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts) to both designers and implementers, and we recommend reading it in its entirety at least once, even if you've already started your journey with Auth0.\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Learn more\n\n*   [Authenticate with Your Own User Store](https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections)\n*   [Create Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection)\n*   [Custom Database Action Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates)\n*   [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling)",
    "title": "Custom Database Connections",
    "description": "Learn about authenticating users using your database as an identity provider.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/password-options",
    "markdown": "# Password Options in Auth0 Database Connections\n\nWhen using passwords for authentication, you should enforce the creation of unique passwords. A strong password policy will make it difficult, if not improbable, for a bad actor to guess a password through either manual or automated means.\n\nImportant facets of strong passwords are their uniqueness and difficulty to guess. Auth0's password options for database connections allow you to force your users to make better decisions when choosing their passwords.\n\n![Password Options](https://images.ctfassets.net/cdy7uua7fh8z/1vqXxz0OD7hNLYLwrZZzIe/adf82ab79709eede8ae3ed7354460dfd/2024-04-15_11-14-00.png)\n\nThe Password Options area is located at [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database). Choose the database connection you wish to update and select the **Authentication Methods** tab. In the Password section, select **Configure**.\n\nThe **Password Policy** settings page contains the ability to configure the [Password Strength Policy](https://auth0.com/docs/authenticate/database-connections/password-strength) as well as the following password options.\n\n## Password history\n\nEnabling this option disallows users from setting passwords that repeat passwords they've used in the recent past. Auth0 can retain a password history for each user, up to a maximum of 24 entries per user. Note that when this option is enabled, only password changes going forward will be affected because the history will not have been kept prior to that point.\n\nEven if you do not have a required password change policy (for example, forcing users to change passwords every six months), you still may want to disallow the use of previous passwords. For example, if a security breach in your organization causes you to force users to change their passwords everywhere, you will want to ensure they aren't just re-using passwords that might be compromised.\n\n## Password dictionary\n\nEnabling this option disallows users from setting passwords to common options included in a [default dictionary list](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10k-most-common.txt). You may also include your own prohibited passwords by entering them in the text field in this section.\n\nNote that Auth0 uses case-insensitive comparison with the Password Dictionary feature.\n\n## Personal data\n\nEnabling this option disallows users from setting passwords that contain any part of their personal data. This includes:\n\n*   `name`\n    \n*   `username`\n    \n*   `nickname`\n    \n*   `user_metadata.name`\n    \n*   `user_metadata.first`\n    \n*   `user_metadata.last`\n    \n*   The first part of the user's email will also be checked - `firstpart`@example.com\n    \n\nFor example, if the user's name were \"John\", the user would not be allowed to include \"John\" in their password; `John1234` would not be allowed.\n\n## API access\n\nBecause password options are associated with a Database connection, you can access them using the Management API's [Connections endpoints](https://auth0.com/docs/api/management/v2#!/Connections). Password-related fields are stored in the `options` object. Because these fields are not used for non-database connections, they are not required, so if they are not enabled for a connection, they may not appear.\n\nFor example, after setting a password policy, a MySQL database connection will look like this:\n\n```\n{\n  \"id\": \"con_9dKKcib71UMRiHHW\",\n  \"options\": {\n    \"password_history\": {\n      \"enable\": true,\n      \"size\": 5\n    },\n    \"password_dictionary\": {\n      \"enable\": true,\n      \"dictionary\": [\n        \"entry1\",\n        \"entry2\"\n      ]\n    },\n    \"password_no_personal_info\": {\n      \"enable\": true\n    },\n    \"passwordPolicy\": \"fair\"\n  },\n  \"strategy\": \"auth0\",\n  \"name\": \"MySQL\",\n  \"enabled_clients\": [\n    \"smTzlgPEdqGV0i070t6kPhmG98787987\",\n    \"ztIyxRuiK7Pr2VTzEGvRqxfuh7DgePbF\"\n  ]\n}\n```\n\nIn this example, we can see from the `options` object that all three password options are enabled, password history will store the 5 most recent passwords, and each password will be cross-checked against two dictionaries: `entry1` and `entry2`.\n\nIf you are [creating a connection](https://auth0.com/docs/api/management/v2#!/Connections/post_connections) or [updating an existing connection](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) using the Management API, you can update the password policy for the connection using these fields.",
    "title": "Password Options in Auth0 Database Connections",
    "description": "Auth0's Password Options allow you to disallow users from repeating prior passwords, to customize a password dictionary of passwords to disallow, and to disallow passwords related to the user's personal data.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/passkeys",
    "markdown": "# Passkeys\n\nPasskeys are a phishing-resistant alternative to traditional authentication factors (such as username/password) that offer an easier and more secure login experience to users. Passkeys are modeled from FIDO® W3C Web Authentication (WebAuthn) and Client to Authenticator Protocol (CTAP) [specifications](https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#intro)).\n\nPasskeys reduce the friction experienced with single-device authentication methods by allowing credentials to sync across devices. Cross-device authentication eliminates the need for users to re-enroll on each of their devices. It also supports a more reliable recovery method as the stored credentials can survive the loss of an originating device. To learn more about passkeys, review the FIDO® Alliance [Passkey FAQs](https://fidoalliance.org/passkeys/#faq).\n\nAuth0 supports passkeys as an authentication method for [database connections](https://auth0.com/docs/authenticate/database-connections).\n\n## User experience flows\n\nSimilar to traditional authentication factors, passkeys can support several user experience flows such as signup, login, and account recovery.\n\n### Signup flow\n\nThe signup flow requires the user to provide an email address, and then create a passkey on either their current device or another device through cross-device authentication.\n\n1.  Prompts the user to enter their email address.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/5SlpzscSseNOuJlvhOgBqr/318d95254ef48197a32e58c92be00d2b/signup-passkey_default.png)\n2.  User enters their email address.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3r5pFsWx6SkYOHSHglRwzG/337e3569359c3431c82e80adfeceb470/signup-passkey_filled.png)\n3.  Prompts the user to create a passkey.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/7vZK4q4iUtxyld1Os6og4s/49c22a4c2c06f31256e5a0d4df6daca2/signup-passkey_enrol.png)\n4.  If the user selects **Create a passkey**, it triggers the browser (or operating system) flow to create a passkey.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/IsWmSXNHc2fvRuEgn5DpK/52b2464e21c8dc68bb06869126043ba9/Signup_-_Passkey_-_Browser_OS_Create_a_Passkey.png)\n    *   If the user selects **Continue**, it prompts them to authenticate with their device’s credentials.\n        \n        ![](https://images.ctfassets.net/cdy7uua7fh8z/6OJlPQrWBhgO8izXXoKbOw/a3c1af9a94aaeffc50793e3e9b88db8f/Signup_-_Passkeys_-_Chrome_Prompt_for_Device_Credentials.png)\n    *   If the user selects **Try another way**, it prompts them to create a passkey on another device.\n        \n        ![](https://images.ctfassets.net/cdy7uua7fh8z/2yXrkVbYLxxp6MXnrZLqVN/5f67ddf9b8003729a11604a3af3e553d/passkey-browser-cross-device.png)\n\n### Login flow\n\nThe login flow detects if the user has a passkey registered to the current device and then automatically selects it using autofill. If the user has multiple passkeys registered to the device, they can manually select one with a button.\n\n1.  Prompts the user for an email address or a passkey.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3qqI3Uo1z1yQhvb7boQ0cx/820f38ffdec77388331ef238ff80de88/login-passkey_default.png)\n2.  User can use autofill or select **Continue with a passkey**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3zvWl2rpxzJ5klloIihRYB/a311cc3cc54075b7b92aca677ced29ba/login-passkey_filled.png)![](https://images.ctfassets.net/cdy7uua7fh8z/tC4UZmYFgo7Zjt9kviP9j/690b87af58068c18a4609c8e9431e5b7/Login_-_Passkeys_-_Choose_a_passkey.png)\n3.  Prompts the user to authenticate with the device’s credentials.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/6OJlPQrWBhgO8izXXoKbOw/a3c1af9a94aaeffc50793e3e9b88db8f/Signup_-_Passkeys_-_Chrome_Prompt_for_Device_Credentials.png)\n\n## Passkeys with MFA enabled\n\nIf MFA is enabled, the user may be prompted to complete an MFA challenge after authenticating with a passkey based on settings and risk assessment.\n\nThe default behavior is to require the completion of an MFA challenge regardless if the authentication method used was a password or a passkey. Given the high level of security passkeys provide, you may skip MFA for users that have authenticated with a passkey in order to reduce friction. This can be achieved by using a post-login Action.\n\nTo learn more, read [Reduce friction with passkeys](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow#reduce-friction-with-passkeys) and [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication).",
    "title": "Passkeys",
    "description": "Learn about implementing passkeys as an authentication method ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/password-strength",
    "markdown": "# Password Strength in Auth0 Database Connections\n\nAn important concern when using passwords for authentication is password strength. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means.\n\nThe following characteristics define a strong password:\n\n*   **Password Length**: Longer passwords include a greater combination of characters making it more difficult to guess. Passwords shorter than 10 characters are considered weak.\n    \n*   **Password Complexity**: Passwords containing a combination of upper-case and lower-case letters, numbers, and special characters are recommended.\n    \n*   **Passphrases**: Sentences or combinations of words can be much longer than typical passwords yet much easier to remember.\n    \n\n## Password policies\n\nAuth0's Password Strength feature allows you to customize the level of enforced complexity for passwords entered during user sign-up. Auth0 offers 5 levels of security to match [OWASP password recommendations](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md).\n\nAt each level, new passwords must meet the following criteria:\n\n*   **None** (default): at least 1 character of any type.\n    \n*   **Low**: at least 6 characters.\n    \n*   **Fair**: at least 8 characters including a lower-case letter, an upper-case letter, and a number.\n    \n*   **Good**: at least 8 characters including at least 3 of the following 4 types of characters: a lower-case letter, an upper-case letter, a number, a special character (such as `!@#$%^&*`).\n    \n*   **Excellent**: at least 10 characters including at least 3 of the following 4 types of characters: a lower-case letter, an upper-case letter, a number, a special character (such as `!@#$%^&*`). Not more than 2 identical characters in a row (for example, `111` is not allowed).\n    \n\n## Minimum password length\n\nYou can set a minimum length requirement for passwords that is independent of the policy strength requirements described in the [Password Policies section](#password-policies).\n\nThe minimum password length you can set is 1 byte, while the maximum is 72 bytes.\n\nIf you opt for a higher-level password policy, but you do not specify a minimum length value, the minimum password length for the policy level will automatically be used:\n\n| Password Policy Level | Minimum Password Length |\n| --- | --- |\n| None | 1   |\n| Low | 6   |\n| Fair | 8   |\n| Good | 8   |\n| Excellent | 10  |\n\nIf you provide a minimum password length, this value supersedes that indicated by the password policy.\n\n### Minimum password length when using Universal Login Pages\n\nIf you are using either the [Universal Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login) or the [Universal Login Password Reset Page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page), and you want to set the minimum password length value, you will need to complete a few additional configuration steps using the [Auth0 Dashboard](https://manage.auth0.com/#).\n\n#### Set minimum password length when using Hosted Password Reset Pages\n\nIf you're using a [customized Password Reset Page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page), and you want to set the password length parameter, you must:\n\n1\\. Update your templates to include library version 1.5.1 or later 2. Add `password_complexity_options` to leverage the new parameter\n\nIf you do not update the Password Reset Page, Auth0 ignores any attempt to set the minimum password length.\n\n##### Step 1: Update the change password library version\n\nTo use the new minimum password length feature, you should update the change password library used to version 1.5.1 (or later):\n\n```\n<script src=\"https://cdn.auth0.com/js/change-password-1.5.1.min.js\"></script>\n```\n\n##### Step 2: Add password\\_complexity\\_options to leverage the new parameter\n\nYou'll need to add `password_complexity_options` to leverage the new parameter. Add this option to the page's script as follows:\n\n```\n<script>\n    //code omitted for brevity\n    new Auth0ChangePassword({\n    container:                    \"change-password-widget-container\",     // required\n    email:                        '{{email}}',                            // DO NOT CHANGE THIS\n    csrf_token:                   '{{csrf_token}}',                       // DO NOT CHANGE THIS\n    ticket:                       '{{ticket}}',                           // DO NOT CHANGE THIS\n    password_policy:              '{{password_policy}}',                  // DO NOT CHANGE THIS\n    password_complexity_options:  {{password_complexity_options}}         // DO NOT CHANGE THIS\n\n    //code omitted for brevity\n\n  });\n</script>\n```\n\nScroll to the bottom, and select **Save**.\n\n#### Set minimum password length when using Universal Login Pages\n\nIf you're using a customized [Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login) and you want to set the password length parameter, you must [update the page to use Lock version 11.9 or later](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience).\n\n```\n<script src=\"https://cdn.auth0.com/js/lock/11.9/lock.min.js\"></script>\n```\n\nScroll to the bottom, and select **Save**.\n\n## Change your policy\n\nTo change the password strength policy, navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database). Choose the database connection you wish to update and select the Authentication Methods tab. In the Password section, select Configure, then locate the **Password Strength** section:\n\n![Auth0 Database Authentication - Password Policy - Password Strength](https://images.ctfassets.net/cdy7uua7fh8z/5DaTBH1ILrFFYXYPQzaxgl/73f7811885a0dec760b84a0cda0a5a7b/dashboard-connections-database-edit_view-password-policy_password-strength.png)\n\nThe new policy will be enforced on all subsequent user sign-ups and password changes. If the user enters a password that does not match the required criteria, the password will be rejected by Auth0 and the user will be asked to create one that complies with these requirements.\n\n### Lock\n\nAfter password policies have been enabled, users will be notified on signup and reset password Lock modes if their password does not meet the required criteria.\n\nThis is how Lock will appear on the desktop:\n\n![Auth0 Lock Password Strength checks on Desktop](https://images.ctfassets.net/cdy7uua7fh8z/3BOFON1gZiWRHl4Foybm5H/98d045d03e2b497a0eb389168f89978d/7cmjQFY45M.png)\n\nand on mobile:\n\n![Auth0 Lock Password Strength checks on Mobile](https://images.ctfassets.net/cdy7uua7fh8z/01rh02vYW6lBjOxBFh7HVC/619b3cea2e916987e4cfb0d1a835530b/moUbn4XXxR.png)\n\n## Custom signup errors\n\nSign-up errors will return a `400` HTTP status code. The JSON response will contain `code: invalid_password` when the password does not meet the selected password policy criteria.\n\nThe response will also contain additional information that can be used to guide the user to what is incorrect in the selected password:\n\n*   A `message` is ready to be formatted using the `printf` function (or Node.js `util.format`).\n    \n*   `format` is an array with values to be used in the `message`. (`message` is separate from the `format` to allow easier i18n of error messages in custom UIs.)\n    \n*   `verified` can be either `true` or `false`. Returns `false` if the rule has been violated.\n    \n\n### Examples\n\nThis is a sample `description` error report from a `good` policy with `hello` as the password:\n\n```\n{\n  \"rules\":[\n    {\n      \"message\":\"At least %d characters in length\",\n      \"format\":[8],\n      \"verified\":false\n    },\n    {\n      \"message\":\"Contain at least %d of the following %d types of characters:\",\n      \"format\":[3,4],\n      \"items\":[\n        {\n          \"message\":\"lower case letters (a-z)\",\n          \"verified\":true\n        },\n        {\n          \"message\":\"upper case letters (A-Z)\",\n          \"verified\":false\n        },\n        {\n          \"message\":\"numbers (such as 0-9)\",\n          \"verified\":false\n        },\n        {\n          \"message\":\"special characters (such as !@#$%^&*)\",\n          \"verified\":false\n        }\n      ],\n      \"verified\":false\n    }\n  ],\"\n  verified\":false\n}\n```\n\nThis is a sample `description` error report from a `good` policy with `hello1234` as the password:\n\n```\n{\n    \"rules\":[\n      {\"message\":\"At least %d characters in length\",\"format\":[8],\"verified\":true},\n      {\"message\":\"Contain at least %d of the following %d types of characters:\",\"format\":[3,4],\n        \"items\":[\n          {\"message\":\"lower case letters (a-z)\",\"verified\":true},\n          {\"message\":\"upper case letters (A-Z)\",\"verified\":false},\n          {\"message\":\"numbers (such as 0-9)\",\"verified\":true},\n          {\"message\":\"special characters (such as !@#$%^&*)\",\"verified\":false}\n        ],\"verified\":false}\n      ],\"\n      verified\":false\n    }\n```\n\n## Password options\n\nIn addition to the Password Strength feature explained here, the Password Policy settings for a database connection also include various Password Options that can further enhance your connection's password policy and ensure that your users have more secure passwords. To learn more, read [Password Options](https://auth0.com/docs/authenticate/database-connections/password-options).",
    "title": "Password Strength in Auth0 Database Connections",
    "description": "Auth0's Password Strength feature allows you to customize the level of enforced complexity for passwords entered during user sign-up. Auth0 offers 5 levels of security to match OWASP password recommendations.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/password-change",
    "markdown": "# Change Users' Passwords\n\nThis topic describes different ways to reset the password for a user in your database. You can change passwords for users in your [database connections](https://auth0.com/docs/authenticate/database-connections) only. Users signing in with [social](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers) or [enterprise](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers) connections must reset their passwords with the identity provider (such as Google or Facebook).\n\nThere are two basic methods for changing a user's password:\n\n*   [Trigger an interactive password reset flow](#trigger-an-interactive-password-reset-flow) that sends the user a link through email. The link opens the Auth0 password reset page where the user can enter a new password.\n    \n*   [Directly set the new password](#directly-set-the-new-password) using the Auth0 Management API or the Auth0 Dashboard.\n    \n\n#### Not what you're looking for?\n\n*   To configure the custom Password Reset page, read [Customize Password Reset Page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page).\n    \n*   To implement custom behavior after a successful password change, read [Actions Triggers: post-change-password](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow).\n    \n*   To reset the password to your personal Auth0 user account, read [Reset Account Passwords](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords).\n    \n\n## Trigger an interactive password reset flow\n\nThere are two ways to trigger an interactive password reset flow, depending on your use case: through the Universal Login page or the Authentication API.\n\n### Universal Login page\n\nIf your application uses Universal Login, the user can use the Lock widget on the Login screen to trigger a password reset email. With Universal Login, the user can click the **Don't remember your password?** link and then enter their email address. This fires off a POST request to Auth0 that triggers the password reset process. The user [receives a password reset email](#password-reset-email).\n\n### Authentication API\n\nIf your application uses an interactive password reset flow through the Authentication API, make a `POST` call. In the `email` field, provide the email address of the user who needs to change their password. If the call is successful, the user [receives a password reset email](#password-reset-email).\n\nIf you call the API from the browser, be sure the origin URL is allowed:\n\nGo to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications/{yourClientId}/settings), and add the URL to the **Allowed Origins (CORS)** list.\n\nIf your connection is a custom database, check to see if the user exists in the database before you invoke the Authentication API for `changePassword`.\n\n*   [cURL](#6d065832f3c2428e9145ab89019ce199_shell)\n*   [C#](#6d065832f3c2428e9145ab89019ce199_csharp)\n*   [Go](#6d065832f3c2428e9145ab89019ce199_go)\n*   [Java](#6d065832f3c2428e9145ab89019ce199_java)\n*   [Node.JS](#6d065832f3c2428e9145ab89019ce199_node)\n*   [Obj-C](#6d065832f3c2428e9145ab89019ce199_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/dbconnections/change_password' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\",\"email\": \"\",\"connection\": \"Username-Password-Authentication\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/dbconnections/change_password\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/dbconnections/change_password\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/dbconnections/change_password\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/dbconnections/change_password',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    email: '',\n    connection: 'Username-Password-Authentication'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"email\": @\"\",\n                              @\"connection\": @\"Username-Password-Authentication\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/dbconnections/change_password\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/dbconnections/change_password\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/dbconnections/change_password\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/dbconnections/change_password\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"email\": \"\",\n  \"connection\": \"Username-Password-Authentication\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/dbconnections/change_password\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Password reset email\n\nRegardless of how the password reset process was triggered, the user receives email containing a link to reset their password.\n\n![Password Reset Email](https://images.ctfassets.net/cdy7uua7fh8z/5IBhcrCJ7XXI6OgQOnHMJa/33cdafbfe7a63a48cfaa2e58a12a2494/password-reset-email.png)\n\nClicking the link sends the user to the [password reset page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page).\n\nAfter submitting the new password, the user sees confirmation that they can now log in with their new credentials.\n\nNotes on password resets:\n\n*   The reset password link in the email is valid for one use only.\n    \n*   If the user receives multiple password reset emails, only the password link in the most recent email is valid.\n    \n*   The **URL Lifetime** field determines how long the link is valid. From the Auth0 dashboard, you can [customize the Change Password email](https://auth0.com/docs/customize/email/email-templates) and [modify the link's lifetime](https://auth0.com/docs/api/authentication/reference#change-password).\n    \n*   You can extend the password reset flow to include another factor with Auth0 Actions. To learn more, read [Password Reset Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset).\n    \n\nWith [Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience), you can configure a URL to redirect users to after completing the password reset. The URL receives a success indicator and a message. To learn more, read the \"Configuring the Redirect-To URL\" section in [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\n[Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience) redirects the user to the [default login route](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes) when it succeeds, and handles the error cases as part of the Universal Login flow. This experience ignores the Redirect URL in the email template.\n\n#### Generate Password Reset tickets\n\nThe Management API provides the [Create a Password Change Ticket](https://auth0.com/docs/api/management/v2#!/Tickets/post_password_change) endpoint, which generates a URL like the one in the password reset email. You can use the generated URL when the email delivery method is not appropriate. Keep in mind that in the default flow, the email delivery verifies the identity of the user. (An impostor wouldn't have access to the email inbox.) If you use the ticket URL, your application is responsible for verifying the identity of the user in some other way.\n\n## Directly set the new password\n\nTo directly set a new password for the user without sending a password reset email, use either the [Management API](#use-the-management-api) or the [Auth0 Dashboard](#manually-set-users-passwords-using-the-auth0-dashboard).\n\n### Use the Management API\n\nIf you want to implement your own password reset flow, you can directly change a user's password from a server request to the Management API: make a `PATCH` call to the [Update a User endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id).\n\n*   [cURL](#fe3f80e9252a48218aaf0941dbda0f63_shell)\n*   [C#](#fe3f80e9252a48218aaf0941dbda0f63_csharp)\n*   [Go](#fe3f80e9252a48218aaf0941dbda0f63_go)\n*   [Java](#fe3f80e9252a48218aaf0941dbda0f63_java)\n*   [Node.JS](#fe3f80e9252a48218aaf0941dbda0f63_node)\n*   [Obj-C](#fe3f80e9252a48218aaf0941dbda0f63_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/%7BuserId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"password\": \"newPassword\",\"connection\": \"connectionName\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"application/json\", \"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/%7BuserId%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/%7BuserId%7D',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer {yourMgmtApiAccessToken}'\n  },\n  data: {password: 'newPassword', connection: 'connectionName'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"password\": @\"newPassword\",\n                              @\"connection\": @\"connectionName\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/%7BuserId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/%7BuserId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/%7BuserId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\"\n]\nlet parameters = [\n  \"password\": \"newPassword\",\n  \"connection\": \"connectionName\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/%7BuserId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Manually set users' passwords using the Auth0 Dashboard\n\nAnyone with administrative privileges to your Auth0 tenant can manually change a user's password at [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n\n1.  Select the name of the user whose password you want to change.\n    \n2.  Locate the **Danger Zone** at the bottom of the page.\n    \n3.  In the red **Change Password** box, select **Change**.\n    \n    ![Manually set password](https://images.ctfassets.net/cdy7uua7fh8z/5mrEG3UtlZW47AnTikwIGv/e630ad2f291bd9e355c8a6af03e9e168/dashboard-users-edit_view-details_danger-zone__1_.png)\n4.  Enter the new password, and select **Save**.",
    "title": "Change Users' Passwords",
    "description": "Describes the different ways to reset users' passwords for your Auth0 applications.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/require-username",
    "markdown": "# Adding Username for Database Connections\n\nFor database connections, you can have your users sign in with a username instead of their email address.\n\n## Require username\n\n1.  Go to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), and select the name of the connection you want to edit.\n    \n    ![Select connection](https://images.ctfassets.net/cdy7uua7fh8z/6shISO4Uw6XqldxxGnbrqW/0215e069f09c6baebd1d7abb5b3ae253/2024-03-20_16-39-37.png)\n2.  Locate **Requires Username**, and use the toggle to enable or disable requiring a username.\n    \n    ![Enable or disable require username setting](https://images.ctfassets.net/cdy7uua7fh8z/1MlOrFmcSCOCRYKRxWz6xT/aeda72f60869c61a3068bcb9ad5fe023/dashboard-connections-database-settings__1_.png)\n\nTo see how this will affect the login screen, select the **Try Connection** view. Notice that once **Requires Username** is enabled, new users must enter a username and their email address to sign up.\n\n![Login form with username](https://images.ctfassets.net/cdy7uua7fh8z/AiB37UZqyBPb8h55PZtzm/65c820f3637da094ded3d1ba4ed43a10/dashboard-connections-database-edit_view-try-connection-requires-username.png)\n\nUsers can then login with either their username or their email address. Users who registered while **Requires Username** was disabled will not have a Username field stored and will have to log in with their email address.\n\n### Username length\n\nThe default allowed length for usernames is between 1 and 15 characters. However, using the Auth0 Dashboard or via the Management API v2, you can modify the length minimum and maximum (up to a maximum length of 128 characters).\n\n![Username length](https://images.ctfassets.net/cdy7uua7fh8z/1u1fZqgsr7RUUl1s0F7bd7/ae94d939f3e1d9c6462c78c03bb1387e/dashboard-connections-database-settings_requires-username.png)\n\n### Allowed characters\n\nThe username field accepts the following characters:\n\n*   Alphanumeric characters (without accent marks, automatically converted to lowercase);\n    \n*   The at sign (@) character (but email addresses are not allowed);\n    \n*   The caret (^) character;\n    \n*   The dollar sign ($) character;\n    \n*   The dot (.) character;\n    \n*   The exclamation (!) character;\n    \n*   The grave accent (\\\\\\`) character;\n    \n*   The minus (-) character;\n    \n*   The number sign (#) character;\n    \n*   The plus (+) character;\n    \n*   The single quote (') character;\n    \n*   The tilde (~) character;\n    \n*   The underscore (\\_) character;\n    \n\nNo other characters/symbols are allowed, and Auth0 does not validate or sanitize custom database inputs.",
    "title": "Adding Username for Database Connections",
    "description": "Learn how to add a username field for login to database connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/activate-and-configure-attributes-for-flexible-identifiers",
    "markdown": "# Activate and Configure Attributes for Flexible Identifiers\n\n## Activate attributes configuration\n\n1.  Navigate to [**Auth0 Dashboard > Authentication > Database**](https://manage.auth0.com/#/connections/database), then select the Database Connection you’d like to activate from the list of **Database Connections**.\n    \n2.  Go to the **Attributes** tab and choose **Activate** on the **New Attributes Configuration** screen, then confirm you’ve tested your configuration in a Development environment. \n    \n3.  Select **Proceed**. The new configuration options become available.\n    \n\n![New EA feature, Attributes, needs to be activated by end users. ](https://images.ctfassets.net/cdy7uua7fh8z/3Ko21nSZQqR6MQHnsD0iMn/37a9b5e2818f893bf0e6283ad8e5bf49/2024-05-21_15-35-26.png)\n\n### Choose Attributes on a new connection\n\nAttributes are added to connections by navigating to [**Auth0 Dashboard > Authentication > Database**](https://auth0.com/docs/$manage_url/database).\n\nTo create a new connection, choose **\\+ Create DB Connection** and pick which Attributes to add. To add, configure, or remove Attributes in use by an existing connection, configure an existing connection, choose the **Attributes** tab and follow the instructions below.   \n\nDefault values are assigned to a new connection and can be edited after the connection has been created.\n\n| Setting | Value |\n| --- | --- |\n| Use `{attribute}` as Identifier | `True` |\n| Allow Signup with `{attribute}` | Required |\n| Require `{attribute}` on user profile | `True` |\n| Username Length | Min: 1 Max: 15 |\n| Allow usernames in email format | `False` |\n| Allow usernames in phone number format | `False` |\n\n### Add Attributes to an existing connection\n\nNavigate to the **Attributes** tab and choose **Activate**, then choose from the available Attributes and select the **Create** option.\n\n### Configure or remove existing Attributes on a connection\n\nAll Attributes can be changed or deleted from your Auth0 Dashboard. Users cannot log in, sign up or reset passwords using the removed Attribute, and a minimum of one Attribute must remain active on every connection.\n\nTo change or remove an Attribute, navigate to the Attributes tab, then choose the **...** menu button next to an Attribute and select **Configure** or **Remove** from the dropdown menu.\n\n### Revert a connection\n\nIf your tenant has `username` enabled as an Attribute, performing the following action requires you to modify your `username` settings. You'll need to reconfigure your username settings if you choose this path.\n\nTo revert a connection back to its original state, use the Management API to [PATCH the connection](https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id) endpoint `/api/v2/connections/:id` with an empty `options` object like the example below.",
    "title": "Activate and Configure Attributes for Flexible Identifiers",
    "description": "Describes how identifiers like email and phone must be configured in a user tenant.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/db2-script",
    "markdown": "# Login Script for IBM DB2\n\nIf you are integrating Auth0 with [IBM DB2](https://www.ibm.com/analytics/us/en/technology/db2), you can use the following script for your login process.\n\n```\nfunction login (email, password, callback) {\n  var ibmdb = require(\"ibm_db\");\n  var bcrypt = require('bcrypt');\n  var credentials = \"\";\n  credentials += \"DRIVER={DB2};\";\n  credentials += \"DATABASE=SAMPLE;\";\n  credentials += \"HOSTNAME=<db2host_url>;\";\n  credentials += \"UID=<user_name>;\";\n  credentials += \"PWD=<password>;\";\n  credentials += \"PORT=50001;\";\n  credentials += \"PROTOCOL=TCPIP\";\n  ibmdb.open(credentials, function(err, conn) {\n    if (err) callback(new Error(\"Error while trying to connect to auth source\"));\n    conn.query(\"select * from =<user_name>.USERS where email='\" + email + \"'\", function(err, data) {\n      if (err) callback(new Error(err));\n      else {\n      if (!bcrypt.compareSync(password, data[0].PASSWORDHASH)) return;\n      //map attributes to profile – sample below\n      var profile = {\n        user_id: data[0].ID,\n        nickname: data[0].EMAIL,\n        email: data[0].EMAIL,\n        given_name : data[0].FIRSTNAME,\n        family_name : data[0].LASTNAME\n      };\n      callback(null,profile);\n      }\n      conn.close(function() {\n      });\n    });\n  });\n}\n```",
    "title": "Login Script for IBM DB2",
    "description": "Provides a custom callback script for those integrating with IBM DB2.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/flexible-identifiers-and-attributes",
    "markdown": "# Flexible Identifiers and Attributes\n\nA **Flexible Identifier** is the attribute a user inputs on a login screen to authenticate themselves. You can choose from one or more types of identifiers: email and username are generally available, while the phone identifier is in our early access program. To learn more about Auth0 releases, review [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages).\n\n### Attribute and Identifier definitions\n\nFor this product, an **Attribute** is a piece of user data that can be stored, such as email, phone number, and username. All Identifiers are Attributes, but only specific attributes are Identifiers.\n\nAn **Identifier** is a unique Attribute that recognizes a distinct user in a given connection. Email, phone, and username can uniquely identify an individual and serve as Identifiers, while other attributes contribute to the user's profile without uniquely identifying a user.\n\n### Early Access changes and limitations\n\nFlexible Identifiers is available for early access with some limitations to the early access service:\n\n*   Flexible Identifiers including the phone attribute are only available with [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience) and you must [configure a phone provider](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers).\n    \n*   You must configure [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) to use phone verification on signup.\n    \n*   The email address attribute must be enabled to use [Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n    \n*   You must have email on the User Profile to use Signup invites for [Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview).\n    \n*   End users blocked under Brute Force Protection cannot unblock themselves via an email link. Other methods are available. To learn more, [read Brute Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection).\n    \n*   Flexible Identifiers moves the identifier field to the first login screen and changes the reset password prompt from email to username.\n    \n\n### Issues using Flexible Identifiers\n\nThe following is a list of potential issues you may encounter while configuring and managing Flexible Identifiers:\n\n*   If the scope `phone` is not specified in the authorization request by your application, you will not receive the `phone_number` claim. To learn more about scopes, [read Scopes](https://auth0.com/docs/get-started/apis/scopes).\n    \n*   Your Get User custom database action script must be valid when **Import Users to Auth0** is set to **on.** To learn more, [read Configure Automatic Migration from Your Database](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database).\n    \n*   Each user must be assigned a unique username and email address if **Custom Database with Import Mode** is set to **on**.\n    \n*   If you use the custom database action script Change Password and want to set `email` and `email_verified` to `True`, you must return the preferred `email_verified` state on the object. To learn more, [read Change Password](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password).\n    \n*   If you use a custom database connection with Import Users to Auth0 toggled off, you must align your user profile properties with the Auth0 normalized user profile. To learn more, [read Normalized User Profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles).\n    \n*   If you use a custom database connection with Import Users to Auth0 toggled on, Auth0 will check for uniqueness of `phone_number` and `phone_verified.`\n    \n*   Once you participate in the early access program, Identifier First prompts will change to display all identifiers on the first screen and remove your previous settings, and the Reset Password prompt will display the input field to Username instead of Email.\n    \n*   Familiarize yourself with best practices to avoid SMS Pumping attacks. To learn more, read our [whitepaper on SMS Pumping](https://www.okta.com/resources/whitepaper-handling-toll-fraud-and-sms-pumping-with-twilio-in-the-okta-customer-identity/).",
    "title": "Flexible Identifiers and Attributes",
    "description": "Describes limitations of Identifiers and Attributes. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates",
    "markdown": "# Custom Database Action Script Templates\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nIf you have your own database (known as a legacy data store in Auth0) containing user identity data, you can use it as an identity provider to authenticate users. You create and configure the connection to your legacy data store as a custom database in Auth0. You can choose to migrate data to Auth0's data store from your legacy database incrementally over time, or you can continue to use it without migrating data. We provide script templates to perform functions on the custom database that you can use and customize.\n\nThere are two different types of custom database scripts:\n\n*   **Automatic Migration**: Whenever a user logs into Auth0, if the user is not yet in Auth0, the script will check the legacy database to see if the user exists there. If found and the **Import users to Auth0** flag is turned on, the user data migrates the user to Auth0 data store. This capability is sometimes called **trickle migration** or **lazy migration**.\n    \n*   **Legacy Database**: Auth0 will always query the underlying database when a user tries to log in, is created, changes their password, verifies their email, or is deleted. If found and the **Import users to Auth0** flag is **not** turned on, user data stays in the legacy database and does **not** migrate to Auth0.\n    \n\nAuth0 provides the following custom database action scripts:\n\n*   [Change Password](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n    \n*   [Create User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n    \n*   [Delete User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n    \n*   [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n    \n*   [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n    \n*   [Verify User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n    \n*   [Change Email](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)\n    \n\n#### Network firewall\n\nIf you are behind a firewall, this feature may require that you add the appropriate Auth0 IP addresses to the Allow List to work properly.\n\n## Script execution\n\nAs described in [Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db), a custom database connection type allows you to configure action scripts: custom code that is used when interfacing with your legacy identity store. Each action script is essentially a named JavaScript function that is passed a number of parameters, with the name of the function and the parameters passed depending on the script.\n\n### Limits\n\nAction script execution supports the asynchronous nature of JavaScript, and constructs such as [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) objects can be used. Asynchronous processing effectively results in suspension pending completion of an operation, and an Auth0 serverless Webtask container typically has a 20-second execution limit, after which the container may be recycled. Recycling a container due to this limit will prematurely terminate operation, ultimately resulting in an error condition being returned (as well as resulting in a potential reset of the `global` object).\n\n### Completion and the callback function\n\nThe `callback` function supplied to each action script effectively acts as a signal to indicate completion of operation. An action script should complete immediately following a call to the `callback` function (either implicitly or by explicitly executing a JavaScript return statement) and should refrain from any other operation.\n\nIf an action script uses asynchronous processing, then a call to the `callback` function must be deferred to the point where asynchronous processing completes, and must be the final thing called. Asynchronous execution will result in a JavaScript `callback` being executed after the asynchronous operation is complete; this callback is typically fired at some point after the main (synchronous) body of a JavaScript function completes.\n\n## Learn more\n\n*   [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution)\n*   [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling)",
    "title": "Custom Database Action Script Templates",
    "description": "Learn about custom database action script templates.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages",
    "markdown": "# Customize Login Pages\n\n[Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process. \n\nUniversal Login is Auth0's primary hosted login solution. [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience) features easy-to-use customization tools and promotes a simpler, faster experience for end-users. Alternatively, Auth0 also supports [Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience), a hosted login experience that uses JavaScript controls for customization.\n\nFor a comparison between login experiences, review [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).",
    "title": "Customize Login Pages",
    "description": "Explore topics related to login page customization",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email",
    "markdown": "# Customize Emails\n\nYou can configure a test SMTP email server in your development or test environments to check for successful email delivery and view how emails you send appear to recipients prior to going to production. To learn more, read [Configure Test SMTP Email Server](https://auth0.com/docs/customize/email/configure-test-smtp-email-servers).\n\nAuth0's built-in email provider is **not supported for use in a production environment**, should only be used for testing, and has several restrictions:\n\n*   You will not be able to use any of the email customization features. The content of the emails sent for testing will be restricted to the format of the existing templates.\n    \n*   All emails will be sent from a predefined **from address** (`no-reply@auth0user.net`).\n    \n*   You will be restricted to sending no more than 10 emails per minute, regardless of email type.\n    \n*   Your ability to send email from your tenant may be reduced (or even temporarily blocked) if your emails result in high bounce rates.\n    \n\nTo remove these restrictions, you must set up your own email provider. Some options are:\n\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n    \n*   [Configure Custom External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)\n    \n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n    \n\nAfter you have configured your own email service provider, go to [Dashboard > Branding > Email Templates](https://manage.auth0.com/#/emails) to [customize your emails](https://auth0.com/docs/customize/email/email-templates). If you have an Auth0 database connection, there are several email templates you can use as part of the authentication flow:\n\n*   Verification emails (using link or code)\n    \n*   Welcome emails\n    \n*   Enroll in MFA emails\n    \n*   Change password emails\n    \n*   Blocked account emails\n    \n*   Password breach alert emails\n    \n\nYou can restrict user signups to an application with user invitations as a provisioning workflow, either in conjunction with or as an alternative to self-provisioning. To learn more, read [Send Email Invitations for Application Signup](https://auth0.com/docs/customize/email/send-email-invitations-for-application-signup).\n\nA paid subscription plan is required for email customization. To learn more, read [Auth0 Pricing Page](https://auth0.com/pricing).\n\n## Learn more\n\n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Set Up Database Connections](https://auth0.com/docs/get-started/applications/set-up-database-connections)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n*   [Configure Test SMTP Email Server](https://auth0.com/docs/customize/email/configure-test-smtp-email-servers)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)",
    "title": "Customize Emails",
    "description": "Describes the Auth0 built-in email services.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database",
    "markdown": "# Configure Automatic Migration from Your Database\n\nConfigure your Database connection to automatically migrate your users from an external user store to Auth0 with [custom database action scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates).\n\n## Configure Database connection as custom\n\nCreate a Database connection, and then set it to custom.\n\n1.  Go to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database) and select the database to view.\n    \n2.  Select the **Custom Database** view, and toggle on **Use my own database**.\n    \n    ![Auth0 Dashboard Authentication Database Connection Custom Database Settings Use Own Database Enabled](https://images.ctfassets.net/cdy7uua7fh8z/11HPAdVwJMmnWbzMVjHCJ8/c6583a1d8e3c02771fb81f2515f6e813/dashboard-connections-database-edit_view-custom-database_use-my-own-database.png)\n3.  Select the **Settings** view, toggle on **Import Users to Auth0**, and select **Save**.\n    \n    ![Dashboard Authentication Database Settings Import User to Auth0](https://images.ctfassets.net/cdy7uua7fh8z/1OqPgVsKGjRSRMNewmbU2y/4130babd9f0e6f1a38ecf565dd97e242/Screen_Shot_2021-05-18_at_8.33.49_PM.png)\n\n## Configure Database Action Scripts\n\nSelect the **Custom Database** view, and then locate **Database Action Scripts**.\n\n![Dashboard Authentication Database Connection Custom Database tab Database Action Scripts](https://images.ctfassets.net/cdy7uua7fh8z/4LBIvvjaABo51It4eVCmX3/4ef14765c79cc5b7ecfa3f3155caa9eb/Screen_Shot_2021-05-18_at_8.54.55_PM.png)\n\n### Login\n\nThe [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login) script executes each time a user who is not found in the Auth0 attempts to log in. It verifies that the user exists in the external user store without reprompting the user for their password.\n\n### Get User\n\nThe [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user) script executes after any of the following scenarios:\n\n*   A user initiates signup attempt.\n    \n*   A user initiates a change password flow.\n    \n*   A user enters their login identifier when using Identifier First + Biometrics.\n    \n*   The Management API [Update a User's Email or Username](https://auth0.com/docs/api/v2#!/Users/patch_users_by_id) or [Create User](https://auth0.com/docs/api/management/v2#!/Users/post_users) endpoint is called.\n    \n\nIf a user who has not been migrated confirms a password change and logs in successfully, their user profile will be created in the Auth0 with the new password. This user profile contains all the data returned in the Get User script. All subsequent logins for this user will be performed directly in Auth0.\n\n## Verify user migration is complete\n\nVerify that all users have been migrated to the Auth0 user store using the Auth0 Dashboard or the Auth0 Management API.\n\n1.  Go to [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users), and review the list of users.\n    \n2.  Use the Management API [List or Search Users](https://auth0.com/docs/api/v2#!/Users/get_users) endpoint.\n    \n\n## Disconnect external user store\n\nReconfigure the Database Action Scripts as no operation functions. This will prevent Auth0 from reaching out to your external user store to authenticate users.\n\n1.  Go to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), and then select your Database connection.\n    \n2.  Switch to the **Custom Database** view, and then locate **Database Action Scripts.**\n    \n3.  Update the **Login** script.\n    \n    ```\n    function login (email, password, callback) {\n      return callback(null, null);\n    }\n    ```\n    \n4.  Update the **Get User** script.\n    \n    ```\n    function getByEmail (email, callback) {\n      return callback(null, null);\n    }\n    ```\n    \n\n## Troubleshoot user migration issues\n\nIf you encounter any issues with automatic migration, first read [Custom Database Connection and Action Script Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts).\n\n### User already exists\n\nThe most common scenarios when you may encounter this issue:\n\n*   You delete a user from your Database connection and then try to recreate the user.\n    \n*   You attempt to create a new user on your Database connection when the user already exists in your external user store.\n    \n*   A user's migration process was interrupted.\n    \n\nDuring the user migration process, Auth0 first creates a partial user profile in an internal user store, and then creates a full user profile on your Database connection. If an issue occurs that prevents this full user profile from being created, you may encounter the `The user already exists` error.\n\nYou can usually resolve this issue by deleting the user from the Database connection, deleting the user from the internal user store, and then reattempting the migration process.\n\n1.  Check the `console.log()` statements with the [Real-time Webtask Logs extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs).\n    \n2.  Delete the user with the Management API [Delete a User](https://auth0.com/docs/api/management/v2#!/Users/delete_users_by_id) endpoint.\n    \n3.  Delete the user with the Management API [Delete a Connection User](https://auth0.com/docs/api/management/v2#!/Connections/delete_users_by_email) endpoint.\n    \n4.  Instruct the user to log in or change their password to reattempt migration.\n    \n\n### Missing metadata\n\nIf a user is interrupted during the login or change password flow that initiates the migration process, Auth0 may not be able to transfer their metadata (`user_metadata` or `app_metadata`) along with their other profile data.\n\nYou can mitigate this scenario by creating an [Action](https://auth0.com/docs/customize/actions) that verifies the user's profile is missing metadata, retrieves it from the external use store, and then stores it in Auth0.\n\n## Learn more\n\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)\n*   [User Import / Export Extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension)",
    "title": "Configure Automatic Migration from Your Database",
    "description": "Learn how to enable automatic user migration with your custom database.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/customize-sms-or-voice-messages",
    "markdown": "# Customize Multi-factor Authentication SMS and Voice Messages\n\nYou can customize SMS and voice messages sent by Auth0 during enrollment (when associating a device to Guardian) and verification (when an authentication message is sent to the device):\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa), and click **Phone Message**.\n    \n2.  Customize your message templates, and click **Save**.\n    \n\n![Dashboard - Security - Multifactor Auth - Phone Message - Templates](https://images.ctfassets.net/cdy7uua7fh8z/J6KTz7YTKeswbUjJa1YIs/ac89bdd4f58fb5bb7d25eb17fd94908b/dashboard-mfa_factor_phone-message.png)\n\nYou can customize templates for two message types:\n\n*   **Enrollment**: Message sent by Auth0 during device enrollment.\n    \n*   **Verification**: Message sent by Auth0 to verify the possession of the device.\n    \n\n## Syntax\n\n[Liquid](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers) syntax is the supported templating engine you use when accessing user attributes in SMS templates. The following attributes are available:\n\n| Attribute | Description |\n| --- | --- |\n| `message_type` | Indicates which kind of message is sent; `sms` or `voice`. |\n| `code` | Enrollment/verification code. When sending voice messages. Variable values are separated by dots between the digits (`1.2.3.4.5`) so it can be pronounced accurately by voice messaging providers. |\n| `locale` | For Universal Login or MFA API. Designates the language. |\n| `requestInfo.lang` | For Classic Login localization. Browser accept-language header. For example: `es-AR,es;q=8.0`, `en-US,en`. |\n| `tenant.friendlyName` | The **Friendly Name** set in **Dashboard > Tenant Settings**. |\n\n## Example\n\n```\n{% if message_type == \"voice\" %}\n  {% if locale contains \"fr\" %}\n  Bonjour, vous avez demandé à recevoir un code de vérification pour vous enregister avec {{tenant.friendly_name}}. Votre code est: {{pause}} {{code}}. Je répète, votre code est: {{pause}}{{code}}.\n  {% elsif locale contains \"es\" %}\n  Usted ha requerido un código de verificación para inscribirse con {{tenant.friendly_name}}. Su código es: {{pause}}{{code}}. Repito, su código es: {{pause}}{{code}}.\n  {% else %}\n  Hello, you requested a verification code to enroll with {{tenant.friendly_name}}. Your code is: {{pause}}{{code}}. I repeat, your code is: {{pause}}{{code}}.\n  {% endif %}\n{% else %}\n  {% if locale contains \"fr\" %}\n  {{code}} est votre code de vérification pour vous enregistrer avec {{tenant.friendly_name}}.\n  {% elsif locale contains \"es\" %}\n  {{code}} es su código para inscribirse con {{tenant.friendly_name}}.\n  {% else %}\n  {{code}} is your verification code to enroll with {{tenant.friendly_name}}.\n  {% endif %}\n{% endif %}\n```\n\n## Localization\n\nThe endpoints support the `x-request-language` header and you can use it to send the locale. See [](https://auth0.com/docs/connections/passwordless/guides/sms-otp#multi-language-support)[Multi-Language Support](https://auth0.com/docs/connections/passwordless/guides/sms-otp#multi-language-support) for details.\n\nThis is also supported in the MFA API (`POST /mfa/associate` and `POST /mfa/challenge` endpoints). When it's sent, that locale will be available in the `locale` variable in the MFA SMS/voice template.\n\nYou must also select those languages in **Tenant > Settings** (under **Supported Languages**) for this to work.\n\n## Learn more\n\n*   [Multi-Factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication)\n*   [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)",
    "title": "Customize Multi-factor Authentication SMS and Voice Messages",
    "description": "Learn how to customize SMS and voice messages sent by Auth0 during enrollment and verification.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/phone-messages",
    "markdown": "# Customize Phone Messages\n\nAuth0’s default phone message flow addresses the requirements of most applications. You may want to customize your phone message flow, such as in the following use cases:\n\n*   Localize your phone messages to meet the needs of different target markets.\n    \n*   Set a custom sending phone number based on the user or tenant.\n    \n*   Enable different phone message templates per application or tenant.\n    \n\nThe [Auth0 Management API](https://auth0.com/docs/api/management/v2) provides endpoints to help you manage your phone message flow to control when and how phone messages are sent. You can also implement and manage your own custom phone endpoints using the Auth0 Management API.\n\n## Learn more\n\n*   [Configure Phone Messaging Providers](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers)\n*   [Customize Phone Templates](https://auth0.com/docs/customize/phone-messages/customize-phone-templates)",
    "title": "Customize Phone Messages",
    "description": "Learn how to customize your phone message flow in the Auth0 Dashboard. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions",
    "markdown": "# Auth0 Actions\n\nActions are secure, tenant-specific, versioned functions written in Node.js that execute at certain points within the Auth0 platform. Actions are used to customize and extend Auth0's capabilities with custom logic.",
    "title": "Auth0 Actions",
    "description": "Describes Auth0 Actions, which are secure, tenant-specific, self-contained functions that allow you to customize the behavior of Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/rules",
    "markdown": "# Auth0 Rules\n\nRules can be used in a variety of situations as part of the authentication pipeline where protocol-specific artifacts are generated:\n\n*   an ID token in OpenID Connect (OIDC)\n    \n*   an access token in OAuth 2.0\n    \n*   an assertion in SAML\n    \n\nA new pipeline in which rules execute is created for each authentication request.",
    "title": "Auth0 Rules",
    "description": "Learn about Rules and how you can use them to customize and extend Auth0's capabilities.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/internationalization-and-localization",
    "markdown": "# Internationalization and Localization\n\nWas this article helpful?",
    "title": "Internationalization and Localization",
    "description": "Learn how to internationalize and localize emails, login prompts, and Lock password options. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/forms",
    "markdown": "# Forms for Actions\n\nForms for Actions is a visual editor that allows you to create customizable forms that can extend your identity flows with additional steps and business logic.\n\n![Dashboard > Actions > Forms](https://images.ctfassets.net/cdy7uua7fh8z/3QLVE6XsMRwhL17SUSMw8H/c679b99a8930d463a30352e1d11ee755/2024-05-09_14-20-42.png)\n\nSome of the key capabilities of Form for Actions include:\n\n*   Controlled and secure experience within your tenant's domain. Not required to [redirect](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions) users to external sites.\n    \n*   Pre-built components with frontend and backend validations.\n    \n*   Custom business logic with out-of-the-box integrations with third parties.\n    \n*   Consistent branding experience with Universal Login.\n    \n\nUsing Forms for Actions enables you to build use cases like:\n\n*   **Progressive profiling:** Defines a set of conditions to require users to complete additional information as they engage with your product. For example, when third-time users log in, you can require them to complete their profile.\n    \n*   **Custom policies acceptance:** If you need to update your policies, you can define logic to check if users have accepted the latest policies, and depending on that, display a custom form to users requiring acceptance.\n    \n*   **Custom signup or login steps:** Extend and customize your flows with additional steps and custom logic. For example, you can verify email or phone numbers with OTP and account linking, or verify payment details with Stripe, and more.",
    "title": "Forms for Actions",
    "description": "Forms for Actions is a visual editor that allows you to create customizable forms that can be used to extend your identity flows with additional steps and business logic.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/hooks",
    "markdown": "# Auth0 Hooks\n\nHooks are secure, self-contained functions that allow you to customize the behavior of Auth0 when executed for selected extensibility points of the Auth0 platform. Auth0 invokes hooks during runtime to execute your custom Node.js code.\n\nWhether hooks can be used with connections varies according to extensibility point. Hooks that can be used with connections only work with database and passwordless connections. To learn more, read [Database Connections](https://auth0.com/docs/connections/database) and [Passwordless Connections](https://auth0.com/docs/connections/passwordless).\n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Create Hooks](https://auth0.com/docs/hooks/create-hooks) | How to create hooks using the Dashboard or the Management API. |\n| [Update Hooks](https://auth0.com/docs/hooks/update-hooks) | How to update hooks using the Dashboard or the Management API. |\n| [Delete Hooks](https://auth0.com/docs/hooks/delete-hooks) | How to delete hooks using the Dashboard or the Management API. |\n| [Enable/Disable Hooks](https://auth0.com/docs/hooks/enable-disable-hooks) | How to enable and disable hooks using the Dashboard and Management API. |\n| [View Hooks](https://auth0.com/docs/hooks/view-hooks) | How to view hooks using the Dashboard and Management API. |\n| [View Logs for Hooks](https://auth0.com/docs/hooks/view-logs-for-hooks) | How to view real-time log events for specific configured hooks. |\n| [Extensibility Points](https://auth0.com/docs/hooks/extensibility-points) | About Auth0 extensibility points where hooks can be executed. |\n| [Hook Secrets](https://auth0.com/docs/hooks/hook-secrets) | About how hooks store secrets and how to manage them. |",
    "title": "Auth0 Hooks",
    "description": "Describes Auth0 hooks, some of which may be used with database and passwordless connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/extensions",
    "markdown": "# Auth0 Extensions\n\nAuth0 Extensions enable you to install applications or run commands/scripts that extend the functionality of the Auth0 base product. Each extension is separate from all other extensions. Auth0 defines extensions per tenant, so data is stored by the pair `tenant\\extension`.",
    "title": "Auth0 Extensions",
    "description": "Describes Auth0 extensions that enable you to install applications or run commands and scripts that extend the functionality of Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/integrations",
    "markdown": "# Auth0 Integrations\n\nReduce implementation time with Auth0-reviewed integrations that you can trust. The Auth0 platform is inherently extensible, allowing you to meet your specific needs by tailoring identity flows with custom code and integrating with third-party applications and tools.\n\nGo to [Auth0 Marketplace](https://marketplace.auth0.com/) to find and enable third-party identity solutions that integrate with our products.",
    "title": "Auth0 Integrations",
    "description": "Describes Auth0 integrations with third-party applications and services.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts",
    "markdown": "# User Accounts\n\nAuth0's hosted cloud database stores a variety of information on your users that is accessible to you. This information is available to you via a user profile, and your users are grouped by tenant. The user information itself can come from a variety of sources, including identity providers, your own databases, and enterprise connections (Active Directory, SAML).",
    "title": "User Accounts",
    "description": "Learn about working with user accounts in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/log-streams",
    "markdown": "# Log Streams\n\nAuth0's log streaming service allows you to export tenant log events to a log event analysis service URL. You can choose the content type and form and preview the payload using the Auth0 Dashboard. Log streaming allows you to react to events like password changes or new registrations with your own business logic. Using the Auth0 Dashboard, you can pause a stream, view and update settings, and check the health of the stream.\n\nYou can create a new log stream in the Auth0 Dashboard using one of the services we support or you can configure a stream to a service you already use with a custom webhook.\n\n![Dashboard Monitoring Streams](https://images.ctfassets.net/cdy7uua7fh8z/5ZY6sT68DabXNL9Dr4bhss/d14c4c42ff62634b1bd514e8b08aeda4/Log-Streaming2.png)\n\n## Supported log streaming services\n\nWe support a variety of [log streaming services](https://marketplace.auth0.com/features/log-streaming) through the [Auth0 Marketplace](https://marketplace.auth0.com/), including:\n\n*   [Amazon EventBridge](https://marketplace.auth0.com/integrations/amazon-log-streaming)\n    \n*   [Azure Event Grid](https://marketplace.auth0.com/integrations/azure-log-streaming)\n    \n*   [Elastic](https://marketplace.auth0.com/integrations/elastic-security)\n    \n*   [Logz.io](https://marketplace.auth0.com/integrations/logz-io)\n    \n*   [MDR ONE](https://marketplace.auth0.com/integrations/mdr-one)\n    \n*   [Mixpanel](https://marketplace.auth0.com/integrations/mixpanel-log-streaming)\n    \n*   [Oort](https://marketplace.auth0.com/integrations/oort)\n    \n*   [Pangea](https://marketplace.auth0.com/integrations/pangea-log-streaming)\n    \n*   [Panther](https://marketplace.auth0.com/integrations/panther-log-stream)\n    \n*   [Perch Security](https://marketplace.auth0.com/integrations/perch-security-log-streaming)\n    \n*   [Segment](https://marketplace.auth0.com/integrations/segment-log-streaming)\n    \n*   [Slack](https://marketplace.auth0.com/integrations/slack-log-streaming)\n    \n*   [Verosint](https://marketplace.auth0.com/integrations/verosint-log-stream)\n    \n*   [Datadog](https://marketplace.auth0.com/integrations/datadog-log-streaming) (Auth0 also provides Datadog dashboard templates you can use. To learn more, read [Use Auth0 Dashboard Templates with Datadog](https://auth0.com/docs/customize/log-streams/datadog-dashboard-templates).\n    \n*   [Splunk](https://marketplace.auth0.com/integrations/splunk-log-streaming) (Auth0 also provides a dashboard that you can use to visualize the data from your Auth0 tenant. The app allows you to use recommended aggregations from Auth0, or to use them as a starting point to create your own custom visualizations. To learn more, read [Use Auth0 App for Splunk](https://auth0.com/docs/customize/log-streams/splunk-dashboard).)\n    \n*   [Sumo Logic](https://marketplace.auth0.com/integrations/sumo-logic-log-streaming) (Auth0 provides an Auth0 App for Sumo Logic which creates a dashboard that you can use to visualize the data from your Auth0 tenant. The dashboard allows you to monitor the health of the login traffic for a tenant. The app allows you to use recommended aggregations from Auth0, or to use them as a starting point to create your own custom visualizations. To learn more, read [Use Auth0 App for Sumo Logic](https://auth0.com/docs/customize/log-streams/sumo-logic-dashboard).)\n    \n\n## Delivery attempts and log retention\n\nAuth0 uses a streaming mechanism that delivers each event to your server as it is triggered in our system. We guarantee events are delivered at least once.\n\nWhen an event is triggered:\n\n1.  We attempt to deliver the event to your server up to three times.\n    \n2.  If we fail to reach your server by the third attempt, we log an error visible in the **Health** view for the log stream.\n    \n3.  We restart this process for any errored events until the problem is resolved.\n    \n\nIf we fail to reach your server for 7 consecutive days, we'll automatically pause the stream. You'll need to resolve the issue, and then resume the stream manually.\n\nAuth0 retains events for 30 days. If there is an issue where your server does not receive log events sent from Auth0, you can set the **Starting Cursor** field to restart the stream from a specific day and time within the 30-day retention period.\n\n## Learn more\n\n*   [Create Custom Log Streams Using Webhooks](https://auth0.com/docs/customize/log-streams/custom-log-streams)\n*   [Check Log Stream Health](https://auth0.com/docs/customize/log-streams/check-log-stream-health)\n*   [Log Stream Filters](https://auth0.com/docs/customize/log-streams/event-filters)",
    "title": "Log Streams",
    "description": "Describes how to export your log events in near real-time using log streaming.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-migration",
    "markdown": "# Import and Export Users\n\nAuth0 supports importing users from external applications using custom database connections, the Auth0 Management API, or the User Import/Export Extension.\n\n## Automatic migrations\n\nAuth0 supports automatic migration of users from a [custom database connection](https://auth0.com/docs/connections/database/custom-db) to Auth0. This practice is sometimes known as **trickle migration** or **lazy migration**. By activating this feature, your users are:\n\n*   Moved to Auth0 the first time they log in after you set up the integration.\n    \n*   Not asked to reset their password as a result of the migration.\n    \n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nWhen a user authenticates via a custom database connection marked for import to Auth0, the following process takes place:\n\n*   Auth0 authenticates migrated users against the Auth0 database.\n    \n*   If the user has not been migrated, Auth0 executes your custom login script and, upon successfully log in, adds the user to the Auth0 database.\n    \n*   Subsequent logins result in the user's credentials retrieved from Auth0, **NOT** your custom database.\n    \n*   New users are automatically added to the Auth0 database.\n    \n\n![User Migration Diagram](https://images.ctfassets.net/cdy7uua7fh8z/JAHBs6NzVRf0N5iXI7Wby/770d8ad3f03a5f47ad28ec2947c92993/migrating-diagram.png)\n\n## Bulk user imports with the Management API\n\nIf you already have a user database, you can use our [`/post_users_imports`](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) Management API endpoint to populate a database connection with this information.\n\n## Migrate users with the User Import/Export Extension\n\nThe User Import/Export Extension allows you to:\n\n*   Bulk import your existing database users into Auth0.\n    \n*   Search for and export some (or all) of your Auth0 database users.\n    \n\nYou must be a Dashboard Admin to use this extension.\n\nYou can import and export user data using the User Import/Export Extension available on the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard. Select the **User Import / Export** extension and install it. For more information, see [User Import/Export Extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension).\n\n## Learn more\n\n*   [Configure Automatic Migration from Your Database](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database)\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)\n*   [User Import / Export Extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension)",
    "title": "Import and Export Users",
    "description": "Overview of importing users from external applications into Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/organizations",
    "markdown": "# Auth0 Organizations\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nThe Organizations feature represents a broad update to the Auth0 platform that allows our business-to-business (B2B) customers to better manage their partners and customers, and to customize the ways that end-users access their applications. Auth0 customers can use Organizations to:\n\n*   Represent their business customers and partners in Auth0 and manage their membership.\n    \n*   Configure branded, federated login flows for each business.\n    \n*   Build administration capabilities into their products, using Organizations APIs, so that those businesses can manage their own organizations.",
    "title": "Auth0 Organizations",
    "description": "Describes the Auth0 Organizations feature details.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-search",
    "markdown": "# Search for Users\n\nUser search allows you to retrieve user profile details using Auth0's [Management API](https://auth0.com/docs/api/management/v2). Search results can be [viewed](https://auth0.com/docs/manage-users/user-search/view-search-results-by-page), [sorted](https://auth0.com/docs/manage-users/user-search/sort-search-results), and [exported](https://auth0.com/docs/manage-users/user-migration/bulk-user-exports).\n\nMost user profile fields are not returned as part of an [ID Token](https://auth0.com/docs/secure/tokens/id-tokens), nor are they included in the response from the [`/userinfo` endpoint](https://auth0.com/docs/api/authentication#get-user-info) of the Authentication API.\n\nWhen searching for users in Auth0, you can use multiple endpoints to search for ID, email, or other criteria:\n\n## Search Result Terminology\n\nWe use the following terms to describe the user search results:\n\n*   **Eventually consistent**: Search results may not reflect a recently-completed write operation. However, if you repeat your request after a short period of time, the response will return up-to-date data.\n    \n*   **Immediately consistent**: Search results will reflect the results of all successful write operations, including those that occurred shortly prior to your request.\n    \n\n## Learn more\n\n*   [User Search Query Syntax](https://auth0.com/docs/manage-users/user-search/user-search-query-syntax)\n*   [Retrieve Users with the Get Users Endpoint](https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint)\n*   [Sort Search Results](https://auth0.com/docs/manage-users/user-search/sort-search-results)",
    "title": "Search for Users",
    "description": "Understand how the Auth0 Management API search endpoints allow you to search for and retrieve user profiles.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/access-control",
    "markdown": "# Access Control\n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/rbac) | About the concept of role-based access control and how it applies in Auth0. |\n| [Authorization Policies](https://auth0.com/docs/manage-users/access-control/authorization-policies) | About the concept of authorization policies and how they apply in Auth0. |\n| [Rules for Authorization Policies](https://auth0.com/docs/manage-users/access-control/rules-for-authorization-policies) | How rules apply to authorization policies and Auth0's role-based access control (RBAC) system. |\n| [Sample Use Cases: Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/sample-use-cases-role-based-access-control) | How to implement roles-based authorization (RBAC) in different scenarios and explore how to use rules with RBAC. |\n| [Sample Use Cases: Actions with Authorization](https://auth0.com/docs/manage-users/access-control/sample-use-cases-actions-with-authorization) | How to use actions with roles-based access control (RBAC). For use with our Authorization Core feature set. |\n| [Sample Use Cases: Rules with Authorization](https://auth0.com/docs/manage-users/access-control/sample-use-cases-rules-with-authorization) | How to use rules with roles-based access control (RBAC). For use with our Authorization Core feature set. |\n| [Authorization Core vs. Authorization Extension](https://auth0.com/docs/manage-users/access-control/authorization-core-vs-authorization-extension) | About the differences between Auth0's core RBAC release and the Authorization Extension. |\n| [Configure Core RBAC](https://auth0.com/docs/manage-users/access-control/configure-core-rbac) | How to configure Auth0 Core Authorization features for role-based access control (RBAC) of your APIs. |",
    "title": "Access Control",
    "description": "Explore topics related to access control, including role-based access control (RBAC), authorization policies, and the differences between Auth0's core authorization feature and the authorization extension.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/application-credentials",
    "markdown": "# Application Credentials\n\nConfidential applications, unlike public applications, can securely store credentials. When confidential applications request access or ID tokens from the [token endpoint](https://auth0.com/docs/api/authentication#get-token), the application must authenticate with the authorization server. During this request for tokens, the application provides credentials known by the application. Additionally, application credentials can also provide authenticity and integrity protection for request parameters sent to the [`/authorize`](https://auth0.com/docs/api/authentication#authorize-application) endpoint.\n\nTo learn more about confidential applications versus public applications, read [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n\n## Application authentication methods\n\nTo get tokens from Auth0, your application must authenticate through the [Authentication API](https://auth0.com/docs/api/authentication). Auth0 supports the following ways your application can authenticate:\n\n*   **Client Secret:** A symmetrical authentication method. In Client Secret authentication, you use the Client Secret Auth0 generated when you created the application.\n    \n*   **Private Key JWT:** An asymmetric authentication method. In Private Key JWT, you generate a pair of keys, public and private, to use as credentials. You provide the public key and securely store the private key in your own systems without sharing it with Auth0.\n    \n*   **mTLS for OAuth:** An asymmetric authentication method. In mTLS for OAuth, you register a standard X.509 client certificate with Auth0. Then, you use the corresponding private key to securely establish the mTLS tunnel to send requests to your Auth0 tenant endpoints.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3tPMyIcI7dTfnJLY5lASun/2e566bc0de8b8352bb15a22f40b6c84c/Screenshot_2024-05-28_at_4.30.51_PM.png)\n\n### Client Secret authentication\n\nClient Secret authentication is a symmetric authentication method included in the [OAuth 2.0 specification](https://www.rfc-editor.org/rfc/rfc6749#section-2.3). Client Secret authentication is the default authentication method in Auth0.\n\nThis authentication method is supported by all existing applications and tooling. The Client Secret is a high-entropy value generated by Auth0 when you create an application and is known by both your application and Auth0. Your application authenticates by including the Client Secret in the request to the authorization server.\n\nSome security risks are associated with using Client Secret as a credential, especially for scenarios with higher security demands:\n\n*   The secret used by the application is shared with Auth0.\n    \n*   The secret is sent over the network and could be intercepted in the case of man-in-the-middle attacks. \n    \n\nAn application can have a single Client Secret. It is not possible to rotate the secret while you update your implementation with the new secret. To learn more, read [Rotate Client Secrets](https://auth0.com/docs/get-started/applications/rotate-client-secret).\n\n### Private Key JWT authentication\n\nPrivate Key JWT authentication is an asymmetric authentication method that relies on private and public key pairs. To learn more, read [JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants](http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer).\n\nYou can use the Auth0 Dashboard or Auth0 Management API to configure a tenant to use Private Key JWT. To learn more, read [Configure Private Key JWT Authentication.](https://auth0.com/docs/get-started/applications/configure-private-key-jwt)\n\nIn Private Key JWT, a request to the authorization server consists of two main steps:\n\n1.  Configure public and private keys:\n    \n    1.  [Generate a key pair](https://auth0.com/docs/secure/application-credentials/generate-rsa-key-pair) (one public key and one private key).\n        \n    2.  Register the private key with the application making the authentication request and register the public key with the identity provider (IdP).\n        \n2.  Build an assertions for requests to the authorization server:\n    \n    1.  Create a new assertion with specified claims in JWT format and sign it with the private key. Include this assertion as part of the request to the IdP.\n        \n    2.  IdP validates the assertion using the public key.\n        \n\nTo configure Private Key JWT for Auth0, read [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt). To learn more about building an assertion for Private Key JWT, read [Authenticate with Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt).\n\nThere are some security benefits associated with using Private Key JWT:\n\n*   The private key is not transmitted over the network and reduces the exposure risk of your application’s credentials. Identity providers like Auth0 have no knowledge of the private key, and only applications that have access to the private key can create authentication requests.\n    \n*   The signed assertions have a short expiry time, limiting the window of opportunity for replay attacks.\n    \n\n### mTLS for OAuth\n\n[mTLS for OAuth](https://www.rfc-editor.org/rfc/rfc8705) authenticates requests to the authorization server using mutual TLS based on self-signed certificates or public key infrastructure (PKI). Read [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls) to learn more about how mTLS authentication works at Auth0.\n\nAuth0’s mTLS for OAuth initially targets customers in highly regulated sectors such as finance and healthcare that most likely already have mTLS deployments. To simplify customer adoption, the mTLS feature builds on [custom domains](https://auth0.com/docs/customize/custom-domains) and leverages the customer’s existing mTLS infrastructure to perform certificate provisioning and verification. To learn more about authenticating with mTLS and setting up your edge network, read [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls) and [Set up your customer edge](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge). \n\nTo learn how to configure mTLS, read [Configure mTLS Authentication](https://auth0.com/docs/get-started/applications/configure-mtls). Once you have set up your edge network and configured mTLS, your application needs to establish the mTLS tunnel to send requests to Auth0, as explained in [Call the authorization server](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls#call-the-authorization-server).\n\nIn mTLS, the client certificate’s private key is not transmitted over the network, reducing the risk of exposing your application credentials. Identity providers like Auth0 do not have access to the private key. Only applications that have access to the private key can authenticate.\n\n[JWT-Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/rfc9101/) is an OAuth2 protocol extension that enhances the security of authorization requests. It does so by using a JSON Web Token (JWT) request parameter to protect the integrity and confidentiality of the authorization request parameters.\n\nYou can use the [Auth0 Management API](https://auth0.com/docs/api/management/v2) to configure JAR for your application. Auth0 implementation for JAR uses asymmetric cryptography, where you register the public key while securely storing the private key on your end. To learn more, read [Configure JWT-Secured Authorization Requests](https://auth0.com/docs/get-started/applications/configure-jar).\n\nWhen using JAR, the client creates a JWT that includes the authorization request parameters, signs it with its private key, and sends it to the authorization server. The authorization server then verifies the signature using the client's public key, and if the signature is valid, extracts the authorization request parameters from the JWT and processes the request as usual. To learn more about how to use JAR, read [Authorization Code Flow with JWT-Secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar).\n\n### Key and certificate registration\n\nYou can register two public keys for an application at the same time. Auth0 handles verification against the proper key and allows you to rotate with no downtime. Once the old key has been removed or deactivated, all requests signed with the corresponding private key are invalidated.\n\n**Note:** Auth0 supports the following algorithms for application authentication and authorization request signing: RS256, RS384 and PS256. Please make sure to provide the appropriate keys for them. To learn more, read [Configure Private JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt) and [Configure JWT-Secured Authorization Requests](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar).\n\nSimilarly, for mTLS client certificates, you can register two client X.509 certificates (self-signed or with the CA cert’s Subject DN) at the same time for an application. Auth0 handles verification against both client certificates, which allows you to rotate certificates with zero downtime.\n\n## Update application authentication method\n\nYou can update an application’s authentication method in the Auth0 Dashboard. To learn more, read [Credential Settings](https://auth0.com/docs/get-started/applications/credentials).\n\n## Learn more\n\n*   [Credential Settings](https://auth0.com/docs/get-started/applications/credentials)\n*   [Authenticate with Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)\n*   [Rotate Credentials](https://auth0.com/docs/get-started/applications/rotate-credentials)\n*   [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt)\n*   [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls)",
    "title": "Application Credentials",
    "description": "Describes ways you can authenticate your application with Auth0 services.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/sessions",
    "markdown": "# Sessions\n\nA session is a group of interactions between a user and an application during a given timeframe. A single session may consist of multiple activities (such as page views, events, social interactions, and e-commerce transactions) and can store this information temporarily while the user is connected.\n\nWith a standard Set-Cookie header implementation, a session ends when a user leaves a website or closes their browser. To prevent users from having to log in every time, applications can extend sessions by setting a maximum lifetime for the session cookie. Sessions end when a user logs out or a session lifetime limit is reached.\n\nTo learn more, review [Auth0 Privacy and Cookie Policy](https://auth0.com/privacy).\n\n## Session use cases\n\nAuth0 maintains a login session for any user who authenticates through an application. When a user performs a new standard login, Auth0 resets the login session. Updating a password, email, or phone number also causes a user's Auth0 session to expire.\n\nWhen you build an application requiring authentication, you can use sessions to determine whether a user is authenticated each time a request occurs. Depending on how your app has been built, different authorization flows are recommended to support a more secure experience for users.\n\nFor example, consider an OIDC-compliant (OpenID Connect) website called storezero.io.\n\n![Example e-commerce website Storezero.io](https://images.ctfassets.net/cdy7uua7fh8z/5XXxdX4fuApQtAapQfZU1b/2fd9161af60962e3de3fc951d95b83d1/use-case-storezero.png)\n\nStorezero.io does not require its users to log in to complete purchases. However, users must log in to view the My Account section of the site. \n\nFor the use cases listed below, consider a scenario where a user wants to review their previous orders prior to checking out. To do so, they navigate to the All Orders page of the My Account section and are prompted to log in. \n\n### Login flows\n\nMost types of applications (such as web apps, single-page apps, and native apps) should use the [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) to facilitate login authentication. This flow involves exchanging an authorization code for tokens.\n\n#### User logs in with username and password\n\nIn this example, a user manually logs in using their username and password:\n\n1.  Auth0's SDK creates a local session and redirects the user to the Auth0 authorization server (`/authorize` endpoint).\n    \n2.  The authorization server creates a session, then redirects the user to the login and authorization prompt.\n    \n3.  The user authenticates using their username and password.\n    \n4.  The Auth0 authorization server updates the user’s previously-created session to indicate they are logged in.\n    \n5.  Depending on the flow used, the authorization server returns the user to your application, along with either an ID token or an authorization code.\n    \n6.  Your application exchanges the token or authorization code for an access token and completes the flow.\n    \n\nWith this flow, two sessions are created:\n\n*   The **local session** (storezero.io), which indicates to the application whether a user is authenticated.\n    \n*   The **authorization server session** (storezero.auth0.com), which indicates to the server whether a user is authenticated. The server session can also optionally track details about the authentication.\n    \n    *   For example, the authorization server can track if a user leveraged [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication). This information can then be used to determine whether a user should be prompted to log in or use MFA the next time they arrive at the authorization server.\n        \n\n#### User logs in with identity provider\n\nIn this example, the user opts to log in with Facebook instead of their username and password: \n\n1.  Auth0's SDK creates a local session and redirects the user to the Auth0 authorization server (`/authorize` endpoint).\n    \n2.  The authorization server creates a session, then redirects the user to the login and authorization prompt. \n    \n3.  Upon choosing to log in with Facebook, the authorization server redirects the user to Facebook. \n    \n4.  Facebook creates a session and authenticates the user. Facebook then updates its session to indicate the user is logged in. \n    \n5.  Facebook returns the user to the Auth0 authorization server. The authorization server then updates its session to indicate the user is logged in.\n    \n6.  Depending on the flow used, the authorization server returns the user to your application, along with either an ID token or an authorization code.\n    \n7.  Your application exchanges the token or authorization code for an access token and completes the flow.\n    \n\nIn this scenario, three sessions are created: the **local session** (storezero.io), the **authorization server session** (storezero.auth0.com), and an **identity provider (IdP) session** (facebook.com).\n\nThe IdP session on Facebook's server authenticates the user and provides a seamless SSO experience. As there is a high probability that users are already logged in to Facebook, users are often authenticated without having to manually provide their Facebook credentials.\n\n### Session management for SPAs\n\nIn the previous examples, a local session is created when the user initiates either login flow. This local session can keep users logged in and determine when they need to reauthenticate.\n\nHowever, local sessions are not available for applications without backends, such as single-page apps (SPAs). Instead, these applications use a different approach known as [silent authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication) to keep users logged in.\n\nSilent authentication uses the session on the authorization server to determine when a user must reauthenticate. A hidden iframe redirects authentication requests to the authorization server along with the `prompt=none` parameter. This parameter prevents the server from prompting the user for input.\n\n*   If the session on the authorization server has not expired, the transaction continues seamlessly. The server sends an access token through WMRM (Web Message Response Mode), which leverages `postMessage`. \n    \n*   If the session on the authorization has expired or the user logs out, the redirect in the iframe returns an error. The application must then direct the user to the authorization server for reauthentication.\n    \n\n## Learn more\n\n*   [Session Layers](https://auth0.com/docs/manage-users/sessions/session-layers)\n*   [Session Lifetime Limits](https://auth0.com/docs/manage-users/sessions/session-lifetime-limits)\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Cookies](https://auth0.com/docs/manage-users/cookies)\n*   [SameSite Cookie Attribute Changes](https://auth0.com/docs/manage-users/cookies/samesite-cookie-attribute-changes)\n*   [Authenticate Single-Page Apps With Cookies](https://auth0.com/docs/manage-users/cookies/spa-authenticate-with-cookies)",
    "title": "Sessions",
    "description": "Describes what sessions are and how the are used in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/cookies",
    "markdown": "# Cookies\n\nCookies are strings of data that a web server sends to the browser. When a browser sends a future request to the web server, it sends the same string to the web server along with its request.\n\nWebsites typically use cookies to ensure that users are recognized when they move between pages, so they don't get asked to log in again every time. Websites also use cookies to remember information users have entered. For example, e-commerce sites use cookies to remember the items placed in a shopping cart.\n\nUsers can choose whether to accept cookies by changing the settings in their browser.\n\n## Cookie-based authentication\n\nTypically, single-page apps (such as React, Vue, and AngularJS + Node), native mobile apps (such as iOS and Android), and web APIs (written in Node, Ruby, ASP.NET, or a mix of those) benefit most from token-based authentication. Traditional, server-side web applications have traditionally used cookie-based authentication.\n\nCookie-based authentication is implemented by each web platform differently, but at the end of the day, they all end up setting some cookie (tied to a session on the server) which represents the authenticated user. On each request, that cookie is sent and the session is deserialized from some store (in memory if it's a single server or some persistent storage if it's a server farm). We provide SDKs for most of the platforms that will tie into the corresponding authentication subsystem (such as passport on node, IPrincipal on .NET or Java, and so on).\n\nWhen you build an application that requires authentication, you can use sessions and cookies to determine if a user is authenticated each time a request is made. To do this, you can choose to use either stateful or stateless cookies.\n\n### Stateful cookies\n\nStateful cookies contain a pointer to a database record that stores the session information.\n\n**Pros**:\n\n*   Have no limitations on amount of session information stored.\n    \n*   Can easily clear a user's session--just remove the record from the database.\n    \n\n**Cons**:\n\n*   Requires a database to store the session data (but most web applications already have this).\n    \n*   Increases latency because you have to make database calls to read the session (and sometimes write it) for each HTTP request a user makes.\n    \n*   Can be challenging to scale when you have many users and therefore many reads/writes to your database.\n    \n\n### Stateless cookies\n\nStateless cookies are self-contained; they include all session information that you need (for authenticated users, the user ID) and reside on the client. To prevent external tampering, stateless cookies should be encrypted (or at least signed).\n\n**Pros**:\n\n*   Can implement easily; doesn’t require a special backend.\n    \n*   Reduces latency because you don't have to call a database.\n    \n*   Easy to scale.\n    \n\n**Cons**:\n\n*   Must restrict stored session information because cookies are limited in size (max 4KB in most browsers). Although session information may be split between multiple cookies, we don't recommend it.\n    \n*   Makes it difficult to revoke a session, because there is no record in a database you can delete; you’ll need to find other methods to forcefully clear a session.\n    \n*   If using multiple web servers, must make sure all servers have the key to encrypt/decrypt or sign the cookie.\n    \n\n## Learn more\n\n*   [Sessions](https://auth0.com/docs/manage-users/sessions)\n*   [Authentication API Cookies](https://auth0.com/docs/manage-users/cookies/authentication-api-cookies)\n*   [SameSite Cookie Attribute Changes](https://auth0.com/docs/manage-users/cookies/samesite-cookie-attribute-changes)\n*   [Secure](https://auth0.com/docs/secure)",
    "title": "Cookies",
    "description": "Describes what cookies are and how they can be used with sessions to track user authentication.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/attack-protection",
    "markdown": "# Attack Protection\n\nAuth0 can detect attacks and stop malicious attempts to access your application such as blocking traffic from certain IPs and displaying CAPTCHA.\n\nIn the [Auth0 Dashboard](https://manage.auth0.com/#/security/attack-protection), you can enable the following attack protection options to mitigate attacks:\n\n*   [](https://auth0.com/docs/secure/attack-protection/brute-force-protection)[Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection)\n    \n*   [Suspicious IP Throttling](https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling)\n    \n*   [Brute Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection)\n    \n*   [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection)\n    \n\n![Dashboard Security Attack Protection page](https://images.ctfassets.net/cdy7uua7fh8z/7IxNz72aMoNqIEgGKPZiuv/ee9f7ec600bd2495bf51d0b338939b25/dashboard-attack-protection-list.png)\n\n## How it works\n\nWhen it comes to combatting abuse, there is no silver bullet. Auth0 supports the principle of layered protection in security that uses a variety of signals to detect and mitigate attacks.\n\n| **Feature** | **Risk signal** | **How it works** |\n| --- | --- | --- |\n| Bot Detection | **IP reputation** computed by analyzing the quality of traffic seen for each IP. | Triggers a CAPTCHA step when a login attempt comes from an IP suspected of use by a bot. |\n| Suspicious IP Throttling | **Velocity** of login attempts from an IP for any number of accounts against a tenant. | Detects when a bot/script tries too many username/password combinations within a short period of time. |\n| Brute-force Protection | **Velocity** of login attempts from an IP for a particular account. | Detects when a bad actor tries to login to an account too many times within a period of time. |\n| Breached Password Detection | **Use of a breached password** that appears in lists of breached passwords on the dark web. | Stops users from using passwords that are known to be breached in some 3P sites. |\n\n## Notification\n\nIn the event of an attack, users will be notified by email once per hour regardless of the number of logins. For example, if a user tries to log in 200 times in 1 hour and 30 minutes, we will send 2 emails. Password reset links are valid for 5 days. You can [customize the emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails) sent to your users.\n\nIn the event of an ongoing attack, traffic can be blocked from thousands of IP addresses at a time. Auth0 will send a single email to each administrator every hour that traffic is blocked, regardless of the number of IPs involved in the attack.\n\n## Monitoring\n\nEnabling attack protection features without configuring response settings activates Monitoring mode, which records related events in your tenant log only. The tenant log will contain information about whether the login was determined to be risky so you can determine if you want to configure responses.\n\n## Reporting\n\nYou can also create reports using tenant log data to [see attack protection events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events).\n\n## Learn more\n\n*   [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection)\n*   [Suspicious IP Throttling](https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling)\n*   [Brute-Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection)\n*   [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection)\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)",
    "title": "Attack Protection",
    "description": "Describes how Auth0 detects attacks to stop malicious attempts to access your application, alert you and your users of suspicious activity, and block further login attempts.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/security-center",
    "markdown": "# Security Center\n\nSecurity Center provides observability tools that allow you to see potential attack trends and quickly respond to them in real-time. Security Center provides real-time monitoring that allows you to observe your own Customer Identity and Access Management (CIAM) anomaly detection metrics, and lets you configure attack mitigation features from within the same space.\n\n## Real-time monitoring\n\nSecurity Center provides you with an overview of your tenant’s security pulse and allows you to drive outcomes from within the Auth0 Management Dashboard. In Security Center, you can:\n\n*   Monitor your total traffic and total threats\n    \n*   Observe threat behavior trends\n    \n*   Identify applications associated with threat behavior trends\n    \n*   Track login and signup traffic\n    \n*   Monitor threats identified by our Attack Protection and MFA features\n    \n\n### Filtering and aggregation\n\nSecurity Center allows you to filter available data to your needs.\n\nYou can filter data based on a time period, including:\n\n*   Last hour\n    \n*   Last 12 hours\n    \n*   Last day\n    \n*   Last 7 days\n    \n*   Last 14 days\n    \n\nDepending on the time period you select, the data is automatically aggregated per minute, per hour, or per day.\n\n### Threat behavior trends\n\nSecurity Center allows you to observe threat behavior trends for the following threat types:\n\n*   **Credential stuffing**: Behavioral patterns that appear to involve a machine attempt with the goal of submitting credentials to compromise user accounts.\n    \n*   **Signup attack**: Behavioral patterns that appear to involve a machine attempt with the goal of creating new user accounts.\n    \n*   **MFA bypass**: Behavior patterns that appear to involve a machine attempt with the goal of circumventing user multi-factor authentication (MFA) protections.\n    \n\nViews allow you to slice data by threat type and identify applications associated with threat behavior trends.\n\n![Screenshot shows a dashboard, a line graph, a horizontal bar chart, and a doughnut chart. The dashboard details the total traffic, total threats, and percentage of threats. The line graph details threat behavior trends by traffic type. Separate lines exist for normal traffic, credential stuffing, signup attacks, and MFA bypass threats. The horizontal bar chart details threat behavior by app. Each bar represents a specific app and different threat types are color coded within the bar. The doughnut chart details the threat behavior type breakdown and different threat types are color coded within the doughnut.](https://images.ctfassets.net/cdy7uua7fh8z/2hyZMfdrGwVZxKtuV4ZOR3/f1795066d12eb02550da8f4eb0f00fd5/Threat_Behavior.png)\n\n### Authentication events\n\nSecurity Center allows you to inspect authentication events, including login attempts and signup attempts.\n\n![Screenshot shows two line graphs. One shows the number of login attempts in the last 7 days. Separate lines are shown for successful logins and failed logins. The other shows the number of signup attempts over the last 7 days. Separate lines are shown for successful signups and failed signups.](https://images.ctfassets.net/cdy7uua7fh8z/6ywLqRG3zUAMwkAEGDoDoU/c24aa46d823ae702861ef57ee14dd9e6/Authentication.png)\n\n#### Login attempts\n\nLogin attempts include both successful and failed login transactions over the last seven days.\n\n#### Signup attempts\n\nSignup attempts include both successful and failed signup transactions over the last seven days.\n\n### Attack Protection and MFA monitoring\n\nSecurity Center helps you understand current attack trends identified by our Attack Protection and MFA features, and allows you to implement countermeasures by enabling and configuring these features:\n\n#### Bot detection\n\nBot detection mitigates scripted attacks by detecting when a request is likely to be coming from a bot. Bot detection includes the number of bots detected over the last seven days.\n\n![Screenshot shows a line graph detailing number of bots detected in the last 7 days.](https://images.ctfassets.net/cdy7uua7fh8z/vfXBOFaB8fprq7rbr1vPG/0676832da280a528326b44f97624e8ff/Bot_Detection.png)\n\nTo learn more about this feature, read [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection).\n\n#### Suspicious IP throttling\n\nSuspicious IP throttling blocks traffic from any IP address that rapidly attempts too many logins or signups. Suspicious IP throttling includes the number of suspicious IPs blocked over the last seven days.\n\n![Screenshot shows a line graph detailing number of suspicious IP activities detected in the last 7 days.](https://images.ctfassets.net/cdy7uua7fh8z/4q2Gso3wAbdAMM9YCUSxTk/23026864247740c4530668a8c4d21665/Suspicious_IP_Throttling.png)\n\nTo learn more about this feature, read [Suspicious IP Throttling](https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling). \n\n#### Brute-force protection\n\nBrute-force protection safeguards against a single IP address attacking a single user account. Brute-force protection includes the number of blocked brute-force attempts over the last seven days.\n\n![Screenshot shows a line graph detailing number of brute-force attempts blocked in the last 7 days.](https://images.ctfassets.net/cdy7uua7fh8z/2nDIp8GDPe2zhhzcdDPKue/a49e729930a01e21800856768440faab/Brute-Force_Protection.png)\n\nTo learn more about this feature, read [Brute-Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection).\n\n#### Breached password detection\n\nBreached password detection protects your applications from bad actors signing up or logging in with stolen credentials. Breached password detection includes the number of breached credentials detected in login and signup flows over the last seven days.\n\n![Screenshot shows line graph detailing number of breached credentials detected in the last 7 days. Separate lines are shown for login flows and signup flows.](https://images.ctfassets.net/cdy7uua7fh8z/6DxOEJdBbE6flhk6S0apkx/f0ba51ef05a1717db67aa055299f0d08/Breached_Password_Detection.png)\n\nTo learn more about this feature, read [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection).\n\n#### Multi-factor authentication\n\nMulti-factor authentication (MFA) verifies users by requiring more than one type of user validation. MFA includes the number of MFA challenges detected and the number of MFA challenges passed or failed over the last seven days.\n\n![Screenshot shows two line graphs. One shows the number of MFA challenges in the last 7 days. The other shows the MFA success rate over the last 7 days. Separate lines are shown for MFA passed and MFA failed.](https://images.ctfassets.net/cdy7uua7fh8z/2qqYETiIMP2o0XOciJSS1b/b7b4a61563620aad422a2048e8eb08d4/Multi-Factor_Auth.png)\n\nTo learn more about this feature, read [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication).\n\n## Learn more\n\n*   [Metrics](https://auth0.com/docs/secure/security-center/metrics)",
    "title": "Security Center",
    "description": "Learn about Security Center, which provides observability tools that empower you to see potential attack trends and quickly respond to them in real-time.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/data-privacy-and-compliance",
    "markdown": "# Auth0 Data Privacy and Compliance\n\nAuth0 maintains and meets the requirements for multiple compliance frameworks and certifications. To download or request Auth0 compliance documentation, [visit the Support Center](https://support.auth0.com/compliance). Auth0 will document additional compliance frameworks and certifications on this page when available.\n\n## Compliance & Certifications\n\n### FAPI\n\nAuth0 supports technical requirements for [FAPI](https://openid.net/wg/fapi/), a set of advanced security profiles specified by the OpenID Foundation. FAPI introduces stricter security standards for industries and scenarios that require more security on top of normal OAuth 2.0 and OpenID Connect (OIDC) implementations. \n\nAuth0 is a certified FAPI OpenID Provider for the following two profiles:\n\n*   FAPI 1 Advanced OP with mTLS, PAR\n    \n*   FAPI 1 Advanced OP with Private Key JWT, PAR\n    \n\nFor more information, see [FAPI OpenID Providers (OP) & Profiles](https://openid.net/certification/#FAPI-OP-P).\n\nTo understand how we incorporated FAPI capabilities into Auth0, see [Highly Regulated Identity](https://auth0.com/docs/secure/highly-regulated-identity).\n\nAuth0 is GDPR ready. Auth0 provides information to its customers to help them understand how features and functionality of the Auth0 platform may affect their GDPR compliance obligations.\n\n### HIPAA and HITECH\n\nAuth0 is considered as a **Business Associate** as defined by the US HIPAA and HITECH legislation. For Auth0 customers who qualify as a **Covered Entity** under US HIPAA legislation and related legislation and regulations and who provide ePHI (electronic Protected Health Information) to Auth0 as part of the Auth0 user profile, Auth0 may qualify as a business associate. Auth0 can provide its **Business Associate Agreement** to you upon request. To learn more about HIPAA, read [Health Information Privacy on hhs.gov](https://www.hhs.gov/hipaa/index.html). To learn more about HITECH, read [HITECH Act Enforcement Final Rules on hhs.gov](https://www.hhs.gov/hipaa/for-professionals/special-topics/HITECH-act-enforcement-interim-final-rule/index.html). HIPAA compliance is not available on Azure deployments.\n\n### CSA STAR\n\nAuth0 is CSA STAR certified. You can review the CSA Consensus Assessments Initiative Questionnaire (CAIQ) and can view our CAIQ and STAR Certificates in the [CSA STAR Registry](https://cloudsecurityalliance.org/star/registry/auth0/).\n\n### ISO 27001/27018\n\nAuth0 undergoes an ISO 27001/27018 audit by an independent auditor annually. To request access to our ISO 27001/27018 certificate, log in to [Auth0 Support Center](http://support.auth0.com/) and select the **Compliance** option. We can also share our Statement of Applicability (SOA) upon request with a non-disclosure agreement (NDA) signed by a corporate officer authorized to represent the company. To request the SOA, please contact your assigned Technical Account Manager or Account Executive.\n\n### PCI DSS\n\nAuth0 offers PCI compliant environment deployment models. Our Attestation of Compliance (AOC) and/or Self Assessment Questionnaire (SAQ-D) is available upon request. For a copy of these documents, log in to [Auth0 Support Center](http://support.auth0.com/) and select the **Compliance** option.\n\n### Payment Services Directive 2 (PSD2)\n\nWe provide the capabilities for customers to build an end-to-end user journey that includes Strong Customer Authentication(SCA) and Dynamic Linking, which dynamically shows transaction details for explicit end-user approval. For more information, read [Highly Regulated Identity](https://auth0.com/docs/secure/highly-regulated-identity).\n\n### SOC2\n\nAuth0 undergoes a SOC 2 Type 2 audit by an independent auditor annually. The audit covers all 5 Trust Services Criteria (Security, Availability, Processing Integrity, Confidentiality and Privacy). For a copy of the SOC 2 report, log in to [Auth0 Support Center](http://support.auth0.com/) and select the **Compliance** option.\n\n## Specifications\n\nFor information on compliance with technical specifications for authentication, please see our [Protocols](https://auth0.com/docs/authenticate/protocols) documentation.\n\n## Learn more\n\n*   [Auth0 General Data Protection Regulation Compliance](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr)\n*   [Auth0 Data Processing](https://auth0.com/docs/secure/data-privacy-and-compliance/data-processing)",
    "title": "Auth0 Data Privacy and Compliance",
    "description": "Learn about how Auth0 maintains and meets requirements for multiple compliance frameworks and certifications, including GDPR, CSA STAR, PCI DSS, and more.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/highly-regulated-identity",
    "markdown": "# Highly Regulated Identity\n\nHighly Regulated Identity (HRI) is Auth0’s Financial-Grade Identity™ solution to secure sensitive data operations and services important for your business. Initially targeting highly regulated industries like finance and healthcare, Highly Regulated Identity raises the security level to protect a wide range of customer use cases, including but not limited to money transfers, digital payments, and access to medical records. You can also use Highly Regulated Identity for other sensitive operations that require enhanced security, such as to approve changes in administrative credentials, secure privileged access to a web portal, and more.\n\nTo secure your sensitive business operations, Highly Regulated Identity provides:\n\n*   [Advanced security with OpenID Connect (FAPI)](#advanced-security-with-openid-connect-fapi-)\n    \n*   [Strong Customer Authentication (SCA)](#strong-customer-authentication-sca-) and [Dynamic Linking](#dynamic-linking)\n    \n*   [Confidentiality and integrity protection](#confidentiality-and-integrity-protection)\n    \n*   [Strong application authentication](#stronger-application-authentication)\n    \n*   [Protect access tokens with Token Binding](#protect-access-tokens-with-token-binding)\n    \n*   [Customizable approval flows for better user experience](#customizable-approval-flows-for-better-user-experience)\n    \n\n## Advanced security with OpenID Connect (FAPI)\n\n[OpenID FAPI](https://openid.net/wg/fapi/specifications/) is a suite of security and privacy specifications developed by the OpenID Foundation. APIs that meet the FAPI standards are classified as “financial-grade,” which means that they provide robust authentication and authorization mechanisms that help secure access to financial and other sensitive data and services.\n\nAuth0 is a certified FAPI provider. To learn more about the security improvements we introduced to meet FAPI standards, see the following sections:\n\n*   [Confidentiality and integrity protection](#confidentiality-and-integrity-protection)\n    \n*   [Strong application authentication](#stronger-application-authentication)\n    \n*   [Protect access tokens with Token Binding](#protect-access-tokens-with-token-binding)\n    \n\nFor more information on FAPI, see OpenID's [Open Banking, Open Data, and Financial-grade APIs](https://openid.net/wordpress-content/uploads/2022/03/OIDF-Whitepaper_Open-Banking-Open-Data-and-Financial-Grade-APIs_2022-03-16.pdf) whitepaper and the [FAPI Working Group specifications](https://openid.net/wg/fapi/specifications/).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/20iajPMtmICMORUfaVQH7a/ec900e1007b3faebd66eb2508f46acb0/image17.png)\n\n## Strong Customer Authentication (SCA)\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3JDIerJcevImoIDRd7OfIy/98597a9164b66cde9ec7ddc23f3e849b/image14.png)\n\nIntroduced by Europe’s [Payment Services Directive (PSD2)](https://www.europeanpaymentscouncil.eu/sites/default/files/infographic/2018-04/EPC_Infographic_PSD2_April%202018.pdf), Strong Customer Authentication (SCA), mandates the use of at least two distinct authentication factors out of the following three:\n\n*   Something the user knows (e.g., a password)\n    \n*   Something the user possesses (e.g., a device)\n    \n*   Something intrinsic to the user (e.g., a fingerprint)\n    \n\nThe authentication factors must be independent so that compromising one does not jeopardize the others. SCA is quickly becoming the worldwide standard for safeguarding sensitive data and services.\n\nTo help with SCA compliance, Auth0 offers various authentication factors that enroll and challenge users during a login transaction. Highly Regulated Identity leverages the following authentication factors to secure your transactions: \n\n*   Mobile push notifications\n    \n*   SMS\n    \n*   Email\n    \n*   WebAuthn\n    \n\nUsing [Actions](https://auth0.com/docs/customize/actions), you can dynamically determine which authentication factors to use. This gives you the flexibility to customize your code logic. For example, you can add a second authentication factor for payments above 10 USD. To learn more, read [Apply dynamic policy](https://auth0.com/docs/secure/highly-regulated-identity/transactional-authorization-with-contextual-sca#apply-dynamic-policy).\n\n## Dynamic Linking\n\nPSD2 requires that payment service providers implement Dynamic Linking along with Strong Customer Authentication. Dynamic Linking presents the user with transaction details for their explicit validation and approval and uniquely links the authorization and the transaction details. This ensures a good user experience and helps with regulatory compliance.\n\nTo enable Dynamic Linking, you can use Rich Authorization Requests (RAR) to pass fine-grained transaction authorization data to the OAuth authorization endpoint. The following code sample shows an `authorization_details` JSON object, which contains information like the payment type, amount, currency, and recipient:\n\n```\n\"authorization_details\": [\n {\n   \"type\": \"one_time_payment\",\n   \"amount\": {\n     \"amount\": 2460,46,\n     \"currency\": \"USD\"\n   },\n   \"sourceAccount\": \"xxxxxxxxxxx4567\",\n   \"recipient\": \"Acme Travel, Inc.\",\n   \"concept\": \"All Inclusive Resort Package for Two\",\n }\n]\n```\n\n`authorization_details` is assigned a unique transaction reference, which Auth0 uses to prompt the user to perform step-up authentication: \n\n*   Use push notifications to show transaction details and get approval on a separate device such as a mobile phone application.\n    \n*   Use SMS, email, or WebAuthn to confirm the details on the device that originated the transaction after the user completes the second authentication factor.\n    \n\nIf the user confirms the details, the transaction progresses and Auth0 issues an access token associated with the now-approved authorization\\_details. Developers can also add the unique transaction reference to the access token. As a result, your API servers can later validate the approved transaction details when receiving and servicing API requests.\n\nTo learn more about RAR, read [Authorization Code Flow with Rich Authorization Requests](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar).\n\n## Confidentiality and integrity protection\n\nAuthorization details may include account numbers, monetary amounts, merchant names, and other highly sensitive information that are passed in URLs or access tokens that are not secure. To protect sensitive data from unauthorized access and tampering, Highly Regulated Identity offers comprehensive confidentiality and integrity protection.\n\n### Protect sensitive data in the front channel\n\nTo protect sensitive data in the front channel, such as a web browser, Highly Regulated Identity offers the following solutions as part of the FAPI 1 Advanced Security profile.\n\n[PAR](https://datatracker.ietf.org/doc/rfc9126/) introduces a new endpoint, which allows clients to directly push the payload of an OAuth 2.0 authorization request to the authorization server (i.e. Auth0 in this case). This avoids passing the authorization parameters via the insecure front channel (i.e., the browser), thus reducing the risk of unauthorized access to authorization parameters by an intermediary.\n\nTo learn more about PAR, read [Authorization Code Flow with Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par) and [Configure Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/applications/configure-par).\n\n#### JWT-Secured Authorization Request (JAR)\n\n[JAR](https://datatracker.ietf.org/doc/rfc9101/) is an OAuth2 protocol extension that enhances the security of authorization requests. It does so by using a JSON Web Token (JWT) request parameter to protect the integrity and, optionally, the confidentiality of the authorization request parameters.\n\nTo learn more about JAR, read [Authorization Code Flow with JWT-Secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar) and [Configure JWT-Secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/applications/configure-jar).\n\n#### Protect sensitive data in access tokens\n\nTo protect the authorization details included in access tokens, Highly Regulated Identity provides support for using [JSON Web Encryption (JWE)](https://datatracker.ietf.org/doc/html/rfc7516) to encrypt the payload of access tokens. This protects access tokens from application-side data breaches and unauthorized inspection into API calls by intermediaries.\n\nTo learn more about JWE, read [JSON Web Encryption](https://auth0.com/docs/secure/tokens/access-tokens/json-web-encryption) and [Configure JSON Web Encryption](https://auth0.com/docs/get-started/apis/configure-json-web-encryption).\n\n## Stronger application authentication\n\nTo improve your application authentication security, Highly Regulated Identity offers two different alternatives as part of the FAPI 1 Advanced Security profile:\n\n*   [Private Key JWT](http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer): involves generating a public-private key pair to use as credentials to authenticate an application. It is already available for customers on the Enterprise plan. To learn more, read [Private Key JWT Authentication](https://auth0.com/docs/secure/application-credentials#private-key-jwt-authentication).\n    \n*   [mTLS for OAuth](https://datatracker.ietf.org/doc/html/rfc8705): involves registering a standard X.509 certificate linked to an application on your tenant. The certificate can either be CA-issued or self-signed. Following standard mTLS procedures, the private key corresponding to the certificate is used on the client side to establish the mTLS tunnel when sending requests to your Auth0 tenant endpoints. As a result, Auth0 can authenticate the application without transmitting secrets over the network. To learn more, read [mTLS for OAuth](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls).\n    \n\nWith both Private Key JWT and OAuth 2.0 mTLS, you can rotate credentials with zero downtime by temporarily keeping two active keys and/or certificates at the same time for a given application.\n\n## Protect access tokens with Token Binding\n\nSupporting mTLS also adds the ability to use Token Binding or Sender Constraining. Token Binding associates the thumbprint of the client certificate used for establishing the mTLS tunnel to an access token. When the client consumes an API using the certificate-bound access token, the API server is then able to verify whether the client is also using the associated client certificate. As a result, even if the access token is compromised, malicious actors who don’t know the client certificate still cannot access protected resources.\n\n**Note:** Token Binding operates independently of the application's authentication method and does not require the pre-registration of the client certificate. To learn more, read [Token Binding](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#enable-token-binding) and [Call the resource server](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls#call-the-resource-server).\n\n## Customizable approval flows for better user experience\n\nWhen designing real-world solutions for financial-grade security, it’s important to consider user experience. Applying one-size-fits-all authentication flows for all transactions is not as effective as dynamically adjusting based on transaction details and use cases. \n\nYou can customize your authentication flow using [Actions](https://auth0.com/docs/customize/actions). For example, after the user logs in, you can inspect transaction details received via RAR, list the user’s enrolled and already validated authentication factors, and use external services, such as risk evaluation engines, to determine the next authentication factor to use. To learn more, read [Apply dynamic policy](https://auth0.com/docs/secure/highly-regulated-identity/transactional-authorization-with-contextual-sca#apply-dynamic-policy). \n\nThe New Universal Login templates also enable you to customize the attributes displayed on the transaction approval screen depending on the type of transaction and other authorization details. To learn more, read [Configure Rich Authorization Requests (RAR)](https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7eBJA1IPsCIZubFKEtHh3m/8ec245ebd3bab775e9ba12fbe7f4096c/image2.png)\n\n## Learn more\n\nTo learn how Highly Regulated Identity works from end-to-end to authorize a one-time transaction, read [Transactional Authorization with Contextual Strong Customer Authentication](https://auth0.com/docs/secure/highly-regulated-identity/transactional-authorization-with-contextual-sca).",
    "title": "Highly Regulated Identity",
    "description": "Learn about Highly Regulated Identity, Auth0's Financial-Grade Identity solution. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/security-guidance",
    "markdown": "# Security Guidance\n\nWas this article helpful?",
    "title": "Security Guidance",
    "description": "Guidance related to security, including general tips, security bulletins, and information about data and token storage, Allow Lists, Deny Lists, and how to prevent common cyberattacks.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor/deployment-options",
    "markdown": "# Deployment Options\n\nAuth0 provides both public cloud and private cloud deployment options and tools to help you with your deployment.\n\nThe Auth0 identity platform can be deployed in the following ways:\n\n| **Option** | **Description** |\n| --- | --- |\n| **Public Cloud** | A multi-tenant cloud service running on Auth0's cloud with standard authentication, personalization, user management, and security features |\n| [**Private Cloud on AWS**](https://auth0.com/docs/deploy/private-cloud) | A dedicated, managed cloud service running on AWS providing isolation, higher performance, dev instances, Geo-HA add-ons and more |\n| [**Private Cloud on Azure**](https://auth0.com/docs/deploy/private-cloud-on-azure) | A dedicated cloud service running on Azure providing isolation, higher performance, dev instances, add-ons and more |\n\nThe **Private Cloud** packages are managed services that you can use if you:\n\n*   Cannot use a multi-tenant public cloud service in your organization\n    \n\n*   Require a guaranteed level of requests per second (RPS)\n    \n\nIf you have specific support requirements or need more information about the Professional Services we offer, please [contact Auth0 Sales](https://auth0.com/contact-us).",
    "title": "Deployment Options",
    "description": "Describes Auth0 public and private cloud deployment options.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor/pre-deployment-checks",
    "markdown": "# Pre-Deployment Checks\n\nBefore you go live, run Auth0's production checks suite to ensure that your tenants are ready for use in a production environment.\n\n| **Read** | **To learn...** |\n| --- | --- |\n| [Production Checks](https://auth0.com/docs/deploy/pre-deployment/how-to-run-production-checks) | How to run the production checks against one or more applications to see if they're production-ready or not. View your results to see any outstanding required and recommended tasks, as well as changes you can make to ensure that you comply with best practices. |\n| [Pre-Deployment Tests](https://auth0.com/docs/deploy/pre-deployment/predeployment-tests) | How to run unit and integration tests before deploying Auth0. |\n| [Pre-Launch Tips](https://auth0.com/docs/deploy/pre-deployment/pre-launch-tips) | About tips we have collected from our customers when first getting started with Auth0. |",
    "title": "Pre-Deployment Checks",
    "description": "A reference of helpful pre-deployment checks for your production Auth0 environment.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor/deploy-private-cloud",
    "markdown": "# Deploy Private Cloud\n\n**Private Cloud** packages are managed services that you can use if you:\n\n*   Cannot use a multi-tenant public cloud service in your organization\n    \n\n*   Require a guaranteed level of requests per second (RPS)\n    \n\nThe Auth0 private cloud can be deployed in the following ways:\n\n| **Option** | **Description** |\n| --- | --- |\n| [**Private Cloud on AWS**](https://auth0.com/docs/deploy/private-cloud) | A dedicated, managed cloud service running on AWS providing isolation, higher performance, dev instances, Geo-HA add-ons and more |\n| [**Private Cloud on Azure**](https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-on-azure) | A dedicated cloud service running on Azure providing isolation, higher performance, dev instances, add-ons and more |\n\nWe also provide [add-on features](https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-add-on-features) that can complement your Auth0 Private Cloud deployment.\n\nIf you have specific support requirements or need more information about the Professional Services we offer, please [contact Auth0 Sales](https://auth0.com/contact-us).",
    "title": "Deploy Private Cloud",
    "description": "Describes Auth0 private cloud deployment options.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool",
    "markdown": "# Deploy CLI Tool\n\nThe Auth0 Deploy CLI is a tool that helps you manage your Auth0 tenant configuration. It integrates into your development workflows as a standalone CLI or as a node module.\n\nSupported resource types: `actions`, `branding`, `client grants`, `clients (applications)`, `connections`, `custom domains`, `email templates`, `emails`, `grants`, `guardian`, `hook secrets`, `log streams`, `migrations`, `organizations`, `pages`, `prompts`, `resource servers (APIs)`, `roles`, `tenant settings`, `themes`.\n\n## Highlights\n\n*   **Multi-Environment Oriented:** Designed to help you test your applications' Auth0 integrations from feature branch all the way to production.\n    \n*   **Keyword Replacement:** Shared resource configurations across all environments with dynamic keyword replacement.\n    \n*   **Versatile:** Integrate into your CI/CD workflows either as a CLI or as a Node module.\n    \n\n## Get started\n\nThis guide will help you to a working implementation of the Deploy CLI tool used as a standalone CLI. There are three main steps before the Deploy CLI can be run:\n\n1.  [Create a dedicated Auth0 Application](#create-a-dedicated-auth0-application)\n    \n2.  [Configure the Deploy CLI](#configure-the-deploy-cli)\n    \n3.  [Call the Deploy CLI](#call-the-deploy-cli)\n    \n\n### Install the Deploy CLI\n\nTo run as a standalone command-line tool:\n\n`npm install -g auth0-deploy-cli`\n\n### Create a dedicated Auth0 application\n\nIn order for the Deploy CLI to call the Management API, a dedicated Auth0 application must be created to make calls on behalf of the tool:\n\n1.  Go to **Auth0 Dashboard > Applications > Applications**.\n    \n2.  Select **\\+ Create Application**.\n    \n    1.  Give it a descriptive name (such as “Deploy CLI”).\n        \n    2.  Select **Machine to Machine Applications** for the **Application Type**.\n        \n    3.  Select **Create**.\n        \n3.  Switch to the **Authorize Machine to Machine Application** view:\n    \n    1.  Select **Auth0 Management API**.\n        \n    2.  Select the appropriate permissions for the resources you wish to manage. Refer to the [Client Scopes](#client-scopes) section for more information.\n        \n    3.  Select **Authorize**.\n        \n\n#### Client scopes\n\nThe designated application needs to be granted scopes in order to allow the Deploy CLI to execute Management operations.\n\nThe principle of least privilege is abided, so it will operate within the set of permissions granted. , you'll need to select `read:clients`, but it’s recommended to select `read:*`, `create:*`, and `update:*` permissions for all resource types within management purview. To enable deletions, you `delete:*` scopes.\n\n### Configure the Deploy CLI\n\nYou can configure the Deploy CLI in two ways:\n\n1.  Use the configuration file (`config.json`).\n    \n2.  Set environment variables.\n    \n\nThe decision to choose one or both would depend on your specific use case and preferences. To learn more, read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\nFor this example, set the following environment variables:\n\n*   `AUTH0_DOMAIN`\n    \n*   `AUTH0_CLIENT_ID`\n    \n*   `AUTH0_CLIENT_SECRET`\n    \n\nThese values can be found in the **Settings** tab for the dedicated Auth0 application you created previously.\n\n### Call the Deploy CLI\n\nThe Deploy CLI `export` command can be run with the following command:\n\n`a0deploy export --format=yaml --output_folder=local`\n\nOnce the process completes, observe the resource configuration files generated in the local directory. Then, run the `import` command to push the configuration from your local machine to your Auth0 tenant:\n\n`a0deploy import --config_file=config.json --input_file local/tenant.yaml`\n\nFor a comprehensive list of flags and options, please read [Use as CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/use-as-a-cli).",
    "title": "Deploy CLI Tool",
    "description": "Learn about the Auth0 Deploy CLI Tool and how it works.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor/deploy-checklist",
    "markdown": "# Deployment Checklist\n\nAuth0 has provided the following deployment checklist for your use. You may not find that every item is applicable, so please modify the checklist based on the needs of your implementation.\n\n## How to use the checklist\n\n1.  Click the link below to download the checklist.\n    \n2.  Open the checklist in any spreadsheet application.\n    \n3.  Customize the checklist to suit your needs.\n    \n\n![Excel Icon](https://images.ctfassets.net/cdy7uua7fh8z/2Cip8jFt1IhR24t5Q4V4KZ/749eb4107b1b8ad60dbabf4066fea151/file_type_icons-02.png)[Deploy Checklist](https://assets.ctfassets.net/cdy7uua7fh8z/78b5P011cQmYyZ7XZkQcoK/3c42c9146f9823b427bcd06b2889fa7c/Deploy-Checklist.xlsx)\n\nIn the Deploy phase, you will deploy the system to either a staging or production environment, where actual users begin to operate and interact with it.\n\nEventually, you deploy all components of the system to the production environment when you make a live release.\n\n## Learn more\n\n*   [Pre-Deployment Checks](https://auth0.com/docs/deploy-monitor/pre-deployment-checks)\n*   [Run Pre-Deployment Tests](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/predeployment-tests)\n*   [Pre-Launch Tips](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/pre-launch-tips)",
    "title": "Deployment Checklist",
    "description": "Deployment checklists for your implementation",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor/auth0-terraform-provider",
    "markdown": "# Auth0 Terraform Provider\n\nThe Deploy CLI is not the only tool available for managing your Auth0 tenant configuration, there is also an [officially supported Terraform Provider](https://github.com/auth0/terraform-provider-auth0). [Terraform](https://terraform.io/) is a third-party tool for representing your cloud resources’ configurations as code. It has an established plug-in framework that supports a wide array of cloud providers, including Auth0.\n\nBoth the Deploy CLI and Terraform Provider exist to help you manage your Auth0 tenant configurations, but each has their own set of pros and cons.\n\nYou may want to consider the Auth0 Terraform Provider if:\n\n*   Your development workflows already leverages Terraform\n    \n*   Your tenant management needs are granular or only pertain to a few specific resources\n    \n\nYou may not want to consider the Auth0 Terraform Provider if:\n\n*   Your development workflow does not use Terraform, requiring extra setup upfront\n    \n*   Your development workflows are primarily concerned with managing your tenants in bulk\n    \n*   Your tenant has lots of existing resources, may require significant effort to “import\"",
    "title": "Auth0 Terraform Provider",
    "description": "Learn about the Auth0 Terraform Provider for representing your tenant configurations as code.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor/deployment-best-practices",
    "markdown": "# Deployment Best Practices\n\n## Use automated deployment for rules\n\nCoding a rule within the Auth0 Dashboard rule editor is a great way to implement and test while still in the development stage. However, when it comes time to deploy into automated test or production environments, a more automated mechanism is required; copying and pasting code between Auth0 tenants is not a satisfactory method to employ.\n\n### Set up version control extensions\n\nChanges made to a rule deployed to an Auth0 tenant will be made live immediately because changes instantly overwrite what is already there. We recommended that you use version control such as Git via GitHub or the like, is employed to provide change management capability.\n\nAuth0 provides automated deployment methods for rules between Auth0 tenant environments. The following Auth0 integrations allow you to update rules from the version control system—both manually and automatically (for example, when a change in the version control system is detected): [GitHub Actions](https://marketplace.auth0.com/integrations/github-actions), [GitLab Pipelines](https://marketplace.auth0.com/integrations/gitlab-pipeline), [Bitbucket Pipelines](https://marketplace.auth0.com/integrations/bitbucket-pipeline), and [Microsoft Azure Pipelines](https://marketplace.auth0.com/integrations/azure-pipeline).\n\n### Use Deploy CLI tool for rule import and export\n\nThe Auth0 Deploy CLI tool can be used to automate deployment between Auth0 tenants. Deploy CLI works with files stored in the file system together with the Auth0 Management API and provides the capability to allow the export of rule assets from an Auth0 tenant, as well as import of them into an Auth0 tenant. Further, the tool provides for programmatic control over rule ordering and rule environment configuration as part of deployment automation. To learn more, read [Deploy CLI Tool](https://auth0.com/docs/deploy-monitor/deploy-cli-tool).\n\nAs a best practice, you should use the Auth Deploy CLI tool in almost all cases involving deployment to test or production environments, such as with the following integrations: [GitLab Pipelines](https://marketplace.auth0.com/integrations/gitlab-pipeline), [GitHub Actions](https://marketplace.auth0.com/integrations/github-actions), [Bitbucket Pipelines](https://marketplace.auth0.com/integrations/bitbucket-pipeline), and [Microsoft Azure Pipelines](https://marketplace.auth0.com/integrations/azure-pipeline). While the integrations can provide automated detection of changes deployed to the respective version control system, the Deploy CLI tool allows precise control of what’s deployed when, where, and how. To learn more about best practices, read [Rules Best Practices](https://auth0.com/docs/rules-best-practices).\n\n## Set up test tenants\n\nWe recommend that you set up a separate test tenant in Auth0 to provide safe testing of any rules before deploying to production. To learn more, read [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n\n## Learn more\n\n*   [Rules Best Practices](https://auth0.com/docs/rules-best-practices)",
    "title": "Deployment Best Practices",
    "description": "Learn about best practices for deployment.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor/monitor",
    "markdown": "# Monitor Auth0\n\nYou can monitor your Auth0 implementation and Auth0 status and services, as well as your tenant log event data.\n\nFollow [@auth0status](https://twitter.com/auth0status) on X to get the latest status updates and monitor your Auth0 implementation to check the status and availability of external services and applications. \n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Check Auth0 Status](https://auth0.com/docs/monitor-auth0/check-auth0-status) | How to check Auth0 service availability for locale and region and subscribe for service updates. |\n| [Check External Services Status](https://auth0.com/docs/monitor-auth0/check-external-services-status) | How to monitor external identity provider services. |\n| [Monitor Applications](https://auth0.com/docs/monitor-auth0/monitor-applications) | How to monitor your application health to report potential impact to your users. |\n| [Monitor Auth0 Using System Center Operations Manager](https://auth0.com/docs/monitor-auth0/monitor-using-scom) | How to monitor Auth0 using System Center Operations Manager (SCOM) or any tool that supports synthetic transactions. |\n| [Logs](https://auth0.com/docs/monitor-auth0/logs) | About Auth0 tenant event logs that you can analyze for your business needs. |\n| [Log Streams](https://auth0.com/docs/monitor-auth0/streams) | How to create tenant log event streams to external services such as AWS EventBridge, Azure Event Grid, Datadog and more. |",
    "title": "Monitor Auth0",
    "description": "Describes how to monitor and track your Auth0 usage, as well as how to send tenant logs to external tools.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/deploy-monitor/logs",
    "markdown": "# Logs\n\nAuth0 provides event logs that you can analyze for your business needs. You can:\n\n*   View actions performed by tenant administrators.\n    \n*   View operations performed via the Management API.\n    \n*   View authentications made by your users.\n    \n*   View intermittent errors that may be hard to find with quality assurance testing.\n    \n*   Capture forensic data for security purposes and to identify anomaly detection triggers.\n    \n*   Identify patterns in usage trends.\n    \n*   Check for authentication errors and Management API call errors.\n    \n*   Set up automatic log scanning to check for rate limit errors so that you can proactively address activity that hits rate limits before it impacts your users.\n    \n*   Correlate management API events to their initiating requests by matching `X-Correlation-ID` header values.\n    \n\n## View and retrieve logs\n\nView log events in the Auth0 Dashboard and retrieve logs using the Management API. To learn more, read:\n\n*   [View Log Events](https://auth0.com/docs/deploy-monitor/logs/view-log-events)\n    \n*   [Retrieve Log Events Using the Management API](https://auth0.com/docs/deploy-monitor/logs/retrieve-log-events-using-mgmt-api)\n    \n\nAuth0 provides a wide variety of log event types and well as filtering to allow you to find the specific events to suit your tracking and analysis needs. To learn more, read:\n\n*   [Personally Identifiable Information in Auth0 Logs](https://auth0.com/docs/deploy-monitor/logs/pii-in-logs)\n    \n*   [Log Data Retention](https://auth0.com/docs/deploy-monitor/logs/log-data-retention)\n    \n*   [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes)\n    \n*   [Adaptive MFA Log Events](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events)\n    \n*   [Attack Protection Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)\n    \n*   [Log Search Query Syntax](https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax)\n    \n*   [Log Event Filters](https://auth0.com/docs/deploy-monitor/logs/log-event-filters)\n    \n\n## Log streaming and exporting\n\nUse log streaming to export logs to your preferred processing and analysis tools. We provide integrations with several analysis services as well as a way to create a custom log stream using webhooks. To learn more, read [Log Streaming](https://auth0.com/docs/customize/log-streams).",
    "title": " Logs",
    "description": "Understand how tenant and operations event logs work in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications",
    "markdown": "# Log Users Out of Applications\n\nEnterprise users typically have Single Sign-on (SSO) enabled for multiple applications (e.g., SharePoint, a few .NET applications, a few Java applications, Zendesk). In this case, when users sign out, often they must be signed out for all of their applications.\n\nThe Auth0 [RP-initiated logout endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0) works in one of two ways:\n\n*   Invalidates the Single Sign-on (SSO) cookie in Auth0. (The cookie still remains in the browser.)\n    \n*   Signs the user out from the identity provider (IdP) (such as ADFS or Google).\n    \n\nRedirecting users to the logout endpoint does not cover the scenario where users need to be signed out of all of the applications they used. If you need to provide this functionality you will have to handle this in one of two ways:\n\n*   Have short timeouts on your local session and redirect to Auth0 at short intervals to re-authenticate. This can be done by calling `checkSession` from the client which does this redirect in a hidden iFrame. If you take the hidden iFrame approach you need to be aware of [rate limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) and third-party [cookie](https://auth0.com/docs/manage-users/cookies) issues.\n    \n*   Handle this entirely at the application level by providing your applications a way to notify all other applications when a logout occurs.\n    \n\nIf you are using the alternative logout endpoint, review the [API documentation](https://auth0.com/docs/api/authentication#logout).\n\n## Learn more\n\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)",
    "title": "Log Users Out of Applications",
    "description": "Describes how to force a user to log out of applications using the Auth0 logout endpoint.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0",
    "markdown": "# Log Users Out of Auth0 with OIDC Endpoint\n\nAuth0 implements OpenID Connect’s [RP-Initiated Logout 1.0](https://openid.net/specs/openid-connect-rpinitiated-1_0.html) for end-user logout. This standard is part of the OpenID Connect collection of [final specifications](https://openid.net/developers/specs/).\n\n## How it works\n\nRP-Initiated Logout is a scenario in which a relying party (user) requests the OpenID provider (Auth0) to log them out.\n\n1.  The user initiates a logout request in your application.\n    \n2.  Your application directs the user to the Auth0 Authentication API [OIDC Logout](https://auth0.com/docs/api/authentication#oidc-logout) endpoint.\n    \n3.  Auth0 redirects the user to the appropriate destination based on the provided [OIDC Logout endpoint parameters](#oidc-logout-endpoint-parameters).\n    \n\n## Configure RP-Initiated Logout\n\nTo configure RP-Initiated Logout, you must ensure that your application can find the `end_session_endpoint` parameter in your Auth0 tenant’s [discovery metadata document](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig), and that it calls the OIDC Logout endpoint with the necessary parameters.\n\n### Enable endpoint discovery\n\nYou can enable **RP-Initiated Logout End Session Endpoint Discovery** in the Auth0 Dashboard or with the Auth0 Management API.\n\nTo enable **RP-Initiated Logout End Session Endpoint Discovery** in the Dashboard:\n\n1.  Go to [Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Locate the **Login and Logout** section.\n    \n3.  Enable the **RP-Initiated Logout End Session Endpoint Discovery** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/7LbKkydtLUOXtzzNxNqI8p/624e66f985d55c2c7a56e90f68a2011a/RP-Initiated_Logout_End_Session_Endpoint_Discovery.png)\n\n### Call the OIDC Logout endpoint\n\nWhen you call the OIDC Logout endpoint, Auth0 recommends that you provide the `id_token_hint` parameter.\n\nIf your application cannot securely store ID tokens, you may provide the `logout_hint` and `client_id` parameters instead.\n\n#### OIDC Logout endpoint parameters\n\nThe Authentication API [OIDC Logout](https://auth0.com/docs/api/authentication#oidc-logout) endpoint supports the following parameters:\n\n| **Parameter** | **Required?** | **Description** |\n| --- | --- | --- |\n| `id_token_hint` | Recommended | ID token previously issued for the user. That indicates which user to log out. |\n| `logout_hint` | Optional | Session ID (`sid`) value that indicates which user to log out. |\n| `post_logout_redirect_uri` | Optional | Redirect URL value that indicates where to redirect the user after logout. |\n| `client_id` | Optional | Client ID of your application. |\n| `federated` | Optional | Directs Auth0 to log the user out of their identity provider. |\n| `state` | Optional | Opaque value that the application adds to the initial logout request, and that Auth0 includes when redirecting the back to the `post_logout_redirect_uri`. |\n| `ui_locales` | Optional | Space-delimited list of locales used to constrain the language list for the request. The first locale on the list must match the enabled locale in your tenant. |\n\n#### id\\_token\\_hint parameter\n\nThe value of the `id_token_hint` parameter must be the ID token that Auth0 issued to the user after they authenticated.\n\nThe ID token contains the registered claims issuer (`iss`), audience (`aud`), and the Auth0 session ID (`sid`) for verification. To learn more about ID token claims, read [ID Token Structure](https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure).\n\n##### Examples\n\n```\nhttps://{yourDomain}/oidc/logout?id_token_hint={yourIdToken}&post_logout_redirect_uri={yourCallbackUrl}\n```\n\n#### logout\\_hint parameter\n\nThe value of the `logout_hint` parameter must be the session ID (`sid`) of the user’s current Auth0 session.\n\nThe session ID (`sid`) is provided as a registered claim within the ID token that Auth0 issued to the user after they authenticated.\n\n##### Example\n\nto configure this snippet with your account\n\n```\nhttps://{yourDomain}/oidc/logout?{clientId}={yourClientId}&logout_hint={sessionId}\n```\n\n#### post\\_logout\\_redirect\\_uri parameter\n\nThe value of the `post_logout_redirect_uri` parameter must be a valid, encoded URL that has been registered in the list of **Allowed Logout URLs** in your:\n\n1.  [Application settings](https://auth0.com/docs/get-started/applications/application-settings#application-uris): If you provide the `id_token_hint` parameter, or the `logout_hint` and `client_id` parameters.\n    \n2.  [Tenant settings](https://auth0.com/docs/get-started/tenant-settings#login-and-logout): If you provide only the `logout_hint` parameter.\n    \n\n##### Example\n\n```\nhttps://{yourDomain}/oidc/logout?post_logout_redirect_uri=http%3A%2F%2Fwww.example.com\n```\n\n##### Update application Allowed Logout URLs\n\nYou can register a URL with your application’s list of **Allowed Logout URLs** in the Auth0 Dashboard or with the Auth0 Management API.\n\nTo register a URL with your application’s list of **Allowed Logout URLs** in the Dashboard:\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select your application.\n    \n3.  Locate the **Application URIs** section.\n    \n4.  Update **Allowed Logout URLs** following the [provided guidelines](#allowed-logout-urls-guidelines).\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/56qLkA7NxiRyg3sJGVVGfZ/d4f3e191d2673c06271f921781e4441a/Application_URIs.png)\n\n##### Update tenant Allowed Logout URLs\n\nYou can register a URL with your tenant’s list of **Allowed Logout URLs** in the Auth0 Dashboard or with the Auth0 Management API.\n\nTo register a URL with your tenant’s list of **Allowed Logout URLs** in the Dashboard:\n\n1.  Go to [Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Locate the **Login and Logout** section.\n    \n3.  Update **Allowed Logout URLs** following the [provided guidelines](#allowed-logout-urls-guidelines).\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/2IRcKtTbTkE6q3GmbLxMyi/ad3905136ddfdcd4bfec5ed95a09d65a/OIDC_Logout_-_Show_RP-Initiated_Logout_End-User_Consent.png)\n\n##### Allowed Logout URLs guidelines\n\nWhen you update **Allowed Logout URLs**, follow the guidelines below to avoid validation errors:\n\n*   Separate multiple URL values with a comma (`,`).\n    \n*   Include the URL scheme part (for example, `https://`).\n    \n\nYou may use an asterisk (`*`) as a wildcard for subdomains (such as `https://*.example.com`), but we recommend that you do not use wildcards in production environments. For more information, read [Subdomain URL Placeholders](https://auth0.com/docs/get-started/applications/wildcards-for-subdomains#wildcard-url-placeholders).\n\n##### Add query string parameters to post\\_logout\\_redirect\\_uri\n\nThe OIDC Logout endpoint parses query string parameters in the URL provided to the `post_logout_redirect_uri` parameter.\n\nYou must include these query string parameters in your **Allowed Logout URLs**, or the logout request may be denied.\n\nFor example, if you pass `https://example.com/logout?myParam=1234` to the `post_logout_redirect_uri` parameter (encoded as `https%3A%2F%2Fexample.com%2Flogout%3FmyParam%3D1234`), you must include `https://example.com/logout?myParam` in your **Allowed Logout URLs**. \n\n#### ui\\_locales parameter\n\nThe value of the `ui_locales` parameter must be a space-delimited list of [supported locales](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization#new-universal-login-experience-localization). \n\nThe first value provided in the list must match your [tenant’s Default Language setting](https://auth0.com/docs/get-started/tenant-settings#languages).\n\n#### federated parameter\n\nThe `federated` parameter does not require a value.\n\nIf you include the federated parameter when you call the OIDC Logout endpoint, Auth0 attempts to [log the user out of their identity provider](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps).\n\n## Logout consent prompt\n\nThe OIDC standard defines that the logout flow should be interrupted to prompt the user for consent if the OpenID provider cannot verify that the request was made by the user.\n\nAuth0 enforces this behavior by displaying a logout consent prompt if it detects any of the following conditions:\n\n*   Neither the `id_token_hint` nor `logout_hint` parameters are provided.\n    \n*   The ID token's `sid` claim does not correspond to the browser session in the request.\n    \n*   The value of the `logout_hint` parameter does not match current session data.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5Sycg1aMJ1CLZwJj19Omv4/2c19a5923369354cdc0617fdd521707a/Logout_Prompt.png)\n\nIf the user confirms the logout request, Auth0 continues the logout flow.\n\n### Disable the logout consent prompt\n\nYou may disable the logout consent prompt. If you do, Auth0 does not attempt to detect anomalous behavior and accepts logout requests automatically.\n\nTo disable the logout consent prompt in the Dashboard:\n\n1.  Go to [Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Disable the **Show RP-Initiated Logout End-User Confirmation** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/37K4hLjhSBMGvdGP9OEP7W/05c2a3cbc438a86b5f24fd9942782272/Tenant_-_Advanced_-_Login_and_Logout_-_Logout_Consent_Prompt_disabled.png)\n\n## Learn more\n\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)",
    "title": "Log Users Out of Auth0 with OIDC Endpoint",
    "description": "Learn how to log user out with the OIDC Logout Endpoint.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps",
    "markdown": "# Log Users Out of SAML Identity Providers\n\nSingle Logout (SLO) is a feature that allows a user to terminate multiple authentication sessions by performing a single logout action.\n\nAuth0 supports SLO when you [connect your application to a SAML Identity Provider (IdP)](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/saml) and supports limited SLO when you [configure Auth0 as a SAML IdP](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider).\n\n## Configure SLO when application is connected to a SAML IdP\n\nIf you’d like Auth0 to [log a user out of their identity provider](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps), include the `federated` parameter when you call the [Auth0 Authentication API Logout endpoint](https://auth0.com/docs/api/authentication#logout).\n\nYou may need to configure additional settings for the SAML connection to ensure that Auth0 sends the logout request to the SAML IdP's logout endpoint:\n\n1.  Go to [Auth0 Dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp) and select your connection.\n    \n2.  Toggle on **Enable Sign Out**.\n    \n3.  Enter the SAML Logout URL provided by the SAML IdP in the **Sign Out URL** field. If you leave this field blank, Auth0 will default to the URL in the **Sign In URL** field.\n    \n4.  Confirm that the value in the **Protocol Binding** field matches the protocol binding expected by the SAML IdP.\n    \n\n## Configure SLO when Auth0 is the SAML IdP\n\nWhen Auth0 is the SAML IdP, there are two logout scenarios to consider:\n\n*   Application-initiated\n    \n*   IdP-initiated\n    \n\nFor both scenarios, you must [configure the SAML2 Web App addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon) to know where to send logout responses:\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select your application.\n    \n2.  Navigate to the **Addons** tab and select **SAML2 Web App**.\n    \n3.  Go to the **Settings** tab.\n    \n4.  Locate the **Settings** box and add (or update) the `logout` object with the following properties:\n    \n    *   `callback`: Enter the SLO URL of the application.\n        \n    *   `slo_enabled`: Enter `true` if you would like to enable IdP-initiated SLO in which Auth0 sends a SAML logout request to the application when the user logs out of the Auth0 SAML IdP. Otherwise, enter `false`.\n        \n        ```\n        {\n          \"logout\": {\n            \"callback\": \"https://myapp.exampleco.com/saml/logout\",\n            \"slo_enabled\": true\n          }\n        }\n        ```\n        \n\nBy default, Auth0 sends SAML logout responses with the `HTTP-POST` protocol binding. If your application expects the `HTTP-Redirect` protocol binding, add (or update) the `binding` property like so:\n\n```\n{\n  \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"\n}\n```\n\n### Application-initiated logout\n\nWhen the user initiates logout from an application, it must send a request to the Authentication API [SAML Logout endpoint](https://auth0.com/docs/api/authentication#saml-logout) to trigger SLO.\n\nIf your application does not support SLO but does support a redirect URL to send the user to after logout, set the redirect URL to the Authentication API [OIDC Logout endpoint](https://auth0.com/docs/api/authentication#oidc-logout) (or the Authentication API [Auth0 Logout endpoint](https://auth0.com/docs/api/authentication#auth0-logout) if you're using legacy logout). Auth0 won't notify other session participants that a logout was initiated, but we will remove the user’s [Auth0 session](https://auth0.com/docs/manage-users/sessions/session-layers).\n\n### IdP-initiated logout\n\nWhen a user initiates logout from an Auth0 SAML IdP, Auth0 sends a SAML logout response to the URL in the `logout.callback` property within the SAML2 Web App addon’s Settings. You can only specify a single URL for this property.\n\nDue to this constraint, Auth0 does not natively support the scenario where a user needs to be signed out of multiple applications connected to your Auth0 SAML IdP.\n\nYou can achieve functionality similar to SLO by configuring your applications to regularly check the status of the user’s Auth0 session and terminate the application session accordingly. To learn more, read about [Session Lifetime Limits](https://auth0.com/docs/manage-users/sessions/session-lifetime-limits).\n\n## Learn more\n\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors)",
    "title": "Log Users Out of SAML Identity Providers",
    "description": "Describes how to log users out of an external SAML identity provider.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/attack-protection/state-parameters",
    "markdown": "# Prevent Attacks and Redirect Users with OAuth 2.0 State Parameters\n\nAuthorization protocols provide a `state` parameter that allows you to restore the previous state of your application. The `state` parameter preserves some state objects set by the client in the Authorization request and makes it available to the client in the response.\n\n## CSRF attacks\n\nThe primary reason for using the `state` parameter is to mitigate [CSRF attacks](https://en.wikipedia.org/wiki/Cross-site_request_forgery) by using a unique and non-guessable value associated with each authentication request about to be initiated. That value allows you to prevent the attack by confirming that the value coming from the response matches the one you sent.\n\nThe `state` parameter is a string so you can encode any other information in it. You send a random value when starting an authentication request and validate the received value when processing the response. You store something on the client application side (in cookies, session, or localstorage) that allows you to perform the validation. If you receive a response with a state that doesn't match, you can infer that you may be the target of an attack because this is either a response for an unsolicited request or someone trying to forge the response.\n\nA CSRF attack specifically targets state-changing requests to initiate an action instead of getting user data because the attacker has no way to see the response to the forged request. For the most basic cases the state parameter should be a nonce, used to correlate the request with the response received from the authentication.\n\nMost modern OIDC and OAuth SDKs, including Auth0.js in single-page applications, handle the state generation and validation automatically.\n\n### Set and compare state parameter values\n\n1.  Before redirecting a request to the Identity Provider (IdP), have the app generate a random string. For example:\n    \n    The allowed length for state is not unlimited. If you get the error `414 Request-URI Too Large`, try a smaller value.\n2.  Store the string locally. For example:\n    \n    ```\n    storeStateLocally(xyzABC123)\n    ```\n    \n3.  Add the `state` parameter to the request (URL-encoding if necessary). For example:\n    \n    ```\n    // Encode the String   \n    tenant.auth0.com/authorize?...&state=xyzABC123\n    ```\n    \n    After the request is sent, the user is redirected back to the application by Auth0. The `state` value will be included in this redirect. Note that depending on the type of connection used, this value might be in the body of the request or in the query string.\n    \n    ```\n    /callback?...&state=xyzABC123\n    ```\n    \n4.  Retrieve the returned `state` value and compare it with the one you stored earlier. If the values match, then approve the authentication response, else deny it.\n    \n    ```\n    // Decode the String\n    var decodedString = Base64.decode(encodedString);\n    if(receivedState === retrieveStateStoredLocally()) {\n     // Authorized request\n    } \n    else {\n      // This response is not for us, reject it\n    }\n    ```\n    \n\n## Redirect users\n\nYou can use the `state` parameter to encode an application state that will put the user where they were before the authentication process started. For example, if a user intends to access a protected page in your application, and that action triggers the request to authenticate, you can store that URL to redirect the user back to their intended page after the authentication finishes.\n\nGenerate and store a nonce locally (in cookies, session, or local storage) along with any desired state data like the redirect URL. Use the nonce as a state in the protocol message. If the returned state matches the stored nonce, accept the OAuth2 message and fetch the corresponding state data from storage. This is the approach we use in auth0.js.\n\n### Use the stored URL to redirect users\n\n1.  Set the nonce state parameter value that you used to mitigate CSRF attacks as explained above.\n    \n2.  Store the nonce locally, using it as the key to store all the other application state information such as the URL where the user intended to go. For example:\n    \n    ```\n    {\n      \"xyzABC123\" : {\n        redirectUrl: '/protectedResource',\n        expiresOn: [...]\n      }\n    }\n    ```\n    \n3.  Authenticate the user, [sending the generated nonce as the state](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow).\n    \n4.  As part of the callback processing and response validation, verify that the state returned matches the nonce stored locally. If it does, retrieve the rest of the application state (like the `redirectUrl`).\n    \n5.  Once you complete the callback processing, redirect the user to the URL previously stored.\n    \n\n### Alternate redirect method\n\n1.  Generate and store a nonce value locally.\n    \n2.  Encode any desired state (like the redirect URL) along with the nonce in a protected message (that will need to be encrypted/signed to avoid tampering).\n    \n3.  In the response processing, unprotect the message, getting the nonce and other properties stored.\n    \n4.  Validate that the included nonce matches what was stored locally and, if so, accept the OAuth2 message.\n    \n\n## Limitations and considerations\n\n*   Choose a storage method based on your application type.\n    \n    | App Type | Storage Recommendation |\n    | --- | --- |\n    | Regular Web App | Cookie or session |\n    | SPA | Local browser |\n    | Native App | Memory or local |\n    \n*   From a security perspective, neither the request nor the response is integrity-protected so a user can manipulate them. That is true for adding a parameter to the `redirect_uri` as well.\n    \n*   The allowed length for state parameter value is not unlimited. If you get the error `414 Request-URI Too Large`, try a smaller value.\n    \n*   Passing URLs in plaintext or in any predictable way is unsafe. Ensure that the state parameter value is:\n    \n    *   Unique and opaque to ensure that it can be used for defense against CSRF and phishing attacks.\n        \n    *   If stored in a cookie, it should be signed to prevent forgery.\n        \n\n## Learn more\n\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)\n*   [Sessions](https://auth0.com/docs/manage-users/sessions)",
    "title": "Prevent Attacks and Redirect Users with OAuth 2.0 State Parameters",
    "description": "Describes how to use the state parameter in authentication requests to help prevent CSRF attacks and restore state",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon",
    "markdown": "# Enable SAML2 Web App Addon\n\nYou can configure a SAML2 Web Application add-on for use with an application.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Identify the application with which you want to use a SAML2 Web Application, and click the Application's name to go to its configuration settings.\n    \n3.  Go to the **Addons** tab.\n    \n4.  In the **SAML2 Web App** box, click the slider to enable the Addon.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n5.  Go to the **Settings** tab and provide your **Application Callback URL** that receives the SAML response, as well as the **Settings**. On the **Settings** tab, there is a sample object that you can use when determining which settings you want to enable.\n    \n6.  Click **Debug** to test if your provided parameters are valid.\n    \n7.  Click **Save** when done.\n    \n\n## Provide application details\n\nWhile the specific steps for providing your application details to your SAML2 Web App will vary, you can get the configuration information you need from the **Usage** tab after you set up the addon.\n\n![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Integrations\n\nYou can choose from the following integrations:\n\n*   [Amazon Web Services](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)\n    \n*   [GitHub Enterprise Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-cloud)\n    \n*   [GitHub Enterprise Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n    \n*   [Heroku](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-heroku)\n    \n*   [Oracle Eloqua Marketing Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-addon-eloqua)\n    \n\n## Limitation\n\nThe SAML2 Web App addon does not support passive SAML requests (e.g. where `isPassive=true`).\n\n## Learn more\n\n*   [Configure Amazon Web Services as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)\n*   [Configure GitHub Enterprise Cloud as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-cloud)\n*   [Configure GitHub Enterprise Server as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n*   [Configure Heroku as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-heroku)\n*   [Configure Oracle Eloqua Marketing Cloud as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-addon-eloqua)\n*   [CVE-2017-16897: Security Update for passport-wsfed-saml2 Passport Strategy Library](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2017-16897)",
    "title": "Enable SAML2 Web App Addon",
    "description": "Learn how to enable the SAML2 web app add-on for use with Auth0 as a SAML single sign-on (SSO) identity provider. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login",
    "markdown": "# Auth0 Universal Login\n\nAuth0 Universal Login provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process. \n\nWith Universal Login, you don’t have to complete any integration work to accommodate different methods of authentication. You can start with a simple username and password flow, then add additional features, such as social login or multi-factor authentication (MFA), to customize a secure and user-friendly login experience.\n\nConfiguring Universal Login is dynamic and does not require any application-level changes, as web pages hosted on Auth0’s centralized authentication server completely drive the login flow. Additionally, you don’t need to manually update your code for applications to benefit from improvements Auth0 makes to Universal Login.\n\nFrom the Auth0 Dashboard, you can customize the appearance and behavior of login pages to create a consistent, branded experience. For advanced use cases, you can also change the code of each page individually.\n\nTo learn more about the differences between Universal Login and embedded login, review [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\n## Configure Universal Login\n\nOn your Auth0 Dashboard, you can choose which experience to use for default login pages under [Branding > Universal Login > Advanced Options](https://manage.auth0.com/#/universal-login/customizations-new).\n\n![Auth0 Branding Universal Login Settings Tab Experience](https://images.ctfassets.net/cdy7uua7fh8z/1kronfcLaGJ9NqgfGsKtGi/3b1495aa7b9aaad8802630d2be7e59ef/Universal_Login_Experience_-_Dashboard_Options_-_Smaller__1_.png)\n\nAuth0 offers two hosted login experiences:\n\n*   **Universal Login** offers a streamlined experience for users and does not require the use of JavaScript for customization.\n    \n*   **Classic Login** uses JavaScript controls for each page of the login flow.\n    \n\nAt this time, Auth0’s active development efforts are focused on Universal Login, and Classic Login no longer receives updates. Unless your specific use case requires the Classic experience, implementing Universal Login is recommended.\n\nTo learn more about how these two experiences compare, review [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).\n\n### Accessibility\n\nAuth0 is implementing [WCAG 2.2 standards](https://www.w3.org/WAI/standards-guidelines/wcag/) to improve access to universal login flows for people with different vision levels. During the initial Early Access rollout, you can use WCAG standards by enabling the toggle on your [Auth0 Dashboard](https://manage.auth0.com/dashboard/us/dev-6endizjt/login_settings).\n\n![In Early Access, this toggle enables WCAG elements in your sign-in flow. ](https://images.ctfassets.net/cdy7uua7fh8z/5O4DDy1h0rgbYNzKwm1lKY/0218b59f9773d500f54a1fdaebdf9cd5/Screenshot_2024-04-05_at_3.31.39_PM_2__4_.png)\n\nThis feature can also be enabled in the Management API by updating the `enable_ulp_wcag_compliance` flag in the [Update Prompt Settings endpoint](https://auth0.com/docs/api/management/v2/prompts/patch-prompts):\n\n```\ncurl -L -X PATCH 'https://<tenant_name>.auth0.com/api/v2/prompts' \\\n-H 'Content-Type: application/json' \\\n-H 'Accept: application/json' \\\n-H 'Authorization: Bearer 'abc123' \\\n-d '{\"universal_login_experience\":\"new\",\"identifier_first\":true,\"webauthn_platform_first_factor\":true,\"enable_ulp_wcag_compliance\":true}'\n```\n\nThese improvements are optional during the Early Access period and do not apply to Classic Login. After the feature is made generally available, the option to opt in will be deprecated and removed for all customers.\n\n### Customize login page\n\nAfter enabling Universal Login, you can customize your login page directly from the Auth0 Dashboard. Specifically, you can customize page templates and themes, sign-up and login prompts, and other text elements. To learn more, review Customize Universal Login. \n\nIf you decide to implement Classic Login, you can customize basic branding options from the Auth0 Dashboard. You can then configure advanced customization with the SDK used to build your login flow. To learn more, review Customize Classic Login.\n\n## Implement Universal Login\n\nAfter enabling either Universal Login or Classic Login within your tenant, follow the steps below to implement the experience:\n\n1.  [Register your application](https://auth0.com/docs/get-started/auth0-overview/create-applications) with Auth0.\n    \n2.  Configure your application to call the [Login endpoint](https://auth0.com/docs/api/authentication#login) of the Authentication API to trigger the login flow and handle the response. and handle the response. You can configure this directly or use one of Auth0's [SDKs](https://auth0.com/docs/libraries).\n    \n3.  Create a [Database](https://auth0.com/docs/get-started/applications/set-up-database-connections), [Enterprise](https://auth0.com/docs/authenticate/enterprise-connections), or [Social](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers) connection and enable it for your application.\n    \n\n### Navigate to the login page\n\nYou can call the [Login endpoint](https://auth0.com/docs/api/authentication#login) directly from any browser:\n\n```\nhttps://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection={connectionName}&\n  redirect_uri={https://yourApp/callback}&\n  state={state}\n```\n\nThe request must include the following values:\n\n*   `response_type` (either `code` or `token`)\n    \n*   `client_id`\n    \n*   `redirect_uri`\n    \n*   `state`\n    \n    *   To better understand why this value is required review [Prevent Attacks and Redirect Users With OAuth 2.0 State Parameters](https://auth0.com/docs/secure/attack-protection/state-parameters).\n        \n\nOptionally, you can include the `connection` parameter to prompt users to authenticate with the specified connection.\n\n### Use the Quickstart guides\n\nFor more information on how you can set up Universal Login for your application, review the [Quickstart guides](https://auth0.com/docs/quickstarts). Choose the approach that best fits your technologies and follow the Quickstart for a walkthrough of the implementation.\n\n## Learn more\n\n*   [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login)\n*   [Universal Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience)\n*   [Classic Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience)\n*   [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login)\n*   [Universal Login Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization)",
    "title": "Auth0 Universal Login",
    "description": "Describes how Auth0 Universal Login provides you with the means to prove your users' identities with our authorization server.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims",
    "markdown": "# Create Custom Claims\n\nTo read custom claims on access and ID tokens, you must use JSON Web Tokens (JWT) and pass an audience (`aud`) in an OIDC login flow. To learn more, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens).\n\nWhen configuring custom claims on JWTs, you want to avoid collisions. To keep your custom claims from colliding with any reserved claims or claims from other resources, give them a collision-resistant name. Auth0 recommends using a namespaced format.\n\n## General restrictions\n\nAuth0 applies the following restrictions to custom claims:\n\n*   Custom claims payload is set to a maximum of 100KB\n    \n*   OPENID standard claims or claims used internally by Auth0 cannot be customized or modified\n    \n*   Access tokens with an Auth0 API audience, excluding the `/userinfo` endpoint, cannot have private, non-namespaced custom claims \n    \n*   Only specified OIDC user profile claims can be added to access tokens\n    \n\nThe following claims are subject to Auth0's restrictions:\n\n*   `acr`\n*   `act`\n*   `active`\n*   `amr`\n*   `at_hash`\n*   `ath`\n*   `attest`\n*   `aud`\n*   `auth_time`\n*   `authorization_details`\n*   `azp`\n*   `c_hash`\n*   `client_id`\n*   `cnf`\n*   `cty`\n*   `dest`\n*   `entitlements`\n*   `events`\n*   `exp`\n*   `groups`\n*   `gty`\n*   `htm`\n*   `htu`\n*   `iat`\n*   `internalService`\n*   `iss`\n*   `jcard`\n*   `jku`\n*   `jti`\n*   `jwe`\n*   `jwk`\n*   `kid`\n*   `may_act`\n*   `mky`\n*   `nbf`\n*   `nonce`\n*   `object_id`\n*   `org_id`\n*   `org_name`\n*   `orig`\n*   `origid`\n*   `permissions`\n*   `roles`\n*   `rph`\n*   `s_hash`\n*   `sid`\n*   `sip_callid`\n*   `sip_cseq_num`\n*   `sip_date`\n*   `sip_from_tag`\n*   `sip_via_branch`\n*   `sub`\n*   `sub_jwk`\n*   `toe`\n*   `txn`\n*   `typ`\n*   `uuid`\n*   `vot`\n*   `vtm`\n*   `x5t#S256`\n\n### Non-restricted claims\n\nYou can create claims for sensitive user information to enhance the user profile and add to the user experience. These claims are consumed by your application from ID tokens. To learn more about using non-restricted claims, read [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens), and keep in mind [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices) if you use them.\n\nThe following claims are only subject to general restrictions:\n\n*   `address`\n*   `birthdate`\n*   `email`\n*   `email_verified`\n*   `family_name`\n*   `gender`\n*   `given_name`\n*   `locale`\n*   `middle_name`\n*   `name`\n*   `nickname`\n*   `phone_number`\n*   `phone_number_verified`\n*   `picture`\n*   `preferred_username`\n*   `profile`\n*   `updated_at`\n*   `website`\n*   `zoneinfo`\n\n## Namespaced guidelines\n\nUse the following guidelines for namespace identifiers:\n\n*   Use any non-Auth0 HTTP or HTTPS URL as a namespace identifier. Auth0 domains cannot be used as namespace identifiers, and include:\n    \n    *   auth0.com\n        \n    *   webtask.io\n        \n    *   webtask.run\n        \n*   Use a URL that you control as a namespace identifier; this allows you to avoid the risk that someone else is using the same namespace. The namespace URL does not have to point to an actual resource. It is only used as an identifier; it will not be called.\n    \n*   Begin the URL with `http://` or `https://`.\n    \n*   Create multiple namespaces, as needed.\n    \n\nOnce you have chosen your namespace, append the claim to it to create a namespaced claim, which can be added to a token. For example:\n\n`http://www.example.com/favorite_color`\n\n## Non-namespaced guidelines\n\nUse the following guidelines for non-namespaced custom claims:\n\n*   Unless absolutely necessary for your application, use public, namespaced custom claims that are collision resistant.\n    \n*   Create claims with meaningful and collision resistant names. For example, use `employee_id` instead of `e_id`.\n    \n*   Keep the claim names and values as light as possible, passing only the data strictly necessary for your application.\n    \n*   Avoid assigning heavy payloads to custom claims.\n    \n\nFor more examples of custom claims added to a token, see [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims).\n\n## Create custom claims\n\nUse Auth0 Actions to create custom claims. The `api` object allows you to use the method `setCustomClaim` on access tokens or ID tokens.\n\n### Example\n\n```\nexports.onExecuteCredentialsExchange = async (event, api) => {\n  api.accessToken.setCustomClaim('myClaim', 'this is a private, non namespaced claim');\n};\n```\n\n## Learn more\n\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes)",
    "title": "Create Custom Claims",
    "description": "Learn how to create collision-resistant names for custom claims.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/id-tokens",
    "markdown": "# ID Tokens\n\nID tokens are used in token-based authentication to cache user profile information and provide it to a client application, thereby providing better performance and experience. The application receives an ID token after a user successfully authenticates, then consumes the ID token and extracts user information from it, which it can then use to personalize the user's experience.\n\nFor example, suppose you have a regular web app that you [register it with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps) and configure to allow users to login with Google. Once a user logs in, use the ID token to gather information such as name and email address, which you can then use to auto-generate and send a personalized welcome email.\n\nID Tokens should never be used to obtain direct access to APIs or to make authorization decisions.\n\n## ID token security\n\nAs with other [JWTs](https://auth0.com/docs/secure/tokens/json-web-tokens), you should follow [token usage best practices](https://auth0.com/docs/secure/tokens/token-best-practices) when using and storing ID tokens.\n\nSecuring apps that make API calls come with their own set of concerns. You'll need to ensure that tokens and other sensitive data are not vulnerable to cross-site scripting (XSS) and can't be read by malicious JavaScript.\n\n## ID token lifetime\n\nBy default, an ID token is valid for 36000 seconds (10 hours). If there are security concerns, you can shorten the time period before the token expires, keeping in mind that one of the purposes of the token is to improve user experience by caching user information. See [Update ID Token Lifetime](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime) for details.\n\n## Learn more\n\n*   [Validate ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens)\n*   [Get ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens)\n*   [Revoke Tokens](https://auth0.com/docs/secure/tokens/revoke-tokens)\n*   [ID Token Structure](https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "ID Tokens",
    "description": "Describes how ID Tokens are used in token-based authentication to cache user profile information and provide it to a client application.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/email-templates",
    "markdown": "# Customize Email Templates\n\nThe **Redirect To** URL is an optional destination to redirect the user to after the relevant action (verify account, reset password, unblock account) was performed.\n\nWith the Universal Login Classic Experience, you can provide a URL to which users are redirected after they reset their password. Auth0 sends a `success` indicator and a `message` to the URL. To learn more about these two parameters, see [Email Template Descriptions](https://auth0.com/docs/customize/email/email-templates/email-template-descriptions).\n\nWith the New Universal Login Experience, Auth0 redirects users to the default log in route when the user succeeds in resetting the password. If not, Auth0 handles the errors as part of the Universal Login flow and ignores the redirect URL provided in the email template.\n\nOnly the following three variables are available on the **Redirect To** URL:\n\n*   `application.name` (or its synonym `client.name`)\n    \n*   `application.clientID`\n    \n*   `application.callback_domain` (or its synonym `client.callback_domain`)\n    \n\nThe `application.callback_domain` variable will contain the origin of the **first** URL listed in the application's **Allowed Callback URL** list. This lets you redirect users to a path of the application that triggered the action by using a syntax like this:\n\n`{{ application.callback_domain }}/result_page`\n\nNote that while the variable is called `callback_domain`, it is really an origin, so it includes the protocol in addition to the domain, e.g. `https://myapp.com`.\n\nIf your application has multiple **Allowed Callback URLs** configured, Auth0 will use the first URL listed. You can also provide a default origin using Liquid syntax:\n\n`{{ application.callback_domain | default: \"https://my-default-domain.com\" }}/result_page`\n\n##### Dynamic redirect to URLs\n\nYou can set up a different Redirect To URLs based on your application name. For example:\n\n`{% if application.name == 'JWT.io' %} https://jwt.io {% else %} https://auth0.com {% endif %}`\n\nBecause the application name is encoded for security, you should always use an encoded value (especially if your application name contains a character that changes once encoded). For example, you'll want to use `My%20App` instead of `My App`.\n\nFor single-page applications (SPAs), the **Redirect To** URL may contain the hash and route for a particular state/view in the app, followed by route parameters. This can cause the following issue with the **Redirect To** URL:\n\n`http://localhost:3000/#/register`\n\nWhich will result in a user getting redirected to the following URL:\n\n```\nhttp://localhost:3000/?supportSignUp=true\n  &supportForgotPassword=true\n  &email=john.doe%40exampleco.com\n  &message=Your%20email%20was%20verified.%20You%20can%20continue%20using%20the%20application.\n  &success=true#/register\n```\n\nThis is described by Internet Standards (to learn more, read the [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) spec by the Internet Engineering Task Force) that define the expected order of a URL as `scheme|authority|path|query|fragment`. However, SPA frameworks (such as Angular) typically expect URLs in the `scheme|authority|path|fragment|query` format (with the query string parameters at the end). This causes the application not to enter the expected state. For example, with the above URL, the app will be routed to `/` instead of `/#/register`.\n\nTo work around this limitation of SPA frameworks, it is recommended to use a server-side callback URL as the **redirect To** URL with a `route` parameter that preserves the SPA app route for the redirect. Once in this server-side URL, simply redirect to the SPA route saved in the `route` parameter along with rest of the query string.\n\n1.  Add a server-side URL as the **redirect To** URL with a `route` parameter that records the SPA route for the redirect. `http://localhost:3001/register?route=register`\n    \n2.  Create a server-side route controller that reads the `route` and other parameters from the URL and redirects to the SPA route specified in `route` parameter. Remember to append the other parameters received from Auth0.\n    \n    ```\n    var express = require('express');\n    var router = express.Router();\n    var qs = require('qs'); // to read query string params and stringify them\n    \n    router.get('/register', function(req, res, next) {\n      var route = req.query.route; // retrieve the route param that contains the SPA client side route user needs to be redirected to.\n    \n      delete req.query.route; // remove it from query params.\n      res.redirect('http://localhost:3000/#/' + route + '?' +  qs.stringify(req.query)); // Send a 302 redirect for the expected route\n    });\n    \n    module.exports = router;\n    ```",
    "title": "Customize Email Templates",
    "description": "Learn how to customize your emails with Liquid templating syntax.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/json-web-tokens",
    "markdown": "# JSON Web Tokens\n\nJSON web token (JWT), pronounced \"jot\", is an open standard ([RFC 7519](https://tools.ietf.org/html/rfc7519)) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. Again, JWT is a standard, meaning that all JWTs are tokens, but not all tokens are JWTs.\n\nBecause of its relatively small size, a JWT can be sent through a URL, through a POST parameter, or inside an HTTP header, and it is transmitted quickly. A JWT contains all the required information about an entity to avoid querying a database more than once. The recipient of a JWT also does not need to call a server to validate the token.\n\n## Benefits of JWTs\n\nThere are benefits to using JWTs when compared to simple web tokens (SWTs) and SAML tokens.\n\n*   **More compact**: JSON is less verbose than XML, so when it is encoded, a JWT is smaller than a SAML token. This makes JWT a good choice to be passed in HTML and HTTP environments.\n    \n\n![Encoded JWT Compared to SAML Token](https://images.ctfassets.net/cdy7uua7fh8z/4S6xl4Yvi0H1CUrLB69ZtH/e3e3bf1767d2d29563a99cf71cab158d/comparing-jwt-vs-saml2.png)\n\n*   **More secure**: JWTs can use a public/private key pair in the form of an X.509 certificate for signing. A JWT can also be symmetrically signed by a shared secret using the HMAC algorithm. And while SAML tokens can use public/private key pairs like JWT, signing XML with XML Digital Signature without introducing obscure security holes is very difficult when compared to the simplicity of signing JSON. Read more about JWT [signing algorithms](https://auth0.com/docs/tokens/concepts/signing-algorithms).\n    \n*   **More common**: JSON parsers are common in most programming languages because they map directly to objects. Conversely, XML doesn't have a natural document-to-object mapping. This makes it easier to work with JWT than SAML assertions.\n    \n*   **Easier to process**: JWT is used at internet scale. This means that it is easier to process on users' devices, especially mobile.\n    \n\n## Use JWTs\n\nJWTs can be used in various ways:\n\n*   **Authentication**: When a user successfully logs in using their credentials, an [ID token](https://auth0.com/docs/secure/tokens/id-tokens) is returned. According to the [OpenID Connect (OIDC) specs](https://openid.net/specs/openid-connect-core-1_0.html#IDToken), an ID token is always a JWT.\n    \n*   **Authorization**: Once a user is successfully logged in, an application may request to access routes, services, or resources (e.g., APIs) on behalf of that user. To do so, in every request, it must pass an Access Token, which may be in the form of a JWT. Single Sign-on (SSO) widely uses JWT because of the small overhead of the format, and its ability to easily be used across different domains.\n    \n*   **Information exchange**: JWTs are a good way of securely transmitting information between parties because they can be signed, which means you can be certain that the senders are who they say they are. Additionally, the structure of a JWT allows you to verify that the content hasn't been tampered with.\n    \n\n## Security of JWTs\n\nThe information contained within the JSON object can be verified and trusted because it is digitally signed. Although JWTs can also be encrypted to provide secrecy between parties, Auth0-issued JWTs are JSON Web Signatures (JWS), meaning they are signed rather than encrypted. As such, we will focus on signed tokens, which can verify the integrity of the claims contained within them, while encrypted tokens hide those claims from other parties.\n\nIn general, JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA (although Auth0 supports only HMAC and RSA). When tokens are signed using public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it.\n\nBefore a received JWT is used, it should be [properly validated using its signature](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens). Note that a successfully validated token only means that the information contained within the token has not been modified by anyone else. This doesn't mean that others weren't able to see the content, which is stored in plain text. Because of this, you should never store sensitive information inside a JWT and should take other steps to ensure that JWTs are not intercepted, such as by sending JWTs only over HTTPS, following [best practices](https://auth0.com/docs/secure/tokens/token-best-practices), and using only secure and up-to-date libraries.\n\n## Learn more\n\n*   [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure)\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens)\n*   [Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys)\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)",
    "title": "JSON Web Tokens",
    "description": "Learn about JSON web tokens (JWTs) and how they are used.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/delegation-tokens",
    "markdown": "# Delegation Tokens\n\nA delegation token should be obtained and used when an application needs to call the API of an Application Add-on, such as Firebase or SAP, registered and configured in Auth0, in the same tenant as the calling program.\n\nGiven an existing token, this endpoint will generate a new token signed with the `target` application's secret. This is used to flow the identity of the user from the application to an API.\n\nThe type of the delegation token varies depending on the provider. For example, if it is issued for Azure Blob Storage, it will be an SAS (Shared Access Signature). If it is for the Firebase Add-on, it will be a JWT.\n\nThe ID token for an authenticated user can be used with the `/delegation` endpoint to request a delegation token for a particular target. The target can be an application Add-on configured in Auth0. The Add-ons for which this can be done are those that are not SAML or WS-Fed Add-ons. The Add-on must be configured in Auth0 with secrets obtained from the Add-on service, such as Firebase. Instructions for setting up the secrets are available from the Add-on configuration page for each Add-on. The secrets are used to sign the delegation token so that the Add-on API can validate and trust the token.\n\nThe delegation endpoint allows you to set several parameters which govern the contents of the delegation token including the `target`, the `scope`, the API to be called (`api_type`), and an additional free-form area for additional parameters.\n\n## Auth0.js example\n\nFor an example on how to get a new token for an Add-on that you have activated, using **Auth0.js**, refer to Delegation Token Request. Note that this example is for **version 7** of the **Auth0.js** library; delegation is **not supported** in version 8 of **Auth0.js**.\n\n## Validity period and termination\n\nThe validity period and the ability to revoke a delegation token, varies by individual Add-on. The documentation available from the provider of any Add-on API should be consulted for further information.\n\n## Use Delegation tokens with public applications\n\nThere is an important caveat to note when using the delegation endpoint with Public Applications.\n\nIf you call the `/token` endpoint from a Public Application, the ID Token will be forcibly signed using `RS256`, even if the JsonWebToken Signature Algorithm in the Application settings is configured as `HS256`.\n\nIf you then subsequently call the delegation endpoint with that ID Token, it will fail if the Application's JsonWebToken Signature Algorithm was configured as `HS256`. This is because delegation performs validation according to the Application's settings, but the ID Token was issued with a different algorithm because of the forced algorithm change.\n\nIt is therefore important that if you intend to use delegation with a Public Application, that you configure the JsonWebToken Signature Algorithm of your application as `RS256`.",
    "title": "Delegation Tokens",
    "description": "Describes how Auth0 delegation tokens work in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/revoke-tokens",
    "markdown": "# Revoke Tokens\n\nOnce issued, access tokens and ID tokens cannot be revoked in the same way as cookies with session IDs for server-side sessions.\n\nAs a result, tokens should be issued for relatively short periods, and then [refreshed](https://auth0.com/docs/secure/tokens/refresh-tokens) periodically if the user remains active.\n\n## Learn more\n\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Revoke Tokens",
    "description": "Describes how to use tokens to control user access.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/manage-refresh-tokens-with-auth0-management-api",
    "markdown": "# Manage Refresh Tokens with Auth0 Management API\n\nAuth0 issues a refresh token as a credential artifact that your application can use to get a new access token without user interaction. This allows Auth0 to shorten the access token lifetime for security purposes without involving the user when the access token expires.\n\n## Management API endpoints\n\nThe Auth0 Management API provides endpoints to manage refresh tokens individually or as a collection.\n\nThese endpoints complement [alternative refresh-token revocation](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens), superseding the `device-credentials` resource endpoints with extended properties and bulk revocation operations.\n\n### Refresh Token resource\n\nYou can view or revoke a specific refresh token with the following endpoints:\n\n| **Name** | **URL** | **Required scope(s)** |\n| --- | --- | --- |\n| View a refresh token information by ID | `GET /api/v2/refresh-tokens/{tokenId}` | `read:refresh_tokens` |\n| Revoke a refresh token by ID | `DELETE /api/v2/refresh-tokens/{tokenId}` | `delete:refresh_tokens` |\n\n### User resource\n\nYou can list or revoke all refresh tokens for a given user with the following endpoints:\n\n| **Name** | **URL** | **Required scope(s)** |\n| --- | --- | --- |\n| List all refresh tokens for a user | `GET /api/v2/users/{userId}/refresh-tokens` | `read:refresh_tokens` |\n| Revoke all refresh tokens for a user | `DELETE /api/v2/users/{userId}/refresh-tokens` | `delete:refresh_tokens` |\n\n## Refresh token properties\n\nThe refresh token endpoints return relevant information about the token and its history.\n\n| **Field** | **Description** |\n| --- | --- |\n| Refresh Token ID | A unique and tenant-specific identifier of the refresh token in the API. It is not the token itself, which is a secret to exchange with the token endpoint in the authentication API.<br><br>Refresh tokens can outlive a session. The refresh token keeps this information regardless of the session lifecycle. |\n| Session ID | The session ID is a persistent identifier of the session in the Auth0 tenant. Note that the session ID corresponds to the `sid` claim already in ID Tokens and Logout Tokens and can be used to cross-reference these entities.<br><br>The refresh token contains references to the session that was used to create the token. The session ID can be used to retrieve additional information with the Management API [introspect a specific session by ID](https://auth0.com/docs/manage-users/sessions/manage-user-sessions-with-auth0-management-api) endpoint. |\n| Relevant Time | Refresh token creation, and expiry information. |\n| Client and Resource Servers Information | Summary information about the applications and APIs bound to a refresh token. |\n\n## Limitations \n\n*   Refresh token revocation (`DELETE`) operations run asynchronously, and are eventually consistent.\n    \n*   Refresh tokens issued on or after 21-09-2023 (22-02-2024 for tenants in the US-3 region) contain the session ID (`session_id`) property with the appropriate value. Refresh tokens issued before this date contain this property with a `null` value.\n    \n\n## Learn more\n\n*   [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Use Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens)",
    "title": "Manage Refresh Tokens with Auth0 Management API",
    "description": "Learn how to manage refresh tokens with the Auth0 Management API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens",
    "markdown": "# Validate ID Tokens\n\nAn [ID token](https://auth0.com/docs/secure/tokens/id-tokens), which contains user profile attributes, is consumed by an app and is typically used for user interface display. Auth0 issues all ID tokens in [JSON web token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens) format.\n\nIf any of these checks fail, the token is considered invalid, and the request must be rejected.\n\n1.  [Validate the JWT](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens).\n    \n2.  Check additional standard claims. If you've performed the standard JWT validation, you have already decoded the [JWT's Payload](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure) and looked at its standard claims. Additional claims to verify for ID tokens include:\n    \n    *   **Token audience** (`aud`, string): The audience value for the token must match the client ID of the application as defined in your [Application's Settings](https://manage.auth0.com/#/applications) in the **Client ID** field.\n        \n    *   **Nonce** (`nonce`, string): Passing a nonce in the token request is recommended (required for the Implicit Flow) to help prevent replay attacks. The nonce value in the token must exactly match the original nonce sent in the request. See [Mitigate Replay Attacks](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow) for details.\n        \n\n## Learn more\n\n*   [Get ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens)\n*   [ID Token Structure](https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure)\n*   [Update ID Token Lifetime](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime)\n*   [Mitigate Replay Attacks When Using the Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow)",
    "title": "Validate ID Tokens",
    "description": "Describes how to validate an ID token.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/token-best-practices",
    "markdown": "# Token Best Practices\n\nHere are some basic considerations to keep in mind when using tokens:\n\n*   **Keep it secret. Keep it safe**: The signing key should be treated like any other credential and revealed only to services that need it.\n    \n*   **Do not add sensitive data to the payload**: Tokens are signed to protect against manipulation and are easily decoded. Add the bare minimum number of claims to the payload for best performance and security.\n    \n*   **Give tokens an expiration**: Technically, once a token is signed, it is valid forever—unless the signing key is changed or expiration explicitly set. This could pose potential issues so have a strategy for expiring and/or revoking tokens.\n    \n*   **Embrace HTTPS**: Do not send tokens over non-HTTPS connections as those requests can be intercepted and tokens compromised.\n    \n*   **Consider all of your authorization use cases**: Adding a secondary token verification system that ensures tokens were generated from your server may be necessary to meet your requirements.\n    \n*   **Store and reuse:** Reduce unnecessary roundtrips that extend your application's attack surface, and optimize plan token limits (where applicable) by storing access tokens obtained from the authorization server. Rather than requesting a new token, use the stored token during future calls until it expires. How you store tokens will depend on the characteristics of your application: typical solutions include databases (for apps that need to perform API calls regardless of the presence of a session) and HTTP sessions (for apps that have an activity window limited to an interactive session). For an example of server-side storage and token reuse, see [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage).\n    \n\n## Tokens vs. Cookies\n\nTypically, single-page apps (such as React, Vue, and AngularJS + Node), native mobile apps (such as iOS and Android), and web APIs (written in Node, Ruby, ASP.NET, or a mix of those) benefit most from token-based authentication. Traditional, server-side web applications have traditionally used cookie-based authentication.\n\nToken-based authentication is implemented by generating a token when the user authenticates and then setting that token in the `Authorization` header of each subsequent request to your API. You want that token to be something standard, like JSON web tokens since you will find libraries in most of the platforms and you don't want to do your own crypto.\n\nWith both approaches, you can get the same amount of information from the user. That's controlled by the `scope` parameter sent in the login request (either using the Lock, our JavaScript library or a plain link). The `scope` is a parameter of the `.signin({scope: 'openid name email'})` method which ends up being part of the query string in the login request.\n\nBy default, we use `scope=openid` in token-based authentication to avoid having a huge token. You can control any standard OpenID Connect (OIDC) claims that you want to get in the token by adding them as scope values. For example, `scope=openid name email family_name address phone_number`. To learn more, see [Standard Claims on openid.net](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).\n\nYou can mix token-based authentication with cookie-based authentication. Take into account that cookies will work just fine if the web app and the API are served from the same domain, so you might not need token based authentication. If you need to, we also return a JWT on the web app flow. Each of our SDKs will do it differently. If you want to call your APIs from JavaScript(instead of using the existing cookie), then you have to set the access tokens using Web Workers or JavaScript closures to handle token transmissions and storage. To learn more, read the Browser in-memory scenarios section of our [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage) page.\n\n## Refresh token usage\n\nYou can only get a Refresh token if you are implementing the following flows:\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow)\n    \n*   [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/add-login-using-the-authorization-code-flow-with-pkce)\n    \n*   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n    \n*   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)\n    \n\nIf you limit offline access to your API, a safeguard configured via the **Allow Offline Access** switch at [Auth0 Dashboard > Applications > APIs > Settings](https://manage.auth0.com/#/apis), Auth0 will not return a Refresh Token for the API (even if you include the `offline_access` scope in your request).\n\nRules will run for the refresh token exchange. To execute special logic, you can look at the `context.protocol` property in your rule. If the value is `oauth2-refresh-token`, then the rule is running during the exchange.\n\nWhen trying to get a refresh token, the audience parameter is not available on the Rules context object. If you receive an error when attempting to add the audience parameter, verify that you do not have it set on the token.\n\nIf you try to do a redirect with `context.redirect`, the authentication flow will return an error.\n\nIf you have added custom claims to your tokens using a rule, the custom claims will appear in new tokens issued when using a refresh token for as long as your rule is in place. Although new tokens do not automatically inherit custom claims, rules run during the refresh token flow, so the same code will be executed. This allows you to add or change custom claims in newly-issued tokens without forcing previously-authorized applications to obtain a new refresh token.\n\n### Refresh token limits\n\nAuth0 limits the amount of active refresh tokens to 200 tokens per user per application. This limit only applies to active tokens. If the limit is reached and a new refresh token is created, the system revokes and deletes the oldest token for that user and application. Revoked tokens and expired tokens do not count against the limit.\n\n#### Automated tests\n\nRefresh tokens accumulate due to automated tests and are generally used for the test lifetime. To avoid a token stockpile subject to refresh token limits, you can use the Auth0 Management API to remove unnecessary refresh tokens.\n\n1.  [Create a user](https://auth0.com/docs/api/management/v2#!/Users/post_users) with Management API. You will use this user for testing.\n    \n2.  The response returns a `user_id` that you need to persist during tests to be used later.\n    \n3.  Once tests are complete, [delete the user](https://auth0.com/docs/api/management/v2#!/Users/delete_users_by_id) through Management API. When the test user is deleted, the associated artifacts are also removed, including refresh tokens.\n    \n\nIf you want to keep the test user for future testing:\n\n1.  List the user’s refresh tokens using [Management API's device credential endpoint](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials). The endpoint will return a maximum of 1000 tokens without specific order regardless of accumulated tokens or the use of pagination.\n    \n2.  Delete those credentials [using the DELETE](https://auth0.com/docs/api/management/v2#!/Device_Credentials/delete_device_credentials_by_id) method.\n    \n3.  If the user has more than 1k tokens, repeat listing and deleting tokens until no more tokens left for the user.\n    \n\n#### Configure Expiring Refresh Tokens\n\nWhen users log into your application with Auth0, and when the `offline_access` is requested in the authorization request, a new refresh token is issued to the user. In the case users log out and in again with the same device, a new refresh token is issued. Depending on how your application stores and uses refresh tokens, the old refresh token from the first login might become obsolete, and your application will most likely use the new refresh tokens if both tokens are issued with the same audience. To learn more, read [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage).\n\nTo avoid accumulating obsolete refresh tokens, even though the refresh token limit removes the oldest token first, we recommend you configure refresh token expiration. Both rotating and non-rotating (or reusable) refresh tokens can be configured to expire with either idle or absolute expiry values. Both expiration values help remove tokens that are not in active use and avoid accumulating tokens for the user. To learn more, read [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration).\n\n## JWT validation\n\nWe strongly recommend that you use middleware or one of the existing open source third-party libraries to parse and validate JWTs. At [JWT.io](https://jwt.io/#libraries-io), you can find libraries for various platforms and languages, such as .NET, Python, Java, Ruby, Objective-C, Swift, and PHP.\n\n## Signing algorithms\n\nThe algorithm used to sign tokens issued for your application or API. A signature is part of a JWT and is used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way. To learn more about JWTs, read [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens). To learn more about signatures, read [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure).\n\nYou can select from the following signing algorithms:\n\n*   **RS256** (RSA Signature with SHA-256): An asymmetric algorithm, which means that there are two keys: one public key and one private key that must be kept secret. Auth0 has the private key used to generate the signature, and the consumer of the JWT retrieves a public key from the Metadata endpoints provided by Auth0 and uses it to [validate the JWT signature](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens).\n    \n*   **HS256** (HMAC with SHA-256): A symmetric algorithm, which means that there is only one private key that must be kept secret, and it is shared between the two parties. Since the same key is used both to generate the signature and to validate it, care must be taken to ensure that the key is not compromised. This private key (or secret) is created when you register your Application (**Client Secret**) or API (**Signing Secret**) and choose the HS256 signing algorithm.\n    \n\nThe most secure practice, and our recommendation, is to use **RS256** because:\n\n*   With RS256, you are sure that only the holder of the private key (Auth0) can sign tokens, while anyone can check if the token is valid using the public key.\n    \n*   With RS256, you can request a token that is valid for multiple audiences.\n    \n*   With RS256, if the private key is compromised, you can implement key rotation without having to re-deploy your application or API with the new secret (which you would have to do if using HS256).\n    \n*   With HS256, if the secret key is compromised you would have to redeploy the API with the new secret.\n    \n\n## Signing keys\n\nIt's good practice to assume that multiple signing keys could be present in your JWKS. This may seem unnecessary since the Auth0 JWKS endpoint typically contains a single signing key; however, multiple keys can be found in the JWKS when rotating signing certificates.\n\nWe recommend that you cache your signing keys to improve application performance and avoid running into rate limits, but you will want to make sure that if decoding a token fails, you invalidate the cache and retrieve new signing keys before trying **only one** more time.\n\n## Learn more\n\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage)",
    "title": "Token Best Practices",
    "description": "Lists best practices when using tokens in authentication and authorization.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/access-token-profiles",
    "markdown": "# Access Token Profiles\n\nAccess token profiles define the format and claims of access tokens issued for an API. Auth0 supports the following access token profiles, also known as token dialects:\n\n*   Auth0 token profile, or the default access token profile\n    \n*   RFC 9068 token profile, or the access token profile that follows the [IETF JWT Profile for OAuth 2.0 Access Tokens (RFC 9068)](https://datatracker.ietf.org/doc/html/rfc9068)\n    \n\n| **Token Profile** | **Description** | **Token Dialect** |\n| --- | --- | --- |\n| Auth0 token profile | The default token profile. Issues access tokens formatted as a [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens). | The Auth0 token profile is associated with two token dialects:<br><br>*   `access_token`<br>*   `access_token_authz`, or the `access_token` profile with the `permissions` claim included |\n| RFC 9068 token profile | Issues access tokens formatted as a JSON Web Token (JWT) following the [IETF standard](https://datatracker.ietf.org/doc/html/rfc9068) for encoding OAuth 2.0 Access Tokens in JWT format. | The RFC 9068 token profile is associated with two token dialects:<br><br>*   `rfc9068_profile`<br>*   `rfc9068_profile_authz`, or the `rfc9068_profile` profile with the `permissions` claim included |\n\nWhile both access token profiles issue JWTs, the JWTs have [different token formats](#token-profile-differences). Both access token profiles can enable [Role-Based Access Control (RBAC)](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis) and add the permissions claim to the access token. \n\nTo configure the access token profile for an API, read [Configure Access Token Profile](https://auth0.com/docs/get-started/apis/configure-access-token-profile).\n\n### Auth0 profile sample token\n\n```\n{\n  \"iss\": \"https://my-domain.auth0.com/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": [\n    \"https://example.com/health-api\",\n    \"https://my-domain.auth0.com/userinfo\"\n  ],\n  \"azp\": \"my_client_id\",\n  \"exp\": 1311281970,\n  \"iat\": 1311280970,\n  \"scope\": \"openid profile read:patients read:admin\",\n  \"my_custom_claim\": \"my_custom_value\"\n}\n```\n\n### RFC 9068 profile sample token\n\n```\n{\n  \"iss\": \"https://my-domain.auth0.com/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": [\n    \"https://example.com/health-api\",\n    \"https://my-domain.auth0.com/userinfo\"\n  ],\n  \"client_id\": \"my_client_id\",\n  \"exp\": 1311281970,\n  \"iat\": 1311280970,\n  \"jti\":\"73WakrfVbNJBaAmhQtEeDv\",\n  \"scope\": \"openid profile read:patients read:admin\",\n  \"my_custom_claim\": \"my_custom_value\"\n}\n```\n\n## Token profile differences\n\nThe Auth0 profile and RFC 9068 profile issue JWTs that have different token formats. The main differences are:\n\n*   The RFC 9068 profile incorporates the `jti` claim, providing a unique identifier for the JWT.\n    \n*   The Auth0 profile uses the `azp` claim to represent the client ID whereas the RFC 9068 profile uses the `client_id` claim.\n    \n*   The RFC 9068 profile does not use the `gty` claim, which is an Auth0-specific claim that represents the authentication flow.\n    \n\n| **Data** | **RFC 9068 Profile** | **Auth0 Profile** |\n| --- | --- | --- |\n| `type` | `at+jwt` | `JWT` |\n| `alg` | Signing algorithm, for example, `RS256` | Signing algorithm, for example, `RS256` |\n\n### Claims\n\n| **Claim** | **Description** | **Present in RFC 9068 Profile** | **Present in Auth0 Profile** | **Sample Claim** |\n| --- | --- | --- | --- | --- |\n| `iss` | Issuer identifier for the Auth0 tenant issuing the access token. | Yes | Yes | Tenant domain: `https://tenant.auth0.com/` |\n| `sub` | The subject claim indicates which user or application the access token was issued for:<br><br>*   For grants where an end user is involved, such as the Authorization Code Flow, the `sub` claim is the `user_id`.<br>*   For Machine-to-Machine applications using the Client Credentials grant where no end user is involved, the `sub` claim is a unique identifier for the application. | Yes | Yes | *   User ID:`auth0\\|6553da60a54af58e29493993`<br>*   Client ID with suffix: `awZfdIir8YFdGZWkvCejDoUb7SjTDicx@clients` |\n| `aud` | The audience claim defines the intended recipient of the access token. | Yes | Yes | `\"https://test-server/api\"` OR `[ \"https://test-server/api\", \"https://test.local.dev.auth0.com/userinfo\" ]` |\n| `client_id` | Client ID of the application that requests the access token. | Yes | No  | Client ID: `K1AUPhZq8mRi0Q0pjhkfu1D7y6KjDQja` |\n| `azp` | Client ID of the application that requests the access token. | No  | Yes | Client ID: `K1AUPhZq8mRi0Q0pjhkfu1D7y6KjDQja` |\n| `exp` | The expiration time on or after which the access token must not be accepted for processing. | Yes | Yes | Epoch timestamp in seconds: `1516238022` |\n| `iat` | Timestamp at which the access token was issued. | Yes | Yes | Epoch timestamp in seconds: `1516239022` |\n| `scope` | Scope of the issued access token. To learn more, read [Scopes](https://auth0.com/docs/get-started/apis/scopes). | Yes | Yes | `\"openid profile offline_access\"` |\n| `jti` | Unique identifier for the access token. | Yes | No  | Unique string identifier: `aBv9njtYfwL4xfPZyEwz9m` |\n| `gty` | [Grant type](https://auth0.com/docs/get-started/applications/application-grant-types) that the application used to request the access token. Only present for `password` and `refresh_token` grant types. | No  | Case-specific | Grant type: `password` |\n| `permissions` | Permissions available to a user or application depending on their role. Included only when the **Enable RBAC** and **Add permissions in the Access Token** settings are enabled for the API. To learn more, read [Enable Role-Based Access Control for APIs.](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis) | Case-specific | Case-specific | `[ \"create:bar\", \"create:foo\", \"read:bar\", \"read:foo\" ]` |\n| `org_id` | Organization ID. Added when a user has authenticated through an Organization. To learn more, read [Work with Tokens and Organizations.](https://auth0.com/docs/manage-users/organizations/using-tokens) | Case-specific | Case-specific | Organization ID: `org_9ybsU1dN2dKfDkBi` |\n| `org_name` | Organization Name. Added when a user has authenticated through an Organization and the **Organization Names in Authentication API** setting is enabled. To learn more, read [Use Organization Names in Authentication API.](https://auth0.com/docs/manage-users/organizations/configure-organizations/use-org-name-authentication-api) | Case-specific | Case-specific | Organization Name: `my_organization` |\n| `authorization_details` | Authorization details used in Rich Authorization Requests (RAR). To learn more, read [Authorization Code Flow with Rich Authorization Requests.](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar) | Case-specific | Case-specific | `{ \"type\": \"money_transfer\", \"instructedAmount\": {\"amount\": 2500, \"currency\": \"USD\"}, \"destinationAccount\": \"xxxxxxxxxxx9876\", \"beneficiary\": \"Hanna Herwitz\", }` |\n| `cnf` | Confirmation claim that is supported for [mTLS Token Binding](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-resource-server-for-token-binding). | Case-specific | Case-specific | `{\"x5t#S256\":\"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0\"}` |\n| Custom claims | Custom claims can be added to access tokens via Actions. To learn more, read [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims). | Case-specific | Case-specific | `\"favorite_color\": “blue”` |",
    "title": "Access Token Profiles",
    "description": "Learn about the access token profiles that Auth0 supports. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/security-guidance/data-security/token-storage",
    "markdown": "# Token Storage\n\nSecuring SPAs that make API calls come with their own set of concerns. You'll need to ensure that tokens and other sensitive data are not vulnerable to [cross-site scripting](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)) (XSS) and can't be read by malicious JavaScript.\n\nTo learn more, see [JWT Handbook](https://auth0.com/resources/ebooks/jwt-handbook) and [The Ultimate Guide to Next.js Authentication with Auth0](https://auth0.com/blog/ultimate-guide-nextjs-authentication-auth0/?utm_source=twitter&utm_medium=sc&utm_campaign=nextjs_authn_guide).\n\n#### Next.js static site scenarios\n\nWhen you're building a Next.js application, authentication might be needed in the following cases:\n\n1.  When accessing a page\n    \n2.  When accessing an API route\n    \n3.  When your application calls an API hosted outside of your Next.js application on behalf of the user\n    \n\nWhere a server is available, your app can handle the interaction with Auth0 and create a session, but in this model, we don't have a backend. All of the work happens on the frontend:\n\n1.  The user is redirected to Auth0.\n    \n2.  When the user is successfully signed in, they will be redirected back to the application.\n    \n3.  The client-side will complete the code exchange with Auth0 and retrieve the user's `id_token` and `access_token` which will be stored in memory.\n    \n    ![Token Storage Best Practices In-Memory Storage diagram](https://images.ctfassets.net/cdy7uua7fh8z/6a4aA0TH8PJQpvhkLaGSIp/e38aae00318515f2a0efa0dfce24dca2/in-memory-token-storage.png)\n\nIf your app is using a sign in scenario that doesn't require API calls, only an ID token is required. There is no need to store it. You can validate it and get the data from it that you required.\n\nIf your app needs to call APIs on behalf of the user, access tokens and (optionally) refresh tokens are needed. These can be stored server-side or in a session cookie. The cookie needs to be encrypted and have a maximum size of 4 KB. If the data to be stored is large, storing tokens in the session cookie is not a viable option.\n\nUse the following flow types in these scenarios:\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)\n    \n*   [Regular Web App Quickstarts](https://auth0.com/docs/quickstart/webapp)\n    \n\n### Browser in-memory scenarios\n\nAuth0 recommends storing tokens in browser memory as the most secure option. Using [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) to handle the transmission and storage of tokens is the best way to protect the tokens, as Web Workers run in a separate global scope than the rest of the application. Use Auth0 SPA SDK whose default storage option is in-memory storage leveraging Web Workers.\n\nIf you cannot use Web Workers, Auth0 recommends as an alternative that you use [JavaScript closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Emulating_private_methods_with_closures) to emulate private methods.\n\nUse Auth0 SPA SDK whose default storage option is in-memory storage to leverage both Web Workers and JavaScript closures depending on the type of token.\n\n### Browser local storage scenarios\n\nUsing browser local storage can be a viable alternative to mechanisms that require retrieving the access token from an iframe and to cookie-based authentication across domains when these are not possible due to browser restrictions (for example, ITP2).\n\nTo reduce security risks if your SPA is using implicit (we recommend using authorization code flow with PKCE instead) or hybrid flows, you can reduce the absolute token expiration time. This reduces the impact of a reflected XSS attack (but not of a persistent one). To reduce the expiration time, go to **Dashboard > APIs > Settings > Token Expiration For Browser Flows (Seconds)**.\n\nReduce the amount of third-party JavaScript code included from a source outside your domain to the minimum needed (such as links to jQuery, Bootstrap, Google Analytics etc.) Reducing third-party JS code reduces the possibility of an XSS vulnerability. Performing [Subresource Integrity (SRI)](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) checking in third-party scripts (where possible) to verify that the resources fetched are delivered without unexpected manipulation is also more secure.\n\n## Learn more\n\n*   [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens)\n*   [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens)\n*   [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Token Storage",
    "description": "Learn how and where to store tokens used in token-based authentication.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/use-access-tokens",
    "markdown": "# Use Access Tokens\n\nAccess tokens are used in token-based authentication to allow an application to access an API. For example, a Calendar application needs access to a Calendar API in the cloud so that it can read the user's scheduled events and create new events.\n\nOnce an application has received an access token, it will include that token as a credential when making API requests. To do so, it should transmit the access token to the API as a **Bearer** credential in an HTTP **Authorization** header.\n\nFor example:\n\n```\nGET /calendar/v1/events\n    Host​: api.example.com\n    \n    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUuYXV0aDAuY29tLyIsImF1ZCI6Imh0dHBzOi8vYXBpLmV4YW1wbGUuY29tL2NhbGFuZGFyL3YxLyIsInN1YiI6InVzcl8xMjMiLCJpYXQiOjE0NTg3ODU3OTYsImV4cCI6MTQ1ODg3MjE5Nn0.CA7eaHjIHz5NxeIJoFK9krqaeZrPLwmMmgI_XiQiIkQ\n```\n\nIn this example, the Access Token is a JWT that decodes to the following claims:\n\n```\n{\n      \"alg\": \"RS256\",\n      \"typ\": \"JWT\"\n    }\n    .\n    {\n      \"iss\": \"https://example.auth0.com/\",\n      \"aud\": \"https://api.example.com/calendar/v1/\",\n      \"sub\": \"usr_123\",\n      \"scope\": \"read write\",\n      \"iat\": 1458785796,\n      \"exp\": 1458872196\n    }\n```\n\nBefore permitting access to the API using this token, the API must [validate the access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\nOnce the Access Token has been successfully validated, the API can be sure that:\n\n*   The token was issued by Auth0.\n    \n*   The token was issued to an application being used by a user with an identifier of `usr_123`.\n    \n*   The user granted the application access to read from and write to their calendar.\n    \n\nThe API can now process the request, allowing the application to read from and write to user `usr_123`'s calendar.\n\n## Learn more\n\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Identity Provider Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/identity-provider-access-tokens)\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Use Access Tokens",
    "description": "Describes how to use Access Tokens to call APIs.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens",
    "markdown": "# Get Access Tokens\n\nTo access your API, you must request an [access token](https://auth0.com/docs/secure/tokens/access-tokens) when authenticating a user.\n\nTo request an access token, make a POST call to the [token URL](https://auth0.com/docs/api/authentication#client-credentials-flow).\n\n#### Example POST to token URL\n\n*   [cURL](#d73c598283194c6bb9214bd195de631d_shell)\n*   [C#](#d73c598283194c6bb9214bd195de631d_csharp)\n*   [Go](#d73c598283194c6bb9214bd195de631d_go)\n*   [Java](#d73c598283194c6bb9214bd195de631d_java)\n*   [Node.JS](#d73c598283194c6bb9214bd195de631d_node)\n*   [Obj-C](#d73c598283194c6bb9214bd195de631d_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data client_id=YOUR_CLIENT_ID \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: 'YOUR_CLIENT_ID',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id=YOUR_CLIENT_ID\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id=YOUR_CLIENT_ID\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"client\\_credentials\". |\n| `client_id` | Your application's Client ID. You can find this value on the [application's settings tab](https://manage.auth0.com/#/applications). |\n| `client_secret` | Your application's Client Secret. You can find this value on the [application's settings tab](https://manage.auth0.com/#/applications). To learn more about available application authentication methods, read [Application Credentials](https://auth0.com/docs/secure/application-credentials). |\n| `audience` | The audience for the token, which is your API. You can find this in the **Identifier** field on your [API's settings tab](https://manage.auth0.com/#/apis). |\n\n#### Response\n\nYou receive an `HTTP 200` response with a payload containing `access_token`, `token_type`, and `expires_in` values:\n\n```\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n## Control access token audience\n\nWhen a user authenticates, you request an access token and include the target audience and scope of access in your request. The application uses the `/authorize` endpoint to request access. This access is both requested by the application and granted by the user during authentication\n\nYou can configure your tenant to always include a default audience.\n\n| Token Use | Format | Requested Audience | Requested Scope |\n| --- | --- | --- | --- |\n| /userinfo endpoint | Opaque | tenant name (`{yourDomain}`), no value for `audience` parameter, no `audience` parameter passed | `openid` |\n| Auth0 Management API | JWT | Management API v2 identifier (`https://{tenant}.auth0.com/api/v2/`) |     |\n| Your own custom API | JWT | The API Identifier for your custom API registered in the Auth0 Dashboard |     |\n\nIn only one specific instance, access tokens can have multiple target audiences. This requires that your custom API's signing algorithm is set to **RS256**. To learn more, read [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices).\n\n### Multiple audiences\n\nIf you specify an audience of your custom API identifier and a scope of `openid`, then the resulting access token's `aud` claim will be an array rather than a string, and the access token will be valid for both your custom API and for the `/userinfo` endpoint. Your access tokens can have two or more audiences only if you use a single custom API as well as Auth0's `/userinfo` endpoint, y.\n\n### Custom domains and the Auth0 Management API\n\nAuth0 issues tokens with an issuer (`iss)` claim of whichever domain you used when requesting the token. [Custom domain](https://auth0.com/docs/customize/custom-domains) users can use either their custom domain or their Auth0 domain.\n\nFor example, suppose you have a custom domain, `https://login.northwind.com`. If you request an access token from `https://login.northwind.com/authorize`, your token's `iss` claim will be `https://login.northwind.com/`. However, if you request an access token from `https://northwind.auth0.com/authorize`, your token's `iss` claim will be `https://northwind.auth0.com/`.\n\nIf you request an access token from your custom domain with the target audience of the Auth0 Management API, then you **must** call the Auth0 Management API from your custom domain. Otherwise your access token is considered invalid.\n\n## Renew access tokens\n\nBy default, an access token for a custom API is valid for 86400 seconds (24 hours). You can [shorten the time period before the token expires](https://auth0.com/docs/secure/tokens/access-tokens/update-access-token-lifetime).\n\nAfter an access token has expired, you can renew your access token. To do so either re-authenticate the user using Auth0 or use a [](https://auth0.com/docs/tokens/concepts/refresh-tokens)[refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n## Learn more\n\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Use Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/use-access-tokens)\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens)\n*   [Identity Provider Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/identity-provider-access-tokens)\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)",
    "title": "Get Access Tokens",
    "description": "Learn how to request Access Tokens using the Authorize endpoint when authenticating users and include the target audience and scope of access requested by the app and granted by the user.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens",
    "markdown": "# Validate Access Tokens\n\nAn access token is meant for an API and should be validated only by the API for which it was intended.\n\nIf any of these checks fail, the token is considered invalid, and the request must be rejected with `401 Unauthorized` result.\n\n1.  **Perform standard JWT validation.** Because the access token is a JWT, you need to perform the standard JWT validation steps. See [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens) for details.\n    \n2.  **Verify token audience claims.** If you've performed the standard JWT validation, you have already decoded the JWT's payload and looked at its standard claims. The token audience claim (`aud`, array of strings) depends on the initial token request. The `aud` field could contain both an audience corresponding to your custom API and an audience corresponding to the `/userinfo` endpoint. At least one of the audience values for the token must match the unique identifier of the target API as defined in your [API's Settings](https://manage.auth0.com/#/apis) in the **Identifier** field. See [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens) for details.\n    \n3.  **Verify permissions (scopes).** Verify that the application has been granted the permissions required to access your API. To do so, you will need to check the `scope` claim (`scope`, space-separated list of strings) in the decoded JWT's payload. It should match the permissions required for the endpoint being accessed. For example, if your custom API provides three endpoints to read, create, or delete a user record, when you registered your API with Auth0, you created three corresponding permissions:\n    \n    1.  `create:users` provides access to the `/create` endpoint\n        \n    2.  `read:users` provides access to the `/read` endpoint\n        \n    3.  `delete:users` provides access to the `/delete` endpoint\n        \n    \n    In this case, if an application requests access the `/create` endpoint, but the access token's `scope` claim does not include the value `create:users`, then the API should reject the request.\n    \n\n## Learn more\n\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)\n*   [Use Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/use-access-tokens)\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Validate Access Tokens",
    "description": "Describes how to validate an access token.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/update-access-token-lifetime",
    "markdown": "# Update Access Token Lifetime\n\nYou can change the access token lifetime using the Auth0 Dashboard.\n\n## Configure access token lifetime\n\n1.  Go to [Dashboard > Applications > APIs](https://manage.auth0.com/#/apis) and select the name of the API to view.\n    \n    ![Dashboard Applications APIs List](https://images.ctfassets.net/cdy7uua7fh8z/3rhmhghYZDSi6YWHRA5yMQ/c71340259481b0b6787d5f3887cfda0f/dashboard-apis-list.png)\n2.  Locate the **Token Expiration** field under **Token Settings**.\n    \n    ![Dashboard - API - Token Settings - Expiration](https://images.ctfassets.net/cdy7uua7fh8z/2FFfqqmntXL9CnGrSxea9M/810e5542553168ffcd6081a10bc2db2f/image2.png)\n3.  Enter the desired lifetime (in seconds) for access tokens issued for this API.\n    \n    *   Default value is `86,400` seconds (24 hours).\n        \n    *   Maximum value is `2,592,000 seconds` (30 days).\n        \n4.  Select **Save Changes**.\n    \n\n## Token Expiration For Browser Flows\n\nThe **Token Expiration For Browser Flows** field refers to access tokens issued for the API through implicit and hybrid flows and does not cover all flows initiated from browsers.\n\nFor example, the PKCE flow (used in `auth0-js-spa` SDK) can be initiated from the browser, but it references the **Token Expiration** value, not the **Token Expiration For Browser Flows** value.\n\n## Restricted lifetime for MFA access tokens\n\nThe lifetime of access tokens with the `{yourAuth0Domain}/mfa` audience are restricted to `600` seconds (10 minutes) for security reasons and cannot be modified.\n\n## Learn more\n\n*   [Update ID Token Lifetime](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime)",
    "title": "Update Access Token Lifetime",
    "description": "Describes how to update the access token lifetime for an API using the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure",
    "markdown": "# JSON Web Token Structure\n\nAll Auth0-issued JWTs have [JSON Web Signatures (JWSs)](https://tools.ietf.org/html/rfc7515), meaning they are signed rather than encrypted. A JWS represents content secured with digital signatures or Message Authentication Codes (MACs) using JSON-based data structures.\n\nA well-formed JWT consists of three concatenated Base64url-encoded strings, separated by dots (`.`):\n\n*   **JOSE Header**: contains metadata about the type of token and the cryptographic algorithms used to secure its contents.\n    \n*   **JWS payload** (set of [claims](https://tools.ietf.org/html/rfc7519#section-4)): contains verifiable security statements, such as the identity of the user and the permissions they are allowed.\n    \n*   **JWS signature**: used to validate that the token is trustworthy and has not been tampered with. When you use a JWT, you **must** [check its signature](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens) before storing and using it.\n    \n\nA JWT typically looks like this:\n\n![JSON Web Token](https://images.ctfassets.net/cdy7uua7fh8z/7FI79jeM55zrNGd6QFdxnc/80a18597f06faf96da649f86560cbeab/encoded-jwt3.png)\n\nTo see for yourself what is inside a JWT, use the [JWT.io Debugger](http://jwt.io/). It allows you to quickly check that a JWT is well formed and to manually inspect the values of the various claims.\n\n![JWT Debugger](https://images.ctfassets.net/cdy7uua7fh8z/5U3Azt2AReuNzNuQqkRs5/9629ab9924a0212b74bee0b8fa88c295/legacy-app-auth-5.png)\n\nJSON object containing the parameters describing the cryptographic operations and parameters employed. The JOSE (JSON Object Signing and Encryption) Header is comprised of a set of Header Parameters that typically consist of a name/value pair: the hashing algorithm being used (e.g., HMAC SHA256 or RSA) and the type of the JWT.\n\n```\n{\n      \"alg\": \"HS256\",\n      \"typ\": \"JWT\"\n    }\n```\n\n## JWS payload\n\nThe payload contains statements about the entity (typically, the user) and additional entity attributes, which are called claims. In this example, our entity is a user.\n\n```\n{\n      \"sub\": \"1234567890\",\n      \"name\": \"John Doe\",\n      \"admin\": true\n    }\n```\n\nWhen working with JWT claims, you should be aware of the different claim types and naming rules.\n\n## JWS signature\n\nThe signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.\n\nTo create the signature, the Base64-encoded header and payload are taken, along with a secret, and signed with the algorithm specified in the header.\n\nFor example, if you are creating a signature for a token using the HMAC SHA256 algorithm, you would do the following:\n\n```\nHMACSHA256(\n      base64UrlEncode(header) + \".\" +\n      base64UrlEncode(payload),\n      secret)\n```\n\n## Learn more\n\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens)\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [JSON Web Key Set Properties](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties)\n*   [Locate JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets)\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)",
    "title": "JSON Web Token Structure",
    "description": "Describes how the JSON web tokens with JSON web signatures (JWSs) are structured.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens",
    "markdown": "# Management API Access Tokens\n\nTo call the [Auth0 Management API v2](https://auth0.com/docs/api/management/v2) endpoints, you need to authenticate with an access token called the Auth0 Management API token. These tokens are [JSON Web Tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens) which contain specific grant permissions known as [scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes).\n\n## Get Management API tokens\n\nThe first time you get a Management API token for testing is when you authorize a machine-to-machine application in the Dashboard. Depending on what you are using the Management API for, there are different ways to get Management API tokens:\n\n*   [Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing): You can get a test token [manually](https://manage.auth0.com/#/apis/management/explorer) by following the prompts on the Auth0 dashboard.\n    \n*   [Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production): Auth0 recommends that you get a short-lived token programmatically for production.\n    \n*   [Single page applications (SPAs)](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-tokens-for-single-page-applications): Because SPAs are public clients and cannot securely store sensitive information, they must retrieve Management API tokens from the frontend, unlike other application types. There are some limitations.\n    \n\n## Token lifetime\n\nA Management API token is valid for 24 hours. Create a new access token when the old one expires.\n\n## Token security\n\nWhen using the token for testing purposes, you can change the expiration time, however Auth0 recommends that you use short-lived tokens to minimize security risks. You cannot renew or revoke a Management API token.\n\n*   **Compromised token**: If a token has been compromised, you can delete the application grant to prevent new tokens from being issued using the Management API [`/delete_client_grants_by_id`](https://auth0.com/docs/api/management/v2#!/Client_Grants/delete_client_grants_by_id) endpoint or by manually [deauthorizing the API application](https://manage.auth0.com/#/apis/management/authorized-applications) in the Dashboard.\n    \n*   **Compromised client secret**: If your client secret has been compromised, you can rotate the client secret using the Management API [`/post_rotate_secret`](https://auth0.com/docs/api/management/v2#!/Clients/post_rotate_secret) endpoint or by clicking the **Rotate** icon in the [application's settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) in the Dashboard.\n    \n\n## Token quotas\n\nTokens issued for Auth0 APIs (Management API, Authentication API, MFA API, etc.) do **not** count toward the M2M token quota listed in the Dashboard. Only tokens with external audiences count toward your quota. See [Auth0 Management API Rate Limits](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits) for details.\n\nToken quota limits are broken down by subscription tier. See [Auth0 Pricing](https://auth0.com/pricing/) for details. You can access your current quota in the [Auth0 Support Center](https://support.auth0.com/reports/quota). If you have questions about pricing or quotas, please direct them to our [sales team](https://auth0.com/contact-us).\n\n## Learn more\n\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Get Management API Access Tokens for Single-Page Applications](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-tokens-for-single-page-applications)\n*   [Changes in Auth0 Management APIv2 Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/changes-in-auth0-management-apiv2-tokens)\n*   [Migrate to Management API Endpoints with Access Tokens](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-calling-api-with-access-tokens)",
    "title": "Management API Access Tokens",
    "description": "Learn how Auth0 Management APIv2 Access Tokens work and how to use them.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/identity-provider-access-tokens",
    "markdown": "# Identity Provider Access Tokens\n\nIdentity providers issue third-party access tokens after users authenticate with that provider. You can use these access tokens to call the API of the third-party provider that issued them. For example, you can use an access token issued after a user authenticates with Facebook to call the Facebook Graph API.\n\nFor individual users, the identity provider tokens are available in the `identities` array on the `user` object under the element for the particular connection. To securely access tokens for a specific user, you need an [access token for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) that includes the `read:user_idp_tokens` scope. Then, you can make an HTTP GET call to the [Get a User endpoint](https://auth0.com/docs/api/management/v2/#!/Users/get_users_by_id) to retrieve the tokens.\n\nFor admin users of Enterprise connections set up using an OAuth 2.0 consent flow, the identity provider tokens are available in the `connection` object. To securely access tokens for a connection, you need an [access token for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) that includes the `read:connections` scope. Then, you can make an HTTP GET call to the [Get a Connection endpoint](https://auth0.com/docs/api/management/v2/connections/get-connections-by-id) to retrieve the tokens.\n\n## Renew third-party tokens\n\nThere is no standard way to renew identity provider access tokens through Auth0. The mechanism for renewing identity provider access tokens varies for each provider. For certain identity providers, Auth0 can store a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens), which you can use to obtain a new access token for the identity provider. Here is a list of some of the identity providers:\n\n*   BitBucket\n    \n*   Google OAuth 2.0 (pass the parameter `access_type=offline`, as well the `connection_scope` parameter with required scopes, when calling the Auth0 `/authorize` endpoint)\n    \n*   Any other OAuth 2.0 identity provider\n    \n*   SharePoint\n    \n*   Azure AD\n    \n\nYou can retrieve refresh tokens in the same manner you retrieve access tokens. Review the guidelines above for more information.\n\n## Validate third-party tokens\n\nIn general, if you have received an access token from an identity provider, you don't need to validate it. You can pass it to the issuer, and the issuer takes care of the rest.\n\n## Learn more\n\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)",
    "title": "Identity Provider Access Tokens",
    "description": "Understand third-party access tokens issued by identity providers after user authentication and how to use them to call the third-party APIs.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/json-web-encryption",
    "markdown": "# JSON Web Encryption\n\nJSON Web Encryption (JWE) is an [IETF standard](https://datatracker.ietf.org/doc/html/rfc7516) for representing encrypted content using JSON. In Auth0, you can configure APIs to encrypt the details inside an access token using the JWE format. \n\nWhen JWE is used, Auth0 generates a JWT access token containing a set of claims that are signed using JSON Web Signature (JWS). This JWT access token is then encrypted using JWE and serialized using the JWE Compact format. This allows solutions to maintain the confidentiality of data within the access tokens' claims while also ensuring integrity protection using a signature.\n\n#### Generate and validate an access token\n\n[Configure JWE for each API](https://auth0.com/docs/get-started/apis/configure-json-web-encryption). Assuming you have configured the `apiIdentifier` to use JWE, the code sample requests an encrypted access token via the client credentials grant for a machine-to-machine (M2M) application. JWE is available for all grant types supported by Auth0.\n\n```\ncurl -X POST --location \"https://{domain}/oauth/token\" \\\n    -H \"Content-Type: application/x-www-form-urlencoded\" \\\n    -d \"client_id={clientId}&client_secret={clientSecret}&audience={apiIdentifier}&grant_type=client_credentials\"\n```\n\n A successful response contains an encrypted access token:\n\n```\n{\n  \"access_token\": \"eyJ…XAw\",\n  \"expires_in\": 86400,\n  \"token_type\": \"Bearer\"\n}\n```\n\nWhen the access token is used, the resource server must decrypt and validate the JWE token. The JWE token header contains metadata that describes the cryptographic algorithm ([`alg`](https://datatracker.ietf.org/doc/html/rfc7516#section-4.1.1)), the content encryption algorithm ([`enc`](https://datatracker.ietf.org/doc/html/rfc7516#section-4.1.2)), and, if provided when [configuring the API](https://auth0.com/docs/get-started/apis/configure-json-web-encryption), the key id (`kid`) that were used to encrypt the payload. \n\n```\n{\n  …\n  \"alg\": \"A256GCM\",\n  \"enc\": \"RSA-OAEP-256\",\n  \"kid\": \"my-kid\"\n}\n```\n\n \n\nUsing this information, the resource server should be able to decrypt the JWE token. The result is a regular signed JWT, which can be verified using the Auth0’s tenant keys.\n\nTo learn how to configure JWE for your API, read [Configure JSON Web Encryption](https://auth0.com/docs/get-started/apis/configure-json-web-encryption).\n\n## Learn more\n\n*   [Configure JSON Web Encryption (JWE)](https://auth0.com/docs/get-started/apis/configure-json-web-encryption)",
    "title": "JSON Web Encryption",
    "description": "Learn how to encrypt access tokens using JSON Web Encryption. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/token-binding",
    "markdown": "# Token Binding\n\nToken Binding, or sender constraining, enables the binding of access tokens to cryptographic keys, such as a private key. It enforces that only the application that requested the access token can use it to access the associated resource, thus mitigating token theft and replay attacks.\n\nHighly Regulated Identity provides token binding capabilities through [Mutual-TLS Client Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705), also known as mTLS Token Binding. To learn how to configure a client to support Token Binding, see [Enable Token Binding](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#enable-token-binding).\n\n## How access tokens are bound to a certificate\n\nAfter [configuring your application for mTLS](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#enable-token-binding), your application can use mutual TLS to request an access token. The authorization server binds the client certificate to the issued access token by including the confirmation claim (cnf) in the access token payload. The cnf contains a hash representing the thumbprint of the client certificate.\n\nThe following code sample represents the payload of a certificate-bound access token:\n\n```\n{\n  \"iss\": \"https://server.example.com\",\n  \"sub\": \"ty.webb@example.com\",\n  \"exp\": 1493726400,\n  \"nbf\": 1493722800,\n  \"cnf\":{\n    \"x5t#S256\": \"bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\"\n  }\n}\n```\n\n## Token verification\n\nWhen mTLS Token Binding is enabled, access and refresh tokens are constrained to the application that requested them (i.e. the “sender” application). The resource server is responsible for verifying that the client certificate sent in the request has the same thumbprint as the one included in the access/refresh token, otherwise known as proof-of-possession verification.\n\nTo verify that the application is authorized to use the certificate-bound access/refresh token, the resource server must generate the thumbprint of the client certificate used in the request and compare it to the thumbprint in the `cnf` claim. For more information on the format of the `cnf` claim and how to generate the thumbprint of a certificate, see RFC 8705’s section on the [JWT Certificate Thumbprint Confirmation Method](https://www.rfc-editor.org/rfc/rfc8705#name-jwt-certificate-thumbprint-).\n\nIf the application does not send the client certificate in the request, or the thumbprint of the client certificate does not match, the resource server must reject the request using an `HTTP 401` status code and an `invalid_token` error code.\n\nThe following table describes whether issued tokens are sender-constrained based on the mTLS configuration for the [application](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client) (OAuth client) and the [API](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-resource-server-for-token-binding) (OAuth resource server). The table covers the following scenarios:\n\n*   The type of audience that was requested: `userinfo` only or a custom audience that may include `userinfo`. \n    \n*   Whether sender constraining is `required` by the client.\n    \n*   Whether sender constraining is configured for the resource server:\n    \n    *   `none`: Sender constraining has not been configured for the resource server. \n        \n    *   `allowed`: Sender constraining has been configured for the resource server by setting mTLS as the sender-constraining method.\n        \n    *   `required`: Sender constraining is required for the resource server, meaning that access tokens must be sender-constrained to an application. Requires a sender-constraining method. \n        \n*   Whether the client application sent a Proof-of-Possession assertion in the token request.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3NRnK4mzW0hBosq9ovUdw1/71ea03b0ef903b97bac3f40db8630377/Screenshot_2024-05-28_at_11.56.40_AM.png)\n\n## Learn more\n\n*   [Configure mTLS Authentication](https://auth0.com/docs/get-started/applications/configure-mtls)",
    "title": "Token Binding",
    "description": "Learn how to use Token Binding to secure access tokens.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims",
    "markdown": "# JSON Web Token Claims\n\n[JSON web tokens (JWTs)](https://auth0.com/docs/tokens/concepts/jwts) claims are pieces of information asserted about a subject. For example, an [ID token](https://auth0.com/docs/secure/tokens/id-tokens) (which is always a JWT) can contain a claim called `name` that asserts that the name of the user authenticating is \"John Doe\". In a JWT, a claim appears as a name/value pair where the name is always a string and the value can be any JSON value. Generally, when we talk about a claim in the context of a JWT, we are referring to the name (or key). For example, the following JSON object contains three claims (`sub`, `name`, `admin`):\n\n```\n{\n      \"sub\": \"1234567890\",\n      \"name\": \"John Doe\",\n      \"admin\": true\n    }\n```\n\nThere are two types of JWT claims:\n\n*   **Registered**: standard claims registered with the [Internet Assigned Numbers Authority (IANA)](https://www.iana.org/assignments/jwt/jwt.xhtml) and defined by the [JWT specification](https://tools.ietf.org/html/rfc7519) to ensure interoperability with third-party, or external, applications. OIDC standard claims are reserved claims.\n    \n*   **Custom**:  consists of non-registered public or private claims. Public claims are collision-resistant while private claims are subject to possible collisions.\n    \n\n## Registered claims\n\nThe JWT specification defines seven reserved claims that are not required, but are recommended to allow interoperability with [third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications). These are:\n\n*   `iss` (issuer): Issuer of the JWT\n    \n*   `sub` (subject): Subject of the JWT (the user)\n    \n*   `aud` (audience): Recipient for which the JWT is intended\n    \n*   `exp` (expiration time): Time after which the JWT expires\n    \n*   `nbf` (not before time): Time before which the JWT must not be accepted for processing\n    \n*   `iat` (issued at time): Time at which the JWT was issued; can be used to determine age of the JWT\n    \n*   `jti` (JWT ID): Unique identifier; can be used to prevent the JWT from being replayed (allows a token to be used only once)\n    \n\nYou can see a full list of registered claims at the [IANA JSON Web Token Claims Registry](https://www.iana.org/assignments/jwt/jwt.xhtml#claims).\n\n## Custom claims\n\nYou can define your own custom claims which you control and you can add them to a token using Actions. Here are some examples:\n\n*   Add a user's email address to an access token and use that to uniquely identify the user.\n    \n*   Add custom information stored in an Auth0 user profile to an ID token.\n    \n\nAs long as the Action is in place, the custom claims it adds will appear in new tokens issued when using a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\nFor an example showing how to add custom claims to a token, see [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims).\n\n### Public claims\n\nYou can create custom claims for public consumption, which might contain generic information like name and email. If you create public claims, you must either register them or use collision-resistant names through namespacing and take reasonable precautions to make sure you are in control of the namespace you use.\n\nIn the [IANA JSON Web Token Claims Registry](https://www.iana.org/assignments/jwt/jwt.xhtml#claims), you can see some examples of public claims registered by OpenID Connect (OIDC):\n\n*   `auth_time`\n    \n*   `acr`\n    \n*   `nonce`\n    \n\n### Private claims\n\nYou can create private custom claims to share information specific to your application. For example, while a public claim might contain generic information like name and email, private claims would be more specific, such as employee ID and department name.\n\n## Auth0 restrictions\n\nAuth0 enforces the general restrictions on custom claims: \n\n*   custom claims payload is set to a maximum of 100KB\n    \n*   a subset of OIDC and other registered standard claims or claims used internally by Auth0 cannot be customized or modified\n    \n*   access tokens with an Auth0 API audience, excluding the `/userinfo` endpoint, cannot have private, non-namespaced custom claims \n    \n*   only specified OIDC user profile claims can be added to access tokens\n    \n\nTo learn more about custom claims, read [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n## Learn more\n\n*   [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens)\n*   [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure)\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [JSON Web Key Set Properties](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties)",
    "title": "JSON Web Token Claims",
    "description": "Describe JSON web token (JWT) claims and how they are used in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens",
    "markdown": "# Get Refresh Tokens\n\nTo get a refresh token, you must include the `offline_access` [scope](https://auth0.com/docs/get-started/apis/scopes) when you initiate an authentication request through the `/authorize` endpoint. Be sure to initiate Offline Access in your API. For more information, read [API Settings](https://auth0.com/docs/get-started/apis/api-settings).\n\nFor example, if you are using the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), the authentication request would look like the following:\n\n```\nhttps://{yourDomain}/authorize?\n    audience={API_AUDIENCE}&\n    scope=offline_access&\n    response_type=code&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    state={OPAQUE_VALUE}\n```\n\nThe refresh token is stored in session. Then, when a session needs to be refreshed (for example, a preconfigured timeframe has passed or the user tries to perform a sensitive operation), the app uses the refresh token on the backend to obtain a new ID token, using the `/oauth/token` endpoint with `grant_type=refresh_token`.\n\nOnce the user authenticates successfully, the application will be redirected to the `redirect_uri`, with a `code` as part of the URL: `{https://yourApp/callback}?code=BPPLN3Z4qCTvSNOy`. You can exchange this code with an access token using the `/oauth/token` endpoint.\n\n*   [cURL](#0034efa159e4401abb57f3cfd8aefa8a_shell)\n*   [C#](#0034efa159e4401abb57f3cfd8aefa8a_csharp)\n*   [Go](#0034efa159e4401abb57f3cfd8aefa8a_go)\n*   [Java](#0034efa159e4401abb57f3cfd8aefa8a_java)\n*   [Node.JS](#0034efa159e4401abb57f3cfd8aefa8a_node)\n*   [Obj-C](#0034efa159e4401abb57f3cfd8aefa8a_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'code={yourAuthorizationCode}' \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    code: '{yourAuthorizationCode}',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code={yourAuthorizationCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code={yourAuthorizationCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe response should contain an access token and a refresh token.\n\n```\n{\n      \"access_token\": \"eyJz93a...k4laUWw\",\n      \"refresh_token\": \"GEbRxBN...edjnXbL\",\n      \"token_type\": \"Bearer\"\n    }\n```\n\nIf you are requesting a Refresh Token for a mobile app using the corresponding Native Client (which is public), then you don't need to send the `client_secret` in the request since it's only required for confidential applications.\n\nRefresh Tokens must be stored securely by an application since they allow a user to remain authenticated essentially forever.\n\nFor more information on how to implement this using the Authorization Code Flow, refer to our tutorial, [Call API Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow). For other grants, see [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow).\n\n## Learn more\n\n*   [Use Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)",
    "title": "Get Refresh Tokens",
    "description": "Describes how to get a Refresh Token when you initiate a request using the Authorize endpoint.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens",
    "markdown": "# Use Refresh Tokens\n\nRefresh tokens are used to request a new access token and/or ID token for a user without requiring them to re-authenticate.\n\nTypically, you should request a new access token before the previous one expires (to avoid any service interruption), but not every time you call an API, as token exchanges are subject to our [Rate Limiting Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy).\n\nYou may also use a refresh token to request a new ID token for a user, and should do so if you need to refresh the claims within the ID token.\n\n## Call the API\n\nTo exchange the refresh token you received during authentication for a new access token, call the Auth0 Authentication API [Get token endpoint](https://auth0.com/docs/api/authentication#refresh-token) in the Authentication API.\n\nTo learn more about the authentication methods available for the Authentication API, read [Authentication Methods](https://auth0.com/docs/api/authentication#authentication-methods).\n\n### Use Basic authentication\n\n*   [cURL](#f967c9c28e964235a8b695985774dbb8_shell)\n*   [C#](#f967c9c28e964235a8b695985774dbb8_csharp)\n*   [Go](#f967c9c28e964235a8b695985774dbb8_go)\n*   [Java](#f967c9c28e964235a8b695985774dbb8_java)\n*   [Node.JS](#f967c9c28e964235a8b695985774dbb8_node)\n*   [Obj-C](#f967c9c28e964235a8b695985774dbb8_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'authorization: Basic {yourApplicationCredentials}' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=refresh_token \\\n  --data 'client_id={yourClientId}' \\\n  --data 'refresh_token={yourRefreshToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddHeader(\"authorization\", \"Basic {yourApplicationCredentials}\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Add(\"authorization\", \"Basic {yourApplicationCredentials}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .header(\"authorization\", \"Basic {yourApplicationCredentials}\")\n  .body(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {\n    'content-type': 'application/x-www-form-urlencoded',\n    authorization: 'Basic {yourApplicationCredentials}'\n  },\n  data: new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: '{yourClientId}',\n    refresh_token: '{yourRefreshToken}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\",\n                           @\"authorization\": @\"Basic {yourApplicationCredentials}\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=refresh_token\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&refresh_token={yourRefreshToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Basic {yourApplicationCredentials}\",\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nheaders = {\n    'content-type': \"application/x-www-form-urlencoded\",\n    'authorization': \"Basic {yourApplicationCredentials}\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest[\"authorization\"] = 'Basic {yourApplicationCredentials}'\nrequest.body = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/x-www-form-urlencoded\",\n  \"authorization\": \"Basic {yourApplicationCredentials}\"\n]\n\nlet postData = NSMutableData(data: \"grant_type=refresh_token\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&refresh_token={yourRefreshToken}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Use Post authentication\n\n*   [cURL](#2f90907e172e4805836ab4ada4b2ffa5_shell)\n*   [C#](#2f90907e172e4805836ab4ada4b2ffa5_csharp)\n*   [Go](#2f90907e172e4805836ab4ada4b2ffa5_go)\n*   [Java](#2f90907e172e4805836ab4ada4b2ffa5_java)\n*   [Node.JS](#2f90907e172e4805836ab4ada4b2ffa5_node)\n*   [Obj-C](#2f90907e172e4805836ab4ada4b2ffa5_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=refresh_token \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'refresh_token={yourRefreshToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    refresh_token: '{yourRefreshToken}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=refresh_token\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&refresh_token={yourRefreshToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=refresh_token\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&refresh_token={yourRefreshToken}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Parameter definition\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `grant_type` | Type of grant to execute. |\n| `client_id` | Application's client ID. |\n| `client_secret` | (Optional) Application's client secret. Only required for confidential applications using the Post token authentication method. |\n| `refresh_token` | Refresh token to exchange. |\n\nThe response will include a new access token, its type, its lifetime (in seconds), and the granted scopes. If the scope of the initial token included `openid`, then a new ID token will be in the response as well.\n\n```\n{\n      \"access_token\": \"eyJ...MoQ\",\n      \"expires_in\": 86400,\n      \"scope\": \"openid offline_access\",\n      \"id_token\": \"eyJ...0NE\",\n      \"token_type\": \"Bearer\"\n    }\n```\n\n## Bypass MFA\n\nIf [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) is enabled and refresh token functions fail, you can use the following workaround:\n\n```\nfunction (user, context, callback) {\n  if (context.protocol === 'oauth2-refresh-token'){\n    return callback(null, user, context);\n  }\n\n  // Add MFA logic\n\n  callback(null, user, context);\n}\n```\n\n## Learn more\n\n*   [Get Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)\n*   [Lock.Android: Refresh JSON Web Tokens](https://auth0.com/docs/libraries/lock-android/lock-android-refresh-jwt)",
    "title": "Use Refresh Tokens",
    "description": "Describes how to use a Refresh Token you received during authorization.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation",
    "markdown": "# Configure Refresh Token Rotation\n\nConfigure refresh token rotation for each application using the Dashboard or the [Auth0 SPA SDK](https://auth0.com/docs/libraries/auth0-single-page-app-sdk). When refresh token rotation is enabled, the transition for the user is seamless. The application uses the previous, unexpired non-rotating refresh token and swaps it for a rotating refresh token.\n\nMigration scenarios accommodate automatic token revocation when migrating from a non-rotating refresh token to a rotating refresh token and vice-versa.\n\n*   Exchanging a non-rotating refresh token when refresh token rotation is enabled deletes all the non-rotating tokens issued for the same `client_id`, resource server, and user and tenant.\n    \n*   Exchanging a rotating refresh token when refresh token rotation is disabled issues a non-rotating refresh token and revokes the rotating refresh token family issued for the same `client_id`, resource server, and user and tenant.\n    \n\n## Configure in the Dashboard\n\n1.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select the application you want to configure.\n    \n3.  Go to the **Settings** tab.\n    \n4.  Under **Refresh Token Rotation**, enable **Rotation**.\n    \n    ![Dashboard Applications Applications Settings Tab Refresh Token Rotation](https://images.ctfassets.net/cdy7uua7fh8z/Rk6i8MUVWZG34P7K6aurb/c1906bf4e4066a26965e012b61237af3/dashboard-applications-applications-settings-refresh-token-rotation.png)\n5.  Enter **Reuse Interval** (in seconds) for the refresh token to account for leeway time between request and response before triggering automatic reuse detection. This interval helps to avoid concurrency issues when exchanging the rotating refresh token multiple times within a given timeframe. During the leeway window the breach detection features don't apply and a new rotating refresh token is issued. Only the previous token can be reused; if the second-to-last one is exchanged, breach detection will be triggered.\n    \n6.  Click **Save Changes**.\n    \n\n## Configure with the Auth0 SPA SDK\n\nYou can use the Auth0 SPA SDK to enable refresh token rotation. You must enable offline access and request the offline access scope in the client SDK.\n\n1.  Install the latest version of the `auth0-spa-js` SDK: `npm install @auth0/auth0-spa-js`\n    \n2.  Enable the feature on the SDK by setting `useRefreshTokens: true` to start sending the `offline_access` scope.\n    \n    to configure this snippet with your account\n    \n    ```\n    const auth0 = await createAuth0Client({\n          domain: '{yourDomain}',\n          client_id: '{yourClientId}',\n          audience: '{yourApiIdentifier}',\n          useRefreshTokens: true\n        });\n    ```\n    \n3.  Configure the Refresh Token rotation settings. For example:\n    \n    ```\n    PATCH /api/v2/clients/{client_id}\n        {\n          \"refresh_token\": {\n            \"rotation_type\": \"rotating\",\n            \"expiration_type\": \"expiring\",\n            \"token_lifetime\": \"2592000\",\n            \"leeway\": 3\n          }\n        }\n    ```\n    \n    | **Attribute** | **Description** |\n    | --- | --- |\n    | `rotation_type` | Text string: \"rotating\" or \"non-rotating\" |\n    | `expiration_type` | Text string: \"expiring\" or \"non-expiring\" |\n    | `token_lifetime` | The default refresh token expiration period, when **Refresh Token Rotation** is enabled, is 30 days (2,592,000 seconds). You can configure up to 1 year (31,557,600 seconds). **The lifetime does not extend when tokens are rotated.** |\n    | `leeway` | Allow the same refresh token to be used within the time period to account for potential network concurrency issues that would otherwise invalidate the token should the client attempt to retry using the same refresh token. By default leeway is disabled. Configurable in seconds. |\n    \n\n## Automatic reuse detection\n\nIf a previously invalidated token is used, the entire set of refresh tokens issued since that invalidated token was issued will immediately be revoked along with the grant, requiring the user to re-authenticate.\n\n## Learn more\n\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Use Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-token-rotation)\n*   [Disable Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation)",
    "title": "Configure Refresh Token Rotation",
    "description": "Describes how to configure refresh token rotation.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration",
    "markdown": "# Configure Refresh Token Expiration\n\nRefresh tokens can be a target for abuse if leaked because they can be used to acquire new access tokens. To mitigate this risk, Auth0 recommends using Automatic Reuse Detection and Refresh Token Rotation. Refresh Token Rotation issues a refresh token that expires after a preset lifetime. After expiration, the user gets a new refresh token in the same family, or refresh tokens that share a family ID, or a new access token/refresh token pair. To learn more, read [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation).\n\nYou can enable and configure two refresh token lifetime settings, absolute and inactivity expiration, using either the Auth0 Dashboard or the Auth0 Management API. You can use a combination of absolute and inactivity expiration periods to create a balance between security and user experience that suits your business needs.\n\n*   **Absolute Lifetime**: Set a refresh token or refresh token family lifetime after which the user must re-authenticate before being issued a new access token. If you disable this setting, the absolute lifetime will be indefinite.\n    \n*   **Inactivity Lifetime**: Set the inactivity lifetime of issued refresh tokens to expire if the user is not active in your application during a specified period.\n    \n\n## Use the Dashboard\n\n1.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select the application you want to configure.\n    \n3.  Go to the **Settings** tab.\n    \n4.  Under **Refresh Token Expiration**, enable **Absolute Expiration**. When enabled, a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is enabled, an expiration lifetime must be set.\n    \n    ![Dashboard Applications Applications Settings Tab Refresh Token Expiration](https://images.ctfassets.net/cdy7uua7fh8z/2EnpIEc4kBxjnS3T67xPzC/22af4a1d7fbc26a9bfbd4785ff8cb1a3/dashboard-applications-applications-settings-refresh-token-expiration.png)\n5.  Enter **Absolute Lifetime** in seconds. The refresh token expires after the specified interval and can no longer be used to get a new access token. When rotation is enabled, the absolute expiration also applies to the ability to get new tokens.\n    \n    |     | **Value** |\n    | --- | --- |\n    | Default | 2,592,000 seconds (30 days) |\n    | Minimum | 1 second |\n    | Maximum | 31,557,600 seconds (1 year) |\n    \n6.  Enable **Inactivity Expiration**. When enabled, a refresh token will expire based on a specified inactivity lifetime, after which the token can no longer be used.\n    \n7.  Enter **Inactivity Lifetime** in seconds. If the refresh token is not exchanged within the specified interval, the refresh token expires and can no longer be used to get a new access token. The expiration period is renewed each time the refresh token is exchanged for a new access token within the interval.\n    \n    |     | **Value** |\n    | --- | --- |\n    | Minimum | 1 second |\n    | Maximum | 31,557,600 seconds (1 year) |\n    \n8.  Click **Save Changes**.\n    \n\n## Use the Management API\n\nYou can configure the absolute and inactivity lifetime settings in the payload for the Management API [/api/v2/clients/{id}](https://auth0.com/docs/api/management/v2#!/Clients/patch_clients_by_id) endpoint. Here is an example that sets expiration lifetime for a non-rotating refresh token:\n\n```\nPATCH /api/v2/clients/{id}\n{\n  \"refresh_token\": {\n      \"rotation_type\": \"non-rotating\",\n      \"expiration_type\": \"expiring\",\n      \"token_lifetime\": 2592000,\n      \"infinite_token_lifetime\": false,\n      \"idle_token_lifetime\": 604800,\n      \"infinite_idle_token_lifetime\": false\n  }\n}\n```\n\n## Support and limitations\n\n*   You can opt-in to use refresh token expiration capabilities; no action is required by you. Existing refresh tokens are not affected.\n    \n*   If need to go above the 1 year limitation (up to 5 years), Auth0 can increase the limit for you. Contact your Auth0 Technical Account Manager for details.\n    \n*   Refresh token expiration works with the following flows:\n    \n    *   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)\n        \n    *   [Authorization Code Flow with Proof Key for Code Exchange](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)\n        \n    *   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)[](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n        \n    *   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n        \n*   All Auth0 SDKs support refresh token expiration.\n    \n*   The refresh token expiration feature complies with the [OAuth 2.0 Security BCP recommendations](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-16.html#section-4.13.2).\n    \n\n## Learn more\n\n*   [Get Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens)\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)",
    "title": "Configure Refresh Token Expiration",
    "description": "Learn how to configure the refresh token expiration lifetimes.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-token-rotation",
    "markdown": "# Use Refresh Token Rotation\n\nTo use refresh token rotation, you will use the Auth0 Single Page App SDK. The Auth0 SPA SDK handles token storage, session management, and other details for you.\n\n## Prerequisite\n\n[Configure refresh token rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation) to enable offline access and request the offline access scope in the client SDK.\n\n## Enable useRefreshTokens\n\nIn compliance with the OAuth2 specifications, when a browser requests a refresh token from the /token endpoint, Auth0 will only return a refresh token if Refresh Token Rotation is enabled for that client.\n\nUse the option `useRefreshTokens` on `createAuth0Client` which defaults to `false`. With this option set to `false`, when `getTokenSilently()` is invoked and a new Access Token is required, the SDK attempts to acquire a new Access Token using a hidden iframe and `prompt=none`.\n\nIf you set to this option to `true`, the `offline_access` scope is automatically requested when using `loginWithRedirect(), loginWithPopup()` and `getTokenSilently()`. When `getTokenSilently()` is invoked and the Access Token has expired, the SDK attempts to renew the ID and Access Tokens by calling the `/token` endpoint using the `refresh_token` grant type along with the Refresh Token from the cache.\n\nSilent re-authentication is achieved by sending a `prompt=none` parameter upon the authentication request and using a hidden iframe, provided that there is an active user session on the authorization server. The SDK uses the iframe method if you have set `useRefreshTokens` to `true` but no Refresh Token is available in the cache. This helps users to silently migrate to using Refresh Tokens without making them log in again.\n\nIf the exchange fails because `useRefreshTokens` is `true` but there isn't a Refresh Token in the cache, then it falls back to the iframe method (which could also fail if third-party cookies are blocked).\n\n## Token storage\n\nWith SPAs, ID and Access Tokens are obtained from the authorization server and typically cached in memory. Token renewal (due to refreshing the browser, memory cache eviction budgets, or expiration) is handled by the SDK.\n\n## Example\n\nThe following example shows how to configure the SDK to use both local storage and refresh tokens:\n\n```\nconst auth0 = await createAuth0Client({\n    domain: '<your Auth0 domain>',\n    client_id: '<your Auth0 client ID>',\n    cacheLocation: 'localstorage',\n    useRefreshTokens: true\n    });\n    \n    // Logging-in will automatically request the offline_access scope\n    // and store the resulting refresh token\n    auth0.loginWithRedirect();\n    \n    // Silently refreshing the access token will use the /token endpoint\n    // with ‘refresh_token’ grant and the refresh token from the cache\n    await auth0.getTokenSilently();\n```\n\n## Learn more\n\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Disable Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Use Refresh Token Rotation",
    "description": "Describes how to use Refresh Token rotation for you received during authorization.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation",
    "markdown": "# Disable Refresh Token Rotation\n\nYou can disable refresh token rotation for each application using Dashboard or the Management API.\n\n## Disable with the Dashboard\n\n1.  Go to [Dashboard > Application Settings](https://manage.auth0.com/#/applications) and scroll to the **Application Tokens** section.\n    \n2.  Next to **Refresh Token Behavior** select **Non-Rotating**.\n    \n    ![Disable Refresh Token Rotation Screen](https://images.ctfassets.net/cdy7uua7fh8z/2XKvvu388Zp3SEmzB62ecZ/b1c9eebba8a1906bc3ba877d34420afb/non-rotating-tokens.png)\n3.  Click **Save Changes**.\n    \n\n## Disable with the Management API\n\n1.  Disable refresh token rotation for each application using the Management API:\n    \n    to configure this snippet with your account\n    \n    ```\n    const auth0 = await createAuth0Client({\n          domain: '{yourDomain}',\n          client_id: '{yourClientId}',\n          audience: '{yourApiIdentifier}',\n          useRefreshTokens: false\n        });\n    ```\n    \n2.  Configure the non-rotating refresh token settings as follows:\n    \n    ```\n    PATCH /api/v2/clients/{client_id}\n        {\n          \"refresh_token\": {\n        \"rotation_type\": \"non-rotating\",\n        \"expiration_type\": \"non-expiring\"\n          }\n        }\n    ```\n    \n\n## Learn more\n\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Use Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-token-rotation)",
    "title": "Disable Refresh Token Rotation",
    "description": "Describes how to disable Refresh Token rotation.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation",
    "markdown": "# Refresh Token Rotation\n\nRefresh token rotation is a technique for getting new access tokens using refresh tokens that goes beyond [silent authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication). Refresh tokens are typically longer-lived and can be used to request new access tokens after the shorter-lived access tokens expire. Refresh tokens are often used in native applications on mobile devices in conjunction with short-lived access tokens to provide seamless UX without having to issue long-lived access tokens.\n\nWith refresh token rotation enabled in the Auth0 Dashboard, every time an application exchanges a refresh token to get a new access token, a new refresh token is also returned. Therefore, you no longer have a long-lived refresh token that, if compromised, could provide illegitimate access to resources. As refresh tokens are continually exchanged and invalidated, the threat is reduced.\n\nThe way refresh token rotation works in Auth0 conforms with the [OAuth 2.0 BCP](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-4.12) and works with the following flows:\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)\n    \n*   [Authorization Code Flow with Proof Key for Code Exchange](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)\n    \n*   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)\n    \n*   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n    \n\n## Maintain user sessions in SPAs\n\nUntil very recently, SPAs maintained the user’s session by using the Authorization Code Flow with PKCE in conjunction with silent authentication. Recent developments in browser privacy technology, such as Intelligent Tracking Prevention (ITP) prevent access to the Auth0 session cookie, thereby requiring users to reauthenticate.\n\n![Refresh Token Rotation Maintain User Sessions in SPAs diagram](https://images.ctfassets.net/cdy7uua7fh8z/3sf7RRsy81bt3zcXMnHUSe/2171fdab4ffeb0987c329aa897038abc/rt-and-at.png)\n\nUnfortunately, long-lived refresh tokens are not suitable for SPAs because there is no persistent storage mechanism in a browser that can assure access by the intended application only. As there are vulnerabilities that can be exploited to obtain these high-value artifacts and grant malicious actors access to protected resources, using refresh tokens in SPAs has been strongly discouraged.\n\nRefresh token rotation offers a remediation to end-user sessions being lost due to side-effects of browser privacy mechanisms. Because refresh token rotation does not rely on access to the Auth0 session cookie, it is not affected by ITP or similar mechanisms.\n\nThe following state diagram illustrates how refresh token rotation is used in conjunction with the Authorization Code Flow with PKCE, but the general principle of getting a new refresh token with each exchange applies to all supported flows.\n\n![Refresh Token Rotation Maintain User Sessions in SPAs State diagram](https://images.ctfassets.net/cdy7uua7fh8z/41avsR2u0B4fSP3Bwh0WZz/d803a9057ea6e606d602c7c97d99fc3a/rtr-state-diagram.png)\n\nThis means you can safely use refresh tokens to mitigate the adverse effects of browser privacy tools and provide continuous access to end-users without disrupting the user experience.\n\n## Automatic reuse detection\n\nWhen a client needs a new access token, it sends the refresh token with the request to Auth0 to get a new token pair. As soon as the new pair is issued by Auth0, the refresh token used in the request is invalidated. This safeguards your app from replay attacks resulting from compromised tokens.\n\nWithout enforcing sender-constraint, it’s impossible for the authorization server to know which actor is legitimate or malicious in the event of a replay attack. So it’s important that the most recently issued refresh token is also immediately invalidated when a previously-used refresh token (already invalidated) is sent to the authorization server. This prevents any refresh tokens in the same token family (all refresh tokens descending from the original refresh token issued for the client) from being used to get new access tokens.\n\nFor example, consider the following scenario:\n\n![Refresh Token Rotation Reuse Detection state diagram](https://images.ctfassets.net/cdy7uua7fh8z/33fe73R81Cpm6eTmOWfAnm/e7d168edc27861507a121910b32f1ee2/reuse-detection1.png)\n\n1.  Legitimate Client has **refresh token 1**, and it is leaked to or stolen by Malicious Client.\n    \n2.  Legitimate Client uses **refresh token 1** to get a new refresh token/access token pair.\n    \n3.  Auth0 returns **refresh token 2/access token 2**.\n    \n4.  Malicious Client then attempts to use **refresh token 1** to get an access token. Auth0 recognizes that refresh token 1 is being reused, and immediately invalidates the refresh token family, including **refresh token 2**.\n    \n5.  Auth0 returns an access denied response to Malicious Client.\n    \n6.  **Access token 2** expires and Legitimate Client attempts to use **refresh token 2** to request a new token pair. Auth0 returns an access denied response to Legitimate Client.\n    \n7.  Re-authentication is required.\n    \n\nThis protection mechanism works regardless of whether the legitimate client or the malicious client is able to exchange **refresh token 1** for a new token pair before the other. As soon as reuse is detected, all subsequent requests will be denied until the user re-authenticates. When reuse is detected, Auth0 captures detected reuse [events](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes) (such as `ferrt` indicating a failed exchange) in logs. This can be especially useful in conjunction with Auth0’s [log streaming](https://auth0.com/docs/customize/log-streams) capabilities to detect suspicious activity.\n\nAnother example is where the malicious client steals **refresh token 1** and successfully uses it to acquire an access token before the legitimate client attempts to use **refresh token 1**. In this case, the malicious client’s access would be short-lived because **refresh token 2** (or any subsequently issued refresh tokens) is automatically revoked when the legitimate client tries to use **refresh token 1**, as shown in the following diagram:\n\n![Refresh Token Rotation Reuse Detection State diagram](https://images.ctfassets.net/cdy7uua7fh8z/36rAUgLOAqW7k7Fdl1eRN1/c1a57be5093416b50d42ec41a1e3a233/reuse-detection2.png)\n\n## SDK support\n\nThe following SDKs include support for refresh token rotation and automatic reuse detection.\n\n*   Auth0 SPA SDK\n    \n*   Flutter (Web)\n    \n*   Swift (iOS) SDK\n    \n*   Android SDK\n    \n*   Flutter\n    \n*   React Native SDK\n    \n*   WPF / Winforms\n    \n*   Xamarin\n    \n\nFor documentation specific to these SDKs, visit the [Auth0 SDK Libraries](https://auth0.com/docs/libraries) page.\n\nYou can choose to store tokens in either local storage or browser memory. The default is in browser memory. See [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices) for recommendations about token storage. You must enable offline access and request the offline access scope in the client SDK.\n\n## Learn more\n\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Disable Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Refresh Token Rotation",
    "description": "Describes how refresh token rotation provides greater security by issuing a new refresh token with each request made to Auth0 for a new access token by a client using refresh tokens.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens",
    "markdown": "# Revoke Refresh Tokens\n\nYou can revoke refresh tokens in case they become compromised. Auth0 handles token revocation as though the token has been potentially exposed to malicious adversaries.\n\nYou can also use [refresh token rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation) so that every time a client exchanges a refresh token to get a new access token, a new refresh token is also returned. Therefore, you no longer have a long-lived refresh token that, if compromised, could provide illegitimate access to resources. As refresh tokens are continually exchanged and invalidated, the threat is reduced.\n\nYou can revoke a refresh token in the following ways:\n\n*   In the Dashboard\n    \n*   Post a request to the Authentication API `/oauth/revoke` endpoint\n    \n*   Post a request to the Management API `/api/v2/device-credentials` endpoint\n    \n\n## Refresh tokens and grants\n\nA grant provides an application with access to a resource on another entity without exposing user credentials. Tokens are issued in the context of a grant, and when a grant is revoked, so are all tokens issued in the context of that grant. When, on the other hand, a token is revoked, this does not necessarily mean that the grant is revoked.\n\nYou can choose the revocation behavior in the Dashboard tenant settings when a device is unlinked from a user in Auth0, using either the Dashboard or the Management API.\n\n1.  Go to [Dashboard > Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced) and scroll to the **Settings** section.\n    \n2.  Enable or disable the **Refresh Token Revocation Deletes Grant** toggle depending on how you want the revocation to work.\n    \n    1.  Enable the toggle to delete the underlying grant when you revoke the refresh token. Each revocation request invalidates not only the specific token but all other tokens based on the same authorization grant. This means that all refresh tokens that have been issued for the same user, application, and audience will be revoked.\n        \n    2.  Disable the toggle to retain the underlying grant when you revoke the refresh token. When a device is unlinked, only the associated refresh token is revoked, leaving the grant intact.\n        \n\n## Use the Dashboard\n\nYou can use the Dashboard to revoke a user's authorized access to the application that issued the token. This renders the refresh token invalid, which is functionally identical to revoking the token itself.\n\n1.  Go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users), and click the name of the user to view.\n    \n2.  Select the **Authorized Applications** tab. This page lists all the applications to which the user has authorized access.\n    \n3.  To revoke the user's access to an authorized application, and hence invalidate the refresh token, click **Revoke**.\n    \n\n![Dashboard - Users - Revoke Refresh Token](https://images.ctfassets.net/cdy7uua7fh8z/76GtqCfeJFc3UPGc8MefeZ/299dfb54e07ae504253022bc2f048e56/dashboard-users-edit_view-authorized-applications.png)\n\n## Use the Authentication API\n\nTo revoke a refresh token, send a `POST` request to `https://{yourDomain}/oauth/revoke`.\n\nThe `/oauth/revoke` endpoint revokes the entire grant, not just a specific token. Use the `/api/v2/device-credentials` endpoint to revoke refresh tokens. The API first validates the application credentials and then verifies whether the token was issued to the application making the revocation request. If this validation fails, the request is refused, and the application is informed of the error. Next, the API invalidates the token. The invalidation takes place immediately, and the token cannot be used again after the revocation. Each revocation request invalidates all the tokens that have been issued for the same authorization grant.\n\n*   [cURL](#e5f1455a64d142d99b7212a09fe1c914_shell)\n*   [C#](#e5f1455a64d142d99b7212a09fe1c914_csharp)\n*   [Go](#e5f1455a64d142d99b7212a09fe1c914_go)\n*   [Java](#e5f1455a64d142d99b7212a09fe1c914_java)\n*   [Node.JS](#e5f1455a64d142d99b7212a09fe1c914_node)\n*   [Obj-C](#e5f1455a64d142d99b7212a09fe1c914_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/revoke' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"token\": \"{yourRefreshToken}\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/revoke\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/revoke\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/revoke\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/revoke',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    token: '{yourRefreshToken}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"token\": @\"{yourRefreshToken}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/revoke\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/revoke\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/revoke\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/revoke\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"token\": \"{yourRefreshToken}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/revoke\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nWhere:\n\n| Attribute | Description |\n| --- | --- |\n| `client_id`  <br>Required | Your application's Client ID. The application should match the one the Refresh Token was issued for. |\n| `client_secret` | Your application's Client Secret. Required for [confidential applications](https://auth0.com/docs/applications/concepts/app-types-confidential-public#confidential-applications). |\n| `token`  <br>Required | The Refresh Token you want to revoke. |\n\nThe application should match the one for which the refresh token was issued.\n\n### Revoke tokens without the client secret\n\nFor applications that cannot keep the client secret safe (such as native apps), the `/oauth/revoke` endpoint supports access without the client secret. However, the application itself must have the property `tokenEndpointAuthMethod` set to `none`. You can change the `tokenEndpointAuthMethod` value, either from the [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), or using the Management API.\n\nIf the request is valid, the refresh token is revoked, and the response is `HTTP 200`, with an empty response body. Otherwise, the response body contains the error code and description.\n\n```\n{\n      \"error\": \"invalid_request|invalid_client\",\n      \"error_description\": \"Description of the error\"\n    }\n```\n\nThe possible responses are:\n\n| HTTP Status | Description |\n| --- | --- |\n| 200 | The Refresh Token is revoked, does not exist, or was not issued to the application making the revocation request. The response body is empty. |\n| 400 | The required parameters were not sent in the request (`\"error\": \"invalid_request\"`). |\n| 401 | The request is not authorized (`\"error\": \"invalid_client\"`). Check that the application credentials (`client_id` and `client_secret`) are present in the request and hold valid values. |\n\n## Use the Management API\n\nTo revoke a refresh token using the Auth0 Management API, you need the `id` of the refresh token you wish to revoke. To obtain a list of existing refresh tokens, call the [](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials)[](https://auth0-docs-staging.herokuapp.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials)`/api/v2/device-credentials` [endpoint](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials), specifying `type=refresh_token` and `user_id` with an access token containing `read:device_credentials` scope. To narrow the results, you can also specify the `client_id` associated with the token (if known).\n\n```\nGET https://{yourDomain}/api/v2/device-credentials?\n      type=refresh_token\n      &client_id=\n      &user_id=\n    \n    {\n      \"Authorization\":   \"Bearer {your_access_token}\"\n    }\n```\n\nResponse body:\n\n```\n[\n      {\n    \"id\": \"dcr_dFJiaAxbEroQ5xxx\",\n    \"device_name\": \"my-device\" // the value of 'device' provided in the /authorize call when creating the token\n      }\n    ]\n```\n\nTo revoke a refresh token, call the `/api/v2/device-credentials` endpoint with an access token containing `delete:device_credentials` scope and the value of ID obtained above:\n\n```\nDELETE https://{yourDomain}/api/v2/device-credentials/{id}\n    \n    {\n      \"Authorization\":   \"Bearer {your_access_token}\"\n    }\n```\n\nThe response will be `HTTP 204: The credential no longer exists.`\n\n## Considerations and limitations\n\nWith the [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow), the only way to force a device to reauthorize is to revoke the refresh token assigned to the device. See [Unlink Devices from Users](https://auth0.com/docs/manage-users/user-accounts/unlink-devices-from-users) for details. The device will not be forced to reauthorize until the current access token expires and the application tries to use the revoked refresh token.\n\nWhen using [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation), if a previously invalidated token is used, the entire set of refresh tokens issued since that invalidated token was issued will immediately be revoked, requiring the end-user to re-authenticate.\n\n*   Use the Authentication API `/oauth/revoke` [endpoint](https://auth0.com/docs/api/authentication#revoke-refresh-token) to revoke a refresh token. This endpoint does not delete the underlying grant. You can change this behavior to also delete the underlying grant in the Dashboard: [Dashboard > Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced). Scroll to **Settings** and enable the **Refresh Token Revocation Deletes Grant** toggle.\n    \n*   Use the Management API `/api/v2/device-credentials` [endpoint](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials) to revoke refresh tokens configured for rotation.\n    \n\n## Learn more\n\n*   [Get Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens)\n*   [Use Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens)\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)",
    "title": "Revoke Refresh Tokens",
    "description": "Learn how to revoke a refresh token if it gets compromised using the Authentication API, the Management API, or the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa",
    "markdown": "# Enable Multi-Factor Authentication\n\nYou can enable multi-factor authentication (MFA) for your tenant in the Auth0 Dashboard.\n\nWhen you enable MFA, select the factors (such as push notifications or phone messages) you intend to make available to users and define a policy to determine when you require them to authenticate.\n\n## Select factors\n\nAuth0 supports a variety of factors you can enable for your users to complete authentication.\n\n### Independent factors\n\nYou must enable and configure at least one independent factor to require MFA for users on your tenant. You may enable multiple independent factors simultaneously as you’d like.\n\nAvailable independent factors are:\n\n*   [WebAuthn with FIDO Security Keys](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)\n    \n*   [One-time Password (OTP)](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n    \n*   [Push Notification using Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n    \n*   [Phone Message](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n    \n*   [Cisco Duo Security](https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa)\n    \n\n### Dependent factors\n\nYou may enable one or more dependent factors once you’ve already enabled and configured at least one independent factor for users on your tenant.\n\nAvailable dependent factors are:\n\n*   [WebAuthn with FIDO Biometrics](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)\n    \n*   [Email](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa)\n    \n*   [Recovery Code](https://auth0.com/docs/secure/multi-factor-authentication/configure-recovery-codes-for-mfa)\n    \n\n## Enable MFA in the Auth0 Dashboard\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa).\n    \n    ![Auth0 Dashboard Security Multi-Factor Authentication](https://images.ctfassets.net/cdy7uua7fh8z/4xrjmhY1cLhXhlygZKyN4f/3ec3b4cfc0d4e3ce178b519a0fb7df17/Dashboard_-_Security_-_MFA.png)\n2.  In the **Factors** section, enable and configure the factors you’d like to make available to users.\n    \n3.  In the **Define policies** section, select a policy to determine when users will be prompted for MFA.\n    \n    *   **Never**: MFA is not required for any logins.\n        \n    *   **Use Adaptive MFA**: MFA is required based on Auth0 risk determination. To learn more, read [Enable Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n        \n    *   **Always**: MFA is required for all logins.\n        \n4.  If you choose the **Never** or **Always** policy, the **MFA Risk Assessors** section appears. By default, the **Enable Adaptive MFA Risk Assessment** setting is disabled. Enable the toggle to assess and record risk for all login transactions in your tenant logs.\n    \n5.  In the **Additional Settings** section, configure the following options as needed:\n    \n    *   **Show Multi-factor Authentication options:** Enable this toggle to allow users to select authentication factors upon enrollment. When disabled, Auth0 automatically presents the most secure authentication factors to users upon enrollment.\n        \n        ![Show Multi-factor Authentication options end user view](https://images.ctfassets.net/cdy7uua7fh8z/3Mo3EXUk3ZFK4hZKck0yOO/c6d0faf48fca2017ef17dc36c99a8f7f/image-20230308-003813.png)\n    *   **Customize MFA Factors using Actions**: Enable this toggle to customize your MFA flows using `post-login` [Actions](https://auth0.com/docs/customize/actions). This allows you to challenge users with a specific factor or sequence of factors, as well as use contextual information to create more individualized experiences. To learn more, review [Customize MFA Selection for Universal Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login).\n        \n6.  Click **Save**.\n    \n\n## Customize MFA flow\n\nYou can use Auth0 Actions to customize the MFA flow for users on your tenant. For example, you can create an Action to require MFA in specific circumstances or to force a particular factor to be used.\n\nTo learn more, read [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-rules).\n\n## Learn more\n\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n*   [Configure OTP Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n*   [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n*   [Configure Email Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa)\n*   [Configure Cisco Duo Security for MFA](https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa)\n*   [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa)",
    "title": "Enable Multi-Factor Authentication",
    "description": "Learn how to enable multi-factor authentication (MFA) in the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/webauthn-as-mfa",
    "markdown": "# WebAuthn as Multi-Factor Authentication\n\nWhen users authenticate with WebAuthn, they use something **they have** as an authentication factor: a security key, or a device.\n\nBoth Security Keys and Device Biometrics support **user verification**, which requires users provide something **they know** (a PIN or a passcode) and something **they are** (like biometric traits).\n\nWhen using Device Biometrics, user verification is always performed. To perform verification with Security Keys, you [need to configure Auth0](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa) to require a PIN. Then users will be asked to enter a PIN, which is only stored in the security key, to complete authentication. Now when user verification is performed, users can login with WebAuthn as the only authentication method to achieve multi-factor authentication.\n\nBy using WebAuthn for authentication combined with user verification, you not only replace the password with something much simpler to use, you also remove the need of having another authentication step when requiring MFA.\n\n## Webauthn.me\n\nAuth0 maintains [webauthn.me](https://a0.to/webauthme-auth0-docs), which has [detailed information](https://webauthn.me/introduction) about WebAuthn and an up-to-date list of browsers supporting WebAuthn.",
    "title": "WebAuthn as Multi-Factor Authentication",
    "description": "Brief overview of how WebAuthn works as a factor for MFA",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa",
    "markdown": "# Configure Cisco Duo Security for MFA\n\nCisco Duo is a multi-faceted authentication provider and can only be used on your Auth0 tenant if all other factors are disabled. Your Duo account can support push notifications, SMS, OTP, phone callback, and more based on your configuration.\n\nYou cannot also enable Duo if other factors are enabled. Duo is only available to users when it is the sole factor enabled.\n\nThe application will prompt the user for the second factor with Duo, listing the options you have enabled in your Duo account.\n\n![Security Multi-Factor Authentication Cisco Duo Security Login screen example](https://images.ctfassets.net/cdy7uua7fh8z/t2OF0hjHWOPWk3GK5HrcP/d06ef1e506941e177a34e9a697eb9e4b/duo-login.png)\n\nYour users can download Duo from [Google Play](https://play.google.com/store/apps/details?id=com.duosecurity.duomobile) or the [App Store](https://itunes.apple.com/us/app/duo-mobile/id422663827?mt=8) for use as a second factor.\n\n## Configure Duo\n\nTo configure Duo Security, you must pass your Duo credentials to your application in the Auth0 Dashboard.\n\n1.  Go to [Dashboard > Security > Multi-factor Auth > Duo Security](https://manage.auth0.com/#/security/mfa/duo) and enable it.\n    \n2.  Enter the information in the fields to link your Duo account to Auth0.\n    \n    ![Dashboard - Security - Multifactor Auth - Duo Security](https://images.ctfassets.net/cdy7uua7fh8z/7k9AG9OfFJNCbaz4UoFXkq/cf5d3f9b9a052e15d17eb58cc1a26703/Duo_Security_-_Config_Screen__large_.png)\n3.  Select **Save**.\n    \n\n## Use Actions to enable Duo\n\nTo enable Duo within an Action, pass `duo` as the `provider` parameter when you enable multi-factor authentication.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  api.multifactor.enable('duo', { allowRememberBrowser: false });\n};\n```\n\nDuo does not provide an option for \"Remember Me\" behavior. The 30-day MFA session is hard-coded to remember the user after the initial login.\n\nTo force your users to log in with Duo every time, create a rule with `allowRememberBrowser: false`.\n\n## Actions template for Duo\n\nThis template provides an example and starting point to trigger multi-factor authentication with [Duo Security](http://duosecurity.com/) when a condition is met.\n\nUpon first login, the user can enroll the device.\n\nto configure this snippet with your account\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\n\tconst CLIENTS_WITH_MFA = ['{yourClientId}'];\n\t// run only for the specified clients\n\tif (CLIENTS_WITH_MFA.includes(event.client.client_id)) {\n\n\t\t// uncomment the following if clause in case you want to request a second factor only from user's that have user_metadata.use_mfa === true\n\t\t//if (event.user.user_metadata && event.user.user_metadata.use_mfa){\n\n\t\t// optional, defaults to true. Set to false to force DuoSecurity every time.\n\t\t// See https://auth0.com/docs/multifactor-authentication/custom#change-the-frequency-of-authentication-requests for details\n\t\tapi.multifactor.enable('duo', {\n\t\t\tproviderOptions.ikey: configuration.DUO_IKEY,\n\t\t\tproviderOptions.skey: configuration.DUO_SKEY,\n\t\t\tproviderOptions.host: configuration.DUO_HOST,\n\t\t\tallowRememberBrowser: false\n\t\t})\n\n\t\t// optional. Use some attribute of the profile as the username in DuoSecurity. This is also useful if you already have your users enrolled in Duo.\n\t\t// username: event.user.nickname\n\t};\n\t// }\n\n};\n```\n\n## Current limitations\n\n*   You cannot use [Auth0 MFA Enrollment Tickets](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets) to enroll users with Duo. Onboard those users from Duo itself.\n    \n*   If you use Universal Login, you must enable Duo in an Action with `provider` set to `duo` as described previously. You can conditionally use Duo or the built-in Auth0 provider for specific applications.\n    \n\n## Learn more\n\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
    "title": "Configure Cisco Duo Security for MFA",
    "description": "Describes how to configure Cisco Duo Security for MFA.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn",
    "markdown": "# FIDO Authentication with WebAuthn\n\nThe Web Authentication API (also known as WebAuthn) is a [specification](https://www.w3.org/TR/webauthn/) written by the W3C and FIDO, with the participation of Google, Mozilla, Microsoft, Yubico, and others. The API allows users to be authenticated using public key cryptography.\n\nWebAuthn is the most secure and usable authentication method on the web. Some key reasons for this are:\n\n*   It minimizes login friction. A simple and familiar gesture lets users authenticate.\n    \n*   It's the only web authentication method that is phishing resistant.\n    \n*   It's standard based and implemented across browsers and operating systems\n    \n\nWebAuthn let users authenticate with two types of authenticators:\n\n*   **Roaming authenticators** are removable and cross-platform, like a Yubikey, and can be used on multiple devices. To authenticate with a roaming authenticator, you need to connect it to the device (through USB, NFC, or Bluetooth), provide proof of presence (by touching it, for example), and optionally provide user verification, for example, by entering a PIN.\n    \n*   **Platform authenticators** are attached to a device and only work on that device. Some examples are MacBook’s TouchBar, Windows Hello, iOS Touch/FaceId, and Android’s fingerprint/face recognition. Biometric data is stored on the device and never sent to the server. When biometrics cannot be used, alternative authentication methods are usually provided. For example, if you are wearing a mask, instead of using Face ID you can enter your passcode.\n    \n\n## WebAuthn and Web Origins\n\nWebAuthn works by generating a private/public key pair for each [web origin](https://en.wikipedia.org/wiki/Same-origin_policy) which are registered in the device or security key.\n\nSince the key pair is bound to the domain, users are protected from phishing attacks. If the attacker tricks them into using WebAuthn in a different domain, the WebAuthn authenticator will not have a key pair for that domain and authentication will fail. The attacker will not get any data that can identify the user.\n\n## Roaming Authenticators\n\nTo learn how to enable roaming authenticators in Auth0, check the [WebAuthn with Security Keys](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa) documentation.\n\nThe default enrollment flow for security keys in Android displayed below and has the following steps:\n\n*   Users authenticate with username/password.\n    \n*   They are prompted to select the authentication method they want to enroll.\n    \n*   If they pick Security Keys, they are shown a list of instructions.\n    \n*   They are then prompted to enter their security key.\n    \n*   The device shows their native UI to complete the security key challenge.\n    \n*   Users can name the key to later identify it, in case they enroll multiple ones.\n    \n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/47W86ZLKHPc2GjhvBFSvlu/6de067c6c446fab92641d25032840205/security-key-enrollment.png)\n\nIn the challenge flow, the user is prompted for the security key and then it calls the native user interface for the device, which in this example is Android:\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/6cATwflHcqYECdI0J75AXi/1802a4b44aa394b2d7885ccfbaa299be/security-key-challenge.png)\n\n## Platform Authenticators\n\nTo learn how to enable platform authenticators, check the [Webauthn with Device Biometrics](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa) documentation.\n\nGiven platform authenticators can only be used in a single device, it **should not be the only factors that users enroll.** To make sure users are not locked out from their accounts, Auth0 will prompt users to enroll with platform authenticators after they succesfuly authenticated using another authentication method.\n\nAuth0 will try to **progressively enroll** all users' devices. Users will be prompted to enroll their devices' platform authenticators in each device they use.\n\nThe default enrollment flow for Face ID in iOS is displayed below and has the following steps:\n\n*   Users authenticate with username/password.\n    \n*   They enroll another MFA authentication method, like [SMS](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa), [Push](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa) or [Time-Based OTP](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa).\n    \n*   They name their device, to identify it later.\n    \n\n![Device Biometrics MFA Enrollment](https://images.ctfassets.net/cdy7uua7fh8z/1lGCq8BMA0rdkbiG3WZXWr/db44bb26054e6fadc540140f65bbc026/image.png)\n\nThe next time they login from that device, users enter their username/password and complete MFA with their device biometric authenticator.\n\n![WebAuthn Device Biometrics MFA Challenge](https://images.ctfassets.net/cdy7uua7fh8z/Y9gbCvOtQ3uEm7a0lPQwS/1244401ecd935586cf2433173e659751/image.png)\n\n## WebAuthn as Multi Factor Authentication\n\n## Webauthn.me\n\nAuth0 maintains [webauthn.me](https://a0.to/webauthme-auth0-docs), which has [detailed information](https://webauthn.me/introduction) about WebAuthn and an up-to-date list of browsers supporting WebAuthn.\n\n## Learn more\n\n*   [Configure WebAuthn with Device Biometrics for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)\n*   [Configure WebAuthn with Security Keys for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)",
    "title": "FIDO Authentication with WebAuthn",
    "description": "Describes Web Authentication API (WebAuthn) and FIDO-based authentication and how it works with Auth0 multi-factor authentication. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors",
    "markdown": "# Multi-Factor Authentication Factors\n\nAuth0 supports a number of different options or factors for protecting user account access with multi-factor authentication (MFA).\n\nTo select the MFA factors to use on your tenant, go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa). You must enable at least one factor on your tenant to use MFA. Available factors are dependent on your subscription plan. To learn more, read [Auth0 Pricing](https://auth0.com/pricing/).\n\n## Factors\n\nAuth0 supports the following factors for implementing MFA.\n\n### Push notifications\n\nSend users push notifications to their pre-registered devices, typically a mobile phone or tablet, from which a user can immediately allow or deny account access via the simple press of a button. Push factor is offered with the **Auth0 Guardian** mobile app, available for both iOS and Android. To learn more, read [Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian).\n\nIf you don’t want your customers to have to download a separate application, Auth0 also provides a **Guardian SDK** for building a second-factor workflow in your existing mobile device app. To learn more, read [Install Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/install-guardian-sdk). \n\n### SMS notifications\n\nSend users a one-time code over SMS which the user is then prompted to enter before they can finish authenticating. To learn more, read [Configure SMS and Voice Notifications for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n\n### Voice notifications\n\nDeliver a one-time code to users through voice call which the user is then prompted to enter before they can finish authenticating. To learn more, read [Configure SMS and Voice Notifications for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n\n### One-Time passwords\n\nOne-time passwords allow you to use an authenticator application on the user's personal device, such as Google Authenticator, to generate a one-time password that changes over time and which can be entered as the second factor to validate an account. To learn more, read [Configure OTP Notifications for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n\n### WebAuthn with security keys\n\nEnable users to perform MFA with FIDO compliant Security Keys (e.g. [Yubikey](https://www.yubico.com/), [Google Titan](https://cloud.google.com/titan-security-key)). To learn more, read [Configure WebAuthn with Security Keys for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)\n\n### WebAuthn with device biometrics\n\nEnable users to perform MFA using platform authenticators such as are MacBook’s TouchBar, Windows Hello, iOS Touch/FaceId, and Android’s fingerprint/face recognition. To learn more, read [Configure WebAuthn with Device Biometrics for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)\n\n### Email notifications\n\nEnable users to perform MFA using one-time passwords delivered through email when they don't have other authentication factors available. To learn more, read [Configure Email Notifications for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa)\n\n### Cisco Duo security\n\nCisco Duo is a multi-faceted provider and can only be used if it's the only factor available for the user. Use your Duo account to manage MFA with Auth0. To learn more, read [Configure Cisco Duo Security for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa)\n\n### Recovery codes\n\nRecovery codes are unique codes allowing users to regain account access if they cannot access the device or account used for MFA enrollment. To learn more, read [Configure Recovery Codes for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/configure-recovery-codes-for-mfa)\n\n## Policies\n\nPolicies determine when a user will be prompted to complete additional steps to prove they own a particular account. Use policies to define your own level of acceptable risk. You can choose between **Never**, **Use Adaptive MFA**, and **Always**.\n\nYou can achieve more refined multi-factor configurations (such as per application, per user, etc.) by using Auth0 Actions. To learn more, read [Auth0 Actions](https://auth0.com/docs/customize/actions).\n\nTo learn more, read [Defined Authentication Policies on OpenID.](http://openid.net/specs/openid-provider-authentication-policy-extension-1_0.html#rfc.section.4)\n\n## Use cases\n\nThere are different ways to manage MFA depending on your environment:\n\n*   B2B: Your customers manage MFA factors for their users.\n    \n*   B2C: End users manage their own MFA factors via an **My MFA Settings** page.\n    \n*   B2E: You manage MFA factors for your users.\n    \n\nTo learn about the API endpoints that you can use to build a user interface to manage MFA factors, see [Manage Authenticator Factors Using the MFA API.](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n\nApplications that allow access to different types of resources can require users to authenticate with a stronger authentication mechanism to access sensitive resources. See [Step-Up Authentication](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication) for details.\n\nTo create an Action go to [Dashboard > Actions > Flows](https://manage.auth0.com/#/actions/flows) and define conditions to trigger authentication challenges. Use Actions to force MFA for users of certain applications, or for users with particular user metadata or IP ranges, among other triggers.\n\nAdd contextual MFA which allows you to define arbitrary conditions that will trigger additional authentication challenges to your customers for increased security, for example, geographic location (geofencing), address or type of network used (IP filtering), time of day, day of the week or change in the location or device being used to log in.\n\n## Learn more\n\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n*   [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n*   [Configure OTP Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n*   [Configure Email Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa)\n*   [Configure Cisco Duo Security for MFA](https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa)\n*   [Configure WebAuthn with Security Keys for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)",
    "title": "Multi-Factor Authentication Factors",
    "description": "Describes multi-factor authentication (MFA) factors, policies, and use cases.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa",
    "markdown": "# Adaptive MFA\n\nAdaptive MFA is a flexible, extensible MFA policy that can help you protect your tenant from bad actors without increasing friction for real users. It assesses potential risk during every login transaction, and then prompts the user for additional verification if appropriate.\n\n## How it works\n\nDuring a login transaction, Adaptive MFA calculates an overall confidence score based on analysis of three risk assessments:\n\n| **Assessor** | **Risk Signal** | **How it is computed** |\n| --- | --- | --- |\n| `NewDevice` | User attempts to sign in from a device that has not been used to access the account in the last 30 days. | User agent and browser cookies identify a device. At login time, the device information is compared to the list of devices for the account. |\n| `ImpossibleTravel` | User attempts to sign in from a geolocation that indicates an impossible travel situation when compared to the last login. | The distance between the last valid location and the location of the attempted sign in is computed; the time difference between the sign in attempt is used to compute a hypothetical travel velocity. Velocity is compared to a reasonable travel velocity. |\n| `UntrustedIP` | User attempts to sign in from an IP address known to be associated with suspicious behavior. | Auth0 uses intelligence from traffic events to determine the likelihood that the IP address has been used by bad actors to perpetrate high velocity attacks. |\n| Overall Risk Score | A combination of all 3 factors above. | Auth0 uses all 3 scores to assign an overall score. Use [Actions](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa) if you want to implement your own business logic. |\n\nWhen Adaptive MFA determines the overall confidence score is low (that the login transaction is high-risk), it requires the user to verify their identity with MFA. If the user is not enrolled in MFA, they are required to complete additional verification before they are eligible to do so.\n\nAdaptive MFA includes a comprehensive security flow that ensures the authenticity of users:\n\n![Auth0 Login Adaptive multi-factor authentication flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/6NpeGW8jtQIma1jTVydW7U/731ec743802098372a2164300a15c402/adaptive-mfa-flow.png)\n\nAdaptive MFA ignores any and all existing MFA sessions (for example, a user selected **Remember this browser** during a previous MFA flow), and does not allow users to bypass MFA challenges.\n\n## Customize Adaptive MFA\n\nYou can use Actions to customize the MFA flow and provide the best experience for your users.\n\nTo learn more about risk assessments, confidence scores, and customization options, read [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa).\n\n## Support and limitations\n\nAdaptive MFA is supported by all authentication and authorization flows that start with the end user. To learn more about the different flows and protocols, read [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow) and [Protocols](https://auth0.com/docs/authenticate/protocols).\n\n| **Protocol** | **Flow** | **Supported** |\n| --- | --- | --- |\n| OIDC/OAuth2 | Authorization Code Flow | Supported |\n| OIDC/OAuth2 | Authorization Code Flow with PKCE | Supported |\n| OIDC/OAuth2 | Implicit Flow with Form Post | Supported |\n| OIDC/OAuth2 | Hybrid Flow | Supported |\n| OIDC/OAuth2 | Client Credentials | Not supported |\n| OIDC/OAuth2 | Device Authorization | Not supported |\n| OIDC/OAuth2 | Resource Owner Password (ROP) | Not supported |\n| SAML | Service Provider-Initiated (SP-initiated) | Supported |\n| SAML | Identity Provider-Initiated (IdP-initiated) | Not supported\\* |\n| WS-Federation | N/A | Supported |\n| AD/LDAP | N/A | Supported |\n\n\\*Adaptive MFA is not supported for SAML IdP\\-initiated flows, but you can simulate the flow with OIDC applications. To learn more, read [Configure IdP-Initiated SAML Sign-on to OIDC Apps](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-idp-initiated-saml-sign-on-to-oidc-apps).\n\nAdaptive MFA is fully supported for social connection types where an email address is available for each user.\n\nAdaptive MFA requires an email address to complete the email challenge step that occurs when a user is not enrolled in MFA. If an email address is not available, Adaptive MFA cannot perform the email challenge and the transaction will be blocked. This scenario does not introduce a security risk, but it does limit the functionality of the feature.\n\nIf you’ve set up a social connection, and expect an email address to be available but it’s not, verify your configuration and confirm that the correct scopes, claims, and permissions are being requested. To learn more about supported social connections and how to install them, read [Social Connections on Auth0 Marketplace](https://marketplace.auth0.com/features/social-connections).\n\n### Auth0 features\n\nThe following table lists Auth0 implementations and their functionality with Adaptive MFA:\n\n| **Login Flow Implementation** | **Adaptive MFA Support Level** |\n| --- | --- |\n| Universal Login | Supported |\n| Classic Login with no customization | Supported |\n| Classic Login (hosted by Auth0), custom login page with `lock.js` Lock template | Supported |\n| Classic Login (hosted by Auth0), custom login page with `auth0.js` Custom Login Form template | Supported |\n| Classic Login (hosted by Auth0), custom login page with email passwordless flow and `lock.js` Passwordless template | Supported |\n| Classic Login (hosted by Auth0), custom login page with SMS passwordless flow and `lock.js` Passwordless template | Not supported, because it does not make an email address available, which is a requirement. |\n| Web or native apps using Resource Owner Password Grant (ROPG) flow (including those using older versions of `lock.android` and `lock.swift` SDKs | Supported, with the following limitations:  <br>• Works when all end users are already enrolled in MFA (when users are required to enroll on signup). Users who are not already enrolled will be blocked in risky scenarios.  <br>• Risk assessment to determine if a user is logging in from a new device will not work. The ROPG flow does not support the browser cookies needed to determine risk.  <br>• You must pass `auth0-forwarded-for` header with information from the originating IP address for risk assessments for IP reputation to work. |\n| Native apps using newest version of SDKs that support embedded Universal Login | Supported |\n| Native apps using newest version of SDKs and ROPG flow | Supported with the following limitations:  <br>• Works when all end users are already enrolled in MFA (when users are required to enroll on signup). Users who are not already enrolled will be blocked in risky scenarios.  <br>• Risk assessment to determine if a user is logging in from a new device will not work. The ROPG flow does not support the browser cookies needed to determine risk.  <br>• You must pass `auth0-forwarded-for` header with information from the originating IP address for risk assessments for IP reputation to work. |\n| Flows hosted by you (not Auth0) using `lock.js` or `auth0.js` that perform cross-origin authentication (co/authenticate endpoint) | Supported |\n\n## Learn more\n\n*   [Enable Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/enable-adaptive-mfa)\n*   [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa)\n*   [Adaptive MFA Log Events](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events)",
    "title": "Adaptive MFA",
    "description": "Learn about Adaptive MFA, including how it works, how to customize it, and what flows are supported.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian",
    "markdown": "# Auth0 Guardian\n\nAuth0 Guardian is a mobile application for iOS and Android devices that allows users to complete [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) with push notifications or temporary one-time passwords.\n\nAuth Guardian can deliver push notifications to users’ enrolled devices (typically mobile phones or tablets) or generate one-time passwords directly within the app. Users can then quickly respond to these push notifications or retrieve a one-time password to complete their login.\n\nUsers can download the Auth0 Guardian app from the [Apple App Store](https://apps.apple.com/us/app/auth0-guardian/id1093447833) or the [Google Play Store](https://play.google.com/store/apps/details?id=com.auth0.guardian). Alternatively, you can embed Auth0 Guardian capabilities in your own custom app using the Guardian SDK.\n\n## Push Notifications\n\nIn order to use push notifications, users must have either the Auth0 Guardian app or a custom app built with the Guardian SDK installed on their device. When a user attempts to authenticate, push notifications are sent to the installed app. The user must respond to the notification to complete their login, proving they both know their login information and possess the device set up for MFA. \n\nAuth0 push notifications can be implemented using AWS Simple Notification Service (SNS) or one or more of the following direct-to-vendor services to configure vendor-specific integrations:\n\n*   Firebase Cloud Messaging (FCM)\n    \n*   Apple Push Notification (APN)\n    \n\n![Auth0 Guardian flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/TdN0nXfYs0mqHpi9U3JQ9/7bf919773ed8f94c7d5be25cc345eebd/diagram.png)\n\n### Enroll in push notifications\n\nWhen you use Auth0 Guardian to configure push notifications, users are prompted to download the mobile app when they first sign up or log in to your application. If you use the Guardian SDK to implement push notifications in a custom app, users are not prompted to download any applications during enrollment.\n\nYou can enable push notifications from the Auth0 Dashboard under [Security > Multi-factor Auth > Push Notification using Auth0 Guardian](https://manage.auth0.com/#/security/mfa/guardian).\n\n![Auth0 Dashboard > Security > Multi-factor Auth > Push Notification using Auth0 Guardian](https://images.ctfassets.net/cdy7uua7fh8z/fwjSKFNhsvObzdPDiA79N/65850980f88029cb23eef5eaef4f9b20/Auth0_Dashboard_-_Push_Notification_screen.png)\n\nWhen a user first signs up or logs in to your application, [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides a QR code they can use to register the Auth0 Guardian app or custom Guardian SDK app as a secondary authentication factor. The user has a short amount of time to scan this code with the designated app to complete their enrollment.\n\nAfter the user enrolls, they can use push notifications as an authentication factor. Whenever the user attempts to log in to your application, they will receive a push notification on their device via the Auth0 Guardian or custom Guardian SDK app. The user must approve this request to successfully log in to your application.\n\nTo learn how to reset MFA for users who have lost their devices or recovery codes, review [Reset Multi-Factor Authentication and Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa). For additional assistance, review [Troubleshooting Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues).\n\n## Temporary one-time passwords\n\nThe Auth0 Guardian app and the Guardian SDK also support the use of temporary one-time passwords (OTPs) as secondary authentication factors. Both the app and the SDK can generate temporary OTPs that users can use to complete Universal Login MFA challenges. \n\nBy default, the Auth0 Guardian app lists the user’s enrolled applications. After selecting an application, the corresponding OTP for that application displays. Each 6-digit OTP remains valid for 30 seconds. OTPs that are nearing expiration display in red. Upon expiration, the app immediately generates a new OTP. To avoid failed authentications, users should not use any red OTPs\n\nIn custom Guardian SDK apps, OTP appearance may vary.\n\n### Use temporary one-time passwords\n\nYou can leverage OTPs in two primary ways:\n\n*   As a fallback option to push notifications in the event that the Auth0 Guardian app or other custom app does not receive a push request.\n    \n*   As an [MFA challenge](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors) if you enable the One-Time Password factor [in your tenant](https://manage.auth0.com/#/security/mfa).\n    \n\n## Auth0 Guardian app settings\n\n### User security settings\n\nIn the Auth0 Guardian app, users can enable passcodes and biometrics as layers of app security on iOS and Android. If a user enables one or more of these options, they must complete these challenges before they can respond to push notifications or retrieve one-time passwords. \n\nTo enable these options on iOS or Android devices, users can follow the steps below.\n\nTo enable security settings for the Auth0 Guardian app on iOS: \n\n1.  In the app, select the **gear icon** to open the Settings menu. \n    \n2.  Select **Passcode** to enable passcode protection. \n    \n3.  Set and confirm a 6-digit passcode. \n    \n\nThe app is now protected by the passcode. The user must enter this passcode before they can respond to push notifications or retrieve OTPs.\n\n![The Settings menu from the Auth0 Guardian app on iOS devices](https://images.ctfassets.net/cdy7uua7fh8z/6l3sP6IjmSzJmED3Am8pna/82a5517b7639814b8a3d9bd4138a9d70/iOS_settings-small.png)\n\nAfter enabling passcode protection, the user can configure device biometrics as an alternate security measure. To enable device biometrics:\n\n1.  In the app, select the **gear icon** to open the Settings menu.\n    \n2.  Enable device biometrics by selecting one of the available options, such as **Face ID** or **Touch ID**. \n    \n\n### Localization options\n\nThe Auth0 Guardian app supports localization for multiple languages and dialects on iOS and Android.\n\nIn the Language section of the Settings menu, users can select their preferred language. By default, the app uses the same language as the device system.\n\nThe Auth0 Guardian app supports the following languages and dialects:\n\n| **Language** | **Code** |\n| --- | --- |\n| Basque | `eu-ES` |\n| Bosnian | `bs` |\n| Bulgarian | `bg` |\n| Catalan | `ca-ES` |\n| Croatian | `hr` |\n| Czech | `cs` |\n| Chinese (Simplified) | `zh-CN` |\n| Chinese (Traditional) | `zh-TW` |\n| Danish | `da` |\n| Dutch | `nl` |\n| English | `en` |\n| Estonian | `et` |\n| Finnish | `fi` |\n| French | `fr-FR` |\n| French (Canada) | `fr-CA` |\n| Galician | `gl-ES` |\n| German | `de` |\n| Greek | `el` |\n| Hindi | `hi` |\n| Hungarian | `hu` |\n| Indonesian | `id` |\n| Italian | `it` |\n| Icelandic | `is` |\n| Latvian | `lv` |\n| Lithuanian | `lt` |\n| Japanese | `ja` |\n| Korean | `ko` |\n| Norwegian | `no` |\n| Norwegian (Bokmål) | `nb` |\n| Norwegian (Nynorsk) | `nn` |\n| Polish | `pl` |\n| Portuguese (Brazil) | `pt-BR` |\n| Portuguese (Portugal) | `pt-PT` |\n| Romanian | `ro` |\n| Russian | `ru` |\n| Serbian | `sr` |\n| Slovak | `sk` |\n| Slovenian | `sl` |\n| Spanish | `es` |\n| Spanish (Argentina) | `es-AR` |\n| Swedish | `sv` |\n| Thai | `th` |\n| Turkish | `tr` |\n| Ukrainian | `uk` |\n| Vietnamese | `vi` |\n| Welsh | `cy` |\n\n### Guardian app themes\n\nThe Auth0 Guardian app for both iOS and Android supports light and dark mode themes.\n\nIn the Theme section of the Settings menu, users can select the following options:\n\n*   **System**: Uses default system theme\n    \n*   **Light**: Enables the light mode theme\n    \n*   **Dark**: Enables the dark mode theme\n    \n\n### Customization options for protected applications\n\nTo make it easier for users to distinguish between their protected applications in the Auth0 Guardian app, each application can be customized with a distinct name, accent color, and icon. \n\nTo customize a protected application:\n\n1.  Select an application from the list.\n    \n    *   **Tip**: You can also swipe left on the application to reveal Edit and Delete options. \n        \n2.  On the Account Detail page, choose **Edit**. \n    \n3.  Update the application’s name, color, and icon as needed.\n    \n4.  Select **Save**.\n    \n\n![The Account Edit screen of the Auth0 Guardian app displaying customization options](https://images.ctfassets.net/cdy7uua7fh8z/2dXh2M3Rp0oWoJdVFyvRCl/6e77dba1028f598019ba10b608cf8c67/Application_customization_options-small.png)\n\n## Guardian SDKs\n\nYou can [install the Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/install-guardian-sdk) (available for [iOS](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk) and [Android](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)) to build your own multi-factor authentication application with complete control over the branding and look-and-feel. With the Guardian SDK, you can build your own custom mobile applications that work like Guardian or integrate some Guardian functionalities, such as receiving push notifications in your existing mobile applications. A typical scenario could be for a banking app. You can use the Guardian SDK in your existing mobile app to receive and confirm push notifications when someone performs an ATM transaction.\n\n## Use Actions to enable Multi-Factor with Auth0 Guardian\n\nTo enable Auth0 Guardian within an Action, pass `guardian` as the `provider` parameter when you enable multi-factor authentication:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  api.multifactor.enable('guardian', { allowRememberBrowser: false });\n};\n```\n\nTo force your users to log in with Auth0 Guardian every time, create the Action with `allowRememberBrowser: false`.\n\nThis template provides an example and starting point to trigger multi-factor authentication with Auth0 Guardian for push notifications when a condition is met.\n\nUpon first login, the user can enroll the device. See [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa) for more information about MFA.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\nconst groups = event.user.app_metadata.authorization.groups;\nconst GROUPS_WITH_MFA = {\n// Add groups that need MFA here\n// Example\nadmins: true\n};\n\nconst needsMFA = !!groups.find(function (group) {\nreturn GROUPS_WITH_MFA[group];\n});\n\nif (needsMFA) {\n// optional, defaults to true. Set to false to force Guardian authentication every time.\n// See https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa#change-frequency-of-mfa-prompts for details\napi.multifactor.enable('guardian', { allowRememberBrowser: false });\n}\n\n};\n```\n\n## Learn more\n\n*   [Install Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/install-guardian-sdk)\n*   [Guardian.swift iOS SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk)\n*   [Guardian for Android SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n*   [Reset User Multi-Factor Authentication and Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa)\n*   [Guardian Error Code Reference](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/guardian-error-code-reference)",
    "title": "Auth0 Guardian",
    "description": "Describes how Guardian works and how the Guardian SDK helps you build your own authenticator and Guardian-like applications.",
    "languageCode": null
  }
]