[
  {
    "url": "https://turbo.build/pack/docs",
    "markdown": "# Getting startedTurborepoTurborepoTurborepoVercel\n\n## Getting started\n\nTurbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust by the creators of webpack and [Next.js](https://nextjs.org/) at [Vercel](https://vercel.com/).\n\nThe secret to Turbopack's performance is twofold: highly optimized machine code and a low-level incremental computation engine that enables caching down to the level of individual functions. Once Turbopack performs a task it never does it again.\n\nOur team has taken the lessons from 10 years of webpack, combined with the innovations in incremental computation from [Turborepo](https://turbo.build/repo) and Google's Bazel, and created an architecture ready to support the coming decades of computing.\n\nTurbopack is currently in **beta** in the Next.js development server. You can try out Turbopack today by adding the `--turbo` flag to your `next dev` command.\n\nTo report an issue, please use [the issue template in the Next.js repository](https://github.com/vercel/next.js/issues/new?assignees=&labels=template%3A+bug&projects=&template=1.bug_report.yml). We appreciate your feedback.\n\nNote: Production builds with `next build` are not yet supported.\n\nAs of today, Turbopack can be used in Next.js 14. In the future, we will be releasing a standalone CLI, plugin API, and support for other frameworks such as Svelte and Vue. For now, please follow these instructions to get started:\n\n### [New Projects](#new-projects)\n\n1.  Create a Next.js 14 project with Turbopack:\n\nTerminal\n\n2.  Start the Next.js development server (with Turbopack):\n\nThe Next.js 14 development server is now powered by Turbopack! Startup and updates should both be near-instant. The larger the application, the larger the improvement will be.\n\n### [Existing Projects](#existing-projects)\n\nAdd `--turbo` to your `next dev` command:\n\npackage.json\n\nWant to learn more about Turbopack? Here's a deep dive on what we think makes it special.",
    "title": "Getting started",
    "description": "Start building web applications with Turbopack.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/why-turbopack",
    "markdown": "# Why Turbopack?TurborepoTurborepoTurborepoVercel\n\nWhen we set out to create Turbopack, we wanted to solve a problem. We had been working on speed improvements for Next.js. We migrated away from several JS-based tools. Babel, gone. Terser, gone. Our next target was another JS-based tool, webpack.\n\nReplacing it became our goal. But with what?\n\nA new generation of native-speed bundlers were emerging, but after assessing the bundlers on the market, we decided to build our own. Why?\n\nA large reason why frameworks like Next.js have become so popular is that implementing features like SSR (and now RSC) with the current generation of bundlers is non-trivial. You need to create multiple compilers for each output environment (browser, server, etc), and manage the communication between them so that their bundles end up correctly stitched together.\n\nWe wanted to remove this maintenance burden from Next.js and any framework that chooses to use Turbopack. We can also create a cleaner and more stable implementation by designing a single unified graph that can be used to generate bundles for multiple environments.\n\nFrameworks like Vite use a technique where they don’t bundle application source code in development mode. Instead, they rely on the browser’s native ES Modules system. This approach results in incredibly responsive updates since they only have to transform a single file.\n\nWe experimented with this approach, but ran into scaling issues with large applications made up of many modules. A flood of cascading network requests in the browser lead to a relatively slow startup time. For the browser, it’s faster if it can receive the code it needs in as few network requests as possible - even on a local server.\n\nThat’s why we decided that, like webpack, we wanted Turbopack to bundle the code in the development server. Turbopack can do it much faster, especially for larger applications, because it is written in Rust and skips optimization work that is only necessary for production.\n\nThere are two ways to make a process faster: do less work or do work in parallel. We knew if we wanted to make the fastest bundler possible, we’d need to pull hard on both levers.\n\nWe decided to create a reusable Turbo build engine, similar to Parcel's request manager and rustc's query system, for distributed and incremental behavior. The Turbo engine works like a scheduler for function calls, allowing calls to functions to be parallelized across all available cores.\n\nThe Turbo engine also caches the result of all the functions it schedules, meaning it never needs to do the same work twice. Put simply, **it does the minimum work at maximum speed**.\n\nEarly versions of Next.js tried to bundle the _entire_ web app in development mode. We quickly realized that this ‘eager’ approach was less than optimal. Modern versions of Next.js bundle only the pages requested by the dev server. For instance, if you go to `localhost:3000`, it’ll bundle only `pages/index.jsx`, and the modules it imports.\n\nThis more ‘lazy’ approach (only bundling assets when absolutely necessary) is key for a fast dev server. Native ESM handles this without much magic - you request a module, which requests other modules. However, we wanted to build a bundler, for the reasons explained above.\n\nesbuild doesn’t have a concept of ‘lazy’ bundling - it’s all-or-nothing, unless you specifically target only certain entry points.\n\nTurbopack’s development mode builds a minimal graph of your app’s imports and exports based on received requests and only bundles the minimal code necessary. Learn more in the [core concepts docs](https://turbo.build/pack/docs/core-concepts#compiling-by-request).\n\nWe wanted to:\n\n*   Support a unified graph. This allows frameworks to use a single compiler that can target multiple environments.\n*   Build a bundler. Bundlers outperform Native ESM when working on large applications.\n*   Use incremental computation. The Turbo engine brings this into the core of Turbopack’s architecture - maximizing speed and minimizing work done.\n*   Optimize our dev server’s startup time. For that, we build a lazy asset graph to compute only the assets requested.\n\nThat’s why we chose to build Turbopack.",
    "title": "Why Turbopack?",
    "description": "Learn why we think Turbopack is the future of bundling for the web.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/core-concepts",
    "markdown": "# Core ConceptsTurborepoTurborepoTurborepoVercel\n\n## Core Concepts\n\nLet’s dive deep into the internals of Turbopack to figure out why it’s so fast.\n\nTurbopack is so fast because it’s built on a reusable library for Rust which enables incremental computation known as the Turbo engine. Here’s how it works:\n\n### [Function-level caching](#function-level-caching)\n\nIn a Turbo engine-powered program, you can mark certain functions as ‘to be remembered’. When these functions are called, the Turbo engine will remember **what they were called with**, and **what they returned**. It’ll then save it in an in-memory cache.\n\nHere’s a simplified example of what this might look like in a bundler:\n\n![](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fturbo-engine-first-run.56899855.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nWe start with calling `readFile` on two files, `api.ts` and `sdk.ts`. We then `bundle` those files, `concat` them together, and end up with the `fullBundle` at the end. The results of all of those function calls get saved in the cache for later.\n\nLet’s imagine that we’re running on a dev server. You save the `sdk.ts` file on your machine. Turbopack receives the file system event, and knows it needs to recompute `readFile(\"sdk.ts\")`:\n\n![](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fturbo-engine-second-run.f9aacfd9.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nSince the result of `sdk.ts` has changed, we need to `bundle` it again, which then needs to be concatenated again.\n\nCrucially, `api.ts` hasn’t changed. We read its result from the cache and pass that to `concat` instead. So we save time by not reading it and re-bundling it again.\n\nNow imagine this in a real bundler, with thousands of files to read and transformations to execute. The mental model is the same. You can save enormous amounts of work by remembering the result of function calls and not re-doing work that’s been done before.\n\n### [The cache](#the-cache)\n\nThe Turbo engine currently stores its cache in memory. This means the cache will last as long as the process running it - which works well for a dev server. When you run `next dev --turbo` in Next.js 13+, you’ll start a cache with the Turbo engine. When you cancel your dev server, the cache gets cleared.\n\nIn the future, we’re planning to persist this cache - either to the filesystem, or to a remote cache like Turborepo’s. This will mean that Turbopack could remember work done _across runs and machines._\n\n### [How does it help?](#how-does-it-help)\n\nThis approach makes Turbopack extremely fast at computing incremental updates to your apps. This optimizes Turbopack for handling updates in development, meaning your dev server will always respond snappily to changes.\n\nIn the future, a persistent cache will open the door to much faster production builds. By remembering work done _across runs_, new production builds could only rebuild changed files - potentially leading to enormous time savings.",
    "title": "Core Concepts",
    "description": "Learn about the innovative architecture that powers Turbopack's speed improvements.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/roadmap",
    "markdown": "# RoadmapTurborepoTurborepoTurborepoVercel\n\n## Roadmap\n\nWe've got big plans for Turbopack. Here's what we're aiming for in the future:\n\nRight now, Turbopack is being used as an opt-in feature in Next.js's dev server. This is helping to create an extremely fast experience in local development that scales to big projects.\n\nNext, we want to use Turbopack to power production builds with Next.js. We think that this will result in a big boost in performance, especially when integrated with remote caching.\n\nWe're planning to build a first-class integration with Svelte to let Turbopack power the next generation of SvelteKit applications.\n\nWe are in active discussions with other frameworks to bring Turbopack to their users. We're excited to see what we can build together!\n\nTurbopack is built from the ground up to take advantage of caching. Currently, this cache is stored in-memory only. This lets us optimize for our current use case - making the Next.js dev server fast.\n\nIn the future, we plan to persist this cache to the file system, to speed up Turbopack between runs. This will work similarly to [Turborepo's cache](https://turbo.build/repo/docs/core-concepts/remote-caching) - but at a much more granular level. Turborepo can currently only cache the results of entire builds. Turbopack, however, can cache the results of individual functions within those builds - saving much more time over subsequent runs.\n\nOnce persisting to the file system is working, we can build the next logical step: persisting to a remote cache. With Turborepo, we've already built [remote caching](https://turbo.build/repo/docs/core-concepts/remote-caching) on Vercel. In the future, you'll be able to _share_ Turbopack's hyper-granular cache across your whole team, using the Vercel Remote Cache.\n\nTo learn more about our future plans for webpack integration, check out our [Migrating from webpack](https://turbo.build/pack/docs/migrating-from-webpack) page.\n\nIn the future, Turborepo and Turbopack will merge into a single toolchain--Turbo--that can be used as either a bundler or a build system or both.",
    "title": "Roadmap",
    "description": "Learn more about Turbopack's roadmap.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/features/javascript",
    "markdown": "# JavaScriptTurborepoTurborepoTurborepoVercel\n\n## JavaScript\n\nTurbopack uses [SWC](https://swc.rs/) to bundle JavaScript and TypeScript files. So, we match SWC's support for ECMAScript versions - anything that SWC supports, Turbopack will support.\n\nThis means that by default **we support all syntax in ESNext**.\n\n[Browserslist](https://github.com/browserslist/browserslist) has become an industry standard for defining which browsers you plan to target. To make use of it, you can add a `browserslist` field to your `package.json`:\n\npackage.json\n\nTurbopack supports Browserslist **out-of-the-box**. We pass the information we find in your `package.json` to SWC, which handles [`browserslist` support](https://swc.rs/docs/configuration/supported-browsers) for us.\n\nThis means you can feel comfortable using Turbopack to target legacy browsers, or deciding to only ship code to modern browsers.\n\nTurbopack is available in beta preview with a dev server, which uses a pre-set minimal browserslist to minimize transformation during development. In a future release, Turbopack will build apps for production targeting your defined browserslist.\n\n[Babel](https://babel.dev/) allows you to add custom transformations to your code to provide custom syntax, including support for early language proposals.\n\nBabel plugins are currently **not supported** on Turbopack. In our default configuration, we don't use Babel to compile JavaScript or TypeScript code.\n\nIn the future, Babel support will be provided via plugins.",
    "title": "JavaScript",
    "description": "Learn more about JavaScript in Turbopack.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/features",
    "markdown": "# FeaturesTurborepoTurborepoTurborepoVercel\n\n## Features\n\nThe practice of building web applications is enormously diverse. In CSS alone, you have SCSS, Less, CSS Modules, PostCSS, and hundreds of other libraries. Frameworks like React, Vue and Svelte require custom setups.\n\nWhen building a bundler, we needed to consider which features would be:\n\n*   **Built-in**: they work out of the box, no config required\n*   **Available via plugins**: usually installed from a registry and configured\n*   **Unavailable**: not available at all\n\n**Turbopack is in beta**, so very few of these decisions are set in stone. In its current state, **Turbopack cannot yet be configured** - so plugins are not available yet.\n\nLet's discuss which features are available out-of-the-box, in Turbopack's default configuration. We'll also touch on features which will be configurable via plugins.\n\n[\n\n### JavaScript\n\nAll ESNext features, Browserslist and top-level await.\n\n](https://turbo.build/pack/docs/features/javascript)[\n\n### TypeScript\n\nTypeScript out of the box, including resolving paths and baseUrl.\n\n](https://turbo.build/pack/docs/features/typescript)[\n\n### Imports\n\nrequire, import, dynamic imports, and more.\n\n](https://turbo.build/pack/docs/features/imports)[\n\n### Dev server\n\nHot Module Reloading (HMR) and Fast Refresh.\n\n](https://turbo.build/pack/docs/features/dev-server)[\n\n### CSS\n\nGlobal CSS, CSS Modules, postcss-nested, and @import.\n\n](https://turbo.build/pack/docs/features/css)[\n\n### Frameworks\n\nNext.js, Svelte, Vue, and React Server Components\n\n](https://turbo.build/pack/docs/features/frameworks)[\n\n### Static assets\n\n/public directory, JSON imports, and importing assets via ESM.\n\n](https://turbo.build/pack/docs/features/static-assets)",
    "title": "Features",
    "description": "Learn about Turbopack's supported features",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/features/frameworks",
    "markdown": "# FrameworksTurborepoTurborepoTurborepoVercel\n\n## Frameworks\n\nTurbopack plans to offer first-class support for multiple frameworks. No matter whether you're using Svelte, React, Vue.js, or another framework, we want to provide a great experience on Turbopack.\n\n### [JSX/TSX](#jsxtsx)\n\n`.jsx` and `.tsx` files are supported out of the box with Turbopack. We use [SWC](https://swc.rs/) to compile your JavaScript and TypeScript code, which results in extremely fast compilation.\n\nSimilar to Next.js, Turbopack doesn't require you to import React in order to use JSX:\n\nsrc/index.tsx\n\n### [React Server Components](#react-server-components)\n\nReact Server Components let you declare certain components as 'server' components, allowing you to run backend code inside an `async` function. Next.js 13+ brings [first-class support for them](https://beta.nextjs.org/docs/rendering/server-and-client-components).\n\nReact Server Components impose unusual constraints on your bundler. The mix of client and server code means you need to ensure that server code does not get compiled to the client, and vice versa.\n\nTurbopack has been built from the ground up to solve these problems - it works with React Server Components out of the box.\n\nTo begin with, Turbopack is focused on providing a great experience for the Next.js dev server. We're using this as our initial goal to show what Turbopack can do. In the future, we want Turbopack to act as a low-level engine for other frameworks.\n\n[Vue.jJS](https://vuejs.org/) and [Svelte](https://svelte.dev/) are tremendously popular frameworks which deliver a world-class developer experience.\n\nSince Turbopack is in beta, we're focusing our support on Next.js's dev server. That means that right now, Vue and Svelte don't work out of the box.\n\nIn future versions, we'll be supporting Vue and Svelte via plugins.",
    "title": "Frameworks",
    "description": "Learn more about frameworks in Turbopack.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/features/typescript",
    "markdown": "# TypeScriptTurborepoTurborepoTurborepoVercel\n\n## TypeScript\n\nTurbopack supports [TypeScript](https://www.typescriptlang.org/) out of the box. This means you can import `.ts` files with Turbopack. We support all of TypeScript's feature set.\n\nThanks to our JSX support, you can also import `.tsx` files too.\n\nIn TypeScript, you can use the [`paths`](https://www.typescriptlang.org/tsconfig#paths) property of `tsconfig.json` to let you import files from custom paths.\n\ntsconfig.json\n\nThis would let you import directly from `app/*` without needing to do a relative import:\n\nsrc/app/some/deep/file/in/your/app.ts\n\nTurbopack reads the `paths` and `baseUrl` in `tsconfig.json` in order to resolve these paths, just like `Next.js` does.\n\nThis means you only need to configure your absolute paths in one place.\n\nTurbopack does not perform type checks on your application. We use [SWC](https://swc.rs/) to compile TypeScript code, which also does not perform type checks.\n\nThis means that in order to run your type checks, you'll need a sidecar process running `tsc --watch`. Or, you can rely on your IDE's TypeScript integration.",
    "title": "TypeScript",
    "description": "Learn more about TypeScript in Turbopack.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/features/dev-server",
    "markdown": "# Dev ServerTurborepoTurborepoTurborepoVercel\n\n## Dev Server\n\nTurbopack is optimized to give you an extremely fast development server. We considered these features indispensable.\n\nHot Module Replacement (HMR) gives your dev server the ability to push file updates to the browser without triggering a full refresh. This works for most static assets (including JavaScript files) enabling a smooth and fast developer experience.\n\nTurbopack supports Hot Module Replacement out of the box. Because of our [incremental architecture](https://turbo.build/pack/docs/core-concepts), we are hyper-optimized for delivering fast updates.\n\nFast Refresh builds on top of HMR by providing a framework-level integration to preserve _state_ across updates. Changes to a `<Count />` component, for instance, would preserve the component's internal `count` across changes.\n\nTurbopack supports Fast Refresh out of the box for React. Support for other frameworks will be [added over time](https://turbo.build/pack/docs/features/frameworks).",
    "title": "Dev Server",
    "description": "Learn more about the Turbopack Dev Server.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/features/css",
    "markdown": "# CSSTurborepoTurborepoTurborepoVercel\n\n## CSS\n\nCSS parsing and transformation is handled by [Lightning CSS](https://lightningcss.dev/).\n\nImporting CSS into global scope is built-in in Turbopack.\n\nmy-file.tsx\n\nTurbopack handles CSS Modules. Any file with a `.module.css` extension will be considered a CSS module, and you can import it into a JavaScript or TypeScript file:\n\ncomponent.tsx\n\nThis follows the same rules set out by [Next.js](https://nextjs.org/docs/basic-features/built-in-css-support#adding-component-level-css) - letting you easily distinguish between global and scoped CSS.\n\nTurbopack handles [CSS Nesting](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting/Using_CSS_nesting) syntax. This is [officially part of the CSS specification](https://www.w3.org/TR/css-nesting-1/) and lets you nest CSS declarations inside each other:\n\nphone.css\n\nUsing the CSS `@import` syntax to import other CSS files is supported. This gives you the ability to combine several CSS files together into a single module:\n\nglobals.css\n\n## [PostCSS](#postcss)\n\nPostCSS gives you the ability to use plugins to enhance your CSS toolchain. It's been an invaluable tool for integrating libraries like Tailwind and `autoprefixer` into applications.\n\nThe most common pattern is adding a `postcss.config.js` file to the root of your application, where you can import and configure your plugins.\n\nWhen Turbopack finds a `postcss.config.js` file, it will automatically process your CSS files with PostCSS in a Node.js worker pool.\n\npostcss.config.js\n\n`.scss` and `.sass` files let you utilize the [Sass](https://sass-lang.com/) language.\n\nSass is currently supported when using Next.js with Turbopack.\n\nThis is likely to be available via plugins/loaders in the future when using Turbopack directly.\n\n`.less` files let you utilize the [Less](https://lesscss.org/) language.\n\nThis is likely to be available via plugins/loaders in the future.\n\nTailwind CSS can be used via PostCSS plugins. You can use the [official Tailwind Next.js guide](https://tailwindcss.com/docs/guides/nextjs) to get started.",
    "title": "CSS",
    "description": "Learn more about CSS in Turbopack.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/features/imports",
    "markdown": "# ImportsTurborepoTurborepoTurborepoVercel\n\n## Imports\n\nTurbopack supports CJS and ESM imports out of the box, and offers partial support for AMD.\n\nTurbopack bundles your application, so imports won't be resolved to native browser ESM. You can learn why in our [bundling vs Native ESM](https://turbo.build/pack/docs/why-turbopack#bundling-vs-native-esm) section.\n\n## [CommonJS](#commonjs)\n\nTurbopack supports the `require` syntax out-of-the-box:\n\nmy-file.ts\n\n```\nconst { add } = require('./math');\n \nadd(1, 2);\n```\n\n## [ESM](#esm)\n\nImporting via the `import` syntax is also supported out-of-the-box. This includes static assets, and `import type`:\n\nmy-file.ts\n\n```\nimport img from './img.png';\n \nimport type { User } from '../server/types';\n \nimport { z } from 'zod';\n```\n\n## [Dynamic Imports](#dynamic-imports)\n\nTurbopack supports dynamic imports via `import()`:\n\nmy-file.ts\n\n```\nconst getFeatureFlags = () => {\n  return import('/featureFlags').then((mod) => {\n    return mod.featureFlags;\n  });\n};\n```",
    "title": "Imports",
    "description": "Learn more about imports in Turbopack.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/benchmarks",
    "markdown": "# BenchmarksTurborepoTurborepoTurborepoVercel\n\nCheck back soon for benchmark results against real-world Next.js Applications when `next dev --turbo` becomes stable.",
    "title": "Benchmarks",
    "description": "Learn more about benchmarks for Turbopack.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/migrating-from-webpack",
    "markdown": "# Migrating from webpack to TurbopackTurborepoTurborepoTurborepoVercel\n\n## Migrating from webpack to Turbopack\n\nWe're planning Turbopack as the successor to webpack. In the future, we plan to give Turbopack all the tools needed to support your webpack app.\n\nFor apps running Next.js 13.2 or later, Turbopack supports configuration familiar to webpack users, including support for webpack loaders and customizing resolution rules. Visit the [webpack loaders page in the Next.js docs](https://nextjs.org/docs/app/api-reference/next-config-js/turbo#webpack-loaders) for how to configure Turbopack with these options.\n\nNote that using webpack-based Next.js plugins as-is from `next.config.js` is **not yet supported**.\n\n### [Will it be compatible with webpack's API?](#will-it-be-compatible-with-webpacks-api)\n\nwebpack has a huge API. It's extremely flexible and extensible, which is a big reason why it's so popular.\n\nWe're planning on making Turbopack very flexible and extensible, but we're **not planning 1:1 compatibility with webpack**. This lets us make choices which improve on webpack's API, and lets us optimize for speed and efficiency.\n\n### [Will we be able to use webpack plugins?](#will-we-be-able-to-use-webpack-plugins)\n\nwebpack plugins are a crucial part of webpack's ecosystem. They let you customize your toolchain, giving you low-level tools to maximize your productivity.\n\nUnlike loaders, webpack plugins can be tightly integrated with webpack's internals.\n\nSince we're not offering 1:1 API compatibility for plugins, most won't work out of the box with Turbopack. However, we're working on porting several of the most popular webpack plugins to Turbopack.",
    "title": "Migrating from webpack to Turbopack",
    "description": "Learn about how to migrate from webpack to its Rust-powered successor, Turbopack.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/features/static-assets",
    "markdown": "# Static AssetsTurborepoTurborepoTurborepoVercel\n\n## Static Assets\n\nPart of bundling for the web is handling all the asset types the web supports - images, JSON, and much more. Turbopack offers familiar tools for these so you can immediately get productive.\n\nImporting static assets works out of the box with Turbopack:\n\nmy-file.ts\n\n### [Next.js](#nextjs)\n\nIn webpack and some other frameworks, importing an image returns a string containing that image's URL.\n\nmy-file.ts\n\nIn Next.js, importing an image returns an object, containing various metadata about the image. This is so it can be fed into [Next.js's Image component](https://nextjs.org/docs/basic-features/image-optimization#local-images).\n\nMost frameworks allow you to import JSON directly into your application:\n\nmy-file.ts\n\nThis is supported out of the box with Turbopack, as is performing a named import on that JSON:\n\nmy-file.ts",
    "title": "Static Assets",
    "description": "Learn more about static assets in Turbopack.",
    "languageCode": "en"
  },
  {
    "url": "https://turbo.build/pack/docs/advanced/profiling",
    "markdown": "# ProfilingTurborepoTurborepoTurborepoVercel\n\nAdvanced\n\n## Profiling\n\n### [Install](#install-cargo-instruments) [`cargo-instruments`](https://github.com/cmyr/cargo-instruments)\n\nTerminal\n\nMake sure you have all the [prerequisites](https://github.com/cmyr/cargo-instruments#pre-requisites) for running cargo-instruments.\n\n### [Run the profiler](#run-the-profiler)\n\nBy default, `turbopack-cli dev` will keep watching for changes to your application and never exit until you manually interrupt it. However, [`cargo-instruments`](https://github.com/cmyr/cargo-instruments) waits for your program to exit before building and opening the trace file. For this purpose, we've added a `profile` feature to `turbopack-cli` which exits the program if no updates are detected within a given time frame and there are no pending tasks.\n\nTo profile `turbopack-cli`, run the following command:\n\nTerminal\n\nYou can also run [other templates](https://github.com/cmyr/cargo-instruments#templates) than the time profiler.\n\nOnce the program exits, the profiler will open the trace file in Instruments. Refer to the [learning resources](https://github.com/cmyr/cargo-instruments#resources) to learn how to use Instruments.\n\n![](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Fpack%2Finstruments-light.png&w=2048&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\n![](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Fpack%2Finstruments-dark.png&w=2048&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nAn example trace from the time profiler.\n\n### [Memory usage](#memory-usage)\n\nTerminal\n\nWe currently don't have a guide for profiling Turbopack on other platforms.",
    "title": "Profiling",
    "description": "Learn how to profile Turbopack",
    "languageCode": "en"
  }
]