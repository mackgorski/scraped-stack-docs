[
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel",
    "markdown": "# ZModel Language | ZenStack\n\nThe first thing that ZenStack may surprise you is that, unlike other Prisma tools, we created a new schema language called _ZModel_. It's a superset of the Prisma Schema Language (PSL) with syntax elements to support additional features. The `zenstack` CLI takes a ZModel file as input and generates a Prisma Schema file out of it - which in turn can be fed to the standard `prisma` CLI for generating a Prisma Client or migrating the database.\n\nWhy did we invent a new schema language?\n\n### Why ZModel?[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#why-zmodel \"Direct link to Why ZModel?\")\n\n#### Custom Attributes[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#custom-attributes \"Direct link to Custom Attributes\")\n\nWhile Prisma Schema Language provides a terse and intuitive way to define data models, it has a major extensibility limitation: you can't add custom attributes. Prisma provides a set of pre-defined attributes to control detailed aspects of your tables and fields, but you're stuck when you need custom ones for your special modeling purposes. Traditionally, Prisma community tools have been hacking around this limitation by smuggling custom information in code comments, like the following example with [TypeGraphQL Prisma](https://prisma.typegraphql.com/):\n\n```\nmodel User {    id Int @default(autoincrement()) @id    email String @unique    /// @TypeGraphQL.omit(output: true, input: true)    password String}\n```\n\nIt works, but it's ugly and gets no protection from the compiler. The model can become messy if it's littered with such hacks everywhere. One of the biggest reasons for introducing the ZModel language is to systematically remove this obstacle so that we have a solid foundation for adding custom semantics into the schema down the road.\n\nHere's a quick example of the custom `@password` and `@omit` attributes ZModel added for automatically hashing passwords upon saving and omitting them from query results:\n\n```\nmodel User {    id Int @default(autoincrement()) @id    email String @unique    password String @omit @password}\n```\n\nThe access policies and data validation rules are also implemented with custom attributes. Don't worry. We'll cover them in detail in the following chapters.\n\n#### Other Language Features[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#other-language-features \"Direct link to Other Language Features\")\n\nA custom schema language also allows us to add new language features besides custom attributes. For example:\n\n1.  The `import` syntax for breaking down a large schema into multiple files\n2.  The `extends` syntax for inheriting fields from a base model\n\nHere's an example of how to use them to manage large schemas more effectively:\n\nbase.zmodel\n\n```\nabstract model Base {    id Int @id @default(autoincrement())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt()    published Boolean @default(true)    // author has full access    @@allow('all', auth() != null && published)}\n```\n\nschema.zmodel\n\n```\nimport \"base\"model User extends Base {    name String}model Post extends Base {    title String    content String?    viewCount Int @default(0)    comment Comment[]}model Comment extends Base {    content String    post Post @relation(fields: [postId], references: [id])    postId Int}\n```\n\n#### A Better Plugin System[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#a-better-plugin-system \"Direct link to A Better Plugin System\")\n\nPrisma allows you to write custom generators. However, the generator development API is undocumented and difficult to understand. ZenStack provides a plugin system that enables you to generate custom artifacts with a simple API and object model. In fact, almost all the features of ZenStack itself are implemented as plugins. [Part II](https://zenstack.dev/docs/1.x/the-complete-guide/part2) of this guide is dedicated to covering the plugin system.\n\n### ZModel Structure[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#zmodel-structure \"Direct link to ZModel Structure\")\n\nThe ZModel language is a superset of Prisma Schema Language (PSL). All Prisma schema syntaxes are valid in ZModel. A ZModel can contain the following declarations.\n\n#### Imports[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#imports \"Direct link to Imports\")\n\nThe `import` syntax is an extension to PSL. You can use it to break down a large schema into multiple files.\n\nschema.zmodel\n\n```\nimport \"user\"import \"post\"\n```\n\nuser.zmodel\n\n```\nmodel User {    id Int @id @default(autoincrement())    email String @unique    posts Post[]}\n```\n\npost.zmodel\n\n```\nmodel Post {    id Int @id @default(autoincrement())    title String    author User @relation(fields: [authorId], references: [id])    authorId Int}\n```\n\nWhen the `zenstack` CLI compiles an input schema, it merges the content of all imported files into a single schema before further processing.\n\n#### Data Source[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#data-source \"Direct link to Data Source\")\n\nThe `datasource` declaration of ZModel is exactly the same as PSL. ZenStack passes it to the generated Prisma schema without modification.\n\n```\ndatasource db {    provider = \"postgresql\"    url      = env(\"DATABASE_URL\")}\n```\n\n#### Prisma Generators[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#prisma-generators \"Direct link to Prisma Generators\")\n\nThe `generator` declarations of ZModel are exactly the same as PSL. ZenStack passes it to the generated Prisma schema without modification.\n\n```\ngenerator client {    provider = \"prisma-client-js\"}\n```\n\n#### Plugins[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#plugins \"Direct link to Plugins\")\n\nPlugins are the new extensibility mechanism provided by ZModel. Its syntax is similar to generators but with the `plugin` declaration keyword. Here's an example for generating tRPC CRUD routers:\n\n```\nplugin trpc {    provider = \"@zenstackhq/trpc\"    output   = \"src/generated\"}\n```\n\n[Part II](https://zenstack.dev/docs/1.x/the-complete-guide/part2) of this guide will cover the plugin system in detail.\n\n#### Models[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#models \"Direct link to Models\")\n\nThe `model` declaration of ZModel is exactly the same as PSL, except for the new set of attributes ZenStack added.\n\n```\nmodel User {    id Int @id @default(autoincrement())    // during create and update, ZenStack validates the field is a valid email address    email String @unique @email    // the field is automatically hashed upon saving, and omitted from query results    password String @omit @password    // access policy: open to sign up    @@allow('create', true)    // access policy: the user has full access to self    @@allow('all', auth() == this)}\n```\n\n### IDE Support[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#ide-support \"Direct link to IDE Support\")\n\nZenStack comes with a [VSCode extension](https://marketplace.visualstudio.com/items?itemName=zenstack.zenstack) and a [JetBrains IDE plugin](https://plugins.jetbrains.com/plugin/23397-zenstack-language-tools). You can find more information about IDE support [here](https://zenstack.dev/docs/1.x/guides/ide).\n\n### Full Documentation[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/zmodel#full-documentation \"Direct link to Full Documentation\")\n\nCheck out the [ZModel Language](https://zenstack.dev/docs/1.x/reference/zmodel-language) reference documentation for a complete language description.",
    "title": "ZModel Language | ZenStack",
    "description": "The first thing that ZenStack may surprise you is that, unlike other Prisma tools, we created a new schema language called ZModel. It's a superset of the Prisma Schema Language (PSL) with syntax elements to support additional features. The zenstack CLI takes a ZModel file as input and generates a Prisma Schema file out of it - which in turn can be fed to the standard prisma CLI for generating a Prisma Client or migrating the database.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/conclusion",
    "markdown": "# Conclusion | ZenStack\n\nIn this part of the guide, we've focused on the core layer of ZenStack - an enhanced Prisma Client. The enhanced Prisma Client essentially turns the ORM into a fully secured data access layer, enabling the upper layer features like the automatic CRUD APIs and the generation of frontend data query libraries.\n\nThe design choice of enhancing Prisma Client makes ZenStack framework-agnostic. It can be used wherever Prisma is used - a CLI application, a Node.js backend, or a full-stack application - as a non-intrusive drop-in replacement.\n\nAs you have seen, the ZModel language provides great flexibility in modeling the authorization aspects of your application. If you want to learn how commonly used patterns like RBAC, ABAC, etc., can be modeled in ZModel, this blog post can be a good reference: [Modeling Authorization in Prisma - No Theory, Just Code](https://zenstack.dev/blog/model-authz).\n\nThe completed sample project up to the end of this part can be found in the \"part1\" branch of the [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/part1) repo. You can clone it and check out to that branch with the following command:\n\n```\ngit clone --branch v1-part1 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```",
    "title": "Conclusion | ZenStack",
    "description": "In this part of the guide, we've focused on the core layer of ZenStack - an enhanced Prisma Client. The enhanced Prisma Client essentially turns the ORM into a fully secured data access layer, enabling the upper layer features like the automatic CRUD APIs and the generation of frontend data query libraries.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func",
    "markdown": "# Expressions and Functions | ZenStack\n\nIn the previous chapters, we've informally introduced how policy expressions are written. This chapter will list all expression types supported and functions that help you construct complex rules.\n\n### Expressions[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#expressions \"Direct link to Expressions\")\n\n#### Literal Expression[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#literal-expression \"Direct link to Literal Expression\")\n\n*   String: both single or double quoted, `\"foo\"`, `'bar'`.\n*   Number: `123`, `3.14`.\n*   Boolean: `true`, `false`.\n*   Null: `null`.\n\n#### Array Expression[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#array-expression \"Direct link to Array Expression\")\n\nArray of expressions. E.g, `[1, 2, 3]`, `['foo', 'bar']`, `[ADMIN, MEMBER]`.\n\n#### Reference Expression[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#reference-expression \"Direct link to Reference Expression\")\n\nUsed to reference a model field or an enum field.\n\n```\nmodel Post {    ...    published Boolean    @@allow('read', published) // `published` is a Reference Expression}\n```\n\n#### This Expression[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#this-expression \"Direct link to This Expression\")\n\nRepresented by `this` keyword. Used to address the value of the containing model.\n\n```\nmodel User {    id Int @id    @@allow('all', auth() == this) // `this` is a This Expression}\n```\n\n#### Member Access Expression[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#member-access-expression \"Direct link to Member Access Expression\")\n\nUsed to access a field from an expression.\n\n```\nmodel Post {    id Int @id    published Boolean    @@allow('read', auth().role == 'READ') // `auth().role` is a Member Access Expression}\n```\n\n#### Invocation Expression[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#invocation-expression \"Direct link to Invocation Expression\")\n\nUsed to invoke a function. E.g, `auth()` is an Invocation Expression.\n\n#### Unary Expression[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#unary-expression \"Direct link to Unary Expression\")\n\n*   `!` Logical NOT, operand must be boolean\n\n#### Binary Expression[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#binary-expression \"Direct link to Binary Expression\")\n\n*   `==` Equality, translated to id comparison when model types are compared\n*   `!=` Inequality, translated to id comparison when model types are compared\n*   `>` Greater than, both operands must be number\n*   `>=` Greater than or equal to, both operands must be number\n*   `<` Less than, both operands must be number\n*   `<=` Less than or equal to, both operands must be number\n*   `&&` Logical AND, both operands must be boolean\n*   `||` Logical OR, both operands must be boolean\n*   `in` Membership, with the left operand being an array and the right operand being a literal or a reference to an enum field\n\n### Functions[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#functions \"Direct link to Functions\")\n\nYou can find the detailed signature of each function in the [Predefined attribute functions](https://zenstack.dev/docs/1.x/reference/zmodel-language#predefined-attribute-functions) document.\n\n#### auth()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#auth \"Direct link to auth()\")\n\nReturns the current user. The function call has the type of the [auth model](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#auth-model).\n\n#### now()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#now \"Direct link to now()\")\n\nReturns the current timestamp. The function call is typed `DateTime`.\n\n```\n@@allow('read', future().updatedAt < now())\n```\n\n#### future()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#future \"Direct link to future()\")\n\nRepresents the post-update model value. You'll learn more about it in the [next chapter](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/post-update).\n\n#### contains()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#contains \"Direct link to contains()\")\n\nReturns if a string field contains a value.\n\n```\nmodel Post {    id Int @id    title String    @@allow('read', contains(title, 'zenstack'))}\n```\n\nThe comparison is case-sensitive by default. You can also pass a third argument to make the comparison case insensitive:\n\n```\n@@allow('read', contains(title, 'zenstack', true))\n```\n\n#### search()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#search \"Direct link to search()\")\n\nReturns if a string field matches the search condition with [full-text-search](https://www.prisma.io/docs/concepts/components/prisma-client/full-text-search). Need to enable Prisma's \"fullTextSearch\" preview feature to use.\n\n```\n@@allow('read', search(title, 'zenstack is awesome'))\n```\n\n#### startsWith()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#startswith \"Direct link to startsWith()\")\n\nReturns if a string field starts with a value.\n\n```\n@@allow('read', startsWith(title, 'zenstack'))\n```\n\n#### endsWith()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#endswith \"Direct link to endsWith()\")\n\nReturns if a string field ends with a value.\n\n```\n@@allow('read', endsWith(title, 'zenstack'))\n```\n\n#### has()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#has \"Direct link to has()\")\n\nReturns if an array field contains a value.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', has(tags, 'zenstack'))}\n```\n\n#### hasEvery()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#hasevery \"Direct link to hasEvery()\")\n\nReturns if an array field contains every value in the provided array.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', has(tags, ['zenstack', 'prisma']))}\n```\n\n#### hasSome()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#hassome \"Direct link to hasSome()\")\n\nReturns if an array field contains some value in the provided array.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', hasSome(tags, ['zenstack', 'prisma']))}\n```\n\n#### isEmpty()[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/expr-func#isempty \"Direct link to isEmpty()\")\n\nReturns if an array field is empty.\n\n```\nmodel Post {    id Int @id    tags String[]    @@allow('read', isEmpty(tags))}\n```",
    "title": "Expressions and Functions | ZenStack",
    "description": "In the previous chapters, we've informally introduced how policy expressions are written. This chapter will list all expression types supported and functions that help you construct complex rules.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood",
    "markdown": "# How Does ZenStack Work Under the Hood?\n\nAdvanced Topic\n\nThis document is for advanced users who want to understand how ZenStack works under the hood. It's not required for using ZenStack.\n\nZenStack extends Prisma ORM mainly at two levels. First, it provides a modeling DSL (ZModel) - a superset of Prisma schema. Second, it allows the creation of enhanced wrappers for Prisma clients at runtime for injecting extra behaviors.\n\nThis document explains how these extensions work so that you can make a more informed judgment on whether ZenStack is the right choice for you.\n\n## ZModel Language[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#zmodel-language \"Direct link to ZModel Language\")\n\nZenStack implemented the ZModel DSL from scratch, including the CLI and the VSCode extension, using the fantastic language toolkit [Langium](https://langium.org/). The DLS includes a plugin system, allowing a modular and extensible way to generate different artifacts from the schema. The core functionality of the toolkit is supported by the following three core plugins:\n\n*   Prisma: `@core/prisma`\n    \n    The Prisma plugin generates the Prisma schema and Prisma client from the ZModel schema. The Prisma schema can then be used for common Prisma tasks like `db push`, `migrate dev`, etc.\n    \n*   Model-meta: `@core/model-meta`\n    \n    The model-meta plugin generates the model metadata, which provides basic information about models and fields at runtime. The metadata is much more lightweight than the whole ZModel AST and is much cheaper to load.\n    \n    The default output location is `node_modules/.zenstack/model-meta.ts`.\n    \n*   Policy: `@core/access-policy`\n    \n    The access policy plugin converts access policy rules (expressed with `@@allow` and `@@deny` attributes) into checker functions. The functions take a context object as input and return partial Prisma query objects, which will be injected into Prisma query arguments at runtime. The context object contains the following properties:\n    \n    *   `user`: the current user, which serves as the return value of [`auth()`](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user) in the policy rules.\n    *   `preValue`: the previous value of an entity before update (for supporting the [`future()`](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/post-update) function in the policy rules).\n    \n    The default output location is `node_modules/.zenstack/policy.ts`.\n    \n    For example, for the following `Post` model:\n    \n    ```\n    model Post {    id        String @id @default(cuid())    createdAt DateTime @default(now())    updatedAt DateTime @updatedAt    title     String    published Boolean @default(false)    author    User @relation(fields: [authorId], references: [id])    authorId  String    // author has full access    @@allow('all', auth() == author)    // logged-in users can view published posts    @@allow('read', auth() != null && published)}\n    ```\n    \n    , the following checker functions are generated for \"read\" and \"update\" respectively:\n    \n    ```\n    function Post_read(context: QueryContext) {    const user = hasAllFields(context.user, ['id']) ? context.user : null;    return {        OR: [            user == null                ? { OR: [] } // false condition                : {                      author: {                          is: {                              id: user.id,                          },                      },                  },            {                AND: [                    user == null ? { OR: [] } : { AND: [] },                    {                        published: true,                    },                ],            },        ],    };}function Post_update(context: QueryContext) {    const user = hasAllFields(context.user, ['id']) ? context.user : null;    return user == null        ? { OR: [] } // false condition        : {              author: {                  is: {                      id: user.id,                  },              },          };}\n    ```\n    \n\n## Runtime Enhancements[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#runtime-enhancements \"Direct link to Runtime Enhancements\")\n\nThe primary responsibility of ZenStack's runtime is to create _enhanced_ Prisma client instances:\n\n*   `enhance` creates an enhanced client that includes all behaviors below.\n*   `withPolicy` creates an enhanced client that enforces access policies expressed with `@@allow` and `@@deny` attributes.\n*   `withPassword` creates an enhanced client that automatically hashes fields marked with the `@password` attribute before storing them in the database.\n*   `withOmit` creates an enhanced client that automatically strips fields marked with the `@omit` attribute before returning to the caller.\n\n### Proxies[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#proxies \"Direct link to Proxies\")\n\nRuntime enhancements are achieved by creating transparent proxies around raw Prisma clients. The proxies intercept all Prisma client methods, inject into query arguments, and manipulate the query results returned by the client. The proxies work independently from each other so that they can be freely combined. In fact, the `enhance` helper is a direct combination of `withPassword`, `withOmit`, and `withPolicy`.\n\n```\nexport function enhance<DbClient extends object>(    prisma: DbClient,    context?: WithPolicyContext,    options?: EnhancementOptions) {    return withPolicy(withOmit(withPassword(prisma, modelMeta), modelMeta), context, policy, modelMeta);}\n```\n\n### Access Policies[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#access-policies \"Direct link to Access Policies\")\n\nAccess policies, enabled by the `withPolicy` enhancer, are the most complex parts of the system. Part of the complexity comes from the great flexibility Prisma offers in querying and mutating data. For example, to enforce \"read\" rules on a `Post` model, we need to consider several possibilities:\n\n```\n// a direct where conditionprisma.post.findMany({    where: {...}});// nested fetch for relationsprisma.user.findUnique({    where: {id: ...},    include: { posts: true }});// nested fetch during mutationprisma.user.update({    where: {id: ...},    data: { ... },    select: { id: true, email: true, posts: true }});// ...\n```\n\nWe need the following measures to enforce access policies systematically:\n\n1.  **Inject filter conditions into the \"where\" clause in the context of \"find many\"**\n    \n    This covers cases like direct `findMany`/`findUnique`/`findFirst`/... calls:\n    \n    ```\n    prisma.user.findMany({ where: { ... } });// toprisma.user.findMany({    where: {        AND: [            { /* original conditions */ },            { /* read conditions */ },        ],    },});\n    ```\n    \n    Or nested \"find\" for a to-many relation:\n    \n    ```\n    prisma.user.findMany({ include: { posts: true } });// toprisma.user.findMany({    include: {        posts: {            where: {                /* read conditions */            },        },    },});\n    ```\n    \n    Or an implicit \"find\" carried with a mutation:\n    \n    ```\n    prisma.user.update({ data: { ... }, include: { posts: true } });// toprisma.user.update({ data: { ... }, include: { posts: { where: { /* read conditions */ } } } });\n    ```\n    \n2.  **Inject filter conditions into the \"where\" clause of \"mutate many\"**\n    \n    This covers cases like `updateMany` and `deleteMany`:\n    \n    ```\n    prisma.user.updateMany({ where: { ... }, data: { ... } });// toprisma.user.updateMany({    where: {        AND: [ { /* original conditions */ }, { /* update conditions */ } ]    },    data: { ... }});\n    ```\n    \n    Or nested usage of them:\n    \n    ```\n    prisma.user.update({ where: { ... }, data: { posts: { deleteMany: { where: { ... } } } } });// toprisma.user.update({ where: { ... },    data: {        posts: {            deleteMany: {                AND: [ { /* original conditions */ }, { /* delete conditions */ } ]            }        }    }});\n    ```\n    \n3.  **Post-read check for entities fetched as a to-one relation**\n    \n    To-one relation is a special case for reading because there's no way to do filtering at the read time: you either include it or not. So, we need to do a post-read check to ensure the fetched entity can be read.\n    \n    ```\n    const user = prisma.user.findUnique({ where: { id: ... }, include: { profile: true } });// toconst user = prisma.user.findUnique({ where: { id: ... }, include: { profile: true } });if (profile && !readable(user.profile)) {   // throw rejected error}\n    ```\n    \n4.  **Transaction-protected mutations**\n    \n    Policies that do \"post-mutation\" checks, including \"create\" and \"post-update\" (\"update\" rule calling [`future()`](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#the-future-function) function) rules, are protected by a transaction. The mutation is conducted first, and then post-mutation checks are performed. If any of the checks fail, the transaction rolls back.\n    \n    Although, for simple cases, we can enforce policies by checking the mutation input, there are many cases where we can't safely rely on that. Instead, employing a transaction is the most reliable way to achieve a consistent result. In the future, we may add input checking as an optimization where possible.\n    \n    ```\n    prisma.user.create({ data: { ... } });// toprisma.$transaction((tx) => {    const user = prisma.user.create({ data: { ... } });    if (!createable(user)) {        // throw rejected error    }})\n    ```\n    \n\n### The `auth()` function[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#the-auth-function \"Direct link to the-auth-function\")\n\nThe `auth()` function connects authentication with access control. It's typed as the auth model (the model named \"User\" by default) in ZModel and represents the current authenticated user. The most common way of setup is to read the auth model entity from the database after authentication is completed and pass the result to the `enhance` function as context.\n\nAlthough `auth()` resolves to the auth model, since it's provided by the user, there's no way to guarantee its value fully conforms to the model' typing: e.g., non-nullable fields can be passed as `null` or `undefined`. We employ some simple rules to deal with such cases:\n\n*   If `auth()` is `undefined`, it's normalized to `null` when evaluating access policies.\n*   If `auth()` itself is `null`, any member access (or chained member access) is `null`.\n*   `expression == null` evaluates to `true` if `expression` is `null`.\n*   Otherwise, a boolean expression evaluates to `false` if a `null` value is involved.\n\nHere are a few examples (assuming `auth()` is `null`):\n\n1.  `auth() == null` -> `true`\n2.  `auth() != null` -> `false`\n3.  `auth().name == null` -> `true`\n4.  `auth().age > 0` -> `false`\n5.  `auth().age < 0` -> `false`\n\n### The `future()` function[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/under-the-hood#the-future-function \"Direct link to the-future-function\")\n\nAn \"update\" policy rule is treated as a \"post-update\" rule if it involves a `future()` function call. `future()` represents the value of the model entity after the update is completed. In a \"post-update\" policy rule, any member accesses that are not prefixed with `future().` is treated as referencing the entity's value before the update. To support the evaluation of such rules, the entity value before the update is captured and passed as the `preValue` field in the context object passed to the checker function.",
    "title": "How Does ZenStack Work Under the Hood? | ZenStack",
    "description": "This document is for advanced users who want to understand how ZenStack works under the hood. It's not required for using ZenStack.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters",
    "markdown": "# Server Adapters | ZenStack\n\n### Overview[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#overview \"Direct link to Overview\")\n\nZenStack is a toolkit but not a framework. It doesn't come with its own web server. Instead, it provides a set of server adapters that \"mount\" APIs to the server of your choice.\n\nServer adapters are framework-specific. ZenStack ships a `@zenstackhq/server` package that contains adapters for the most popular backend and full-stack frameworks:\n\n*   [Express](https://zenstack.dev/docs/1.x/reference/server-adapters/express)\n*   [Fastify](https://zenstack.dev/docs/1.x/reference/server-adapters/fastify)\n*   [Next.js](https://zenstack.dev/docs/1.x/reference/server-adapters/next)\n*   [Nuxt](https://zenstack.dev/docs/1.x/reference/server-adapters/nuxt)\n*   [SvelteKit](https://zenstack.dev/docs/1.x/reference/server-adapters/sveltekit)\n\nCheck out their respective documentation to learn more details.\n\nAs mentioned in the previous chapter, server adapters handle framework-specific request/response formats and transform them to the canonical form that the underlying API handlers understand. All server adapters share the following two initialization options:\n\n*   `handler`\n    \n    The API handler to use. As mentioned in the previous chapter, ZenStack provides two built-in API handler implementations. If you don't specify this option, the default API handler is RPC.\n    \n    *   RPC handler: `@zenstackhq/server/api/rpc`\n    *   RESTful handler: `@zenstackhq/server/api/rest`\n*   `getPrisma`\n    \n    A callback function for getting a PrismaClient instance used for handling a CRUD request. The function is passed with a framework-specific request object. Although you can return a vanilla Prisma Client, you most likely should use an enhanced one to enforce access policies.\n    \n\n### 🛠️ Serving CRUD API[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#%EF%B8%8F-serving-crud-api \"Direct link to 🛠️ Serving CRUD API\")\n\nLet's see how we can automagically turn our ZModel schema into a web API without really coding it 🚀! We'll use Express for simplicity for now, but working with another framework is essentially the same.\n\n#### 1\\. Installing dependencies[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#1-installing-dependencies \"Direct link to 1. Installing dependencies\")\n\nFirst, install Express and the ZenStack server package:\n\n```\nnpm install express @zenstackhq/servernpm install --save-dev @types/express tsx\n```\n\n#### 2\\. Creating an Express app[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#2-creating-an-express-app \"Direct link to 2. Creating an Express app\")\n\nCreate a file `main.ts` with the following content:\n\nmain.ts\n\n```\nimport express from 'express';const app = express();app.use(express.json());app.get('/', (req, res) => {    res.json({ greet: 'Hello World!' });});app.listen(3000, () => console.log('🚀 Server ready at: http://localhost:3000'));\n```\n\nStart the server:\n\nMake a request in another terminal to verify everything is working:\n\n```\ncurl http://localhost:3000\n```\n\n> { \"greet\": \"Hello World!\" }\n\n#### 3\\. Adding ZenStack server adapter (RPC flavor)[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#3-adding-zenstack-server-adapter-rpc-flavor \"Direct link to 3. Adding ZenStack server adapter (RPC flavor)\")\n\nLet's create an express middleware and mount the CRUD API to the `/api/rpc` path. Replace `main.ts` with the following content:\n\nmain.ts\n\n```\nimport { PrismaClient } from '@prisma/client';import { ZenStackMiddleware } from '@zenstackhq/server/express';import express from 'express';const app = express();app.use(express.json());const prisma = new PrismaClient();app.use('/api/rpc', ZenStackMiddleware({ getPrisma: () => prisma }));app.listen(3000, () => console.log('🚀 Server ready at: http://localhost:3000'));\n```\n\ninfo\n\nThe `ZenStackMiddleware` server adapter uses RPC-flavor API by default.\n\nWe've configured the server adapter to use a vanilla Prisma Client for now for quick testing. By default, the server adapter uses RPC-style API. We can hit the endpoint to do a few tests now:\n\n*   Find a `List`\n    \n    ```\n    curl \"http://localhost:3000/api/rpc/list/findFirst\"\n    ```\n    \n    ```\n    {    \"data\" : {        \"createdAt\" : \"2023-11-08T04:38:53.385Z\",        \"id\" : 1,        \"ownerId\" : 1,        \"private\" : false,        \"spaceId\" : 1,        \"title\" : \"Grocery\",        \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"    },    \"meta\" : { ... }}\n    ```\n    \n*   Find a private `List`\n    \n    Note the parameter `q` is url-encoded `{\"where\":{\"private\":true}}`.\n    \n    ```\n    curl \"http://localhost:3000/api/rpc/list/findFirst?q=%7B%22where%22%3A%7B%22private%22%3Atrue%7D%7D\"\n    ```\n    \n    ```\n    {    \"data\" : {        \"createdAt\" : \"2023-11-11T02:34:29.880Z\",        \"id\" : 5,        \"ownerId\" : 1,        \"private\" : true,        \"spaceId\" : 1,        \"title\" : \"Joey' List\",        \"updatedAt\" : \"2023-11-11T02:34:29.880Z\"    },    \"meta\" : { ...}}\n    ```\n    \n*   Create a `List`\n    \n    ```\n    curl -XPOST \"http://localhost:3000/api/rpc/list/create\" \\    -d '{\"data\":{\"title\":\"Jobs to be done\",\"owner\":{\"connect\":{\"id\":2}},\"space\":{\"connect\":{\"id\":1}}}}' \\    -H 'Content-Type: application/json'\n    ```\n    \n    ```\n    {    \"data\": {        \"id\": 6,        \"createdAt\": \"2023-11-11T02:40:58.765Z\",        \"updatedAt\": \"2023-11-11T02:40:58.765Z\",        \"spaceId\": 1,        \"ownerId\": 2,        \"title\": \"Jobs to be done\",        \"private\": false    },    \"meta\": { ... }}\n    ```\n    \n\n#### 4\\. Making access policies work[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#4-making-access-policies-work \"Direct link to 4. Making access policies work\")\n\nTo make access policies work, we need to create an enhanced Prisma Client, and to do that, we need to be able to get the current user from the request. Since we haven't implemented authentication yet, we'll use a special `x-user-id` header to simulate and pass the requesting user's ID. It's definitely not a secure implementation, but it's sufficient for demonstration. We'll hook up a real authentication system in [Part IV](https://zenstack.dev/docs/1.x/the-complete-guide/part4/).\n\nReplace the content of `main.ts` with the following code:\n\nmain.ts\n\n```\nimport { PrismaClient } from '@prisma/client';import { enhance } from '@zenstackhq/runtime';import { ZenStackMiddleware } from '@zenstackhq/server/express';import express, { Request } from 'express';const app = express();app.use(express.json());const prisma = new PrismaClient();function getUser(req: Request) {    if (req.headers['x-user-id']) {        return { id: parseInt(req.headers['x-user-id'] as string) };    } else {        return undefined;    }}app.use('/api/rpc',     ZenStackMiddleware({         getPrisma: (req) => enhance(prisma, { user: getUser(req) })    }));app.listen(3000, () => console.log('🚀 Server ready at: http://localhost:3000'));\n```\n\nNow, if we hit the endpoint again without the `x-user-id` header, we'll get a null response:\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst\"\n```\n\nAdd the header and request again. We should get back a result then:\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst\" -H \"x-user-id: 1\"\n```\n\n```\n{  \"data\": {    \"id\": 1,    \"createdAt\": \"2023-11-08T04:38:53.385Z\",    \"updatedAt\": \"2023-11-09T04:52:57.987Z\",    \"spaceId\": 1,    \"ownerId\": 1,    \"title\": \"Grocery\",    \"private\": false  },  \"meta\": { ... }}\n```\n\nYou can try other operations with different user identities. The service's behavior should be consistent with what we've seen in the REPL with the enhanced Prisma in [Part I](https://zenstack.dev/docs/1.x/the-complete-guide/part1/access-policy/current-user#add-user-based-access-control).\n\n#### 5\\. Trying Out The RESTful API Flavor[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/server-adapters#5-trying-out-the-restful-api-flavor \"Direct link to 5. Trying Out The RESTful API Flavor\")\n\nLet's mount a RESTful-flavor API under another path `/api/rest`. Add the following code to `main.ts` before the line of `app.listen(...)`:\n\n```\nimport RESTHandler from '@zenstackhq/server/api/rest';app.use('/api/rest',     ZenStackMiddleware({         handler: RESTHandler({ endpoint: 'http://localhost:3000/api/rest' }),        getPrisma: (req) => enhance(prisma, { user: getUser(req) })    }));\n```\n\nAs you've seen above, we're using the same server adapter implementation and swapped the API handler. Now we can fetch the first `List` item by making a RESTful-style request.\n\ninfo\n\nThe \"-g\" parameter passed to curl is for allowing square brackets in the URL.\n\n```\ncurl -g 'http://localhost:3000/api/rest/list?page[limit]=1' -H \"x-user-id: 1\"\n```\n\n```\n{   \"data\" : [      {         \"attributes\" : {            \"createdAt\" : \"2023-11-08T04:38:53.385Z\",            \"ownerId\" : 1,            \"private\" : false,            \"spaceId\" : 1,            \"title\" : \"Grocery\",            \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"         },         \"id\" : 1,         \"links\" : { ... },         \"relationships\" : { ... },         \"type\" : \"list\"      }   ],   \"jsonapi\" : {      \"version\" : \"1.1\"   },   \"links\" : { ... },   \"meta\" : { ... }}\n```",
    "title": "Server Adapters | ZenStack",
    "description": "Overview",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part2/using-plugins",
    "markdown": "# Using Plugins | ZenStack\n\n```\nplugin openapi {    provider = \"@zenstackhq/openapi\"    output = \"openapi.yaml\"    title = \"My Todo API\"    version = \"1.0.0\"}\n```",
    "title": "Using Plugins | ZenStack",
    "description": "To use a plugin, install the plugin npm package:",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part2/conclusion",
    "markdown": "# Conclusion | ZenStack\n\nIn this part of the guide, we've focused on the plugin system of ZenStack. We've learned how to use plugins and how to write one.\n\nZModel contains a formal representation of how data is organized and its constraints. Besides serving as database schema and access control, it's an excellent source for powering other aspects of your app. Don't hesitate to write your own plugins when you feel the need.\n\nIn [Part III](https://zenstack.dev/docs/1.x/the-complete-guide/part3/) and [Part IV](https://zenstack.dev/docs/1.x/the-complete-guide/part4/) of the guide, you'll see in action how we use plugins to turn our Todo project from a schema to a full-stack application without writing much code.\n\nThe completed sample project up to the end of this part can be found in the \"part2\" branch of the [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/v1-part2) repo. You can clone it and check out to that branch with the following command:\n\n```\ngit clone --branch v1-part2 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```",
    "title": "Conclusion | ZenStack",
    "description": "In this part of the guide, we've focused on the plugin system of ZenStack. We've learned how to use plugins and how to write one.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part2/builtin-plugins",
    "markdown": "# Built-in Plugins | ZenStack\n\nZenStack ships with a set of built-in plugins. They fall into the following two categories.\n\nMost of the core functionalities of ZenStack are implemented as or supported by a few core plugins. They're vital to the operation of ZenStack and are enabled automatically as needed. Core plugins are implemented inside the `zenstack` npm package and have names starting with `@core/`.\n\nThe ZenStack CLI automatically decides whether a core plugin should be enabled based on the ZModel. You can also explicitly declare a core plugin to override its options. For example, declare a `@core/prisma` plugin to output the generated Prisma schema file to a custom location:\n\n```\nplugin prisma {    provider = \"@core/prisma\"    output = \"src/db/prisma/schema.prisma\"}\n```\n\nBesides core plugins, the ZenStack team maintains a set of useful but non-essential plugins. They are implemented in separate npm packages under the `@zenstackhq` organization.",
    "title": "Built-in Plugins | ZenStack",
    "description": "ZenStack ships with a set of built-in plugins. They fall into the following two categories.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/customization",
    "markdown": "# Customizing The Generated API | ZenStack\n\nHaving APIs derived from the schema is great, but sometimes, you want to customize them to fit your needs. Some of the common use cases are:\n\nIn this chapter, let's explore a few options to do that.\n\nMost server frameworks provide some kind of \"middleware\" mechanism for developers to intercept requests and responses. For example, you can use a separate Express middleware to add custom a custom header to the response before it's sent to the client:\n\n```\napp.use('/api/rpc',     ZenStackMiddleware({        getPrisma: (req) => enhance(prisma, { user: getUser(req) }),        // instructs the middleware to not send the response,        // instead, store it in `res.locals`        sendResponse: false,    }),    (req: Request, res: Response) => {        // another middleware to intercept the CRUD response,        // add a header and send the response        const { status, body } = res.locals;        res.header('x-requested-by', req.headers['x-user-id']);        res.status(status).json(body);    });\n```\n\nSince server adapters are just lightweight wrappers around API handlers, you can also implement a custom adapter to interact with the API handler directly. This way, you have complete control over how the API handler's result data is processed and sent back to the client as a framework response.\n\nThe following code demonstrates how to add the 'x-requested-by' header with this approach:\n\n```\nimport RESTHandler from '@zenstackhq/server/api/rest';app.use('/api/rpc-custom', async (req: Request, res: Response) => {    const url = req.protocol + '://' + req.get('host') + req.originalUrl;    const searchParams = new URL(url).searchParams;    const query = Object.fromEntries(searchParams);    const handler = RPCHandler();    const { status, body } = await handler({        method: req.method,        path: req.path,        query,        requestBody: req.body,        prisma: enhance(prisma, { user: getUser(req) }) as any,    });    res.status(status)        .header('x-requested-by', req.header('x-user-id'))        .json(body);});\n```\n\nUsing the automatic CRUD API doesn't mean you can't implement your own APIs. You can always build fully customized APIs from scratch and leverage the enhanced Prisma Client.",
    "title": "Customizing The Generated API | ZenStack",
    "description": "Having APIs derived from the schema is great, but sometimes, you want to customize them to fit your needs. Some of the common use cases are:",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins",
    "markdown": "# Writing Plugins | ZenStack\n\nThe ZModel schema is the single source of truth for your data and access control. It can be used to generate many other valuable things based on your specific needs. In this part of the guide, we'll learn the fundamentals of how to write plugins and create a simple one that generates a markdown documentation from the ZModel schema.\n\n### Structure of a Plugin[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#structure-of-a-plugin \"Direct link to Structure of a Plugin\")\n\nA plugin is a Node.js module that has the following exports:\n\n1.  A named export `name` that specifies the name of the plugin used for logging and error reporting.\n2.  A default function export containing the plugin logic.\n\nHere's what a bare minimum plugin looks like:\n\n```\nimport type { DMMF } from '@prisma/generator-helper';import { type PluginOptions } from '@zenstackhq/sdk';import { type Model } from '@zenstackhq/sdk/ast';export const name = 'My Plugin';export default async function run(model: Model, options: PluginOptions, dmmf: DMMF.Document) {    ...}\n```\n\nWhen `zenstack generate` runs, it identifies all the plugins declared in the ZModel, loads their Javascript modules, and calls the default export functions. The following sections explain the arguments passed to the plugin function.\n\n#### ZModel AST[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#zmodel-ast \"Direct link to ZModel AST\")\n\nThe first input of the plugin function is the ZModel AST. It is the result object model of parsing and linking the ZModel schema - a tree structure containing all the information in the schema. Most plugins traverse the AST, extract information of interest, and transform it into another form.\n\nThe following diagram shows the (abbreviated) AST of a simple ZModel schema:\n\n```\ndatasource db {    provider = 'sqlite'    url = 'file:.dev.db'}model User {    id Int @id @default(autoincrement())    posts Post[]}model Post {    id Int @id @default(autoincrement())    title String    author User @relation(fields: [authorId], references: [id])    authorId Int    @@allow('all', auth() == author)}\n```\n\nThe best way to understand the AST structure is to inspect the [ZModel language definition](https://github.com/zenstackhq/zenstack/blob/main/packages/language/src/zmodel.langium).\n\n#### Plugin Options[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#plugin-options \"Direct link to Plugin Options\")\n\nThe second input of the plugin function is the options - an object containing the config fields that the plugin user specified in the ZModel. As a plugin developer, you should define and document what config options your plugin supports.\n\n#### Prisma DMMF[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#prisma-dmmf \"Direct link to Prisma DMMF\")\n\nThe third input of the plugin function is the Prisma DMMF (Data Model Meta Format). DMMF is essentially Prisma Schema's AST enriched with other information needed to generate Prisma Client. It is the main API that developers use to write custom Prisma generators. However, the API is undocumented and considered internal.\n\nFor ZenStack plugins, the DMMF is provided as an auxiliary input. If you only need information from the ZModel schema, the ZModel AST is all you need. However, if you need to access types generated for the Prisma Client (e.g., the parameter shapes of `prisma.user.findMany()`), DMMF is the only way to get them. The best way to learn how to use DMMF is to study the source code of [Prisma's community generators](https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators).\n\n### Adding Custom Attributes[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#adding-custom-attributes \"Direct link to Adding Custom Attributes\")\n\nA plugin can contribute custom attributes and functions to the ZModel language. To do that, simply include a `plugin.zmodel` file in the same directory as the plugin's entry point, and declare the attributes and functions there. Check [here](https://github.com/zenstackhq/zenstack/blob/main/packages/plugins/openapi/src/plugin.zmodel) for an example. As a convention for conflict avoidance, please qualify the declaration names with your plugin name. E.g.:\n\n```\nattribute @@myplugin.include()\n```\n\nAnd you can use it in the ZModel when the plugin is enabled:\n\n```\nmodel Foo {    ...    @@myplugin.include()}\n```\n\n### Publishing a Plugin[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#publishing-a-plugin \"Direct link to Publishing a Plugin\")\n\nIf your plugin is specific to your project, you can implement it inside the project and load it with a relative path in the ZModel. No publishing is needed. We'll see how to do that in the next section.\n\nIf you're building something reusable, please publish it as an NPM package and [tweet us](https://twitter.com/intent/tweet?text=I%27ve%20published%20a%20%40zenstackhq%20plugin%3A&url=) or reach us on [Discord](https://discord.gg/Ykhr738dUe). We'll be happy to share your work with the community.\n\n### 🛠️ Building a Markdown Generator Plugin[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#%EF%B8%8F-building-a-markdown-generator-plugin \"Direct link to 🛠️ Building a Markdown Generator Plugin\")\n\nLet's build a simple plugin that generates a markdown documentation from the ZModel schema. The generated documentation will look like this:\n\n```\n# My Awesome Todo AppA multi-tenant Todo app built with ZenStack.- [Space](#space)- [User](#user)- ...## Space- CREATE  - ❌ auth() == null  - ✅ true- READ  - ❌ auth() == null  - ✅ members?[user == auth()]- UPDATE  - ❌ auth() == null  - ✅ members?[user == auth() && role == ADMIN]- DELETE  - ❌ auth() == null  - ✅ members?[user == auth() && role == ADMIN]## User...\n```\n\n#### 1\\. Creating the plugin[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#1-creating-the-plugin \"Direct link to 1. Creating the plugin\")\n\nIn our sample project, create a `markdown-plugin.ts` file at the root:\n\nmarkdown-plugin.ts\n\n```\nimport { type PluginOptions } from '@zenstackhq/sdk';import {    isDataModel,    type DataModel,    type Model,} from '@zenstackhq/sdk/ast';import fs from 'fs';export const name = 'Markdown';export default async function run(model: Model, options: PluginOptions) {    // process options    const title = options.title ?? 'My Application Model';    const description = options.description ?? 'Description of my application';    // get all data models    const dataModels = model.declarations.filter((x): x is DataModel =>        isDataModel(x)    );    // TOC    const toc = dataModels.map((x) => `- [${x.name}](#${x.name})`).join('\\n');    // data model docs    const dataModelDocs = generateDataModelDocs(dataModels);    fs.writeFileSync(        'schema.md',        `# ${title}    ${description}    ${toc}    ${dataModelDocs}    `    );}\n```\n\nThe code sets up the high-level structure of the markdown document. Let's now add the `generateDataModelDocs` function implementation in the same file.\n\nmarkdown-plugin.ts\n\n```\nimport { ZModelCodeGenerator, getLiteral } from '@zenstackhq/sdk';import { type DataModelAttribute } from '@zenstackhq/sdk/ast';function generateDataModelDocs(dataModels: DataModel[]) {    // AST -> ZModel source generator    const zmodelCodeGen = new ZModelCodeGenerator();    // all CRUD operations    const CRUD = ['create', 'read', 'update', 'delete'];    const docs = dataModels.map((dataModel) => {        // first, group model attributes by CRUD operations        const groupByCrud = dataModel.attributes            .filter((attr) =>                ['@@allow', '@@deny'].includes(attr.decl.ref?.name || '')            )            .reduce<Record<string, DataModelAttribute[]>>((group, attr) => {                const ops = getLiteral<string>(attr.args[0].value);                if (ops) {                    const splitOps =                        ops == 'all'                            ? CRUD                            : ops.split(',').map((op) => op.trim());                    splitOps.forEach((op) => {                        group[op] = group[op] || [];                        group[op].push(attr);                    });                }                return group;            }, {});        // then generate rules for each operation        const policies = CRUD.map((op) => {            const rules = groupByCrud[op]                ? groupByCrud[op]                      // output `@@deny` before `@@allow`                      .sort((a) => {                          return a.decl.ref?.name == '@@deny' ? -1 : 1;                      })                      .map(                          (attr) =>                              `  - ${                                  attr.decl.ref?.name == '@@deny'                                      ? '❌ '                                      : '✅ '                              }${zmodelCodeGen.generate(attr.args[1].value)}`                      )                      .join('\\n')                : [];            return [`- ${op.toUpperCase()}`, rules].join('\\n');        }).join('\\n');        return `## ${dataModel.name}\\n\\n${policies}`;    });    return docs.join('\\n\\n');}\n```\n\nFinally, compile the plugin code:\n\nThe JavaScript output should have been generated into the `dist` folder.\n\n#### 2\\. Testing the plugin[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#2-testing-the-plugin \"Direct link to 2. Testing the plugin\")\n\nWe can now add the plugin to our ZModel:\n\n```\nplugin markdown {    provider = './dist/markdown-plugin'    title = 'My Awesome Todo App'    description = 'A multi-tenant Todo application built with ZenStack.'}\n```\n\nPlugin module resolution\n\nWhen you use a relative path (starting with \".\") in the \"provider\" field, ZenStack resolves the path relative to the ZModel file and loads the plugin module from it with `require()`. If the plugin is a published NPM package, use the package name directly in the \"provider\" field.\n\nNow run the CLI to regenerate:\n\nYou should see the following output and the `schema.md` file generated in the current directory:\n\n```\n⌛️ ZenStack CLI v1.3.1, running plugins✔ Running plugin Prisma✔ Running plugin Model Metadata✔ Running plugin Access Policy✔ Running plugin Zod✔ Running plugin Markdown👻 All plugins completed successfully!Don't forget to restart your dev server to let the changes take effect.\n```\n\n#### 3\\. Full source code[​](https://zenstack.dev/docs/1.x/the-complete-guide/part2/writing-plugins#3-full-source-code \"Direct link to 3. Full source code\")\n\nThe sample plugin we implemented here is a simplified version of the [zenstack-markdown](https://github.com/jiashengguo/zenstack-markdown) plugin created by [@jiashengguo](https://github.com/jiashengguo). Besides outputting access policies, it also generates mini entity-relation diagrams in [mermaid](https://mermaid-js.github.io/) format.",
    "title": "Writing Plugins | ZenStack",
    "description": "The ZModel schema is the single source of truth for your data and access control. It can be used to generate many other valuable things based on your specific needs. In this part of the guide, we'll learn the fundamentals of how to write plugins and create a simple one that generates a markdown documentation from the ZModel schema.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/serialization",
    "markdown": "# Data Serialization | ZenStack\n\nOne problem with passing Prisma requests and responses across the network is that the data is not always serializable. The following Prisma types are problematic:\n\n*   `Date`: Javascript's `Date` object is serializable, but its type is lost\n*   `Bytes`: not serializable\n*   `BigInt`: not serializable\n*   `Decimal`: not serializable\n\nZenStack solves this problem by using [superjson](https://github.com/blitz-js/superjson) to deserialize input and serialize output. Since data is still JSON-serializable most of the time, ZenStack adopts superjson in a non-intrusive way. The serialized data is directly put inside the request or response data. When there is extra serialization information (superjson generates it when it encounters data that's not JSON-serializable), it's put inside the `meta` field in the request or response.\n\nThe benefit of this design is that if the data is fully JSON-serializable (not involving the types mentioned above), the wire format is just plain JSON serialization without any pollution.\n\nYou can find more details about serialization in the [RPC API Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rpc#serialization) and [RESTful API Handler](https://zenstack.dev/docs/1.x/reference/server-adapters/api-handlers/rest#serialization) documentation.\n\n### 🛠️ Observing Serialization Behavior[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/serialization#%EF%B8%8F-observing-serialization-behavior \"Direct link to 🛠️ Observing Serialization Behavior\")\n\nTo illustrate this, let's try a few requests to observe the serialization behavior.\n\nMake the following request to find the first `List` with `{\"select\":{\"id\":true,\"title\":true}}`:\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst?q=%7B%22select%22%3A%7B%22id%22%3Atrue%2C%22title%22%3Atrue%7D%7D\" -H \"x-user-id: 1\"\n```\n\nYou should get a simple response. Since the result data is fully JSON-serializable, the response has no extra serialization metadata.\n\n```\n{    \"data\": {        \"id\":1,        \"title\":\"Grocery\"    }}\n```\n\nNow, if we send a different request and ask for the full `List` object\n\n```\ncurl \"http://localhost:3000/api/rpc/list/findFirst\" -H \"x-user-id: 1\"\n```\n\nWe get back a richer response. The `createdAt` and `updatedAt` fields are not directly JSON-serializable, and the information contained in the `meta.serialization` field is generated by superjson to facilitate deserialization.\n\n```\n{   \"data\" : {      \"createdAt\" : \"2023-11-08T04:38:53.385Z\",      \"id\" : 1,      \"ownerId\" : 1,      \"private\" : false,      \"spaceId\" : 1,      \"title\" : \"Grocery\",      \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"   },   \"meta\" : {      \"serialization\" : {         \"values\" : {            \"createdAt\" : [ \"Date\" ],            \"updatedAt\" : [ \"Date\" ]         }      }   }}\n```\n\nThe API consumer should pass the data and the serialization metadata to the superjson API to get back data with full fidelity. The following code shows how to deserialize and restore the proper `Date` type for the `createdAt` and `updatedAt` fields.\n\n```\nimport SuperJSON from 'superjson';SuperJSON.deserialize({    json: {        \"createdAt\" : \"2023-11-08T04:38:53.385Z\",        \"id\" : 1,        \"ownerId\" : 1,        \"private\" : false,        \"spaceId\" : 1,        \"title\" : \"Grocery\",        \"updatedAt\" : \"2023-11-09T04:52:57.987Z\"   },   meta: {        \"values\" : {            \"createdAt\" : [ \"Date\" ],            \"updatedAt\" : [ \"Date\" ]        }    }});\n```\n\n```\n{    createdAt: 2023-11-08T04:38:53.385Z,    id: 1,    ownerId: 1,    private: false,    spaceId: 1,    title: 'Grocery',    updatedAt: 2023-11-09T04:52:57.987Z}\n```",
    "title": "Data Serialization | ZenStack",
    "description": "One problem with passing Prisma requests and responses across the network is that the data is not always serializable. The following Prisma types are problematic:",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks",
    "markdown": "# 🛠️ Generating Hooks | ZenStack\n\nIf you use a frontend framework like React or Vue, you've probably used or heard of libraries like [TanStack Query](https://tanstack.com/query/latest) and [SWR](https://swr.vercel.app/). These libraries make it a breeze to build data-driven UI by providing excellent encapsulation for reactive data query, cache management, and data invalidation (aka refetching).\n\nZenStack provides plugins for generating frontend hooks targeting these two libraries. In this guide, we'll focus on using TanStack Query, but the concepts and usage are similar for SWR.\n\n### Installing Dependencies[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks#installing-dependencies \"Direct link to Installing Dependencies\")\n\n```\nnpm install @tanstack/react-query @zenstackhq/tanstack-query\n```\n\nThe `@zenstackhq/tanstack-query` package contains both the plugin and a runtime part, so it needs to be installed as a regular dependency.\n\n### Setting Up TanStack Query[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks#setting-up-tanstack-query \"Direct link to Setting Up TanStack Query\")\n\nTo use TanStack Query, we need to set up a `QueryClientProvider` context provider in the root component of our app. First, create a file `src/components/QueryClientProvider.tsx` with the following content:\n\nsrc/components/QueryClientProvider.tsx\n\n```\n'use client';import { QueryClient, QueryClientProvider } from '@tanstack/react-query';type Props = {  children: React.ReactNode;};const queryClient = new QueryClient();function Provider({ children }: Props) {  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;}export default Provider;\n```\n\nThen, update the `src/app/layout.tsx` file to use it:\n\nsrc/app/layout.tsx\n\n```\nimport QueryClientProvider from '~/components/QueryClientProvider';export default function RootLayout({ children }: { children: React.ReactNode }) {  return (    <html lang=\"en\">      <body className={`font-sans ${inter.variable}`}>        <QueryClientProvider>          <NextAuthSessionProvider>{children}</NextAuthSessionProvider>        </QueryClientProvider>      </body>    </html>  );}\n```\n\n### Adding TanStack Query Plugin[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks#adding-tanstack-query-plugin \"Direct link to Adding TanStack Query Plugin\")\n\nNow add the plugin to the ZModel schema:\n\nschema.zmodel\n\n```\nplugin hooks {  provider = '@zenstackhq/tanstack-query'  target = 'react'  version = 'v5'  output = 'src/lib/hooks'}\n```\n\nTanStack Query is a multi-framework library and supports React, Vue, and Svelte. The \"target\" field specifies the frontend framework to generate hooks for. The \"version\" field specifies the version of TanStack Query to target. Here, we're using the latest \"v5\" version.\n\nThen, rerun generation and observe that the hooks code is generated in the `src/lib/hooks` directory.\n\n### A Peek Into the Hooks[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/generate-hooks#a-peek-into-the-hooks \"Direct link to A Peek Into the Hooks\")\n\nThe generated hooks allow you to query and mutate data without worrying about the API details. They're designed to fully preserve the Prisma query syntax you already know. Here are some quick examples of their usage:\n\n*   Nested read with filtering and sorting\n    \n    ```\n    // `data` is typed as `(Todo & { list: List })[]`const { data } = useFindManyTodo({  where: { owner: { id: 1 } },  include: { list: true },  orderBy: { createdAt: 'desc' }});\n    ```\n    \n*   Nested create\n    \n    ```\n    const { mutate } = useCreateList();function onCreateList() {  mutate({    data: {       title: 'My List',      owner: { connect: { id: userId } },      todos: {        create: [          { name: 'Todo 1' },          { name: 'Todo 2' }        ]      }    }  })}\n    ```\n    \n*   Count\n    \n    ```\n    const { data } = useCountTodo({ where: { owner: { id: 1 } } });\n    ```\n    \n\nWe'll cover the usage of the hooks in detail in the upcoming chapters.",
    "title": "🛠️ Generating Hooks | ZenStack",
    "description": "If you use a frontend framework like React or Vue, you've probably used or heard of libraries like TanStack Query and SWR. These libraries make it a breeze to build data-driven UI by providing excellent encapsulation for reactive data query, cache management, and data invalidation (aka refetching).",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation",
    "markdown": "# Generating API Documentation | ZenStack\n\nVersion: 1.x\n\nAn API is only complete when documented. Similar to the API itself, the documentation can also be derived from the ZModel.\n\nIn [Part II](https://zenstack.dev/docs/1.x/the-complete-guide/part2/) of the guide, we've learned how to use plugins. ZenStack ships the [@zenstackhq/openapi](https://zenstack.dev/docs/1.x/reference/plugins/openapi) plugin to generate [OpenAPI](https://www.openapis.org/) specs from the ZModel schema. Like the API handlers, the openapi plugin also supports two flavors: \"rpc\" and \"rest\".\n\nOnce the documentation is generated, it's easy to render it using tools like [Swagger UI](https://swagger.io/tools/swagger-ui/) and [Redocly](https://redocly.com/).\n\n### 🛠️ Serving API Documentation[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation#%EF%B8%8F-serving-api-documentation \"Direct link to 🛠️ Serving API Documentation\")\n\nLet's generate an OpenAPI spec for our Todo API and serve it using Swagger UI.\n\n#### 1\\. Installing Dependencies[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation#1-installing-dependencies \"Direct link to 1. Installing Dependencies\")\n\n```\nnpm install --save-dev @zenstackhq/openapinpm install swagger-ui-expressnpm install -D @types/swagger-ui-express\n```\n\n#### 2\\. Adding OpenAPI Plugin to ZModel[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation#2-adding-openapi-plugin-to-zmodel \"Direct link to 2. Adding OpenAPI Plugin to ZModel\")\n\nschema.zmodel\n\n```\nplugin openapi {    provider = \"@zenstackhq/openapi\"    output = \"todo-api.json\"    title = \"My Todo API\"    version = \"1.0.0\"    flavor = \"rpc\"}\n```\n\nRerun generation:\n\nThe `todo-api.json` file should be generated in the project root.\n\n#### 3\\. Serving the OpenAPI Spec[​](https://zenstack.dev/docs/1.x/the-complete-guide/part3/documentation#3-serving-the-openapi-spec \"Direct link to 3. Serving the OpenAPI Spec\")\n\nAdd the following code to `main.ts` before the line of `app.listen(...)`:\n\nmain.ts\n\n```\nimport swaggerUI from 'swagger-ui-express';app.use(    '/api/docs',    swaggerUI.serve,    swaggerUI.setup(require('./todo-api.json')));\n```\n\nNow, you can visit the documentation at [http://localhost:3000/api/docs](http://localhost:3000/api/docs) in a browser.\n\n![Swagger UI](https://zenstack.dev/assets/images/todo-app-openapi-5c63d09d659d098462f00c376787718c.png)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
    "title": "Generating API Documentation | ZenStack",
    "description": "An API is only complete when documented. Similar to the API itself, the documentation can also be derived from the ZModel.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/conclusion",
    "markdown": "# Conclusion | ZenStack\n\nIn this part of the guide, we've focused on ZenStack's powers for deriving CRUD APIs automatically from the ZModel schema. We had an overview of the different API flavors and learned how to mount the APIs onto a backend framework.\n\nIn the next part, we'll see how effortless it is to consume the APIs from a frontend application and eventually turn our Todo project into a full-stack application.\n\nThe completed sample project up to the end of this part can be found in the \"part3\" branch of the [the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample/tree/v1-part3) repo. You can clone it and check out to that branch with the following command:\n\n```\ngit clone --branch v1-part3 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app\n```",
    "title": "Conclusion | ZenStack",
    "description": "In this part of the guide, we've focused on ZenStack's powers for deriving CRUD APIs automatically from the ZModel schema. We had an overview of the different API flavors and learned how to mount the APIs onto a backend framework.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project",
    "markdown": "# 🛠️ Creating a Full-Stack Project\n\nTo simplify the process of building our full-stack Todo app, we'll recreate the project from scratch using the [create-t3-app](https://create.t3.gg/) scaffolding tool - saving us a lot of time manually integrating different tools and libraries. We'll reuse the ZModel schema we built in Part I.\n\nZenStack is framework-agnostic\n\nFor ease of demonstration, we'll use the [Next.js](https://nextjs.org/) framework for full-stack development. However, ZenStack is framework-agnostic. Most of the content apply to other choices, including full-stack ones like like [Nuxt](https://nuxt.com/) and [SvelteKit](https://kit.svelte.dev/), or SPA + backend frameworks like [Express](https://expressjs.com/), [Fastify](https://fastify.dev/), [NestJS](https://nestjs.com/).\n\n### 1\\. Creating the Project[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#1-creating-the-project \"Direct link to 1. Creating the Project\")\n\nCreate a new Next.js project using `create-t3-app`:\n\n```\nnpx create-t3-app@latest --tailwind --nextAuth --prisma --appRouter --CI my-todo-app\n```\n\nIt sets up a project with the following features:\n\n*   [Next.js](https://nextjs.org/) with app router\n*   TypeScript\n*   Prisma for ORM\n*   [NextAuth.js](https://next-auth.js.org/) for authentication\n*   [Tailwind CSS](https://tailwindcss.com/) for styling\n*   SQLite for database\n\nWe'll also use \"daisyUI\" for UI components. Run the following command to install it:\n\nThen add the \"daisyui\" plugin to `tailwind.config.ts`:\n\n```\nmodule.exports = {  //...  plugins: [require(\"daisyui\")],}\n```\n\nFinally, add some utility packages we'll use later:\n\n### 2\\. Setting Up ZenStack[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#2-setting-up-zenstack \"Direct link to 2. Setting Up ZenStack\")\n\nInitialize the project for ZenStack:\n\nBesides installing dependencies, the command also copies the `prisma/schema.prisma` file to `schema.zmodel`. We're going to continue using the ZModel we've developed in the previous part, but with a few tweaks:\n\n1.  All \"id\" fields are changed to String type (as required by NextAuth).\n2.  The \"markdown\" and \"openapi\" plugins are removed (not needed for this part).\n\nYou can also find the updated version here: [https://github.com/zenstackhq/the-complete-guide-sample/blob/v1-part4-start/schema.zmodel](https://github.com/zenstackhq/the-complete-guide-sample/blob/v1-part4-start/schema.zmodel). Replace the `schema.zmodel` file in your project with it.\n\nRun generation and push the schema to the database:\n\n```\nnpx zenstack generate && npx prisma db push\n```\n\n### 3\\. Implementing Authentication[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#3-implementing-authentication \"Direct link to 3. Implementing Authentication\")\n\n#### 3.1 NextAuth Session Provider[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#31-nextauth-session-provider \"Direct link to 3.1 NextAuth Session Provider\")\n\nTo use NextAuth, we'll need to install a session provider at the root of our app. First, create a file `src/components/SessionProvider.tsx` with the following content:\n\nsrc/components/SessionProvider.tsx\n\n```\n'use client';import { SessionProvider } from 'next-auth/react';import React from 'react';type Props = {  children: React.ReactNode;};function NextAuthSessionProvider({ children }: Props) {  return <SessionProvider>{children}</SessionProvider>;}export default NextAuthSessionProvider;\n```\n\nThen, update the `src/app/layout.tsx` file to use it\n\nsrc/app/layout.tsx\n\n```\nimport NextAuthSessionProvider from '~/components/SessionProvider';export default function RootLayout({ children }: { children: React.ReactNode }) {  return (    <html lang=\"en\">      <body className={`font-sans ${inter.variable}`}>        <NextAuthSessionProvider>{children}</NextAuthSessionProvider>      </body>    </html>  );}\n```\n\n#### 3.2 Credential-Based Auth[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#32-credential-based-auth \"Direct link to 3.2 Credential-Based Auth\")\n\nThe default project created by `create-t3-app` uses Discord OAuth for authentication. We'll replace it with credential-based authentication for simplicity.\n\nReplace the content of `/src/server/auth.ts` with the following:\n\n/src/server/auth.ts\n\n```\nimport { PrismaAdapter } from '@next-auth/prisma-adapter';import type { PrismaClient } from '@prisma/client';import { compare } from 'bcryptjs';import NextAuth, { type DefaultSession, type NextAuthOptions } from 'next-auth';import CredentialsProvider from 'next-auth/providers/credentials';import { db } from './db';declare module 'next-auth' {  interface Session extends DefaultSession {    user: {      id: string;    } & DefaultSession['user'];  }}export const authOptions: NextAuthOptions = {  session: {    strategy: 'jwt',  },  // Include user.id on session  callbacks: {    session({ session, token }) {      if (session.user) {        session.user.id = token.sub!;      }      return session;    },  },  // Configure one or more authentication providers  adapter: PrismaAdapter(db),  providers: [    CredentialsProvider({      credentials: {        email: { type: 'email' },        password: { type: 'password' },      },      authorize: authorize(db),    }),  ],};function authorize(prisma: PrismaClient) {  return async (credentials: Record<'email' | 'password', string> | undefined) => {    if (!credentials?.email) throw new Error('\"email\" is required in credentials');    if (!credentials?.password) throw new Error('\"password\" is required in credentials');    const maybeUser = await prisma.user.findFirst({      where: { email: credentials.email },      select: { id: true, email: true, password: true },    });    if (!maybeUser?.password) return null;    // verify the input password with stored hash    const isValid = await compare(credentials.password, maybeUser.password);    if (!isValid) return null;    return { id: maybeUser.id, email: maybeUser.email };  };}export default NextAuth(authOptions);\n```\n\nRemove code related to `DISCORD_CLIENT_ID` and `DISCORD_CLIENT_SECRET` from `/src/env.js`, and update the `.env` file under project root to the following:\n\n.env\n\n```\nDATABASE_URL=\"file:./db.sqlite\"NEXTAUTH_SECRET=\"abc123\"NEXTAUTH_URL=\"http://localhost:3000\"\n```\n\ninfo\n\nYou should use a strong `NEXTAUTH_SECRET` in a real application.\n\n### 4\\. Mounting the CRUD API[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#4-mounting-the-crud-api \"Direct link to 4. Mounting the CRUD API\")\n\nZenStack uses server adapters to mount CRUD APIs to frameworks, and it has several pre-built adapters for popular frameworks - one of which is Next.js. First, install the server adapter package:\n\n```\nnpm install @zenstackhq/server\n```\n\nThen, create a file `src/app/api/model/[...path]/route.ts` with the following content:\n\nsrc/app/api/model/\\[...path\\]/route.ts\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { NextRequestHandler } from '@zenstackhq/server/next';import { getServerSession } from 'next-auth';import { authOptions } from '~/server/auth';import { db } from '~/server/db';async function getPrisma() {  const session = await getServerSession(authOptions);  return enhance(db, { user: session?.user });}const handler = NextRequestHandler({ getPrisma, useAppDir: true });export { handler as DELETE, handler as GET, handler as PATCH, handler as POST, handler as PUT };\n```\n\ninfo\n\nThe crucial part is that we use an enhanced PrismaClient with the server adapter, so all API calls are automatically subject to the access policies defined in the ZModel schema.\n\nIn the next chapter, we'll learn how to use a plugin to generate frontend data query hooks that help us consume it.\n\nFinally, make a change to the `next.config.js` file to exclude the `@zenstackhq/runtime` package from the server component bundler:\n\nnext.config.js\n\n```\nconst config = {  experimental: {    serverComponentsExternalPackages: ['@zenstackhq/runtime']  }};\n```\n\nWhy is this needed?\n\nNext.js's server component bundler automatically bundles dependencies, but it has some restrictions on the set of Node.js features a package can use. The `@zenstackhq/runtime` package makes [unsupported](https://nextjs.org/docs/app/api-reference/next-config-js/serverComponentsExternalPackages) `require()` calls. We'll try to make it compatible in a future release.\n\n### 5\\. Compile the Project[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/prepare-project#5-compile-the-project \"Direct link to 5. Compile the Project\")\n\nCompile the project and see if everything is working correctly:",
    "title": "🛠️ Creating a Full-Stack Project | ZenStack",
    "description": "To simplify the process of building our full-stack Todo app, we'll recreate the project from scratch using the create-t3-app scaffolding tool - saving us a lot of time manually integrating different tools and libraries. We'll reuse the ZModel schema we built in Part I.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/conclusion",
    "markdown": "# Conclusion | ZenStack\n\nVersion: 1.x\n\nIn this part of the guide, we've focused on using plugins to generate frontend data query hooks and use them to build highly responsive data-driven UIs with ease. We've also evolved our sample project into a fully functional application. There are still a few parts unimplemented (like space member management), but since we've covered all essential ZenStack concepts and features with what we've built, we'll skip them in this guide. You can find the completed source code for this part in the \"main\" branch of [https://github.com/zenstackhq/the-complete-guide-sample](https://github.com/zenstackhq/the-complete-guide-sample).\n\nThere are also variants of the Todo app built with different stacks in the following repositories. They are feature complete and have better UI styling.\n\n*   [Next.js (pages route) + SWR](https://github.com/zenstackhq/sample-todo-nextjs)\n*   [Next.js (pages route) + TanStack Query](https://github.com/zenstackhq/sample-todo-nextjs-tanstack)\n*   [Nuxt + TanStack Query](https://github.com/zenstackhq/sample-todo-nuxt)\n*   [SvelteKit + TanStack Query](https://github.com/zenstackhq/sample-todo-sveltekit)\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
    "title": "Conclusion | ZenStack",
    "description": "In this part of the guide, we've focused on using plugins to generate frontend data query hooks and use them to build highly responsive data-driven UIs with ease. We've also evolved our sample project into a fully functional application. There are still a few parts unimplemented (like space member management), but since we've covered all essential ZenStack concepts and features with what we've built, we'll skip them in this guide. You can find the completed source code for this part in the \"main\" branch of https://github.com/zenstackhq/the-complete-guide-sample.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/guides/authentication/next-auth",
    "markdown": "# Integrating With Auth.js (NextAuth) | ZenStack\n\n[NextAuth](https://next-auth.js.org/) is a comprehensive framework for implementing authentication in Next.js projects. It offers a pluggable mechanism for configuring how user data is persisted.\n\nTo get access policies to work, ZenStack needs to be connected to the authentication system to get the user's identity. This guide introduces tasks required for integrating ZenStack with NextAuth. You can find a complete example [here](https://github.com/zenstackhq/sample-todo-nextjs/tree/v1 \":target=blank\").\n\n### Data model requirement[​](https://zenstack.dev/docs/1.x/guides/authentication/next-auth#data-model-requirement \"Direct link to Data model requirement\")\n\nNextAuth is agnostic about the underlying database type, but it requires specific table structures, depending on how you configure it. Therefore, your ZModel definitions should reflect these requirements. A sample `User` model is shown here (to be used with `CredentialsProvider`):\n\n/schema.zmodel\n\n```\nmodel User {    id String @id @default(cuid())    email String @unique @email    emailVerified DateTime?    password String @password @omit    name String?    image String? @url    // open to signup    @@allow('create', true)    // full access by oneself    @@allow('all', auth() == this)}\n```\n\nYou can find the detailed database model requirements [here](https://next-auth.js.org/adapters/models \":target=blank\").\n\n### Adapter[​](https://zenstack.dev/docs/1.x/guides/authentication/next-auth#adapter \"Direct link to Adapter\")\n\nAdapter is a NextAuth mechanism for hooking in custom persistence of auth-related entities, like User, Account, etc. Since ZenStack is based on Prisma, you can use PrismaAdapter for the job:\n\n/src/pages/api/auth/\\[...nextauth\\].ts\n\n```\nimport { PrismaAdapter } from \"@next-auth/prisma-adapter\";import NextAuth, { type NextAuthOptions } from 'next-auth';import { prisma } from \"../../../server/db/client\";export const authOptions: NextAuthOptions = {    // install Prisma adapter    adapter: PrismaAdapter(prisma),    ...};export default NextAuth(authOptions);\n```\n\nIf you use [`CredentialsProvider`](https://next-auth.js.org/providers/credentials \":target=blank\"), i.e. email/password based auth, you need to implement an `authorize` function for verifying credentials against the database.\n\nThis is standard Prisma stuff, and the following is just a quick example of how to do it:\n\n/src/pages/api/auth/\\[...nextauth\\].ts\n\n```\nimport { prisma } from \"../../../server/db/client\";export const authOptions: NextAuthOptions = {    ...    providers: [        CredentialsProvider({            credentials: {                email: {                    label: 'Email Address',                    type: 'email',                },                password: {                    label: 'Password',                    type: 'password',                },            },            authorize: authorize(prisma),        }),    ]};function authorize(prisma: PrismaClient) {  return async (credentials: Record<\"email\" | \"password\", string> | undefined) => {    if (!credentials) throw new Error(\"Missing credentials\");    if (!credentials.email) throw new Error('\"email\" is required in credentials');    if (!credentials.password) throw new Error('\"password\" is required in credentials');    const maybeUser = await prisma.user.findFirst({      where: { email: credentials.email },      select: { id: true, email: true, password: true },    });    if (!maybeUser || !maybeUser.password) return null;    const isValid = await compare(credentials.password, maybeUser.password);    if (!isValid) {      return null;    }    return { id: maybeUser.id, email: maybeUser.email };  };}\n```\n\n### Create an enhanced Prisma client[​](https://zenstack.dev/docs/1.x/guides/authentication/next-auth#create-an-enhanced-prisma-client \"Direct link to Create an enhanced Prisma client\")\n\nYou can create an enhanced Prisma client which automatically validates access policies, field validation rules etc., during CRUD operations. For more details, please refer to [ZModel Language](https://zenstack.dev/docs/1.x/reference/zmodel-language) reference.\n\nTo create such a client with a standard setup, call the `enhance` API with a regular Prisma client and the current user (fetched with NextAuth API). Here's an example:\n\n```\nimport type { NextApiRequest, NextApiResponse } from 'next';import { getServerSession } from 'next-auth';import { enhance } from '@zenstackhq/runtime';import { authOptions } from '../../pages/api/auth/[...nextauth]';import { prisma } from '../../../server/db/client';async function getPrisma(req: NextApiRequest, res: NextApiResponse) {    const session = await getServerSession(req, res, authOptions);    // create a wrapper of Prisma client that enforces access policy,    // data validation, and @password, @omit behaviors    return enhance(prisma, { user: session?.user });}\n```\n\nYou can then use this enhanced Prisma client for CRUD operations that you desire to be governed by the access policies you defined in your data models.",
    "title": "Integrating With Auth.js (NextAuth) | ZenStack",
    "description": "Integrating with Auth.js.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/optimistic-update",
    "markdown": "# Optimistic Update | ZenStack\n\nOptimistic update is a technique that allows us to update the UI immediately after a user action without waiting for the server response. It's a great way to improve the perceived performance of an application and is especially useful for the parts where users interact with the UI frequently.\n\nLibraries like TanStack Query and SWR provides the framework for developers to implement optimistic update. The approach is essentially to update the query cache immediately after the user action and revert or invalidate the cache after the server response comes back (either success or error). However, similar to the query invalidation problem we discussed in the previous chapter, the challenge is identifying which queries need to be updated and how.\n\nZenStack supports automatic optimistic update for the hooks it generates. It uses a set of rules to update queries and aims to cover the most common use cases. You can find more on how it works [here](https://zenstack.dev/docs/1.x/reference/plugins/tanstack-query#details-of-the-optimistic-behavior).\n\nAutomatic optimistic update is an approximation\n\nIt's often impossible to accurately determine the correct way to update a query cache from the frontend. For example, you may have a query that fetches a filtered list of Todos using the `useFindManyTodo()` hook. When creating a new Todo, we can't precisely determine if the new item should be inserted into the query result (i.e., matching the filter conditions) without querying the database. But paradoxically, the update is no longer optimistic if we query the database.\n\nZenStack takes an \"optimistic\" action here and inserts the new Todo into the query result. It's not always correct, but the worst-case scenario is that the item shows up on the list for a short while until the query is invalidated upon getting the server response.\n\n### 🛠️ Adding Todo Management[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/optimistic-update#%EF%B8%8F-adding-todo-management \"Direct link to 🛠️ Adding Todo Management\")\n\nThe main missing part of our sample app is managing Todos in a List. This is a great place to implement optimistic update because users may add, update, or delete Todos in quick paces, and waiting for the server response to update the UI will result in a very sluggish experience.\n\nLet's first implement the Todo management UI without optimistic update. First, create a component `src/components/TodoComponent.tsx` to manage one single Todo:\n\nsrc/components/TodoComponent.tsx\n\n```\nimport type { Todo } from \"@prisma/client\";import { useDeleteTodo, useUpdateTodo } from \"~/lib/hooks\";type Props = {  value: Todo;  optimistic?: boolean;};export default function TodoComponent({ value, optimistic }: Props) {  const update = useUpdateTodo();  const del = useDeleteTodo();  function onDelete() {    del.mutate({ where: { id: value.id } });  }  function onToggleCompleted(completed: boolean) {    if (completed === !!value.completedAt) {      return;    }    update.mutate({      where: { id: value.id },      data: { completedAt: completed ? new Date() : null },    });  }  return (    <div className=\"flex w-96 flex-col items-center rounded-lg border px-8 py-4\">      <div className=\"flex w-full justify-between\">        <h3          className={`flex items-center text-xl                        ${                          value.completedAt                            ? \"italic text-gray-400 line-through\"                            : \"text-gray-700\"                        }                    }`}        >          {value.title}          {optimistic && (            <span className=\"loading loading-spinner loading-sm ml-1\"></span>          )}        </h3>        <div className=\"flex\">          <input            type=\"checkbox\"            className=\"checkbox mr-2\"            checked={!!value.completedAt}            onChange={(e) => onToggleCompleted(e.currentTarget.checked)}          />          <button className=\"btn btn-ghost btn-xs\" onClick={onDelete}>            Delete          </button>        </div>      </div>    </div>  );}\n```\n\nThen, create a page at `src/app/spaces/[slug]/[listId]/page.tsx` to manage Todos in a List:\n\nsrc/app/spaces/\\[slug\\]/\\[listId\\]/page.tsx\n\n```\n\"use client\";import { useSession } from \"next-auth/react\";import { useParams } from \"next/navigation\";import { useState } from \"react\";import TodoComponent from \"~/components/TodoComponent\";import { useCreateTodo, useFindManyTodo, useFindUniqueList } from \"~/lib/hooks\";export default function TodoList() {  const { listId } = useParams<{ listId: string }>();  const { data: session } = useSession();  const { data: list } = useFindUniqueList(    {      where: { id: listId },    },    { enabled: !!session?.user },  );  const { mutate: create } = useCreateTodo();  const { data: todos } = useFindManyTodo(    {      where: { listId },      orderBy: { createdAt: \"desc\" as const },    },    { enabled: !!session?.user },  );  const [title, setTitle] = useState(\"\");  function onCreate() {    create({      data: {        title,        owner: { connect: { id: session?.user.id } },        list: { connect: { id: listId } },      },    });    setTitle(\"\");  }  if (!session?.user || !list) {    return <></>;  }  return (    <div>      <div className=\"container mx-auto flex w-full flex-col items-center py-12\">        <h1 className=\"mb-4 text-2xl font-semibold\">{list.title}</h1>        <div className=\"flex space-x-2\">          <input            type=\"text\"            placeholder=\"Type a title and press enter\"            className=\"input input-bordered mt-2 w-72 max-w-xs\"            value={title}            autoFocus            onKeyUp={(e) => {              if (e.key === \"Enter\") {                onCreate();              }            }}            onChange={(e) => {              setTitle(e.currentTarget.value);            }}          />        </div>        <ul className=\"flex w-auto flex-col space-y-4 py-8\">          {todos?.map((todo) => (            <TodoComponent              key={todo.id}              value={todo}              optimistic={todo.$optimistic}            />          ))}        </ul>      </div>    </div>  );}\n```\n\nTo simulate usage in the real world, I've enabled Chrome's network throttling to \"Fast 3G\" mode. Here's what it looks like:\n\n![Todo management without optimistic update](https://zenstack.dev/assets/images/todo-mgmt-non-optimistic-e9bea05d48adde85d7afa4da60f01bf0.gif)\n\nIt's obviously very sluggish. It's not something a user wants to pay for.\n\nLet's make some small changes to enable automatic optimistic update. In `src/pages/spaces/[slug]/[listId]/index.tsx`, change the `useCreateTodo` call to the following:\n\n```\n// the three arguments are: //     - mutation options//     - auto invalidate (default true)//     - auto optimistic-update (default false)const { mutate: create } = useCreateTodo(undefined, true, true);\n```\n\nAnd likewise, change the `useUpdateTodo` and `useDeleteTodo` calls in `Todo.tsx` to the following:\n\n```\nconst update = useUpdateTodo(undefined, true, true); // optimistic updateconst del = useDeleteTodo(undefined, true, true); // optimistic update\n```\n\nNow, if we repeat the same test with network throttling, we'll see a much better experience:\n\n![Todo management with optimistic update](https://zenstack.dev/assets/images/todo-mgmt-optimistic-7ab48fdba468dbd916e0b9da99cefe22.gif)\n\nOpt-out of automatic optimistic update\n\nWhen you enable automatic optimistic update for a mutation, it applies to all queries that may be impacted. If this is not desirable, you can pass an extra `optimisticUpdate` argument as `false` to opt out of automatic optimistic update. For example:\n\n```\nconst { data: todos } = useFindManyTodo(    { where: { listId } },    { enabled: !!session?.user },    false, // <- opt-out automatic optimistic update);\n```\n\nWith this change, the `useCreateTodo` mutation will not optimistically update this query even if the mutation is set to do so.",
    "title": "Optimistic Update | ZenStack",
    "description": "Optimistic update is a technique that allows us to update the UI immediately after a user action without waiting for the server response. It's a great way to improve the perceived performance of an application and is especially useful for the parts where users interact with the UI frequently.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/invalidation",
    "markdown": "# Automatic Invalidation | ZenStack\n\nData query libraries like TanStack Query and SWR are essentially cache managers. They cache the data fetched from the server, let you bind it to the UI, and allow you to invalidate the query cache when the data is updated.\n\nIn application development, query invalidation is the developers' job. After making a mutation, a developer should know what queries are impacted, compute their keys, and trigger invalidation. For example, after creating a `Todo`, you'll need to remember to invalidate the queries that directly or indirectly fetch a list of Todos. This can be hard to manage when your app gets more complex.\n\nFortunately, ZenStack can fully automate it for you by exploiting an important fact:\n\n> It knows what mutations impact what kind of queries for the hooks it generates.\n\nFor example, when you use `useCreateTodo()` to create a `Todo`, ZenStack can go through the query cache, identify all queries potentially impacted by the mutation, and invalidate them. For example, a query made with:\n\n```\nuseFindManyList({ include: { todos: true } });\n```\n\nwill be invalidated because it fetches a list of Todos with nested reading.\n\nHow ZenStack uses query keys\n\nZenStack uses a quintuple to form a query key:\n\n```\n['zenstack', model, operation, args, flags]\n```\n\n*   `'zenstack'`: a string literal prefix\n*   `model`: the model name, e.g., \"Todo\"\n*   `operation`: the Prisma operation name, e.g., \"findMany\"\n*   `args`: the arguments passed to the operation, e.g., `{ include: { todos: true } }`\n*   `flags`: a set of flags that further defines the query, e.g., if it's an infinite query, etc\n\nYou usually don't need to use query keys directly, but the generated hooks provide a `getQueryKey` helper function to help you compute them.\n\nIn this chapter, we'll add a `Space` and a `List` management UI to our Todo app and see how the automatic invalidation works in action.\n\n### 🛠️ Adding Space Management[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/invalidation#%EF%B8%8F-adding-space-management \"Direct link to 🛠️ Adding Space Management\")\n\nWe'll use the homepage to manage spaces. Replace the content of `src/app/page.tsx` with the following:\n\nsrc/app/page.tsx\n\n```\n'use client';import { nanoid } from 'nanoid';import type { NextPage } from 'next';import { signOut, useSession } from 'next-auth/react';import Link from 'next/link';import { useCreateSpace, useFindManySpace } from '~/lib/hooks';const Home: NextPage = () => {  const { data: session } = useSession();  const { mutate: createSpace } = useCreateSpace();  const { data: spaces } = useFindManySpace({ orderBy: { createdAt: 'desc' } });  function onCreateSpace() {    const name = prompt('Enter a name for your space');    if (name) {      createSpace({        data: {          name,          slug: nanoid(6),          owner: { connect: { id: session?.user.id } },          // add the creating user as an admin member          members: {            create: {              user: { connect: { id: session?.user.id } },              role: 'ADMIN',            },          },        },      });    }  }  return (    <div className=\"container mx-auto flex justify-center\">      {session?.user ? (        <div className=\"mt-8 flex w-full flex-col items-center\">          <h1 className=\"text-center text-2xl\">            Welcome {session.user.email}{' '}            <button                className=\"btn btn-ghost btn-xs mt-4\"                onClick={() => signOut({ callbackUrl: '/signin' })}            >              Logout            </button>          </h1>          <div className=\"w-full p-8\">            <h2 className=\"mb-8 text-xl\">              Choose a space to start, or{' '}              <button className=\"btn btn-link p-0 text-xl\" onClick={onCreateSpace}>                create a new one.              </button>            </h2>            <ul className=\"flex gap-4\">              {spaces?.map((space) => (                <Link href={`/spaces/${space.slug}`} key={space.id}>                  <li className=\"flex h-32 w-72 items-center justify-center rounded-lg border text-2xl\">                    {space.name}                  </li>                </Link>              ))}            </ul>          </div>        </div>      ) : (        <div>          Please{' '}          <Link href=\"/signin\">            <button className=\"btn btn-link p-0\">login</button>          </Link>{' '}          to get started        </div>      )}    </div>  );};export default Home;\n```\n\nThe key part is the usage of the `useFindManySpace` query hook and the `useCreateSpace` mutation hook. Some quick notes about the logic:\n\n*   Calling `useFindManySpace` is conceptually equivalent to calling `db.space.findMany()` in the backend. The access policies ensure only the spaces readable to the user are returned.\n    \n*   The `onCreateSpace` function shows the flexibility of the hooks. When creating a space, we make a nested write to create a `SpaceUser` record that adds the user as the admin member of the space. The call is also executed in the backend as a nested write, so the two create operations are atomic.\n    \n\nNow, you can head to the homepage and create a few spaces. The UI should look like this:\n\n![Space management](https://zenstack.dev/assets/images/space-mgmt-8392e76dfb277cae09e35132c0760dd9.png)\n\nYou've probably already noticed this: after creating a space, you don't need to refresh the UI to see the result. ZenStack figures out that the `useCreateSpace` mutation can potentially impact the `useFindManySpace` query and automatically invalidates it.\n\nOpt-out of automatic invalidation\n\nWhen calling a mutation hook, you can pass an extra `invalidateQueries` argument as `false` to opt out of automatic invalidation. For example:\n\n```\nconst { mutate: createSpace } = useCreateSpace(undefined, false);\n```\n\nWith this change, the created space won't appear in the list until you refresh the page.\n\n### 🛠️ Adding List Management[​](https://zenstack.dev/docs/1.x/the-complete-guide/part4/invalidation#%EF%B8%8F-adding-list-management \"Direct link to 🛠️ Adding List Management\")\n\nList management is essentially the same as space, so we'll skip the code walkthrough. Here's the content of `src/app/spaces/[slug]/page.tsx`:\n\nsrc/app/spaces/\\[slug\\]/page.tsx\n\n```\n'use client';import { useSession } from 'next-auth/react';import Link from 'next/link';import { useParams } from 'next/navigation';import { useCreateList, useFindManyList, useFindUniqueSpace } from '~/lib/hooks';export default function SpaceHome() {    const { slug } = useParams<{ slug: string }>();    const { data: session } = useSession();    const { data: space } = useFindUniqueSpace({ where: { slug } }, { enabled: !!session?.user });    const { data: lists } = useFindManyList(        {            where: { space: { slug } },            include: { owner: true },            orderBy: { updatedAt: 'desc' },        },        { enabled: !!session?.user },    );    const { mutate: createList } = useCreateList();    function onCreateList() {        const title = prompt('Enter a title for your list');        if (title) {            createList({                data: {                    title,                    space: { connect: { id: space?.id } },                    owner: { connect: { id: session?.user.id } },                },            });        }    }    if (!session?.user || !space || !lists) return null;    return (        <div className=\"container mx-auto mt-16\">            <h1 className=\"text-center text-3xl\">                Welcome to Space <span className=\"italic\">{space.name}</span>            </h1>            <div className=\"p-8\">                <button className=\"btn btn-primary btn-wide\" onClick={onCreateList}>                    Create a list                </button>                <ul className=\"mt-8 flex flex-wrap gap-6\">                    {lists?.map((list) => (                        <Link href={`/spaces/${slug}/${list.id}`} key={list.id}>                            <li className=\"flex h-32 w-72 items-center justify-center rounded-lg border text-2xl\">                                {list.title}                            </li>                        </Link>                    ))}                </ul>            </div>        </div>    );}\n```\n\nThe result should look like this:\n\n![List management](https://zenstack.dev/assets/images/list-mgmt-85e7f4b0f3f41b3751d283e2cbf83f6e.png)",
    "title": "Automatic Invalidation | ZenStack",
    "description": "Data query libraries like TanStack Query and SWR are essentially cache managers. They cache the data fetched from the server, let you bind it to the UI, and allow you to invalidate the query cache when the data is updated.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/guides/authentication/clerk",
    "markdown": "# Integrating With Clerk | ZenStack\n\n[Clerk](https://clerk.com/) is a comprehensive authentication and user management platform, providing both APIs and pre-made UI components.\n\n### Set up Clerk[​](https://zenstack.dev/docs/1.x/guides/authentication/clerk#set-up-clerk \"Direct link to Set up Clerk\")\n\nFirst, follow Clerk's [quick start guides](https://clerk.com/docs/quickstarts/overview) to set up your project.\n\n### Adjust your ZModel[​](https://zenstack.dev/docs/1.x/guides/authentication/clerk#adjust-your-zmodel \"Direct link to Adjust your ZModel\")\n\nSince Clerk manages both user authentication and storage, you don't need to store users in your database anymore. However, since the `auth()` function is resolved to the `User` model in ZModel, you still need to define it in your schema. The trick here is to mark the `User` model as ignored so Prisma doesn't map it to a database table.\n\nYou can include any field you want in the `User` model, as long as you provide the same set of fields in the context object used for creating the enhanced Prisma client.\n\nThe following code shows an example blog post schema:\n\n```\nmodel User {    id String @id    @@ignore}model Post {  id String @id @default(cuid())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title String  published Boolean @default(false)  authorId String // stores Clerk's user ID  // author has full access  @@allow('all', auth() != null && auth().id == authorId)  // logged-in users can view published posts  @@allow('read', auth() != null && published)}\n```\n\nIf you choose to [synchronize user data to your database](https://clerk.com/docs/users/sync-data-to-your-backend), you can model the `User` model as a regular Prisma model without putting the `@@ignore` attribute there.\n\n### Create an enhanced Prisma client[​](https://zenstack.dev/docs/1.x/guides/authentication/clerk#create-an-enhanced-prisma-client \"Direct link to Create an enhanced Prisma client\")\n\nYou can create an enhanced Prisma client that automatically validates access policies, field validation rules, etc., during CRUD operations. For more details, please refer to [ZModel Language](https://zenstack.dev/docs/1.x/reference/zmodel-language) reference.\n\nTo create such a client with a standard setup, call the `enhance` API with a regular Prisma client and the current user (fetched from Clerk). Here's an example:\n\n```\nimport type { NextApiRequest } from 'next';import { enhance } from '@zenstackhq/runtime';import { getAuth } from '@clerk/nextjs/server';import { prisma } from '../lib/db';async function getPrisma(req: NextApiRequest) {    const auth = getAuth(req);    // create a wrapper of Prisma client that enforces access policy,    // data validation, and @password, @omit behaviors    return enhance(prisma, { user: auth ? { id: auth.userId } : undefined });}\n```\n\n* * *\n\nYou can find a working sample project [here](https://github.com/zenstackhq/docs-tutorial-clerk/tree/v1).",
    "title": "Integrating With Clerk | ZenStack",
    "description": "Integrating with Clerk.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part4/auth-ui",
    "markdown": "# 🛠️ Building Authentication UI | ZenStack\n\n```\n'use client';import { signIn } from 'next-auth/react';import Link from 'next/link';import { useState, type FormEvent } from 'react';import { useCreateUser } from '~/lib/hooks';export default function Signup() {  const [email, setEmail] = useState('');  const [password, setPassword] = useState('');  const { mutate: signup, error: signupError } = useCreateUser({    onSuccess: async () => {      // sign-up succeeded, sign in with the credentials      const signInResult = await signIn('credentials', {        redirect: false,        email,        password,      });      if (signInResult?.ok) {        window.location.href = '/';      } else {        console.error('Signin failed:', signInResult?.error);      }    },  });  const _err = signupError as { info?: { code?: string } };  const errMsg = _err    ? _err.info?.code === 'P2002' // P2002 is the Prisma error code for unique constraint failure      ? 'Email already exists'      : `Unexpected error occurred: ${JSON.stringify(_err)}`    : '';  function onSignup(e: FormEvent<HTMLFormElement>) {    e.preventDefault();    signup({ data: { email, password } });  }  return (    <div className=\"mx-auto flex h-screen flex-col items-center justify-center\">      <div className=\"mb-10 flex items-center space-x-4\">        <h1 className=\"text-4xl\">Welcome to Todo</h1>      </div>      <div className=\"flex w-full max-w-screen-sm items-center justify-center rounded-lg\">        <div className=\"w-full space-y-8 p-16\">          <h2 className=\"text-3xl font-bold\">Create a Free Account</h2>          <form className=\"mt-8 space-y-6\" action=\"#\" onSubmit={onSignup}>            <div>              <label htmlFor=\"email\" className=\"label\">                Your email              </label>              <input                type=\"email\"                value={email}                onChange={(e) => setEmail(e.target.value)}                className=\"input input-bordered w-full\"                placeholder=\"Email address\"                required              />            </div>            <div>              <label htmlFor=\"password\" className=\"label\">                Your password              </label>              <input                type=\"password\"                value={password}                onChange={(e) => setPassword(e.target.value)}                placeholder=\"••••••••\"                className=\"input input-bordered w-full\"                required              />            </div>            {errMsg && <p className=\"text-sm text-red-600\">{errMsg}</p>}            <button className=\"btn btn-primary mt-4\" type=\"submit\">              Create account            </button>            <div>              Already have an account?{' '}              <Link href=\"/signin\" className=\"text-primary\">                Login here              </Link>            </div>          </form>        </div>      </div>    </div>  );}\n```",
    "title": "🛠️ Building Authentication UI | ZenStack",
    "description": "The TanStack Query hooks generated in the previous chapter provide all the data-access building blocks for implementing the UI. Let's first use it to implement the authentication UI.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/guides/authentication/supabase",
    "markdown": "# Integrating With Supabase Auth | ZenStack\n\n[Supabase](https://supabase.com/) is a comprehensive Backend-as-a-Service that offers database, authentication, and blob services.\n\nTo get access policies to work, ZenStack needs to be connected to the authentication system to get the user's identity. If you use Supabase as your authentication provider, this document will guide you through integrating ZenStack with it.\n\n### Using Prisma with Supabase[​](https://zenstack.dev/docs/1.x/guides/authentication/supabase#using-prisma-with-supabase \"Direct link to Using Prisma with Supabase\")\n\ninfo\n\nThis section is only relevant if you're also using Supabase's Database service as the underlying Postgres database of Prisma/ZenStack.\n\nThis section is not directly to integrating authentication, but since ZenStack is based on Prisma, understanding how Prisma and Supabase should be set up appropriately when Supabase Auth is involved is important.\n\nSupabase Auth stores user data in a separate Postgres schema called \"auth\". Since that schema is managed by Supabase, it's good idea not to directly import it into ZModel and use it in your application, since Supabase team may decide to change table schemas at any time. Instead, a better approach is to define your own `User` model in ZModel, and use database triggers to synchronize user data from Supabase Auth to your `User` table.\n\n**Schema:**\n\nschema.zmodel\n\n```\nmodel User {    id String @id @db.Uuid    posts Post[]    ... // other fields    @@allow('read', true)}model Post {    id String @id @db.Uuid    title String    author User @relation(fields: [authorId], references: [id])    authorId String @db.Uuid    @@allow('all', author == auth())}\n```\n\n**Database trigger (for synchronizing new users):**\n\nYou can check [here](https://supabase.com/docs/guides/database/postgres/triggers) for a general introduction about triggers in Supabase. The following code shows how to use it to synchronize new users:\n\n```\n-- inserts a row into public.\"User\"create function public.handle_new_user()returns triggerlanguage plpgsqlsecurity definer set search_path = publicas $$begin  insert into public.\"User\" (id)  values (new.id);  return new;end;$$;-- trigger the function every time a user is createdcreate trigger on_auth_user_created  after insert on auth.users  for each row execute procedure public.handle_new_user();\n```\n\nSimilarly you can implement more triggers to synchronize user update and delete. Find more information about this approach [here](https://supabase.com/docs/guides/auth/managing-user-data#using-triggers).\n\nWith these in place, your own `User` table will be always in sync with Supabase Auth, and in your application, your other entities will have relations to the `User` table instead of pointing to Supabase Auth's internal tables.\n\n### Creating an enhanced Prisma client[​](https://zenstack.dev/docs/1.x/guides/authentication/supabase#creating-an-enhanced-prisma-client \"Direct link to Creating an enhanced Prisma client\")\n\nTo get ZenStack's access policies to work, you need to create an enhanced `PrismaClient` with a current user context. The way to fetch \"current user\" on the server side depends on the type of server you're using. Supabase provides a set of [auth helpers](https://supabase.com/docs/guides/auth/auth-helpers) for different frameworks. For example, if you're following [this guide](https://supabase.com/docs/guides/auth/auth-helpers/nextjs) to use Supabase Auth with Next.js (app router), you can create an enhanced `PrismaClient` using `@supabase/auth-helpers-nextjs` like the following:\n\n```\nimport { enhance } from '@zenstackhq/runtime';import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';import { prisma } from '@lib/db';// create a wrapper of Prisma client that enforces access policy,// data validation, and @password, @omit behaviorsasync function getPrisma() {    const supabase = createRouteHandlerClient({ cookies });    const { data: user } = await supabase.auth.getUser();    const uid = user.user?.id;    // TODO: if you need to access fields other than just \"id\" in access policies,     // you can do a database query here to fetch the full user record    const contextUser = uid ? { id: uid } : undefined;    return enhance(prisma, { user: contextUser });}\n```\n\nYou can then use this enhanced Prisma client for CRUD operations that you desire to be governed by the access policies you defined in your data models.\n\nNext, make sure to read [this guide](https://zenstack.dev/docs/1.x/guides/supabase-security) to ensure your database is securely protected from HTTP requests to the supabase API.",
    "title": "Integrating With Supabase Auth | ZenStack",
    "description": "Integrating with Supabase Auth.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/api-flavor/",
    "markdown": "# API Flavors | ZenStack\n\nVersion: 1.x\n\nAPI design is a complex topic. While thinking about wrapping CRUD APIs around ORM, we feel there are two main competing goals:\n\n*   Query flexibility\n    \n    Prisma's API is very flexible, especially regarding nested reads and writes. It'd be nice to preserve this flexibility fully in the derived APIs. This way, you can also carry your knowledge of using Prisma over to using the APIs.\n    \n*   RESTfulness\n    \n    When designing CRUD APIs, making it RESTful is a natural choice. Resource-oriented URLs and semantic HTTP verbs match the problem well. While RESTful APIs traditionally suffer from the [N + 1 Problem](https://restfulapi.net/rest-api-n-1-problem/) (as traditionally ORM did, too), there are some conventions we can use to mitigate it.\n    \n\nIt is tough to choose one over the other. So, we decided to provide both API flavors. You can choose the one that fits your use case better.\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
    "title": "API Flavors | ZenStack",
    "description": "API design is a complex topic. While thinking about wrapping CRUD APIs around ORM, we feel there are two main competing goals:",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/guides/authentication/auth0",
    "markdown": "# 🚧 Integrating With Auth0 | ZenStack\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
    "title": "🚧 Integrating With Auth0 | ZenStack",
    "description": "Integrating with Auth0.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/the-complete-guide/part3/api-flavor/1.1-rpc",
    "markdown": "# RPC Flavor API | ZenStack\n\nThe RPC flavor of API is designed to fully preserve Prisma's query API for both its input and output format. The name \"RPC\" indicates it's literally like remote procedure calls into a Prisma Client. This API flavor is a good choice if you want to expose Prisma's full power and familiar query syntax to your frontend and care less about API taxonomy.\n\n```\n// find all postsGET /api/model/post/findMany=> [{ id: 1, title: 'Hello World', ... }, ...}]// find all published posts, the \"q\" parameter is `{\"where\":{\"published\":true}}` url-encodedGET /api/model/post/findMany?q=%7B%22where%22%3A%7B%22published%22%3Atrue%7D%7D=> [{ id: 1, title: 'Hello World', ... }, ...}]// find all posts with their authors, the \"q\" parameter is `{\"include\":{\"author\":true}}` url-encodedGET /api/model/post/findMany?q=%7B%22include%22%3A%7B%22author%22%3Atrue%7D%7D=> [{ id: 1, title: 'Hello World', author: { id: 1, name: 'Joey', ... } }, ...}]// create a post for user#1POST /api/model/post/create{    \"data\": {        \"title\": \"Hello World\",        \"author\": { \"connect\": { \"id\": 1 } }    }}// update a postPOST /api/model/post/update{    \"where\": { \"id\": 1 },    \"data\": { \"title\": \"Hello New World!\" }}// delete a postDELETE /api/model/post/delete{    \"where\": { \"id\": 1 }}\n```\n\nIn [Part IV](https://zenstack.dev/docs/the-complete-guide/part4/) of this guide, you'll see how to use the auto-generated frontend data query hooks to consume the API, so you don't need to construct the HTTP calls manually.",
    "title": "RPC Flavor API | ZenStack",
    "description": "The RPC flavor of API is designed to fully preserve Prisma's query API for both its input and output format. The name \"RPC\" indicates it's literally like remote procedure calls into a Prisma Client. This API flavor is a good choice if you want to expose Prisma's full power and familiar query syntax to your frontend and care less about API taxonomy.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/guides/authentication/lucia",
    "markdown": "# 🚧 Integrating With Lucia | ZenStack\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
    "title": "🚧 Integrating With Lucia | ZenStack",
    "description": "Integrating with Lucia.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/api-flavor/1.3-api-handler",
    "markdown": "# API Handlers | ZenStack\n\nAlthough many different backend and full-stack frameworks exist in the Javascript world, how APIs are designed is entirely independent. We've implemented the API flavors as framework-agnostic API handlers. They take canonical input (HTTP verb, URL, body, etc.) and generate canonical output (status code and body).\n\nThe server adapters, as we will see in the next chapter, are responsible for dealing with the framework details and handling the transformation between the framework-specific request/response and the canonical format. If, in the future, we want to introduce a new API flavor, we don't need to change the server adapters.\n\nThe following diagram depicts the relationship between the API handlers and the server adapters:\n\n![ZModel Generation](https://zenstack.dev/img/intro/api-handler-light.png)![ZModel Generation](https://zenstack.dev/img/intro/api-handler-dark.png)",
    "title": "API Handlers | ZenStack",
    "description": "Although many different backend and full-stack frameworks exist in the Javascript world, how APIs are designed is entirely independent. We've implemented the API flavors as framework-agnostic API handlers. They take canonical input (HTTP verb, URL, body, etc.) and generate canonical output (status code and body).",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/the-complete-guide/part3/api-flavor/1.2-rest",
    "markdown": "# RESTful Flavor API | ZenStack\n\nThe RESTful flavor of API is designed to rigorously follow the RESTful conventions - resources, verbs, and links for further navigation based on the result dataset. It's a good choice if you want to expose a formal RESTful API to your client. The API adopts [JSON:API](https://jsonapi.org/format/) as data format.\n\n```\n// find all postsGET /api/model/post=> {    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        { \"type\": \"post\", \"id\": \"1\", \"attributes\": { \"title\": \"Hello World\", ... }, ... },        ...    ],    ...}// find all published postsGET /api/model/post?filter[published]=true=>{    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        { \"type\": \"post\", \"id\": \"1\", \"attributes\": { \"title\": \"Hello World\", ... }, ... },        ...    ],    ...}// find all posts with their authorsGET /api/model/post?include=author=>{    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        {             \"type\": \"post\",             \"id\": \"1\",             \"attributes\": { \"title\": \"Hello World\", ... },            \"relationships\": {                \"author\": { \"data\": { \"type\": \"user\", \"id\": \"1\" } }            }        },        ...    ],    \"included\": [        { \"type\": \"user\", \"id\": \"1\", \"attributes\": { \"name\": \"Joey\", ... } },        ...    ],    ...}// create a post for user#1POST /api/model/post{    \"data\": {        \"type\": \"post\",        \"attributes\": {            \"title\": \"Hello World\"        },        \"relationships\": {            \"author\": { \"data\": { \"type\": \"user\", \"id\": \"1\" } }        }    }}// update a postPATCH /api/model/post/1{    \"data\": {        \"type\": \"post\",        \"id\": \"1\",        \"attributes\": {            \"title\": \"Hello New World!\"        }    }}// delete a postDELETE /api/model/post/1\n```",
    "title": "RESTful Flavor API | ZenStack",
    "description": "The RESTful flavor of API is designed to rigorously follow the RESTful conventions - resources, verbs, and links for further navigation based on the result dataset. It's a good choice if you want to expose a formal RESTful API to your client. The API adopts JSON:API as data format.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/api-flavor/1.1-rpc",
    "markdown": "# RPC Flavor API | ZenStack\n\nThe RPC flavor of API is designed to fully preserve Prisma's query API for both its input and output format. The name \"RPC\" indicates it's literally like remote procedure calls into a Prisma Client. This API flavor is a good choice if you want to expose Prisma's full power and familiar query syntax to your frontend and care less about API taxonomy.\n\n```\n// find all postsGET /api/model/post/findMany=> [{ id: 1, title: 'Hello World', ... }, ...}]// find all published posts, the \"q\" parameter is `{\"where\":{\"published\":true}}` url-encodedGET /api/model/post/findMany?q=%7B%22where%22%3A%7B%22published%22%3Atrue%7D%7D=> [{ id: 1, title: 'Hello World', ... }, ...}]// find all posts with their authors, the \"q\" parameter is `{\"include\":{\"author\":true}}` url-encodedGET /api/model/post/findMany?q=%7B%22include%22%3A%7B%22author%22%3Atrue%7D%7D=> [{ id: 1, title: 'Hello World', author: { id: 1, name: 'Joey', ... } }, ...}]// create a post for user#1POST /api/model/post/create{    \"data\": {        \"title\": \"Hello World\",        \"author\": { \"connect\": { \"id\": 1 } }    }}// update a postPOST /api/model/post/update{    \"where\": { \"id\": 1 },    \"data\": { \"title\": \"Hello New World!\" }}// delete a postDELETE /api/model/post/delete{    \"where\": { \"id\": 1 }}\n```\n\nIn [Part IV](https://zenstack.dev/docs/1.x/the-complete-guide/part4/) of this guide, you'll see how to use the auto-generated frontend data query hooks to consume the API, so you don't need to construct the HTTP calls manually.",
    "title": "RPC Flavor API | ZenStack",
    "description": "The RPC flavor of API is designed to fully preserve Prisma's query API for both its input and output format. The name \"RPC\" indicates it's literally like remote procedure calls into a Prisma Client. This API flavor is a good choice if you want to expose Prisma's full power and familiar query syntax to your frontend and care less about API taxonomy.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/the-complete-guide/part3/api-flavor/1.3-api-handler",
    "markdown": "# API Handlers | ZenStack\n\nAlthough many different backend and full-stack frameworks exist in the Javascript world, how APIs are designed is entirely independent. We've implemented the API flavors as framework-agnostic API handlers. They take canonical input (HTTP verb, URL, body, etc.) and generate canonical output (status code and body).\n\nThe server adapters, as we will see in the next chapter, are responsible for dealing with the framework details and handling the transformation between the framework-specific request/response and the canonical format. If, in the future, we want to introduce a new API flavor, we don't need to change the server adapters.\n\nThe following diagram depicts the relationship between the API handlers and the server adapters:\n\n![ZModel Generation](https://zenstack.dev/img/intro/api-handler-light.png)![ZModel Generation](https://zenstack.dev/img/intro/api-handler-dark.png)",
    "title": "API Handlers | ZenStack",
    "description": "Although many different backend and full-stack frameworks exist in the Javascript world, how APIs are designed is entirely independent. We've implemented the API flavors as framework-agnostic API handlers. They take canonical input (HTTP verb, URL, body, etc.) and generate canonical output (status code and body).",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part1/debugging",
    "markdown": "# Debugging | ZenStack\n\nVersion: 1.x\n\nZenStack provides you with a set of powerful tools to model the authorization aspects of your application. However, it can be challenging to understand why an operation is rejected or why a query gives seemingly incorrect results.\n\nYou can let ZenStack log all queries sent to the wrapped Prisma Client and use it to inspect the effect of your policy rules. To enable the logging, pass an extra `logPrismaQuery` option when calling the `enhance` function:\n\n```\nconst db = enhance(prisma, { user }, { logPrismaQuery: true });\n```\n\nThe logs are output to the logger of Prisma Client with \"info\" level, so to be able to see it on the console, you'll also need to make sure it's turned on in the Prisma Client options:\n\n```\nconst prisma = new PrismaClient({ log: ['info'] });\n```\n\nAfter setting these up, you should be able to see all Prisma queries ZenStack makes in the console.\n\n### 🛠️ Debugging In REPL[​](https://zenstack.dev/docs/1.x/the-complete-guide/part1/debugging#%EF%B8%8F-debugging-in-repl \"Direct link to 🛠️ Debugging In REPL\")\n\nThe REPL environment provides a \".debug\" command to turn on/off debugging output on the fly.\n\n```\n.auth { id: 1 }.debugdb.list.findMany()\n```\n\nYou should see the Prisma queries injected by ZenStack printed in the console.\n\n```\nprisma:info [policy] `findMany` list:{  where: {    AND: [      { NOT: { OR: [] } },      {        OR: [          { owner: { is: { id: 1 } } },          {            AND: [              {                space: {                  members: {                    some: { user: { is: { id: 1 } } }                  }                }              },              { NOT: { private: true } }            ]          }        ]      }    ]  }}\n```\n\n###### Comments\n\nFeel free to ask questions, give feedback, or report issues.\n\nDon't Spam\n\n* * *\n\nYou can edit/delete your comments by going directly to the discussion, clicking on the 'comments' link below",
    "title": "Debugging | ZenStack",
    "description": "ZenStack provides you with a set of powerful tools to model the authorization aspects of your application. However, it can be challenging to understand why an operation is rejected or why a query gives seemingly incorrect results.",
    "languageCode": "en"
  },
  {
    "url": "https://zenstack.dev/docs/1.x/the-complete-guide/part3/api-flavor/1.2-rest",
    "markdown": "# RESTful Flavor API | ZenStack\n\nThe RESTful flavor of API is designed to rigorously follow the RESTful conventions - resources, verbs, and links for further navigation based on the result dataset. It's a good choice if you want to expose a formal RESTful API to your client. The API adopts [JSON:API](https://jsonapi.org/format/) as data format.\n\n```\n// find all postsGET /api/model/post=> {    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        { \"type\": \"post\", \"id\": \"1\", \"attributes\": { \"title\": \"Hello World\", ... }, ... },        ...    ],    ...}// find all published postsGET /api/model/post?filter[published]=true=>{    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        { \"type\": \"post\", \"id\": \"1\", \"attributes\": { \"title\": \"Hello World\", ... }, ... },        ...    ],    ...}// find all posts with their authorsGET /api/model/post?include=author=>{    \"jsonapi\": { \"version\": \"1.0\" },    \"data\": [        {             \"type\": \"post\",             \"id\": \"1\",             \"attributes\": { \"title\": \"Hello World\", ... },            \"relationships\": {                \"author\": { \"data\": { \"type\": \"user\", \"id\": \"1\" } }            }        },        ...    ],    \"included\": [        { \"type\": \"user\", \"id\": \"1\", \"attributes\": { \"name\": \"Joey\", ... } },        ...    ],    ...}// create a post for user#1POST /api/model/post{    \"data\": {        \"type\": \"post\",        \"attributes\": {            \"title\": \"Hello World\"        },        \"relationships\": {            \"author\": { \"data\": { \"type\": \"user\", \"id\": \"1\" } }        }    }}// update a postPATCH /api/model/post/1{    \"data\": {        \"type\": \"post\",        \"id\": \"1\",        \"attributes\": {            \"title\": \"Hello New World!\"        }    }}// delete a postDELETE /api/model/post/1\n```",
    "title": "RESTful Flavor API | ZenStack",
    "description": "The RESTful flavor of API is designed to rigorously follow the RESTful conventions - resources, verbs, and links for further navigation based on the result dataset. It's a good choice if you want to expose a formal RESTful API to your client. The API adopts JSON:API as data format.",
    "languageCode": "en"
  }
]