[
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql",
    "markdown": "# Schema Incompatibilities | PostgreSQL | Prisma Documentation\n\n## Overview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#overview \"Direct link to Overview\")\n\nEach section on this page describes a potential problem when upgrading from Prisma 1 to Prisma ORM 2._x_ and later and explains the available workarounds.\n\n## Default values aren't represented in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#default-values-arent-represented-in-database \"Direct link to Default values aren't represented in database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem \"Direct link to Problem\")\n\nWhen adding the `@default` directive in a Prisma 1 datamodel, the default values for this field are generated by the Prisma 1 server at runtime. There's no `DEFAULT` constraint added to the database column. Because this constraint is not reflected in the database itself, the Prisma ORM 2._x_ and later versions of introspection can't recognize it.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-datamodel \"Direct link to Prisma 1 datamodel\")\n\n```\ntype Post {  id: ID! @id  published: Boolean @default(value: false)}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  published BOOLEAN NOT NULL);\n```\n\n#### Result of introspection in Prisma ORM versions 2._x_ and later[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-introspection-in-prisma-orm-versions-2x-and-later \"Direct link to result-of-introspection-in-prisma-orm-versions-2x-and-later\")\n\nschema.prisma\n\n```\nmodel Post {  id        String  @id  published Boolean}\n```\n\nBecause the `DEFAULT` constraint has not been added to the database when mapping the Prisma 1 datamodel to the database with `prisma deploy`, Prisma ORM v2 (and later versions) doesn't recognize it during introspection.\n\n### Workarounds[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workarounds \"Direct link to Workarounds\")\n\n#### Manually add a `DEFAULT` constraint to the database column[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#manually-add-a-default-constraint-to-the-database-column \"Direct link to manually-add-a-default-constraint-to-the-database-column\")\n\nYou can alter the column to add the `DEFAULT` constraint as follows:\n\n```\nALTER TABLE \"Post\"\tALTER COLUMN published SET DEFAULT false;\n```\n\nAfter this adjustment, you can re-introspect your database and the `@default` attribute will be added to the `published` field:\n\nschema.prisma\n\n```\nmodel Post {  id        String  @id  published Boolean @default(false)}\n```\n\n#### Manually add a `@default` attribute to the Prisma model[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#manually-add-a-default-attribute-to-the-prisma-model \"Direct link to manually-add-a-default-attribute-to-the-prisma-model\")\n\nYou can add the `@default` attribute to the Prisma model:\n\nschema.prisma\n\n```\nmodel Post {  id        String  published Boolean @default(false)}\n```\n\nIf the `@default` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will generate the specified default values at runtime (similar to what the Prisma 1 server did in Prisma 1).\n\n## Generated CUIDs as ID values aren't represented in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#generated-cuids-as-id-values-arent-represented-in-database \"Direct link to Generated CUIDs as ID values aren't represented in database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem-1 \"Direct link to Problem\")\n\nPrisma 1 auto-generates ID values as CUIDs for `ID` fields when they're annotated with the `@id` directive. These CUIDs are generated by the Prisma 1 server at runtime. Because this behavior is not reflected in the database itself, the introspection in Prisma ORM 2._x_ and later can't recognize it.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example-1 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-datamodel-1 \"Direct link to Prisma 1 datamodel\")\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration-1 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);\n```\n\n#### Result of introspection in Prisma ORM versions 2._x_ and later[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-introspection-in-prisma-orm-versions-2x-and-later-1 \"Direct link to result-of-introspection-in-prisma-orm-versions-2x-and-later-1\")\n\nschema.prisma\n\n```\nmodel Post {  id String @id}\n```\n\nBecause there's no indication of the CUID behavior in the database, Prisma ORM's introspection doesn't recognize it.\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workaround \"Direct link to Workaround\")\n\nAs a workaround, you can manually add the `@default(cuid())` attribute to the Prisma model:\n\nschema.prisma\n\n```\nmodel Post {  id String @id @default(cuid())}\n```\n\nIf the `@default` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will generate the specified default values at runtime (similar to what the Prisma 1 server did in Prisma 1).\n\nNote that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!\n\n## `@createdAt` isn't represented in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#createdat-isnt-represented-in-database \"Direct link to createdat-isnt-represented-in-database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem-2 \"Direct link to Problem\")\n\nPrisma 1 auto-generates values for `DateTime` fields when they're annotated with the `@createdAt` directive. These values are generated by the Prisma 1 server at runtime. Because this behavior is not reflected in the database itself, the introspection in Prisma ORM 2._x_ and later can't recognize it.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example-2 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-datamodel-2 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype Post {  id: ID! @id  createdAt: DateTime! @createdAt}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration-2 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  \"createdAt\" TIMESTAMP NOT NULL);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-introspection-in-prisma-orm-2x-and-later-versions \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions\")\n\nschema.prisma\n\n```\nmodel Post {  id        String   @id  createdAt DateTime}\n```\n\n### Workarounds[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workarounds-1 \"Direct link to Workarounds\")\n\n#### Manually add `DEFAULT CURRENT_TIMESTAMP` to the database column[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#manually-add-default-current_timestamp-to-the-database-column \"Direct link to manually-add-default-current_timestamp-to-the-database-column\")\n\nYou can alter the column to add the `DEFAULT` constraint as follows:\n\n```\nALTER TABLE \"Post\"\tALTER COLUMN \"createdAt\" SET DEFAULT CURRENT_TIMESTAMP;\n```\n\nAfter this adjustment, you can re-introspect your database and the `@default` attribute will be added to the `createdAt` field:\n\nschema.prisma\n\n```\nmodel Post {  id        String  createdAt DateTime @default(now())}\n```\n\n#### Manually add the `@default(now())` attribute to the Prisma model[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#manually-add-the-defaultnow-attribute-to-the-prisma-model \"Direct link to manually-add-the-defaultnow-attribute-to-the-prisma-model\")\n\nAs a workaround, you can manually add the `@default(now())` attribute to the Prisma model:\n\nschema.prisma\n\n```\nmodel Post {  id        String   @id  createdAt DateTime @default(now())}\n```\n\nIf the `@default` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will generate the specified default values at runtime (similar to what the Prisma 1 server did in Prisma 1).\n\nNote that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!\n\n## `@updatedAt` isn't represented in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#updatedat-isnt-represented-in-database \"Direct link to updatedat-isnt-represented-in-database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem-3 \"Direct link to Problem\")\n\nPrisma 1 auto-generates values for `DateTime` fields when they're annotated with the `@updatedAt` directive. These values are generated by the Prisma 1 server at runtime. Because this behavior is not reflected in the database itself, the introspection in Prisma ORM 2._x_ and later can't recognize it..\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example-3 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-datamodel-3 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype Post {  id: ID! @id  updatedAt: DateTime! @updatedAt}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration-3 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  updatedAt TIMESTAMP);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-introspection-in-prisma-orm-2x-and-later-versions-1 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-1\")\n\nschema.prisma\n\n```\nmodel Post {  id        String   @id  updatedAt DateTime}\n```\n\n### Workarounds[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workarounds-2 \"Direct link to Workarounds\")\n\n#### Manually add the `@updatedAt` attribute to the Prisma model[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#manually-add-the-updatedat-attribute-to-the-prisma-model \"Direct link to manually-add-the-updatedat-attribute-to-the-prisma-model\")\n\nAs a workaround, you can manually add the `@updatedAt` attribute to the Prisma model:\n\nschema.prisma\n\n```\nmodel Post {  id        String   @id  updatedAt DateTime @updatedAt}\n```\n\nIf the `@updatedAt` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will automatically generate values for this column when an existing record is updated (similar to what the Prisma 1 server did in Prisma 1).\n\nNote that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!\n\n## Inline 1-1 relations are recognized as 1-n (missing `UNIQUE` constraint)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint \"Direct link to inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem-4 \"Direct link to Problem\")\n\nIn the [datamodel v1.1](https://www.prisma.io/blog/datamodel-v11-lrzqy1f56c90) that was introduced in Prisma ORM v1.31, 1-1 relations can be declared as _inline_. In that case, the relation will not be maintained via a [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) but via a single foreign key on one of the two tables involved.\n\nWhen this approach is used, Prisma ORM doesn't add a `UNIQUE` constraint to the foreign key column which means that after introspection in Prisma ORM version 2._x_ and later, this former 1-1 relation will be added as a 1-n relation to the Prisma schema.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example-4 \"Direct link to Example\")\n\n#### Prisma ORM datamodel v1.1 (available from Prisma ORM v1.31)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-orm-datamodel-v11-available-from-prisma-orm-v131 \"Direct link to Prisma ORM datamodel v1.1 (available from Prisma ORM v1.31)\")\n\n```\ntype User {  id: ID! @id  profile: Profile @relation(link: INLINE)}type Profile {  id: ID! @id  user: User}\n```\n\nNote that omitting the `@relation` directive in this case would result in the same behavior because `link: INLINE` is the _default_ for 1-1 relations.\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration-4 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);CREATE TABLE \"Profile\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  \"user\" VARCHAR(25),  FOREIGN KEY (\"user\") REFERENCES \"User\"(id));\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-introspection-in-prisma-orm-2x-and-later-versions-2 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-2\")\n\nschema.prisma\n\n```\nmodel User {  id      String    @id  Profile Profile[]}model Profile {  id   String  @id  user String?  User User?   @relation(fields: [user], references: [id])}\n```\n\nBecause there's no `UNIQUE` constraint defined on the `user` column (which represents the foreign key in this relation), Prisma ORM's introspection recognizes the relation as 1-n.\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workaround-1 \"Direct link to Workaround\")\n\n#### Manually add `UNIQUE` constraint to the foreign key column[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#manually-add-unique-constraint-to-the-foreign-key-column \"Direct link to manually-add-unique-constraint-to-the-foreign-key-column\")\n\nYou can alter the foreign key column to add the `UNIQUE` constraint as follows:\n\n```\nALTER TABLE \"Profile\"  ADD CONSTRAINT userId_unique UNIQUE (\"user\");\n```\n\nAfter this adjustment, you can re-introspect your database and the 1-1 relation will be properly recognized:\n\nschema.prisma\n\n```\nmodel User {  id      String   @id  Profile Profile?}model Profile {  id   String  @id  user String? @unique  User User?   @relation(fields: [user], references: [id])}\n```\n\n## _All_ non-inline relations are recognized as m-n[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#all-non-inline-relations-are-recognized-as-m-n \"Direct link to all-non-inline-relations-are-recognized-as-m-n\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem-5 \"Direct link to Problem\")\n\nPrisma 1 represents relations as relation tables most of the time:\n\n*   All relations in the Prisma 1 **datamodel v1.0** are represented as relation tables\n*   In **datamodel v1.1**, all m-n relations as well as the 1-1 and 1-n relations declared as `link: TABLE` are represented as relation tables.\n\nBecause of this representation, introspection in Prisma ORM version 2._x_ and later will recognize all these relations as m-n relations, even though they might have been declared as 1-1 or 1-n in Prisma 1.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example-5 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-datamodel-4 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype User {  id: ID! @id  posts: [Post!]!}type Post {  id: ID! @id  author: User! @relation(link: TABLE)}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration-5 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);CREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);CREATE TABLE \"_PostToUser\" (  \"A\" VARCHAR(25) NOT NULL REFERENCES \"Post\"(id) ON DELETE CASCADE,  \"B\" VARCHAR(25) NOT NULL REFERENCES \"User\"(id) ON DELETE CASCADE);CREATE UNIQUE INDEX \"_PostToUser_AB_unique\" ON \"_PostToUser\"(\"A\" text_ops,\"B\" text_ops);CREATE INDEX \"_PostToUser_B\" ON \"_PostToUser\"(\"B\" text_ops);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-introspection-in-prisma-orm-2x-and-later-versions-3 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-3\")\n\nschema.prisma\n\n```\nmodel User {  id   String @id  Post Post[] @relation(references: [id])}model Post {  id   String @id  User User[] @relation(references: [id])}\n```\n\nBecause the relation table that was created by Prisma 1 uses the same [conventions for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations) as in Prisma ORM version 2._x_ and later, the relation now gets recognized as a m-n relation.\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workaround-2 \"Direct link to Workaround\")\n\nAs a workaround, you can migrate the data into a structure that's compatible with Prisma ORM's 1-n relation:\n\n1.  Create new column `authorId` on the `Post` table. This column should be a _foreign key_ that references the `id` field of the `User` table:\n    \n    ```\n    ALTER TABLE \"Post\"  ADD COLUMN \"authorId\" VARCHAR(25);ALTER TABLE \"Post\"ADD CONSTRAINT fk_authorFOREIGN KEY (\"authorId\")REFERENCES \"User\"(\"id\");\n    ```\n    \n2.  Write a SQL query that reads all the rows from the `_PostToUser` relation table and for each row:\n    \n    1.  Finds the respective `Post` record by looking up the value from column `A`\n    2.  Inserts the value from column `B` as the value for `authorId` into that `Post` record\n    \n    ```\n    UPDATE \"Post\" postSET \"authorId\" = post_to_user.\"B\"FROM \"_PostToUser\" post_to_userWHERE post_to_user.\"A\" = post.\"id\";\n    ```\n    \n3.  Delete the `_PostToUser` relation table\n    \n    ```\n    DROP TABLE \"_PostToUser\";\n    ```\n    \n\nAfter that you can introspect your database and the relation will now be recognized as 1-n:\n\nschema.prisma\n\n```\nmodel User {  id   String @id  Post Post[]}model Post {  id       String @id  User     User   @relation(fields: [authorId], references: [id])  authorId String}\n```\n\n## `Json` type is represented as `TEXT` in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#json-type-is-represented-as-text-in-database \"Direct link to json-type-is-represented-as-text-in-database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem-6 \"Direct link to Problem\")\n\nPrisma 1 supports the `Json` data type in its datamodel. However, in the underlying database, fields of type `Json` are actually stored as plain strings using the `TEXT` data type of the underlying database. Any parsing and validation of the stored JSON data is done by the Prisma 1 server at runtime.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example-6 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-datamodel-5 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype User {  id: ID! @id  jsonData: Json}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration-6 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  jsonData TEXT);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-introspection-in-prisma-orm-2x-and-later-versions-4 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-4\")\n\nschema.prisma\n\n```\nmodel User {  id       String  @id  jsonData String?}\n```\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workaround-3 \"Direct link to Workaround\")\n\nYou can manually change the type of the column to `JSON`\n\n```\nALTER TABLE \"User\" ALTER COLUMN \"jsonData\" TYPE JSON  USING \"jsonData\"::json;\n```\n\nAfter this adjustment, you can re-introspect your database and the field will now be recognized as `Json`:\n\nschema.prisma\n\n```\nmodel User {  id       String @id  jsonData Json?}\n```\n\n## Enums are represented as `TEXT` in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#enums-are-represented-as-text-in-database \"Direct link to enums-are-represented-as-text-in-database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem-7 \"Direct link to Problem\")\n\nPrisma 1 supports the `enum` data type in its datamodel. However, in the underlying database, types declared as `enum` are actually stored as plain strings using the `TEXT` data type of the underlying database. Any validation of the stored `enum` data is done by the Prisma 1 server at runtime.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example-7 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-datamodel-6 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype User {  id: ID! @id  role: Role}enum Role {  ADMIN  CUSTOMER}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration-7 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  role TEXT);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-introspection-in-prisma-orm-2x-and-later-versions-5 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-5\")\n\nschema.prisma\n\n```\nmodel User {  id   String  @id  role String?}\n```\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workaround-4 \"Direct link to Workaround\")\n\nYou can manually turn the `role` column into an enum with your desired values:\n\n1.  Create an `enum` in your database that mirrors the `enum` you defined in the Prisma 1 datamodel:\n    \n    ```\n    CREATE TYPE \"Role\" AS ENUM ('CUSTOMER', 'ADMIN');\n    ```\n    \n2.  Change the type from `TEXT` to your new `enum`:\n    \n    ```\n    ALTER TABLE \"User\" ALTER COLUMN \"role\" TYPE \"Role\"USING \"role\"::text::\"Role\";\n    ```\n    \n\nAfter introspection, the type is now properly recognized as an enum:\n\nschema.prisma\n\n```\nmodel User {  id   String @id  role Role?}enum Role {  ADMIN  CUSTOMER}\n```\n\n## Mismatching CUID length[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#mismatching-cuid-length \"Direct link to Mismatching CUID length\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem-8 \"Direct link to Problem\")\n\nPrisma 1 uses CUIDs as ID values for all database records. In the underlying database, these IDs are represented as strings with a maximum size of 25 characters (as `VARCHAR(25)`). However, when configuring default CUIDs in your Prisma ORM 2._x_ (or later versions) schema with `@default(cuid())` the generated ID values might exceed the limit of 25 characters (the maximum length might be 30 characters). To make your IDs proof for Prisma ORM 2._x_ (or later versions), you therefore need to adjust the column type to `VARCHAR(30)`.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example-8 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-datamodel-7 \"Direct link to Prisma 1 datamodel\")\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration-8 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-introspection-in-prisma-orm-2x-and-later-versions-6 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-6\")\n\nschema.prisma\n\n```\nmodel User {  id String @id}\n```\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workaround-5 \"Direct link to Workaround\")\n\nYou can manually turn the `VARCHAR(25)` columns into `VARCHAR(30)`:\n\n```\nALTER TABLE \"User\" ALTER COLUMN \"id\" SET DATA TYPE character varying(30);\n```\n\n> **Note**: When fixing this issue with the [Upgrade CLI](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#prisma-1-upgrade-cli), the generated SQL statements will keep appearing in the Upgrade CLI even after you have changed the column types in the underlying database. This is a currently a limitation in the Upgrade CLI.\n\n## Scalar lists (arrays) are maintained with extra table[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#scalar-lists-arrays-are-maintained-with-extra-table \"Direct link to Scalar lists (arrays) are maintained with extra table\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#problem-9 \"Direct link to Problem\")\n\nIn Prisma 1, you can define lists of _scalar_ types on your models. Under the hood, this is implemented with an extra table that keeps track of the values in the list.\n\nTo remove the approach with the extra table which incurred hidden performance costs, Prisma ORM 2._x_ and later versions only support scalar lists only when they're natively supported by the database you use. At the moment, only [PostgreSQL supports scalar lists (arrays) natively](https://www.postgresql.org/docs/9.1/arrays.html).\n\nWith PostgreSQL, you therefore can keep using scalar lists in Prisma ORM 2._x_ and later versions, but you'll need to perform a data migration to transfer the data from the extra table from Prisma 1 into an actual PostgreSQL array.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#example-9 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-datamodel-8 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype User {  id: ID! @id  coinflips: [Boolean!]! @scalarList(strategy: RELATION)}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#prisma-1-generated-sql-migration-9 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);CREATE TABLE \"User_coinflips\" (    \"nodeId\" VARCHAR(25) REFERENCES \"User\"(id),    position INTEGER,    value BOOLEAN NOT NULL,    CONSTRAINT \"User_coinflips_pkey\" PRIMARY KEY (\"nodeId\", position));CREATE UNIQUE INDEX \"User_coinflips_pkey\" ON \"User_coinflips\"(\"nodeId\" text_ops,position int4_ops);\n```\n\n#### Result of Prisma ORM 2 introspection[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#result-of-prisma-orm-2-introspection \"Direct link to Result of Prisma ORM 2 introspection\")\n\nschema.prisma\n\n```\nmodel User {  id             String           @id  User_coinflips User_coinflips[]}model User_coinflips {  nodeId   String  position Int  value    Boolean  User     User    @relation(fields: [nodeId], references: [id])  @@id([nodeId, position])}\n```\n\nNote that you can now generate Prisma Client and you'll be able to access the data from the scalar lists through the extra table. PostgreSQL users can alternatively migrate the data into a native PostgreSQL array and continue to benefit from the slicker Prisma Client API for scalar lists (read the section below for more info).\n\nExpand for sample Prisma Client API calls\n\nTo access the coinflips data, you will now have to always [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) it in your queries:\n\n```\nconst user = await prisma.user.findUnique({  where: { id: 1 },  include: {    coinflips: {      orderBy: { position: 'asc' },    },  },})\n```\n\n> **Note**: The `orderBy` is important to retain the order of the list.\n\nThis is the \\`result of the query:\n\n```\n{  id: 1,  name: 'Alice',  coinflips: [    { id: 1, position: 1000, value: false },    { id: 2, position: 2000, value: true },    { id: 3, position: 3000, value: false },    { id: 4, position: 4000, value: true },    { id: 5, position: 5000, value: true },    { id: 6, position: 6000, value: false }  ]}\n```\n\nTo access just the boolean values from the list, you can `map` over the `coinflips` on `user` as follows:\n\n```\nconst currentCoinflips = user!.coinflips.map((cf) => cf.value)\n```\n\n> **Note**: The exclamation mark above means that you're _force unwrapping_ the `user` value. This is necessary because the `user` returned from the previous query might be `null`.\n\nHere's the value of `currentCoinflips` after the call to `map`:\n\n```\n[false, true, false, true, true, false]\n```\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#workaround-6 \"Direct link to Workaround\")\n\nThe following workaround is only available for PostgreSQL users!\n\nAs scalar lists (i.e. [arrays](https://www.postgresql.org/docs/9.1/arrays.html)) are available as a native PostgreSQL feature, you can keep using the same notation of `coinflips: Boolean[]` in your Prisma schema.\n\nHowever, in order to do so you need to manually migrate the underlying data from the `User_coinflips` table into a PostgreSQL array. Here's how you can do that:\n\n1.  Add the new `coinflips` column to the `User` tables:\n    \n    ```\n    ALTER TABLE \"User\" ADD COLUMN coinflips BOOLEAN[];\n    ```\n    \n2.  Migrate the data from `\"User_coinflips\".value` to `\"User.coinflips\"`:\n    \n    ```\n    UPDATE \"User\"  SET coinflips = t.flipsFROM (  SELECT \"nodeId\", array_agg(VALUE ORDER BY position) AS flips  FROM \"User_coinflips\"  GROUP BY \"nodeId\") twhere t.\"nodeId\" = \"User\".\"id\";\n    ```\n    \n3.  To cleanup, you can delete the `User_coinflips` table:\n    \n    ```\n    DROP TABLE \"User_coinflips\";\n    ```\n    \n\nYou can now introspect your database and the `coinflips` field will be represented as an array in your new Prisma schema:\n\nschema.prisma\n\n```\nmodel User {  id        String    @id  coinflips Boolean[]}\n```\n\nYou can keep using Prisma Client as before:\n\n```\nconst user = await prisma.user.findUnique({  where: { id: 1 },})\n```\n\nThis is the result from the API call:\n\n```\n{  id: 1,  name: 'Alice',  coinflips: [ false, true, false, true, true, false ]}\n```",
    "title": "Schema Incompatibilities | PostgreSQL | Prisma Documentation",
    "description": "Problems and workarounds for Prisma 1 and 2.0 schemas with PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql",
    "markdown": "# Schema Incompatibilities | MySQL | Prisma Documentation\n\n## Overview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#overview \"Direct link to Overview\")\n\nEach section on this page describes a potential problem when upgrading from Prisma 1 to Prisma ORM 2._x_ and later and explains the available workarounds.\n\n## Default values aren't represented in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#default-values-arent-represented-in-database \"Direct link to Default values aren't represented in database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem \"Direct link to Problem\")\n\nWhen adding the `@default` directive in a Prisma 1 datamodel, the default values for this field are generated by the Prisma 1 server at runtime. There's no `DEFAULT` constraint added to the database column. Because this constraint is not reflected in the database itself, the Prisma ORM 2._x_ and later versions of introspection can't recognize it.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-datamodel \"Direct link to Prisma 1 datamodel\")\n\n```\ntype Post {  id: ID! @id  published: Boolean @default(value: false)}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  published BOOLEAN NOT NULL);\n```\n\n#### Result of introspection in Prisma ORM versions 2._x_ and later[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-introspection-in-prisma-orm-versions-2x-and-later \"Direct link to result-of-introspection-in-prisma-orm-versions-2x-and-later\")\n\nschema.prisma\n\n```\nmodel Post {  id        String  @id  published Boolean}\n```\n\nBecause the `DEFAULT` constraint has not been added to the database when mapping the Prisma 1 datamodel to the database with `prisma deploy`, Prisma ORM v2 (and later versions) doesn't recognize it during introspection.\n\n### Workarounds[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workarounds \"Direct link to Workarounds\")\n\n#### Manually add a `DEFAULT` constraint to the database column[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#manually-add-a-default-constraint-to-the-database-column \"Direct link to manually-add-a-default-constraint-to-the-database-column\")\n\nYou can alter the column to add the `DEFAULT` constraint as follows:\n\n```\nALTER TABLE `Post`\tALTER COLUMN published SET DEFAULT false;\n```\n\nAfter this adjustment, you can re-introspect your database and the `@default` attribute will be added to the `published` field:\n\nschema.prisma\n\n```\nmodel Post {  id        String  @id  published Boolean @default(false)}\n```\n\n#### Manually add a `@default` attribute to the Prisma model[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#manually-add-a-default-attribute-to-the-prisma-model \"Direct link to manually-add-a-default-attribute-to-the-prisma-model\")\n\nYou can add the `@default` attribute to the Prisma model:\n\nschema.prisma\n\n```\nmodel Post {  id        String  published Boolean @default(false)}\n```\n\nIf the `@default` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will generate the specified default values at runtime (similar to what the Prisma 1 server did in Prisma 1).\n\n## Generated CUIDs as ID values aren't represented in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#generated-cuids-as-id-values-arent-represented-in-database \"Direct link to Generated CUIDs as ID values aren't represented in database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem-1 \"Direct link to Problem\")\n\nPrisma 1 auto-generates ID values as CUIDs for `ID` fields when they're annotated with the `@id` directive. These CUIDs are generated by the Prisma 1 server at runtime. Because this behavior is not reflected in the database itself, the introspection in Prisma ORM 2._x_ and later can't recognize it.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example-1 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-datamodel-1 \"Direct link to Prisma 1 datamodel\")\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration-1 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);\n```\n\n#### Result of introspection in Prisma ORM versions 2._x_ and later[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-introspection-in-prisma-orm-versions-2x-and-later-1 \"Direct link to result-of-introspection-in-prisma-orm-versions-2x-and-later-1\")\n\nschema.prisma\n\n```\nmodel Post {  id String @id}\n```\n\nBecause there's no indication of the CUID behavior in the database, Prisma ORM's introspection doesn't recognize it.\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workaround \"Direct link to Workaround\")\n\nAs a workaround, you can manually add the `@default(cuid())` attribute to the Prisma model:\n\nschema.prisma\n\n```\nmodel Post {  id String @id @default(cuid())}\n```\n\nIf the `@default` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will generate the specified default values at runtime (similar to what the Prisma 1 server did in Prisma 1).\n\nNote that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!\n\n## `@createdAt` isn't represented in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#createdat-isnt-represented-in-database \"Direct link to createdat-isnt-represented-in-database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem-2 \"Direct link to Problem\")\n\nPrisma 1 auto-generates values for `DateTime` fields when they're annotated with the `@createdAt` directive. These values are generated by the Prisma 1 server at runtime. Because this behavior is not reflected in the database itself, the introspection in Prisma ORM 2._x_ and later can't recognize it.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example-2 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-datamodel-2 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype Post {  id: ID! @id  createdAt: DateTime! @createdAt}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration-2 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  \"createdAt\" TIMESTAMP NOT NULL);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-introspection-in-prisma-orm-2x-and-later-versions \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions\")\n\nschema.prisma\n\n```\nmodel Post {  id        String   @id  createdAt DateTime}\n```\n\n### Workarounds[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workarounds-1 \"Direct link to Workarounds\")\n\n#### Manually add `DEFAULT CURRENT_TIMESTAMP` to the database column[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#manually-add-default-current_timestamp-to-the-database-column \"Direct link to manually-add-default-current_timestamp-to-the-database-column\")\n\nYou can alter the column to add the `DEFAULT` constraint as follows:\n\n```\nALTER TABLE \"Post\"\tALTER COLUMN \"createdAt\" SET DEFAULT CURRENT_TIMESTAMP;\n```\n\nAfter this adjustment, you can re-introspect your database and the `@default` attribute will be added to the `createdAt` field:\n\nschema.prisma\n\n```\nmodel Post {  id        String  createdAt DateTime @default(now())}\n```\n\n#### Manually add the `@default(now())` attribute to the Prisma model[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#manually-add-the-defaultnow-attribute-to-the-prisma-model \"Direct link to manually-add-the-defaultnow-attribute-to-the-prisma-model\")\n\nAs a workaround, you can manually add the `@default(now())` attribute to the Prisma model:\n\nschema.prisma\n\n```\nmodel Post {  id        String   @id  createdAt DateTime @default(now())}\n```\n\nIf the `@default` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will generate the specified default values at runtime (similar to what the Prisma 1 server did in Prisma 1).\n\nNote that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!\n\n## `@updatedAt` isn't represented in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#updatedat-isnt-represented-in-database \"Direct link to updatedat-isnt-represented-in-database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem-3 \"Direct link to Problem\")\n\nPrisma 1 auto-generates values for `DateTime` fields when they're annotated with the `@updatedAt` directive. These values are generated by the Prisma 1 server at runtime. Because this behavior is not reflected in the database itself, the introspection in Prisma ORM 2._x_ and later can't recognize it..\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example-3 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-datamodel-3 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype Post {  id: ID! @id  updatedAt: DateTime! @updatedAt}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration-3 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  updatedAt TIMESTAMP);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-introspection-in-prisma-orm-2x-and-later-versions-1 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-1\")\n\nschema.prisma\n\n```\nmodel Post {  id        String   @id  updatedAt DateTime}\n```\n\n### Workarounds[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workarounds-2 \"Direct link to Workarounds\")\n\n#### Manually add the `@updatedAt` attribute to the Prisma model[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#manually-add-the-updatedat-attribute-to-the-prisma-model \"Direct link to manually-add-the-updatedat-attribute-to-the-prisma-model\")\n\nAs a workaround, you can manually add the `@updatedAt` attribute to the Prisma model:\n\nschema.prisma\n\n```\nmodel Post {  id        String   @id  updatedAt DateTime @updatedAt}\n```\n\nIf the `@updatedAt` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will automatically generate values for this column when an existing record is updated (similar to what the Prisma 1 server did in Prisma 1).\n\nNote that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!\n\n## Inline 1-1 relations are recognized as 1-n (missing `UNIQUE` constraint)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint \"Direct link to inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem-4 \"Direct link to Problem\")\n\nIn the [datamodel v1.1](https://www.prisma.io/blog/datamodel-v11-lrzqy1f56c90) that was introduced in Prisma ORM v1.31, 1-1 relations can be declared as _inline_. In that case, the relation will not be maintained via a [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) but via a single foreign key on one of the two tables involved.\n\nWhen this approach is used, Prisma ORM doesn't add a `UNIQUE` constraint to the foreign key column which means that after introspection in Prisma ORM version 2._x_ and later, this former 1-1 relation will be added as a 1-n relation to the Prisma schema.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example-4 \"Direct link to Example\")\n\n#### Prisma ORM datamodel v1.1 (available from Prisma ORM v1.31)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-orm-datamodel-v11-available-from-prisma-orm-v131 \"Direct link to Prisma ORM datamodel v1.1 (available from Prisma ORM v1.31)\")\n\n```\ntype User {  id: ID! @id  profile: Profile @relation(link: INLINE)}type Profile {  id: ID! @id  user: User}\n```\n\nNote that omitting the `@relation` directive in this case would result in the same behavior because `link: INLINE` is the _default_ for 1-1 relations.\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration-4 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);CREATE TABLE \"Profile\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  \"user\" VARCHAR(25),  FOREIGN KEY (\"user\") REFERENCES \"User\"(id));\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-introspection-in-prisma-orm-2x-and-later-versions-2 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-2\")\n\nschema.prisma\n\n```\nmodel User {  id      String    @id  Profile Profile[]}model Profile {  id   String  @id  user String?  User User?   @relation(fields: [user], references: [id])}\n```\n\nBecause there's no `UNIQUE` constraint defined on the `user` column (which represents the foreign key in this relation), Prisma ORM's introspection recognizes the relation as 1-n.\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workaround-1 \"Direct link to Workaround\")\n\n#### Manually add `UNIQUE` constraint to the foreign key column[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#manually-add-unique-constraint-to-the-foreign-key-column \"Direct link to manually-add-unique-constraint-to-the-foreign-key-column\")\n\nYou can alter the foreign key column to add the `UNIQUE` constraint as follows:\n\n```\nALTER TABLE `Profile`  ADD CONSTRAINT userId_unique UNIQUE (`user`);\n```\n\nAfter this adjustment, you can re-introspect your database and the 1-1 relation will be properly recognized:\n\nschema.prisma\n\n```\nmodel User {  id      String   @id  Profile Profile?}model Profile {  id   String  @id  user String? @unique  User User?   @relation(fields: [user], references: [id])}\n```\n\n## _All_ non-inline relations are recognized as m-n[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#all-non-inline-relations-are-recognized-as-m-n \"Direct link to all-non-inline-relations-are-recognized-as-m-n\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem-5 \"Direct link to Problem\")\n\nPrisma 1 represents relations as relation tables most of the time:\n\n*   All relations in the Prisma 1 **datamodel v1.0** are represented as relation tables\n*   In **datamodel v1.1**, all m-n relations as well as the 1-1 and 1-n relations declared as `link: TABLE` are represented as relation tables.\n\nBecause of this representation, introspection in Prisma ORM version 2._x_ and later will recognize all these relations as m-n relations, even though they might have been declared as 1-1 or 1-n in Prisma 1.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example-5 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-datamodel-4 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype User {  id: ID! @id  posts: [Post!]!}type Post {  id: ID! @id  author: User! @relation(link: TABLE)}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration-5 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);CREATE TABLE \"Post\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);CREATE TABLE \"_PostToUser\" (  \"A\" VARCHAR(25) NOT NULL REFERENCES \"Post\"(id) ON DELETE CASCADE,  \"B\" VARCHAR(25) NOT NULL REFERENCES \"User\"(id) ON DELETE CASCADE);CREATE UNIQUE INDEX \"_PostToUser_AB_unique\" ON \"_PostToUser\"(\"A\" text_ops,\"B\" text_ops);CREATE INDEX \"_PostToUser_B\" ON \"_PostToUser\"(\"B\" text_ops);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-introspection-in-prisma-orm-2x-and-later-versions-3 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-3\")\n\nschema.prisma\n\n```\nmodel User {  id   String @id  Post Post[] @relation(references: [id])}model Post {  id   String @id  User User[] @relation(references: [id])}\n```\n\nBecause the relation table that was created by Prisma 1 uses the same [conventions for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations) as in Prisma ORM version 2._x_ and later, the relation now gets recognized as a m-n relation.\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workaround-2 \"Direct link to Workaround\")\n\nAs a workaround, you can migrate the data into a structure that's compatible with Prisma ORM's 1-n relation:\n\n1.  Create new column `authorId` on the `Post` table. This column should be a _foreign key_ that references the `id` field of the `User` table:\n    \n    ```\n    ALTER TABLE `Post` ADD COLUMN `authorId` VARCHAR(25);ALTER TABLE `Post` ADD FOREIGN KEY (`authorId`) REFERENCES `User` (`id`);\n    ```\n    \n2.  Write a SQL query that reads all the rows from the `_PostToUser` relation table and for each row:\n    \n    1.  Finds the respective `Post` record by looking up the value from column `A`\n    2.  Inserts the value from column `B` as the value for `authorId` into that `Post` record\n    \n    ```\n    UPDATE Post, _PostToUserSET Post.authorId = _PostToUser.BWHERE Post.id = _PostToUser.A\n    ```\n    \n3.  Delete the `_PostToUser` relation table\n    \n    ```\n    DROP TABLE `_PostToUser`;\n    ```\n    \n\nAfter that you can introspect your database and the relation will now be recognized as 1-n:\n\nschema.prisma\n\n```\nmodel User {  id   String @id  Post Post[]}model Post {  id       String @id  User     User   @relation(fields: [authorId], references: [id])  authorId String}\n```\n\n## `Json` type is represented as `TEXT` in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#json-type-is-represented-as-text-in-database \"Direct link to json-type-is-represented-as-text-in-database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem-6 \"Direct link to Problem\")\n\nPrisma 1 supports the `Json` data type in its datamodel. However, in the underlying database, fields of type `Json` are actually stored as plain strings using the `TEXT` data type of the underlying database. Any parsing and validation of the stored JSON data is done by the Prisma 1 server at runtime.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example-6 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-datamodel-5 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype User {  id: ID! @id  jsonData: Json}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration-6 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  jsonData TEXT);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-introspection-in-prisma-orm-2x-and-later-versions-4 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-4\")\n\nschema.prisma\n\n```\nmodel User {  id       String  @id  jsonData String?}\n```\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workaround-3 \"Direct link to Workaround\")\n\nYou can manually change the type of the column to `JSON`\n\n```\nALTER TABLE User MODIFY COLUMN jsonData JSON;\n```\n\nAfter this adjustment, you can re-introspect your database and the field will now be recognized as `Json`:\n\nschema.prisma\n\n```\nmodel User {  id       String @id  jsonData Json?}\n```\n\n## Enums are represented as `TEXT` in database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#enums-are-represented-as-text-in-database \"Direct link to enums-are-represented-as-text-in-database\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem-7 \"Direct link to Problem\")\n\nPrisma 1 supports the `enum` data type in its datamodel. However, in the underlying database, types declared as `enum` are actually stored as plain strings using the `TEXT` data type of the underlying database. Any validation of the stored `enum` data is done by the Prisma 1 server at runtime.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example-7 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-datamodel-6 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype User {  id: ID! @id  role: Role}enum Role {  ADMIN  CUSTOMER}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration-7 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL,  role TEXT);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-introspection-in-prisma-orm-2x-and-later-versions-5 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-5\")\n\nschema.prisma\n\n```\nmodel User {  id   String  @id  role String?}\n```\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workaround-4 \"Direct link to Workaround\")\n\nYou can manually turn the `role` column into an enum with your desired values:\n\n1.  Create an `enum` in your database that mirrors the `enum` you defined in the Prisma 1 datamodel:\n    \n    ```\n    CREATE TYPE \"Role\" AS ENUM ('CUSTOMER', 'ADMIN');\n    ```\n    \n2.  Change the type from `TEXT` to your new `enum`:\n    \n    ```\n    ALTER TABLE \"User\" ALTER COLUMN \"role\" TYPE \"Role\"USING \"role\"::text::\"Role\";\n    ```\n    \n\nAfter introspection, the type is now properly recognized as an enum:\n\nschema.prisma\n\n```\nmodel User {  id   String @id  role Role?}enum Role {  ADMIN  CUSTOMER}\n```\n\n## Mismatching CUID length[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#mismatching-cuid-length \"Direct link to Mismatching CUID length\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem-8 \"Direct link to Problem\")\n\nPrisma 1 uses CUIDs as ID values for all database records. In the underlying database, these IDs are represented as strings with a maximum size of 25 characters (as `VARCHAR(25)`). However, when configuring default CUIDs in your Prisma ORM 2._x_ (or later versions) schema with `@default(cuid())` the generated ID values might exceed the limit of 25 characters (the maximum length might be 30 characters). To make your IDs proof for Prisma ORM 2._x_ (or later versions), you therefore need to adjust the column type to `VARCHAR(30)`.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example-8 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-datamodel-7 \"Direct link to Prisma 1 datamodel\")\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration-8 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);\n```\n\n#### Result of introspection in Prisma ORM 2._x_ and later versions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-introspection-in-prisma-orm-2x-and-later-versions-6 \"Direct link to result-of-introspection-in-prisma-orm-2x-and-later-versions-6\")\n\nschema.prisma\n\n```\nmodel User {  id String @id}\n```\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workaround-5 \"Direct link to Workaround\")\n\nYou can manually turn the `VARCHAR(25)` columns into `VARCHAR(30)`:\n\n```\nSET FOREIGN_KEY_CHECKS=0;ALTER TABLE `User` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;SET FOREIGN_KEY_CHECKS=1;\n```\n\n> **Note**: When fixing this issue with the [Upgrade CLI](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#prisma-1-upgrade-cli), the generated SQL statements will keep appearing in the Upgrade CLI even after you have changed the column types in the underlying database. This is a currently a limitation in the Upgrade CLI.\n\n## Scalar lists (arrays) are maintained with extra table[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#scalar-lists-arrays-are-maintained-with-extra-table \"Direct link to Scalar lists (arrays) are maintained with extra table\")\n\n### Problem[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#problem-9 \"Direct link to Problem\")\n\nIn Prisma 1, you can define lists of _scalar_ types on your models. Under the hood, this is implemented with an extra table that keeps track of the values in the list.\n\nTo remove the approach with the extra table which incurred hidden performance costs, Prisma ORM 2._x_ and later versions only support scalar lists only when they're natively supported by the database you use. At the moment, only [PostgreSQL supports scalar lists (arrays) natively](https://www.postgresql.org/docs/9.1/arrays.html).\n\nWith PostgreSQL, you therefore can keep using scalar lists in Prisma ORM 2._x_ and later versions, but you'll need to perform a data migration to transfer the data from the extra table from Prisma 1 into an actual PostgreSQL array.\n\n### Example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#example-9 \"Direct link to Example\")\n\n#### Prisma 1 datamodel[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-datamodel-8 \"Direct link to Prisma 1 datamodel\")\n\n```\ntype User {  id: ID! @id  coinflips: [Boolean!]! @scalarList(strategy: RELATION)}\n```\n\n#### Prisma 1 generated SQL migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#prisma-1-generated-sql-migration-9 \"Direct link to Prisma 1 generated SQL migration\")\n\n```\nCREATE TABLE \"User\" (  id VARCHAR(25) PRIMARY KEY NOT NULL);CREATE TABLE \"User_coinflips\" (    \"nodeId\" VARCHAR(25) REFERENCES \"User\"(id),    position INTEGER,    value BOOLEAN NOT NULL,    CONSTRAINT \"User_coinflips_pkey\" PRIMARY KEY (\"nodeId\", position));CREATE UNIQUE INDEX \"User_coinflips_pkey\" ON \"User_coinflips\"(\"nodeId\" text_ops,position int4_ops);\n```\n\n#### Result of Prisma ORM 2 introspection[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#result-of-prisma-orm-2-introspection \"Direct link to Result of Prisma ORM 2 introspection\")\n\nschema.prisma\n\n```\nmodel User {  id             String           @id  User_coinflips User_coinflips[]}model User_coinflips {  nodeId   String  position Int  value    Boolean  User     User    @relation(fields: [nodeId], references: [id])  @@id([nodeId, position])}\n```\n\nNote that you can now generate Prisma Client and you'll be able to access the data from the scalar lists through the extra table. PostgreSQL users can alternatively migrate the data into a native PostgreSQL array and continue to benefit from the slicker Prisma Client API for scalar lists (read the section below for more info).\n\nExpand for sample Prisma Client API calls\n\nTo access the coinflips data, you will now have to always [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) it in your queries:\n\n```\nconst user = await prisma.user.findUnique({  where: { id: 1 },  include: {    coinflips: {      orderBy: { position: 'asc' },    },  },})\n```\n\n> **Note**: The `orderBy` is important to retain the order of the list.\n\nThis is the \\`result of the query:\n\n```\n{  id: 1,  name: 'Alice',  coinflips: [    { id: 1, position: 1000, value: false },    { id: 2, position: 2000, value: true },    { id: 3, position: 3000, value: false },    { id: 4, position: 4000, value: true },    { id: 5, position: 5000, value: true },    { id: 6, position: 6000, value: false }  ]}\n```\n\nTo access just the boolean values from the list, you can `map` over the `coinflips` on `user` as follows:\n\n```\nconst currentCoinflips = user!.coinflips.map((cf) => cf.value)\n```\n\n> **Note**: The exclamation mark above means that you're _force unwrapping_ the `user` value. This is necessary because the `user` returned from the previous query might be `null`.\n\nHere's the value of `currentCoinflips` after the call to `map`:\n\n```\n[false, true, false, true, true, false]\n```\n\n### Workaround[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#workaround-6 \"Direct link to Workaround\")\n\nThe following workaround is only available for PostgreSQL users!\n\nAs scalar lists (i.e. [arrays](https://www.postgresql.org/docs/9.1/arrays.html)) are available as a native PostgreSQL feature, you can keep using the same notation of `coinflips: Boolean[]` in your Prisma schema.\n\nHowever, in order to do so you need to manually migrate the underlying data from the `User_coinflips` table into a PostgreSQL array. Here's how you can do that:\n\n1.  Add the new `coinflips` column to the `User` tables:\n    \n    ```\n    ALTER TABLE \"User\" ADD COLUMN coinflips BOOLEAN[];\n    ```\n    \n2.  Migrate the data from `\"User_coinflips\".value` to `\"User.coinflips\"`:\n    \n    ```\n    UPDATE \"User\"  SET coinflips = t.flipsFROM (  SELECT \"nodeId\", array_agg(VALUE ORDER BY position) AS flips  FROM \"User_coinflips\"  GROUP BY \"nodeId\") twhere t.\"nodeId\" = \"User\".\"id\";\n    ```\n    \n3.  To cleanup, you can delete the `User_coinflips` table:\n    \n    ```\n    DROP TABLE \"User_coinflips\";\n    ```\n    \n\nYou can now introspect your database and the `coinflips` field will be represented as an array in your new Prisma schema:\n\nschema.prisma\n\n```\nmodel User {  id        String    @id  coinflips Boolean[]}\n```\n\nYou can keep using Prisma Client as before:\n\n```\nconst user = await prisma.user.findUnique({  where: { id: 1 },})\n```\n\nThis is the result from the API call:\n\n```\n{  id: 1,  name: 'Alice',  coinflips: [ false, true, false, true, true, false ]}\n```",
    "title": "Schema Incompatibilities | MySQL | Prisma Documentation",
    "description": "Problems and workarounds for Prisma 1 and 2.0 schemas with MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus",
    "markdown": "# Upgrade Prisma 1 with nexus-prisma to @nexus/schema\n\n## Old to new Nexus\n\n## Overview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#overview \"Direct link to Overview\")\n\n> **Note**: This guide is not fully up-to-date as it currently uses the [deprecated](https://github.com/graphql-nexus/nexus-plugin-prisma/issues/1039) version of the [`nexus-plugin-prisma`](https://github.com/graphql-nexus/nexus-plugin-prisma). While this is still functional, it is recommended to use the new [`nexus-prisma`](https://github.com/prisma/nexus-prisma/) library or an alternative code-first GraphQL library like [Pothos](https://pothos-graphql.dev/) going forward. If you have any questions, feel free to share them on our [Discord](https://pris.ly/discord).\n\nThis upgrade guide describes how to upgrade a project that's based on [Prisma 1](https://github.com/prisma/prisma1) and uses [`nexus`](https://www.npmjs.com/package/nexus) (< v0.12.0) or [`@nexus/schema`](https://github.com/graphql-nexus/schema) together with [`nexus-prisma`](https://www.npmjs.com/package/nexus-prisma) (< v4.0.0) to implement a GraphQL server.\n\nThe code will be upgraded to the latest version of `@nexus/schema`. Further, the `nexus-prisma` package will be replaced with the new [`nexus-plugin-prisma`](https://github.com/graphql-nexus/nexus-plugin-prisma).\n\nThe guide assumes that you already went through the [guide for upgrading the Prisma ORM layer](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql). This means you already:\n\n*   installed the Prisma ORM 2 CLI\n*   created your Prisma ORM 2 schema\n*   introspected your database and resolved potential [schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql)\n*   installed and generated Prisma Client\n\nThe guide further assumes that you have a file setup that looks similar to this:\n\n```\n.├── README.md├── package.json├── prisma│   └── schema.prisma├── prisma1│   ├── datamodel.prisma│   └── prisma.yml└── src    ├── generated    │   ├── nexus-prisma    │   ├── nexus.ts    │   ├── prisma-client    │   └── schema.graphql    ├── types.ts    └── index.ts\n```\n\nThe important parts are:\n\n*   A folder called with `prisma` with your Prisma ORM 2 schema\n*   A folder called `src` with your application code\n\nIf this is not what your project structure looks like, you'll need to adjust the instructions in the guide to match your own setup.\n\n## 1\\. Upgrade Nexus dependencies[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#1-upgrade-nexus-dependencies \"Direct link to 1. Upgrade Nexus dependencies\")\n\nTo get started, you can remove the old Nexus and Prisma 1 dependencies:\n\n```\nnpm uninstall nexus nexus-prisma prisma-client-lib prisma1\n```\n\nThen, you can install the latest `@nexus/schema` dependency in your project:\n\n```\nnpm install @nexus/schema\n```\n\nNext, install the Prisma ORM plugin for Nexus which will allow you to expose Prisma ORM models in your GraphQL API (this is the new equivalent of the former `nexus-prisma` package):\n\n```\nnpm install nexus-plugin-prisma\n```\n\nThe `nexus-plugin-prisma` dependency bundles all required Prisma ORM dependencies. You should therefore remove the dependencies that you added installed when you upgraded the Prisma ORM layer of your app:\n\n```\nnpm uninstall @prisma/cli @prisma/client\n```\n\nNote however that you can still invoke the Prisma ORM 2 CLI with the familiar command:\n\n> **Note**: If you see the output of the Prisma 1 CLI when running `npx prisma -v`, be sure to delete your `node_modules` folder and re-run `npm install`.\n\n## 2\\. Update the configuration of Nexus and Prisma ORM[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#2-update-the-configuration-of-nexus-and-prisma-orm \"Direct link to 2. Update the configuration of Nexus and Prisma ORM\")\n\nTo get started, you can remove the old imports that are not needed any more with your new setup:\n\n```\nimport { makePrismaSchema, prismaObjectType } from 'nexus-prisma'import datamodelInfo from './generated/nexus-prisma'import { prisma } from './generated/prisma-client'\n```\n\nInstead, you now import the following into your application:\n\n```\nimport { nexusSchemaPrisma } from 'nexus-plugin-prisma/schema'import { objectType, makeSchema, queryType, mutationType } from '@nexus/schema'import { PrismaClient } from '@prisma/client'\n```\n\nNext you need to adjust the code where you currently create your `GraphQLSchema`, most likely this is currently happening via the `makePrismaSchema` function in your code. Since this function was imported from the removed `nexus-prisma` package, you'll need to replace it with the `makeSchema` function from the `@nexus/schema` package. The way how the Prisma ORM plugin for Nexus is used also changes in the latest version.\n\nHere's an example for such a configuration:\n\n./src/index.ts\n\n```\n const schema = makePrismaSchema({ const schema = makeSchema({  // Provide all the GraphQL types we've implemented  types: [Query, Mutation, UserUniqueInput, User, Post, Category, Profile],  // Configure the interface to Prisma  prisma: {    datamodelInfo,    client: prisma,  },  plugins: [nexusSchemaPrisma({    experimentalCRUD: true,  })],  // Specify where Nexus should put the generated files  outputs: {    schema: path.join(__dirname, './generated/schema.graphql'),    typegen: path.join(__dirname, './generated/nexus.ts'),  },  // Configure nullability of input arguments: All arguments are non-nullable by default  nonNullDefaults: {    input: false,    output: false,  },  // Configure automatic type resolution for the TS representations of the associated types  typegenAutoConfig: {    sources: [      {        source: path.join(__dirname, './types.ts'),        alias: 'types',      },    ],    contextType: 'types.Context',  },})\n```\n\nIf you previously typed the GraphQL `context` object that's passed through your resolver chain, you need to adjust the type like so:\n\n./src/types.ts\n\n```\nimport { Prisma } from './generated/prisma-client'import { PrismaClient } from '@prisma/client'export interface Context {  prisma: Prisma  prisma: PrismaClient}\n```\n\n## 3\\. Migrate your GraphQL types[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#3-migrate-your-graphql-types \"Direct link to 3. Migrate your GraphQL types\")\n\nHere's a quick overview of the main differences between the two approaches of creating GraphQL types with the latest versions of `@nexus/schema` and `nexus-plugin-prisma`.\n\n*   The `prismaObjectType` function is not available any more, all types are created with Nexus' `objectType` function.\n*   To expose Prisma models via Nexus, you can use the `t.model` property which is added to the `t` argument that's passed into Nexus' `definition` functions. `t.model` gives you access to the properties of a Prisma model and lets you expose them.\n*   Exposing CRUD operations for Prisma models via Nexus follows a similar approach. These are exposed via `t.crud` in the `definition` functions of your `queryType` and `mutationType` types.\n\n### 3.1. Migrating the `Post` type[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#31-migrating-the-post-type \"Direct link to 31-migrating-the-post-type\")\n\n#### Type definition with the previous `nexus-prisma` package[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#type-definition-with-the-previous-nexus-prisma-package \"Direct link to type-definition-with-the-previous-nexus-prisma-package\")\n\nIn the sample app, the `User` type is defined as follows:\n\n```\nconst User = prismaObjectType({  name: 'User',  definition(t) {    t.prismaFields([      'id',      'name',      'email',      'jsonData',      'role'      {        name: 'posts',        args: [], // remove the arguments from the `posts` field of the `User` type in the Prisma schema      },    ])  },})\n```\n\n#### Type definition with the latest version of `@nexus/schema` and the `nexus-plugin-prisma`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#type-definition-with-the-latest-version-of-nexusschema-and-the-nexus-plugin-prisma \"Direct link to type-definition-with-the-latest-version-of-nexusschema-and-the-nexus-plugin-prisma\")\n\nWith the latest version of `@nexus/schema`, you can now access the `objectType` function on your main `schema` instance and expose all fields from the Prisma model like so:\n\n```\nconst User = objectType({  name: 'User',  definition(t) {    t.model.id()    t.model.name()    t.model.email()    t.model.jsonData()    t.model.role()    t.model.posts({      pagination: false,      ordering: false,      filtering: false,    })    t.model.profile()  },})\n```\n\nNote that `t.model` looks at the `name` attribute in the object that's passed as an argument to the `objectType` function and matches it against the models in your Prisma schema. In this case, it's matched against the `User` model. Therefore, `t.model` exposes functions that are named after the fields of the `User` model.\n\nAt this point, you might see errors on the relation fields `posts` and `profile`, e.g.:\n\n```\n//delete-next-lineMissing type Post, did you forget to import a type to the root query?\n```\n\nThis is because you didn't add the `Post` and `Profile` types to the GraphQL schema yet, the errors will go away once these types are part of the GraphQL schema as well!\n\n### 3.2. Migrating the `Post` type[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#32-migrating-the-post-type \"Direct link to 32-migrating-the-post-type\")\n\n#### Type definition with the previous `nexus-prisma` package[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#type-definition-with-the-previous-nexus-prisma-package-1 \"Direct link to type-definition-with-the-previous-nexus-prisma-package-1\")\n\nIn the sample app, the `Post` type is defined as follows:\n\n```\nconst Post = prismaObjectType({  name: 'Post',  definition(t) {    t.prismaFields(['*'])  },})\n```\n\nThe asterisk in `prismaFields` means that _all_ Prisma fields are exposed.\n\n#### Type definition with the latest version of `@nexus/schema` and the `nexus-plugin-prisma`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#type-definition-with-the-latest-version-of-nexusschema-and-the-nexus-plugin-prisma-1 \"Direct link to type-definition-with-the-latest-version-of-nexusschema-and-the-nexus-plugin-prisma-1\")\n\nWith the latest version of `@nexus/schema`, you need to expose all fields explicitly, there's no option to just expose everything from a Prisma model.\n\nTherefore, the new definition of `Post` must explicitly list all its fields:\n\n```\nconst Post = objectType({  name: 'Post',  definition(t) {    t.model.id()    t.model.title()    t.model.content()    t.model.published()    t.model.author()    t.model.categories()  },})\n```\n\nNote that `t.model` looks at the `name` attribute and matches it against the models in your Prisma schema. In this case, it's matched against the `Post` model. Therefore, `t.model` exposes functions that are named after the fields of the `Post` model.\n\n### 3.3. Migrating the `Profile` type[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#33-migrating-the-profile-type \"Direct link to 33-migrating-the-profile-type\")\n\n#### Type definition with the previous `nexus-prisma` package[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#type-definition-with-the-previous-nexus-prisma-package-2 \"Direct link to type-definition-with-the-previous-nexus-prisma-package-2\")\n\nIn the sample app, the `Profile` type is defined as follows:\n\n```\nconst Profile = prismaObjectType({  name: 'Profile',  definition(t) {    t.prismaFields(['*'])  },})\n```\n\nThe asterisk in `prismaFields` means that _all_ Prisma fields are exposed.\n\n#### Type definition with the latest version of `@nexus/schema` and the `nexus-plugin-prisma`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#type-definition-with-the-latest-version-of-nexusschema-and-the-nexus-plugin-prisma-2 \"Direct link to type-definition-with-the-latest-version-of-nexusschema-and-the-nexus-plugin-prisma-2\")\n\nWith the latest version of `@nexus/schema`, you need to expose all fields explicitly, there's no option to just expose everything from a Prisma model.\n\nTherefore, the new definition of `Profile` must explicitly list all its fields:\n\n```\nconst Profile = objectType({  name: 'Profile',  definition(t) {    t.model.id()    t.model.bio()    t.model.user()    t.model.userId()  },})\n```\n\nNote that `t.model` looks at the `name` attribute and matches it against the models in your Prisma schema. In this case, it's matched against the `Profile` model. Therefore, `t.model` exposes functions that are named after the fields of the `Profile` model.\n\n### 3.4. Migrating the `Category` type[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#34-migrating-the-category-type \"Direct link to 34-migrating-the-category-type\")\n\n#### Type definition with the previous `nexus-prisma` package[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#type-definition-with-the-previous-nexus-prisma-package-3 \"Direct link to type-definition-with-the-previous-nexus-prisma-package-3\")\n\nIn the sample app, the `Category` type is defined as follows:\n\n```\nconst Category = prismaObjectType({  name: 'Category',  definition(t) {    t.prismaFields(['*'])  },})\n```\n\nThe asterisk in `prismaFields` means that _all_ Prisma ORM fields are exposed.\n\n#### Type definition with the latest version of `@nexus/schema` and the `nexus-plugin-prisma`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#type-definition-with-the-latest-version-of-nexusschema-and-the-nexus-plugin-prisma-3 \"Direct link to type-definition-with-the-latest-version-of-nexusschema-and-the-nexus-plugin-prisma-3\")\n\nWith the latest version of `@nexus/schema`, you need to expose all fields explicitly, there's no option to just expose everything from a Prisma model.\n\nTherefore, the new definition of `Category` must explicitly list all its fields:\n\n```\nconst Category = objectType({  name: 'Category',  definition(t) {    t.model.id()    t.model.name()    t.model.posts({      pagination: true,      ordering: true,      filtering: true,    })  },})\n```\n\nNote that `t.model` looks at the `name` attribute and matches it against the models in your Prisma schema. In this case, it's matched against the `Category` model. Therefore, `t.model` exposes functions that are named after the fields of the `Category` model.\n\n## 4\\. Migrate GraphQL operations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#4-migrate-graphql-operations \"Direct link to 4. Migrate GraphQL operations\")\n\nAs a next step, you can start migrating all the GraphQL _queries_ and _mutations_ from the \"previous\" GraphQL API to the new one.\n\nFor this guide, the following sample GraphQL operations will be used:\n\n```\ninput UserUniqueInput {  id: String  email: String}type Query {  posts(searchString: String): [Post!]!  user(userUniqueInput: UserUniqueInput!): User  users(where: UserWhereInput, orderBy: Enumerable<UserOrderByInput>, skip: Int, after: String, before: String, first: Int, last: Int): [User]!}type Mutation {  createUser(data: UserCreateInput!): User!  createDraft(title: String!, content: String, authorId: ID!): Post  updateBio(userUniqueInput: UserUniqueInput!, bio: String!): User  addPostToCategories(postId: String!, categoryIds: [String!]!): Post}\n```\n\n### 4.1. Migrate GraphQL queries[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#41-migrate-graphql-queries \"Direct link to 4.1. Migrate GraphQL queries\")\n\nIn this section, you'll migrate all GraphQL _queries_ from the previous version of `nexus` and `nexus-prisma` to the latest version of `@nexus/schema` and the `nexus-plugin-prisma`.\n\n#### 4.1.1. Migrate the `users` query[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#411-migrate-the-users-query \"Direct link to 411-migrate-the-users-query\")\n\nIn our sample API, the `users` query from the sample GraphQL schema is implemented as follows.\n\n```\nconst Query = prismaObjectType({  name: 'Query',  definition(t) {    t.prismaFields(['users'])  },})\n```\n\nTo get the same behavior with the new Nexus, you need to call the `users` function on `t.crud`:\n\n```\nschema.queryType({  definition(t) {    t.crud.users({      filtering: true,      ordering: true,      pagination: true,    })  },})\n```\n\nRecall that the `crud` property is added to `t` by the `nexus-plugin-prisma` (using the same mechanism as for `t.model`).\n\n#### 4.1.2. Migrate the `posts(searchString: String): [Post!]!` query[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#412-migrate-the-postssearchstring-string-post-query \"Direct link to 412-migrate-the-postssearchstring-string-post-query\")\n\nIn the sample API, the `posts` query is implemented as follows:\n\n```\nqueryType({  definition(t) {    t.list.field('posts', {      type: 'Post',      args: {        searchString: stringArg({ nullable: true }),      },      resolve: (parent, { searchString }, context) => {        return context.prisma.posts({          where: {            OR: [              { title_contains: searchString },              { content_contains: searchString },            ],          },        })      },    })  },})\n```\n\nThe only thing that needs to be updated for this query is the call to Prisma ORM since the new Prisma Client API looks a bit different from the one used in Prisma 1.\n\n```\nqueryType({  definition(t) {    t.list.field('posts', {      type: 'Post',      args: {        searchString: stringArg({ nullable: true }),      },      resolve: (parent, { searchString }, context) => {        return context.prisma.post.findMany({          where: {            OR: [              { title: { contains: searchString } },              { content: { contains: searchString } },            ],          },        })      },    })  },})\n```\n\nNotice that the `db` object is automatically attached to the `context` by the `nexus-plugin-prisma`. It represents an instance of your `PrismaClient` which enables you to send queries to your database inside your resolvers.\n\n#### 4.1.3. Migrate the `user(uniqueInput: UserUniqueInput): User` query[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#413-migrate-the-useruniqueinput-useruniqueinput-user-query \"Direct link to 413-migrate-the-useruniqueinput-useruniqueinput-user-query\")\n\nIn the sample API, the `user` query is implemented as follows:\n\n```\ninputObjectType({  name: 'UserUniqueInput',  definition(t) {    t.string('id')    t.string('email')  },})queryType({  definition(t) {    t.field('user', {      type: 'User',      args: {        userUniqueInput: schema.arg({          type: 'UserUniqueInput',          nullable: false,        }),      },      resolve: (_, args, context) => {        return context.prisma.user({          id: args.userUniqueInput?.id,          email: args.userUniqueInput?.email,        })      },    })  },})\n```\n\nYou now need to adjust the call to your `prisma` instance since the new Prisma Client API looks a bit different from the one used in Prisma 1.\n\n```\nconst Query = queryType({  definition(t) {    t.field('user', {      type: 'User',      args: {        userUniqueInput: arg({          type: 'UserUniqueInput',          nullable: false,        }),      },      resolve: (_, args, context) => {        return context.prisma.user.findUnique({          where: {            id: args.userUniqueInput?.id,            email: args.userUniqueInput?.email,          },        })      },    })  },})\n```\n\n### 4.2. Migrate GraphQL mutations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#42-migrate-graphql-mutations \"Direct link to 4.2. Migrate GraphQL mutations\")\n\nIn this section, you'll migrate the GraphQL mutations from the sample schema to the latest versions of `@nexus/schema` and the `nexus-plugin-prisma`.\n\n#### 4.2.1. Migrate the `createUser` mutation[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#421-migrate-the-createuser-mutation \"Direct link to 421-migrate-the-createuser-mutation\")\n\nIn our sample API, the `createUser` mutation from the sample GraphQL schema is implemented as follows.\n\n```\nconst Mutation = prismaObjectType({  name: 'Mutation',  definition(t) {    t.prismaFields(['createUser'])  },})\n```\n\nTo get the same behavior with the latest versions of `@nexus/schema` and the `nexus-plugin-prisma`, you need to call the `createOneUser` function on `t.crud` and pass an `alias` in order to rename the field in your GraphQL schema to `createUser` (otherwise it would be called `createOneUser`, after the function that's used):\n\n```\nconst Query = queryType({  definition(t) {    t.crud.createOneUser({      alias: 'createUser',    })  },})\n```\n\nRecall that the `crud` property is added to `t` by the `nexus-plugin-prisma` (using the same mechanism as for `t.model`).\n\nIn the sample app, the `createDraft` mutation implemented as follows.\n\n```\nmutationType({  definition(t) {    t.field('createDraft', {      type: 'Post',      args: {        title: stringArg({ nullable: false }),        content: stringArg(),        authorId: stringArg({ nullable: false }),      },      resolve: (_, args, context) => {        return context.prisma.createPost({          title: args.title,          content: args.content,          author: {            connect: { id: args.authorId },          },        })      },    })  },})\n```\n\nYou now need to adjust the call to your `prisma` instance since the new Prisma Client API looks a bit different from the one used in Prisma 1.\n\n```\nconst Mutation = mutationType({  definition(t) {    t.field('createDraft', {      type: 'Post',      args: {        title: stringArg({ nullable: false }),        content: stringArg(),        authorId: stringArg({ nullable: false }),      },      resolve: (_, args, context) => {        return context.prisma.post.create({          data: {            title: args.title,            content: args.content,            author: {              connect: { id: args.authorId },            },          },        })      },    })  },})\n```\n\n#### 4.2.3. Migrate the `updateBio(bio: String, userUniqueInput: UserUniqueInput!): User` mutation[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#423-migrate-the-updatebiobio-string-useruniqueinput-useruniqueinput-user-mutation \"Direct link to 423-migrate-the-updatebiobio-string-useruniqueinput-useruniqueinput-user-mutation\")\n\nIn the sample API, the `updateBio` mutation is defined and implemented as follows.\n\n```\nmutationType({  definition(t) {    t.field('updateBio', {      type: 'User',      args: {        userUniqueInput: arg({          type: 'UserUniqueInput',          nullable: false,        }),        bio: stringArg(),      },      resolve: (_, args, context) => {        return context.prisma.updateUser({          where: {            id: args.userUniqueInput?.id,            email: args.userUniqueInput?.email,          },          data: {            profile: {              create: { bio: args.bio },            },          },        })      },    })  },})\n```\n\nYou now need to adjust the call to your `prisma` instance since the new Prisma Client API looks a bit different from the one used in Prisma 1.\n\n```\nconst Mutation = mutationType({  definition(t) {    t.field('updateBio', {      type: 'User',      args: {        userUniqueInput: arg({          type: 'UserUniqueInput',          nullable: false,        }),        bio: stringArg(),      },      resolve: (_, args, context) => {        return context.prisma.user.update({          where: {            id: args.userUniqueInput?.id,            email: args.userUniqueInput?.email,          },          data: {            profile: {              create: { bio: args.bio },            },          },        })      },    })  },})\n```\n\n#### 4.2.4. Migrate the `addPostToCategories(postId: String!, categoryIds: [String!]!): Post` mutation[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#424-migrate-the-addposttocategoriespostid-string-categoryids-string-post-mutation \"Direct link to 424-migrate-the-addposttocategoriespostid-string-categoryids-string-post-mutation\")\n\nIn the sample API, the `addPostToCategories` mutation is defined and implemented as follows.\n\n```\nmutationType({  definition(t) {    t.field('addPostToCategories', {      type: 'Post',      args: {        postId: stringArg({ nullable: false }),        categoryIds: stringArg({          list: true,          nullable: false,        }),      },      resolve: (_, args, context) => {        const ids = args.categoryIds.map((id) => ({ id }))        return context.prisma.updatePost({          where: {            id: args.postId,          },          data: {            categories: { connect: ids },          },        })      },    })  },})\n```\n\nYou now need to adjust the call to your `prisma` instance since the new Prisma Client API looks a bit different from the one used in Prisma 1.\n\n```\nconst Mutation = mutationType({  definition(t) {    t.field('addPostToCategories', {      type: 'Post',      args: {        postId: stringArg({ nullable: false }),        categoryIds: stringArg({          list: true,          nullable: false,        }),      },      resolve: (_, args, context) => {        const ids = args.categoryIds.map((id) => ({ id }))        return context.prisma.post.update({          where: {            id: args.postId,          },          data: {            categories: { connect: ids },          },        })      },    })  },})\n```\n\n## 5\\. Cleaning up[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#5-cleaning-up \"Direct link to 5. Cleaning up\")\n\n### 5.1. Clean up npm dependencies[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#51-clean-up-npm-dependencies \"Direct link to 5.1. Clean up npm dependencies\")\n\nIf you haven't already, you can now uninstall dependencies that were related to the Prisma 1 setup:\n\n```\nnpm uninstall prisma1 prisma-client-lib\n```\n\n### 5.2. Delete unused files[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#52-delete-unused-files \"Direct link to 5.2. Delete unused files\")\n\nNext, delete the files of your Prisma 1 setup:\n\n```\nrm -rf src/generatedrm -rf prisma1\n```\n\n### 5.3. Stop the Prisma ORM server[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus#53-stop-the-prisma-orm-server \"Direct link to 5.3. Stop the Prisma ORM server\")\n\nFinally, you can stop running your Prisma ORM server.",
    "title": "Upgrade Prisma 1 with nexus-prisma to @nexus/schema | Prisma Documentation",
    "description": "Learn how to upgrade existing Prisma 1 projects with nexus-prisma to Prisma ORM 2 and Nexus.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api",
    "markdown": "# Upgrading a REST API from Prisma 1 to Prisma ORM 2\n\n## Overview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#overview \"Direct link to Overview\")\n\nThis upgrade guide describes how to migrate a Node.js project that's based on [Prisma 1](https://github.com/prisma/prisma1) and uses the [Prisma 1 client](https://v1.prisma.io/docs/1.34/prisma-client/) to implement a REST API.\n\nThe guide assumes that you already went through the [guide for upgrading the Prisma ORM layer](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql). This means you already:\n\n*   installed the Prisma ORM 2 CLI\n*   created your Prisma ORM 2 schema\n*   introspected your database and resolved potential schema incompatibilities\n*   installed and generated Prisma Client\n\nThe guide further assumes that you have a file setup that looks similar to this:\n\n```\n.├── README.md├── package-lock.json├── package.json├── prisma│   ├── datamodel.prisma│   ├── docker-compose-mysql.yml│   ├── docker-compose.yml│   ├── prisma.yml│   └── seed.graphql├── src│   ├── generated│   │   └── prisma-client│   │       ├── index.ts│   │       └── prisma-schema.ts│   └── index.ts└── tsconfig.json\n```\n\nThe important parts are:\n\n*   A folder called with `prisma` with your Prisma ORM 2 schema\n*   A folder called `src` with your application code\n\nIf this is not what your project structure looks like, you'll need to adjust the instructions in the guide to match your own setup.\n\n## 1\\. Adjust the application to use Prisma Client 2[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#1-adjust-the-application-to-use-prisma-client-2 \"Direct link to 1. Adjust the application to use Prisma Client 2\")\n\nFor the purpose of this guide, we'll use the sample API calls from the [`rest-express`](https://github.com/prisma/prisma1-examples/tree/master/typescript/rest-express) example in the [`prisma1-examples`](https://github.com/prisma/prisma1-examples/) repository.\n\nThe application code in our example is located in a single file and looks as follows:\n\n```\nimport * as express from 'express'import * as bodyParser from 'body-parser'import { prisma } from './generated/prisma-client'const app = express()app.$use(bodyParser.json())app.post(`/user`, async (req, res) => {  const result = await prisma.createUser({    ...req.body,  })  res.json(result)})app.post(`/post`, async (req, res) => {  const { title, content, authorEmail } = req.body  const result = await prisma.createPost({    title: title,    content: content,    author: { connect: { email: authorEmail } },  })  res.json(result)})app.put('/publish/:id', async (req, res) => {  const { id } = req.params  const post = await prisma.updatePost({    where: { id },    data: { published: true },  })  res.json(post)})app.delete(`/post/:id`, async (req, res) => {  const { id } = req.params  const post = await prisma.deletePost({ id })  res.json(post)})app.get(`/post/:id`, async (req, res) => {  const { id } = req.params  const post = await prisma.post({ id })  res.json(post)})app.get('/feed', async (req, res) => {  const posts = await prisma.post({ where: { published: true } })  res.json(posts)})app.get('/filterPosts', async (req, res) => {  const { searchString } = req.query  const draftPosts = await prisma.post({    where: {      OR: [        {          title_contains: searchString,        },        {          content_contains: searchString,        },      ],    },  })  res.json(draftPosts)})app.listen(3000, () =>  console.log('Server is running on http://localhost:3000'))\n```\n\nConsider each occurrence of the Prisma Client instance `prisma` and replacing with the respective usage of Prisma Client 2. You can learn more in the [API Reference](https://www.prisma.io/docs/orm/prisma-client).\n\n### 1.1. Adjusting the import[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#11-adjusting-the-import \"Direct link to 1.1. Adjusting the import\")\n\nImport the generated `@prisma/client` node module as shown:\n\n```\nimport { PrismaClient } from '@prisma/client'\n```\n\nNote that this only imports the `PrismaClient` constructor, so you also need to instantiate a Prisma Client 2 instance:\n\n```\nconst prisma = new PrismaClient()\n```\n\n### 1.2. Adjusting the `/user` route (`POST`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#12-adjusting-the-user-route-post \"Direct link to 12-adjusting-the-user-route-post\")\n\nWith the Prisma Client 2 API, the `/user` route for `POST` requests has to be changed to:\n\n```\napp.post(`/user`, async (req, res) => {  const result = await prisma.user.create({    data: {      ...req.body,    },  })  res.json(result)})\n```\n\n### 1.3. Adjusting the `/post` route (`POST`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#13-adjusting-the-post-route-post \"Direct link to 13-adjusting-the-post-route-post\")\n\nWith the Prisma Client 2 API, the `/post` route for `POST` requests has to be changed to:\n\n```\napp.post(`/post`, async (req, res) => {  const { title, content, authorEmail } = req.body  const result = await prisma.post.create({    data: {      title: title,      content: content,      author: { connect: { email: authorEmail } },    },  })  res.json(result)})\n```\n\n### 1.4. Adjusting the `/publish/:id` route (`PUT`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#14-adjusting-the-publishid-route-put \"Direct link to 14-adjusting-the-publishid-route-put\")\n\nWith the Prisma Client 2 API, the `/publish/:id` route for `PUT` requests has to be changed to:\n\n```\napp.put('/publish/:id', async (req, res) => {  const { id } = req.params  const post = await prisma.post.update({    where: { id },    data: { published: true },  })  res.json(post)})\n```\n\n### 1.5. Adjusting the `/post/:id` route (`DELETE`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#15-adjusting-the-postid-route-delete \"Direct link to 15-adjusting-the-postid-route-delete\")\n\nWith the Prisma Client 2 API, the `//post/:id` route for `DELETE` requests has to be changed to:\n\n```\napp.delete(`/post/:id`, async (req, res) => {  const { id } = req.params  const post = await prisma.post.delete({    where: { id },  })  res.json(post)})\n```\n\n### 1.6. Adjusting the `/post/:id` route (`GET`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#16-adjusting-the-postid-route-get \"Direct link to 16-adjusting-the-postid-route-get\")\n\nWith the Prisma Client 2 API, the `/post/:id` route for `GET` requests has to be changed to:\n\n```\napp.get(`/post/:id`, async (req, res) => {  const { id } = req.params  const post = await prisma.post.findUnique({    where: { id },  })  res.json(post)})\n```\n\n### 1.7. Adjusting the `/feed` route (`GET`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#17-adjusting-the-feed-route-get \"Direct link to 17-adjusting-the-feed-route-get\")\n\nWith the Prisma Client 2 API, the `/feed` route for `GET` requests has to be changed to:\n\n```\napp.get('/feed', async (req, res) => {  const posts = await prisma.post.findMany({ where: { published: true } })  res.json(posts)})\n```\n\n### 1.8. Adjusting the `/filterPosts` route (`GET`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api#18-adjusting-the-filterposts-route-get \"Direct link to 18-adjusting-the-filterposts-route-get\")\n\nWith the Prisma Client 2 API, the `/user` route for `POST` requests has to be changed to:\n\n```\napp.get('/filterPosts', async (req, res) => {  const { searchString } = req.query  const filteredPosts = await prisma.post.findMany({    where: {      OR: [        {          title: { contains: searchString },        },        {          content: { contains: searchString },        },      ],    },  })  res.json(filteredPosts)})\n```",
    "title": "Upgrading a REST API from Prisma 1 to Prisma ORM 2 | Prisma Documentation",
    "description": "Learn how to upgrade a REST API from Prisma 1 to Prisma ORM 2.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql",
    "markdown": "# Upgrading the Prisma ORM layer to Prisma ORM 2 | MySQL\n\n## Overview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#overview \"Direct link to Overview\")\n\nThis page explains the first step of your upgrade process: Taking your Prisma 1 configuration and upgrading it to Prisma ORM 2. Concretely, you will learn how to:\n\n1.  Add the Prisma ORM 2 CLI as a development dependency\n2.  Create your Prisma ORM 2 schema\n3.  Determine your connection URL and connect to your database\n4.  Introspect your database (that was so far managed with Prisma 1)\n5.  Use the [Prisma 1 Upgrade CLI](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#prisma-1-upgrade-cli) to resolve the [schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql) in the new Prisma ORM 2 data model\n6.  Install and generate Prisma Client\n\nOnce done with these steps, you can move on to the next guide that explains how you can upgrade the application layer to use Prisma Client for your database queries.\n\n> **Note**: During the upgrade process it can be helpful to get a graphical view on your database. It is therefore recommended to use a graphical database client to connect to your database, such as [TablePlus](https://tableplus.com/) or [Postico](https://eggerapps.at/postico/).\n\n## 1\\. Install Prisma ORM 2 CLI[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#1-install-prisma-orm-2-cli \"Direct link to 1. Install Prisma ORM 2 CLI\")\n\nThe Prisma ORM 2 CLI is available as the [`prisma`](https://www.npmjs.com/package/prisma) package on npm and is invoked via the `prisma` command.\n\nNote that the former `prisma` command for Prisma 1 has been renamed to `prisma1`. You can learn more about this [here](https://www.prisma.io/blog/prisma-2-beta-b7bcl0gd8d8e#renaming-the-prisma2-cli).\n\nYou can install the Prisma ORM 2 CLI in your Node.js project as follows (be sure to invoke this command in the directory where your `package.json` is located):\n\n```\nnpm install prisma --save-dev\n```\n\n> **Note**: With Prisma 1, it was usually recommended to install the CLI globally. We now recommend to [install the Prisma CLI locally](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) to prevent version conflicts.\n\nYou can now use the local installation of the `prisma` CLI by prefixing it with `npx`:\n\nIf you're upgrading your entire project [all at once](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-strategies), you can now also uninstall the Prisma 1 CLI (otherwise expand below):\n\n```\n# remove global installationnpm uninstall -g prisma1# remove local installationnpm uninstall prisma1\n```\n\n  \nExpand if you want to keep using your Prisma 1 CLI side-by-side\n\nIf you want to keep using the Prisma 1 CLI, it is recommend to remove your global installation of it and add the `prisma1` CLI as a development dependency:\n\n```\n# installs v1.34 of the Prisma 1 CLInpm uninstall -g prismanpm install prisma1 --save-dev\n```\n\nYou can now invoke it as follows:\n\nNote that if you need a CLI version smaller than 1.34 (e.g. 1.30), you can install it as follows:\n\n```\n# installs v1.30 of the Prisma 1 CLInpm uninstall -g prisma@1.30npm install prisma@1.30 --save-dev\n```\n\nYou can now invoke it as follows:\n\n## 2\\. Create your Prisma ORM 2 schema[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#2-create-your-prisma-orm-2-schema \"Direct link to 2. Create your Prisma ORM 2 schema\")\n\nFor this guide, you'll first create a new Prisma schema using the `prisma init` command and then \"fill\" it with a data model using [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nRun the following command to create your Prisma schema (note that this throws an error if you already have a folder called `prisma`):\n\nIf you're seeing the following error, you need to rename your current `prisma` directory:\n\n```\nERROR  A folder called prisma already exists in your project.       Please try again in a project that is not yet using Prisma.\n```\n\nYou can rename the current `prisma` directory to `prisma1` to make it clear that this holds the former Prisma 1 configuration:\n\nNow you can run `init` and it will succeed:\n\nIt should print the following output:\n\n```\n✔ Your Prisma schema was created at prisma/schema.prisma.  You can now open it in your favorite editor.Next steps:1. Set the `DATABASE_URL` in the `.env` file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started2. Set the `provider` of your `datasource` block in `schema.prisma` to match your database: `postgresql`, `mysql` or `sqlite`.3. Run `prisma db pull` to turn your database schema into a Prisma data model.4. Run `prisma generate` to install Prisma Client. You can then start querying your database.More information in our documentation:https://pris.ly/d/getting-started\n```\n\nThe command created a new folder called `prisma`, and two files:\n\n*   `prisma/schema.prisma`: Your Prisma schema that specifies the [data source](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources), [generator](https://www.prisma.io/docs/orm/prisma-schema/overview/generators) and [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) (note that the data model doesn't exist yet, it will be generated via introspection).\n*   `.env`: A [dotenv](https://github.com/motdotla/dotenv#readme) file to configure your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls).\n\nYour initial Prisma schema looks as follows:\n\nschema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\nWith Prisma 1, you specify which language variant of Prisma Client you wanted to use in your `prisma.yml`. With Prisma ORM 2, this information is now specified inside the Prisma schema via a `generator` block.\n\n> **Note**: Unlike Prisma 1, the TypeScript and JavaScript variants of Prisma Client 2.0 use the _same_ generator called `prisma-client-js`. The generated types in `index.d.ts` are _always_ included, even in plain JavaScript projects. This enables feature like autocompletion in VS Code even when not using TypeScript.\n\n## 3\\. Determine your connection URL and connect to your database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#3-determine-your-connection-url-and-connect-to-your-database \"Direct link to 3. Determine your connection URL and connect to your database\")\n\nWith Prisma 1, the database connection is configured in the Docker Compose file that's used to launch the Prisma ORM server. The Prisma ORM server then exposes a GraphQL endpoint (via HTTP) that proxies all database requests from the Prisma Client application code. That HTTP endpoint is specified in your `prisma.yml`.\n\nWith Prisma ORM 2, the HTTP layer isn't exposed any more and Prisma Client 2.0 is configured to run requests \"directly\" against the database (that is, requests are proxied by Prisma ORM's [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines), but there isn't an extra server any more).\n\nSo, as a next step you'll need to tell Prisma ORM 2 _what_ kind of database you use (MySQL or PostgreSQL) and _where_ it is located.\n\nFirst, you need to ensure that that `provider` field on the `datasource` block inside `schema.prisma` is configured to use the right database:\n\n*   If you're using PostgreSQL, it needs to define the value `\"postgresql\"` in the `provider` field.\n*   If you're using MySQL, it needs to define the value `\"mysql\"` in the `provider` field.\n\nSwitch around with the tabs in the code block to see examples of both:\n\n*   PostgreSQL\n*   MySQL\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nWith the `provider` field set, you can go ahead and configure the connection URL inside the `.env` file.\n\nAssume the database configuration in your Docker Compose file that you used to deploy your Prisma ORM server looks as follows:\n\ndocker-compose.yml\n\n```\nPRISMA_CONFIG: |  port: 4466  databases:    default:      connector: mysql      host: mysql      port: 3306      user: root      password: randompassword\n```\n\nAlso assume your `endpoint` in `prisma.yml` is configured as follows:\n\nprisma.yml\n\n```\nendpoint: http://localhost:4466/myproject/dev\n```\n\nBased on these connection details, you need to configure the `DATABASE_URL` environment variable inside your `.env` file as follows:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root:randompassword@localhost:3306/myproject@dev\"\n```\n\nNote that the _database name_ in the connection URL is typically composed of your _service name_ and _service stage_ (which are part of the `endpoint` in `prisma.yml`), separated by the `@` character.\n\nSometimes no service name and stage are specified in `prisma.yml`:\n\nprisma.yml\n\n```\nendpoint: http://localhost:4466/\n```\n\nIn that case, the database name must be specified as follows:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root:randompassword@localhost:3306/default@default\"\n```\n\nLearn more on the [Connection URLs](https://www.prisma.io/docs/orm/reference/connection-urls) page.\n\n## 4\\. Introspect your database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#4-introspect-your-database \"Direct link to 4. Introspect your database\")\n\nFor the purpose of this guide, we'll use the following Prisma 1 data model (select the **SQL** tab below to see what the data model maps to in SQL):\n\n*   Prisma 1 Data Model\n*   SQL\n\n```\ntype User {  id: ID! @id  email: String @unique  name: String!  role: Role! @default(value: CUSTOMER)  jsonData: Json  profile: Profile  posts: [Post!]!}type Post {  id: ID! @id  createdAt: DateTime! @createdAt  updatedAt: DateTime! @updatedAt  title: String!  content: String  published: Boolean! @default(value: false)  author: User @relation(link: TABLE)  categories: [Category!]!}type Profile {  id: ID! @id  bio: String  user: User! @relation(link: INLINE)}type Category {  id: ID! @id  name: String!  posts: [Post!]!}enum Role {  ADMIN  CUSTOMER}\n```\n\nNote that this data model has three [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations):\n\n*   1-1: `User` ↔ `Profile`\n*   1-n: `User` ↔ `Post` (maintained via the `_PostToUser` relation table)\n*   m-n: `Post` ↔ `Category` (maintained via the `_CategoryToPost` relation table)\n\nNow you can run Prisma ORM's introspection against your database with the following command:\n\nHere's a graphical illustration for what happens when `db pull` is invoked:\n\n![Introspect your database](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nFor the above Prisma 1 datamodel, this results in the following Prisma ORM 2 schema (note that the models have been reordered to match the initial order of the Prisma 1 datamodel):\n\nschema.prisma\n\n```\nmodel User {  id       String    @id @default(cuid())  email    String?   @unique  name     String  role     String  jsonData String?  Profile  Profile[]  Post     Post[]}model Post {  id        String     @id @default(cuid())  createdAt DateTime  updatedAt DateTime  title     String  content   String?  published Boolean  Category  Category[]  User      User[]}model Profile {  id   String  @id @default(cuid())  bio  String?  user String? @unique  User User?   @relation(fields: [user], references: [id])}model Category {  id   String @id @default(cuid())  name String  Post Post[]}\n```\n\nWhile this is already a valid Prisma ORM 2 schema, it lacks a number of _features_ that were part of its Prisma 1 equivalent:\n\n*   no auto-generated date values for the `createdAt` and `updatedAt` fields on `Post`\n*   no default value for the `role` field on `User`\n*   no default value for the `published` field on `Post`\n\nThere further are a number of inconsistencies which result in a less idiomatic/ergonomic Prisma Client API:\n\n*   `User` ↔ `Profile` is a 1-n instead of 1-1 relation\n*   `User` ↔ `Post` is a m-n instead of 1-n relation\n*   relation fields are uppercased (e.g. `Profile` and `Post` on `User`)\n*   the `jsonData` field on `User` is of type `String` instead of `Json`\n*   the `role` field on `User` is of type `String` instead of `Role`, the `enum` definition for role is missing altogether\n\nWhile these inconsistencies don't actually impact the \"feature set\" you'll have available in your Prisma Client API, they make you lose certain constraints/guarantees that were present before.\n\nFor example, Prisma ORM now won't guarantee that a `User` is connected to _at most_ one `Profile` because the relation between the tables was recognized as 1-n during introspection, so one `User` record _could_ now get connected to multiple `Profile` records.\n\nAnother issue is that you can store whatever text for the `jsonData` and `role` fields, regardless of whether it's valid JSON or represents a value of the `Role` enum.\n\nTo learn more about these inconsistencies check out the [Schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql) page.\n\nIn the following, we'll go through these incompatibilities and fix them one by one using the Prisma schema upgrade CLI.\n\n## 5\\. Use the Prisma schema upgrade CLI to resolve schema incompatibilities[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#5-use-the-prisma-schema-upgrade-cli-to-resolve-schema-incompatibilities \"Direct link to 5. Use the Prisma schema upgrade CLI to resolve schema incompatibilities\")\n\nThe [Prisma 1 Upgrade CLI](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#prisma-1-upgrade-cli) is an interactive tool that helps you upgrading your Prisma schema and ironing out most of the inconsistencies listed above.\n\nThe Prisma 1 Upgrade CLI works in two major phases:\n\n1.  Fix the database schema via plain SQL\n2.  Add missing attributes to the Prisma ORM 2 schema and other schema fixes\n\nDuring the first phase, it will generate and print a number of SQL statements that you should run against your database to adjust the database schema. You can either run all of the statements or a subset of them before continuing to the second phase.\n\nDuring the second phase, you don't need to do anything manually. The Upgrade CLI will make changes to your Prisma schema by adding certain Prisma ORM-level attributes (like `@default(cuid))` or `@updatedAt`), adjusting the names of relation fields to match the ones from your Prisma 1 datamodel and ensure 1-1-relations that were required on both sides in your Prisma 1 datamodel are also required in the Prisma ORM 2 schema.\n\nNote that **you can start over at any time during the process** and go back from the second to the first phase.\n\nIn this illustration, the green area shows the first phase, the blue area shows the second phase. Note that you can optionally run `prisma db pull` in between the phases to update your Prisma ORM data model:\n\n![Fixing the schema incompatibilities](https://www.prisma.io/docs/assets/images/fix-schema-incompatibilities-09a1632f64517dbb92da2de4416337e8.png)\n\nTo use the Upgrade CLI, you can either install it locally in your project, or invoke it once without installation using `npx` as done here:\n\n```\nnpx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma\n```\n\nThe CLI will greet you with the following message:\n\n```\n◮ Welcome to the interactive Prisma Upgrade CLI that helps with theupgrade process from Prisma 1 to Prisma ORM 2.Please read the docs to learn more about the upgrade process:https://pris.ly/d/how-to-upgrade➤ GoalThe Upgrade CLI helps you resolve the schema incompatibilitiesbetween Prisma 1 and Prisma ORM 2. Learn more in the docs:https://pris.ly/d/schema-incompatibilities➤ How it worksThroughout the process, you'll need to adjust your database schema by sendingSQL statements to it. The SQL statements are provided by the Upgrade CLI.Note that the Upgrade CLI never makes changes to your database,you are in full control over any operations that are executed against it.You can stop and re-run the Upgrade CLI at any time.These are the different steps of the upgrade process:  1. The Upgrade CLI generates SQL commands for you to run on your database.  2. You run the SQL commands against your database.  3. You run the `npx prisma db pull` command again.  4. You run the `npx prisma-upgrade` command again.  5. The Upgrade CLI adjusts the Prisma ORM 2 schema by adding missing attributes.➤ NoteIt is recommended that you make a full backup of your existing data before startingthe upgrade process. If possible, the migration should be performed in a stagingenvironment before executed against a production environment.➤ HelpIf you have any questions or run into any problems along the way,please create an issue at:https://github.com/prisma/upgrade/issues/newAre you ready? [Y/n]\n```\n\nPress the Y button, then confirm by hitting RETURN on your keyboard to continue.\n\nOnce you confirmed, the CLI outputs the SQL statements you should be running against your database:\n\n```\n➤ Adjust your database schemaRun the following SQL statements against your database:  Fix columns with ENUM data types  https://pris.ly/d/schema-incompatibilities#enums-are-represented-as-text-in-database    ALTER TABLE `User` CHANGE `role` `role` ENUM('ADMIN', 'CUSTOMER') NOT NULL;  Add missing `DEFAULT` constraints to the database  https://pris.ly/d/schema-incompatibilities#default-values-arent-represented-in-database    ALTER TABLE `User` CHANGE `role` `role` ENUM('ADMIN', 'CUSTOMER') NOT NULL DEFAULT 'CUSTOMER';    ALTER TABLE `Post` CHANGE `published` `published` TINYINT(1) NOT NULL DEFAULT 0;  Fix columns with JSON data types  https://pris.ly/d/schema-incompatibilities#json-type-is-represented-as-text-in-database    ALTER TABLE `User` CHANGE `jsonData` `jsonData` JSON ;  Replicate `@createdAt` behavior in Prisma ORM 2.0  https://pris.ly/d/schema-incompatibilities#createdat-isnt-represented-in-database    ALTER TABLE `Post` CHANGE `createdAt` `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;  Fix 1-1 relations by adding `UNIQUE` constraints  https://pris.ly/d/schema-incompatibilities#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint    ALTER TABLE `Profile` ADD UNIQUE (`user`);  Migrate IDs from varchar(25) to varchar(30)  https://pris.ly/d/schema-incompatibilities#mismatching-cuid-length    SET FOREIGN_KEY_CHECKS=0;    ALTER TABLE `Category` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;    ALTER TABLE `Post` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;    ALTER TABLE `Profile` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;    ALTER TABLE `Profile` CHANGE `user` `user` char(30) CHARACTER SET utf8 ;    ALTER TABLE `User` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;    SET FOREIGN_KEY_CHECKS=1;➤ Breaking changes detectedIn order to fully optimize your database schema, you'll need to run a few SQLstatements that can break your Prisma 1 setup. Note that these changes are optionaland if you are upgrading gradually and running Prisma 1 and Prisma ORM 2 side-by-side,you should not perform these changes yet. Instead, you can perform them wheneveryou are ready to completely remove Prisma 1 from your project.If you are upgrading all at once, you can safely perform these changes now.Learn more in the docs:https://pris.ly/d/how-to-upgrade'\n```\n\n> **Note**: If you're seeing the note about breaking changes, you can ignore it for now. We'll discuss it later.\n\nThe shown SQL statements are categorized into a number of \"buckets\", all aiming to resolve a certain [schema incompatibility](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql):\n\n*   Fix columns with ENUM data types\n*   Add missing `DEFAULT` constraints to the database\n*   Fix columns with JSON data types\n*   Replicate `@createdAt` behavior in Prisma 2\n*   Fix 1-1 relations by adding `UNIQUE` constraints\n\nAs a next step, you can start sending the SQL statements to your database. Note that all of these changes are non-breaking and you'll be able to continue using Prisma 1 side-by-side with Prisma ORM 2.\n\nThe next sections cover the different kinds of SQL statements to be sent to your database individually.\n\n### 5.1. Fix the database schema via plain SQL (non-breaking)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#51-fix-the-database-schema-via-plain-sql-non-breaking \"Direct link to 5.1. Fix the database schema via plain SQL (non-breaking)\")\n\nIn this section, we'll walk through the printed SQL statements and run them against the database one by one.\n\n### 5.1.1. Fix columns with ENUM data types[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#511-fix-columns-with-enum-data-types \"Direct link to 5.1.1. Fix columns with ENUM data types\")\n\nThe first thing the tool does is help you ensure that `enum` definitions in your Prisma 1 datamodel will be represented as actual `ENUM` types in the underlying database, right now they are represented as plain strings (e.g. as `MEDIUMTEXT` in MySQL).\n\nThe CLI currently shows the following output:\n\n```\nFix columns with ENUM data typeshttps://pris.ly/d/schema-incompatibilities#enums-are-represented-as-text-in-database  ALTER TABLE `User` CHANGE `role` `role` ENUM('ADMIN', 'CUSTOMER') NOT NULL;\n```\n\nGo ahead and run these statements against your database now.\n\n![Altering columns to use ENUM with SQL](https://www.prisma.io/docs/assets/images/altering-columns-to-use-enum-bb9dd5b6096ca5acfdf83878da7b892a.png)\n\n### 5.1.2. Add missing `DEFAULT` constraints to the database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#512-add-missing-default-constraints-to-the-database \"Direct link to 512-add-missing-default-constraints-to-the-database\")\n\nNext, the Upgrade CLI helps you resolve the issue that [default values aren't represented in the database](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#default-values-arent-represented-in-database) by generating SQL statements that add the respective `DEFAULT` constraints directly to the database.\n\nIn this case, two `DEFAULT` constraints are missing which are suggested by the tool:\n\n```\nAdd missing `DEFAULT` constraints to the databasehttps://pris.ly/d/schema-incompatibilities#default-values-arent-represented-in-database  ALTER TABLE `User` CHANGE `role` `role` ENUM('ADMIN', 'CUSTOMER') NOT NULL DEFAULT 'CUSTOMER';  ALTER TABLE `Post` CHANGE `published` `published` TINYINT(1) NOT NULL DEFAULT 0;\n```\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like TablePlus:\n\n![TablePlus GUI](https://www.prisma.io/docs/assets/images/TablePlus-GUI-5d298d92541ecacb87c261763594ccf4.png)\n\n### 5.1.3. Fix columns with JSON data types[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#513-fix-columns-with-json-data-types \"Direct link to 5.1.3. Fix columns with JSON data types\")\n\nNext, the tool helps you ensure that `Json` fields in your Prisma 1 datamodel will be represented as `JSON` columns in the underlying database, right now they are represented as plain strings (e.g. as `MEDIUMTEXT` in MySQL).\n\nChanging the column type to `JSON` will ensure that the field is properly recognized as `Json` during Prisma ORM 2 introspection.\n\nThe CLI currently shows the following output:\n\n```\nFix columns with JSON data typeshttps://pris.ly/d/schema-incompatibilities#json-type-is-represented-as-text-in-database  ALTER TABLE `User` CHANGE `jsonData` `jsonData` JSON ;\n```\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like TablePlus:\n\n![TablePlus GUI](https://www.prisma.io/docs/assets/images/fix-columns-with-json-data-types-2b1e09144ceeafe04cd49271e9d30798.png)\n\n### 5.1.4. Replicate `@createdAt` behavior in Prisma ORM 2[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#514-replicate-createdat-behavior-in-prisma-orm-2 \"Direct link to 514-replicate-createdat-behavior-in-prisma-orm-2\")\n\nThe next thing the tools does is help you resolve the issue that the behavior of [`@createdAt` isn't represented in database](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#default-values-arent-represented-in-database)\n\nThe CLI currently shows the following output:\n\n```\nReplicate `@createdAt` behavior in Prisma ORM 2.0https://pris.ly/d/schema-incompatibilities#createdat-isnt-represented-in-database  ALTER TABLE `Post` CHANGE `createdAt` `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;\n```\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like TablePlus.\n\n### 5.1.5. Fix 1-1 relations by adding `UNIQUE` constraints[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#515-fix-1-1-relations-by-adding-unique-constraints \"Direct link to 515-fix-1-1-relations-by-adding-unique-constraints\")\n\nNow, the tool will help you [turn the current 1-n relation between `User` ↔ `Profile` back into a 1-1 relation](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint) by adding a `UNIQUE` constraint to the foreign key column called `user` (named after the relation field in the Prisma 1 datamodel) in the database.\n\nThe CLI currently shows the following output:\n\n```\nFix 1-1 relations by adding `UNIQUE` constraintshttps://pris.ly/d/schema-incompatibilities#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint  ALTER TABLE `Profile` ADD UNIQUE (`user`);\n```\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like TablePlus.\n\n### 5.1.6. Fix mismatch of CUID length[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#516-fix-mismatch-of-cuid-length \"Direct link to 5.1.6. Fix mismatch of CUID length\")\n\n> **Note**: These SQL statements will keep appearing in the Upgrade CLI even after you have changed the column types in the underlying database. This is a currently a limitation in the Upgrade CLI.\n\nFinally, the tool will help you [turn the current ID columns of type `VARCHAR(25)` into `VARCHAR(30)`](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#mismatching-cuid-length) by adding a `UNIQUE` constraint to the foreign key column called `user` (named after the relation field in the Prisma 1 datamodel) in the database.\n\nThe CLI currently shows the following output:\n\n```\nMigrate IDs from varchar(25) to varchar(30)https://pris.ly/d/schema-incompatibilities#mismatching-cuid-lengthSET FOREIGN_KEY_CHECKS=0;ALTER TABLE `Category` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;ALTER TABLE `Post` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;ALTER TABLE `Profile` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;ALTER TABLE `Profile` CHANGE `user` `user` char(30) CHARACTER SET utf8 ;ALTER TABLE `User` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;SET FOREIGN_KEY_CHECKS=1;\n```\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like TablePlus.\n\n### 5.1.7. Breaking changes detected[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#517-breaking-changes-detected \"Direct link to 5.1.7. Breaking changes detected\")\n\nIn case the Upgrade CLI has printed a note about breaking changes, your database schema needs some adjustments that will break Prisma 1 compatibility in order to be fully optimized.\n\nIf there are no breaking changes detected, you can [skip forward to section 5.2](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#52-re-introspect-your-database-to-update-your-prisma-schema)\n\nDepending on your [upgrade strategy](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-strategies), you can either perform these changes now or skip to the next phase of the Upgrade CLI:\n\n*   If you are following the gradual side-by-side upgrade strategy, do not perform these changes yet since they will break your Prisma 1 setup. In that case, you can continue to the next phase of the Upgrade CLI by typing n and hitting RETURN.\n*   If you are following the all at once upgrade strategy, you can perform these changes now. In that case, continue by typing Y and hitting RETURN.\n\n### 5.2. Fix the database schema via plain SQL (breaking)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#52-fix-the-database-schema-via-plain-sql-breaking \"Direct link to 5.2. Fix the database schema via plain SQL (breaking)\")\n\nIn this section, you'll resolve the schema incompatibilities that are breaking your Prisma 1 setup. Do not perform these changes if you are still running Prisma 1 in your project!\n\n### 5.2.1. Fix incorrect m-n relations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#521-fix-incorrect-m-n-relations \"Direct link to 5.2.1. Fix incorrect m-n relations\")\n\nNow, the Upgrade CLI helps you fix all 1-1 and 1-n relations that Prisma 1 represents with relation tables and that [currently only exist as m-n relations](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#all-non-inline-relations-are-recognized-as-m-n) in your new Prisma ORM 2 schema. Concretely, this is the case for the `User` ↔ `Post` relation which currently is defined as m-n but _should_ really be a 1-n relation.\n\nTo fix this, you'll need to perform the following migration:\n\n1.  Create a new foreign key column on `Post` to link directly to the `User` table.\n2.  Migrate the foreign key values from the relation table into the new foreign key column on `Post`.\n3.  Delete the relation table.\n\nThese instructions are now printed by the CLI:\n\n```\n➤ Adjust your database schemaRun the following SQL statements against your database:  Fix one-to-many table relations  https://pris.ly/d/schema-incompatibilities#all-non-inline-relations-are-recognized-as-m-n    ALTER TABLE `Post` ADD COLUMN `authorId` char(25) CHARACTER SET utf8 ;    ALTER TABLE `Post` ADD CONSTRAINT author FOREIGN KEY (`authorId`) REFERENCES `User`(`id`);    UPDATE `Post`, `_PostToUser` SET `Post`.`authorId` = `_PostToUser`.B where `_PostToUser`.A = `Post`.`id`;    DROP TABLE `_PostToUser`;➤ Next StepsAfter you executed one or more of the above SQL statements against your database,please run the following two commands to refresh your Prisma ORM 2 Schema and checkthe changes.  1. Run `npx prisma db pull` again to refresh your Prisma ORM 2 schema.  2. Run `npx prisma-upgrade` again.If you can't or don't want to execute the remaining SQL statements right now, you canskip to the last step where the Upgrade CLI adds missing attributes to your Prisma ORM 2schema that are not picked up by introspection.Skip to the last step? [Y/n]?\n```\n\nFor this fix, you'll need to run three SQL statements:\n\n1.  Create new column `authorId` on the `Post` table. This column should be a _foreign key_ that references the `id` field of the `User` table:\n    \n    ```\n    ALTER TABLE `Post` ADD COLUMN `authorId` char(25) CHARACTER SET utf8 ;ALTER TABLE `Post` ADD CONSTRAINT author FOREIGN KEY (`authorId`) REFERENCES `User`(`id`);\n    ```\n    \n2.  Write a SQL query that reads all the rows from the `_PostToUser` relation table and for each row:\n    \n    1.  Finds the respective `Post` record by looking up the value from column `A`\n    2.  Inserts the value from column `B` as the value for `authorId` into that `Post` record\n    \n    ```\n    UPDATE `Post`, `_PostToUser` SET `Post`.`authorId` = `_PostToUser`.B where `_PostToUser`.A = `Post`.`id`;\n    ```\n    \n3.  Delete the `_PostToUser` relation table\n    \n    ```\n    DROP TABLE `_PostToUser`;\n    ```\n    \n\n![Fixing incorrect m-n relations with SQL](https://www.prisma.io/docs/assets/images/fix-incorrect-m-n-relations-sql-40f523e1ff9f3bab48da924500acf789.png)\n\nAfter these commands, the user ID values of the records from column `B` of the relation table are migrated to the new `authorId` column.\n\n### 5.2. Re-introspect your database to update your Prisma schema[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#52-re-introspect-your-database-to-update-your-prisma-schema \"Direct link to 5.2. Re-introspect your database to update your Prisma schema\")\n\nAt this point, you've resolved the schema incompatibilities with the Upgrade CLI. You can now exit the Upgrade CLI for now by typing n and hitting RETURN.\n\nIn this section, you'll update your Prisma schema with another introspection round. This time, the previous flaws of the Prisma schema will be resolved because the database schema has been adjusted:\n\nThis time, the resulting Prisma schema looks as follows:\n\nschema.prisma\n\n```\nmodel User {  id       String   @id  name     String  email    String?  @unique  jsonData Json?  role     Role     @default(CUSTOMER)  Post     Post[]  Profile  Profile?}model Post {  id        String     @id  createdAt DateTime   @default(now())  updatedAt DateTime  title     String  content   String?  published Boolean    @default(false)  authorId  String?  User      User?      @relation(fields: [authorId], references: [id])  Category  Category[] @relation(references: [id])}model Category {  id   String @id  name String  Post Post[] @relation(references: [id])}model Profile {  bio  String?  id   String  @id  user String? @unique  User User?   @relation(fields: [user], references: [id])}enum Role {  ADMIN  CUSTOMER}\n```\n\nThis schema has most issues resolved, but it still lacks the following:\n\n### 5.2. Add missing attributes to the Prisma 2 schema and other schema fixes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#52-add-missing-attributes-to-the-prisma-2-schema-and-other-schema-fixes \"Direct link to 5.2. Add missing attributes to the Prisma 2 schema and other schema fixes\")\n\nThe CLI now prints the following:\n\n```\n➤ What happens nextAs a last step, some final adjustments will be made to your Prisma ORM 2 schemato carry over some Prisma ORM-level attributes that aren't picked up by introspection.As a last step, some final adjustments will be made to your Prisma ORM 2.0schema to carry over some Prisma ORM-level attributes that aren't pickedup by introspection.WarningYour current Prisma ORM 2.0 schema will be overwritten, so pleasemake sure you have a backup!Are you ready? [Y/n]\n```\n\nAt this point, you either ran all the SQL statement that were printed by the CLI or you skipped some of them. Either way, you can now move on the last step and let the Upgrade CLI add the missing Prisma ORM 2 attributes. Typically these are the following:\n\n*   `@default(cuid())` for your `@id` fields\n*   `@updatedAt` for any fields that were using this attribute in Prisma 1\n*   `@map` and `@@map` as replacements for `@db` and `@@db` from Prisma 1\n\nIn that step, the Upgrade CLI also fixes other issues that occurred in the transition to Prisma ORM 2:\n\n*   it makes sure that 1-1-relations that were required on both sides in Prisma 1 are also required in your Prisma ORM 2 schema\n*   it renames relation fields to the same names they had in your Prisma 1 datamodel ([coming soon](https://github.com/prisma/upgrade/issues/25))\n\nTo apply these changes, you can re-run the Upgrade CLI:\n\n```\nnpx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma\n```\n\nIf you did not resolve all schema incompatibilities, the Upgrade CLI now prints the remaining SQL statements (as well as the ones for migrating IDs). You can just ignore them at this point and continue to the last step by continuously typing Y and hitting RETURN when prompted.\n\nIf you did resolve all schema incompatibilities, no SQL statements will be printed and the Upgrade CLI only outputs the following:\n\n```\n$ npx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma➤ Next StepsAfter you executed one or more of the previous SQL statements against your database,please run the following two commands to refresh your Prisma ORM 2 schema and checkthe changes.  1. Run `npx prisma db pull` again to refresh your Prisma ORM 2 schema.  2. Run `npx prisma-upgrade` again.If you can't or don't want to execute the remaining SQL statements right now, you canskip to the last step where the Upgrade CLI adds missing attributes to your Prisma ORM 2schema that are not picked up by introspection.Skip to the last step? [Y/n]?\n```\n\nOne more time, type Y and hit RETURN to confirm.\n\nThe final prompt of the Upgrade CLI now asks you to confirm the above mentioned changes it will make to your Prisma schema:\n\n```\n➤ What happens nextAs a last step, some final adjustments will be made to your Prisma ORM 2 schemato carry over some Prisma ORM-level attributes that aren't picked up by introspection.As a last step, some final adjustments will be made to your Prisma ORM 2.0schema to carry over some Prisma ORM-level attributes that aren't pickedup by introspection.WarningYour current Prisma ORM 2.0 schema will be overwritten, so pleasemake sure you have a backup!Are you ready? [Y/n]\n```\n\nOne last time, type Y and hit RETURN to confirm.\n\nThis is the final output of the Upgrade CLI:\n\n```\nUpdating prisma/schema.prisma...Done updating prisma/schema.prisma!✔ Congratulations, you're all set!➤ NoteIf you didn't execute all generated SQL commands against your database,you can re-run the Upgrade CLI at any time.Note that the Upgrade CLI doesn't resolve all of the schema incompatibilitiesbetween Prisma 1 and Prisma ORM 2. If you want to resolve the remaining ones,you can do so manually by following this guide:https://pris.ly/d/upgrading-the-prisma-layer➤ Next stepsOtherwise you can continue your upgrade process by installing Prisma Client 2:npm install @prisma/clientYou can find guides for different upgrade scenarios in the docs:https://pris.ly/d/upgrade-from-prisma-1\n```\n\n### 5.3. Final result[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#53-final-result \"Direct link to 5.3. Final result\")\n\nThe final version of the Prisma schema should look as follows:\n\nschema.prisma\n\n```\nmodel User {  id       String   @id @default(cuid())  name     String  email    String?  @unique  jsonData Json?  role     Role     @default(CUSTOMER)  Post     Post[]  Profile  Profile?}model Post {  id        String     @id @default(cuid())  createdAt DateTime   @default(now())  updatedAt DateTime   @updatedAt  title     String  content   String?  published Boolean    @default(false)  authorId  String?  User      User?      @relation(fields: [authorId], references: [id])  Category  Category[] @relation(references: [id])}model Profile {  id   String  @id @default(cuid())  bio  String?  user String? @unique  User User?   @relation(fields: [user], references: [id])}model Category {  id   String @id @default(cuid())  name String  Post Post[] @relation(references: [id])}enum Role {  ADMIN  CUSTOMER}\n```\n\n### 5.4. Rename relation fields[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#54-rename-relation-fields \"Direct link to 5.4. Rename relation fields\")\n\nOne thing you'll notice with this version of the Prisma ORM 2 schema is that all [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are named after their respective models, e.g:\n\nschema.prisma\n\n```\nmodel User {  Post    Post[]  Profile Profile?}model Post {  User     User?      @relation(fields: [authorId], references: [id])  Category Category[] @relation(references: [id])}model Profile {  User User? @relation(fields: [user], references: [id])}model Category {  Post Post[] @relation(references: [id])}\n```\n\nThis is not ideal and you can in fact manually rename all of them to their previous versions!\n\nBecause all relation fields are _virtual_, meaning they don't _manifest_ in the database, you can name them whatever you like. In this case, all relation fields are lowercased and sometimes pluralized.\n\nHere's what they look like after the rename:\n\nschema.prisma\n\n```\nmodel User {  posts   Post[]  profile Profile?}model Post {  author     User?      @relation(fields: [authorId], references: [id])  categories Category[] @relation(references: [id])}model Profile {  user  String? @unique  owner User?   @relation(fields: [user], references: [id])}model Category {  posts Post[] @relation(references: [id])}\n```\n\n> **Note**: For the 1-1-relation between `User` and `Profile` it was not possible to set the old name `user` for the relation field. This is because there'd be a naming conflict with the already existing [relation scalar](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#annotated-relation-fields) field that holds the foreign key. In that case, you can choose a different name or alternatively rename the foreign key column directly in the database via SQL.\n\n### 5.5. Resolving remaining schema incompatibilities[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#55-resolving-remaining-schema-incompatibilities \"Direct link to 5.5. Resolving remaining schema incompatibilities\")\n\nThere are a few schema incompatibilities that were not yet resolved by the Upgrade CLI. At this point you still haven't fixed [scalar lists](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql#scalar-lists-arrays-are-maintained-with-extra-table). You can find the recommended workarounds for this and others on the [Schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql) page.\n\n## 6\\. Install and generate Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#6-install-and-generate-prisma-client \"Direct link to 6. Install and generate Prisma Client\")\n\nNow that you have your Prisma ORM 2 schema ready, you can install Prisma Client with the following command:\n\n```\nnpm install @prisma/client\n```\n\n## 7\\. Next steps[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#7-next-steps \"Direct link to 7. Next steps\")\n\nCongratulations, you have now upgraded your Prisma ORM layer to Prisma ORM 2! From here on, you can move on to update your application code using one of the following guides:\n\n*   [Old to new Nexus](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus): Choose this guide if you're currently running Prisma 1 with GraphQL Nexus.\n*   [prisma-binding to Nexus](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus): Choose this guide if you're currently running Prisma 1 with `prisma-binding` and want to upgrade to [Nexus](https://www.nexusjs.org/#/) (and TypeScript).\n*   [prisma-binding to SDL-first](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first): Choose this guide if you're currently running Prisma 1 with `prisma-binding` and want to upgrade to an [SDL-first](https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3) GraphQL server.\n*   [REST API](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api): Choose this guide if you're currently running Prisma 1 using Prisma Client 1 and are building a REST API.\n\n## Bonus: Prisma Client API comparison[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#bonus-prisma-client-api-comparison \"Direct link to Bonus: Prisma Client API comparison\")\n\nThis section contains a high-level and side-by-side comparison of the Prisma Client APIs of Prisma 1 and Prisma ORM 2. For more details about the new Prisma Client API, you can explore the [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) docs.\n\n### Reading single records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#reading-single-records \"Direct link to Reading single records\")\n\n**Prisma Client (v1)**\n\n```\nconst user = await prisma.user({ id: 1 })\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findUnique({  where: { id: 1 },})\n```\n\n### Reading lists of records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#reading-lists-of-records \"Direct link to Reading lists of records\")\n\n**Prisma Client (v1)**\n\n```\nconst user = await prisma.users()\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findMany()\n```\n\n### Filtering lists[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#filtering-lists \"Direct link to Filtering lists\")\n\n**Prisma Client (v1)**\n\n```\nconst users = await prisma.users({  where: {    name: 'Alice',  },})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findMany({  where: {    name: 'Alice',  },})\n```\n\n### Paginating lists[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#paginating-lists \"Direct link to Paginating lists\")\n\n**Prisma Client (v1)**\n\n```\nconst posts = await prisma.posts({  skip: 5,  first: 10,})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findMany({  skip: 5,  take: 10,})\n```\n\n> **Note**: You can learn more about the new pagination API in the respective [release notes](https://github.com/prisma/prisma/releases/tag/2.0.0-beta.7) or the [Pagination](https://www.prisma.io/docs/orm/prisma-client/queries/pagination) page in the docs.\n\n### Sorting lists[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#sorting-lists \"Direct link to Sorting lists\")\n\n**Prisma Client (v1)**\n\n```\nawait prisma.posts({  orderBy: 'title_ASC',})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.posts({  orderBy: {    title: 'asc',  },})\n```\n\n### Creating records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#creating-records \"Direct link to Creating records\")\n\n**Prisma Client (v1)**\n\n```\nawait prisma.createUser({  name: 'Alice',})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.create({  data: {    name: 'Alice',  },})\n```\n\n### Updating records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#updating-records \"Direct link to Updating records\")\n\n**Prisma Client (v1)**\n\n```\nawait prisma.updateUser({  where: { id: 1 },  data: {    name: 'James',    email: 'james@prisma.io',  },})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.update({  where: { id: 1 },  data: {    name: 'James',    email: 'james@prisma.io',  },})\n```\n\n### Deleting records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#deleting-records \"Direct link to Deleting records\")\n\n**Prisma Client (v1)**\n\n```\nawait prisma.deleteUser({ id: 1 })\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.delete({  where: { id: 1 },})\n```\n\n### Selecting fields & loading relations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql#selecting-fields--loading-relations \"Direct link to Selecting fields & loading relations\")\n\nIn Prisma 1, the only ways to select specific fields and/or load relations of an object was by using the string-based `$fragment` and `$graphql` functions. With Prisma ORM 2, this is now done in a clean and type-safe manner using [`select`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#select-specific-fields) and [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields).\n\nAnother benefit of this approach is that you can use `select` and `include` on _any_ Prisma Client query, e.g. `findUnique`, `findMany`, `create`, `update`, `delete`, ...\n\n**Prisma Client (v1)**\n\n```\nawait prisma.user({ id: 1 }).$fragment(`  fragment NameAndEmail on User { id email }``)\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findUnique({  where: { id: 1 },  select: {    id: true,    email: true,  },})\n```\n\nAs an example, creating a new record and only retrieving the `id` in the returned object was not possible in Prisma 1. With Prisma ORM 2 you can achieve this as follows:\n\n```\nawait prisma.user.create({  data: {    name: 'Alice',  },  select: {    id: true,  },})\n```",
    "title": "Upgrading the Prisma ORM layer to Prisma ORM 2 | MySQL | Prisma Documentation",
    "description": "Learn how to upgrade the Prisma ORM layer to Prisma ORM 2 and create your Prisma schema with MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql",
    "markdown": "# Upgrading the Prisma ORM layer to Prisma ORM 2 | PostgreSQL\n\n## Overview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#overview \"Direct link to Overview\")\n\nThis page explains the first step of your upgrade process: Taking your Prisma 1 configuration and upgrading it to Prisma ORM 2. Concretely, you will learn how to:\n\n1.  Add the Prisma ORM 2 CLI as a development dependency\n2.  Create your Prisma ORM 2 schema\n3.  Determine your connection URL and connect to your database\n4.  Introspect your database (that was so far managed with Prisma 1)\n5.  Use the [Prisma 1 Upgrade CLI](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#prisma-1-upgrade-cli) to resolve the [schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql) in the new Prisma ORM 2 data model\n6.  Install and generate Prisma Client\n\nOnce done with these steps, you can move on to the next guide that explains how you can upgrade the application layer to use Prisma Client for your database queries.\n\n> **Note**: During the upgrade process it can be helpful to get a graphical view on your database. It is therefore recommended to use a graphical database client to connect to your database, such as [TablePlus](https://tableplus.com/) or [Postico](https://eggerapps.at/postico/).\n\n## 1\\. Install Prisma ORM 2 CLI[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#1-install-prisma-orm-2-cli \"Direct link to 1. Install Prisma ORM 2 CLI\")\n\nThe Prisma ORM 2 CLI is available as the [`prisma`](https://www.npmjs.com/package/prisma) package on npm and is invoked via the `prisma` command.\n\nNote that the former `prisma` command for Prisma 1 has been renamed to `prisma1`. You can learn more about this [here](https://www.prisma.io/blog/prisma-2-beta-b7bcl0gd8d8e#renaming-the-prisma2-cli).\n\nYou can install the Prisma ORM 2 CLI in your Node.js project as follows (be sure to invoke this command in the directory where your `package.json` is located):\n\n```\nnpm install prisma --save-dev\n```\n\n> **Note**: With Prisma 1, it was usually recommended to install the CLI globally. We now recommend to [install the Prisma CLI locally](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) to prevent version conflicts.\n\nYou can now use the local installation of the `prisma` CLI by prefixing it with `npx`:\n\nIf you're upgrading your entire project [all at once](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-strategies), you can now also uninstall the Prisma 1 CLI (otherwise expand below):\n\n```\n# remove global installationnpm uninstall -g prisma1# remove local installationnpm uninstall prisma1\n```\n\n  \nExpand if you want to keep using your Prisma 1 CLI side-by-side\n\nIf you want to keep using the Prisma 1 CLI, it is recommend to remove your global installation of it and add the `prisma1` CLI as a development dependency:\n\n```\n# installs v1.34 of the Prisma 1 CLInpm uninstall -g prismanpm install prisma1 --save-dev\n```\n\nYou can now invoke it as follows:\n\nNote that if you need a CLI version smaller than 1.34 (e.g. 1.30), you can install it as follows:\n\n```\n# installs v1.30 of the Prisma 1 CLInpm uninstall -g prisma@1.30npm install prisma@1.30 --save-dev\n```\n\nYou can now invoke it as follows:\n\n## 2\\. Create your Prisma ORM 2 schema[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#2-create-your-prisma-orm-2-schema \"Direct link to 2. Create your Prisma ORM 2 schema\")\n\nFor this guide, you'll first create a new Prisma schema using the `prisma init` command and then \"fill\" it with a data model using [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nRun the following command to create your Prisma schema (note that this throws an error if you already have a folder called `prisma`):\n\nIf you're seeing the following error, you need to rename your current `prisma` directory:\n\n```\nERROR  A folder called prisma already exists in your project.       Please try again in a project that is not yet using Prisma.\n```\n\nYou can rename the current `prisma` directory to `prisma1` to make it clear that this holds the former Prisma 1 configuration:\n\nNow you can run `init` and it will succeed:\n\nIt should print the following output:\n\n```\n✔ Your Prisma schema was created at prisma/schema.prisma.  You can now open it in your favorite editor.Next steps:1. Set the `DATABASE_URL` in the `.env` file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started2. Set the `provider` of your `datasource` block in `schema.prisma` to match your database: `postgresql`, `mysql` or `sqlite`.3. Run `prisma db pull` to turn your database schema into a Prisma data model.4. Run `prisma generate` to install Prisma Client. You can then start querying your database.More information in our documentation:https://pris.ly/d/getting-started\n```\n\nThe command created a new folder called `prisma`, and two files:\n\n*   `prisma/schema.prisma`: Your Prisma schema that specifies the [data source](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources), [generator](https://www.prisma.io/docs/orm/prisma-schema/overview/generators) and [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) (note that the data model doesn't exist yet, it will be generated via introspection).\n*   `.env`: A [dotenv](https://github.com/motdotla/dotenv#readme) file to configure your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls).\n\nYour initial Prisma schema looks as follows:\n\nschema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\nWith Prisma 1, you specify which language variant of Prisma Client you wanted to use in your `prisma.yml`. With Prisma ORM 2, this information is now specified inside the Prisma schema via a `generator` block.\n\n> **Note**: Unlike Prisma 1, the TypeScript and JavaScript variants of Prisma Client 2.0 use the _same_ generator called `prisma-client-js`. The generated types in `index.d.ts` are _always_ included, even in plain JavaScript projects. This enables feature like autocompletion in VS Code even when not using TypeScript.\n\n## 3\\. Determine your connection URL and connect to your database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#3-determine-your-connection-url-and-connect-to-your-database \"Direct link to 3. Determine your connection URL and connect to your database\")\n\nWith Prisma 1, the database connection is configured in the Docker Compose file that's used to launch the Prisma ORM server. The Prisma ORM server then exposes a GraphQL endpoint (via HTTP) that proxies all database requests from the Prisma Client application code. That HTTP endpoint is specified in your `prisma.yml`.\n\nWith Prisma ORM 2, the HTTP layer isn't exposed any more and Prisma Client 2.0 is configured to run requests \"directly\" against the database (that is, requests are proxied by Prisma ORM's [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines), but there isn't an extra server any more).\n\nSo, as a next step you'll need to tell Prisma ORM 2 _what_ kind of database you use (MySQL or PostgreSQL) and _where_ it is located.\n\nFirst, you need to ensure that that `provider` field on the `datasource` block inside `schema.prisma` is configured to use the right database:\n\n*   If you're using PostgreSQL, it needs to define the value `\"postgresql\"` in the `provider` field.\n*   If you're using MySQL, it needs to define the value `\"mysql\"` in the `provider` field.\n\nSwitch around with the tabs in the code block to see examples of both:\n\n*   PostgreSQL\n*   MySQL\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nWith the `provider` field set, you can go ahead and configure the connection URL inside the `.env` file.\n\nAssume the database configuration in your Docker Compose file that you used to deploy your Prisma ORM server looks as follows:\n\ndocker-compose.yml\n\n```\nPRISMA_CONFIG: |  port: 4466  databases:    default:      connector: postgres      host: postgres      port: 5432      user: prisma      password: prisma\n```\n\nAlso assume your `endpoint` in `prisma.yml` is configured as follows:\n\nprisma.yml\n\n```\nendpoint: http://localhost:4466/myproject/dev\n```\n\nBased on these connection details, you need to configure the `DATABASE_URL` environment variable inside your `.env` file as follows:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://janedoe:randompassword@localhost:5432/prisma?schema=myproject$dev\"\n```\n\nNote that the `schema` argument is typically composed of your _service name_ and _service stage_ (which are part of the `endpoint` in `prisma.yml`), separated by the `$` character.\n\nSometimes no service name and stage are specified in `prisma.yml`:\n\nprisma.yml\n\n```\nendpoint: http://localhost:4466/\n```\n\nIn that case, the `schema` must be specified as follows:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://janedoe:randompassword@localhost:5432/prisma?schema=default$default\"\n```\n\nLearn more on the [Connection URLs](https://www.prisma.io/docs/orm/reference/connection-urls) page.\n\n## 4\\. Introspect your database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#4-introspect-your-database \"Direct link to 4. Introspect your database\")\n\nFor the purpose of this guide, we'll use the following Prisma 1 data model (select the **SQL** tab below to see what the data model maps to in SQL):\n\n*   Prisma 1 Data Model\n*   SQL\n\n```\ntype User {  id: ID! @id  email: String @unique  name: String!  role: Role! @default(value: CUSTOMER)  jsonData: Json  profile: Profile  posts: [Post!]!}type Post {  id: ID! @id  createdAt: DateTime! @createdAt  updatedAt: DateTime! @updatedAt  title: String!  content: String  published: Boolean! @default(value: false)  author: User @relation(link: TABLE)  categories: [Category!]!}type Profile {  id: ID! @id  bio: String  user: User! @relation(link: INLINE)}type Category {  id: ID! @id  name: String!  posts: [Post!]!}enum Role {  ADMIN  CUSTOMER}\n```\n\nNote that this data model has three [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations):\n\n*   1-1: `User` ↔ `Profile`\n*   1-n: `User` ↔ `Post` (maintained via the `_PostToUser` relation table)\n*   m-n: `Post` ↔ `Category` (maintained via the `_CategoryToPost` relation table)\n\nNow you can run Prisma ORM's introspection against your database with the following command:\n\nHere's a graphical illustration for what happens when `db pull` is invoked:\n\n![Introspect your database](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nFor the above Prisma 1 datamodel, this results in the following Prisma ORM 2 schema (note that the models have been reordered to match the initial order of the Prisma 1 datamodel):\n\nschema.prisma\n\n```\nmodel User {  id       String    @id @default(cuid())  email    String?   @unique  name     String  role     String  jsonData String?  Profile  Profile[]  Post     Post[]}model Post {  id        String     @id @default(cuid())  createdAt DateTime  updatedAt DateTime  title     String  content   String?  published Boolean  Category  Category[]  User      User[]}model Profile {  id   String  @id @default(cuid())  bio  String?  user String? @unique  User User?   @relation(fields: [user], references: [id])}model Category {  id   String @id @default(cuid())  name String  Post Post[]}\n```\n\nWhile this is already a valid Prisma ORM 2 schema, it lacks a number of _features_ that were part of its Prisma 1 equivalent:\n\n*   no auto-generated date values for the `createdAt` and `updatedAt` fields on `Post`\n*   no default value for the `role` field on `User`\n*   no default value for the `published` field on `Post`\n\nThere further are a number of inconsistencies which result in a less idiomatic/ergonomic Prisma Client API:\n\n*   `User` ↔ `Profile` is a 1-n instead of 1-1 relation\n*   `User` ↔ `Post` is a m-n instead of 1-n relation\n*   relation fields are uppercased (e.g. `Profile` and `Post` on `User`)\n*   the `jsonData` field on `User` is of type `String` instead of `Json`\n*   the `role` field on `User` is of type `String` instead of `Role`, the `enum` definition for role is missing altogether\n\nWhile these inconsistencies don't actually impact the \"feature set\" you'll have available in your Prisma Client API, they make you lose certain constraints/guarantees that were present before.\n\nFor example, Prisma ORM now won't guarantee that a `User` is connected to _at most_ one `Profile` because the relation between the tables was recognized as 1-n during introspection, so one `User` record _could_ now get connected to multiple `Profile` records.\n\nAnother issue is that you can store whatever text for the `jsonData` and `role` fields, regardless of whether it's valid JSON or represents a value of the `Role` enum.\n\nTo learn more about these inconsistencies check out the [Schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql) page.\n\nIn the following, we'll go through these incompatibilities and fix them one by one using the Prisma schema upgrade CLI.\n\n## 5\\. Use the Prisma schema upgrade CLI to resolve schema incompatibilities[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#5-use-the-prisma-schema-upgrade-cli-to-resolve-schema-incompatibilities \"Direct link to 5. Use the Prisma schema upgrade CLI to resolve schema incompatibilities\")\n\nThe [Prisma 1 Upgrade CLI](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#prisma-1-upgrade-cli) is an interactive tool that helps you upgrading your Prisma schema and ironing out most of the inconsistencies listed above.\n\nThe Prisma 1 Upgrade CLI works in two major phases:\n\n1.  Fix the database schema via plain SQL\n2.  Add missing attributes to the Prisma ORM 2 schema and other schema fixes\n\nDuring the first phase, it will generate and print a number of SQL statements that you should run against your database to adjust the database schema. You can either run all of the statements or a subset of them before continuing to the second phase.\n\nDuring the second phase, you don't need to do anything manually. The Upgrade CLI will make changes to your Prisma schema by adding certain Prisma ORM-level attributes (like `@default(cuid))` or `@updatedAt`), adjusting the names of relation fields to match the ones from your Prisma 1 datamodel and ensure 1-1-relations that were required on both sides in your Prisma 1 datamodel are also required in the Prisma ORM 2 schema.\n\nNote that **you can start over at any time during the process** and go back from the second to the first phase.\n\nIn this illustration, the green area shows the first phase, the blue area shows the second phase. Note that you can optionally run `prisma db pull` in between the phases to update your Prisma ORM data model:\n\n![Fixing the schema incompatibilities](https://www.prisma.io/docs/assets/images/fix-schema-incompatibilities-09a1632f64517dbb92da2de4416337e8.png)\n\nTo use the Upgrade CLI, you can either install it locally in your project, or invoke it once without installation using `npx` as done here:\n\n```\nnpx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma\n```\n\nThe CLI will greet you with the following message:\n\n```\n◮ Welcome to the interactive Prisma Upgrade CLI that helps with theupgrade process from Prisma 1 to Prisma ORM 2.Please read the docs to learn more about the upgrade process:https://pris.ly/d/how-to-upgrade➤ GoalThe Upgrade CLI helps you resolve the schema incompatibilitiesbetween Prisma 1 and Prisma ORM 2. Learn more in the docs:https://pris.ly/d/schema-incompatibilities➤ How it worksThroughout the process, you'll need to adjust your database schema by sendingSQL statements to it. The SQL statements are provided by the Upgrade CLI.Note that the Upgrade CLI never makes changes to your database,you are in full control over any operations that are executed against it.You can stop and re-run the Upgrade CLI at any time.These are the different steps of the upgrade process:  1. The Upgrade CLI generates SQL commands for you to run on your database.  2. You run the SQL commands against your database.  3. You run the `npx prisma db pull` command again.  4. You run the `npx prisma-upgrade` command again.  5. The Upgrade CLI adjusts the Prisma ORM 2 schema by adding missing attributes.➤ NoteIt is recommended that you make a full backup of your existing data before startingthe upgrade process. If possible, the migration should be performed in a stagingenvironment before executed against a production environment.➤ HelpIf you have any questions or run into any problems along the way,please create an issue at:https://github.com/prisma/upgrade/issues/newAre you ready? [Y/n]\n```\n\nPress the Y button, then confirm by hitting RETURN on your keyboard to continue.\n\nOnce you confirmed, the CLI outputs the SQL statements you should be running against your database:\n\n```\n➤ Adjust your database schemaRun the following SQL statements against your database:  Fix columns with ENUM data types  https://pris.ly/d/schema-incompatibilities#enums-are-represented-as-text-in-database    CREATE TYPE \"default$default\".\"Role\" AS ENUM ('ADMIN', 'CUSTOMER');    ALTER TABLE \"default$default\".\"User\" ALTER COLUMN \"role\" SET DATA TYPE \"default$default\".\"Role\" using \"role\"::\"default$default\".\"Role\";  Add missing `DEFAULT` constraints to the database  https://pris.ly/d/schema-incompatibilities#default-values-arent-represented-in-database    ALTER TABLE \"default$default\".\"User\" ALTER COLUMN \"role\" SET DEFAULT 'CUSTOMER';    ALTER TABLE \"default$default\".\"Post\" ALTER COLUMN \"published\" SET DEFAULT false;  Fix columns with JSON data types  https://pris.ly/d/schema-incompatibilities#json-type-is-represented-as-text-in-database    ALTER TABLE \"default$default\".\"User\" ALTER COLUMN \"jsonData\" SET DATA TYPE JSONB USING \"jsonData\"::TEXT::JSONB;  Replicate `@createdAt` behavior in Prisma ORM 2  https://pris.ly/d/schema-incompatibilities#createdat-isnt-represented-in-database    ALTER TABLE \"default$default\".\"Post\" ALTER COLUMN \"createdAt\" SET DEFAULT CURRENT_TIMESTAMP;  Fix 1-1 relations by adding `UNIQUE` constraints  https://pris.ly/d/schema-incompatibilities#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint    ALTER TABLE \"default$default\".\"Profile\" ADD UNIQUE (\"user\");  Migrate IDs from varchar(25) to varchar(30)  https://pris.ly/d/schema-incompatibilities#mismatching-cuid-length    ALTER TABLE \"default$default\".\"Category\" ALTER COLUMN \"id\" SET DATA TYPE character varying(30);    ALTER TABLE \"default$default\".\"Post\" ALTER COLUMN \"id\" SET DATA TYPE character varying(30);    ALTER TABLE \"default$default\".\"Profile\" ALTER COLUMN \"id\" SET DATA TYPE character varying(30);    ALTER TABLE \"default$default\".\"Profile\" ALTER COLUMN \"user\" SET DATA TYPE character varying(30);    ALTER TABLE \"default$default\".\"User\" ALTER COLUMN \"id\" SET DATA TYPE character varying(30);➤ Breaking changes detectedIn order to fully optimize your database schema, you'll need to run a few SQLstatements that can break your Prisma 1 setup. Note that these changes are optionaland if you are upgrading gradually and running Prisma 1 and Prisma ORM 2 side-by-side,you should not perform these changes yet. Instead, you can perform them wheneveryou are ready to completely remove Prisma 1 from your project.If you are upgrading all at once, you can safely perform these changes now.Learn more in the docs:https://pris.ly/d/how-to-upgrade'\n```\n\n> **Note**: If you're seeing the note about breaking changes, you can ignore it for now. We'll discuss it later.\n\nThe shown SQL statements are categorized into a number of \"buckets\", all aiming to resolve a certain [schema incompatibility](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql):\n\n*   Fix columns with ENUM data types\n*   Add missing `DEFAULT` constraints to the database\n*   Fix columns with JSON data types\n*   Replicate `@createdAt` behavior in Prisma 2\n*   Fix 1-1 relations by adding `UNIQUE` constraints\n\nAs a next step, you can start sending the SQL statements to your database. Note that all of these changes are non-breaking and you'll be able to continue using Prisma 1 side-by-side with Prisma ORM 2.\n\nThe next sections cover the different kinds of SQL statements to be sent to your database individually.\n\n### 5.1. Fix the database schema via plain SQL (non-breaking)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#51-fix-the-database-schema-via-plain-sql-non-breaking \"Direct link to 5.1. Fix the database schema via plain SQL (non-breaking)\")\n\nIn this section, we'll walk through the printed SQL statements and run them against the database one by one.\n\n### 5.1.1. Fix columns with ENUM data types[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#511-fix-columns-with-enum-data-types \"Direct link to 5.1.1. Fix columns with ENUM data types\")\n\nThe first thing the tool does is help you ensure that `enum` definitions in your Prisma 1 datamodel will be represented as actual `ENUM` types in the underlying database, right now they are represented as plain strings (e.g. as `MEDIUMTEXT` in MySQL).\n\nThe CLI currently shows the following output:\n\n```\nFix columns with ENUM data typeshttps://pris.ly/d/schema-incompatibilities#enums-are-represented-as-text-in-database  CREATE TYPE \"default$default\".\"Role\" AS ENUM ('ADMIN', 'CUSTOMER');  ALTER TABLE \"default$default\".\"User\" ALTER COLUMN \"role\" SET DATA TYPE \"default$default\".\"Role\" using \"role\"::\"default$default\".\"Role\";\n```\n\n> **⚠️ Warning**: If you are running Prisma 1 and Prisma ORM 2 [side-by-side](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-strategies), these [SQL statements will break your Prisma 1 setup](https://github.com/prisma/upgrade/issues/74). The docs will be updated to reflect this soon.\n\nGo ahead and run these statements against your database now.\n\n![Altering columns to use ENUM with SQL](https://www.prisma.io/docs/assets/images/altering-columns-to-use-enum-bb9dd5b6096ca5acfdf83878da7b892a.png)\n\n### 5.1.2. Add missing `DEFAULT` constraints to the database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#512-add-missing-default-constraints-to-the-database \"Direct link to 512-add-missing-default-constraints-to-the-database\")\n\nNext, the Upgrade CLI helps you resolve the issue that [default values aren't represented in the database](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#default-values-arent-represented-in-database) by generating SQL statements that add the respective `DEFAULT` constraints directly to the database.\n\nIn this case, two `DEFAULT` constraints are missing which are suggested by the tool:\n\n```\nAdd missing `DEFAULT` constraints to the databasehttps://pris.ly/d/schema-incompatibilities#default-values-arent-represented-in-database  ALTER TABLE \"default$default\".\"User\" ALTER COLUMN \"role\" SET DEFAULT 'CUSTOMER';  ALTER TABLE \"default$default\".\"Post\" ALTER COLUMN \"published\" SET DEFAULT false;\n```\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like Postico:\n\n![Adding missing DEFAULT constraints to columns](https://www.prisma.io/docs/assets/images/add-missing-default-constraints-to-columns-3d4377228ca02a8fd21969c52c5fdfca.png)\n\n### 5.1.3. Fix columns with JSON data types[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#513-fix-columns-with-json-data-types \"Direct link to 5.1.3. Fix columns with JSON data types\")\n\nNext, the tool helps you ensure that `Json` fields in your Prisma 1 datamodel will be represented as `JSON` columns in the underlying database, right now they are represented as plain strings (e.g. as `MEDIUMTEXT` in MySQL).\n\nChanging the column type to `JSON` will ensure that the field is properly recognized as `Json` during Prisma ORM 2 introspection.\n\nThe CLI currently shows the following output:\n\n```\nFix columns with JSON data typeshttps://pris.ly/d/schema-incompatibilities#json-type-is-represented-as-text-in-database  ALTER TABLE \"default$default\".\"User\" ALTER COLUMN \"jsonData\" TYPE JSON  USING \"jsonData\"::json;\n```\n\n> **⚠️ Warning**: If you are running Prisma 1 and Prisma ORM 2 [side-by-side](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-strategies), these [SQL statements will break your Prisma 1 setup](https://github.com/prisma/upgrade/issues/73). The docs will be updated to reflect this soon.\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like Postico:\n\n![Adding missing DEFAULT constraints to columns](https://www.prisma.io/docs/assets/images/fix-columns-with-json-data-types-2b1e09144ceeafe04cd49271e9d30798.png)\n\n### 5.1.4. Replicate `@createdAt` behavior in Prisma ORM 2[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#514-replicate-createdat-behavior-in-prisma-orm-2 \"Direct link to 514-replicate-createdat-behavior-in-prisma-orm-2\")\n\nThe next thing the tools does is help you resolve the issue that the behavior of [`@createdAt` isn't represented in database](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#default-values-arent-represented-in-database)\n\nThe CLI currently shows the following output:\n\n```\nReplicate `@createdAt` behavior in Prisma ORM 2.0https://pris.ly/d/schema-incompatibilities#createdat-isnt-represented-in-database  ALTER TABLE \"default$default\".\"Post\" ALTER COLUMN \"createdAt\" SET DEFAULT CURRENT_TIMESTAMP;\n```\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like Postico:\n\n![Running an SQL command to alter a column](https://www.prisma.io/docs/assets/images/run-sql-command-to-alter-column-b40021ec19a8232232e50387f423b1a0.png)\n\n### 5.1.5. Fix 1-1 relations by adding `UNIQUE` constraints[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#515-fix-1-1-relations-by-adding-unique-constraints \"Direct link to 515-fix-1-1-relations-by-adding-unique-constraints\")\n\nNow, the tool will help you [turn the current 1-n relation between `User` ↔ `Profile` back into a 1-1 relation](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint) by adding a `UNIQUE` constraint to the foreign key column called `user` (named after the relation field in the Prisma 1 datamodel) in the database.\n\nThe CLI currently shows the following output:\n\n```\nFix 1-1 relations by adding `UNIQUE` constraintshttps://pris.ly/d/schema-incompatibilities#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint  ALTER TABLE \"default$default\".\"Profile\" ADD UNIQUE (\"user\");\n```\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like Postico:\n\n![Running an SQL command to alter a column](https://www.prisma.io/docs/assets/images/run-sql-command-to-alter-column-b40021ec19a8232232e50387f423b1a0.png)\n\n### 5.1.6. Fix mismatch of CUID length[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#516-fix-mismatch-of-cuid-length \"Direct link to 5.1.6. Fix mismatch of CUID length\")\n\n> **Note**: These SQL statements will keep appearing in the Upgrade CLI even after you have changed the column types in the underlying database. This is a currently a limitation in the Upgrade CLI.\n\nFinally, the tool will help you [turn the current ID columns of type `VARCHAR(25)` into `VARCHAR(30)`](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#mismatching-cuid-length) by adding a `UNIQUE` constraint to the foreign key column called `user` (named after the relation field in the Prisma 1 datamodel) in the database.\n\nThe CLI currently shows the following output:\n\n```\nMigrate IDs from varchar(25) to varchar(30)https://pris.ly/d/schema-incompatibilities#mismatching-cuid-length  ALTER TABLE \"default$default\".\"Category\" ALTER COLUMN \"id\" SET DATA TYPE character varying(30);  ALTER TABLE \"default$default\".\"Post\" ALTER COLUMN \"id\" SET DATA TYPE character varying(30);  ALTER TABLE \"default$default\".\"Profile\" ALTER COLUMN \"id\" SET DATA TYPE character varying(30);  ALTER TABLE \"default$default\".\"Profile\" ALTER COLUMN \"user\" SET DATA TYPE character varying(30);  ALTER TABLE \"default$default\".\"User\" ALTER COLUMN \"id\" SET DATA TYPE character varying(30);\n```\n\nYou can now run these SQL statements against your database either using a command line client or a GUI like Postico:\n\n![Running an SQL command to alter a column](https://www.prisma.io/docs/assets/images/run-sql-command-to-alter-column-b40021ec19a8232232e50387f423b1a0.png)\n\n### 5.1.7. Breaking changes detected[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#517-breaking-changes-detected \"Direct link to 5.1.7. Breaking changes detected\")\n\nIn case the Upgrade CLI has printed a note about breaking changes, your database schema needs some adjustments that will break Prisma 1 compatibility in order to be fully optimized.\n\nIf there are no breaking changes detected, you can [skip forward to section 5.2](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#52-re-introspect-your-database-to-update-your-prisma-schema)\n\nDepending on your [upgrade strategy](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-strategies), you can either perform these changes now or skip to the next phase of the Upgrade CLI:\n\n*   If you are following the gradual side-by-side upgrade strategy, do not perform these changes yet since they will break your Prisma 1 setup. In that case, you can continue to the next phase of the Upgrade CLI by typing n and hitting RETURN.\n*   If you are following the all at once upgrade strategy, you can perform these changes now. In that case, continue by typing Y and hitting RETURN.\n\n### 5.2. Fix the database schema via plain SQL (breaking)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#52-fix-the-database-schema-via-plain-sql-breaking \"Direct link to 5.2. Fix the database schema via plain SQL (breaking)\")\n\nIn this section, you'll resolve the schema incompatibilities that are breaking your Prisma 1 setup. Do not perform these changes if you are still running Prisma 1 in your project!\n\n### 5.2.1. Fix incorrect m-n relations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#521-fix-incorrect-m-n-relations \"Direct link to 5.2.1. Fix incorrect m-n relations\")\n\nNow, the Upgrade CLI helps you fix all 1-1 and 1-n relations that Prisma 1 represents with relation tables and that [currently only exist as m-n relations](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#all-non-inline-relations-are-recognized-as-m-n) in your new Prisma ORM 2 schema. Concretely, this is the case for the `User` ↔ `Post` relation which currently is defined as m-n but _should_ really be a 1-n relation.\n\nTo fix this, you'll need to perform the following migration:\n\n1.  Create a new foreign key column on `Post` to link directly to the `User` table.\n2.  Migrate the foreign key values from the relation table into the new foreign key column on `Post`.\n3.  Delete the relation table.\n\nThese instructions are now printed by the CLI:\n\n```\n➤ Adjust your database schemaRun the following SQL statements against your database:  Fix one-to-many table relations  https://pris.ly/d/schema-incompatibilities#all-non-inline-relations-are-recognized-as-m-n    ALTER TABLE \"default$default\".\"Post\" ADD COLUMN \"authorId\" character varying(25) ;    ALTER TABLE \"default$default\".\"Post\" ADD CONSTRAINT \"author\" FOREIGN KEY (\"authorId\") REFERENCES \"default$default\".\"User\"(\"id\");    UPDATE \"default$default\".\"Post\" SET \"authorId\" = \"default$default\".\"_PostToUser\".\"B\" FROM \"default$default\".\"_PostToUser\" WHERE \"default$default\".\"_PostToUser\".\"A\" = \"default$default\".\"Post\".\"id\";    DROP TABLE \"default$default\".\"_PostToUser\";➤ Next StepsAfter you executed one or more of the previous SQL statements against your database,please run the following two commands to refresh your Prisma ORM 2 schema and checkthe changes.  1. Run `npx prisma db pull` again to refresh your Prisma ORM 2 schema.  2. Run `npx prisma-upgrade` again.If you can't or don't want to execute the remaining SQL statements right now, you canskip to the last step where the Upgrade CLI adds missing attributes to your Prisma ORM 2schema that are not picked up by introspection.Skip to the last step? [Y/n]?\n```\n\nFor this fix, you'll need to run three SQL statements:\n\n1.  Create new column `authorId` on the `Post` table. This column should be a _foreign key_ that references the `id` field of the `User` table:\n    \n    ```\n    ALTER TABLE `Post` ADD COLUMN `authorId` VARCHAR(25);ALTER TABLE `Post` ADD FOREIGN KEY (`authorId`) REFERENCES `User` (`id`);\n    ```\n    \n2.  Write a SQL query that reads all the rows from the `_PostToUser` relation table and for each row:\n    \n    1.  Finds the respective `Post` record by looking up the value from column `A`\n    2.  Inserts the value from column `B` as the value for `authorId` into that `Post` record\n    \n    ```\n    UPDATE Post, _PostToUserSET Post.authorId = _PostToUser.BWHERE Post.id = _PostToUser.A\n    ```\n    \n3.  Delete the `_PostToUser` relation table\n    \n    ```\n    DROP TABLE `_PostToUser`;\n    ```\n    \n\n![Fixing incorrect m-n relations with SQL](https://www.prisma.io/docs/assets/images/fix-incorrect-m-n-relations-sql-40f523e1ff9f3bab48da924500acf789.png)\n\nAfter these commands, the user ID values of the records from column `B` of the relation table are migrated to the new `authorId` column.\n\n### 5.2. Re-introspect your database to update your Prisma schema[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#52-re-introspect-your-database-to-update-your-prisma-schema \"Direct link to 5.2. Re-introspect your database to update your Prisma schema\")\n\nAt this point, you've resolved the schema incompatibilities with the Upgrade CLI. You can now exit the Upgrade CLI for now by typing n and hitting RETURN.\n\nIn this section, you'll update your Prisma schema with another introspection round. This time, the previous flaws of the Prisma schema will be resolved because the database schema has been adjusted:\n\nThis time, the resulting Prisma schema looks as follows:\n\nschema.prisma\n\n```\nmodel User {  id       String   @id  name     String  email    String?  @unique  jsonData Json?  role     Role     @default(CUSTOMER)  Post     Post[]  Profile  Profile?}model Post {  id        String     @id  createdAt DateTime   @default(now())  updatedAt DateTime  title     String  content   String?  published Boolean    @default(false)  authorId  String?  User      User?      @relation(fields: [authorId], references: [id])  Category  Category[] @relation(references: [id])}model Category {  id   String @id  name String  Post Post[] @relation(references: [id])}model Profile {  bio  String?  id   String  @id  user String? @unique  User User?   @relation(fields: [user], references: [id])}enum Role {  ADMIN  CUSTOMER}\n```\n\nThis schema has most issues resolved, but it still lacks the following:\n\n### 5.2. Add missing attributes to the Prisma 2 schema and other schema fixes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#52-add-missing-attributes-to-the-prisma-2-schema-and-other-schema-fixes \"Direct link to 5.2. Add missing attributes to the Prisma 2 schema and other schema fixes\")\n\nThe CLI now prints the following:\n\n```\n➤ What happens nextAs a last step, some final adjustments will be made to your Prisma ORM 2 schemato carry over some Prisma ORM-level attributes that aren't picked up by introspection.As a last step, some final adjustments will be made to your Prisma ORM 2.0schema to carry over some Prisma ORM-level attributes that aren't pickedup by introspection.WarningYour current Prisma ORM 2.0 schema will be overwritten, so pleasemake sure you have a backup!Are you ready? [Y/n]\n```\n\nAt this point, you either ran all the SQL statement that were printed by the CLI or you skipped some of them. Either way, you can now move on the last step and let the Upgrade CLI add the missing Prisma ORM 2 attributes. Typically these are the following:\n\n*   `@default(cuid())` for your `@id` fields\n*   `@updatedAt` for any fields that were using this attribute in Prisma 1\n*   `@map` and `@@map` as replacements for `@db` and `@@db` from Prisma 1\n\nIn that step, the Upgrade CLI also fixes other issues that occurred in the transition to Prisma ORM 2:\n\n*   it makes sure that 1-1-relations that were required on both sides in Prisma 1 are also required in your Prisma ORM 2 schema\n*   it renames relation fields to the same names they had in your Prisma 1 datamodel ([coming soon](https://github.com/prisma/upgrade/issues/25))\n\nTo apply these changes, you can re-run the Upgrade CLI:\n\n```\nnpx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma\n```\n\nIf you did not resolve all schema incompatibilities, the Upgrade CLI now prints the remaining SQL statements (as well as the ones for migrating IDs). You can just ignore them at this point and continue to the last step by continuously typing Y and hitting RETURN when prompted.\n\nIf you did resolve all schema incompatibilities, no SQL statements will be printed and the Upgrade CLI only outputs the following:\n\n```\n$ npx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma➤ Next StepsAfter you executed one or more of the previous SQL statements against your database,please run the following two commands to refresh your Prisma ORM 2 schema and checkthe changes.  1. Run `npx prisma db pull` again to refresh your Prisma ORM 2 schema.  2. Run `npx prisma-upgrade` again.If you can't or don't want to execute the remaining SQL statements right now, you canskip to the last step where the Upgrade CLI adds missing attributes to your Prisma ORM 2schema that are not picked up by introspection.Skip to the last step? [Y/n]?\n```\n\nOne more time, type Y and hit RETURN to confirm.\n\nThe final prompt of the Upgrade CLI now asks you to confirm the above mentioned changes it will make to your Prisma schema:\n\n```\n➤ What happens nextAs a last step, some final adjustments will be made to your Prisma ORM 2 schemato carry over some Prisma ORM-level attributes that aren't picked up by introspection.As a last step, some final adjustments will be made to your Prisma ORM 2.0schema to carry over some Prisma ORM-level attributes that aren't pickedup by introspection.WarningYour current Prisma ORM 2.0 schema will be overwritten, so pleasemake sure you have a backup!Are you ready? [Y/n]\n```\n\nOne last time, type Y and hit RETURN to confirm.\n\nThis is the final output of the Upgrade CLI:\n\n```\nUpdating prisma/schema.prisma...Done updating prisma/schema.prisma!✔ Congratulations, you're all set!➤ NoteIf you didn't execute all generated SQL commands against your database,you can re-run the Upgrade CLI at any time.Note that the Upgrade CLI doesn't resolve all of the schema incompatibilitiesbetween Prisma 1 and Prisma ORM 2. If you want to resolve the remaining ones,you can do so manually by following this guide:https://pris.ly/d/upgrading-the-prisma-layer➤ Next stepsOtherwise you can continue your upgrade process by installing Prisma Client 2:npm install @prisma/clientYou can find guides for different upgrade scenarios in the docs:https://pris.ly/d/upgrade-from-prisma-1\n```\n\n### 5.3. Final result[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#53-final-result \"Direct link to 5.3. Final result\")\n\nThe final version of the Prisma schema should look as follows:\n\nschema.prisma\n\n```\nmodel User {  id       String   @id @default(cuid())  name     String  email    String?  @unique  jsonData Json?  role     Role     @default(CUSTOMER)  Post     Post[]  Profile  Profile?}model Post {  id        String     @id @default(cuid())  createdAt DateTime   @default(now())  updatedAt DateTime   @updatedAt  title     String  content   String?  published Boolean    @default(false)  authorId  String?  User      User?      @relation(fields: [authorId], references: [id])  Category  Category[] @relation(references: [id])}model Profile {  id   String  @id @default(cuid())  bio  String?  user String? @unique  User User?   @relation(fields: [user], references: [id])}model Category {  id   String @id @default(cuid())  name String  Post Post[] @relation(references: [id])}enum Role {  ADMIN  CUSTOMER}\n```\n\n### 5.4. Rename relation fields[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#54-rename-relation-fields \"Direct link to 5.4. Rename relation fields\")\n\nOne thing you'll notice with this version of the Prisma ORM 2 schema is that all [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are named after their respective models, e.g:\n\nschema.prisma\n\n```\nmodel User {  Post    Post[]  Profile Profile?}model Post {  User     User?      @relation(fields: [authorId], references: [id])  Category Category[] @relation(references: [id])}model Profile {  User User? @relation(fields: [user], references: [id])}model Category {  Post Post[] @relation(references: [id])}\n```\n\nThis is not ideal and you can in fact manually rename all of them to their previous versions!\n\nBecause all relation fields are _virtual_, meaning they don't _manifest_ in the database, you can name them whatever you like. In this case, all relation fields are lowercased and sometimes pluralized.\n\nHere's what they look like after the rename:\n\nschema.prisma\n\n```\nmodel User {  posts   Post[]  profile Profile?}model Post {  author     User?      @relation(fields: [authorId], references: [id])  categories Category[] @relation(references: [id])}model Profile {  user  String? @unique  owner User?   @relation(fields: [user], references: [id])}model Category {  posts Post[] @relation(references: [id])}\n```\n\n> **Note**: For the 1-1-relation between `User` and `Profile` it was not possible to set the old name `user` for the relation field. This is because there'd be a naming conflict with the already existing [relation scalar](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#annotated-relation-fields) field that holds the foreign key. In that case, you can choose a different name or alternatively rename the foreign key column directly in the database via SQL.\n\n### 5.5. Resolving remaining schema incompatibilities[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#55-resolving-remaining-schema-incompatibilities \"Direct link to 5.5. Resolving remaining schema incompatibilities\")\n\nThere are a few schema incompatibilities that were not yet resolved by the Upgrade CLI. At this point you still haven't fixed [scalar lists](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql#scalar-lists-arrays-are-maintained-with-extra-table). You can find the recommended workarounds for this and others on the [Schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql) page.\n\n## 6\\. Install and generate Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#6-install-and-generate-prisma-client \"Direct link to 6. Install and generate Prisma Client\")\n\nNow that you have your Prisma ORM 2 schema ready, you can install Prisma Client with the following command:\n\n```\nnpm install @prisma/client\n```\n\n## 7\\. Next steps[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#7-next-steps \"Direct link to 7. Next steps\")\n\nCongratulations, you have now upgraded your Prisma ORM layer to Prisma ORM 2! From here on, you can move on to update your application code using one of the following guides:\n\n*   [Old to new Nexus](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus): Choose this guide if you're currently running Prisma 1 with GraphQL Nexus.\n*   [prisma-binding to Nexus](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus): Choose this guide if you're currently running Prisma 1 with `prisma-binding` and want to upgrade to [Nexus](https://www.nexusjs.org/#/) (and TypeScript).\n*   [prisma-binding to SDL-first](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first): Choose this guide if you're currently running Prisma 1 with `prisma-binding` and want to upgrade to an [SDL-first](https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3) GraphQL server.\n*   [REST API](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api): Choose this guide if you're currently running Prisma 1 using Prisma Client 1 and are building a REST API.\n\n## Bonus: Prisma Client API comparison[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#bonus-prisma-client-api-comparison \"Direct link to Bonus: Prisma Client API comparison\")\n\nThis section contains a high-level and side-by-side comparison of the Prisma Client APIs of Prisma 1 and Prisma ORM 2. For more details about the new Prisma Client API, you can explore the [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) docs.\n\n### Reading single records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#reading-single-records \"Direct link to Reading single records\")\n\n**Prisma Client (v1)**\n\n```\nconst user = await prisma.user({ id: 1 })\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findUnique({  where: { id: 1 },})\n```\n\n### Reading lists of records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#reading-lists-of-records \"Direct link to Reading lists of records\")\n\n**Prisma Client (v1)**\n\n```\nconst user = await prisma.users()\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findMany()\n```\n\n### Filtering lists[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#filtering-lists \"Direct link to Filtering lists\")\n\n**Prisma Client (v1)**\n\n```\nconst users = await prisma.users({  where: {    name: 'Alice',  },})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findMany({  where: {    name: 'Alice',  },})\n```\n\n### Paginating lists[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#paginating-lists \"Direct link to Paginating lists\")\n\n**Prisma Client (v1)**\n\n```\nconst posts = await prisma.posts({  skip: 5,  first: 10,})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findMany({  skip: 5,  take: 10,})\n```\n\n> **Note**: You can learn more about the new pagination API in the respective [release notes](https://github.com/prisma/prisma/releases/tag/2.0.0-beta.7) or the [Pagination](https://www.prisma.io/docs/orm/prisma-client/queries/pagination) page in the docs.\n\n### Sorting lists[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#sorting-lists \"Direct link to Sorting lists\")\n\n**Prisma Client (v1)**\n\n```\nawait prisma.posts({  orderBy: 'title_ASC',})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.posts({  orderBy: {    title: 'asc',  },})\n```\n\n### Creating records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#creating-records \"Direct link to Creating records\")\n\n**Prisma Client (v1)**\n\n```\nawait prisma.createUser({  name: 'Alice',})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.create({  data: {    name: 'Alice',  },})\n```\n\n### Updating records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#updating-records \"Direct link to Updating records\")\n\n**Prisma Client (v1)**\n\n```\nawait prisma.updateUser({  where: { id: 1 },  data: {    name: 'James',    email: 'james@prisma.io',  },})\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.update({  where: { id: 1 },  data: {    name: 'James',    email: 'james@prisma.io',  },})\n```\n\n### Deleting records[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#deleting-records \"Direct link to Deleting records\")\n\n**Prisma Client (v1)**\n\n```\nawait prisma.deleteUser({ id: 1 })\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.delete({  where: { id: 1 },})\n```\n\n### Selecting fields & loading relations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql#selecting-fields--loading-relations \"Direct link to Selecting fields & loading relations\")\n\nIn Prisma 1, the only ways to select specific fields and/or load relations of an object was by using the string-based `$fragment` and `$graphql` functions. With Prisma ORM 2, this is now done in a clean and type-safe manner using [`select`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#select-specific-fields) and [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields).\n\nAnother benefit of this approach is that you can use `select` and `include` on _any_ Prisma Client query, e.g. `findUnique()`, `findMany`, `create`, `update`, `delete`, ...\n\n**Prisma Client (v1)**\n\n```\nawait prisma.user({ id: 1 }).$fragment(`  fragment NameAndEmail on User { id email }``)\n```\n\n**Prisma Client (v2)**\n\n```\nawait prisma.user.findUnique({  where: { id: 1 },  select: {    id: true,    email: true,  },})\n```\n\nAs an example, creating a new record and only retrieving the `id` in the returned object was not possible in Prisma 1. With Prisma ORM 2 you can achieve this as follows:\n\n```\nawait prisma.user.create({  data: {    name: 'Alice',  },  select: {    id: true,  },})\n```",
    "title": "Upgrading the Prisma ORM layer to Prisma ORM 2 | PostgreSQL | Prisma Documentation",
    "description": "Learn how to upgrade the Prisma ORM layer to Prisma ORM 2 and create your Prisma schema with PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first",
    "markdown": "# Upgrading from Prisma 1 with prisma-binding to SDL-first\n\n## Overview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#overview \"Direct link to Overview\")\n\nThis upgrade guide describes how to migrate a Node.js project that's based on [Prisma 1](https://github.com/prisma/prisma1) and uses `prisma-binding` to implement a GraphQL server.\n\nThe code will keep the [SDL-first approach](https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3) for constructing the GraphQL schema. When migrating from `prisma-binding` to Prisma Client, the main difference is that the `info` object can't be used to resolve relations automatically any more, instead you'll need to implement your _type resolvers_ to ensure that relations get resolved properly.\n\nThe guide assumes that you already went through the [guide for upgrading the Prisma ORM layer](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql). This means you already:\n\n*   installed the Prisma ORM 2 CLI\n*   created your Prisma ORM 2 schema\n*   introspected your database and resolved potential schema incompatibilities\n*   installed and generated Prisma Client\n\nThe guide further assumes that you have a file setup that looks similar to this:\n\n```\n.├── README.md├── package.json├── prisma│   └── schema.prisma├── prisma1│   ├── datamodel.prisma│   └── prisma.yml└── src    ├── generated    │   └── prisma.graphql    ├── index.js    └── schema.graphql\n```\n\nThe important parts are:\n\n*   A folder called with `prisma` with your Prisma ORM 2 schema\n*   A folder called `src` with your application code and a schema called `schema.graphql`\n\nIf this is not what your project structure looks like, you'll need to adjust the instructions in the guide to match your own setup.\n\n## 1\\. Adjusting your GraphQL schema[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#1-adjusting-your-graphql-schema \"Direct link to 1. Adjusting your GraphQL schema\")\n\nWith `prisma-binding`, your approach for defining your GraphQL schema (sometimes called [application schema](https://v1.prisma.io/docs/1.20/data-model-and-migrations/data-model-knul/#a-note-on-the-application-schema)) is based on _importing_ GraphQL types from the generated `prisma.graphql` file (in Prisma 1, this is typically called [Prisma GraphQL schema](https://v1.prisma.io/docs/1.20/data-model-and-migrations/data-model-knul/#the-prisma-graphql-schema)). These types mirror the types from your Prisma 1 datamodel and serve as foundation for your GraphQL API.\n\nWith Prisma ORM 2, there's no `prisma.graphql` file any more that you could import from. Therefore, you have to spell out all the types of your GraphQL schema directly inside your `schema.graphql` file.\n\nThe easiest way to do so is by downloading the full GraphQL schema from the GraphQL Playground. To do so, open the **SCHEMA** tab and click the **DOWNLOAD** button in the top-right corner, then select **SDL**:\n\n![Downloading the GraphQL schema with GraphQL Playground](https://www.prisma.io/docs/assets/images/download-graphql-schema-102cb51c37600968ed1aac9b443d6e9d.png)\n\nAlternatively, you can use the `get-schema` command of the [GraphQL CLI](https://github.com/Urigo/graphql-cli) to download your full schema:\n\n```\nnpx graphql get-schema --endpoint __GRAPHQL_YOGA_ENDPOINT__ --output schema.graphql --no-all\n```\n\n> **Note**: With the above command, you need to replace the `__GRAPHQL_YOGA_ENDPOINT__` placeholder with the actual endpoint of your GraphQL Yoga server.\n\nOnce you obtained the `schema.graphql` file, replace your current version in `src/schema.graphql` with the new contents. Note that the two schemas are 100% equivalent, except that the new one doesn't use [`graphql-import`](https://github.com/ardatan/graphql-import) for importing types from a different file. Instead, it spells out all types in a single file.\n\nHere's a comparison of these two versions of the sample GraphQL schema that we'll migrate in this guide (you can use the tabs to switch between the two versions):\n\n*   Before (with graphql-import)\n*   After (with Prisma 2)\n\n```\n# import Post from './generated/prisma.graphql'# import User from './generated/prisma.graphql'# import Category from './generated/prisma.graphql'type Query {  posts(searchString: String): [Post!]!  user(userUniqueInput: UserUniqueInput!): User  users(where: UserWhereInput, orderBy: Enumerable<UserOrderByInput>, skip: Int, after: String, before: String, first: Int, last: Int): [User]!  allCategories: [Category!]!}input UserUniqueInput {  id: String  email: String}type Mutation {  createDraft(authorId: ID!, title: String!, content: String!): Post  publish(id: ID!): Post  deletePost(id: ID!): Post  signup(name: String!, email: String!): User!  updateBio(userId: String!, bio: String!): User  addPostToCategories(postId: String!, categoryIds: [String!]!): Post}\n```\n\nYou'll notice that the new version of your GraphQL schema not only defines the _models_ that were imported directly, but also additional types (e.g. `input` types) that were not present in the schema before.\n\n## 2\\. Set up your `PrismaClient` instance[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#2-set-up-your-prismaclient-instance \"Direct link to 2-set-up-your-prismaclient-instance\")\n\n`PrismaClient` is your new interface to the database in Prisma ORM 2. It lets you invoke various methods which build SQL queries and send them to the database, returning the results as plain JavaScript objects.\n\nThe `PrismaClient` query API is inspired by the initial `prisma-binding` API, so a lot of the queries you send with Prisma Client will feel familiar.\n\nSimilar to the `prisma-binding` instance from Prisma 1, you also want to attach your `PrismaClient` from Prisma ORM 2 to GraphQL's `context` so that in can be accessed inside your resolvers:\n\n```\nconst { PrismaClient } = require('@prisma/client')// ...const server = new GraphQLServer({  typeDefs: 'src/schema.graphql',  resolvers,  context: (req) => ({    ...req,    prisma: new Prisma({      typeDefs: 'src/generated/prisma.graphql',      endpoint: 'http://localhost:4466',    }),    prisma: new PrismaClient(),  }),})\n```\n\nIn the code block above, the _red_ lines are the lines to be removed from your current setup, the _green_ lines are the ones that you should add. Of course, it's possible that your previous setup differed from this one (e.g. it's unlikely that your Prisma ORM `endpoint` was `http://localhost:4466` if you're running your API in production), this is just a sample to indicate what it _could_ look like.\n\nWhen you're now accessing `context.prisma` inside of a resolver, you now have access to Prisma Client queries.\n\n## 2\\. Write your GraphQL type resolvers[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#2-write-your-graphql-type-resolvers \"Direct link to 2. Write your GraphQL type resolvers\")\n\n`prisma-binding` was able to _magically_ resolve relations in your GraphQL schema. When not using `prisma-binding` though, you need to explicitly resolve your relations using so-called _type resolvers_.\n\n> **Note** You can learn more about the concept of type resolvers and why they're necessary in this article: [GraphQL Server Basics: GraphQL Schemas, TypeDefs & Resolvers Explained](https://www.prisma.io/blog/graphql-server-basics-the-schema-ac5e2950214e)\n\n### 2.1. Implementing the type resolver for the `User` type[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#21-implementing-the-type-resolver-for-the-user-type \"Direct link to 21-implementing-the-type-resolver-for-the-user-type\")\n\nThe `User` type in our sample GraphQL schema is defined as follows:\n\n```\ntype User implements Node {  id: ID!  email: String  name: String!  posts(    where: PostWhereInput    orderBy: Enumerable<PostOrderByInput>    skip: Int    after: String    before: String    first: Int    last: Int  ): [Post!]  role: Role!  profile: Profile  jsonData: Json}\n```\n\nThis type has two relations:\n\n*   The `posts` field denotes a 1-n relation to `Post`\n*   The `profile` field denotes a 1-1 relation to `Profile`\n\nSince you're not using `prisma-binding` any more, you now need to resolve these relations \"manually\" in type resolvers.\n\nYou can do so by adding a `User` field to your _resolver map_ and implement the resolvers for the `posts` and `profile` relations as follows:\n\n```\nconst resolvers = {  Query: {    // ... your query resolvers  },  Mutation: {    // ... your mutation resolvers  },  User: {    posts: (parent, args, context) => {      return context.prisma.user        .findUnique({          where: { id: parent.id },        })        .posts()    },    profile: (parent, args, context) => {      return context.prisma.user        .findUnique({          where: { id: parent.id },        })        .profile()    },  },}\n```\n\nInside of these resolvers, you're using your new `PrismaClient` to perform a query against the database. Inside the `posts` resolver, the database query loads all `Post` records from the specified `author` (whose `id` is carried in the `parent` object). Inside the `profile` resolver, the database query loads the `Profile` record from the specified `user` (whose `id` is carried in the `parent` object).\n\nThanks to these extra resolvers, you'll now be able to nest relations in your GraphQL queries/mutations whenever you're requesting information about the `User` type in a query, e.g.:\n\n```\n{  users {    id    name    posts {      # fetching this relation is enabled by the new type resolver      id      title    }    profile {      # fetching this relation is enabled by the new type resolver      id      bio    }  }}\n```\n\n### 2.2. Implementing the type resolver for the `Post` type[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#22-implementing-the-type-resolver-for-the-post-type \"Direct link to 22-implementing-the-type-resolver-for-the-post-type\")\n\nThe `Post` type in our sample GraphQL schema is defined as follows:\n\n```\ntype Post implements Node {  id: ID!  createdAt: DateTime!  updatedAt: DateTime!  title: String!  content: String  published: Boolean!  author: User  categories(    where: CategoryWhereInput    orderBy: Enumerable<CategoryOrderByInput>    skip: Int    after: String    before: String    first: Int    last: Int  ): [Category!]}\n```\n\nThis type has two relations:\n\n*   The `author` field denotes a 1-n relation to `User`\n*   The `categories` field denotes a m-n relation to `Category`\n\nSince you're not using `prisma-binding` any more, you now need to resolve these relations \"manually\" in type resolvers.\n\nYou can do so by adding a `Post` field to your _resolver map_ and implement the resolvers for the `author` and `categories` relations as follows:\n\n```\nconst resolvers = {  Query: {    // ... your query resolvers  },  Mutation: {    // ... your mutation resolvers  },  User: {    // ... your type resolvers for `User` from before  },  Post: {    author: (parent, args, context) => {      return context.prisma.post        .findUnique({          where: { id: parent.id },        })        .author()    },    categories: (parent, args, context) => {      return context.prisma.post        .findUnique({          where: { id: parent.id },        })        .categories()    },  },}\n```\n\nInside of these resolvers, you're using your new `PrismaClient` to perform a query against the database. Inside the `author` resolver, the database query loads the `User` record that represents the `author` of the `Post`. Inside the `categories` resolver, the database query loads all `Category` records from the specified `post` (whose `id` is carried in the `parent` object).\n\nThanks to these extra resolvers, you'll now be able to nest relations in your GraphQL queries/mutations whenever you're requesting information about the `User` type in a query, e.g.:\n\n```\n{  posts {    id    title    author {      # fetching this relation is enabled by the new type resolver      id      name    }    categories {      # fetching this relation is enabled by the new type resolver      id      name    }  }}\n```\n\n### 2.3. Implementing the type resolver for the `Profile` type[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#23-implementing-the-type-resolver-for-the-profile-type \"Direct link to 23-implementing-the-type-resolver-for-the-profile-type\")\n\nThe `Profile` type in our sample GraphQL schema is defined as follows:\n\n```\ntype Profile implements Node {  id: ID!  bio: String  user: User!}\n```\n\nThis type has one relation: The `user` field denotes a 1-n relation to `User`.\n\nSince you're not using `prisma-binding` any more, you now need to resolve this relation \"manually\" in type resolvers.\n\nYou can do so by adding a `Profile` field to your _resolver map_ and implement the resolvers for the `owner` relation as follows:\n\n```\nconst resolvers = {  Query: {    // ... your query resolvers  },  Mutation: {    // ... your mutation resolvers  },  User: {    // ... your type resolvers for `User` from before  },  Post: {    // ... your type resolvers for `Post` from before  },  Profile: {    user: (parent, args, context) => {      return context.prisma.profile        .findUnique({          where: { id: parent.id },        })        .owner()    },  },}\n```\n\nInside of this resolver, you're using your new `PrismaClient` to perform a query against the database. Inside the `user` resolver, the database query loads the `User` records from the specified `profile` (whose `id` is carried in the `parent` object).\n\nThanks to this extra resolver, you'll now be able to nest relations in your GraphQL queries/mutations whenever you're requesting information about the `Profile` type in a query.\n\n### 2.4. Implementing the type resolver for the `Category` type[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#24-implementing-the-type-resolver-for-the-category-type \"Direct link to 24-implementing-the-type-resolver-for-the-category-type\")\n\nThe `Category` type in our sample GraphQL schema is defined as follows:\n\n```\ntype Category implements Node {  id: ID!  name: String!  posts(    where: PostWhereInput    orderBy: Enumerable<PostOrderByInput>    skip: Int    after: String    before: String    first: Int    last: Int  ): [Post!]}\n```\n\nThis type has one relation: The `posts` field denotes a m-n relation to `Post`.\n\nSince you're not using `prisma-binding` any more, you now need to resolve this relation \"manually\" in type resolvers.\n\nYou can do so by adding a `Category` field to your _resolver map_ and implement the resolvers for the `posts` and `profile` relations as follows:\n\n```\nconst resolvers = {  Query: {    // ... your query resolvers  },  Mutation: {    // ... your mutation resolvers  },  User: {    // ... your type resolvers for `User` from before  },  Post: {    // ... your type resolvers for `Post` from before  },  Profile: {    // ... your type resolvers for `User` from before  },  Category: {    posts: (parent, args, context) => {      return context.prisma        .findUnique({          where: { id: parent.id },        })        .posts()    },  },}\n```\n\nInside of this resolver, you're using your new `PrismaClient` to perform a query against the database. Inside the `posts` resolver, the database query loads all `Post` records from the specified `categories` (whose `id` is carried in the `parent` object).\n\nThanks to this extra resolver, you'll now be able to nest relations in your GraphQL queries/mutations whenever you're requesting information about a `Category` type in a query.\n\nWith all your type resolvers in place, you can start migrating the actual GraphQL API operations.\n\n## 3\\. Migrate GraphQL operations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#3-migrate-graphql-operations \"Direct link to 3. Migrate GraphQL operations\")\n\n### 3.1. Migrate GraphQL queries[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#31-migrate-graphql-queries \"Direct link to 3.1. Migrate GraphQL queries\")\n\nIn this section, you'll migrate all GraphQL _queries_ from `prisma-binding` to Prisma Client.\n\n#### 3.1.1. Migrate the `users` query (which uses `forwardTo`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#311-migrate-the-users-query-which-uses-forwardto \"Direct link to 311-migrate-the-users-query-which-uses-forwardto\")\n\nIn our sample API, the `users` query from the sample GraphQL schema is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#sdl-schema-definition-with-prisma-binding \"Direct link to sdl-schema-definition-with-prisma-binding\")\n\n```\ntype Query {  users(where: UserWhereInput, orderBy: Enumerable<UserOrderByInput>, skip: Int, after: String, before: String, first: Int, last: Int): [User]!  # ... other queries}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#resolver-implementation-with-prisma-binding \"Direct link to resolver-implementation-with-prisma-binding\")\n\n```\nconst resolvers = {  Query: {    users: forwardTo('prisma'),    // ... other resolvers  },}\n```\n\n##### Implementing the `users` resolver with Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#implementing-the-users-resolver-with-prisma-client \"Direct link to implementing-the-users-resolver-with-prisma-client\")\n\nTo re-implement queries that were previously using `forwardTo`, the idea is to pass the incoming filtering, ordering and pagination arguments to `PrismaClient`:\n\n```\nconst resolvers = {  Query: {    users: (_, args, context, info) => {      // this doesn't work yet      const { where, orderBy, skip, first, last, after, before } = args      return context.prisma.user.findMany({        where,        orderBy,        skip,        first,        last,        after,        before,      })    },    // ... other resolvers  },}\n```\n\nNote that this approach does **not** work yet because the _structures_ of the incoming arguments is different from the ones expected by `PrismaClient`. To ensure the structures are compatible, you can use the `@prisma/binding-argument-transform` npm package which ensures compatibility:\n\n```\nnpm install @prisma/binding-argument-transform\n```\n\nYou can now use this package as follows:\n\n```\nconst {  makeOrderByPrisma2Compatible,  makeWherePrisma2Compatible,} = require('@prisma/binding-argument-transform')const resolvers = {  Query: {    users: (_, args, context, info) => {      // this still doesn't entirely work      const { where, orderBy, skip, first, last, after, before } = args      const prisma2Where = makeWherePrisma2Compatible(where)      const prisma2OrderBy = makeOrderByPrisma2Compatible(orderBy)      return context.prisma.user.findMany({        where: prisma2Where,        orderBy: prisma2OrderBy,        skip,        first,        last,        after,        before,      })    },    // ... other resolvers  },}\n```\n\nThe last remaining issue with this are the pagination arguments. Prisma ORM 2 introduces a [new pagination API](https://github.com/prisma/prisma/releases/tag/2.0.0-beta.7):\n\n*   The `first`, `last`, `before` and `after` arguments are removed\n*   The new `cursor` argument replaces `before` and `after`\n*   The new `take` argument replaces `first` and `last`\n\nHere is how you can adjust the call to make it compliant with the new Prisma Client pagination API:\n\n```\nconst {  makeOrderByPrisma2Compatible,  makeWherePrisma2Compatible,} = require('@prisma/binding-argument-transform')const resolvers = {  Query: {    users: (_, args, context) => {      const { where, orderBy, skip, first, last, after, before } = args      const prisma2Where = makeWherePrisma2Compatible(where)      const prisma2OrderBy = makeOrderByPrisma2Compatible(orderBy)      const skipValue = skip || 0      const prisma2Skip = Boolean(before) ? skipValue + 1 : skipValue      const prisma2Take = Boolean(last) ? -last : first      const prisma2Before = { id: before }      const prisma2After = { id: after }      const prisma2Cursor =        !Boolean(before) && !Boolean(after)          ? undefined          : Boolean(before)          ? prisma2Before          : prisma2After      return context.prisma.user.findMany({        where: prisma2Where,        orderBy: prisma2OrderBy,        skip: prisma2Skip,        cursor: prisma2Cursor,        take: prisma2Take,      })    },    // ... other resolvers  },}\n```\n\nThe calculations are needed to ensure the incoming pagination arguments map properly to the ones from the Prisma Client API.\n\n#### 3.1.2. Migrate the `posts(searchString: String): [Post!]!` query[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#312-migrate-the-postssearchstring-string-post-query \"Direct link to 312-migrate-the-postssearchstring-string-post-query\")\n\nThe `posts` query is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#sdl-schema-definition-with-prisma-binding-1 \"Direct link to sdl-schema-definition-with-prisma-binding-1\")\n\n```\ntype Query {  posts(searchString: String): [Post!]!  # ... other queries}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#resolver-implementation-with-prisma-binding-1 \"Direct link to resolver-implementation-with-prisma-binding-1\")\n\n```\nconst resolvers = {  Query: {    posts: (_, args, context, info) => {      return context.prisma.query.posts(        {          where: {            OR: [              { title_contains: args.searchString },              { content_contains: args.searchString },            ],          },        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Implementing the `posts` resolver with Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#implementing-the-posts-resolver-with-prisma-client \"Direct link to implementing-the-posts-resolver-with-prisma-client\")\n\nTo get the same behavior with the new Prisma Client, you'll need to adjust your resolver implementation:\n\n```\nconst resolvers = {  Query: {    posts: (_, args, context) => {      return context.prisma.post.findMany({        where: {          OR: [            { title: { contains: args.searchString } },            { content: { contains: args.searchString } },          ],        },      })    },    // ... other resolvers  },}\n```\n\nYou can now send the respective query in the GraphQL Playground:\n\n```\n{  posts {    id    title    author {      id      name    }  }}\n```\n\n#### 3.1.3. Migrate the `user(uniqueInput: UserUniqueInput): User` query[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#313-migrate-the-useruniqueinput-useruniqueinput-user-query \"Direct link to 313-migrate-the-useruniqueinput-useruniqueinput-user-query\")\n\nIn our sample app, the `user` query is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#sdl-schema-definition-with-prisma-binding-2 \"Direct link to sdl-schema-definition-with-prisma-binding-2\")\n\n```\ntype Query {  user(userUniqueInput: UserUniqueInput): User  # ... other queries}input UserUniqueInput {  id: String  email: String}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#resolver-implementation-with-prisma-binding-2 \"Direct link to resolver-implementation-with-prisma-binding-2\")\n\n```\nconst resolvers = {  Query: {    user: (_, args, context, info) => {      return context.prisma.query.user(        {          where: args.userUniqueInput,        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Implementing the `user` resolver with Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#implementing-the-user-resolver-with-prisma-client \"Direct link to implementing-the-user-resolver-with-prisma-client\")\n\nTo get the same behavior with the new Prisma Client, you'll need to adjust your resolver implementation:\n\n```\nconst resolvers = {  Query: {    user: (_, args, context) => {      return context.prisma.user.findUnique({        where: args.userUniqueInput,      })    },    // ... other resolvers  },}\n```\n\nYou can now send the respective query via the GraphQL Playground:\n\n```\n{  user(userUniqueInput: { email: \"alice@prisma.io\" }) {    id    name  }}\n```\n\n### 3.1. Migrate GraphQL mutations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#31-migrate-graphql-mutations \"Direct link to 3.1. Migrate GraphQL mutations\")\n\nIn this section, you'll migrate the GraphQL mutations from the sample schema.\n\n#### 3.1.2. Migrate the `createUser` mutation (which uses `forwardTo`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#312-migrate-the-createuser-mutation-which-uses-forwardto \"Direct link to 312-migrate-the-createuser-mutation-which-uses-forwardto\")\n\nIn the sample app, the `createUser` mutation from the sample GraphQL schema is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#sdl-schema-definition-with-prisma-binding-3 \"Direct link to sdl-schema-definition-with-prisma-binding-3\")\n\n```\ntype Mutation {  createUser(data: UserCreateInput!): User!  # ... other mutations}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#resolver-implementation-with-prisma-binding-3 \"Direct link to resolver-implementation-with-prisma-binding-3\")\n\n```\nconst resolvers = {  Mutation: {    createUser: forwardTo('prisma'),    // ... other resolvers  },}\n```\n\n##### Implementing the `createUser` resolver with Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#implementing-the-createuser-resolver-with-prisma-client \"Direct link to implementing-the-createuser-resolver-with-prisma-client\")\n\nTo get the same behavior with the new Prisma Client, you'll need to adjust your resolver implementation:\n\n```\nconst resolvers = {  Mutation: {    createUser: (_, args, context, info) => {      return context.prisma.user.create({        data: args.data,      })    },    // ... other resolvers  },}\n```\n\nYou can now write your first mutation against the new API, e.g.:\n\n```\nmutation {  createUser(data: { name: \"Alice\", email: \"alice@prisma.io\" }) {    id  }}\n```\n\nIn the sample app, the `createDraft` mutation is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#sdl-schema-definition-with-prisma-binding-4 \"Direct link to sdl-schema-definition-with-prisma-binding-4\")\n\n```\ntype Mutation {  createDraft(title: String!, content: String, authorId: String!): Post!  # ... other mutations}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#resolver-implementation-with-prisma-binding-4 \"Direct link to resolver-implementation-with-prisma-binding-4\")\n\n```\nconst resolvers = {  Mutation: {    createDraft: (_, args, context, info) => {      return context.prisma.mutation.createPost(        {          data: {            title: args.title,            content: args.content,            author: {              connect: {                id: args.authorId,              },            },          },        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Implementing the `createDraft` resolver with Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#implementing-the-createdraft-resolver-with-prisma-client \"Direct link to implementing-the-createdraft-resolver-with-prisma-client\")\n\nTo get the same behavior with the new Prisma Client, you'll need to adjust your resolver implementation:\n\n```\nconst resolvers = {  Mutation: {    createDraft: (_, args, context, info) => {      return context.prisma.post.create({        data: {          title: args.title,          content: args.content,          author: {            connect: {              id: args.authorId,            },          },        },      })    },    // ... other resolvers  },}\n```\n\nYou can now send the respective mutation via the GraphQL Playground:\n\n```\nmutation {  createDraft(title: \"Hello World\", authorId: \"__AUTHOR_ID__\") {    id    published    author {      id      name    }  }}\n```\n\n#### 3.1.4. Migrate the `updateBio(bio: String, userUniqueInput: UserUniqueInput!): User` mutation[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#314-migrate-the-updatebiobio-string-useruniqueinput-useruniqueinput-user-mutation \"Direct link to 314-migrate-the-updatebiobio-string-useruniqueinput-useruniqueinput-user-mutation\")\n\nIn the sample app, the `updateBio` mutation is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#sdl-schema-definition-with-prisma-binding-5 \"Direct link to sdl-schema-definition-with-prisma-binding-5\")\n\n```\ntype Mutation {  updateBio(bio: String!, userUniqueInput: UserUniqueInput!): User  # ... other mutations}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#resolver-implementation-with-prisma-binding-5 \"Direct link to resolver-implementation-with-prisma-binding-5\")\n\n```\nconst resolvers = {  Mutation: {    updateBio: (_, args, context, info) => {      return context.prisma.mutation.updateUser(        {          data: {            profile: {              update: { bio: args.bio },            },          },          where: { id: args.userId },        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Implementing the `updateBio` resolver with Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#implementing-the-updatebio-resolver-with-prisma-client \"Direct link to implementing-the-updatebio-resolver-with-prisma-client\")\n\nTo get the same behavior with Prisma Client, you'll need to adjust your resolver implementation:\n\n```\nconst resolvers = {  Mutation: {    updateBio: (_, args, context, info) => {      return context.prisma.user.update({        data: {          profile: {            update: { bio: args.bio },          },        },        where: args.userUniqueInput,      })    },    // ... other resolvers  },}\n```\n\nYou can now send the respective mutation via the GraphQL Playground :\n\n```\nmutation {  updateBio(    userUniqueInput: { email: \"alice@prisma.io\" }    bio: \"I like turtles\"  ) {    id    name    profile {      id      bio    }  }}\n```\n\n#### 3.1.5. Migrate the `addPostToCategories(postId: String!, categoryIds: [String!]!): Post` mutation[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#315-migrate-the-addposttocategoriespostid-string-categoryids-string-post-mutation \"Direct link to 315-migrate-the-addposttocategoriespostid-string-categoryids-string-post-mutation\")\n\nIn our sample app, the `addPostToCategories` mutation is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#sdl-schema-definition-with-prisma-binding-6 \"Direct link to sdl-schema-definition-with-prisma-binding-6\")\n\n```\ntype Mutation {  addPostToCategories(postId: String!, categoryIds: [String!]!): Post  # ... other mutations}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#resolver-implementation-with-prisma-binding-6 \"Direct link to resolver-implementation-with-prisma-binding-6\")\n\n```\nconst resolvers = {  Mutation: {    addPostToCategories: (_, args, context, info) => {      const ids = args.categoryIds.map((id) => ({ id }))      return context.prisma.mutation.updatePost(        {          data: {            categories: {              connect: ids,            },          },          where: {            id: args.postId,          },        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Implementing the `addPostToCategories` resolver with Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#implementing-the-addposttocategories-resolver-with-prisma-client \"Direct link to implementing-the-addposttocategories-resolver-with-prisma-client\")\n\nTo get the same behavior with Prisma Client, you'll need to adjust your resolver implementation:\n\n```\nconst resolvers = {  Mutation: {    addPostToCategories: (_, args, context, info) => {      const ids = args.categoryIds.map((id) => ({ id }))      return context.prisma.post.update({        where: {          id: args.postId,        },        data: {          categories: { connect: ids },        },      })    },    // ... other resolvers  },}\n```\n\nYou can now send the respective query via the GraphQL Playground:\n\n```\nmutation {  addPostToCategories(    postId: \"__AUTHOR_ID__\"    categoryIds: [\"__CATEGORY_ID_1__\", \"__CATEGORY_ID_2__\"]  ) {    id    title    categories {      id      name    }  }}\n```\n\n## 4\\. Cleaning up[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#4-cleaning-up \"Direct link to 4. Cleaning up\")\n\nSince the entire app has now been upgraded to Prisma ORM 2, you can delete all unnecessary files and remove the no longer needed dependencies.\n\n### 4.1. Clean up npm dependencies[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#41-clean-up-npm-dependencies \"Direct link to 4.1. Clean up npm dependencies\")\n\nYou can start by removing npm dependencies that were related to the Prisma 1 setup:\n\n```\nnpm uninstall graphql-cli prisma-binding prisma1\n```\n\n### 4.2. Delete unused files[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#42-delete-unused-files \"Direct link to 4.2. Delete unused files\")\n\nNext, delete the files of your Prisma 1 setup:\n\n```\nrm prisma1/datamodel.prisma prisma1/prisma.yml\n```\n\n### 4.3. Stop the Prisma ORM server[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first#43-stop-the-prisma-orm-server \"Direct link to 4.3. Stop the Prisma ORM server\")\n\nFinally, you can stop running your Prisma ORM server.",
    "title": "Upgrading from Prisma 1 with prisma-binding to SDL-first | Prisma Documentation",
    "description": "Learn how to upgrade existing Prisma 1 projects with prisma-binding to Prisma ORM 2 (SDL-first).",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus",
    "markdown": "# Upgrading from Prisma 1 with prisma-binding to Nexus\n\n## Overview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#overview \"Direct link to Overview\")\n\n> **Note**: This guide is not fully up-to-date as it currently uses the [deprecated](https://github.com/graphql-nexus/nexus-plugin-prisma/issues/1039) version of the [`nexus-plugin-prisma`](https://github.com/graphql-nexus/nexus-plugin-prisma). While this is still functional, it is recommended to use the new [`nexus-prisma`](https://github.com/prisma/nexus-prisma/) library or an alternative code-first GraphQL library like [Pothos](https://pothos-graphql.dev/) going forward. If you have any questions, join us on our [Discord](https://pris.ly/discord).\n\nThis upgrade guide describes how to migrate a Node.js project that's based on [Prisma 1](https://github.com/prisma/prisma1) and uses `prisma-binding` to implement a GraphQL server.\n\nThe code will be migrated to [`@nexus/schema`](https://github.com/graphql-nexus/schema) and the [`nexus-plugin-prisma`](https://github.com/graphql-nexus/nexus-plugin-prisma). As opposed to the _SDL-first_ approach that's used with `prisma-binding`, Nexus follows a code-first approach to construct GraphQL schemas. You can learn about the main differences of these two approaches in this [article](https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3). If you want to continue using the SDL-first approach, you can follow the [guide](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first) to upgrade from `prisma-binding` to an SDL-first setup.\n\nThis guide also explains how to migrate from JavaScript to TypeScript, it therefore basically assumes a **full rewrite** of your existing app. If you want to keep running your application in JavaScript, you can ignore the instructions that relate to the TypeScript setup keep using JavaScript as before.\n\nThe guide assumes that you already went through the [guide for upgrading the Prisma ORM layer](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql). This means you already:\n\n*   installed the Prisma ORM 2.0 CLI\n*   created your Prisma ORM 2.0 schema\n*   introspected your database and resolved potential [schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql)\n*   installed and generated Prisma Client\n\nThe guide further assumes that you have a file setup that looks similar to this:\n\n```\n.├── README.md├── package.json├── prisma│   └── schema.prisma├── prisma1│   ├── datamodel.prisma│   └── prisma.yml└── src    ├── generated    │   └── prisma.graphql    ├── index.js    └── schema.graphql\n```\n\nThe important parts are:\n\n*   A folder called with `prisma` with your Prisma ORM 2.0 schema\n*   A folder called `src` with your application code and a schema called `schema.graphql`\n\nIf this is not what your project structure looks like, you'll need to adjust the instructions in the guide to match your own setup.\n\n## 1\\. Installing and configuring Nexus[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#1-installing-and-configuring-nexus \"Direct link to 1. Installing and configuring Nexus\")\n\n### 1.1. Install Nexus dependencies[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#11-install-nexus-dependencies \"Direct link to 1.1. Install Nexus dependencies\")\n\nThe first step is to install the Nexus dependency in your project:\n\n```\nnpm install @nexus/schema\n```\n\nNext, install the the Prisma ORM plugin for Nexus which will allow you to expose Prisma models in your GraphQL API:\n\n```\nnpm install nexus-plugin-prisma\n```\n\nThe `nexus-plugin-prisma` dependency bundles all required Prisma ORM dependencies. You should therefore remove the dependencies that you installed when you upgraded the Prisma ORM layer of your app:\n\n```\nnpm uninstall @prisma/cli @prisma/client\n```\n\nNote however that you can still invoke the Prisma ORM 2.0 CLI with the familiar command:\n\n### 1.2. Configure TypeScript[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#12-configure-typescript \"Direct link to 1.2. Configure TypeScript\")\n\nSince you'll be using TypeScript in this guide, you need to add the required dependencies:\n\n```\nnpm install typescript ts-node-dev --save-dev\n```\n\nCreate a new file named `tsconfig.json` in the root directory of your project:\n\nNow add the following contents to the new file:\n\ntsconfig.json\n\n```\n{  \"compilerOptions\": {    \"skipLibCheck\": true,    \"strict\": true,    \"rootDir\": \"src\",    \"noEmit\": true  },  \"include\": [\"src/**/*\"]}\n```\n\n### 1.3. Create your basic Nexus setup[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#13-create-your-basic-nexus-setup \"Direct link to 1.3. Create your basic Nexus setup\")\n\nCreate the root source file of your API called `index.ts` inside the `src` directory:\n\nNote that for this guide, you'll write the entire application inside of `index.ts`. In practice, you probably want to split your GraphQL types across different files as shown in this [example](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-auth).\n\nFor some basic setup, add this code to `index.ts`:\n\nindex.ts\n\n```\nimport { queryType, makeSchema } from '@nexus/schema'import { nexusSchemaPrisma } from 'nexus-plugin-prisma/schema'import { GraphQLServer } from 'graphql-yoga'import { createContext } from './context'const Query = queryType({  definition(t) {    t.string('hello', () => {      return 'Hello Nexus!'    })  },})export const schema = makeSchema({  types: [Query],  plugins: [nexusSchemaPrisma({ experimentalCRUD: true })],  outputs: {    schema: __dirname + '/../schema.graphql',    typegen: __dirname + '/generated/nexus.ts',  },  typegenAutoConfig: {    contextType: 'Context.Context',    sources: [      {        source: '@prisma/client',        alias: 'prisma',      },      {        source: require.resolve('./context'),        alias: 'Context',      },    ],  },})new GraphQLServer({ schema, context: createContext() }).start(() =>  console.log(`Server ready at: http://localhost:4000`))\n```\n\nNote that this setup already contains the configuration of the Prisma ORM plugin for Nexus. This will enable the `t.model` and `t.crud` functionality that you'll get to know later in this guide.\n\nIn the `typegenAutoConfig` setting, you're providing additional types that help your editor to provide your autocompletion as you develop your app. Right now it references a file named `context.ts` that you don't have in your project yet. This file will contain the type of your `context` object that's passed through your GraphQL resolver chain.\n\nCreate the new `context.ts` file inside the `src` directory:\n\nNow add the following code to it:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()export interface Context {  prisma: PrismaClient}export function createContext(): Context {  return { prisma }}\n```\n\nNext, adjust the `scripts` section inside your `package.json` to include the following commands:\n\n```\n{  \"scripts\": {    \"start\": \"node dist/server\",    \"clean\": \"rm -rf dist\",    \"build\": \"npm -s run clean && npm -s run generate && tsc\",    \"generate\": \"npm -s run generate:prisma && npm -s run generate:nexus\",    \"generate:prisma\": \"prisma generate\",    \"generate:nexus\": \"ts-node --transpile-only src/schema\",    \"dev\": \"ts-node-dev --no-notify --respawn --transpile-only src\"  }}\n```\n\nThe `dev` script starts a development server that you **always** should have running in the background when developing your app. This is important because of the code generation Nexus performs in the background.\n\nYou can start the development server using the following command:\n\nYou should see the following CLI output:\n\n```\nServer ready at: http://localhost:4000\n```\n\nYour GraphQL server is now running at [http://localhost:4000](http://localhost:4000/). So far it implements a single GraphQL query that you can send as follows:\n\nIn the following steps, we'll explain how you can migrate your existing SDL-first GraphQL schema that's implemented with `prisma-binding` to an equivalent setup using Nexus.\n\n## 2\\. Create your GraphQL types[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#2-create-your-graphql-types \"Direct link to 2. Create your GraphQL types\")\n\nThe next step of the upgrade process is to create your _GraphQL types_. In this case, your GraphQL types will mirror the Prisma models (as it likely was the case in your `prisma-binding` setup as well). If a GraphQL type deviates from a Prisma model, you'll be able to easily adjust the exposed GraphQL type accordingly using the Nexus API.\n\nFor the purpose of this guide, you'll keep all the code in a single file. However, you can structure the files to your personal preference and `import` accordingly.\n\nIn Nexus, GraphQL types are defined via the `objectType` function. Import `objectType` and then start with the skeleton for your first GraphQL type. In this case, we're starting by mapping Prisma schema's `User` model to GraphQL:\n\n```\nimport { objectType } from 'nexus'const User = objectType({  name: 'User',  definition(t) {    // the fields of the type will be defined here  },})\n```\n\nWith this code in place, you can start exposing the _fields_ of the `User` model one by one. You can use your editor's autocompletion to save some typing. Inside the body of the `definition` function, type `t.model.` and then hit CTRL+SPACE. This will bring up the autocompletion and suggest all fields that are defined on the `User` model:\n\n![Exposing Prisma model fields with t.model](https://www.prisma.io/docs/assets/images/expose-prisma-model-fields-with-t-model-a9d3088dc56d536a4de65de4733c9aba.png)\n\nNote that the `model` property on `t` is provided by the `nexus-plugin-prisma`. It leverages the type information from your Prisma schema and lets you expose your Prisma models via GraphQL.\n\nIn that manner, you can start completing your object type definition until you exposed all the fields of the model:\n\n```\nconst User = objectType({  name: 'User',  definition(t) {    t.model.id()    t.model.email()    t.model.name()    t.model.jsonData()    t.model.role()    t.model.profile()    t.model.posts()  },})\n```\n\nAt this point, any _relation fields_ might give you TypeScript errors (in this case, that would be `profile` and `posts` which both point to other object types). That's expected, these errors will resolve automatically after you've added the remaining types.\n\n> **Note**: Be sure to have your Nexus development server that you started with `npm run dev` running all the time. It constantly updates the generated Nexus types that enable the autocompletion in the background as you save a file.\n\nNote that the `t.model.posts` relation exposes a _list_ of `Post` objects. By default, Nexus exposes only _pagination_ properties for that list – if you want to add _ordering_ and _filtering_ for that relation as well, you'll need to explicitly enable those:\n\n```\nconst User = objectType({  name: 'User',  definition(t) {    t.model.id()    t.model.email()    t.model.name()    t.model.jsonData()    t.model.role()    t.model.profile()    t.model.posts({      filtering: true,      ordering: true,    })  },})\n```\n\nAfter defining a type using the `objectType` function, you also need to manually add it to your GraphQL schema that you're building with Nexus. You can do it by adding it to the `types` which are provided as an option to the `makeSchema` function:\n\n```\nexport const schema = makeSchema({  types: [Query, User],  plugins: [nexusSchemaPrisma()],  outputs: {    schema: __dirname + '/../schema.graphql',    typegen: __dirname + '/generated/nexus.ts',  },  typegenAutoConfig: {    sources: [      {        source: '@prisma/client',        alias: 'prisma',      },    ],  },})\n```\n\nOnce you're done with the first type, you can start defining the remaining ones.\n\nExpand to view the full version of the sample data model\n\nTo expose all sample Prisma models with Nexus, the following code is needed:\n\n```\nconst User = objectType({  name: 'User',  definition(t) {    t.model.id()    t.model.email()    t.model.name()    t.model.jsonData()    t.model.role()    t.model.profile()    t.model.posts({      filtering: true,      ordering: true,    })  },})const Post = objectType({  name: 'Post',  definition(t) {    t.model.id()    t.model.createdAt()    t.model.updatedAt()    t.model.title()    t.model.content()    t.model.published()    t.model.author()    t.model.authorId()    t.model.categories({      filtering: true,      ordering: true,    })  },})const Profile = objectType({  name: 'Profile',  definition(t) {    t.model.id()    t.model.bio()    t.model.userId()    t.model.user()  },})const Category = objectType({  name: 'Category',  definition(t) {    t.model.id()    t.model.name()    t.model.posts({      filtering: true,      ordering: true,    })  },})\n```\n\nBe sure to include all newly defined types in the `types` option that's provided to `makeSchema`:\n\n```\nexport const schema = makeSchema({  types: [Query, User, Post, Profile, Category],  plugins: [nexusSchemaPrisma()],  outputs: {    schema: __dirname + '/../schema.graphql',    typegen: __dirname + '/generated/nexus.ts',  },  typegenAutoConfig: {    sources: [      {        source: '@prisma/client',        alias: 'prisma',      },    ],  },})\n```\n\nYou can view the current version of your GraphQL schema in SDL in the generated GraphQL schema file in `./schema.graphql`.\n\n## 3\\. Migrate GraphQL operations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#3-migrate-graphql-operations \"Direct link to 3. Migrate GraphQL operations\")\n\nAs a next step, you can start migrating all the GraphQL _queries_ and _mutations_ from the \"previous\" GraphQL API to the new one that's built with Nexus.\n\nFor this guide, the following sample GraphQL schema will be used:\n\n```\n# import Post from './generated/prisma.graphql'# import User from './generated/prisma.graphql'# import Category from './generated/prisma.graphql'input UserUniqueInput {  id: String  email: String}type Query {  posts(searchString: String): [Post!]!  user(userUniqueInput: UserUniqueInput!): User  users(where: UserWhereInput, orderBy: Enumerable<UserOrderByInput>, skip: Int, after: String, before: String, first: Int, last: Int): [User]!}type Mutation {  createUser(data: UserCreateInput!): User!  createDraft(title: String!, content: String, authorId: ID!): Post  updateBio(userUniqueInput: UserUniqueInput!, bio: String!): User  addPostToCategories(postId: String!, categoryIds: [String!]!): Post}\n```\n\n### 3.1. Migrate GraphQL queries[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#31-migrate-graphql-queries \"Direct link to 3.1. Migrate GraphQL queries\")\n\nIn this section, you'll migrate all GraphQL _queries_ from `prisma-binding` to Nexus.\n\n#### 3.1.1. Migrate the `users` query (which uses `forwardTo`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#311-migrate-the-users-query-which-uses-forwardto \"Direct link to 311-migrate-the-users-query-which-uses-forwardto\")\n\nIn our sample API, the `users` query from the sample GraphQL schema is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#sdl-schema-definition-with-prisma-binding \"Direct link to sdl-schema-definition-with-prisma-binding\")\n\n```\ntype Query {  users(where: UserWhereInput, orderBy: Enumerable<UserOrderByInput>, skip: Int, after: String, before: String, first: Int, last: Int): [User]!  # ... other queries}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-prisma-binding \"Direct link to resolver-implementation-with-prisma-binding\")\n\n```\nconst resolvers = {  Query: {    users: forwardTo('prisma'),    // ... other resolvers  },}\n```\n\nTo mirror the same behaviour with Nexus, you can use the `crud` property on the `t` variable inside the `definition` function.\n\nSimilar to `model`, this property is available because you're using the `nexus-prisma-plugin` which leverages type information from your Prisma models and auto-generates resolvers under the hood. The `crud` property also supports autocompletion, so you can explore all available queries in your editor again:\n\n![Using t.crud to generate resolvers](https://www.prisma.io/docs/assets/images/use-t-crud-to-generate-resolvers-b09199bb596c72008f38cc416f5f4d96.png)\n\n##### Forwarding the query with the `nexus-prisma-plugin`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#forwarding-the-query-with-the-nexus-prisma-plugin \"Direct link to forwarding-the-query-with-the-nexus-prisma-plugin\")\n\nTo add the `users` query to your GraphQL API, add the following lines to the query type definition:\n\n```\nconst Query = queryType({  definition(t) {    t.crud.users({      filtering: true,      ordering: true,    })  },})\n```\n\nIf you have the Nexus development server running, you can save the file and your GraphQL API will be updated to expose the new `users` query. You can also observe this by looking at the `Query` type inside the generated `schema.graphql` file:\n\n```\ntype Query {  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: Enumerable<UserOrderByInput>, skip: Int, where: UserWhereInput): [User!]!}\n```\n\nYou can now write your first query against the new API, e.g.:\n\n```\n{  users {    id    name    profile {      id      bio    }    posts {      id      title      categories {        id        name      }    }  }}\n```\n\nIf your application exposes all CRUD operations from Prisma ORM using `forwardTo`, you can now continue adding all remaining ones using the same approach via `t.crud`. To learn how \"custom\" queries can be defined and resolved using Nexus, move on to the next sections.\n\n#### 3.1.2. Migrate the `posts(searchString: String): [Post!]!` query[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#312-migrate-the-postssearchstring-string-post-query \"Direct link to 312-migrate-the-postssearchstring-string-post-query\")\n\nThe `posts` query is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#sdl-schema-definition-with-prisma-binding-1 \"Direct link to sdl-schema-definition-with-prisma-binding-1\")\n\n```\ntype Query {  posts(searchString: String): [Post!]!  # ... other queries}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-prisma-binding-1 \"Direct link to resolver-implementation-with-prisma-binding-1\")\n\n```\nconst resolvers = {  Query: {    posts: (_, args, context, info) => {      return context.prisma.query.posts(        {          where: {            OR: [              { title_contains: args.searchString },              { content_contains: args.searchString },            ],          },        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Code-first schema definition with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#code-first-schema-definition-with-nexus \"Direct link to code-first-schema-definition-with-nexus\")\n\nTo get the same behavior with Nexus, you'll need to add a `t.field` definition to the `queryType`:\n\n```\nconst Query = queryType({  definition(t) {    // ... previous queries    t.list.field('posts', {      type: 'Post',      nullable: false,      args: { searchString: stringArg() },    })  },})\n```\n\nAlthough this code gives probably gives you a type error in your editor, you can already look at the generated SDL version of your GraphQL schema inside `schema.graphql`. You'll notice that this has added the correct _definition_ to your GraphQL schema already:\n\n```\ntype Query {  posts(searchString: String): [Post!]!  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: Enumerable<UserOrderByInput>, skip: Int, where: UserWhereInput): [User!]!}\n```\n\nHowever, the code is missing the actual resolver logic. This is what you're going to add next.\n\n##### Resolver implementation with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-nexus \"Direct link to resolver-implementation-with-nexus\")\n\nYou can add the resolver with Nexus as follows:\n\n```\nconst Query = queryType({  definition(t) {    // ... previous queries    t.list.field('posts', {      type: 'Post',      nullable: false,      args: { searchString: stringArg() },      resolve: (_, args, context) => {        return context.prisma.post.findMany({          where: {            OR: [              {                title: { contains: args.searchString },              },              {                content: { contains: args.searchString },              },            ],          },        })      },    })  },})\n```\n\nTo validate the implementation, you can now e.g. send the following example query to your GraphQL server:\n\n```\n{  posts {    id    title    author {      id      name    }  }}\n```\n\n#### 3.1.2. Migrate the `user(uniqueInput: UserUniqueInput): User` query[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#312-migrate-the-useruniqueinput-useruniqueinput-user-query \"Direct link to 312-migrate-the-useruniqueinput-useruniqueinput-user-query\")\n\nIn our sample app, the `user` query is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#sdl-schema-definition-with-prisma-binding-2 \"Direct link to sdl-schema-definition-with-prisma-binding-2\")\n\n```\ntype Query {  user(userUniqueInput: UserUniqueInput): User  # ... other queries}input UserUniqueInput {  id: String  email: String}\n```\n\nNote that this is a bit of a contrived example to demonstrate the usage of `input` types with Nexus.\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-prisma-binding-2 \"Direct link to resolver-implementation-with-prisma-binding-2\")\n\n```\nconst resolvers = {  Query: {    user: (_, args, context, info) => {      return context.prisma.query.user(        {          where: args.userUniqueInput,        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Code-first schema definition with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#code-first-schema-definition-with-nexus-1 \"Direct link to code-first-schema-definition-with-nexus-1\")\n\nTo get the same behavior with Nexus, you'll need to add a `t.field` definition to the `queryType` and define an `inputObjectType` that includes the two `@unique` fields of your `User` model:\n\n```\nimport { inputObjectType, arg } from '@nexus/schema'const UserUniqueInput = inputObjectType({  name: 'UserUniqueInput',  definition(t) {    t.string('id')    t.string('email')  },})const Query = queryType({  definition(t) {    // ... previous queries    t.field('user', {      type: 'User',      args: {        userUniqueInput: arg({          type: 'UserUniqueInput',          nullable: false,        }),      },    })  },})\n```\n\nSince `UserUniqueInput` is a new type in your GraphQL schema, you again need to add it to the `types` option that's passed to `makeSchema`:\n\n```\nexport const schema = makeSchema({  types: [Query, User, Post, Profile, Category, UserUniqueInput],  plugins: [nexusSchemaPrisma()],  outputs: {    schema: __dirname + '/../schema.graphql',    typegen: __dirname + '/generated/nexus.ts',  },  typegenAutoConfig: {    sources: [      {        source: '@prisma/client',        alias: 'prisma',      },    ],  },})\n```\n\nIf you look at the generated SDL version of your GraphQL schema inside `schema.graphql`, you'll notice that this change already added the correct _definition_ to your GraphQL schema:\n\n```\ntype Query {  posts(searchString: String): [Post!]  user(userUniqueInput: UserUniqueInput!): User  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: Enumerable<UserOrderByInput>, skip: Int, where: UserWhereInput): [User!]!}input UserUniqueInput {  email: String  id: String}\n```\n\nYou can even send the respective query via the GraphQL Playground already:\n\n```\n{  user(userUniqueInput: { email: \"alice@prisma.io\" }) {    id    name  }}\n```\n\nHowever, because the resolver is not yet implemented you will not get any data back yet.\n\n##### Code-first resolver implementation with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#code-first-resolver-implementation-with-nexus \"Direct link to code-first-resolver-implementation-with-nexus\")\n\nThat's because you're still missing the _resolver_ implementation for that query. You can add the resolver with Nexus as follows:\n\n```\nconst UserUniqueInput = inputObjectType({  name: 'UserUniqueInput',  definition(t) {    t.string('id')    t.string('email')  },})const Query = queryType({  definition(t) {    // ... previous queries    t.field('user', {      type: 'User',      nullable: true,      args: {        userUniqueInput: arg({          type: 'UserUniqueInput',          nullable: false,        }),      },      resolve: (_, args, context) => {        return context.prisma.user.findUnique({          where: {            id: args.userUniqueInput?.id,            email: args.userUniqueInput?.email,          },        })      },    })  },})\n```\n\nIf you're re-sending the same query from before, you'll find that it now returns actual data.\n\n### 3.2. Migrate GraphQL mutations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#32-migrate-graphql-mutations \"Direct link to 3.2. Migrate GraphQL mutations\")\n\nIn this section, you'll migrate the GraphQL mutations from the sample schema to the Nexus.\n\n#### 3.2.1. Define the `Mutation` type[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#321-define-the-mutation-type \"Direct link to 321-define-the-mutation-type\")\n\nThe first step to migrate any mutations is to define the `Mutation` type of your GraphQL API. Once that's done, you can gradually add operations to it. Add the following definition to `index.ts`:\n\n```\nimport { mutationType } from '@nexus/schema'const Mutation = mutationType({  definition(t) {    // your GraphQL mutations + resolvers will be defined here  },})\n```\n\nIn order to make sure that the new `Mutation` type is picked by up Nexus, you need to add it to the `types` that are provided to `makeSchema`:\n\n```\nexport const schema = makeSchema({  types: [Query, User, Post, Profile, Category, UserUniqueInput, Mutation],  plugins: [nexusSchemaPrisma()],  outputs: {    schema: __dirname + '/../schema.graphql',    typegen: __dirname + '/generated/nexus.ts',  },  typegenAutoConfig: {    sources: [      {        source: '@prisma/client',        alias: 'prisma',      },    ],  },})\n```\n\n#### 3.2.2. Migrate the `createUser` mutation (which uses `forwardTo`)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#322-migrate-the-createuser-mutation-which-uses-forwardto \"Direct link to 322-migrate-the-createuser-mutation-which-uses-forwardto\")\n\nIn the sample app, the `createUser` mutation from the sample GraphQL schema is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#sdl-schema-definition-with-prisma-binding-3 \"Direct link to sdl-schema-definition-with-prisma-binding-3\")\n\n```\ntype Mutation {  createUser(data: UserCreateInput!): User!  # ... other mutations}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-prisma-binding-3 \"Direct link to resolver-implementation-with-prisma-binding-3\")\n\n```\nconst resolvers = {  Mutation: {    createUser: forwardTo('prisma'),    // ... other resolvers  },}\n```\n\nSimilar to forwarding GraphQL queries, you can use the `crud` property on the `t` variable inside the `definition` function in order to expose full CRUD capabilities for Prisma models.\n\nSimilar to `model`, this property is available because you're using the `nexus-prisma-plugin` which leverages type information from your Prisma models and auto-generates resolvers under the hood. The `crud` property supports autocompletion when defining mutations as well, so you can explore all available operations in your editor again:\n\n![Generating resolvers with t.crud](https://www.prisma.io/docs/assets/images/regenerate-resolvers-with-t-crud-5ce56b7b61bdef5257d87ea7f7402a37.png)\n\n##### Forwarding the mutation with the `nexus-prisma-plugin`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#forwarding-the-mutation-with-the-nexus-prisma-plugin \"Direct link to forwarding-the-mutation-with-the-nexus-prisma-plugin\")\n\nTo add the `createUser` mutation to your GraphQL API, add the following lines to the query type definition:\n\n```\nconst Mutation = mutationType({  definition(t) {    t.crud.createOneUser({      alias: 'createUser',    })  },})\n```\n\nNote that the default name for the mutation in your GraphQL schema is `createOneUser` (named after the function which is exposed by `t.crud`). In order to rename it to `createUser`, you need to provide the `alias` property.\n\nIf you have the Nexus development server running, you can save the file and your GraphQL API will be updated to expose the new `createUser` mutation. You can also observe this by looking at the `Mutation` type inside the generated `schema.graphql` file:\n\n```\ntype Mutation {  createUser(data: UserCreateInput!): User!}\n```\n\nYou can now write your first mutation against the new API, e.g.:\n\n```\nmutation {  createUser(data: { name: \"Alice\", email: \"alice@prisma.io\" }) {    id  }}\n```\n\nIf your application exposes all CRUD operations from Prisma Client using `forwardTo`, you can now continue adding all remaining ones using the same approach via `t.crud`. To learn how \"custom\" mutations can be defined and resolved using Nexus, move on to the next sections.\n\nIn the sample app, the `createDraft` mutation is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#sdl-schema-definition-with-prisma-binding-4 \"Direct link to sdl-schema-definition-with-prisma-binding-4\")\n\n```\ntype Mutation {  createDraft(title: String!, content: String, authorId: String!): Post!  # ... other mutations}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-prisma-binding-4 \"Direct link to resolver-implementation-with-prisma-binding-4\")\n\n```\nconst resolvers = {  Mutation: {    createDraft: (_, args, context, info) => {      return context.prisma.mutation.createPost(        {          data: {            title: args.title,            content: args.content,            author: {              connect: {                id: args.authorId,              },            },          },        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Code-first schema definition with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#code-first-schema-definition-with-nexus-2 \"Direct link to code-first-schema-definition-with-nexus-2\")\n\nTo get the same behavior with Nexus, you'll need to add a `t.field` definition to the `mutationType`:\n\n```\nconst Mutation = mutationType({  definition(t) {    // ... previous mutations    t.field('createDraft', {      type: 'Post',      args: {        title: stringArg({ nullable: false }),        content: stringArg(),        authorId: stringArg({ nullable: false }),      },    })  },})\n```\n\nIf you look at the generated SDL version of your GraphQL schema inside `schema.graphql`, you'll notice that this has added the correct _definition_ to your GraphQL schema already:\n\n```\ntype Mutation {  createUser(data: UserCreateInput!): User!  createDraft(title: String!, content: String, authorId: String!): Post!}\n```\n\nYou can even send the respective mutation via the GraphQL Playground already:\n\n```\nmutation {  createDraft(title: \"Hello World\", authorId: \"__AUTHOR_ID__\") {    id    published    author {      id      name    }  }}\n```\n\nHowever, because the resolver is not yet implemented, no new `Post` record will be created and you will not get any data back in the response.\n\n##### Resolver implementation with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-nexus-1 \"Direct link to resolver-implementation-with-nexus-1\")\n\nThat's because you're still missing the _resolver_ implementation for that mutation. You can add the resolver with Nexus as follows:\n\n```\nconst Mutation = mutationType({  definition(t) {    // ... previous mutations    t.field('createDraft', {      type: 'Post',      args: {        title: stringArg({ nullable: false }),        content: stringArg(),        authorId: stringArg({ nullable: false }),      },      resolve: (_, args, context) => {        return context.prisma.post.create({          data: {            title: args.title,            content: args.content,            author: {              connect: { id: args.authorId },            },          },        })      },    })  },})\n```\n\nIf you're re-sending the same query from before, you'll find that it now create a new `Post` record and return valid data.\n\n#### 3.2.4. Migrate the `updateBio(bio: String, userUniqueInput: UserUniqueInput!): User` mutation[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#324-migrate-the-updatebiobio-string-useruniqueinput-useruniqueinput-user-mutation \"Direct link to 324-migrate-the-updatebiobio-string-useruniqueinput-useruniqueinput-user-mutation\")\n\nIn the sample app, the `updateBio` mutation is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#sdl-schema-definition-with-prisma-binding-5 \"Direct link to sdl-schema-definition-with-prisma-binding-5\")\n\n```\ntype Mutation {  updateBio(bio: String!, userUniqueInput: UserUniqueInput!): User  # ... other mutations}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-prisma-binding-5 \"Direct link to resolver-implementation-with-prisma-binding-5\")\n\n```\nconst resolvers = {  Mutation: {    updateBio: (_, args, context, info) => {      return context.prisma.mutation.updateUser(        {          data: {            profile: {              update: { bio: args.bio },            },          },          where: { id: args.userId },        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Code-first schema definition with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#code-first-schema-definition-with-nexus-3 \"Direct link to code-first-schema-definition-with-nexus-3\")\n\nTo get the same behavior with Nexus, you'll need to add a `t.field` definition to the `mutationType`:\n\n```\nconst Mutation = mutationType({  definition(t) {    // ... previous mutations    t.field('updateBio', {      type: 'User',      args: {        userUniqueInput: arg({          type: 'UserUniqueInput',          nullable: false,        }),        bio: stringArg({ nullable: false }),      },    })  },})\n```\n\nIf you look at the generated SDL version of your GraphQL schema inside `schema.graphql`, you'll notice that this has added the correct _definition_ to your GraphQL schema already:\n\n```\ntype Mutation {  createUser(data: UserCreateInput!): User!  createDraft(title: String!, content: String, authorId: String!): Post!  updateBio(bio: String!, userUniqueInput: UserUniqueInput!): User}\n```\n\nYou can even send the respective mutation via the GraphQL Playground already:\n\n```\nmutation {  updateBio(    userUniqueInput: { email: \"alice@prisma.io\" }    bio: \"I like turtles\"  ) {    id    name    profile {      id      bio    }  }}\n```\n\nHowever, because the resolver is not yet implemented, nothing will be updated in the database and you will not get any data back in the response.\n\n##### Resolver implementation with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-nexus-2 \"Direct link to resolver-implementation-with-nexus-2\")\n\nThat's because you're still missing the _resolver_ implementation for that query. You can add the resolver with Nexus as follows:\n\n```\nconst Mutation = mutationType({  definition(t) {    // ... previous mutations    t.field('updateBio', {      type: 'User',      args: {        userUniqueInput: arg({          type: 'UserUniqueInput',          nullable: false        }),        bio: stringArg()      },      resolve: (_, args, context) => {        return context.prisma.user.update({          where: {            id: args.userUniqueInput?.id,            email: args.userUniqueInput?.email          },          data: {            profile: {              create: { bio: args.bio }            }          }        })      }    }  }})\n```\n\nIf you're re-sending the same query from before, you'll find that it now returns actual data instead of `null`.\n\n#### 3.2.5. Migrate the `addPostToCategories(postId: String!, categoryIds: [String!]!): Post` mutation[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#325-migrate-the-addposttocategoriespostid-string-categoryids-string-post-mutation \"Direct link to 325-migrate-the-addposttocategoriespostid-string-categoryids-string-post-mutation\")\n\nIn our sample app, the `addPostToCategories` mutation is defined and implemented as follows.\n\n##### SDL schema definition with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#sdl-schema-definition-with-prisma-binding-6 \"Direct link to sdl-schema-definition-with-prisma-binding-6\")\n\n```\ntype Mutation {  addPostToCategories(postId: String!, categoryIds: [String!]!): Post  # ... other mutations}\n```\n\n##### Resolver implementation with `prisma-binding`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-prisma-binding-6 \"Direct link to resolver-implementation-with-prisma-binding-6\")\n\n```\nconst resolvers = {  Mutation: {    addPostToCategories: (_, args, context, info) => {      const ids = args.categoryIds.map((id) => ({ id }))      return context.prisma.mutation.updatePost(        {          data: {            categories: {              connect: ids,            },          },          where: {            id: args.postId,          },        },        info      )    },    // ... other resolvers  },}\n```\n\n##### Code-first schema definition with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#code-first-schema-definition-with-nexus-4 \"Direct link to code-first-schema-definition-with-nexus-4\")\n\nTo get the same behavior with Nexus, you'll need to add a `t.field` definition to the `mutationType`:\n\n```\nconst Mutation = mutationType({  definition(t) {    // ... mutations from before    t.field('addPostToCategories', {      type: 'Post',      args: {        postId: stringArg({ nullable: false }),        categoryIds: stringArg({          list: true,          nullable: false,        }),      },    })  },})\n```\n\nIf you look at the generated SDL version of your GraphQL schema inside `schema.graphql`, you'll notice that this has added the correct _definition_ to your GraphQL schema already:\n\n```\ntype Mutation {  createUser(data: UserCreateInput!): User!  createDraft(title: String!, content: String, authorId: String!): Post!  updateBio(bio: String, userUniqueInput: UserUniqueInput!): User  addPostToCategories(postId: String!, categoryIds: [String!]!): Post}\n```\n\nYou can even send the respective query via the GraphQL Playground already:\n\n```\nmutation {  addPostToCategories(    postId: \"__AUTHOR_ID__\"    categoryIds: [\"__CATEGORY_ID_1__\", \"__CATEGORY_ID_2__\"]  ) {    id    title    categories {      id      name    }  }}\n```\n\nHowever, because the resolver is not yet implemented, nothing will be updated in the database and you will not get any data back in the response.\n\n##### Resolver implementation with `nexus`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#resolver-implementation-with-nexus-3 \"Direct link to resolver-implementation-with-nexus-3\")\n\nThat's because you're still missing the _resolver_ implementation for that query. You can add the resolver with Nexus as follows:\n\n```\nconst Mutation = mutationType({  definition(t) {    // ... mutations from before    t.field('addPostToCategories', {      type: 'Post',      args: {        postId: stringArg({ nullable: false }),        categoryIds: stringArg({          list: true,          nullable: false,        }),      },      resolve: (_, args, context) => {        const ids = args.categoryIds.map((id) => ({ id }))        return context.prisma.post.update({          where: {            id: args.postId,          },          data: {            categories: { connect: ids },          },        })      },    })  },})\n```\n\nIf you're re-sending the same query from before, you'll find that it now returns actual data instead of `null`.\n\n## 4\\. Cleaning up[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#4-cleaning-up \"Direct link to 4. Cleaning up\")\n\nSince the entire app has now been upgrade to Prisma ORM 2.0 and Nexus, you can delete all unnecessary files and remove the no longer needed dependencies.\n\n### 4.1. Clean up npm dependencies[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#41-clean-up-npm-dependencies \"Direct link to 4.1. Clean up npm dependencies\")\n\nYou can start by removing npm dependencies that were related to the Prisma 1 setup:\n\n```\nnpm uninstall graphql-cli prisma-binding prisma1\n```\n\n### 4.2. Delete unused files[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#42-delete-unused-files \"Direct link to 4.2. Delete unused files\")\n\nNext, delete the files of your Prisma 1 setup:\n\n```\nrm prisma1/datamodel.prisma prisma1/prisma.yml\n```\n\nYou can also delete any remaining `.js` files, the old `schema.graphql` and `prisma.graphql` files.\n\n### 4.3. Stop the Prisma ORM server[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus#43-stop-the-prisma-orm-server \"Direct link to 4.3. Stop the Prisma ORM server\")\n\nFinally, you can stop running your Prisma ORM server.",
    "title": "Upgrading from Prisma 1 with prisma-binding to Nexus | Prisma Documentation",
    "description": "Learn how to upgrade existing Prisma 1 projects with prisma-binding to Prisma ORM 2.0 and Nexus.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes",
    "markdown": "# How to handle removal of rejectOnNotFound in Prisma ORM 5\n\n## rejectOnNotFound changes\n\nAs of Prisma ORM version 5.0.0, the deprecated parameter `rejectOnNotFound` has been removed. Depending on if your project used `rejectOnNotFound` per query or globally, there will be be different ways of updating your code.\n\nIf you are using the `rejectOnNotFound` parameter on a per-query basis, then follow our steps for [updating your code at the query level](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#replacing-rejectonnotfound-enabled-at-the-query-level).\n\nIf instead you have set up the `rejectOnNotFound` parameter at the client level, you will need to follow [the steps for updating your code at the client level](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#replacing-rejectonnotfound-enabled-at-the-client-level).\n\nA full list of Prisma ORM 5 changes can be found [in our release notes](https://github.com/prisma/prisma/releases/tag/5.0.0).\n\n## Replacing `rejectOnNotFound` enabled at the query level[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#replacing-rejectonnotfound-enabled-at-the-query-level \"Direct link to replacing-rejectonnotfound-enabled-at-the-query-level\")\n\nIf you previously enabled `rejectOnNotFound` on a per-query basis, you will need to replace your usage at the _query level_. You can use our `*OrThrow` query variants, `findFirstOrThrow` or `findUniqueOrThrow` instead of supplying the parameter to `findFirst` and `findUnique()`.\n\n### Simple `rejectOnNotFound` usage[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#simple-rejectonnotfound-usage \"Direct link to simple-rejectonnotfound-usage\")\n\nThe following example:\n\n```\nprisma.user.findFirst({  where: { name: 'Alice' },  rejectOnNotFound: true,})\n```\n\nneeds to be converted to:\n\n```\nprisma.user.findFirstOrThrow({  where: { name: 'Alice' },})\n```\n\n### `rejectOnNotFound` usage with custom error handler[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#rejectonnotfound-usage-with-custom-error-handler \"Direct link to rejectonnotfound-usage-with-custom-error-handler\")\n\nIf you use a custom error handler like the following:\n\n```\nprisma.user.findFirst({  where: { name: 'Alice' },  rejectOnNotFound: () => new UserNotFoundError(),})\n```\n\nYou will need to modify your code to handle the errors thrown by `...OrThrow` methods.\n\n```\ntry {  await prisma.user.findFirstOrThrow({    where: { name: 'Alice' },  })} catch (err) {  if (err.code === 'P2025') {    throw new UserNotFoundError()  }  throw err}\n```\n\nIf your error handler is used in multiple places, you can also create a reusable error adapter which could then be used within a `.catch()` called on your function.\n\n```\nconst adaptError = (customThrowFn) => (error) => {  if (error.code === 'P2025') {    throw customThrowFn()  }  throw error}const user = await prisma.user.findFirstOrThrow({  where: { name: 'Alice' },}).catch(adaptError(() => new MyCustomError())\n```\n\n## Replacing `rejectOnNotFound` enabled at the Client level[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#replacing-rejectonnotfound-enabled-at-the-client-level \"Direct link to replacing-rejectonnotfound-enabled-at-the-client-level\")\n\n### `rejectOnNotFound` via Prisma Client Constructor[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#rejectonnotfound-via-prisma-client-constructor \"Direct link to rejectonnotfound-via-prisma-client-constructor\")\n\nIf you previously enabled `rejectOnNotFound` globally via configuration in the Prisma Client constructor, like in these examples:\n\n```\n// Example 1const prisma = new PrismaClient({  rejectOnNotFound: true,})// Example 2const prisma = new PrismaClient({  rejectOnNotFound: {    findUnique: true,  },})\n```\n\nYou will need to update your codebase to use `findUniqueOrThrow` and `findFirstOrThrow` instead of `findUnique()` and `findFirst`, depending on which calls you would like to throw.\n\n### `rejectOnNotFound` via Prisma Client Constructor with custom error handler[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#rejectonnotfound-via-prisma-client-constructor-with-custom-error-handler \"Direct link to rejectonnotfound-via-prisma-client-constructor-with-custom-error-handler\")\n\nIf instead you use a custom error handler with the `rejectOnNotFound` property, like these examples:\n\n```\n// Example 3const prisma = new PrismaClient({  rejectOnNotFound: (err) => new Error('something'),})// Example 4const prisma = new PrismaClient({  rejectOnNotFound: {    findUnique: (err) => new Error('something'),  },})// Example 5const prisma = new PrismaClient({  rejectOnNotFound: {    findFirst: {      User: (err) => new Error('User error'),      Post: (err) => new Error('Post error'),    },    findUnique: {      User: (err) => new Error('User error'),      Post: (err) => new Error('Post error'),    },  },})\n```\n\nYou will need to update your method usage to `...OrThrow` and then use a [Client Extension](https://www.prisma.io/docs/orm/prisma-client/client-extensions) in order to get the same behavior.\n\nAs an example, the following extension would give the same behavior in Prisma ORM 5 that `Example 5` gave in Prisma ORM 4 and lower.\n\n```\nimport { PrismaClient } from '@prisma/client';const customErrorFunc = async (model, query, args) => {  try {    await query(args)  } catch (error: any) {    if (error.code === 'P2025') {      throw new Error(`${model} error`)    }    throw error;  }}const prisma = (new PrismaClient()).$extends({  query: {    user: {      async findFirstOrThrow({ model, query, args }) {        return await customErrorFunc(model, query, args)      },      async findUniqueOrThrow({ model, query, args }) {        return await customErrorFunc(model, query, args)      },    },    post: {      async findFirstOrThrow({ model, query, args }) {        return await customErrorFunc(model, query, args)      },      async findUniqueOrThrow({ model, query, args }) {        return await customErrorFunc(model, query, args)      },    },  },})\n```",
    "title": "How to handle removal of rejectOnNotFound in Prisma ORM 5 | Prisma Documentation",
    "description": "Sub-guide explaining how to update your code due to the removal of rejectOnNotFound in Prisma ORM 5",
    "languageCode": "en"
  }
]